  query+="delete from t_user_billing_queue_error where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_gamertag_history where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_licenses where bi_user_id="+(long)puid+"\n";
            query+="delete from t_user_per_client_type_data where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_per_service_type_data where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_ppv_licenses where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_video_licenses_console where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_video_licenses_pc where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_web_mapping where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_users_domains where bi_xuid="+(long)puid+"\n";
            UodbWS.ExecuteSQLNonQuery(query, null, timeoutInS);

            query="delete from t_user_machine_history where bi_user_puid="+(long)puid+"\n";
            UodbWS.ExecuteSQLNonQuery(query, null, timeoutInS);

            if (Exists)
            {
                query="delete from t_user_keys where vc_gamertag='"+Gamertag+"'\n";
                query+="delete from t_xenon_user_keys where vc_gamertag='"+Gamertag+"'\n";
                query+="delete from t_user_names where vc_gamertag='"+Gamertag+"'\n";
                UodbWS.ExecuteSQLNonQuery(query, null, timeoutInS);
            }
            else
            {
                query="delete from t_user_keys where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)puid+")\n";
                query+="delete from t_xenon_user_keys where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)puid+")\n";
                query+="delete from t_user_names where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)puid+")\n";
                UodbWS.ExecuteSQLNonQuery(query, null, timeoutInS);
            }

            UodbWS.ExecuteSQLNonQuery("delete from t_users where bi_user_puid="+(long)puid, null, timeoutInS);
        }

        /// <summary>
        /// Completely deletes the user's Xbox360 key entry.
        /// </summary>
        public void RemoveXenonKey()
        {
            if (Exists)
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_xenon_user_keys where vc_gamertag='"+EscapeString(Gamertag)+"'", null);
            }
        }

        //
        // Todo: All of these Sets should be depricated
        //
        /// <summary>
        /// Set's the users xenon key, which is 16 bytes long.
        /// </summary>
        public void SetXenonPassword(byte[] password)
        {
            UodbWS.ExecuteSQLNonQuery("update t_xenon_user_keys set bin_key=0x" + Hexer.tohex(password) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Set's the user's xenon key's ppa2 entry, which is 8 bytes long.
        /// </summary>
        public void SetXenonPPA2(byte[] ppa2)
        {
            UodbWS.ExecuteSQLNonQuery("update t_xenon_user_keys set bin_ppa2=0x" + Hexer.tohex(ppa2) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Set's the user's xenon key's sppa1 entry, which is 20 bytes long.
        /// </summary>
        public void SetXenonSPPA1(byte[] sppa1)
        {
            UodbWS.ExecuteSQLNonQuery("update t_xenon_user_keys set bin_sppa1=0x" + Hexer.tohex(sppa1) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Completely deletes the user's Xbox1 key entry.
        /// </summary>
        public void RemoveXbox1Key()
        {
            if (Exists)
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_user_keys where vc_gamertag='"+EscapeString(Gamertag)+"'", null);
            }
        }

        /// <summary>
        /// Set's the users xbox1 key, which is 16 bytes long.
        /// </summary>
        public void SetXbox1Password(byte[] password)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_key=0x" + Hexer.tohex(password) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Set's the user's xbox1 key's ppa2 entry, which is 8 bytes long.
        /// </summary>
        public void SetXbox1PPA2(byte[] ppa2)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_ppa2=0x" + Hexer.tohex(ppa2) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Set's the user's xbox1 key's sppa1 entry, which is 20 bytes long.
        /// </summary>
        public void SetXbox1SPPA1(byte[] sppa1)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_sppa1=0x" + Hexer.tohex(sppa1) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
        }

        /// <summary>
        /// Removes all passports that are linked to this user.
        /// </summary>
        public void UnlinkAllPassports()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_user_passport_puids where bi_user_puid="+(long)puid, null);
        }

        /// <summary>
        /// Links a passport puid to this user (if not already linked).
        /// This is required before a user can be used for the Askdc's Panorama authentication.
        /// </summary>
        public void LinkPassport(ulong passportPuid)
        {
            if (IsLinkedToPassport(passportPuid))
            {
                return;
            }

            OwnerPassportPuid = (long)passportPuid;
            UserPassportPuid = (long)passportPuid;         

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(passportPuid);
                int bucket=UodbWS.GetHashBucket(passportPuid);
                ws.CommandSql="insert into t_user_passport_puids (bi_user_passport_puid, bi_user_puid, si_hash_bucket) values ("+(long)passportPuid+", "+(long)puid+", "+bucket+")";
                ws.ExecuteNonQuery();
            }            
        }

        /// <summary>
        /// Returns whether the user is currently linked to a specific passport.
        /// </summary>
        public bool IsLinkedToPassport(ulong passportPuid)
        {
            object ret=UodbWS.ExecuteSQLScalar("select count(*) from t_user_passport_puids where bi_user_passport_puid="+(long)passportPuid+" and bi_user_puid="+(long)puid, passportPuid);
            int count=(int)ret;
            return count!=0;
        }

        /// <summary>
        /// Retrieves all privileges specially granted to a user.
        /// </summary>
        public byte[] GetAllPrivilegeGrants()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql="select ti_privilege_id from t_user_privilege_grants where bi_user_puid="+(long)puid;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all privilege grants from a user.
        /// </summary>
        public void RemoveAllPrivilegeGrants()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_user_privilege_grants where bi_user_puid="+(long)puid, puid);
        }

        /// <summary>
        /// Adds a special privilege grant to a user, if they do not already have it.
        /// </summary>
        public void AddPrivilegeGrant(byte privilegeId)
        {
            string query="if (0=(select count(ti_privilege_id) from t_user_privilege_grants where bi_user_puid="+(long)puid+" and ti_privilege_id="+privilegeId+")) ";
            query+="begin insert into t_user_privilege_grants (bi_user_puid, ti_privilege_id, vc_grantor, si_hash_bucket) values ("+(long)puid+", "+(int)privilegeId+", 'STF Test', "+(int)HashBucket+") end";
            UodbWS.ExecuteSQLNonQuery(query, puid);
        }

        /// <summary>
        /// Adds a lost of special privilege grants to a user, if they do not already have them.
        /// </summary>
        public void AddPrivilegeGrants(byte []privilegeIds)
        {
            foreach (byte b in privilegeIds)
            {
                AddPrivilegeGrant(b);
            }
        }

        /// <summary>
        /// Retrieves a list of all privileges that a user is specially restricted from.
        /// </summary>
        public byte[] GetAllPrivilegeRestrictions()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql="select ti_privilege_id from t_user_privilege_restrictions where bi_user_puid="+(long)puid;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all privilege restrictions from a user.
        /// </summary>
        public void RemoveAllPrivilegeRestrictions()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_user_privilege_restrictions where bi_user_puid="+(long)puid, puid);
        }

        /// <summary>
        /// Adds a special privilege restriction to a user, if they do not already have it.
        /// </summary>
        public void AddPrivilegeRestriction(byte privilegeId)
        {
            string query="if (0=(select count(ti_privilege_id) from t_user_privilege_restrictions where bi_user_puid="+(long)puid+" and ti_privilege_id="+privilegeId+")) ";
            query+="begin insert into t_user_privilege_restrictions (bi_user_puid, ti_privilege_id, vc_restrictor, si_hash_bucket) values ("+(long)puid+", "+(int)privilegeId+", 'STF Test', "+(int)HashBucket+") end";
            UodbWS.ExecuteSQLNonQuery(query, puid);
        }

        /// <summary>
        /// Adds a list of special privilege restrictions to a user, if they do not already have them.
        /// </summary>
        public void AddPrivilegeRestrictions(byte []privilegeIds)
        {
            foreach (byte b in privilegeIds)
            {
                AddPrivilegeRestriction(b);
            }
        }

        /// <summary>
        /// Adds a purchased license to a user.  TODO: If they already have the license this will throw.
        /// </summary>
        public void AddPurchasedLicense(ulong offerId, ulong machineId)
        {
            UodbWS.ExecuteSQLNonQuery("insert into t_user_licenses (bi_user_id,    bi_offer_id,      bi_machine_id,      si_hash_bucket) values ("
                                                                   +(long)puid+","+(long)offerId+","+(long)machineId+","+HashBucket+")", puid);

            //TODO: we should be looking up the real guid here... not using random ones.
            UserCommercedbWS.ExecuteSQLNonQuery("insert into t_dmp_purchase_transactions (bi_user_puid,  bi_machine_puid,    uid_tracking_guid,        i_status_id, vc_confirmation_id, " +
                                       "i_hresult, vc_error_code, vc_error_xml, dt_transaction_start, dt_transaction_end, vc_alternate_url, si_hash_bucket, "+
                                       "i_purchase_type_id, vc_ip_address, ti_purchase_origin, i_purchasing_title_id ) values ("+
                                                                                (long)puid+","+(long)machineId+",'"+System.Guid.NewGuid()+"',2,           '12345',"+
                                       "0,         '0',           ' ',          getutcdate(),         getutcdate(),       '/',            "+HashBucket+","+
                                       "1,                  '1.2.3.4',     1,  0" +
                                       ")", puid);

            UserCommercedbWS.ExecuteSQLNonQuery("insert into t_user_offer_instance_purchases (bi_user_puid,  bi_machine_puid, uid_offer_instance_id, " +
                                       "uid_offer_id,                i_offer_media_type_id, dt_purchased,   si_hash_bucket, i_store_id, dt_Change_datetime) values ("+
                                                                                    (long)puid+","+(long)machineId+",'"+System.Guid.NewGuid()+"', "+
                                       "'"+System.Guid.NewGuid()+"', 23,                    getutcdate(), "+HashBucket+",   1,          getutcdate())", puid);

        }

        /// <summary>
        /// Removes all subscriptions from a user, optionally not removing base subscriptions (which are required to sign in)
        /// </summary>
        public void RemoveAllSubscriptions(bool removeBaseSubscriptions)
        {
            if (removeBaseSubscriptions)
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_subscriptions where bi_primary_puid="+(long)puid, puid);
            }
            else
            {
                //TODO: Remove checking bi_offer_id once we switch over to the new guid family mapping system by default
                UodbWS.ExecuteSQLNonQuery("delete from t_subscriptions where bi_primary_puid="+(long)puid+" and uid_catalog_offerinstance_id not in (select distinct guid_offer_instance from t_subscription_family_mapping as tsfm inner join t_subscription_family as tsf on tsfm.guid_subscription_family=tsf.guid_subscription_family where si_subscription_type!=1) and bi_offer_id not in (select bi_offer_id from t_base_offers)", puid);
            }
        }

        /// <summary>
        /// Adds a subscription to a user.  Obsolete.
        /// </summary>
        public void AddSubscription(ulong offerId, uint instance, string serviceInstance, System.DateTime startDate, System.DateTime endDate, uint status, uint flags)
        {
            Global.RO.Warn("UserEditor.AddSubscription using only a 64-bit offerId will be obsolete soon and will no longer work correctly after the subscription family changes.  Call the version that takes the offer guid instead.");
            UodbWS.ExecuteSQLNonQuery("insert into t_subscriptions (bi_primary_puid, bi_offer_id, i_instances, vc_svc_instance_id, i_puid_is_machine, dt_start_date, dt_end_date, i_subscription_status_id, i_transaction_flags, si_hash_bucket) values"+
                "("+(long)puid+", "+(long)offerId+", "+(int)instance+", '"+EscapeString(serviceInstance)+"', 0, '"+startDate+"', '"+endDate+"', "+(int)status+", "+(int)flags+", "+(int)HashBucket+")",
                puid);
        }

        /// <summary>
        /// Adds a valid non-expired subscription to a user using some sane defaults.  If they already have an exact pk match, this will throw.  Obsolete.
        /// </summary>
        public void AddSubscription(ulong offerId)
        {
            Global.RO.Warn("UserEditor.AddSubscription using only a 64-bit offerId will be obsolete soon and will no longer work correctly after the subscription family changes.  Call the version that takes the offer guid instead.");
            AddSubscription(offerId, 1, "StfTest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 1, 1);
        }

        /// <summary> Adds or updates a subscription to a user. </summary>
        public void AddSubscription(System.Guid offerInstanceGuid, System.Guid offerGuid, ulong oldOfferId, uint instance, string serviceInstance, System.DateTime startDate, System.DateTime endDate, uint status, uint flags, System.Nullable<ulong> subscriptionOwnerPuid)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert("t_subscriptions",
                                                               new string[]{"bi_primary_puid", "bi_offer_id", "i_instances", "vc_svc_instance_id", "i_puid_is_machine", "dt_start_date", "dt_end_date", "i_subscription_status_id", "i_transaction_flags", "si_hash_bucket",  "uid_catalog_offerinstance_id", "uid_catalog_offerid", "bi_subscription_owner_puid"},
                                                               new object[]{puid,              oldOfferId,    instance,      serviceInstance,      0,                   startDate,       endDate,       status,                     flags,                 (short)HashBucket, offerInstanceGuid,              offerGuid,             subscriptionOwnerPuid},
                                                               new string[]{"bi_primary_puid", "bi_offer_id", "i_instances", "vc_svc_instance_id", "dt_start_date"}
                                                               );
            UodbWS.ExecuteSQLNonQuery(query, puid);
        }

        /// <summary> Adds or updates a valid non-expired subscription to a user using some sane defaults. </summary>
        public void AddSubscription(System.Guid offerInstanceGuid, System.Guid offerGuid, ulong oldOfferId)
        {
            AddSubscription(offerInstanceGuid, offerGuid, oldOfferId, 1, "StfTest", System.DateTime.UtcNow, new System.DateTime(9999, 12, 30), 1, 1, null);
        }

        /// <summary> Adds a base subscription to a user for a specific type.  This is no different than AddSubscription, except you don't need to know the offer id </summary>
        public void AddBaseSubscription(BaseSubscriptions subType)
        {
            AddBaseSubscription(subType, 1, "StfTest", System.DateTime.UtcNow-new System.TimeSpan(0, 5, 0), new System.DateTime(9999, 12, 30), 1, 1, null);
        }

        /// <summary> Adds a base subscription to a user for a specific type.  This is no different than AddSubscription, except you don't need to know the offer id </summary>
        public void AddBaseSubscription(BaseSubscriptions subType, uint instance, string serviceInstance, System.DateTime startDate, System.DateTime endDate, uint status, uint flags, System.Nullable<ulong> subscriptionOwnerPuid)
        {
            switch (subType)
            {
                case BaseSubscriptions.Xbox1Online:
                    AddSubscription(new System.Guid("80000018-0005-4002-8000-0000FFFE07D1"), new System.Guid("80000018-0000-4000-8000-0000FFFE07D1"), 0xFFFE000080000008, instance, serviceInstance, startDate, endDate, status, flags, subscriptionOwnerPuid); //this is NOT a matching offer guid... but it should behave equivilently in the new subscription family system
                    break;

                case BaseSubscriptions.Xbox360New:
                    // don't actually add one, as New is supposed to be base subscriptionless
                    break;

                case BaseSubscriptions.Xbox360Silver:
                    AddSubscription(new System.Guid("80000011-0067-4003-8000-0000FFFE07D1"), new System.Guid("80000011-0000-4000-8000-0000FFFE07D1"), 0xFFFE07D180000011, instance, serviceInstance, startDate, endDate, status, flags, subscriptionOwnerPuid);
                    break;

                case BaseSubscriptions.Xbox360Gold:
                    AddSubscription(new System.Guid("8000000A-0067-4003-8000-0000FFFE07D1"), new System.Guid("8000000A-0000-4000-8000-0000FFFE07D1"), 0xFFFE07D18000000A, instance, serviceInstance, startDate, endDate, status, flags, subscriptionOwnerPuid);
                    break;

                case BaseSubscriptions.Xbox360FamilyGold:
                    AddSubscription(new System.Guid("8000004A-0067-4003-8000-0000FFFE07D1"), new System.Guid("8000004A-0000-4000-8000-0000FFFE07D1"), 0xFFFE07D18000004A, instance, serviceInstance, startDate, endDate, status, flags, subscriptionOwnerPuid);
                    break;

                default:
                    throw new System.Exception("Unhandled BaseSubscriptions type: "+subType);
            }
        }

        /// <summary>
        /// Set's the users trust rating stats for a specific title.
        /// </summary>
        public void SetUserTitleTrustRating(uint titleId, float c1, float c2, float c3, float c4, float c5, float c6, float c7, float c8, float c9,
                                            uint sessionsTotal, uint sessionsDisconnect, uint compsTotal, uint compsNoShow,
                                            uint sessionBase, uint sessionXbox, uint sessionSeconds, uint sessionFFA)
        {
            string query="delete from t_user_trust_ratings where bi_user_puid="+(long)puid+" and i_title_id="+(int)titleId+" \n";
            query+="insert into t_user_trust_ratings (bi_user_puid, i_title_id, "+
                "f_C1_SuccessfulSessionCount, f_C2_MinoritySessionCount, f_C3_FailedSessionCount, f_C4_ProblematicSessionCount, f_C5_UDPReportSessionCount, "+
                "f_C6_DisconnectCount, f_C7_Type1SuspiciousCount, f_C8_Type2SuspiciousCount, f_C9_Type3SuspiciousCount, "+
                "i_TotalSessions, i_TotalSessionDisconnects, i_TotalCompetitions, i_TotalCompetitionNoShows, i_SessionBase, "+
                "i_SessionXboxCount, i_SessionSeconds, i_SessionFreeForAll, si_hash_bucket) values\n ("+
                (long)puid+", "+(int)titleId+", "+
                c1+", "+c2+", "+c3+", "+c4+", "+c5+", "+c6+", "+c7+", "+c8+", "+c9+", "+
                (int)sessionsTotal+", "+(int)sessionsDisconnect+", "+(int)compsTotal+", "+(int)compsNoShow+", "+(int)sessionBase+", "+
                (int)sessionXbox+", "+(int)sessionSeconds+", "+(int)sessionFFA+", "+(int)HashBucket+
                  ")";
            UodbWS.ExecuteSQLNonQuery(query, puid);
        }

        /// <summary>
        /// Removes all privilege grants from a user.
        /// </summary>
        public void RemoveAllPerServiceTypeData ()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_user_per_service_type_data where bi_user_puid=" + (long)puid, puid);
        }

        /// <summary>
        /// Adds per service type data to a user.
        /// </summary>
        public void AddPerServiceTypeDate (byte serviceType, DateTime acceptedTOS, DateTime provisioned, DateTime suspendedUntil, 
            DateTime? lastSuspended, int timesSuspended, DateTime? lastWebActivity)
        {
            string query = String.Format(@"
Insert into t_user_per_service_type_data
([bi_user_puid],[ti_service_type],[dt_accepted_tos],[dt_provisioned],
[dt_suspended_until],[dt_last_suspended],[i_times_suspended],[dt_last_web_activity],
[si_hash_bucket])
values
({0},{1},'{2}','{3}','{4}',{5},{6},{7},{8})
",
                (long)puid, serviceType, acceptedTOS, provisioned,
                suspendedUntil, (lastSuspended == null ? "NULL" : "'" + lastSuspended.Value.ToString() + "'"),
                timesSuspended, (lastWebActivity == null ? "NULL" : "'" + lastWebActivity.Value.ToString() + "'"),
                HashBucket);
            UodbWS.ExecuteSQLNonQuery(query, puid);
        }

        #endregion
    };

    /// <summary>
    /// Types to be passed to UserEditor's AddBaseSubscription.
    /// </summary>
    public enum BaseSubscriptions
    {
        Xbox1Online,       //tier 6 renewal?
        Xbox360New,        //tier 0
        Xbox360Silver,     //tier 3
        Xbox360Gold,       //tier 6
        Xbox360FamilyGold  //tier 9
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\UserMachineHistoryEditor.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using System.Net;

namespace ServerTestFramework.Database
{
    public class UserMachineHistoryEditor : EditorCommon
    {
        private ulong userPuid;
        public ulong UserPuid
        {
            get { return userPuid; }
        }

        private ulong machinePuid;
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }

        /// <summary> Whether the row actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                String sql = "select count(0) from t_user_machine_history where bi_user_puid="+(long)userPuid+" and bi_machine_puid="+(long)machinePuid;
                bool exists = (int)UodbWS.ExecuteSQLScalar(sql, userPuid) != 0;
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        public DateTime FirstSeen
        {
            get { return GetGenericHistoryProperty<DateTime>("d_first_seen"); }
            set { SetGenericHistoryProperty("d_first_seen", value); }
        }

        public DateTime LastSeen
        {
            get { return GetGenericHistoryProperty<DateTime>("d_last_seen"); }
            set { SetGenericHistoryProperty("d_last_seen", value); }
        }

        public Int32 DaysSeen
        {
            get { return GetGenericHistoryProperty<Int32>("i_days_seen"); }
            set { SetGenericHistoryProperty("i_days_seen", value); }
        }

        public DateTime LastChange
        {
            get { return GetGenericHistoryProperty<DateTime>("dt_change_datetime"); }
        }

        public string IPAddress
        {
            get { return GetGenericNullableStringHistoryProperty("vc_ip_address"); }
            set { SetGenericNullableHistoryProperty("vc_ip_address", value); }
        }

        public System.DateTime? FirstSignin
        {
            get { return GetGenericNullableHistoryProperty<DateTime>("dt_first_signin"); }
            set { SetGenericNullableHistoryProperty("dt_first_signin", value); }
        }

        public System.DateTime? LastSignin
        {
            get { return GetGenericNullableHistoryProperty<DateTime>("dt_last_signin"); }
            set { SetGenericNullableHistoryProperty("dt_last_signin", value); }
        }

        public System.DateTime? LastSignout
        {
            get { return GetGenericNullableHistoryProperty<DateTime>("dt_last_signout"); }
            set { SetGenericNullableHistoryProperty("dt_last_signout", value); }
        }

        public string FriendlyName
        {
            get { return GetGenericNullableStringHistoryProperty("vc_friendly_name"); }
            set { SetGenericNullableHistoryProperty("vc_friendly_name", value); }
        }

        public int TrustLevel
        {
            get { return GetGenericHistoryProperty<int>("i_trust_level"); }
            set { SetGenericHistoryProperty("i_trust_level", value); }
        }

        public short HashBucket
        {
            get { return GetGenericHistoryProperty<short>("si_hash_bucket"); }
            set { SetGenericHistoryProperty("si_hash_bucket", value); }
        }

        // -

        public static UserMachineHistoryEditor FromId(ulong userPuid, ulong machinePuid)
        {
            UserMachineHistoryEditor editor = new UserMachineHistoryEditor();
            editor.userPuid = userPuid;
            editor.machinePuid = machinePuid;

            return editor;
        }

        public static UserMachineHistoryEditor[] FromUserId(ulong userPuid)
        {
            List<UserMachineHistoryEditor> editorList = new List<UserMachineHistoryEditor>();

            using (WSClient ws = new WSClient(xonline.common.config.ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = "select bi_machine_puid from t_user_machine_history where bi_user_puid=" + (long)userPuid;

                using (WstDataReader reader = ws.Execute())
                {
                    while (reader.Read())
                    {
                        ulong machinePuid = (ulong)(long)reader[0];
                        editorList.Add(UserMachineHistoryEditor.FromId(userPuid, machinePuid));
                    }
                }
            }

            return editorList.ToArray();
        }

        public static UserMachineHistoryEditor[] FromMachineId(ulong machinePuid)
        {
            List<UserMachineHistoryEditor> editorList=new List<UserMachineHistoryEditor>();

            using (WSClient ws=new WSClient(xonline.common.config.ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    ws.PartitionType=WstPartitionType.Physical;
                    ws.PhysicalPartition=p;
                    ws.CommandSql="select bi_user_puid from t_user_machine_history where bi_machine_puid="+(long)machinePuid;

                    using (WstDataReader reader=ws.Execute())
                    {
                        while (reader.Read())
                        {
                            ulong userPuid=(ulong)(long)reader[0];
                            editorList.Add(UserMachineHistoryEditor.FromId(userPuid, machinePuid));
                        }
                    }
                }
            }

            return editorList.ToArray();
        }

        public static UserMachineHistoryEditor CreateOrUseExisting(ulong userPuid, ulong machinePuid)
        {
            UserMachineHistoryEditor editor = UserMachineHistoryEditor.FromId(userPuid, machinePuid);
            if (editor.Exists)
            {
                return editor;
            }

            // Use the local computer IP to populate vc_ip_address
            string localIp = null;
            IPAddress[] ipAddresses = Dns.GetHostAddresses(Dns.GetHostName());
            foreach (IPAddress ipAddress in ipAddresses)
            {
                if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    localIp = ipAddress.ToString();
                    break;
                }
            }

            // We have to get the Hash Bucket :(
            UserEditor user = UserEditor.FromPuid(userPuid);

            //create it
            String query = QueryGenerator.GenerateUpdateOrInsert("t_user_machine_history",
                new String[] { "bi_user_puid", "bi_machine_puid", "d_first_seen", "d_last_seen", "i_days_seen", "dt_change_datetime", "si_hash_bucket", "vc_ip_address"},
                new Object[] { userPuid,       machinePuid,       DateTime.Now,   DateTime.Now,  1,             DateTime.Now,         user.HashBucket,  localIp},
                new String[] { "bi_user_puid", "bi_machine_puid" });

            UodbWS.ExecuteSQLNonQuery(query, userPuid);

            return editor;
        }

        public static void ObliterateUserHistory(ulong puid)
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_user_machine_history where bi_user_puid="+(long)puid, puid);
        }

        // -

        /// <summary> Generic implementation of returning a property from an site (or cache if able). </summary>
        private TypeOfProperty GetGenericHistoryProperty<TypeOfProperty>(string columnName)
        {
            if (HasCachedEntry(columnName))
            {
                return (TypeOfProperty)cache[columnName];
            }

            String sql = String.Format("select {0} from t_user_machine_history where bi_user_puid={1} and bi_machine_puid = {2}",
                columnName, QueryGenerator.EvaluateObject(userPuid), QueryGenerator.EvaluateObject(machinePuid));

            object ret = UodbWS.ExecuteSQLScalar(sql, userPuid);

            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_user_machine_history", "bi_user_puid, bi_machine_puid", (long)userPuid + ", " + (long)machinePuid);
        }

        /// <summary> Generic implementation of setting a property in an site.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericHistoryProperty<TypeOfProperty>(string columnName, TypeOfProperty value)
        {
            String sql = String.Format("update t_user_machine_history set {0}={1} where bi_user_puid={2} and bi_machine_puid={3}",
                columnName, QueryGenerator.EvaluateObject(value), QueryGenerator.EvaluateObject(userPuid), QueryGenerator.EvaluateObject(machinePuid));
            UodbWS.ExecuteSQLNonQuery(sql, userPuid);
            SetCacheEntry(columnName, value);
        }

        /// <summary> Generic implementation of returning a property from a table hashed on puid (or cache if able), for columns that may be null. </summary>
        private System.Nullable<TypeOfProperty> GetGenericNullableHistoryProperty<TypeOfProperty>(string columnName)
            where TypeOfProperty:struct
        {
            if (HasCachedEntry(columnName))
            {
                return (TypeOfProperty)cache[columnName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_user_machine_history where bi_user_puid="+(long)userPuid+" and bi_machine_puid="+(long)machinePuid, userPuid);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return null;
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_user_machine_history", columnName, userPuid.ToString());
        }

        /// <summary> Generic implementation of returning a property from a table hashed on puid (or cache if able), for columns that may be null. </summary>
        private string GetGenericNullableStringHistoryProperty(string columnName)
        {
            if (HasCachedEntry(columnName))
            {
                return (string)cache[columnName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_user_machine_history where bi_user_puid="+(long)userPuid+" and bi_machine_puid="+(long)machinePuid, userPuid);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return null;
                }

                string val=(string)ret;
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_user_machine_history", columnName, userPuid.ToString());
        }

        /// <summary> Generic implementation of setting a property in a table hashed on puid for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null. </summary>
        private void SetGenericNullableHistoryProperty(string columnName, object value)
        {
            if (value==null)
            {
                UodbWS.ExecuteSQLNonQuery("update t_user_machine_history set "+columnName+"=null where bi_user_puid="+(long)userPuid+" and bi_machine_puid="+(long)machinePuid, userPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update t_user_machine_history set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_user_puid="+(long)userPuid+" and bi_machine_puid="+(long)machinePuid, userPuid);
            }

            SetCacheEntry(columnName, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\UserPassportHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class UserPassportHistoryEditor
    {
        /// <summary> User Puid.  This is the only non-cached information we store about the user's Passport history. </summary>
        public ulong UserPuid
        {
            get { return userPuid; }
        }
        private ulong userPuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecUserHistoryDB.
        public bool HitSecUHDB
        {
            get { return hitSecUHDB; }
        }
        private bool hitSecUHDB;

        // --

        #region Create an instance of UserPassportHistoryEditor

        //constructor is not for public use
        private UserPassportHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecUHDBInsteadOfUodb
        public static UserPassportHistoryEditor FromUserPuid(ulong upuid, bool hitSecUHDBInsteadOfUodb)
        {
            UserPassportHistoryEditor mghe=new UserPassportHistoryEditor();
            mghe.userPuid=upuid;
            mghe.hitSecUHDB=hitSecUHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the user's Passport history

        public class UserPassportHistoryEntry: System.IEquatable<UserPassportHistoryEntry>
        {
            public ulong UserPuid;
            public ulong ?MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public ulong ?OldPassport;
            public ulong ?NewPassport;
            public byte Reason;
            public short HashBucket;

            public UserPassportHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecMHDBInsteadOfUodbHashing
            public UserPassportHistoryEntry(ulong userPuid, ulong ?machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, ulong ?oldPassport, ulong ?newPassport, byte reason, bool isSecMHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                OldPassport=oldPassport;
                NewPassport=newPassport;
                Reason=reason;

                if (isSecMHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecUserHistoryWebstoreApp, userPuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(userPuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is UserPassportHistoryEntry))
                {
                    return false;
                }

                return Equals((UserPassportHistoryEntry)other);
            }

            public bool Equals(UserPassportHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    OldPassport==other.OldPassport &&
                    NewPassport==other.NewPassport &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return UserPuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "UserPassportHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" OldPassport="+(OldPassport!=null?string.Format("0x{0:X}", OldPassport):"")+" NewPassport="+(NewPassport!=null?string.Format("0x{0:X}", NewPassport):"")+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all Passport history for this machine. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, "delete from t_user_passport_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_user_passport_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
        }

        /// <summary> Adds or updates a history entry for this user. </summary>
        public void SetHistory(UserPassportHistoryEntry ent)
        {
            if (ent.UserPuid!=UserPuid)
            {
                throw new System.Exception("Cannot set row for the wrong user puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_user_passport_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "bi_old_passport_puid", "bi_new_passport_puid", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.OldPassport,        ent.NewPassport,        ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_user_puid", "dt_timestamp"});

            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, query, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, UserPuid);
            }
        }

        /// <summary> Retrieves all history for this user. </summary>
        public UserPassportHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<UserPassportHistoryEntry> entries=new System.Collections.Generic.List<UserPassportHistoryEntry>();

            string webstoreDb;
            if (HitSecUHDB)
            {
                webstoreDb=ConfigUtil.SecUserHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, UserPuid);
                ws.CommandSql="select bi_machine_puid, vc_ip_address, dt_timestamp, i_hr, bi_old_passport_puid, bi_new_passport_puid, ti_reason, si_hash_bucket from t_user_passport_history where bi_user_puid="+(long)UserPuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        UserPassportHistoryEntry entry=new UserPassportHistoryEntry();
                        entry.UserPuid=UserPuid;
                        entry.MachinePuid=(reader[0]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[0]);
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.OldPassport=(reader[4]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[4]);
                        entry.NewPassport=(reader[5]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[5]);
                        entry.Reason=(byte)reader[6];
                        entry.HashBucket=(short)reader[7];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\UserGamertagHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class UserGamertagHistoryEditor
    {
        /// <summary> User Puid.  This is the only non-cached information we store about the User's gamertag history. </summary>
        public ulong UserPuid
        {
            get { return userPuid; }
        }
        private ulong userPuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecUserHistoryDB.
        public bool HitSecUHDB
        {
            get { return hitSecUHDB; }
        }
        private bool hitSecUHDB;

        // --

        #region Create an instance of UserGamertagHistoryEditor

        //constructor is not for public use
        private UserGamertagHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecUHDBInsteadOfUodb
        public static UserGamertagHistoryEditor FromUserPuid(ulong upuid, bool hitSecUHDBInsteadOfUodb)
        {
            UserGamertagHistoryEditor mghe=new UserGamertagHistoryEditor();
            mghe.userPuid=upuid;
            mghe.hitSecUHDB=hitSecUHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the User's gamertag history

        public class UserGamertagHistoryEntry: System.IEquatable<UserGamertagHistoryEntry>
        {
            public ulong UserPuid;
            public ulong ?MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public string OldGamertag;
            public string NewGamertag;
            public byte Reason;
            public short HashBucket;

            public UserGamertagHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecUHDBInsteadOfUodbHashing
            public UserGamertagHistoryEntry(ulong userPuid, ulong ?machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, string oldGamertag, string newGamertag, byte reason, bool isSecUHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                OldGamertag=oldGamertag;
                NewGamertag=newGamertag;
                Reason=reason;

                if (isSecUHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecUserHistoryWebstoreApp, UserPuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(UserPuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is UserGamertagHistoryEntry))
                {
                    return false;
                }

                return Equals((UserGamertagHistoryEntry)other);
            }

            public bool Equals(UserGamertagHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    OldGamertag==other.OldGamertag &&
                    NewGamertag==other.NewGamertag &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return UserPuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "UserGamertagHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" OldGamertag="+OldGamertag+" NewGamertag="+NewGamertag+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all gamertag history for this User. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, "delete from t_user_gamertag_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_user_gamertag_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
        }

        /// <summary> Adds or updates a history entry for this User. </summary>
        public void SetHistory(UserGamertagHistoryEntry ent)
        {
            if (ent.UserPuid!=UserPuid)
            {
                throw new System.Exception("Cannot set row for the wrong User puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_user_gamertag_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "vc_old_gamertag", "vc_new_gamertag", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.OldGamertag,   ent.NewGamertag,   ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_user_puid", "dt_timestamp"});

            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, query, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, UserPuid);
            }
        }

        /// <summary> Retrieves all history for this User. </summary>
        public UserGamertagHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<UserGamertagHistoryEntry> entries=new System.Collections.Generic.List<UserGamertagHistoryEntry>();

            string webstoreDb;
            if (HitSecUHDB)
            {
                webstoreDb=ConfigUtil.SecUserHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, UserPuid);
                ws.CommandSql="select bi_machine_puid, vc_ip_address, dt_timestamp, i_hr, vc_old_gamertag, vc_new_gamertag, ti_reason, si_hash_bucket from t_user_gamertag_history where bi_user_puid="+(long)UserPuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        UserGamertagHistoryEntry entry=new UserGamertagHistoryEntry();
                        entry.MachinePuid=(reader[0]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[0]);
                        entry.UserPuid=UserPuid;
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.OldGamertag=(reader[4]==System.DBNull.Value?null:(string)reader[4]);
                        entry.NewGamertag=(reader[5]==System.DBNull.Value?null:(string)reader[5]);
                        entry.Reason=(byte)reader[6];
                        entry.HashBucket=(short)reader[7];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        /// <summary> Retrieves all history for this User. </summary>
        public static UserGamertagHistoryEntry[] GetAllHistoryForGamertag(string gamertag, bool hitSecUHDB)
        {
            System.Collections.Generic.List<UserGamertagHistoryEntry> entries=new System.Collections.Generic.List<UserGamertagHistoryEntry>();

            string webstoreDb;
            if (hitSecUHDB)
            {
                webstoreDb=ConfigUtil.SecUserHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                //have to scan all partitions for this
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    ws.ClearParameters();
                    ws.PartitionType=WstPartitionType.Physical;
                    ws.PhysicalPartition=p;
                    ws.CommandSql="select bi_user_puid, bi_machine_puid, vc_ip_address, dt_timestamp, i_hr, vc_old_gamertag, vc_new_gamertag, ti_reason, si_hash_bucket from t_user_gamertag_history where vc_old_gamertag='"+QueryGenerator.EscapeString(gamertag)+"' or vc_new_gamertag='"+QueryGenerator.EscapeString(gamertag)+"'";

                    using (WstDataReader reader=ws.Execute())
                    {
                        while (reader.Read())
                        {
                            UserGamertagHistoryEntry entry=new UserGamertagHistoryEntry();
                            entry.UserPuid=(ulong)(long)reader[0];
                            entry.MachinePuid=(reader[1]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[1]);
                            entry.IpAddress=(reader[2]==System.DBNull.Value?null:(string)reader[2]);
                            entry.TimeStamp=(System.DateTime)reader[3];
                            entry.Hr=(uint)(int)reader[4];
                            entry.OldGamertag=(reader[5]==System.DBNull.Value?null:(string)reader[5]);
                            entry.NewGamertag=(reader[6]==System.DBNull.Value?null:(string)reader[6]);
                            entry.Reason=(byte)reader[7];
                            entry.HashBucket=(short)reader[8];

                            entries.Add(entry);
                        }
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\VoucherEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating Vouchers directly in the database.
    /// </summary>
    public class VoucherEditor: EditorCommon
    {
        /// <summary>
        /// Voucher Hash (20 bytes).  This is and the offer id are the only non-cached information we store about the voucher.
        /// Note that the hash is one way - you can't go backwards from the hash to the user string.
        /// </summary>
        public byte []Hash
        {
            get { return hash; }
        }
        private byte []hash;

        /// <summary>
        /// OfferId for the voucher.  This and the hash are the only non-cached information we store about the voucher.
        /// </summary>
        public ulong OfferId
        {
            get { return offerId; }
        }
        private ulong offerId;

        // --
        #region Create an instance of VoucherEditor

        /// <summary>
        /// Construct from an existing Voucher hash (does not guarentee that the Voucher exists).
        /// </summary>
        public static VoucherEditor FromHash(byte []voucherHash, ulong offer)
        {
            if (voucherHash.Length!=20)
            {
                throw new System.Exception("Voucher hash must be 20 bytes.");
            }

            VoucherEditor Voucher=new VoucherEditor();
            Voucher.hash=voucherHash;
            Voucher.offerId=offer;
            return Voucher;
        }

        /// <summary>
        /// Construct from an existing 5x5 token (does not guarentee that the Voucher exists).
        /// </summary>
        public static VoucherEditor FromToken(string token, ulong offer)
        {
            return FromHash(Hexer.unhex(TokendbWS.GetVoucherHash(token)), offer);
        }

        /// <summary>
        /// Constructs from an Voucher hash, creating the Voucher in the db if it does not already exist.
        /// </summary>
        public static VoucherEditor CreateOrUseExistingHash(byte []voucherHash, ulong offer)
        {
            VoucherEditor voucher=FromHash(voucherHash, offer);

            if (!TokendbWS.DoesVoucherExist(voucherHash, offer))
            {
                using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType=WstPartitionType.Logical;
                    ws.SetHashVal(System.BitConverter.ToUInt64(voucherHash, 0));
                    int bucket=ws.Partition;
                    ws.CommandSql="INSERT INTO t_vouchers ([bin_voucher_hash],              [bi_offer_id],  [i_use_count], [i_voucher_status_id], [f_in_scg], [f_console_version],  [si_hash_bucket]) "+
                                                   "VALUES(0x"+Hexer.tohex(voucherHash)+", "+(long)offer+", -1,            0,                     0,          2,                   "+bucket+")";
                    ws.ExecuteNonQuery();
                }
            }

            return voucher;
        }

        /// <summary>
        /// Constructs from a 5x5 token, creating the Voucher in the db if it does not already exist.
        /// </summary>
        public static VoucherEditor CreateOrUseExistingToken(string token, ulong offer)
        {
            return CreateOrUseExistingHash(Hexer.unhex(TokendbWS.GetVoucherHash(token)), offer);
        }

        /// <summary>
        /// Creates a new voucher with a random hash.
        /// </summary>
        public static VoucherEditor CreateNew(ulong offer)
        {
            string voucher="STFXX";
            for (int i=1; i<5; ++i)
            {
                if (i!=0) voucher+="-";
                voucher+=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(5);
            }

            return CreateOrUseExistingToken(voucher, offer);
        }

        //constructor is not for public consumption.
        private VoucherEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the Voucher

        /// <summary>
        /// Whether the Voucher actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = TokendbWS.DoesVoucherExist(hash, offerId);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }


        /// <summary>
        /// Number of times the voucher can be used (-1 = unlimited).
        /// </summary>
        public int UseCount
        {
            get
            {
                return GetGenericVoucherProperty<int>("i_use_count", "usecount");
            }

            set
            {
                SetGenericVoucherProperty("i_use_count", "usecount", value);
            }
        }

        /// <summary>
        /// Voucher's status.
        /// </summary>
        public int Status
        {
            get
            {
                return GetGenericVoucherProperty<int>("i_voucher_status_id", "statusid");
            }

            set
            {
                SetGenericVoucherProperty("i_voucher_status_id", "statusid", value);
            }
        }

        /// <summary>
        /// Whether it is in scg, whatever that is, I guess.
        /// </summary>
        public byte InScg
        {
            get
            {
                return GetGenericVoucherProperty<byte>("f_in_scg", "inscg");
            }

            set
            {
                SetGenericVoucherProperty("f_in_scg", "inscg", value);
            }
        }

        /// <summary>
        /// Console version (type?).
        /// </summary>
        public byte ConsoleVersion
        {
            get
            {
                return GetGenericVoucherProperty<byte>("f_console_version", "consoleversion");
            }

            set
            {
                SetGenericVoucherProperty("f_console_version", "consoleversion", value);
            }
        }

        /// <summary>
        /// Hash bucket for the voucher.
        /// </summary>
        public short HashBucket
        {
            get
            {
                return GetGenericVoucherProperty<short>("si_hash_bucket", "hashbucket");
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from an Voucher (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericVoucherProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=TokendbWS.ExecuteSQLScalar("select "+columnName+" from t_vouchers where bin_voucher_hash=0x"+Hexer.tohex(hash)+" and bi_offer_id="+(long)offerId, System.BitConverter.ToUInt64(hash, 0));
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_vouchers", columnName, "0x"+Hexer.tohex(hash)+" and "+offerId);
        }

        /// <summary>
        /// Generic implementation of setting a property in an Voucher.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericVoucherProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            TokendbWS.ExecuteSQLNonQuery("update t_vouchers set "+columnName+"='"+EscapeString(value.ToString())+"' where bin_voucher_hash=0x"+Hexer.tohex(hash)+" and bi_offer_id="+(long)offerId, System.BitConverter.ToUInt64(hash, 0));
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            return "Voucher 0x"+Hexer.tohex(hash);
        }

        //int string containing every field of the Voucher.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return "Nonexistant "+ToString();
                }
                else
                {
                    string ret=ToString();
                    //TODO: add details...
                    return ret;
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\UserRecoveryHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class UserRecoveryHistoryEditor
    {
        /// <summary> User Puid.  This is the only non-cached information we store about the user's recovery history. </summary>
        public ulong UserPuid
        {
            get { return userPuid; }
        }
        private ulong userPuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecUserHistoryDB.
        public bool HitSecUHDB
        {
            get { return hitSecUHDB; }
        }
        private bool hitSecUHDB;

        // --

        #region Create an instance of UserRecoveryHistoryEditor

        //constructor is not for public use
        private UserRecoveryHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecUHDBInsteadOfUodb
        public static UserRecoveryHistoryEditor FromUserPuid(ulong upuid, bool hitSecUHDBInsteadOfUodb)
        {
            UserRecoveryHistoryEditor mghe=new UserRecoveryHistoryEditor();
            mghe.userPuid=upuid;
            mghe.hitSecUHDB=hitSecUHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the user's Recovery history

        public class UserRecoveryHistoryEntry: System.IEquatable<UserRecoveryHistoryEntry>
        {
            public ulong UserPuid;
            public ulong MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public ulong PassportPuid;
            public byte Reason;
            public short HashBucket;

            public UserRecoveryHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecUHDBInsteadOfUodbHashing
            public UserRecoveryHistoryEntry(ulong userPuid, ulong machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, ulong passportPuid, byte reason, bool isSecUHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                PassportPuid=passportPuid;
                Reason=reason;

                if (isSecUHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecUserHistoryWebstoreApp, userPuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(userPuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is UserRecoveryHistoryEntry))
                {
                    return false;
                }

                return Equals((UserRecoveryHistoryEntry)other);
            }

            public bool Equals(UserRecoveryHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    PassportPuid==other.PassportPuid &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return UserPuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "UserRecoveryHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" PassportPuid="+string.Format("0x{0:X}", PassportPuid)+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all Recovery history for this user. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, "delete from t_user_recovery_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_user_recovery_history where bi_user_puid="+(long)UserPuid, UserPuid);
            }
        }

        /// <summary> Adds or updates a history entry for this user. </summary>
        public void SetHistory(UserRecoveryHistoryEntry ent)
        {
            if (ent.UserPuid!=UserPuid)
            {
                throw new System.Exception("Cannot set row for the wrong user puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_user_recovery_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "bi_user_passport_puid", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.PassportPuid,        ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_user_puid", "dt_timestamp"});

            if (HitSecUHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecUserHistoryWebstoreApp, query, UserPuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, UserPuid);
            }
        }

        /// <summary> Retrieves all history for this user. </summary>
        public UserRecoveryHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<UserRecoveryHistoryEntry> entries=new System.Collections.Generic.List<UserRecoveryHistoryEntry>();

            string webstoreDb;
            if (HitSecUHDB)
            {
                webstoreDb=ConfigUtil.SecUserHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, UserPuid);
                ws.CommandSql="select bi_machine_puid, vc_ip_address, dt_timestamp, i_hr, bi_user_passport_puid, ti_reason, si_hash_bucket from t_user_recovery_history where bi_user_puid="+(long)UserPuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        UserRecoveryHistoryEntry entry=new UserRecoveryHistoryEntry();
                        entry.UserPuid=UserPuid;
                        entry.MachinePuid=(ulong)(long)reader[0];
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.PassportPuid=(ulong)(long)reader[4];
                        entry.Reason=(byte)reader[5];
                        entry.HashBucket=(short)reader[6];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Diagnostics\XDSPackets.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.config;

// This is a modified copy of Larry's code, found in
// $corext\private\server\xds\test\functional\CReflectionRequest.cs
//
namespace ServerTestFramework.LiveService.Diagnostics
{
    public enum XDS_REQUEST_TYPES : ushort
    {
        SAMEIPPORT = 0,
        DIFFERENTIP_SAMEPORT = 1,
        SAMEIP_DIFFERENTPORT = 2,
        ICMP = 3,
        LOG = 4                     // not implemented
    }

    public abstract class SendablePacket
    {
        public abstract byte[] GetPacket();

        //public virtual byte[] SendRecv() { return SendRecv(Global.XEnv.GetVirtualInterface(VirtualInterface.xds), 2000); }
        //public virtual byte[] SendRecv(int timeOutMs) { return SendRecv(Global.XEnv.GetVirtualInterface(VirtualInterface.xds), timeOutMs); }
        public virtual byte[] SendRecv() { return SendRecv(Global.XEnv.GetVirtualInterface(VirtualInterface.xds), 2000); }
        public virtual byte[] SendRecv(int timeOutMs) { return SendRecv(Global.XEnv.GetVirtualInterface(VirtualInterface.xds), timeOutMs); }
        public virtual byte[] SendRecv(IPEndPoint host, int timeOutMS)
        {
            byte[] packet = GetPacket();
            byte[] response = SimpleUdp.SendRecv(packet, host, timeOutMS);
            return response;
        }

        /// <summary>
        /// Generate a random string of characters
        /// </summary>
        /// <param name="size">Lenght of string</param>
        /// <returns></returns>
        public static string GenerateRandomString( int size )
        {
            string result = "";
            byte[] randData = new byte[size];
            System.Text.ASCIIEncoding asci = new System.Text.ASCIIEncoding();

            System.Random rand = new System.Random();

            rand.NextBytes( randData );
            result = asci.GetString( randData );
            return result;
        }

    }


	/// <summary>
	/// Summary description for CReflectionRequest.
	///
	///
	/// </summary>
	public class CReflectionRequest : SendablePacket
	{
        /// <summary>
        /// Reflection Request, use this constructor for making bad packets
        /// </summary>
        /// <param name="pv">Protocol version</param>
        /// <param name="rt">Request type</param>
        /// <param name="rps">Return packet size</param>
        /// <param name="pl">Payload</param>
		public CReflectionRequest( ushort pv, ushort rt, ushort rps, string pl )
		{
            ASCIIEncoding asci = new ASCIIEncoding();

            _protocolVersion    = pv;
            _requestType        = rt;
            _returnPacketSize   = rps;
            _payload            = asci.GetBytes(pl);
		}

        /// <summary>
        /// Reflection Request, simple constructor
        /// </summary>
        /// <param name="rt">Request type</param>
        /// <param name="pl">Payload</param>
        public CReflectionRequest(ushort rt, string pl) : this(1, rt, (ushort)(CReflectionReply.PacketSize + pl.Length), pl)
        {
        }

        /// <summary>
        /// Reflection Request, simple constructor
        /// </summary>
        /// <param name="rt">Request type</param>
        /// <param name="payloadsize">Payload size, automatically generates a random string</param>
        public CReflectionRequest(ushort rt, int payloadSize) : this(1, rt, (ushort)(CReflectionReply.PacketSize + payloadSize), GenerateRandomString(payloadSize))
        {
        }

        /// <summary>
        /// Reflection Request, even simpler constructor
        /// </summary>
        /// <param name="payloadsize">Payload size, automatically generates a random string</param>
        public CReflectionRequest(int payloadSize) : this(1, (ushort)XDS_REQUEST_TYPES.SAMEIPPORT, (ushort)(CReflectionReply.PacketSize + payloadSize), GenerateRandomString(payloadSize))
        {
        }

        public CReflectionRequest( byte[] msg )
        {
            MemoryStream ms         = new MemoryStream( msg, false );
            BinaryReader br         = new BinaryReader( ms );
            ushort lengthOfPayload  = 0;

            _protocolVersion        = br.ReadUInt16();
            _requestType            = br.ReadUInt16();
            _returnPacketSize       = br.ReadUInt16();
            lengthOfPayload         = br.ReadUInt16();
            _payload                = br.ReadBytes( lengthOfPayload );
        }

        public override byte[] GetPacket()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );
            byte[] packet = null;

            ms.SetLength( _returnPacketSize );

            // write the data to the stream.
            bw.Write( _protocolVersion );
            bw.Write( _requestType );
            bw.Write( _returnPacketSize );
            bw.Write( (ushort)(_payload.Length) );
            bw.Write( _payload );

            // Shrink those shorter packets
            ms.SetLength( _returnPacketSize );

            bw.Close();

            packet = ms.ToArray();

            return packet;
        }

        public bool VerifyReply( )
        {
            if (reply == null)
            {
                Global.RO.Debug("No reply");
                return false;
            }

            // ensure the size
            if ( reply.LengthOfPayload != _payload.Length )
            {
                Global.RO.Debug("Length of payload mismatch, got {0}, expected {1}",
                    reply.LengthOfPayload, _payload.Length);
                return false;
            }

            // ensure the length of the payload.
            for ( int nX = 0; nX < reply.LengthOfPayload; nX++ )
            {
                if ( reply.Payload[nX] != _payload[nX] )
                {
                    Global.RO.Debug("Payload mismatch at index {0}", nX);
                    return false;
                }
            }
            return true;
        }

        public static bool operator ==(CReflectionRequest obj1, CReflectionRequest obj2 )
        {
            // true if all values are equal.
            return (
                    obj1._requestType       == obj2._requestType &&
                    obj1._protocolVersion   == obj2._protocolVersion &&
                    obj1._returnPacketSize  == obj2._returnPacketSize &&
                    obj1._payload           == obj2._payload
                    );
        }

        public static bool operator !=(CReflectionRequest obj1, CReflectionRequest obj2 )
        {
            // true if all values are equal.
            return !( obj1 == obj2 );
        }

        public override bool Equals(object obj)
        {
            // true if all values are equal.
            return ( this == (CReflectionRequest)obj );
        }

        public override int GetHashCode()
        {
            // true if all values are equal.
            return ( (int)_protocolVersion * (int)_requestType * (int)_returnPacketSize );
        }

        public bool SendRecvVerify(int timeOutMs)
        {
            reply = null;
            byte[] response = SendRecv(timeOutMs);
            if (response != null && response.Length > 0)
            {
                reply = new CReflectionReply(response);
            }
            return VerifyReply();
        }

        public void SetPayload(int size)
        {
            SetPayload(GenerateRandomString(size));
        }

        public void SetPayload(string pl)
        {
            ASCIIEncoding asci  = new ASCIIEncoding();
            _payload            = asci.GetBytes(pl);
            _returnPacketSize   = (ushort)(_payload.Length + CReflectionReply.PacketSize);
        }

        public ushort  _protocolVersion;
        public ushort  _requestType;
        public ushort  _returnPacketSize;
        // public ushort _lengthOfPayload;  // no need to store, but is part of packet
        public byte[]  _payload;

        // Not part of packet
        public static int PacketSize = 8;
        public CReflectionReply reply = null;
	}

    /// <summary>
    /// Summary description for CICMPRequest.
    ///
    ///
    /// </summary>
    public class CICMPRequest : SendablePacket
    {
        /// <summary>
        /// ICMP Request constructor, use this for making bad packets
        /// </summary>
        /// <param name="pv">Protocol version</param>
        /// <param name="rt">Request type</param>
        /// <param name="signature">Signature</param>
        /// <param name="ts">Timestamp</param>
        /// <param name="packetsize">Packet size</param>
        public CICMPRequest( ushort pv, ushort rt, byte[] signature, ulong ts , uint packetsize )
        {
            _protocolVersion    = pv;
            _requestType        = rt;
            _signature          = signature;
            _timestamp          = ts;
            _packetsize         = packetsize;
        }

        /// <summary>
        /// ICMP Request, simple constructor
        /// </summary>
        /// <param name="reply">Reply packet from a Reflection Request call</param>
        public CICMPRequest(CReflectionReply reply) : this(1, (ushort)XDS_REQUEST_TYPES.ICMP, reply.Signature, reply.TimeStamp, (uint)CICMPRequest.PacketSize)
        {
        }

        /// <summary>
        /// Both parameters must come from a CReflectionReply message
        /// </summary>
        /// <param name="signature"></param>
        /// <param name="timestamp"></param>
        public void SetTimestamp(byte[] signature, ulong timestamp)
        {
            _signature = signature;
            _timestamp = timestamp;

            // So we can determine the age of this packet
            _localtimestamp = System.DateTime.Now.Ticks;
        }

        public override byte[] GetPacket()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );
            byte[] packet = null;

            ms.SetLength( _packetsize );

            // write the data to the stream.
            bw.Write( _protocolVersion );
            bw.Write( _requestType );
            bw.Write( _signature );
            bw.Write( _timestamp );

            // Shrink those shorter packets
            ms.SetLength( _packetsize );

            bw.Close();

            packet = ms.ToArray();

            return packet;
        }

        public bool SendRecvVerify(int timeOutMs)
        {
            byte[] response;

            // We can't receive ICMP packets, to verify it's being sent we have to use NetMon.
            // It's possible we can detect the "Port Unreachable" message here, though.....
            // Update: it seems we can, due to a somewhat boneheaded Winsock implementation
            // that throws an exception (Connection Reset) when we get one of these packets.
            // UDP is connectionless, which is why I say this is somewhat boneheaded.
            try
            {
                response = SendRecv(timeOutMs);
            }
            catch (System.Net.Sockets.SocketException e)
            {
                // WSAECONNRESET
                // This happens when we receive an ICMP Port Unreachable packet.
                // WinSock is kinda stupid here -- this is a *connectionless* protocol
                // after all so it should just swallow a connection reset message. However,
                // for our ICMP tests, this is quite useful. I'm pretty sure this behavior
                // is consistent, so if we are receiving ICMP Port Unreachable messages,
                // this exception WILL be thrown.
                if (e.ErrorCode == 10054)
                {
                    // Got a reply.
                    return true;
                }
                else
                {
                    throw e;
                }
            }

            if (response == null)
            {
                // Got no reply. Let caller determine if this is expected or not.
                return false;
            }
            else
            {
                // Got a UDP reply. This is definitely not expected.
                throw new UnexpectedTestResultException("Got ICMP reply, length is " + response.Length);
            }
        }

        public ushort  _protocolVersion;
        public ushort  _requestType;
        public byte[]  _signature;         // 20 bytes
        public ulong   _timestamp;
        
        public uint    _packetsize;        // not part of packet
        public long    _localtimestamp;    // not part of packet

        public static int PacketSize = 32;
    }

    /// <summary>
    /// Reply packet for Reflection request
    ///
    ///
    /// </summary>
    public class CReflectionReply
    {
        public CReflectionReply( byte[] reply )
        {
            MemoryStream ms     = new MemoryStream( reply, false );
            BinaryReader br     = new BinaryReader( ms );

            _signature          = br.ReadBytes( 20 );
            _timestamp          = br.ReadUInt64();
            _clientSourceIP     = br.ReadUInt32();
            _clientSourcePort   = br.ReadUInt16();
            _lengthOfPayload    = br.ReadUInt16();
            _payload            = br.ReadBytes( _lengthOfPayload );
        }

        public byte[] Signature
        {
            get { return _signature; }
        }

        public ulong TimeStamp
        {
            get { return _timestamp; }
        }

        public uint ClientSrcIP
        {
            get { return _clientSourceIP; }
        }

        public ushort ClientSrcPort
        {
            get { return _clientSourcePort; }
        }

        public ushort LengthOfPayload
        {
            get { return _lengthOfPayload; }
        }

        public byte[] Payload
        {
            get { return _payload; }
        }

        private byte[]  _signature;             // 20 bytes
        private ulong   _timestamp;
        private uint    _clientSourceIP;
        private ushort  _clientSourcePort;
        private ushort  _lengthOfPayload;
        private byte[]  _payload;

        public static int PacketSize = 36;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeAAInfo\FakeAAInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.LiveService.FakeAAInfoNameSpace
{
    public class FakeAAInfo : xonline.common.service.AAInfo
    {
        // Expose the constructor
        public FakeAAInfo() : this(0, "") { }

        public FakeAAInfo(ulong passportPuid)
            : this(passportPuid, Dns.GetHostEntry(Dns.GetHostName()).AddressList[0].ToString()) { }

        public FakeAAInfo(ulong passportPuid, string ipAddressInternet) : base(passportPuid, ipAddressInternet) 
        {
            _certDeviceId = "";
            _samlToken = "";
        }

        // These properties are serialized to the AuthZ header
        public new ulong PassportPuid { set { _passportPuid = value; } }
        public new string IpAddressInternet { set { _ipAddressInternet = value; } }
        public new ulong? LiveXuid { set { _liveXuid = value; } }
        public new ulong PassportCId { set { _passportCId = value; } }
        public new DateTime NotAfter { set { _notAfterDateTime = value; } }
        public new DateTime IssueInstant { set { _issueInstantDateTime = value; } }
        public new string CertDeviceId { get { return _certDeviceId; } set { _certDeviceId = value; } }
        public string SamlToken { set { _samlToken = value; } }

        // These properties are not serialized
        public xonline.common.service.XblSamlToken SamlSecurityToken { set { _xblSamlToken = value; } }
        public new System.Net.IPAddress OriginatingIP { set { _originatingIP = value; } }
        public new byte? CountryId { set { _countryId = value; } }
        public new System.Collections.BitArray UserPrivileges { set { _userPrivileges = value; } }

        #region AAInfo Abstract Members

        // No need to implement these.

        protected override void PopulateLiveXuid ()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserInfo ()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserPrivileges ()
        {
            throw new NotImplementedException();
        }

        #endregion

        public new string ConvertToHttpHeaderValue()
        {
            return base.ConvertToHttpHeaderValue();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\FakeSGRemote.cs ===
using System;
using System.Net;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;

namespace ServerTestFramework.LiveService.FakeSG
{
	public interface IFakeSGRemoteControl
	{
		int GetServiceVersion();

		int       GetInterfaceCount();
		IPAddress GetInterfaceAddress( int index );

		void LoadSlot( ref CSGInfo sgInfo, ulong xboxId );

        void AddXbox(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, CSGInfo.ClientType clientType, uint languageId);
		void RemoveXbox( ulong xboxId );
		void DeadXbox( ulong xboxId );
		void ClearXboxes();
		void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion );
		void SetAltTitles( ulong xboxId, uint[] altTitleIds );
		void SetKey( ulong xboxId, byte[] key );
		void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen);
		void SetStateEndpoint(string endpoint);
		void SetEnableStateBatching(bool enable, uint intervalmiliSeconds);
		
		void   AddUser( ulong xboxId, ulong userId, uint userFlags );
		void   RemoveUser( ulong xboxId, ulong userId );
		byte   GetUserCount( ulong xboxId );
		bool   ReadUserQValPacket( ulong xboxId, ulong userId, out QValPacket packet );
	}

	public class FakeSGRemoteController : MarshalByRefObject
	{
		IFakeSGRemoteControl rc = (IFakeSGRemoteControl) FakeSGBase.GetSingleton();

		public int GetServiceVersion()
		{
			return rc.GetServiceVersion();
		}
		
		public int GetServicedInterfaceCount()
		{
			return rc.GetInterfaceCount();
		}

		public IPAddress GetServicedInterface( int index )
		{
			return rc.GetInterfaceAddress( index );
		}

		public void LoadSlot( ref CSGInfo sgInfo, ulong xboxId )
		{
			rc.LoadSlot( ref sgInfo, xboxId );
		}
		
        public void AddXbox(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, CSGInfo.ClientType clientType, uint languageId)
        {
            rc.AddXbox( sgIp, spi, xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId );
        }

		public void RemoveXbox( ulong xboxId )
		{
			rc.RemoveXbox( xboxId );
		}

		public void DeadXbox( ulong xboxId )
		{
			rc.DeadXbox( xboxId );
		}

		public void ClearXboxes()
		{
			rc.ClearXboxes();
		}

		public void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion )
		{
			rc.SetTitle( xboxId, titleId, titleVer, titleRegion );
		}

		public void SetAltTitles( ulong xboxId, uint[] altTitleIds )
		{
			rc.SetAltTitles( xboxId, altTitleIds );
		}

		public void SetKey( ulong xboxId, byte[] key )
		{
			rc.SetKey( xboxId, key );
		}

		public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen)
		{
			rc.SetUserState(xboxId, userId, matchSessionId, state, titleData, titleDataLen);
		}

		public void SetStateEndpoint(string endpoint)
		{
			rc.SetStateEndpoint(endpoint);
		}
		
		public void SetEnableStateBatching(bool enable, uint intervalmiliSeconds)
		{
			rc.SetEnableStateBatching(enable, intervalmiliSeconds);
		}

		public void AddUser( ulong xboxId, ulong userId, uint userFlags )
		{
			rc.AddUser( xboxId, userId, userFlags );
		}

		public void RemoveUser( ulong xboxId, ulong userId )
		{
			rc.RemoveUser( xboxId, userId );
		}

		public byte GetUserCount( ulong xboxId )
		{
			return rc.GetUserCount( xboxId );
		}

		public bool ReadUserQValPacket( ulong xboxId, ulong userId, out QValPacket packet )
		{
			return rc.ReadUserQValPacket( xboxId, userId, out packet );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\VirtualInterfaceEditor.cs ===
using System;

using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating virtual interfaces directly in the database.
    /// NOTE: Be careful using this, modifying an existing virtual interface is not to be done lightly.
    /// </summary>
    public class VirtualInterfaceEditor : EditorCommon
    {
        /// <summary>The virtual interface's name.</summary>
        /// <remarks>This is the only non-cached information we store.</remarks>
        public string Name
        {
            get;
            private set;
        }

        #region Create or remove an instance of VirtualInterfaceEditor

        /// <summary>Construct from an existing virtual interface name (does not guarantee that the virtual interface exists).</summary>
        public static VirtualInterfaceEditor FromName (string name)
        {
            return new VirtualInterfaceEditor() { Name = name };
        }

        /// <summary>
        /// Constructs from a virtual interface definition, creating the virtual interface in the database
        /// if it does not already exist or overwriting all values if it does.  KNOW WHAT YOU ARE DOING IF YOU USE THIS!
        /// </summary>
        public static VirtualInterfaceEditor CreateOrOverwrite (string name, string interfaceName, int? port, int? portEnd,
            string vDir, string webstoreApp, int? timeout, int? internetPort, int? internetPortEnd, string info1, string info2)
        {
            // check for invalid data
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (string.IsNullOrEmpty(interfaceName))
            {
                throw new ArgumentNullException("interfaceName");
            }

            // create sproc call string
            string sproc = @"
Exec p_config_add_virtual_interface
    @virtualInterface = {0},
    @interface = {1},
    @port = {2},
    @portEnd = {3},
    @vDir = {4},
    @webstoreApp = {5},
    @timeout = {6},
    @internetPort = {7},
    @internetPortEnd = {8},
    @info1 = {9},
    @info2 = {10},
    @overwriteExistingValue = 1
";
            sproc = string.Format(sproc,
                FormatString(name),
                FormatString(interfaceName),
                FormatNullable(port),
                FormatNullable(portEnd),
                FormatString(vDir),
                FormatString(webstoreApp),
                FormatNullable(timeout),
                FormatNullable(internetPort),
                FormatNullable(internetPortEnd),
                FormatString(info1),
                FormatString(info2));

            StaticNpdb.ExecuteNonQuery(sproc);

            return FromName(name);
        }

        /// <summary>Completely removes the virtual interface from the database.</summary>
        public void Delete ()
        {
            StaticNpdb.ExecuteNonQuery("Delete from t_site_virtual_interface_ips where vc_virtual_interface = '" + EscapedName + "'");
            StaticNpdb.ExecuteNonQuery("Delete from t_virtual_interfaces where vc_virtual_interface = '" + EscapedName + "'");
        }

        // constructor is not for public consumption.
        private VirtualInterfaceEditor ()
        {
        }

        #endregion

        #region Lookup or alter properties of the virtual interface

        /// <summary>Whether the virtual interface actually exists in the database.</summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = !string.IsNullOrEmpty(Name) && 
                    ((int)StaticNpdb.ExecuteScalar("Select count(0) from t_virtual_interfaces where vc_virtual_interface = '" +
                    EscapedName + "'") != 0);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>Interface that the virtual interface implements.</summary>
        public string Interface
        {
            get
            {
                return GetGenericProperty<string>("vc_interface");
            }

            set
            {
                SetGenericProperty("vc_interface", value);
            }
        }

        /// <summary>Port of the virtual interface.</summary>
        public int Port
        {
            get
            {
                return GetGenericProperty<int>("i_port");
            }

            set
            {
                SetGenericProperty("i_port", value);
            }
        }

        /// <summary>End port of the virtual interface.</summary>
        public int PortEnd
        {
            get
            {
                return GetGenericProperty<int>("i_port_end");
            }

            set
            {
                SetGenericProperty("i_port_end", value);
            }
        }

        /// <summary>VDir of the virtual interface.</summary>
        public string VDir
        {
            get
            {
                return GetGenericProperty<string>("vc_vdir");
            }

            set
            {
                SetGenericProperty("vc_vdir", value);
            }
        }

        /// <summary>Webstore app of the virtual interface.</summary>
        public string WebstoreApp
        {
            get
            {
                return GetGenericProperty<string>("vc_webstore_app");
            }

            set
            {
                SetGenericProperty("vc_webstore_app", value);
            }
        }

        /// <summary>Timeout of the virtual interface.</summary>
        public int Timeout
        {
            get
            {
                return GetGenericProperty<int>("i_timeout");
            }

            set
            {
                SetGenericProperty("i_timeout", value);
            }
        }

        /// <summary>Internet port of the virtual interface.</summary>
        public int InternetPort
        {
            get
            {
                return GetGenericProperty<int>("i_internet_port");
            }

            set
            {
                SetGenericProperty("i_internet_port", value);
            }
        }

        /// <summary>End internet port of the virtual interface.</summary>
        public int InternetPortEnd
        {
            get
            {
                return GetGenericProperty<int>("i_internet_port_end");
            }

            set
            {
                SetGenericProperty("i_internet_port_end", value);
            }
        }

        /// <summary>Info1 of the virtual interface.</summary>
        public string Info1
        {
            get
            {
                return GetGenericProperty<string>("vc_info1");
            }

            set
            {
                SetGenericProperty("vc_info1", value);
            }
        }

        /// <summary>Info2 of the virtual interface.</summary>
        public string Info2
        {
            get
            {
                return GetGenericProperty<string>("vc_info2");
            }

            set
            {
                SetGenericProperty("vc_info2", value);
            }
        }

        /// <summary>Generic implementation of returning a property from a virtual interface (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName)
        {
            return GetGenericProperty<TypeOfProperty>(columnName, columnName);
        }

        /// <summary>Generic implementation of returning a property from a virtual interface (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = StaticNpdb.ExecuteScalar("Select " + columnName + " from t_virtual_interfaces where vc_virtual_interface = '" +
                    EscapedName + "'");
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_virtual_interfaces", columnName, Name);
        }

        /// <summary>Generic implementation of setting a property of a virtual interface.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, TypeOfProperty value)
        {
            SetGenericProperty<TypeOfProperty>(columnName, columnName, value);
        }

        /// <summary>Generic implementation of setting a property of a virtual interface.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("Update t_virtual_interfaces set " + columnName + " = '" + EscapeString(value.ToString()) + 
                "' where vc_virtual_interface = '" + EscapedName + "'");
            SetCacheEntry(cacheName, value);
        }

        #endregion

        #region Add or remove "assets" for the virtual interface

        //TODO: functions to remove ips and get a list of ips from t_site_virtual_interface_ips

        /// <summary>Updates or creates a new row in t_site_virtual_interface_ips.</summary>
        public void SetVirtualInterfaceIp (string ip)
        {
            string sproc = @"
Exec p_config_add_site_virtual_interface_ip
    @environment = {0}, 
    @siteId = {1},
    @virtualInterface = {2},
    @ip = {3},
    @overwriteExistingValue = 1
";
            sproc = string.Format(sproc,
                FormatString(Config.Environment),
                Config.SiteId,
                FormatString(Name),
                FormatString(ip)
                );

            StaticNpdb.ExecuteNonQuery(sproc);
        }

        /// <summary>
        /// Adds or updates an xrl.
        /// </summary>
        public void AddOrUpdateXrl (string xrl, bool xrlscan, bool websg, bool livepxy, int maxUrlLength,
            int maxContentLength, int maxQueryStringLength, bool allowTextXmlType, bool dontGetSgInfo,
            bool allowNoExactMatch, bool authsg, bool blockLimitedPcAccount, string httpVerbs)
        {
            // check parameters
            if (string.IsNullOrEmpty(xrl))
            {
                throw new ArgumentNullException("xrl");
            }

            if (string.IsNullOrEmpty(httpVerbs))
            {
                throw new ArgumentNullException("httpVerbs");
            }

            #region Giant SQL statement because there is no sproc
            string sql = @"
Declare @vc_xrl nvarchar(64)
Declare @vc_virtual_interface nvarchar(64)
Declare @ti_xrlscan tinyint
Declare @ti_websg tinyint
Declare @ti_livepxy tinyint
Declare @i_max_url_length int
Declare @i_max_content_length int
Declare @i_max_query_string_length int
Declare @ti_allow_text_xml_type tinyint
Declare @ti_dont_get_sg_info tinyint
Declare @ti_allow_no_exact_match tinyint
Declare @ti_authsg tinyint
Declare @ti_block_limited_pc_account tinyint
Declare @vc_environment nvarchar(64)
Declare @vc_http_verbs nvarchar(64)

Set @vc_xrl = {0}
Set @vc_virtual_interface = {1}
Set @ti_xrlscan = {2}
Set @ti_websg = {3}
Set @ti_livepxy = {4}
Set @i_max_url_length = {5}
Set @i_max_content_length = {6}
Set @i_max_query_string_length = {7}
Set @ti_allow_text_xml_type = {8}
Set @ti_dont_get_sg_info = {9}
Set @ti_allow_no_exact_match = {10}
Set @ti_authsg = {11}
Set @ti_block_limited_pc_account = {12}
Select @vc_environment = vc_environment from t_environments where b_current = 1
Set @vc_http_verbs = {13}

IF not exists (Select null from t_xrl_virtual_interface_mappings where vc_xrl = @vc_xrl
    and vc_virtual_interface = @vc_virtual_interface and vc_environment = @vc_environment)
BEGIN
    Insert into t_xrl_virtual_interface_mappings
        (vc_xrl, vc_virtual_interface, ti_xrlscan, ti_websg, ti_livepxy, i_max_url_length,
         i_max_content_length, i_max_query_string_length, ti_allow_text_xml_type, ti_dont_get_sg_info,
         ti_allow_no_exact_match, ti_authsg, ti_block_limited_pc_account, vc_environment, vc_http_verbs)
        values
        (@vc_xrl, @vc_virtual_interface, @ti_xrlscan, @ti_websg, @ti_livepxy, @i_max_url_length,
         @i_max_content_length, @i_max_query_string_length, @ti_allow_text_xml_type, @ti_dont_get_sg_info,
         @ti_allow_no_exact_match, @ti_authsg, @ti_block_limited_pc_account, @vc_environment, @vc_http_verbs)
END ELSE BEGIN
    Update t_xrl_virtual_interface_mappings set
        ti_xrlscan = @ti_xrlscan,
        ti_websg = @ti_websg,
        ti_livepxy = @ti_livepxy,
        i_max_url_length = @i_max_url_length,
        i_max_content_length = @i_max_content_length,
        i_max_query_string_length = @i_max_query_string_length,
        ti_allow_text_xml_type = @ti_allow_text_xml_type,
        ti_dont_get_sg_info = @ti_dont_get_sg_info,
        ti_allow_no_exact_match = @ti_allow_no_exact_match,
        ti_authsg = @ti_authsg,
        ti_block_limited_pc_account = @ti_block_limited_pc_account,
        vc_http_verbs = @vc_http_verbs
    where
        vc_xrl = @vc_xrl and
        vc_virtual_interface = @vc_virtual_interface and
        vc_environment = @vc_environment
END
";
            #endregion
            sql = string.Format(sql,
                FormatString(xrl),
                FormatString(Name),
                FormatBool(xrlscan),
                FormatBool(websg),
                FormatBool(livepxy),
                maxUrlLength,
                maxContentLength,
                maxQueryStringLength,
                FormatBool(allowTextXmlType),
                FormatBool(dontGetSgInfo),
                FormatBool(allowNoExactMatch),
                FormatBool(authsg),
                FormatBool(blockLimitedPcAccount),
                FormatString(httpVerbs)
                );

            StaticNpdb.ExecuteNonQuery(sql);
        }

        /// <summary>
        /// Deletes the specified xrl from the virtual interface.
        /// </summary>
        public void DeleteXrl (string xrl)
        {
            string sql = @"
Delete from t_xrl_virtual_interface_mappings where
    vc_xrl = {0} and
    vc_virtual_interface = {1} and
    vc_environment = {2}
";
            sql = string.Format(sql,
                FormatString(xrl),
                FormatString(Name),
                FormatString(Config.Environment)
                );

            StaticNpdb.ExecuteNonQuery(sql);
        }

        #endregion

        // Short descriptive useful string that doesn't require db hits
        public override string ToString ()
        {
            return "Virtual Interface: " + (Name ?? "<null>");
        }

        // string containing every field.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        #region Helpers

        /// <summary>The Name, escaped.</summary>
        private string EscapedName
        {
            get
            {
                return EscapeString(Name);
            }
        }

        /// <summary>Formats a nullable type for a SQL statement.</summary>
        private static string FormatNullable<T> (Nullable<T> n) where T : struct
        {
            return (n.HasValue ? n.Value.ToString() : "null");
        }

        /// <summary>Formats a string for a SQL statement.</summary>
        private static string FormatString (string s)
        {
            return (s == null ? "null" : "'" + EscapeString(s) + "'");
        }

        /// <summary>Formats a bool for a SQL statement.</summary>
        private static string FormatBool (bool b)
        {
            return (b ? "1" : "0");
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\Global.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;

using xonline.common.protocol;

using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using xonline.common.service;

namespace ServerTestFramework.LiveService.FakeSG
{
    public class GlobalFakeSG
    {
        public static GlobalFakeSG Singleton = new GlobalFakeSG();

        public ushort _FakeSGRemotingPort = 9900;
        public volatile IFakeSGClient _FakeSG;
        private static object _FakeSGInitLock=new object();

        public static ushort FakeSGRemotingPort
        {
            get { return Singleton._FakeSGRemotingPort; }
            set { Singleton._FakeSGRemotingPort = value; }
        }

        public static IFakeSGClient FakeSG
        {
            get
            {
                //lazy init it if someone is looking for it
                if (Singleton._FakeSG == null)
                {
                    lock (_FakeSGInitLock)
                    {
                        if (Singleton._FakeSG == null)
                        {
                            FakeSGClient fakeSGClient = new FakeSGClient("FakeSGClient");
                            if(!fakeSGClient.ConnectToService())
                            {
                                Global.RO.Fatal("Failed to connect to FakeSG Service");
                                throw new System.Exception("Failed to connect to FakeSG Service");
                            }
                            Singleton._FakeSG = fakeSGClient;
                        }
                    }
                }
                //
                return Singleton._FakeSG;
            }
            set { Singleton._FakeSG = value; }
        }

        public static bool IsFakeSGNull()
        {
            return Singleton._FakeSG == null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\QValPacket.cs ===
using System;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.FakeSG
{
	/// <summary>
	/// A representation of the QVAL data that is delivered from notification
	/// to the SG and from the SG to the client. This class packages up the data
	/// and flags so that we can percolate the data from the wire up to the test
	/// infrastructure.
	/// </summary>
	[Serializable]
	public class QValPacket
	{
		private uint []_Data = new uint[15];

		/// <summary>
		///	File time when this qval was delivered
		/// </summary>
		public DateTime DeliveryTime;

		/// <summary>
		/// Push flag set to indicate urgent data delivery
		/// </summary>
		public bool Push;

		/// <summary>
		/// Set the qvals in the packet, copy them into an internal 
		/// buffer.
		/// </summary>
		public uint[] Data
		{
			get {
				return _Data;
			}
			set {
				Array.Copy(value, _Data, 15);
			}
		}

		/// <summary>
		/// Notification Queue Flags
		/// </summary>
		public uint QVal 
		{
			get {
				return _Data[0];
			}
		}

		public uint QValSequenceNum
		{
			get {
				return _Data[0] >> 8;
			}
		}

		/// <summary>
		/// Indication of payload available in queue.
		/// </summary>
		public uint QFlags
		{
			get {
				return _Data[1];
			}
		}

		/// <summary>
		/// Low byte indicates positive existence
		/// of invite transient message, high 24 bits
		/// indicate the sequence number of the invite.
		/// </summary>
		public uint InviteQVal
		{
			get { 
				return _Data[2];
			}
		}

		/// <summary>
		/// Read invite sequence from invite qval.
		/// </summary>
		public uint InviteSequenceNum
		{
			get {
				return _Data[2] >> 8;
			}
		}

		public uint NewMesageIdQVal 
		{
			get {
				return _Data[3];
			}
		}

		/// <summary>
		/// This value is the same for both msg data and id qvals
		/// </summary>
		public uint NewMessageSequenceNum
		{
			get {
				return _Data[3] >> 8;
			}
		}
		
		/// <summary>
		/// The last 3 message IDs that arrived.
		/// </summary>
		public uint NewMessageId(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[4+index];
		}
		
		/// <summary>
		/// </summary>
		public uint NewMessageDataQVal 
		{
			get {
				return _Data[7];
			}
		}

		/// <summary>
		/// Data for the last 3 messages that arrived
		/// </summary>
		public uint NewMessageData(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[8 + index];
		}
		
		/// <summary>
		/// Raw qval value for deleted message payload.
		/// </summary>
		public uint DeletedMessageQVal 
		{
			get {
				return _Data[11];
			}
		}
		
		/// <summary>
		/// Last sequence number for the delete message qval and associated payloads.
		/// </summary>
		public uint DeletedMessageSequenceNum
		{
			get {
				return _Data[11] >> 8;
			}
		}

		

		/// <summary>
		/// Last 3 messages deleted
		/// </summary>
		public uint DeletedMessageId(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[12 + index];
		}
		
		/// <summary>
		/// Validate internal consistency of QVAL packet throw an exception
		/// if something does not match up.
		/// </summary>
		public void Validate()
		{
			if((InviteQVal & 0x00000008) == 0)
            {
                throw new UnexpectedTestResultException( "Invite QVal is bad: 0x" + InviteQVal.ToString("x"));
            }

            if((QVal & 0x00000001) == 0)
            {
                throw new UnexpectedTestResultException( "Qflags QVal is bad : 0x" + QVal.ToString("x"));
            }
		} 

		/// <summary>
		/// Perform copy operation on data rather than object assignment.
		/// </summary>
		public void Copy(QValPacket packet)
		{
			Push          = packet.Push;
			Data          = packet.Data;
			DeliveryTime  = packet.DeliveryTime;
		}

		/// <summary>
		/// Clear the qval payload data.
		/// </summary>
		public void Clear()
		{
			_Data = new uint[15];
		}

		/// <summary>
		/// Find the first matching message type in messaging qvals for provided type ID.
		/// If no appropriate message is found returns 0.
		/// </summary>
		public uint FirstMessageIdMatchingType(byte msgType)
		{
			uint msgId = 0;
			uint msgData = 0;
			uint msgIdMatch = 0;
			uint msgDataMatch = (uint)(msgType << 24);

			for(uint i = 0; i < 3; ++i)
			{
				msgId   = NewMessageId(i);
				msgData = NewMessageData(i);

				if(0 != msgId && 0 != msgData)
				{
					if((msgData & 0xff000000) == msgDataMatch)
					{
						msgIdMatch = msgId;
						break;
					}
				}
			}

			return msgIdMatch;
		}


		//------------------------------------------------------------------------------
		//
		// QFlag property accessors
		//
		//------------------------------------------------------------------------------
		
		public bool HasBuddyRequest
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_BUDDY_REQ);
			}
		}
		public bool HasListChange
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_LIST_CHANGE);
			}
		}
		public bool HasPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PRESENCE);
			}
		}
		public bool HasInvite
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_INVITE);
			}
		}
		public bool HasInviteAnswer
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_INVITE_ANSWER);
			}
		}
		public bool HasTransientMessage
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS);
			}
		}
		public bool HasPeerPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PEER_PRESENCE);
			}
		}
		public bool HasRichPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PRESENCE_2);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\FakeSGBase.cs ===
using System;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using MemoryMappedFile;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.FakeSG
{
    public unsafe class FakeSGBase : InfiniteLifetimeMarshalByRefObject
    {
        ///////////////////////////////////////////////////
        /// <summary>
        /// Version shared by client and service to ensure compatability
        /// IMPORTANT: Increment this when making changes to client / service interaction
        /// </summary>
        /// <returns>FakeSG version number</returns>
        public static int GetCompiledVersion()
        {
            return CurrentVersion;
        }

        // 32=authdata3 changes by kgoodier
        // 33=support for IsXenonTitle and improved ClientVersion by kgoodier
        // 34=change default behavior to return UserNotFound message unless slot is intentionally populated
        // 35=jacobr - support for lossless qval processing
        // 36=jacobr - support for language ID and user flags for PNUser/PNXbox
		// 37=jacobr - support for clearing all xbox state from FakeSG and Presence servers
		// 38=jacobr - disabled exception throwing in service RemoveXbox() for unknown Xbox, fixed LoadSGInfo for client type
		// 39=jacobr - updates to user lookup and stale xbox removal
		// 40=jacobr - made deadxbox explicit, remove user does not auto remove xbox (support for deaduser)
		// 41=jacobr - qval update, increased length of queueing to support burst scenarios
		// 42=jacobr - messaging qval bug fix, more test support for csgclinotifyupdate
		// 43=jacobr - added support for user assigned _ipaI, _ipportI and _liNonce
        // 44=paully - senduserstate bug fix
        // 45=paully - SG Authentication uses ClientType
        // 46=mifish - Switched InstallService from ServerTestFramework.dll to STFCore.dll & STFLive.dll
        // 47=a-mabrow - Added new default privileges for new users.
        // 48=paully - LoadSlot now adds Major/Minor/Build/QFE versions to SGInfo
        // 49=paully - ClientVersion is the combination of Major/Minor/Build/QFE versions
        // 50=johnmcp - Add XblCore.dll to install
        // 50=shailesh - Converted hashtable to list/array so that multiuser on same xbox goes in to the correct place. 
		//				No version change since there is no signature change, and to maintain compat with other branches.
        // 52=johnmcp - Add new SGInfo protocol and flowtoken support to FakeSG, skipped 51 because it was used for a short
        //              time during shailesh's last change.
        //Updating the interval to mili second to mimic prod behavior, and adding error handling for some cases where it was killing fakesgsvc.
        // 54=lukel - Add support for per-user privileges that are present in AuthDataV4.
        protected const int CurrentVersion = 54;  

        ///////////////////////////////////////////////////
        /// <summary>
        /// Get the current FakeSG Service or Client object
        /// </summary>
        /// <returns>Instance of FakeSG Service or Client</returns>
        public static FakeSGBase GetSingleton()
        {
            return Singleton;
        }
        protected static FakeSGBase Singleton = null;

        ///////////////////////////////////////////////////
        /// <summary>
        /// SPI Auth Data
        ///	Uses Memory Mapped file to allow direct maniplation of slots
        /// by both Client and Service
        /// Format:  Header then a table of 0xFFFF slot entries for each local IP (interface)
        /// </summary>
        static protected MMF mmf = new MMF();
        protected static byte*		mmfPtr   = null; // Points to shared data (mmf)
        protected static byte*      slotPtrs = null; // Points to Slot tables for each interface
        protected static MmfHeader*	header   = null; // Points to metadata

        protected static readonly int tableSize = 65536 * sizeof( CSGInfo );

        [StructLayout(LayoutKind.Sequential)]
            public struct MmfHeader
        {
            public int Version;
            public int Interfaces;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Sets up Shared Memory Mapped File
        /// </summary>
        protected void SetUpMMF( int interfaces )
        {
            uint size = (uint) (sizeof( MmfHeader ) + ( interfaces * tableSize ));
            mmf.Create( size );
			
            mmfPtr = mmf.GetData();

            slotPtrs = mmfPtr + sizeof(MmfHeader);
			
            header = (MmfHeader*) mmfPtr;
            header->Interfaces = interfaces; 
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Gets version in user when MMF was created
        /// </summary>
        /// <returns>Version number in MMF header</returns>
        protected int GetMMFVersion()
        {
            return header->Version;
        }

        public void Shutdown()
        {
            mmfPtr = null;
            slotPtrs = null;
            header = null;

            mmf.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\FakeSGClient.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.ServiceProcess;
using System.Collections;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;


namespace ServerTestFramework.LiveService.FakeSG
{
    unsafe public class FakeSGClient : FakeSGBase, IFakeSGClient
    {
        // Service file names and paths
        private const    string serviceName = "FakeSGService";
        private const    string exeName     = serviceName + ".exe";
        private readonly string dirPath;
        private readonly string exePath;

        // Interface table that hashes local IP addresses to MMF slot table offsets
        private Hashtable mmfInterfaces = new Hashtable();

        // Name of test for logging.
        private string testName;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="testName">Name of test that will be connecting</param>
        public FakeSGClient( string testName )
        {
            this.testName = testName;

            dirPath = Path.Combine(
                Environment.GetFolderPath( Environment.SpecialFolder.ProgramFiles ),
                serviceName );

            exePath = Path.Combine( dirPath, exeName );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Checks if FakeSG Service is runnning.
        /// </summary>
        /// <returns>True if status equals Running</returns>
        private bool IsServiceRunning()
        {
            ServiceController sc = new ServiceController( serviceName );
            bool running = false;
            try
            {
                running = ( sc.Status == ServiceControllerStatus.Running );
            }
            catch( InvalidOperationException ) {}

            return running;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Start the FakeSG Service
        /// </summary>
        /// <returns>True if service is started</returns>
        private bool StartService()
        {
            Global.RO.Info( "Starting FakeSG Service..." );
            ServiceController sc = new ServiceController( serviceName );

            bool started = true;
            try
            {
                sc.Start();
                sc.WaitForStatus( ServiceControllerStatus.Running, new TimeSpan( 0, 0, 30 ) ); // 30 Seconds
            }
            catch( InvalidOperationException )
            {
                Global.RO.Error( "FakeSG Service could not be started." );
                started = false;
            }
            catch( System.ServiceProcess.TimeoutException )
            {
                Global.RO.Error( "FakeSG Service could not be started.  Timed out waiting for running status." );
                started = false;
            }

            // Let dust settle a bit
            System.Threading.Thread.Sleep( 500 );

            return started;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Stop the FakeSG Service
        /// </summary>
        /// <returns>True if service is stopped</returns>
        private bool StopService()
        {
            Global.RO.Info( "Stopping FakeSG Service..." );
            ServiceController sc = new ServiceController( serviceName );

            // TBD!!! Someday it would be nice to have a way to tell any tests that are active
            // at the time that this is happening.

            bool stopped = true;
            try
            {
                sc.Stop();
                sc.WaitForStatus( ServiceControllerStatus.Stopped, new TimeSpan( 0, 0, 30 ) ); // 30 Seconds
            }
            catch( InvalidOperationException )
            {
                Global.RO.Error( "FakeSG Service could not be stopped." );
                stopped = false;
            }
            catch( System.ServiceProcess.TimeoutException )
            {
                Global.RO.Error( "FakeSG Service could not be stopped.  Timed out waiting for stopped status." );
                stopped = false;
            }

            return stopped;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Checks if FakeSG Service is installed
        /// </summary>
        /// <returns>"FakeSGService" is found in enumeration of installed services</returns>
        private bool IsServiceInstalled()
        {
            bool installed = false;
            foreach( ServiceController sc in ServiceController.GetServices() )
            {
                if( sc.ServiceName == serviceName )
                {
                    installed = true;
                    break;
                }
            }

            if( installed && ! File.Exists( exePath ) )
            {
                Global.RO.Warn("The FakeSG Service is not installed in the default location. "  +
                    "Automatic updates will not work! Correct this by manually unistalling service and restarting runner." );
            }

            return installed;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Installs the FakeSG Service
        /// </summary>
        /// <returns>Service copied and installed</returns>
        private bool InstallService()
        {
            Global.RO.Info( "Installing FakeSG Service ..." );

            if( !Directory.Exists( dirPath ) )
                Directory.CreateDirectory( dirPath );

            if( ! CopyRequired( exeName ) ||
                ! CopyRequired( "STFCore.dll" ) ||
                ! CopyRequired( "STFLive.dll" ) ||
                ! CopyRequired( "XblCore.dll" ) ||
                ! CopyOptional( serviceName + ".pdb" ) ||
                ! CopyOptional( "STFCore.pdb" ) ||
                ! CopyOptional( "STFLive.pdb" ) ||
                ! CopyOptional( "XblCore.pdb" ) )
            {
                Global.RO.Error(
                    "FakeSG Service Directory could not be set up properly." +
                    "  Check for required files (STFCore, STFLive, and XblCore dlls) or permissions" );
                return false;
            }

            if( ! InstallUtil( exePath, true ) )
            {
                Global.RO.Error(
                    "FakeSG Service could not be installed." +
                    "  Manually running the .Net InstalUtil may be needed." );
                return false;
            }

            // Let dust settle a bit
            System.Threading.Thread.Sleep( 500 );

            return true;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        private bool UninstallService()
        {
            Global.RO.Info( "Uninstalling FakeSG Service ..." );

            if( ! InstallUtil( exePath, false ) )
            {
                Global.RO.Error(
                    "FakeSG Service could not be uninstalled."  +
                    "  Manually running the .Net InstalUtil may be needed." );
                return false;
            }

            // Let dust settle a bit
            System.Threading.Thread.Sleep( 500 );

            return true;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Copies a required file to Service directory
        /// </summary>
        /// <param name="filename">Name of file to copy</param>
        /// <returns>true if copy succedes</returns>
        private bool CopyRequired( string filename )
        {
            string destPath = Path.Combine( dirPath, filename );

            if( ! File.Exists( filename ) )
            {
                Global.RO.Error( Path.Combine( Directory.GetCurrentDirectory(), filename ) + " Doesn't Exist" );
                return false;
            }

            bool replaced = true;
            try
            {
                File.Copy( filename, destPath, true );
            }
            catch( Exception e )
            {
                Global.RO.Error( e.ToString() );
                Global.RO.Error(
                    "Couldn't copy " + Path.Combine( Directory.GetCurrentDirectory(), filename ) +
                    "to " + dirPath );

                replaced = false;
            }

            return replaced;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Copies an optional file to Service directory
        /// </summary>
        /// <param name="filename">Name of file to copy</param>
        /// <returns>true if copy succedes or file is deleted from Service directory</returns>
        private bool CopyOptional( string filename )
        {
            string destPath = Path.Combine( dirPath, filename );

            bool replacedOrDeleted = true;

            bool removeOldFile = false;
            if( File.Exists( filename ) )
            {
                try
                {
                    File.Copy( filename, destPath, true );
                }
                catch( Exception )
                {
                    removeOldFile = true;
                }
            }
            else
            {
                removeOldFile = true;
            }

            if( removeOldFile && File.Exists( destPath ) )
            {
                try
                {
                    File.Delete( destPath );
                }
                catch( Exception e )
                {
                    Global.RO.Error( e.ToString() );
                    Global.RO.Error(
                        "Couldn't delete " + destPath +
                        "when replacement couldn't be copied from " + Directory.GetCurrentDirectory() );

                    replacedOrDeleted = false;
                }
            }

            return replacedOrDeleted;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Use .NET instalutil to install or uninstall FakeSGservice
        /// </summary>
        /// <param name="fileName">Path of Service exe</param>
        /// <param name="install">True to install, False to uninstal</param>
        /// <returns>True if instalation succedes</returns>
        private bool InstallUtil( string fileName, bool install )
        {
            string installUtilPath =
                Path.Combine(Environment.GetEnvironmentVariable("windir"), @"Microsoft.NET\Framework\v2.0.50727");

            if( ! Directory.Exists( installUtilPath ) )
            {
                Global.RO.Error(".NET framework v2.0.50727 is required.");
                return false;
            }

            ProcessStartInfo psi =
                new ProcessStartInfo(
                Path.Combine( installUtilPath, "installutil.exe" ),
                (install ? "" : "/u ") + "\"" + exePath + "\"" );
            psi.RedirectStandardOutput = true;
            psi.RedirectStandardError = true;
            psi.UseShellExecute = false;
            psi.CreateNoWindow = true;

            Process p = new Process();
            p.StartInfo = psi;

            bool installed = true;
            try
            {
                p.Start();
                p.WaitForExit();
                if( p.ExitCode != 0 )
                {
                    Global.RO.Error(
                        "InstallUtil failed with exit code: "+ p.ExitCode +
                        "\n Standard Out:\n" + p.StandardOutput.ReadToEnd() +
                        "\n Standard Error:\n" + p.StandardError.ReadToEnd() );
                    installed = false;
                }
            }
            catch( Exception e )
            {
                Global.RO.Error(
                    "InstallUtil failed." +
                    "\n Standard Out:\n" + p.StandardOutput.ReadToEnd() +
                    "\n Standard Error:\n" + p.StandardError.ReadToEnd() +
                    "\n Exception\n" + e );
                installed = false;
            }

            return installed;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Sets up Remoting connection to Service
        /// </summary>
        /// <returns>Version Number compitled into FakeSG Service exe.</returns>
        private int InitRemoteControl()
        {
            if( ChannelServices.GetChannel( "tcp" ) == null )
                ChannelServices.RegisterChannel( new TcpChannel(), false );
            if( RemotingConfiguration.IsWellKnownClientType( typeof(FakeSGRemoteController) ) == null )
            {
                WellKnownClientTypeEntry remotetype = new WellKnownClientTypeEntry( typeof(FakeSGRemoteController), "tcp://localhost:9900/RemoteFakeSGService");
                RemotingConfiguration.RegisterWellKnownClientType( remotetype );
            }

            FakeSGRemoteController rc = new FakeSGRemoteController();
            if( rc == null )
            {
                Global.RO.Error(
                    "Could not establish Remoting Connection with Fake SG Service." );
                return -1;
            }

            int serviceVersion = -1;
            try
            {
                serviceVersion = rc.GetServiceVersion();
            }
            catch( Exception e )
            {
                Global.RO.Error(
                    "Could not Get Service Version via Remoting Connection with Fake SG Service.\n" +
                    "Exception:\n" + e );
            }

            return serviceVersion;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Tries to make sure correct version of FakeSG Service is running and connect to it.
        /// </summary>
        /// <returns></returns>
        public bool ConnectToService()
        {
            bool retry = false;

            // Break out of this loop when correct verion of service is running
            // All other error cases, including the case of a retry, returns false directly
            while( true )
            {
                if( retry || ! IsServiceRunning() )
                {
                    if( retry || ! StartService() )
                    {
                        if( ! retry && IsServiceInstalled() )
                        {
                            Global.RO.Error(
                                "FakeSG Service appears to be installed.\n"+
                                "  Check event log to see why it wouldn't start and/or try to start it manually" );
                            return false;
                        }

                        if(	! InstallService() )
                        {
                            return false;
                        }

                        if( ! StartService() )
                        {
                            Global.RO.Error(
                                "  Check event log to see why it wouldn't start and/or try to start it manually" );
                            return false;
                        }
                    }
                }

                // At this point it is certain the sevice is started
                int serviceVersion = InitRemoteControl();
                if( serviceVersion == GetCompiledVersion() )
                {
                    break; // out of retry loop
                }
                if( (serviceVersion == -1) && retry )
                {
                    Global.RO.Error("Check event log to try to find out why and/or try to reststart it manually" );

                    return false;
                }
                else if( serviceVersion > GetCompiledVersion() )
                {
                    Global.RO.Error("Test Version "+GetCompiledVersion()+" is different than Service Version "+serviceVersion+".");

                    //uninstall and reinstall the older version
                    if( ! StopService() )
                    {
                        Global.RO.Error("Check event log to see why it wouldn't stop and/or try to stop it manually" );
                        return false;
                    }

                    if( ! UninstallService() )
                    {
                        return false;
                    }

                    retry = true;
                    continue;
                }

                // At this point the service has a lower version than the client
                if( retry )
                {
                    Global.RO.Error(
                        "Test Version "+GetCompiledVersion()+" is still different than Service Version "+serviceVersion+"."+
                        "  Recompile Test with latest Server Test Framework " );
                    return false;
                }

                Global.RO.Info("FakeSG Service is the wrong version.  Replacing...");

                if( ! StopService() )
                {
                    Global.RO.Error("Check event log to see why it wouldn't stop and/or try to stop it manually" );
                    return false;
                }

                if( ! UninstallService() )
                {
                    return false;
                }

                retry = true;
            }

            // Correct version of the service is running and remoting connection has been made

            if( ! mmf.DoesFileExist() )
            {
                Global.RO.Error(
                    "Memory Mapped File for AuthData hasn't been created by Service\n"+
                    "  Check event log to try to find out why" );
                return false;
            }

            FakeSGRemoteController rc = new FakeSGRemoteController();
            int servicedinterfaces = rc.GetServicedInterfaceCount();
            SetUpMMF( servicedinterfaces );
            System.Threading.Thread.Sleep(500);  // For some reason it takes a teeny bit of time for the MMF to be created or something so we need to wait a little bit.

            if( header->Version != GetCompiledVersion() )
            {
                Global.RO.Error(
                    "Memory Mapped File version "+header->Version+" is different than Test version "+GetCompiledVersion()+"\n"+
                    "  Make sure that all FakeSGService binaries were compiled with the latest version\n" +
                    "  or Try Rebooting to clear any stray tests that could be keeping a bad MMF around" );
                return false;
            }

            for( int i = 0; i < servicedinterfaces; ++i )
            {
                int offset = i * tableSize;
                mmfInterfaces[ rc.GetServicedInterface( offset ) ] = offset;
            }

            return true;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Get a block of slot data ready to be loaded
        /// </summary>
        /// <returns>Fresh new SPI Auth data</returns>
        public CSGInfo GetSlot()
        {
            CSGInfo newSlot = new CSGInfo();
            newSlot.Initialize();
            return newSlot;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Set a block of SPI Auth data to the Service to use
        /// </summary>
        /// <param name="slot">Loaded SPI Auth Data</param>
        /// <param name="srcIp">IP address of interface XRL request was sent out on</param>
        public void PutSlot( ref CSGInfo Slot, IPAddress srcIp )
        {
            int interfaceIndex = 0;
            if (mmfInterfaces.ContainsKey(srcIp))
            {
                interfaceIndex = (int)mmfInterfaces[srcIp];
            }

            CSGInfo* pMirror = (CSGInfo*)( slotPtrs + interfaceIndex);
            pMirror[ Slot.port ] = Slot;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Loads an SGInfo slot with the info stored in the service's
        /// xbox table.  This can be used to
        /// </summary>
        /// <param name="sgInfo">The slot to be loaded</param>
        /// <param name="xboxId">The machine ID of the xbox to use</param>
        public void LoadSlot( ref CSGInfo sgInfo, ulong xboxId )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.LoadSlot( ref sgInfo, xboxId );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Adds an xbox to the service's table.  Represents an xbox connecting to an SG.
        /// </summary>
        /// <param name="sgIp"></param>
        /// <param name="spi"></param>
        /// <param name="xboxId"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVer"></param>
        /// <param name="titleRegion"></param>
        /// <param name="key"></param>
        /// <param name="clientVersion"></param>
        /// <param name="clientType"></param>
        public void AddXbox(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, CSGInfo.ClientType clientType, uint languageId)
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.AddXbox( sgIp, spi, xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId );
        }

		
        ///////////////////////////////////////////////////
        /// <summary>
        /// Removes an xbox to the service's table.  
        /// </summary>
        /// <param name="xboxId"></param>
        public void RemoveXbox( ulong xboxId )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.RemoveXbox( xboxId );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Disconnect the xbox in the fake sg and send the CSgMsgNotifyDelete for the removed
		/// xbox.
        /// </summary>
        /// <param name="xboxId"></param>
		public void DeadXbox( ulong xboxId )
		{
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.DeadXbox( xboxId );
		}

		/// <summary>
		/// Clear the FakeSG of any knoledge of XBoxes. Propogate the clear to the presence server.
		/// </summary>
		public void ClearXboxes()
		{
			FakeSGRemoteController rc = new FakeSGRemoteController();
			rc.ClearXboxes();
		}

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents an xbox changing titles.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVer"></param>
        /// <param name="titleRegion"></param>
        public void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetTitle( xboxId, titleId, titleVer, titleRegion );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Sets a single Alt Title
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="titleId"></param>
        /// <param name="pos"></param>
        public void SetAltTitle( ulong xboxId, uint titleId, int pos )
        {
            uint[] altTitleIds = new uint[4];
            altTitleIds[pos] = titleId;

            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetAltTitles( xboxId, altTitleIds );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Sets full set of Alt Titles
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="altTitleIds"></param>
        public void SetAltTitles( ulong xboxId, uint[] altTitleIds )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetAltTitles( xboxId, altTitleIds );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Changes key
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="key"></param>
        public void SetKey( ulong xboxId, byte[] key )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetKey( xboxId, key );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Update state in presence for a xbox with connected user.
        /// TitleId is opaque and contain XBOX 1 state or Xenon state but the length
        /// of titleData cannot exceed 256 bytes.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        /// <param name="matchId"></param>
        /// <param name="state"></param>
        /// <param name="titleId"></param>
        /// <param name="titleData"></param>
        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen)
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetUserState( xboxId, userId, matchSessionId, state, titleData, titleDataLen);
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Set the endpoint that the fake SG will use to send client state updates.
		/// Should be of the form IP:PORT
        /// </summary>
        /// <param name="endpoint"></param>
        public void SetStateEndpoint(string endpoint)
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetStateEndpoint(endpoint);
        }

		///////////////////////////////////////////////////
        /// <summary>
        /// Set the endpoint that the fake SG will use to send client state updates.
        /// </summary>
        /// <param name="endpoint"></param>
        public void SetEnableStateBatching(bool enable, uint intervalmiliSeconds)
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.SetEnableStateBatching(enable, intervalmiliSeconds);
        }
        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents a user being logged on.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public void AddUser( ulong xboxId, ulong userId, uint userFlags )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.AddUser( xboxId, userId, userFlags );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents a user being logged off.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public void RemoveUser( ulong xboxId, ulong userId )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            rc.RemoveUser( xboxId, userId );
        }
		
        ///////////////////////////////////////////////////
        /// <summary>
        /// Queries an xbox in the service's table.  Gets current number of users on xbox.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public byte GetUserCount( ulong xboxId )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            return rc.GetUserCount( xboxId );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Queries an xbox in the service's table.  Gets current Qflags for a user.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public bool ReadUserQValPacket( ulong xboxId, ulong userId, out QValPacket packet )
        {
            FakeSGRemoteController rc = new FakeSGRemoteController();
            return rc.ReadUserQValPacket( xboxId, userId, out packet );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\IFakeSGClient.cs ===
﻿using System;
using System.Net;

namespace ServerTestFramework.LiveService.FakeSG
{
    /// <summary>
    /// An interface for allowing different implementations of a 'fake' SG.
    /// </summary>
    /// <remarks>
    /// 'Slots' are used for authdata lookup requests.
    /// 'Xboxs' are used for qval related stuff.
    /// </remarks>
	public interface IFakeSGClient
    {
        /// <summary>
        /// Tries to make sure the correct version of FakeSG Service is running and connect to it.
        /// </summary>
        /// <returns>True if it is running and the correct version; false otherwise.</returns>
        bool ConnectToService ();

        /// <summary>
        /// Instructs the IFakeSGClient to stop operation and free resources.
        /// Use of the IFakeSGClient after calling Shutdown is undefined.
        /// </summary>
        void Shutdown ();

        /// <summary>
        /// Gets a new, initialized CSGInfo struct.
        /// </summary>
        /// <returns>Fresh new SPI Auth data.</returns>
        CSGInfo GetSlot ();

        /// <summary>
        /// Sets the CSGInfo data for a given IP:Port.
        /// </summary>
        /// <param name="slot">The authdata to set (contains the port).</param>
        /// <param name="srcIp">IP address of interface XRL request was sent out on.</param>
        void PutSlot (ref CSGInfo Slot, IPAddress srcIp);

        /// <summary>
        /// Reads the CSGInfo data based on the given xboxid.
        /// </summary>
        /// <param name="sgInfo">The target CSGInfo struct.</param>
        /// <param name="xboxId">The machine ID of the xbox to look up.</param>
        void LoadSlot (ref CSGInfo sgInfo, ulong xboxId);

        /// <summary>
        /// Adds or updates xbox information that is given.
        /// </summary>
        void AddXbox (uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, 
            byte[] key, ulong clientVersion, CSGInfo.ClientType clientType, uint languageId);

        /// <summary>
        /// Removes an xbox from the list.
        /// </summary>
        /// <param name="xboxId">The xbox to remove.</param>
        void RemoveXbox (ulong xboxId);

        /// <summary>
        /// Sends a dead xbox message and removes it from the list.
        /// FakeSGService only sends the dead xbox message to presence.
        /// </summary>
        /// <param name="xboxId">The xbox to remove.</param>
        void DeadXbox (ulong xboxId);

		/// <summary>
		/// Removes all xboxs.  Analogous to calling DeadXbox on every xbox.
		/// </summary>
        void ClearXboxes ();

        /// <summary>
        /// Update the title information for an xbox.
        /// </summary>
        void SetTitle (ulong xboxId, uint titleId, uint titleVer, uint titleRegion);

        /// <summary>
        /// Changes the alternate titles for an xbox.  The given title will be the only alternate title.
        /// </summary>
        void SetAltTitle (ulong xboxId, uint titleId, int pos);

        /// <summary>
        /// Changes the alternate titles for an xbox.
        /// </summary>
        void SetAltTitles (ulong xboxId, uint[] altTitleIds);

        /// <summary>
        /// Sets the authdata abkey for the given xbox.
        /// </summary>
        void SetKey (ulong xboxId, byte[] key);

        /// <summary>
        /// Update state in presence for an xbox with connected user.
        /// TitleId is opaque and can contain XBOX 1 state or Xenon state but the length
        /// of titleData cannot exceed 256 bytes.
        /// 
        /// Does actually cause state update to be queued and sent to presence eventually.
        /// </summary>
        void SetUserState (ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen);

        /// <summary>
        /// Set the endpoint that the fake SG will use to send client state updates (/xpnfront/state.ashx).
		/// Should be of the form IP:PORT.
        /// </summary>
        void SetStateEndpoint (string endpoint);

        /// <summary>
        /// Set the batching state and interval for user updates.
        /// </summary>
        void SetEnableStateBatching (bool enable, uint intervalmiliSeconds);

        /// <summary>
        /// Add a user to the xbox or modify their flags.
        /// </summary>
        void AddUser (ulong xboxId, ulong userId, uint userFlags);

        /// <summary>
        /// Removes a user from the xbox.
        /// </summary>
        void RemoveUser (ulong xboxId, ulong userId);
		
        /// <summary>
        /// Gets the number of users on a given xbox.
        /// </summary>
        byte GetUserCount (ulong xboxId);

        /// <summary>
        /// Reads a qval packet from the user's queue.
        /// </summary>
        bool ReadUserQValPacket (ulong xboxId, ulong userId, out QValPacket packet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Feedback\xrlUserComplaint.cs ===
using System;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Feedback
{

	public enum PlayerReview : uint

	{
		Prefer = 0,
		AvoidTrashTalk = 1,
		AvoidLanguage = 2,
		AvoidDisruptive = 3,
		AvoidAggressive = 4,
		AvoidUnsporting = 5,
		AvoidDisconnect = 6,
		AvoidUnskilled = 7,
		AvoidTooGood = 8,
		AvoidUnfamiliar = 9,


		// Add new review types here
	}
        
	// 
	// Enumeration of player review types
	//  Maps to ??? in xonline.x
	//
	public enum ComplaintType : uint
	{
		OffensiveGamertag = 0,
		OffensiveMotto = 1,
		OffensiveTextMessage = 2,
		OffensiveVoiceMail = 3,
		OffensiveVoiceChat = 4,
		OffensiveInGame = 5,
		TamperingFeedback = 6,
		TamperingSystem = 7,
		TamperingCheating = 8,
		OffensiveUserContent = 9,
		OffensiveVideoMessage = 10,
		OffensiveVideoChat = 11,
		OffensiveGamerPicture = 12,
		OffensiveInGameVideo = 13,
		OffensivePhotoMessage  = 14,
        OffensiveUrl = 15,
        ChildAbuse = 16,

		// Add new complaint types here
  
	}
        

	/// <summary>
	/// Summary description for xrlUserComplaint.
	/// </summary>
	public class SubmitComplaintRequest : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong   senderPUID;
		public ulong   targetPUID;
		[XRLPayloadFld(IsTitleId=true)]
		public uint    titleID;
		public uint    type;
		public ulong   context;

		[WireInfo(Serialize=false)]
		public Modify Modifyflag = Modify.None;
		public SubmitComplaintRequest()
		{
		}
		
		public SubmitComplaintRequest(ulong spuid, ulong tpuid,uint title, uint ftype,ulong cont)
		{
			senderPUID= spuid;
			targetPUID=tpuid;
			titleID=title;
			type=ftype;
			context=cont;
			ServiceId = XOService.Feedback;

		}
	
		protected override string GetServiceName()
		{
			return "/fbserver/submitcomplaint.ashx";
		}


		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			if(Modifyflag == Modify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if (Modifyflag == Modify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			ManualSlotSetup=true;
		}

		new public Response Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);

			if(Modifyflag != Modify.None )
				ManualPopulateSlot();
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			// create a streem here and then read all data;
			Response Resp = new Response();
			Resp.Xerr=xAct.XErr;
			return Resp;
		}
	}


	public class Response
	{
		public uint Xerr=0;
	}

	public class InvalidFBRequest : XRLPayload
	{
		int _bytestosend=0;
		string _url=null;

		public InvalidFBRequest(int bytestosend,string url)
		{
			_bytestosend=bytestosend;
			_url=url;
		}
		
		protected override string GetServiceName()
		{
			return _url;
		}
		
		

		new public uint Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			byte[] buffer = new byte[_bytestosend];
			Random rand = new Random();
			rand.NextBytes(buffer);
			BinaryWriter writer = new  BinaryWriter(reqStream);
			writer.Write(buffer);
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			return this.XErr;
		}


	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FakeSG\SGInfo.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;

using xonline.common.protocol;

using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using xonline.common.service;

namespace ServerTestFramework.LiveService.FakeSG
{
    [Serializable()]
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct CSGInfo
    {
        private static RandomEx randGen = new RandomEx();

        public uint inaSg;
        public uint SpiSg;

        public uint   ipaI;
        public ushort ipportI;
        public long   liNonce;

        public ulong machinePuid;

        public uint titleId;
        public uint titleVersion;
        public uint titleRegion;

        public uint consoleRegion; // v3
        public uint mediaID;  // v3
        public ushort languageID;  // v3
        public uint authDataFlags;  // v3

        // clientVersion
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;

        public ulong clientVersion
        {
            get { return ClientVersion.Create(wMajorVersion, wMinorVersion, wQFENumber, wBuildNumber); }
            set 
            { 
                ClientVersion version = new ClientVersion(value);
                wMajorVersion = version.wMajorVersion;
                wMinorVersion = version.wMinorVersion;
                wQFENumber = version.wQFENumber;
                wBuildNumber = version.wBuildNumber;
            }
        }

        public ulong userPuid0;
        public ulong userPuid1;
        public ulong userPuid2;
        public ulong userPuid3;

        // dwUserFlags - bit layout
        //
        //Byte 0:
        //Bits 0-1: guest number                        { as calculated by XKDC }
        //Bits 2-4: no show rating                      { as calculated by XKDC }
        //Bits 5-7: disconnect rating                   { as calculated by XKDC }
        //
        //Byte 1:
        //Bits 8-15: country id                         { from country field in t_users }
        //
        //Byte 2:
        //Bit 16: user voice not allowed flag           { as calculated by XKDC }
        //Bit 17: user purchase not allowed flag        { from si_ticket_flags in t_users }
        //Bit 18: user nickname not allowed flag        { from si_ticket_flags in t_users }
        //Bit 19: user shared content not allowed flag  { from si_ticket_flags in t_users }
        //Bits 20-23: user's tier id	                { as calculated by XKDC, this is new }
        //
        //Byte 3:
        //Bit 24: Account has parent-child relationship { calculated by XKDC, owner puid different in t_users }
        //Bits 25-31: unknown                           { from si_ticket_flags in t_users }
        //
        public uint userFlag0;
        public uint userFlag1;
        public uint userFlag2;
        public uint userFlag3;

        //AuthdataV3 only - privileges are shared by all users
        // The way services are implemented is very different from AuthData v2. 
        // dwPrivileges[8] is a 256 bit array.  Bits 0-127 are for services, and the bits
        // counting down from 256 are for privileges.  Overflow services, ones that have a
        // value outside the 0-127 range, are stored in the dwServiceID[4] array, which can 
        // only hold 4 of these.  Things like PSO and LSP sites use this, I suppose.
        public ushort wNumPrivileges;
        public uint dwPrivileges4;
        public uint dwPrivileges5;
        public uint dwPrivileges6;
        public uint dwPrivileges7;

        //AuthdataV4 only - 96 privileges are per-user, 32 privileges are for machines
        public uint dwPrivileges5User0;
        public uint dwPrivileges6User0;
        public uint dwPrivileges7User0;
        public uint dwPrivileges5User1;
        public uint dwPrivileges6User1;
        public uint dwPrivileges7User1;
        public uint dwPrivileges5User2;
        public uint dwPrivileges6User2;
        public uint dwPrivileges7User2;
        public uint dwPrivileges5User3;
        public uint dwPrivileges6User3;
        public uint dwPrivileges7User3;

        //services (upper 128 bits of the shared privilege blocks hold services here)
        public uint dwPrivileges0;
        public uint dwPrivileges1;
        public uint dwPrivileges2;
        public uint dwPrivileges3;
        public ushort wNumDwordServices;
        public uint dwServiceID0;
        public uint dwServiceID1;
        public uint dwServiceID2;
        public uint dwServiceID3;

        public float userTrust0;
        public float userTrust1;
        public float userTrust2;
        public float userTrust3;

        public uint altTitleId0;
        public uint altTitleId1;
        public uint altTitleId2;
        public uint altTitleId3;

        public byte key00;
        public byte key01;
        public byte key02;
        public byte key03;
        public byte key04;
        public byte key05;
        public byte key06;
        public byte key07;
        public byte key08;
        public byte key09;
        public byte key10;
        public byte key11;
        public byte key12;
        public byte key13;
        public byte key14;
        public byte key15;

        public ulong flowToken;


        // Not part of wiredata
        //

        // Our initial array of slots is set to all zeroes.  This field used to be "UserNotFound", which when 
        // set to 0, means the user WAS found.  This is incorrect.  By default, I want the user to not
        // be found, until the slot gets populated.  Changing name to "UserExists".
        public byte UserExists;
        public ushort port;


        public enum ClientType : uint
        {
            Xbox,
            Xenon,
            XenonBackCompat,
            PC
        }

        public static class ClientInfo
        {
            public const UInt64 Mask                = 0xFFFF000000000000;

            public const UInt64 UserBase            = 0x0009000000000000;
            public const UInt64 XboxMachineBase     = 0x0009000000000000;
            public const UInt64 XenonConsoleBase    = 0xF000000000000000;
            public const UInt64 XenonMachineBase    = 0xFA00000000000000;
            public const UInt64 PcMachineBase       = 0xFB00000000000000;

            public static ulong ToMachineBase(CSGInfo.ClientType clientType)
            {
                switch (clientType)
                {
                    case ClientType.Xbox:
                        return XboxMachineBase;
                    case ClientType.Xenon:
                    case ClientType.XenonBackCompat:
                        return XenonMachineBase;
                    case ClientType.PC:
                        return PcMachineBase;
                    default:
                        throw new Exception("Unknown client type: " + clientType.ToString());
                }
            }

            public static CSGInfo.ClientType ToClientType(ulong machinePuid)
            {
                if (IsXenonMachinePuid(machinePuid))
                {
                    return ClientType.Xenon;
                }
                else if (IsXboxMachinePuid(machinePuid))
                {
                    return ClientType.Xbox;
                }
                else if (IsPcMachinePuid(machinePuid))
                {
                    return ClientType.PC;
                }

                throw new Exception(String.Format("Unable to determine client type from machine PUID: 0x{0:X16}", machinePuid));
            }

            public static bool IsUserPuid(ulong id) { return (id & Mask) == UserBase; }
            public static bool IsXboxMachinePuid(ulong id) { return (id & Mask) == XboxMachineBase; }
            public static bool IsXenonMachinePuid(ulong id) { return (id & Mask) == XenonMachineBase; }
            public static bool IsPcMachinePuid(ulong id) { return (id & Mask) == PcMachineBase; }
        }

        public const uint AUTHDATA_FLAGS_ISXENON            = 0x01;  // Legacy
        public const uint AUTHDATA_FLAGS_ISXENONBACKCOMPAT  = 0x02;  // Fusion
        public const uint AUTHDATA_FLAGS_ISDEVKIT           = 0x04;  // Devkit Xenon console
        public const uint AUTHDATA_FLAGS_ISTESTKIT          = 0x08;  // Testkit Xenon console
        public const uint AUTHDATA_FLAGS_ISBETAMACHINE      = 0x10;  // Machine marked for betas (t_machines.i_beta_title_id != 0)

        public const ulong DefaultMachineId = 0xFA00FFFFFFFFFFFF;

        public void SetClientType(ClientType type)
        {
            // dwAuthDataFlags is no longer the main indicator of platform type. It used 
            // to be.  See XkdcPolicy.cpp and xonline.x to see how thigns are really done.  
            // It's only really used to differentiate fusion from Xbox360 (same machine 
            // puid), and to identify devkits and testkits from retail boxes. It is also 
            // used in a legacy manner to indicate regular Xbox360(Xenon) boxes, but this 
            // may go away soon.
            authDataFlags = 0;
            switch (type)
            {
                case ClientType.Xenon:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENON;
                    break;
                case ClientType.XenonBackCompat:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENONBACKCOMPAT;
                    break;
            }

            // If the machine puid is still the default one, we'll generate a new random 
            // one that is correct for your client type.  Otherwise, you're on your own 
            // and are expected to get it right.
            if (machinePuid == DefaultMachineId)
            {
                machinePuid = randGen.GenerateRandomMachineId(type);
            }

            // Here's the check. Let's not do it.
//             UInt64 machineBase = ClientInfo.ToMachineBase(type);
//             if ((machineBase & machinePuid) != machineBase)
//             {
//                 throw new Exception("machine puid doesn't match your client type");
//             }
            
        }

        /// <summary>
        /// Changes ClientType to the one needed because SetClientType only works once
        ///     After machinePuid is newly generated, it's set permanently.
        /// </summary>
        /// <param name="type">Client Type Enum</param>
        public void ChangeClientType(ClientType type)
        {
            authDataFlags = 0;
            switch (type)
            {
                case ClientType.Xenon:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENON;
                    break;
                case ClientType.XenonBackCompat:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENONBACKCOMPAT;
                    break;
            }

            machinePuid = randGen.GenerateRandomMachineId(type);
        }

        public bool IsClientXbox
        {
            get
            {
                return ClientInfo.IsXboxMachinePuid(machinePuid);
            }
        }
        public bool IsClientXenon
        {
            get
            {
                return ClientInfo.IsXenonMachinePuid(machinePuid) 
                    && ((authDataFlags & AUTHDATA_FLAGS_ISXENON) == AUTHDATA_FLAGS_ISXENON);
            }
        }
        public bool IsClientXenonBackcompat
        {
            get
            {
                return ClientInfo.IsXenonMachinePuid(machinePuid) 
                    && ((authDataFlags & AUTHDATA_FLAGS_ISXENONBACKCOMPAT) == AUTHDATA_FLAGS_ISXENONBACKCOMPAT);
            }
        }
        public bool IsClientPC
        {
            get
            {
                return ClientInfo.IsPcMachinePuid(machinePuid);
            }
        }
        public bool IsClientDevkit
        {
            get
            {
                return ((authDataFlags & AUTHDATA_FLAGS_ISDEVKIT) == AUTHDATA_FLAGS_ISDEVKIT);
            }
        }
        public bool IsClientTestkit
        {
            get
            {
                return ((authDataFlags & AUTHDATA_FLAGS_ISTESTKIT) == AUTHDATA_FLAGS_ISTESTKIT);
            }
        }

        public const string TestCaseFlowtokenKey = "CSGInfo.Flowtoken";

        /// <summary>
        /// Gets the test case flowtoken that is associated with the current thread.
        /// </summary>
        /// <returns>The test case flowtoken that is associated with the current thread.</returns>
        public static ulong GetTestCaseFlowtoken ()
        {
            ulong ans;
            ThreadTracker.TryGetSetDefault(TestCaseFlowtokenKey, out ans, RandomEx.GlobalRandGen.NextUlong());
            return ans;
        }


        public void Initialize()
        {
            machinePuid = DefaultMachineId;
            titleId = 0xFFFE0000;
            titleVersion = 1;

            clientVersion = 0;

            userFlag0 = 0x00006700;
            userFlag1 = 0x00006700;
            userFlag2 = 0x00006700;
            userFlag3 = 0x00006700;

            flowToken = GetTestCaseFlowtoken();

            ClearServices();

            AddService(XOService.Base_Subscription);
            AddService(XOService.User_Account);
            AddService(XOService.Billing_Offering);
            AddService(XOService.Signature_Server);
            AddService(XOService.Stats);
            AddService(XOService.Storage);
            AddService(XOService.PresNotification);
            AddService(XOService.DRM);
            AddService(XOService.Crypto);
            AddService(XOService.Lists);
            AddService(XOService.Liveinfo);

            // set up defaults
            SetPrivilege(XOn.XPRIVILEGE_ADD_FRIEND);
            SetPrivilege(XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
            SetPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS);
            SetPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            SetPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            SetPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_PURCHASE_CONTENT);
            SetPrivilege(XOn.XPRIVILEGE_PRESENCE);
            SetPrivilege(XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
            SetPrivilege(XOn.XPRIVILEGE_BILLING_SWITCHING);
            SetPrivilege(XOn.XPRIVILEGE_PASSPORT_SWITCHING);  
            SetPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
            SetPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_CLOUD_SAVED_GAMES);
            


            UserExists = 1;
        }

        private const uint USER_TIERID_MASK = 0x00F00000;
        private const byte USER_TIERID_SHIFT = 20;

        public void SetTier(int userSlot, uint tier)
        {
            uint tierbits = (uint)((tier << USER_TIERID_SHIFT) & USER_TIERID_MASK);
            switch (userSlot)
            {
                case 0:
                    userFlag0 = (userFlag0 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 1:
                    userFlag1 = (userFlag1 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 2:
                    userFlag2 = (userFlag2 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 3:
                    userFlag3 = (userFlag3 & ~USER_TIERID_MASK) | tierbits;
                    break;
            }
        }

        public uint GetTier(int userSlot)
        {
            switch (userSlot)
            {
                case 0:
                    return ((userFlag0 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 1:
                    return ((userFlag1 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 2:
                    return ((userFlag2 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 3:
                    return ((userFlag3 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
            }
            return 0;
        }

        public void SetRegionInfo(uint countryID, uint languageID)
        {
            if (languageID != 0)
            {
                this.languageID = (ushort)languageID;
                this.userFlag0 = UserFlagsUtil.SetUserLanguageId(this.userFlag0, languageID);
                this.userFlag1 = UserFlagsUtil.SetUserLanguageId(this.userFlag1, languageID);
                this.userFlag2 = UserFlagsUtil.SetUserLanguageId(this.userFlag2, languageID);
                this.userFlag3 = UserFlagsUtil.SetUserLanguageId(this.userFlag3, languageID);
            }

            if (countryID != 0)
            {
                this.userFlag0 = UserFlagsUtil.SetUserCountryId(this.userFlag0, countryID);
                this.userFlag1 = UserFlagsUtil.SetUserCountryId(this.userFlag1, countryID);
                this.userFlag2 = UserFlagsUtil.SetUserCountryId(this.userFlag2, countryID);
                this.userFlag3 = UserFlagsUtil.SetUserCountryId(this.userFlag3, countryID);
            }
        }

        public byte[] Key
        {
            get
            {
                byte[] k = new byte[16];
                k[0] = this.key00;
                k[1] = this.key01;
                k[2] = this.key02;
                k[3] = this.key03;
                k[4] = this.key04;
                k[5] = this.key05;
                k[6] = this.key06;
                k[7] = this.key07;
                k[8] = this.key08;
                k[9] = this.key09;
                k[10] = this.key10;
                k[11] = this.key11;
                k[12] = this.key12;
                k[13] = this.key13;
                k[14] = this.key14;
                k[15] = this.key15;
                return k;
            }
        }

        public bool SetKey(byte[] key)
        {
            if (key.GetLength(0) != 16)
            {
                Debug.Assert(true, "key must be 16 bytes!", "");
                return false;
            }
            this.key00 = key[0];
            this.key01 = key[1];
            this.key02 = key[2];
            this.key03 = key[3];
            this.key04 = key[4];
            this.key05 = key[5];
            this.key06 = key[6];
            this.key07 = key[7];
            this.key08 = key[8];
            this.key09 = key[9];
            this.key10 = key[10];
            this.key11 = key[11];
            this.key12 = key[12];
            this.key13 = key[13];
            this.key14 = key[14];
            this.key15 = key[15];

            return true;
        }

        //note that this also clears priviliges
        public void ClearServices()
        {
            this.wNumPrivileges = 0;
            this.wNumDwordServices = 0;
            this.dwPrivileges0 = 0;
            this.dwPrivileges1 = 0;
            this.dwPrivileges2 = 0;
            this.dwPrivileges3 = 0;
            this.dwPrivileges4 = 0;
            this.dwPrivileges5 = 0;
            this.dwPrivileges6 = 0;
            this.dwPrivileges7 = 0;
            this.dwServiceID0 = 0;
            this.dwServiceID1 = 0;
            this.dwServiceID2 = 0;
            this.dwServiceID3 = 0;

            dwPrivileges5User0=0;
            dwPrivileges6User0=0;
            dwPrivileges7User0=0;
            dwPrivileges5User1=0;
            dwPrivileges6User1=0;
            dwPrivileges7User1=0;
            dwPrivileges5User2=0;
            dwPrivileges6User2=0;
            dwPrivileges7User2=0;
            dwPrivileges5User3=0;
            dwPrivileges6User3=0;
            dwPrivileges7User3=0;
        }

        unsafe public bool ClearService(XOService service) { return ClearService((int)service); }
        unsafe public bool ClearService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.ClearValue);
        }

        unsafe public bool GetService(XOService service) { return GetService((int)service); }
        unsafe public bool GetService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.GetValue);
        }

        unsafe public bool AddService(XOService service) { return AddService((int)service); }
        unsafe public bool AddService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.SetValue);
        }

        //this should be avoided going forward - sets the privilege for all users
        public void SetPrivilege(uint priv)
        {
            if (priv<128 || priv>255) //privileges as a whole are in the range 128-255
            {
                throw new ArgumentException(priv+" is not a valid privilege number.");
            }

            if (priv>=160)
            {
                SetUserPrivilege(0, priv);
                SetUserPrivilege(1, priv);
                SetUserPrivilege(2, priv);
                SetUserPrivilege(3, priv);
            }
            else
            {
                SetMachinePrivilege(priv);
            }
        }

        //sets the privilege for a specific user in the v4 authdata, or all users in the v3 authdata
        public unsafe void SetUserPrivilege(int userIndex, uint priv)
        {
            if (priv<160 || priv>255) //per-user privileges are in the range 160-255
            {
                throw new ArgumentException(priv+" is not a valid user privilege number.");
            }

            uint dwordIndex=priv/32;    // 5...7
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, true);
            }

            //per-user
            uint userDwordIndex=(uint)userIndex*3;
            dwordIndex-=5; //0..2
            fixed (uint* pSpecificPriv=&dwPrivileges5User0)
            {
                SetDwordBlockBit(pSpecificPriv, userDwordIndex+dwordIndex, bitIndex, true);
            }

            CountSharedPrivileges();
        }

        //this should be avoided going forward - clears the privilege for all users
        public unsafe void UnsetPrivilege(uint priv)
        {
            if (priv<128 || priv>255) //privileges as a whole are in the range 128-255
            {
                throw new ArgumentException(priv+" is not a valid privilege number.");
            }

            if (priv>=160)
            {
                UnsetUserPrivilege(0, priv);
                UnsetUserPrivilege(1, priv);
                UnsetUserPrivilege(2, priv);
                UnsetUserPrivilege(3, priv);
            }
            else
            {
                UnsetMachinePrivilege(priv);
            }
        }

        //sets the privilege for a specific user in the v4 authdata, or all users in the v3 authdata
        public unsafe void UnsetUserPrivilege(int userIndex, uint priv)
        {
            if (priv<160 || priv>255) //per-user privileges are in the range 160-255
            {
                throw new ArgumentException(priv+" is not a valid user privilege number.");
            }

            uint dwordIndex=priv/32;    // 5...7
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, false);
            }

            //per-user
            uint userDwordIndex=(uint)userIndex*3;
            dwordIndex-=5; //0..2
            fixed (uint* pSpecificPriv=&dwPrivileges5User0)
            {
                SetDwordBlockBit(pSpecificPriv, userDwordIndex+dwordIndex, bitIndex, false);
            }

            CountSharedPrivileges();
        }

        public unsafe void SetMachinePrivilege(uint priv)
        {
            if (priv<128 || priv>=160) //machine privileges in the range 128-159
            {
                throw new ArgumentException(priv+" is not a valid machine privilege number.");
            }

            uint dwordIndex=priv/32;    // 4 always
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, true);
            }

            CountSharedPrivileges();
        }

        public unsafe void UnsetMachinePrivilege(uint priv)
        {
            if (priv<128 || priv>=160) //machine privileges in the range 128-159
            {
                throw new ArgumentException(priv+" is not a valid machine privilege number.");
            }

            uint dwordIndex=priv/32;    // 4 always
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, false);
            }

            CountSharedPrivileges();
        }

        private void CountSharedPrivileges()
        {
            wNumPrivileges=0;
            for (int i=0; i<32; ++i)
            {
                wNumPrivileges+=(ushort)(0!=(dwPrivileges4&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges5&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges6&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges7&(1<<i))?1:0);
            }
        }

        unsafe private void SetDwordBlockBit(uint *dwordBase, uint dwordOffset, uint bit, bool set)
        {
            if (set)
            {
                dwordBase[dwordOffset]|=(uint)(1<<(int)bit);
            }
            else
            {
                dwordBase[dwordOffset]&=~(uint)(1<<(int)bit);
            }
        }

        public ulong GetUserPuid(int index)
        {
            ulong puid = 0;
            switch (index)
            {
                case 0:
                    puid = this.userPuid0;
                    break;
                case 1:
                    puid = this.userPuid1;
                    break;
                case 2:
                    puid = this.userPuid2;
                    break;
                case 3:
                    puid = this.userPuid3;
                    break;
                default:
                    throw new Exception("There are only 4 users in the SGInfo and you asked for #" + index);
            }
            return puid;                
        }

        public void SetUserPuid(int index, ulong userPuid)
        {            
            switch (index)
            {
                case 0:
                    userPuid0 = userPuid;
                    break;
                case 1:
                    userPuid1 = userPuid;
                    break;
                case 2:
                    userPuid2 = userPuid;
                    break;
                case 3:
                    userPuid3 = userPuid;
                    break;
                default:
                    throw new Exception("There are only 4 users in the SGInfo and you tried to set #" + index);
            }            
        }

        public uint GetUserLanguageId(int index)
        {
            uint languageId = 0;
            switch (index)
            {
                case 0:
                    languageId = UserFlagsUtil.UserLanguageId(userFlag0);
                    break;
                case 1:
                    languageId = UserFlagsUtil.UserLanguageId(userFlag1);
                    break;
                case 2:
                    languageId = UserFlagsUtil.UserLanguageId(userFlag2);
                    break;
                case 3:
                    languageId = UserFlagsUtil.UserLanguageId(userFlag3);
                    break;                    
                default:
                    throw new Exception("There are only 4 users in the SGInfo and you tried to set #" + index);
            }
            return languageId;
        }

        public uint GetUserCountryId(int index)
        {
            uint countryId = 0;
            switch (index)
            {
                case 0:
                    countryId = UserFlagsUtil.UserCountryId(userFlag0);
                    break;
                case 1:
                    countryId = UserFlagsUtil.UserCountryId(userFlag1);
                    break;
                case 2:
                    countryId = UserFlagsUtil.UserCountryId(userFlag2);
                    break;
                case 3:
                    countryId = UserFlagsUtil.UserCountryId(userFlag3);
                    break;
                default:
                    throw new Exception("There are only 4 users in the SGInfo and you tried to set #" + index);
            }
            return countryId;
        }

        private enum ServiceAction
        {
            SetValue,
            ClearValue,
            GetValue
        };
        // Consolidate the logic into one place, should help with debugging any bugs in the bit shifting junk
        unsafe private bool ServiceActionHelper(int svcId, ServiceAction action)
        {
            //this should never be passed privileges anymore as it doesn't handle them right after AuthDataV4
            if (svcId>=128 && svcId<=255)
            {
                throw new ArgumentException(svcId+" is not a valid service number.");
            }

            // I'm basing this off \private\common\service\SGInfo.cs
            // and also xonlinep.h (see CAuthData3).  If svcId > 0 and < 256, then
            // it is set as a bit in the dwPrivileges array.  Otherwise, it goes in 
            // the dwServiceID array, which is used for abnormal service IDs like PSO
            // and LSP stuff.
            bool exists = false;
            // This is a privilege or base service
            if (svcId > 0 && svcId < 256)
            {
                int dwordIndex = svcId / 32;    // 0...7
                int bitIndex = svcId % 32;      // 0...31
                uint mask = ((uint)1) << bitIndex;
                //uint notMask = ((uint)0xFFFFFFFF) ^ mask;
                fixed (uint* pPriv = &dwPrivileges0)
                {
                    exists = (pPriv[dwordIndex] & mask) == mask;
                    if (ServiceAction.SetValue == action)
                    {
                        // Only add if it doesn't exist already to keep counts in check
                        if (!exists)
                        {
                            pPriv[dwordIndex] |= mask;
                        }
                    }
                    else if (ServiceAction.ClearValue == action)
                    {
                        // Only clear if it does exist to keep counts in check
                        if (exists)
                        {
                            pPriv[dwordIndex] ^= mask;
                        }
                    }
                    else if (ServiceAction.GetValue == action)
                    {
                    }
                }
            }
            // Not in dwPrivileges array, this is in the dwServiceID array
            else
            {
                int i;
                fixed (uint* pService = &dwServiceID0)
                {
                    // Does it exist?
                    for (i = 0; i < 4; i++)
                    {
                        if (pService[i] == svcId)
                        {
                            exists = true;
                            break;
                        }
                    }

                    if (ServiceAction.SetValue == action && !exists)
                    {
                        // Find empty slot.  If full, do nothing.
                        for (i = 0; i < 4; i++)
                        {
                            if (pService[i] == 0)
                            {
                                pService[i] = (uint)svcId;
                                wNumDwordServices++;
                                break;
                            }
                        }
                    }
                    else if (ServiceAction.ClearValue == action && exists)
                    {
                        // hmm.. have to find it again
                        for (i = 0; i < 4; i++)
                        {
                            if (pService[i] == (uint)svcId)
                            {
                                pService[i] = 0;
                                wNumDwordServices--;
                                break;
                            }
                        }
                    }
                    else if (ServiceAction.GetValue == action)
                    {
                    }
                }
            }
            return exists;
        }

        public CSGInfo ShallowClone()
        {
            return ((CSGInfo)this.MemberwiseClone());
        }

        private const ushort XONLINE_XENON_AUTHDATA_VERSION = 0x03;
        private const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        public byte[] GetHttpAuthHeaderBytes(IPEndPoint ep)
        {
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);

            w.Write(HTTP_HEADER_AUTH_DATA_VERSION);

            // Receiving port and address 
            w.Write((ushort)ep.Port);
            byte[] addrBytes = ep.Address.GetAddressBytes();
            uint addr =
                ((uint)addrBytes[3] << 24) |
                ((uint)addrBytes[2] << 16) |
                ((uint)addrBytes[1] << 8) |
                ((uint)addrBytes[0] << 0);
            w.Write(addr);

            // Nonce - supposed to be random value identifying session. Seems to work fine as 0 for HTTPAuth
            w.Write((ulong)0);

            w.Write(XONLINE_XENON_AUTHDATA_VERSION);
            // wAuthData size - 0 works fine here as well for all the cases 
            w.Write((ushort)0);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(titleId);
            w.Write(titleVersion);
            w.Write(titleRegion);
            w.Write(consoleRegion);
            w.Write(mediaID);
            w.Write(languageID);
            w.Write(authDataFlags);

            w.Write(wNumPrivileges);
            w.Write(dwPrivileges0);
            w.Write(dwPrivileges1);
            w.Write(dwPrivileges2);
            w.Write(dwPrivileges3);
            w.Write(dwPrivileges4);
            w.Write(dwPrivileges5);
            w.Write(dwPrivileges6);
            w.Write(dwPrivileges7);

            w.Write(machinePuid);

            w.Write(userPuid0);
            w.Write(userFlag0);
            w.Write(userPuid1);
            w.Write(userFlag1);
            w.Write(userPuid2);
            w.Write(userFlag2);
            w.Write(userPuid3);
            w.Write(userFlag3);


            w.Write(userTrust0);
            w.Write(userTrust1);
            w.Write(userTrust2);
            w.Write(userTrust3);

            w.Write(wNumDwordServices);
            w.Write(dwServiceID0);
            w.Write(dwServiceID1);
            w.Write(dwServiceID2);
            w.Write(dwServiceID3);

            w.Write(altTitleId0);
            w.Write(altTitleId1);
            w.Write(altTitleId2);
            w.Write(altTitleId3);

            w.Write(key00);
            w.Write(key01);
            w.Write(key02);
            w.Write(key03);
            w.Write(key04);
            w.Write(key05);
            w.Write(key06);
            w.Write(key07);
            w.Write(key08);
            w.Write(key09);
            w.Write(key10);
            w.Write(key11);
            w.Write(key12);
            w.Write(key13);
            w.Write(key14);
            w.Write(key15);

            string header = "HTTPAuthData:" + Convert.ToBase64String(m.ToArray()) + "\r\n";
            return System.Text.Encoding.ASCII.GetBytes(header);

        }

        /// <summary>
        /// Copies the data in this CSGInfo to the authdata object given.
        /// </summary>
        /// <param name="authdata">The object to write to.</param>
        public void CopyToAuthdata (Authdata_Base authdata)
        {
            authdata.MajorVersion = wMajorVersion;
            authdata.MinorVersion = wMinorVersion;
            authdata.BuildNumber = wBuildNumber;
            authdata.QFENumber = wQFENumber;

            authdata.XboxID = machinePuid;

            if (authdata is Authdata_Xenon)
            {
                CopyToAuthdata((Authdata_Xenon)authdata);
            }
            else
            {
                throw new NotImplementedException("Only Authdata_Xenon is supported by CopyToAuthdata currently.");
            }
        }

        /// <summary>
        /// Copies the data in this CSGInfo to the authdata object given.
        /// </summary>
        /// <param name="authdata">The object to write to.</param>
        private void CopyToAuthdata (Authdata_Xenon authdata)
        {
            authdata.dwTitleID = titleId;
            authdata.dwTitleRegion = titleRegion;
            authdata.dwTitleVersion = titleVersion;

            authdata.dwConsoleRegion = consoleRegion;
            authdata.dwMediaID = mediaID;
            authdata.wLanguageID = languageID;
            authdata.dwAuthDataFlags = authDataFlags;

            authdata.wNumPrivileges = wNumPrivileges;
            authdata.dwPrivileges[0] = dwPrivileges0;
            authdata.dwPrivileges[1] = dwPrivileges1;
            authdata.dwPrivileges[2] = dwPrivileges2;
            authdata.dwPrivileges[3] = dwPrivileges3;
            authdata.dwPrivileges[4] = dwPrivileges4;
            authdata.dwPrivileges[5] = dwPrivileges5;
            authdata.dwPrivileges[6] = dwPrivileges6;
            authdata.dwPrivileges[7] = dwPrivileges7;

            if (authdata.users == null)
            {
                authdata.users = new XUserID[4];
            }
            authdata.users[0].qwUserID = userPuid0;
            authdata.users[0].dwUserFlags = userFlag0;
            authdata.users[1].qwUserID = userPuid1;
            authdata.users[1].dwUserFlags = userFlag1;
            authdata.users[2].qwUserID = userPuid2;
            authdata.users[2].dwUserFlags = userFlag2;
            authdata.users[3].qwUserID = userPuid3;
            authdata.users[3].dwUserFlags = userFlag3;

            authdata.afltTrustFactor[0] = userTrust0;
            authdata.afltTrustFactor[1] = userTrust1;
            authdata.afltTrustFactor[2] = userTrust2;
            authdata.afltTrustFactor[3] = userTrust3;

            authdata.wNumDwordServices = wNumDwordServices;
            authdata.dwServiceID[0] = dwServiceID0;
            authdata.dwServiceID[1] = dwServiceID1;
            authdata.dwServiceID[2] = dwServiceID2;
            authdata.dwServiceID[3] = dwServiceID3;

            authdata.dwAltTitleID[0] = altTitleId0;
            authdata.dwAltTitleID[1] = altTitleId1;
            authdata.dwAltTitleID[2] = altTitleId2;
            authdata.dwAltTitleID[3] = altTitleId3;

            authdata.abKey[0] = key00;
            authdata.abKey[1] = key01;
            authdata.abKey[2] = key02;
            authdata.abKey[3] = key03;
            authdata.abKey[4] = key04;
            authdata.abKey[5] = key05;
            authdata.abKey[6] = key06;
            authdata.abKey[7] = key07;
            authdata.abKey[8] = key08;
            authdata.abKey[9] = key09;
            authdata.abKey[10] = key10;
            authdata.abKey[11] = key11;
            authdata.abKey[12] = key12;
            authdata.abKey[13] = key13;
            authdata.abKey[14] = key14;
            authdata.abKey[15] = key15;
        }

        /// <summary> Fills in this structure from a real authdata structure. </summary>
        public void CopyFromXkdcAuthdata(XboxAuthDataBase authdata)
        {
            if (authdata == null)
            {
                throw new System.ArgumentException("authdata may not be null.");
            }

            ClearServices();

            wMajorVersion = authdata.ClientMajorVersion;
            wMinorVersion = authdata.ClientMinorVersion;
            wBuildNumber = authdata.ClientBuildNumber;
            wQFENumber = authdata.ClientQFENumber;

            machinePuid = authdata.XboxID;
            titleId = authdata.TitleID;
            titleVersion = authdata.TitleVersion;
            titleRegion = authdata.TitleRegion;

            key00 = authdata.Key[0];
            key01 = authdata.Key[1];
            key02 = authdata.Key[2];
            key03 = authdata.Key[3];
            key04 = authdata.Key[4];
            key05 = authdata.Key[5];
            key06 = authdata.Key[6];
            key07 = authdata.Key[7];
            key08 = authdata.Key[8];
            key09 = authdata.Key[9];
            key10 = authdata.Key[10];
            key11 = authdata.Key[11];
            key12 = authdata.Key[12];
            key13 = authdata.Key[13];
            key14 = authdata.Key[14];
            key15 = authdata.Key[15];

            userPuid0 = authdata.GetUser(0).UserID;
            userFlag0 = authdata.GetUser(0).UserFlags;
            userPuid1 = authdata.GetUser(1).UserID;
            userFlag1 = authdata.GetUser(1).UserFlags;
            userPuid2 = authdata.GetUser(2).UserID;
            userFlag2 = authdata.GetUser(2).UserFlags;
            userPuid3 = authdata.GetUser(3).UserID;
            userFlag3 = authdata.GetUser(3).UserFlags;

            userTrust0 = authdata.GetUserTrustFactor(0);
            userTrust1 = authdata.GetUserTrustFactor(1);
            userTrust2 = authdata.GetUserTrustFactor(2);
            userTrust3 = authdata.GetUserTrustFactor(3);

            foreach (uint s in authdata.GetByteServices())
            {
                AddService((XOService)s);
            }

            foreach (uint s in authdata.GetDwordServices())
            {
                AddService((XOService)s);
            }

            altTitleId0 = authdata.GetAltTitleId(0);
            altTitleId1 = authdata.GetAltTitleId(1);
            altTitleId2 = authdata.GetAltTitleId(2);
            altTitleId3 = authdata.GetAltTitleId(3);

            if (authdata is XenonAuthDataBase)
            {
                XenonAuthDataBase xenonAuthdata = (XenonAuthDataBase)authdata;

                authDataFlags = xenonAuthdata.AuthDataFlags;
                consoleRegion = xenonAuthdata.ConsoleRegion;
                mediaID = xenonAuthdata.MediaId;
                languageID = xenonAuthdata.LanguageId;

                if (authdata is Xenon2XkdcAuthData)
                {
                    Xenon2XkdcAuthData xenon2Authdata = (Xenon2XkdcAuthData)authdata;

                    for (uint u=0; u<4; ++u)
                    {
                        for (uint p=128; p<=255; ++p)
                        {
                            if (xenon2Authdata.HasPrivilege(p, u))
                            {
                                SetUserPrivilege((int)u, p);
                            }
                        }
                    }

                    flowToken = xenon2Authdata.FlowToken;
                }
                else //does not have per-user privileges
                {
                    for (uint p=128; p<=255; ++p)
                    {
                        if (xenonAuthdata.HasPrivilege(p))
                        {
                            SetPrivilege(p);
                        }
                    }

                    flowToken = 0;
                }
            }
            else //old xbox authdata doesn't have these
            {
                authDataFlags = 0;
                consoleRegion = 0;
                mediaID = 0;
                languageID = 0;

                flowToken = 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Feedback\FeedbackSupport.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Feedback
{
	/// <summary>
	/// Summary description for FeedbackSupport.
	/// </summary>
	public class FeedbackWS
	{
		static string StartDT= DateTime.UtcNow.ToString();
        static string ProfileWebstoreApp = "profiledb";
		
		static public void verifyFeedback(long user,long target,int title,byte type ,string nickname)
		{
			string query = "SELECT count(*) FROM [t_user_feedback_v1]";
			query+="	where [bi_user_puid]="+user+"  and  [bi_target_puid]="+target+" and  [i_title_id]="+title+" and  [i_type]="+type;

            object retval = UodbWS.ExecuteSQLScalar(query, target);
			if(retval ==null || (int)retval<=0)
				throw new Exception("Feedback entry not found in DB");
		}

		static public int GetAggCount(ulong user,uint type )
		{
			string query = "SELECT [i_count] FROM [t_user_review_aggregates]";
			query+="where [bi_user_puid]="+user+" and  [i_type]="+type;

            object retval = UodbWS.ExecuteSQLScalar(query, user);
		
			if(retval !=null)
				return (int)retval;

			return 0;
		}

		static public int AddRatingData(ulong user , int gamesplayed,int  usersplayed ,int  reviewssent )
		{
            int hash = UodbWS.GetHashBucket(user);
			string query = "Exec p_feedback_add_rating_data "+user+","+gamesplayed+","+usersplayed+","+reviewssent+",0,"+hash;

            UodbWS.ExecuteSQLNonQuery(query, user);
			return 0;
		}

		static public double GetRating(ulong user)
		{
			double rating =0;
			string query = "SELECT [vb_value] FROM [t_user_settings]";
			query+="where [bi_user_puid]="+user+"and  i_title_id=-129071 and i_setting_id=1342439435";

            object retval = WebstoreDB.ExecuteSQLScalar(ProfileWebstoreApp, query, user);
			if(retval !=null)
			{
				BinaryReader  tmp  = new BinaryReader(new MemoryStream((byte[])retval));
				rating= tmp.ReadSingle();
			}
		
			return rating;
		}

		static public void SetRating(ulong user, float rating)
		{
            byte[] ratingInBytes = System.BitConverter.GetBytes(rating);
            byte[] ratingInBigEndian = new byte[4];
            ratingInBigEndian[0] = ratingInBytes[3];
            ratingInBigEndian[1] = ratingInBytes[2];
            ratingInBigEndian[2] = ratingInBytes[1];
            ratingInBigEndian[3] = ratingInBytes[0];

            uint ratingBuffer = System.BitConverter.ToUInt32(ratingInBigEndian, 0);

            int hash = WebstoreDB.GetHashBucket(ProfileWebstoreApp, user);
            string query = "update t_user_settings set vb_value = 0x" + ratingBuffer.ToString("X8") + ", dt_change_datetime = getutcdate()where bi_user_puid =" + user + " and i_title_id = -129071 and i_setting_id = 1342439435 ";
            query += " if (@@rowcount = 0) insert into t_user_settings (bi_user_puid, i_title_id, i_setting_id, vb_value, dt_change_datetime, si_hash_bucket)  values (" + user + ", -129071, 1342439435, " + rating + ", getutcdate()," + hash + ")";

            int retval = WebstoreDB.ExecuteSQLNonQuery(ProfileWebstoreApp, query, user);
		}

        static public int GetAffiliacteFlags(PNUser user, long target, int title)
		{
            user.Reconnect();
            System.Threading.Thread.Sleep(5000);
            user.Alive();

			string query = "SELECT [i_list_flag] FROM [t_xprof_affiliates]";
            query += " where [bi_user_puid]= " + user.UserId + "and [bi_affiliate_puid]=" + target + "and  [i_title_id]=" + title;

            object retval = UodbWS.ExecuteSQLScalar(query, (ulong)user.UserId);

			if(retval !=null)
				return (int)retval;

			return 0;
		}

		static public object verifyReview(long user,long target,int title,int type ,long  context)
		{
			string query = "SELECT count(*) FROM [t_user_review]";
			query+="	where [bi_user_puid]="+user+"  and  [bi_target_puid]="+target+" and  [i_title_id]="+title+" and  [i_type]="+type+" and [bi_context]="+context;
			
            object retval = UodbWS.ExecuteSQLScalar(query, (ulong)target);

			return retval;
		}

		static public void verifyComplaint(long user,long target,int title,int type ,long  context)
		{
			string query = "SELECT count(*) FROM [t_user_complaint]";
			query+="	where [bi_user_puid]="+user+"  and  [bi_target_puid]="+target+" and  [i_title_id]="+title+" and  [i_type]="+type+" and [bi_context]="+context;
			
            object retval = UodbWS.ExecuteSQLScalar(query, (ulong)target);
			if(retval==null || ((int)retval)<=0)
				throw new Exception("User Review entry not found in DB");
		}

		static public void prepareforStress()
		{
			string q1= "ALTER TABLE t_user_review NOCHECK CONSTRAINT fk_t_user_review_target_puid";
			string q2 ="ALTER TABLE t_user_complaint NOCHECK CONSTRAINT fk_t_user_complaint_target_puid";
			string q3 ="ALTER TABLE t_user_review_aggregates NOCHECK CONSTRAINT fk_t_user_aggregates_user_puid";

            UodbWS.ExecuteSQLNonQuery(q1, null);  // all partitions
            UodbWS.ExecuteSQLNonQuery(q2, null);  // all partitions
            UodbWS.ExecuteSQLNonQuery(q3, null);  // all partitions
		}


		static public void ClearFeedbackAndVerify(ulong tuser)
		{
			//... execute the clear feedback job...

			string tmp = DateTime.UtcNow.ToString("u");
			tmp= tmp.Remove(tmp.Length-1,1);

			string query = " exec p_feedback_cleanup_data '"+tmp+"'";
            int Nrec = UodbWS.ExecuteSQLNonQuery(query, tuser);


			// make sure the feedback is cleaned.

			query = "SELECT count(*) FROM [t_user_feedback_v1]";
			query +=" where [bi_target_puid]= " + tuser;

            object retval = UodbWS.ExecuteSQLScalar(query, tuser);
			if(retval ==null || (int)retval > 0)
				throw new Exception("Feedback entry not found in DB");

			// make sure the feedback is cleaned.

			query = "SELECT count(*) FROM [t_user_review]";
			query +=" where [bi_target_puid]= " + tuser;

            retval = UodbWS.ExecuteSQLScalar(query, tuser);
			if(retval ==null || (int)retval > 0)
				throw new Exception("Feedback entry not found in DB");

			// make sure the feedback is cleaned.

			query = "SELECT count(*) FROM [t_user_complaint]";
			query +=" where [bi_target_puid]= " + tuser;

            retval = UodbWS.ExecuteSQLScalar(query, tuser);
			if(retval ==null || (int)retval > 0)
				throw new Exception("Feedback entry not found in DB");
		}
	}



	public class FeedbackReq
	{
		public void SendComplaint(ulong  senderPUID,ulong   targetPUID,uint    titleID,uint    type,ulong   context)
		{
			SubmitComplaintRequest req = new  SubmitComplaintRequest(senderPUID,targetPUID,titleID,type,context);
			Response resp = req.Execute();
			
			if(!HResult.Succeeded(resp.Xerr))
				throw new Exception("request failed with Error " + resp.Xerr);
		}

		public void SendReview(ulong  senderPUID,ulong   targetPUID,uint    titleID,uint    type,ulong   context)
		{
			SubmitReview req = new  SubmitReview(senderPUID,targetPUID,titleID,type,context);
			Response resp = req.Execute();
			if(!HResult.Succeeded(resp.Xerr))
				throw new Exception("request failed with Error " + resp.Xerr);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Feedback\XrlFeedback.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Feedback
{
	/// <summary>
	/// Summary description for XrlFeedback.
	/// </summary>
	public class XrlFeedback : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong	SenderPuid=0;
		public ulong	TargetPuid=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint		TitleID=XOn.DASH_TITLE_ID;
		public byte		FeedbackType=0;
		public byte		NicknameLen;
		public string	Nickname;

		protected override string GetServiceName()
		{
			return @"/fbserver/fbserver.ashx";
		}

		override public bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver));
		}
		public bool Execute( byte[] nickname)
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),nickname);
		}

		public XrlFeedback()
		{
			ServiceId=XOService.Feedback;
			this.Slot.AddService(XOService.Feedback);
		}
		public bool Execute(IPEndPoint endPoint, byte[] nickname )
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			BinaryWriter _writer= new BinaryWriter(reqStream);
			byte temp =(byte)0xff;

			_writer.Write(SenderPuid);
			_writer.Write(TargetPuid);
			_writer.Write(TitleID);
			_writer.Write(FeedbackType);
			_writer.Write(temp);
			_writer.Write(nickname,0,nickname.Length);

			bool uRet = false;
			bool bRet=InternalExecute(endPoint,reqStream);

			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					uRet=true;
				}
			}

			return uRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\GI\giprot.cs ===
// 
// GIProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Game Instrumentation Service Integration
// Xbox Online Service
// 

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using ServerTestFramework;
using ServerTestFramework.LiveService;


namespace ServerTestFramework.LiveService.GI
{

    public class GITypes
    {
        public const uint XONLINE_STAT_DATATYPE_MASK     = 0xF0000000;
        
        public const uint XONLINE_STAT_NULL              = 0x00000000;
        public const uint XONLINE_STAT_LONG              = 0x10000000;
        public const uint XONLINE_STAT_LONGLONG          = 0x20000000;
        public const uint XONLINE_STAT_DOUBLE            = 0x30000000;
        public const uint XONLINE_STAT_LPCWSTR           = 0x40000000;
        public const uint XONLINE_STAT_FLOAT             = 0x50000000;
        public const uint XONLINE_STAT_BINARY            = 0x60000000;
        public const uint XONLINE_STAT_DATETIME          = 0x70000000;
    }
    
    //
    // Basic Context name value pair. The value always corresponds to a localized label for display purposes
    //
    public class GIContext : WireData
    {
		public const uint GAME_MODE = 0x0000800B;

        public uint           Id;
        public uint           Value;

        public GIContext() { }
        public GIContext(uint id)
        {
            Id = id;
        }    
        public GIContext(uint id, uint value)
        {
            Id = id;
            Value = value;
        }
    }


    //
    // Property data for Game Instrumentation. This is the meat of how data is represented via instrumentation
    //
    public class GIProperty: WireData
    {
        public GIProperty() { }
        public GIProperty(uint id)
        {
            Id = id;

            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = (float)0.0;
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = (DateTime)DateTime.UtcNow;
                break;
                
            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = (double)0.0;
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = (int)0;
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = (long)0;
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                strValue = "";
                break;
            }            
        }    
        
        public GIProperty(uint id, float f)
        {
            Id = id;
            fValue = f;
            
            if ( (id & GITypes.XONLINE_STAT_FLOAT) != GITypes.XONLINE_STAT_FLOAT)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, DateTime dt)
        {
            Id = id;
            dtValue = dt;
            
            if ((id & GITypes.XONLINE_STAT_DATETIME) != GITypes.XONLINE_STAT_DATETIME)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, double d)
        {
            Id = id;
            dValue = d;

            if ( (id & GITypes.XONLINE_STAT_DOUBLE) != GITypes.XONLINE_STAT_DOUBLE)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, int n)
        {
            Id = id;
            nValue = n;

            if ( (id & GITypes.XONLINE_STAT_LONG) != GITypes.XONLINE_STAT_LONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, long l)
        {
            Id = id;
            lValue = l;

            if ( (id & GITypes.XONLINE_STAT_LONGLONG) != GITypes.XONLINE_STAT_LONGLONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, string str)
        {
            Id = id;
            strValue = str;

            if ( (id & GITypes.XONLINE_STAT_LPCWSTR) != GITypes.XONLINE_STAT_LPCWSTR)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, byte[] bin)
        {
            Id = id;
            binValue = bin;

            if ( (id & GITypes.XONLINE_STAT_BINARY) != GITypes.XONLINE_STAT_BINARY)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }            
        
        
        //
        // Data exposed to SOAP for web services
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors (these aren't serialized)
        //
        [XmlIgnore]
        public float fValue
        {
            get { return (float)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public DateTime dtValue
        {
            get { return (DateTime)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public double dValue
        {
            get { return (double)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public int nValue
        {
            get { return (int)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = binaryReader.ReadSingle();
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = DateTime.FromFileTimeUtc(binaryReader.ReadInt64());
                break;

            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = binaryReader.ReadDouble();
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = binaryReader.ReadInt32();
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = binaryReader.ReadInt64();
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                len = binaryReader.ReadUInt16();
                strValue = Encoding.Unicode.GetString(binaryReader.ReadBytes(len));
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                len = binaryReader.ReadUInt16();
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new ApplicationException("Unrecgonized datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                binaryWriter.Write(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                binaryWriter.Write(Convert.ToDateTime(dtValue).ToFileTimeUtc());
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                binaryWriter.Write(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                binaryWriter.Write(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                binaryWriter.Write(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                {
                byte[] buf;
                
                buf = Encoding.Unicode.GetBytes(strValue);
                binaryWriter.Write((ushort)buf.Length);
                binaryWriter.Write(buf);
                }
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                binaryWriter.Write((ushort)binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new ApplicationException("Unexpected datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }
        }

        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                str.Append(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                str.Append(dtValue);
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                str.Append(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                str.Append(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                str.Append(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                str.Append(strValue);
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                str.Append("Binary:" +binValue.Length);                    
                break;

            default:
                str.Append("null");
                break;
            }
            
            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\GI\GIblob.cs ===
using System;
using System.IO;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.GI
{
	public class GIBlob : WireData
	{
		public uint             TitlePresence;
        public ushort           ContextsLen;
        public ushort           PropertiesLen;
        [WireInfo(SizeParam="ContextsLen")]
        public GIContext[]      Contexts;
        [WireInfo(SizeParam="PropertiesLen")]
        public GIProperty[]     Properties;

		// Containers to aid in blob building
		[WireInfo(Serialize=false)]	
		protected ArrayList 	contexts;
		[WireInfo(Serialize=false)]	
		protected ArrayList		properties;

		public GIBlob()
		{
			contexts = new ArrayList();
			properties = new ArrayList();
		}

		public void AddContext(uint id, uint value)
		{
			AddContext(new GIContext(id, value));
		}

		public void AddContext(GIContext gictx)
		{
			contexts.Add(gictx);
		}

		public void SetContext(uint id, uint value)
		{
			foreach(GIContext ctx in contexts)
			{
				if(ctx.Id == id)
				{
					ctx.Value = value;
				}
			}
		}
		
		public void AddProperty(GIProperty giprop)
		{
			properties.Add(giprop);
		}

		public void SetProperty(GIProperty giprop)
		{
			foreach(GIProperty p in properties)
			{
				if(p.Id == giprop.Id)
				{
					p.Value = giprop.Value;
				}
			}
		}

		public void Clear()
		{
			contexts.Clear();
			properties.Clear();

			// Clear serialized data
			TitlePresence = 0;
			ContextsLen = 0;
			Contexts = null;
			PropertiesLen = 0;
			Properties = null;
		}

		public byte[] GetBytes()
		{
			return GetBytes(true);
		}

		public byte[] GetBytes(bool checkSize)
		{
			ContextsLen = (ushort)contexts.Count;
			Contexts = (GIContext[])contexts.ToArray(typeof(GIContext));
			PropertiesLen = (ushort)properties.Count;
			Properties = (GIProperty[])properties.ToArray(typeof(GIProperty));
			
			// serialize members to binary stream
			MemoryStream stream = new MemoryStream(256);
			WriteStream(stream);

			if(checkSize && stream.Length > 256) 
			{
				throw new Exception("GIBlob cannot be larger than 256 bytes");
			}

			return stream.ToArray();
		}

		public void Compare(GIBlob blob)
		{
			ValueCheck.Test("PropertiesLen", PropertiesLen, blob.PropertiesLen);
			ValueCheck.Test("ContextsLen", ContextsLen, blob.ContextsLen);
			ValueCheck.Test("TitlePresence", TitlePresence, blob.TitlePresence);

			// Do memberwise compare of property and context arrays
			for(int i = 0; i < PropertiesLen; ++i)
			{
				GIProperty a = Properties[i];
				GIProperty b = blob.Properties[i];

				ValueCheck.Test("PropertyId #"+i, a.Id, b.Id);
				switch(a.Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
				{
					case GITypes.XONLINE_STAT_FLOAT:
						ValueCheck.Test("fValue #"+i,  a.fValue, b.fValue);
						break;
					case GITypes.XONLINE_STAT_DATETIME:
						ValueCheck.Test("dtValue #"+i,  a.dtValue, b.dtValue);
						break;
					case GITypes.XONLINE_STAT_DOUBLE:
						ValueCheck.Test("dValue #"+i, a.dValue, b.dValue);
						break;
					case GITypes.XONLINE_STAT_LONG:
						ValueCheck.Test("nValue #"+i, a.nValue, b.nValue);
						break;
					case GITypes.XONLINE_STAT_LONGLONG:
						ValueCheck.Test("lValue #"+i, a.lValue, b.lValue);
						break;
					case GITypes.XONLINE_STAT_LPCWSTR:
						ValueCheck.Test("strValue #"+i, a.strValue, b.strValue);
						break;
				}
			}

			// Do memberwise compare of contexts
			for(int i=0; i<Contexts.Length; i++)
			{
				GIContext a = Contexts[i];
				GIContext b = blob.Contexts[i];

				ValueCheck.Test("ContextId #"+i, a.Id, a.Id);
				ValueCheck.Test("ContextValue #"+i, b.Value, b.Value);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\GI\Pong.cs ===
namespace ServerTestFramework.LiveService.GI
{
	/// Context and properties that are exposed for the pong
	/// test title ID.
	public class Pong
	{
		public const uint TitleId = 0xFFFF400A;

		/// Context IDs used for creating contexts
		/// see named enums below for context values.
		public enum Context : uint 
		{
            GameMode        = 0x0000800B,
			GameSize 		= 1,
			GameSpeed 		= 20,
			WinScore		= 30
		}
		public enum GameMode : uint
		{
			SinglePlayer 	= 0,
			MultiPlayer 	= 1
		} 
		public enum GameSize : uint
		{
			Small 			= 0,
			Medium			= 1,
			Large			= 2
		}
		public enum GameSpeed : uint
		{
			Slow 			= 0,
			Fast 			= 1
		}
		public enum WinScore : uint
		{
			Points15		= 0,
			Points21		= 1
		}

		// Property type for use with GI property blobs
		public const uint PropertyWins 		 = GITypes.XONLINE_STAT_LONG | 0x22;
		public const uint PropertyLosses 	 = GITypes.XONLINE_STAT_LONG | 0x33;
		public const uint PropertyPoints 	 = GITypes.XONLINE_STAT_LONG | 0x44;
        public const uint PropertyUnicode    = GITypes.XONLINE_STAT_LPCWSTR | 0x5D;
        public const uint PropertyUnicode100 = GITypes.XONLINE_STAT_LPCWSTR | 0x3;
        public const uint PropertyUnicode126 = GITypes.XONLINE_STAT_LPCWSTR | 0x4;
        public const uint PropertyUnicode22  = GITypes.XONLINE_STAT_LPCWSTR | 0x5;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Feedback\XrlUserReview.cs ===
using System;
using System.Net;
using System.Text;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Feedback
{
	public enum Modify
	{
		None			=0,
		Change_User		=1,
		Change_Title	=2,
	}

	/// <summary>
	/// Summary description for XrlUserReview.
	/// </summary>
	public class SubmitReview : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong   senderPUID;
		public ulong   targetPUID;
		[XRLPayloadFld(IsTitleId=true)]
		public uint    titleID;
		public uint    type;
		public ulong   context;

		[WireInfo(Serialize=false)]
		public Modify Modifyflag = Modify.None;
		[XRLPayloadFld(Serialize=false)]
		public IPEndPoint AlternatePresenceDestination=null;

		public SubmitReview()
		{
		}

        public SubmitReview(ulong spuid, ulong tpuid,uint title, uint ftype,ulong cont)
		{
			senderPUID= spuid;
			targetPUID=tpuid;
			titleID=title;
			type=ftype;
			context=cont;
			ServiceId = XOService.Feedback;
		}


		public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
		{
			if(AlternatePresenceDestination ==null)
				return base.GenerateHttpHeader(endPoint,reqStream);

			System.Text.ASCIIEncoding AE=new System.Text.ASCIIEncoding();
			string sURL = AE.GetString(base.GenerateHttpHeader(endPoint,reqStream));
			StringBuilder sbURL = new StringBuilder(sURL);
			if (sbURL.Length>=2)
			{
				sbURL.Remove(sbURL.Length-2,2);  //strip last /r/n off
			}

			if (AlternatePresenceDestination != null) 
			{
				sbURL.Append("AlternatePresenceDestination: http://"+AlternatePresenceDestination.Address.ToString()+
					":"+AlternatePresenceDestination.Port.ToString()+"/fbserver/submitreview.ashx\r\n");
			}

			sbURL.Append("\r\n");
			byte[] Header=AE.GetBytes(sbURL.ToString());
			return Header;

		}
		protected override string GetServiceName()
		{
			return "/fbserver/submitreview.ashx";
		}

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			if(Modifyflag == Modify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if (Modifyflag == Modify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			ManualSlotSetup=true;
		}

		new public Response Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			if(Modifyflag != Modify.None )
				ManualPopulateSlot();

			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			// create a streem here and then read all data;
			Response Resp = new Response();
			Resp.Xerr=xAct.XErr;
			return Resp;
		}

		new public Response Execute(IPEndPoint server)
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			if(Modifyflag != Modify.None )
				ManualPopulateSlot();

			bool bRet = InternalExecute(server,reqStream);
			// create a streem here and then read all data;
			Response Resp = new Response();
			Resp.Xerr=xAct.XErr;
			return Resp;
		}
	}

	/*public class EnumerateSentReviews : XRLPayload
	{
		public ulong   senderPUID;
		public uint    page;
		public uint    resultsPerPage;

		protected override string GetServiceName()
		{
			return "/fbserver/enumsentreview.ashx";
		}

		new public EnumerateReviewsReply Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			// create a streem here and then read all data;
			EnumerateReviewsReply Resp = (EnumerateReviewsReply)new EnumerateReviewsReply().ReadBytes(xAct.ResponseContents);
			return Resp;
		}
	}

	public class EnumerateRecdReviewsRequest : XRLPayload
	{
		public ulong   targetPUID;
		public uint    page;
		public uint    resultsPerPage;

		protected override string GetServiceName()
		{
			return "/fbserver/enumrecdreview.ashx";
		}
		new public EnumerateReviewsReply Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			// create a streem here and then read all data;
			EnumerateReviewsReply Resp = (EnumerateReviewsReply)new EnumerateReviewsReply().ReadBytes(xAct.ResponseContents);
			return Resp;
		}
	}

	public class PlayerReview : WireData
	{
		public ulong       senderPUID;
		public ulong       targetPUID;
		public uint        titleID;
		public uint        type;
		public ulong       context;
		public DateTime    dtSubmitted;
	}

	public class EnumerateReviewsReply : WireData
	{
		public uint        hr;
		public uint        cReviews;

		[WireInfo(SizeParam="cReviews")]
		public PlayerReview [] reviews;
	}
	
	*/


	public class GetAggregateReviewsRequest : XRLPayload
	{
		public ulong   targetPUID;
		public GetAggregateReviewsRequest()
		{
		}

		public GetAggregateReviewsRequest(ulong user)
		{
			targetPUID = user;
			ServiceId = XOService.Feedback;
		}

		protected override string GetServiceName()
		{
			return "/fbserver/getaggreview.ashx";
		}

		new public GetAggregateReviewsReply Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver),reqStream);
			// create a streem here and then read all data;
			GetAggregateReviewsReply Resp = (GetAggregateReviewsReply)new GetAggregateReviewsReply().ReadBytes(xAct.ResponseContents);
			return Resp;
		}
	}

	public class AggregateReview : WireData
	{
		public ulong       targetPUID;
		public uint        count;
		public uint        type;
	}

	public class GetAggregateReviewsReply : WireData
	{
		public uint        hr;
		public uint        cReviews;
		[WireInfo(SizeParam="cReviews")]
		public AggregateReview [] aggReviews;
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\LBServer\LBSRequest.cs ===
using System;
using System.IO;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.LiveService.LBServer
{

	public class ProcIds
	{
		public static int CreateLb  = 1;
		public static int DeleteLb  = 2;
		public static int DeleteTitle = 6;
		
		//

		public static int LbProcIdDeleteLbFromMemoryOnly = 12;
		public static int LbProcIdSetLbToReadOnly        = 13;
		public static int  LbProcIdSetLbToReadWrite       = 14; 
		public static int  LbProcIdIsSafeToDeleteLb       = 15;
		public static int  LbProcIdCreateAndLoadOneLb     = 16;
		public static int  LbProcIdGetLbStatus            = 17;

		public static int TestAutoResetLb               = 1001;
		public static int TestAutoDecayLb               = 1002;
		public static int TestChangeLastUpdateTimeLb               = 1003;
		public static int TestTrimLb               = 1004;
	}

	public class StatsMessage
	{
		public ProcCall ProcDef=null;
		public virtual ProcCall GetProc()
		{
			return ProcDef;
		}
	}

	/* public class StatsEnum :StatsMessage
	{
		public StatsEnum(int title,int lbid,int startrank,int count)
		{
			ProcDef = new ProcCall(ProcIds.StatEnum,3);
			ProcDef.AddParam(title);
			ProcDef.AddParam(lbid);
			ProcDef.AddParam(startrank);
			ProcDef.AddParam(count);
		}

	}

	public class StatsRead:StatsMessage
	{
        public StatsRead(int title,int lbid,long puid)
		{
			ProcDef = new ProcCall(ProcIds.StatRead,3);
			ProcDef.AddParam(title);
			ProcDef.AddParam(lbid);
			ProcDef.AddParam(puid);
		}
	
	}

	public class StatsWrite:StatsMessage
	{
		public StatsWrite(int title,int lbid,long puid,short statscount)
		{
			short paramcount = (short)(statscount*2+5);
			ProcDef = new ProcCall(ProcIds.StatWrite,paramcount);
			ProcDef.AddParam(title);
			ProcDef.AddParam(lbid);
			ProcDef.AddParam(puid);
			ProcDef.AddParam((long)0);
			ProcDef.AddParam(statscount);
			
		}

		public void AddStats(short id,int data)
		{
			ProcDef.AddParam(id);
			ProcDef.AddParam(data);
		}
		public void AddStats(short id,long data)
		{
			ProcDef.AddParam(id);
			ProcDef.AddParam(data);
		}
		public void AddStats(short id,double data)
		{
			ProcDef.AddParam(id);
			ProcDef.AddParam(data);
		}
		public void AddStats(short id,string data)
		{
			ProcDef.AddParam(id);
			ProcDef.AddParam(data);
		}
			
	}
	*/

	public class CreateLB :StatsMessage
	{
		public CreateLB(int title, int LBid, string Params)
		{
			ProcDef= new ProcCall(ProcIds.CreateLb,3);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
			ProcDef.AddParam(Params);

		}
		
	}

	public class DeleteLb:StatsMessage
	{
		public DeleteLb(int title, int LBid)
		{
			ProcDef= new ProcCall(ProcIds.DeleteLb,2);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
			
		}
		
	}


	public class DeleteTitle:StatsMessage
	{
		public DeleteTitle(int title)
		{
			ProcDef= new ProcCall(ProcIds.DeleteTitle,1);
			ProcDef.AddParam(title);
		}
		
	}


	public class SetLbToReadOnly :StatsMessage
	{
		public SetLbToReadOnly(int title, int LBid)
		{
			ProcDef= new ProcCall(ProcIds.LbProcIdSetLbToReadOnly,2);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
		}
		
	}

	public class SetLbToReadWrite :StatsMessage
	{
		public SetLbToReadWrite(int title, int LBid)
		{
			ProcDef= new ProcCall(ProcIds.LbProcIdSetLbToReadWrite,2);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
		}
		
	}

	public class LoadOneLb :StatsMessage
	{
		public LoadOneLb(int title, int LBid)
		{
			ProcDef= new ProcCall(ProcIds.LbProcIdCreateAndLoadOneLb,2);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
		}
		
	}

	public class UnLoadOneLb :StatsMessage
	{
		public UnLoadOneLb(int title, int LBid)
		{
			ProcDef= new ProcCall(ProcIds.LbProcIdDeleteLbFromMemoryOnly,2);
			ProcDef.AddParam(title);
			ProcDef.AddParam(LBid);
		}
		
	}


	public class IsSafeToDeleteLb :StatsMessage
	{
		public IsSafeToDeleteLb(int seed)
		{
			ProcDef= new ProcCall(ProcIds.LbProcIdIsSafeToDeleteLb,1);
			ProcDef.AddParam(seed);
		}
		
	}


	public class TestAutoReset:StatsMessage
	{
		public TestAutoReset(long dtime)
		{
			ProcDef= new ProcCall(ProcIds.TestAutoResetLb,1);
			ProcDef.AddParam(dtime);
		}
		
	}

	public class TestAutoDecay:StatsMessage
	{
		public TestAutoDecay(long dtime)
		{
			ProcDef= new ProcCall(ProcIds.TestAutoDecayLb,1);
			ProcDef.AddParam(dtime);
		}
		
	}
	public class TestTrimLb:StatsMessage
	{
		public TestTrimLb()
		{
			ProcDef= new ProcCall(ProcIds.TestTrimLb,0);
			
		}
		
	}

	public class TestChangeLastUpdateTime:StatsMessage
	{
		public TestChangeLastUpdateTime(int title,int lbid,int ndays)
		{
			ProcDef= new ProcCall(ProcIds.TestChangeLastUpdateTimeLb,3);
			ProcDef.AddParam(title);
			ProcDef.AddParam(lbid);
			ProcDef.AddParam(ndays);
		}
		
	}



	/// <summary>
	/// Summary description for LBSRequest.
	/// </summary>
	public class LBSRequest
	{
		public ArrayList ProcCalls = new ArrayList();
		
		public LBSRequest()
		{
		}

		public void AddProc(ProcCall proc)
		{
			ProcCalls.Add(proc);
		}

		public void AddProc(CreateLB proc)
		{
			ProcCalls.Add(proc.GetProc());
		}

		public void AddProc(DeleteTitle proc)
		{
			ProcCalls.Add(proc.GetProc());
		}

		public void AddProc(DeleteLb proc)
		{
			ProcCalls.Add(proc.GetProc());
		}
		
		

		public void AddProc(TestAutoReset proc)
		{
			ProcCalls.Add(proc.GetProc());
		}
		public void AddProc(TestAutoDecay proc)
		{
			ProcCalls.Add(proc.GetProc());
		}
		public void AddProc(TestChangeLastUpdateTime proc)
		{
			ProcCalls.Add(proc.GetProc());
		}

		public void AddProc(StatsMessage proc)
		{
			ProcCalls.Add(proc.GetProc());
		}

			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\GI\PresenceTitleConfig.cs ===
using System;
using System.Text;
using System.Collections;

using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;

namespace ServerTestFramework.LiveService.GI
{
	
	public class Translation
	{
		public string Locale;
		public string Value;

		public Translation() : this("en-US")
		{}

		public Translation(string locale)
		{
			Locale = locale;
			Value = "";
		}
	}

	public class LocalizedString
	{
		public uint Id;
		public Translation[] Translations
		{
			get {
				return (Translation[])_Translations.ToArray(typeof(Translation));
			}
		}
		private ArrayList _Translations;

		public LocalizedString()
		{
			_Translations = new ArrayList();
		}

		public void AddTranslation(string locale, string value)
		{
			Translation found = GetTranslation(locale);

			if(null == found)
			{
				found = new Translation(locale);	
				_Translations.Add(found);
			}

			found.Value = value;
		}

		public Translation GetTranslation(string locale)
		{
			Translation returnValue = null;

			foreach(Translation tr in _Translations)
			{
				if(tr.Locale == locale)
				{
					returnValue = tr;
					break;
				}
			}

			return returnValue;
		}
	}

	public class ContextValue : IComparable
	{
		public uint Value;
		public uint StringId;


		public ContextValue()
		{
			Value = 0;
			StringId = 0;
		}

		public ContextValue(uint value, uint stringId)
		{
			Value = value;
			StringId = stringId;
		}

		// From IComparable
		public int CompareTo(object obj)
		{
			if(obj is ContextValue) 
			{
				ContextValue otherValue = (ContextValue)obj;
				return Value.CompareTo(otherValue.Value);
			}

			throw new ArgumentException("object is not a ContextValue");
		}
	}

	public class Context
	{
		public bool IsGameMode;
		public uint Id;
		public uint StringId;

		public ContextValue[] Values
		{
			get {
				return (ContextValue[])_Values.ToArray(typeof(ContextValue));
			}
		}
		private ArrayList _Values;

		public Context()
		{
			_Values = new ArrayList();
		}

		public ContextValue AddContextValue(uint valueId, uint stringId)
		{
			ContextValue contextValue = GetContextValue(valueId);
			if(null == contextValue)
			{
				contextValue = new ContextValue(valueId, stringId);
				_Values.Add(contextValue);
			}
			else
			{
				contextValue.StringId = stringId;
			}

			_Values.Sort();

			return contextValue;
		}

		public ContextValue GetContextValue(uint valueId)
		{
			ContextValue returnValue = null;
			foreach(ContextValue value in _Values)
			{
				if(value.Value == valueId)
				{
					returnValue = value;
					break;
				}
			}

			return returnValue;
		}
	}

	public class PresenceMode : IComparable
	{
		public uint ContextValue;
		public uint StringId;

		public PresenceMode()
		{
			ContextValue = 0;
			StringId = 0;
		}

		public PresenceMode(uint contextValue, uint stringId)
		{
			ContextValue = contextValue;
			StringId = stringId;
		}

		// From IComparable
		public int CompareTo(object obj)
		{
			if(obj is PresenceMode)
			{
				PresenceMode otherMode = (PresenceMode)obj;
				return ContextValue.CompareTo(otherMode.ContextValue);
			}

			throw new ArgumentException("object is not a PresenceMode");
		}

	}

	public class PresenceTitleConfig
	{
		// from npdb.t_settings vc_setting like '%locale%'
		public enum LanguageId  : byte
		{
            // console supported
			EN = 1,
			JA = 2,
			DE = 3,
			FR = 4,
			ES = 5,
			IT = 6,
			KO = 7,
			ZH = 8,
			PT = 9,
            CHS = 10,
            PL = 11,
            RU = 12,

            // live supported
            DA = 13,
            FI = 14,
            NB = 15,
            NL = 16,
            SV = 17,

            // unsupported
            HU = 18,
            CS = 19,
            CZ = 20,
            HK = 21,
            SK = 22

		}
		
		// from npdb.t_countries
		public enum CountryId : byte
		{
			US = 103,
			JP = 53,
			DE = 24,
			FR = 34,	
			ES = 31,
			IT = 50,	
			KR = 56,
            CN = 20,
			TW = 101,
			PT = 84,
            PL = 82,
            RU = 88,

            DK = 25,
            FI = 32,
            NO = 70,
            NL = 74,
            SE = 90,


			
			// Unsupported ATM
            AT = 5,
            AU = 6,
            BE = 8,
            BG = 9,
            BR = 13,
            CA = 16,
            CH = 18,
            CL = 19,
            CO = 21,
            CZ = 23,
            GB = 35,
            GR = 37,
			HK = 39,
            HU = 42,
			IE = 44,
            IN = 46,
            MX = 71, 
            NZ = 76,
            SG = 91,
            SK = 93,
            ZA = 109
		}
		
		public class LocaleSpec
		{
			public byte   LanguageId;
			public byte   CountryId;
			public string Locale;
			public bool   Supported;
			
			public LocaleSpec(byte languageId, byte countryId, string locale) : this(languageId, countryId, locale, false)
			{}
			
			public LocaleSpec(byte languageId, byte countryId, string locale, bool supported) 
			{
				LanguageId = languageId;
				CountryId  = countryId;
				Locale     = locale;
				Supported  = supported;
			}
		}
			
		// from t_settings t_setting like '%valid%' (valid locales)
		public static LocaleSpec[] LocaleTable = new LocaleSpec[]
		{
			new LocaleSpec((byte)LanguageId.DA, (byte)CountryId.DK, "da-DK"),
			new LocaleSpec((byte)LanguageId.DE, (byte)CountryId.AT, "de-AT"),
			new LocaleSpec((byte)LanguageId.DE, (byte)CountryId.CH, "de-CH"),
			new LocaleSpec((byte)LanguageId.DE, (byte)CountryId.DE, "de-DE"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.AU, "en-AU"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.CA, "en-CA"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.GB, "en-GB"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.HK, "en-HK"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.IE, "en-IE"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.NZ, "en-NZ"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.SG, "en-SG"),
			new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.US, "en-US", true),
			new LocaleSpec((byte)LanguageId.ES, (byte)CountryId.ES, "es-ES", true),
			new LocaleSpec((byte)LanguageId.ES, (byte)CountryId.MX, "es-MX"),
			new LocaleSpec((byte)LanguageId.FI, (byte)CountryId.FI, "fi-FI"),
			new LocaleSpec((byte)LanguageId.FR, (byte)CountryId.BE, "fr-BE"),
			new LocaleSpec((byte)LanguageId.FR, (byte)CountryId.CA, "fr-CA"),
			new LocaleSpec((byte)LanguageId.FR, (byte)CountryId.CH, "fr-CH"),
			new LocaleSpec((byte)LanguageId.FR, (byte)CountryId.FR, "fr-FR", true),
			new LocaleSpec((byte)LanguageId.IT, (byte)CountryId.IT, "it-IT", true),
			new LocaleSpec((byte)LanguageId.JA, (byte)CountryId.JP, "ja-JP", true),
			new LocaleSpec((byte)LanguageId.KO, (byte)CountryId.KR, "ko-KR", true),
			new LocaleSpec((byte)LanguageId.NL, (byte)CountryId.BE, "nl-BE"),
			new LocaleSpec((byte)LanguageId.NL, (byte)CountryId.NL, "nl-NL"),
			new LocaleSpec((byte)LanguageId.NB, (byte)CountryId.NO, "nb-NO"),
			new LocaleSpec((byte)LanguageId.SV, (byte)CountryId.SE, "sv-SE"),
			new LocaleSpec((byte)LanguageId.ZH, (byte)CountryId.HK, "zh-HK"),
			new LocaleSpec((byte)LanguageId.ZH, (byte)CountryId.TW, "zh-TW",  true),
			new LocaleSpec((byte)LanguageId.PT, (byte)CountryId.PT, "pt-PT",  true),
   			new LocaleSpec((byte)LanguageId.ZH, (byte)CountryId.CH, "zh-TW",  true), // zh-CHT converts to zh-TW
            new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.PT, "en-PT"),
            new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.GR, "en-GR"),
            new LocaleSpec((byte)LanguageId.ES, (byte)CountryId.CO, "es-CO"),
            new LocaleSpec((byte)LanguageId.ES, (byte)CountryId.CL, "es-CL"),
            new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.ZA, "en-ZA"),
            new LocaleSpec((byte)LanguageId.EN, (byte)CountryId.IN, "en-IN"),
            new LocaleSpec((byte)LanguageId.PT, (byte)CountryId.BR, "pt-BR"),
            new LocaleSpec((byte)LanguageId.PL, (byte)CountryId.PL, "pl-PL",  true),
            new LocaleSpec((byte)LanguageId.HU, (byte)CountryId.HU, "hu-HU"),
            new LocaleSpec((byte)LanguageId.CS, (byte)CountryId.CZ, "cs-CZ"),
            new LocaleSpec((byte)LanguageId.SK, (byte)CountryId.SK, "sk-SK"),
            new LocaleSpec((byte)LanguageId.RU, (byte)CountryId.RU, "ru-RU",  true)//,
            //new LocaleSpec((byte)LanguageId.CHS, (byte)CountryId.CN, "zh-CHS",  true)
        };

		// Emulate these rows in the database
		public int      TitleId;
		public DateTime Changed;
		public string   DefaultLocale;

		private Hashtable _LocalizedStrings;
		private ArrayList _Contexts;
		private ArrayList _PresenceModes;
		private uint _NextStringGenId;

		public PresenceTitleConfig(int titleId)
		{

			TitleId          = titleId;
			Changed          = DateTime.Now;
			DefaultLocale    = "en-US"; // I believe this is an XLAST assumption as well
			_NextStringGenId  = 1000;
			_LocalizedStrings = new Hashtable();
			_Contexts         = new ArrayList();
			_PresenceModes    = new ArrayList();
		}

		public uint AddDefaultLocalizedString(string strValue)
		{
			return AddLocalizedString(_NextStringGenId++, DefaultLocale, strValue);
		}

		public uint AddDefaultLocalizedString(uint stringId, string strValue)
		{
			return AddLocalizedString(stringId, DefaultLocale, strValue);
		}

		public uint AddLocalizedString(string locale, string strValue)
		{
			return AddLocalizedString(_NextStringGenId++, locale, strValue);
		}

		public uint AddLocalizedString(uint stringId, string locale, string strValue)
		{
			LocalizedString lcs = _LocalizedStrings[stringId] as LocalizedString;
			if(null == lcs)
			{
				lcs = new LocalizedString();
				lcs.Id = stringId;
				_LocalizedStrings[stringId] = lcs;
			}
			lcs.AddTranslation(locale, strValue);

			return stringId;
		}

		public string GetDefaultLocalizedString(uint stringId)
		{
			return GetLocalizedString(stringId, DefaultLocale);
		}

		public string GetLocalizedString(uint stringId, string locale)
		{
			string returnValue = "";
			LocalizedString  lcs = _LocalizedStrings[stringId] as LocalizedString;
			if(null != lcs)
			{
				Translation translation = lcs.GetTranslation(locale);
				if(null != translation)
				{
					returnValue = translation.Value;
				}
			}

			return returnValue;
		}

		public string GetLocalizedStringOrDefault(uint stringId, string locale)
		{
			string returnValue = GetLocalizedString(stringId, locale);
			if(returnValue.Length == 0)
			{
				returnValue = GetDefaultLocalizedString(stringId);
			}
			return returnValue;
		}

		public Translation[] GetLocalizedStrings(uint stringId)
		{
			Translation[] returnValue = null;
			LocalizedString lcs = _LocalizedStrings[stringId] as LocalizedString;
			if(null != lcs)
			{
				returnValue = lcs.Translations;
			}
			return returnValue;
		}

		public Context AddGameMode(uint contextId, uint contextNameStringId)
		{
			return AddContext(true, contextId, contextNameStringId);
		}

		public Context AddContext(uint contextId, uint contextNameStringId)
		{
			return AddContext(false, contextId, contextNameStringId);
		}

		public Context AddContext(bool isGameMode, uint contextId, uint contextNameStringId)
		{
			Context returnValue = GetContext(contextId);
			if(returnValue == null)
			{
				returnValue = new Context();
				returnValue.Id = contextId;
				_Contexts.Add(returnValue);
			}

			returnValue.StringId = contextNameStringId;
			returnValue.IsGameMode = isGameMode;

			return returnValue;
		}

		public Context GetContext(uint contextId)
		{
			Context returnValue = null;

			foreach(Context context in _Contexts)
			{
				if(context.Id == contextId)
				{
					returnValue = context;
				}
			}
			return returnValue;
		}

		public void AddContextValues(uint contextId, uint contextNameStringId, ContextValue[] contextValues)
		{
			Context context = GetContext(contextId);
			if(null == context)
			{
				context = new Context();
				context.Id = contextId;
				_Contexts.Add(context);
			}

			context.StringId = contextNameStringId;

			foreach(ContextValue contextValue in contextValues)
			{
				context.AddContextValue(contextValue.Value, contextValue.StringId);
			}
		}

		public ContextValue AddContextValue(uint contextId, uint contextNameStringId, uint contextValueId, uint contextValueStringId)
		{
			ContextValue returnValue = null;
			Context context = GetContext(contextId);
			if(null == context)
			{
				context = new Context();
				context.Id = contextId;
			}

			context.StringId = contextNameStringId;
			returnValue = context.AddContextValue(contextValueId, contextValueStringId);

			return returnValue;
		}

		public ContextValue GetContextValue(uint contextId, uint contextValue)
		{
			ContextValue returnValue = null;

			Context context = GetContext(contextId);
			if(null != context)
			{
				returnValue = context.GetContextValue(contextValue);
			}

			return returnValue;
		}

		public PresenceMode AddPresenceMode(uint modeValue, uint formatStringId)
		{
			PresenceMode mode = GetPresenceMode(modeValue);
			if(null == mode)
			{
				mode = new PresenceMode(modeValue, formatStringId);
				_PresenceModes.Add(mode);
				_PresenceModes.Sort();
			}
			else
			{
				mode.StringId = formatStringId;
			}

			return mode;
		}

		public string GetPresenceModeFormatString(uint modeValue, string locale)
		{
			string returnValue = "";

			PresenceMode mode = GetPresenceMode(modeValue);
			if(null != mode)
			{
				returnValue = GetLocalizedStringOrDefault(mode.StringId, locale);
			}

			return returnValue;
		}

		public PresenceMode GetPresenceMode(uint modeValue)
		{
			PresenceMode returnValue = null;

			foreach(PresenceMode mode in _PresenceModes)
			{
				if(mode.ContextValue == modeValue)
				{
					returnValue = mode;
					break;
				}
			}

			return returnValue;
		}

		// The xml_config row is built up on request I only store the data elements in memeory
		// for a given set of tests. This accessor is used to build the Xlast file on demand.
		public string BuildXml()
		{
			StringBuilder sb = new StringBuilder(1024);

			sb.Append("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");

			EmitElement(sb, Element.Open, "XboxLiveSubmissionProject", 
					"Version", "1.0",
					"xmlns:xsd", "http://www.w3.org/2001/XMLSchema",
					"xmlns", "http://www.xboxlive.com/xlast"); // default namespace
			{

				EmitElement(sb, Element.Open, "GameConfigProject", 
						"titleId", "0x" + TitleId.ToString("X"));
				{

					// 
					// Emit localized string data
					//
					EmitElement(sb, Element.Open, "LocalizedStrings",
							"defaultLocale", "en-US");
					{
                        foreach (LocaleSpec ls in LocaleTable)
                        {
                            if (ls.Supported)
                                EmitElement(sb, Element.Single, "SupportedLocale", "locale", ls.Locale);
                        }
						foreach(LocalizedString lcs in _LocalizedStrings.Values)
						{
							EmitElement(sb, Element.Open, "LocalizedString",
									"id", lcs.Id);
							foreach(Translation lcst in lcs.Translations)
							{
								EmitElement(sb, Element.Open, "Translation",
										"locale", lcst.Locale);

								sb.Append(lcst.Value);

								EmitElement(sb, Element.Close, "Translation");
							}
							EmitElement(sb, Element.Close, "LocalizedString");
						}
					}
					EmitElement(sb, Element.Close, "LocalizedStrings");

					//
					// Emit GameModes (specialized context)
					//
					EmitElement(sb, Element.Open, "GameModes",
							"defaultValue", 0);

					uint gameModeCount = 0;
					foreach(Context ctx in _Contexts)
					{
						// Skip normal contexts
						if(!ctx.IsGameMode)
						{
							continue;
						}

						if(1 == gameModeCount++)
						{
							throw new UnexpectedTestResultException("Game mode should only be set on a single context container object");
						}

						foreach(ContextValue ctxval in ctx.Values)
						{
							EmitElement(sb, Element.Single, "GameMode",
									"value", ctxval.Value,
									"stringId", ctxval.StringId);
						}
					}
					EmitElement(sb, Element.Close, "GameModes");

					//
					// Emit ContextValues
					//
					EmitElement(sb, Element.Open, "Contexts");
					foreach(Context ctx in _Contexts)
					{
						// Skip game mode contexts
						if(ctx.IsGameMode)
						{
							continue;
						}

						EmitElement(sb, Element.Open, "Context",
								"id", ctx.Id,
								"stringId", ctx.StringId);
						foreach(ContextValue ctxval in ctx.Values)
						{
							EmitElement(sb, Element.Single, "ContextValue",
									"value", ctxval.Value,
									"stringId", ctxval.StringId);
						}
						EmitElement(sb, Element.Close, "Context");
					}
					EmitElement(sb, Element.Close, "Contexts");


					//
					// Emit PresenceModes
					//
					EmitElement(sb, Element.Open, "Presence",
							"defaultPresenceMode", 0);
					foreach(PresenceMode pm in _PresenceModes)
					{
						EmitElement(sb, Element.Single, "PresenceMode", 
								"contextValue", pm.ContextValue,
								"stringId",     pm.StringId);
					}
					EmitElement(sb, Element.Close, "Presence");
				}
				EmitElement(sb, Element.Close, "GameConfigProject");
			}
			EmitElement(sb, Element.Close, "XboxLiveSubmissionProject");

			return sb.ToString();
		}

		public void WriteToDatabase(bool overwrite)
		{
			NpdbUtility npdb = new NpdbUtility();
			npdb.ConnectToServer();

			GameConfigRow gameConfig = null;
			if(overwrite || HResult.S_OK != npdb.GetGameConfig((uint)TitleId, out gameConfig))
			{
				string xmlData = BuildXml();
				npdb.SaveGameConfig((uint)TitleId, xmlData, "TEST-AUTOGEN");
			}
		}

		//------------------------------------------------------------------------------
		// Internal types and methods
		//
		enum Element
		{
			Open,
			Close,
			Single
		}

		void EmitElement(StringBuilder sb, Element eltype, string name, params object[] args)
		{

			if(eltype == Element.Close)
			{
				sb.Append("</");
			}
			else
			{
				sb.Append("<");
			}

			sb.Append(name);

			if(1 == (args.Length & 1))
			{
				throw new ArgumentException("Args to EmitElement must contain an even number of name/value pairs");
			}

			for(int i = 0; i < args.Length; i += 2)
			{
				sb.Append(" ");
				sb.Append(args[i]);
				sb.Append("=\"");
				sb.Append(args[i+1]);
				sb.Append("\"");
			}

			if(eltype == Element.Single)
			{
				sb.Append(" />\n");
			}
			else if(eltype == Element.Close) 
			{
				sb.Append(">\n");
			}
			else if(eltype == Element.Open)
			{
				sb.Append(">");
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\LBServer\Protocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Text;

namespace ServerTestFramework.LiveService.LBServer
{

	public class  msgTypes
	{
		// Low-level LBSP Message Ids
		public static short  ReqHello		=1;
		public static short  RepHello       = 2;
		public static short  BeginRequest	= 3;
		public static short  ReqProcCall    = 5;
		public static short  RepRowsetStart = 8;
		public static short  RepRowsetRow   = 9;
		public static short  RepRowsetEnd   = 11;
		public static short  RepMessage     = 12;
		public static short  EndRequest		= 13;
	}
		
	// All LBSP messages start with this header
	[StructLayout(LayoutKind.Sequential)]
	public class MsgHeader: WireData
	{
		// Size of the message in bytes including header
		public short wMsgSize;
    
		// Message type. One of the LbspId* constants
		public short wMsgType;

		public MsgHeader(){}

		public MsgHeader(short size, short type)
		{
			wMsgSize=(short)(4+size); // 4 is size of MsgHeader.
			wMsgType=type;
		}
	};


	// ReqHello
	// Sent by the client upon establishing a connection
	[StructLayout(LayoutKind.Sequential)]
	public class ReqHello:WireData
	{
		// hdr.wMsgType = ReqHello
		public MsgHeader hdr= null;

		// Size in bytes of clientName. Maximum size is LbspMaxClientName
		public short clientNameLen=0;
    
		// Client name. ANSI string. Not null terminated
		public byte[] clientName;
		public ReqHello(string clientname)
		{
			
			clientName= Encoding.ASCII.GetBytes(clientname);
			hdr = new MsgHeader((short)(2+clientName.Length),msgTypes.ReqHello);
		}
	};

	// RepHello
	// Sent by the server in response to a ReqHello
	[StructLayout(LayoutKind.Sequential)]
	public class RepHello:WireData
	{
		//hdr.wMsgType = LbspIdRepHello;
		public MsgHeader hdr= null;
		// Connection id assigned by the Leaderboard Server. The client should 
		// include the connection id on its error messages and logs.  
		public int dwCid=0;
		public RepHello()
		{
		}
	};

	// BeginRequest
	// Sent by the client to start a request
	[StructLayout(LayoutKind.Sequential)]
	public  class BeginRequest:WireData
	{
		// hdr.wMsgType = ReqBeginRequest
		public MsgHeader hdr;
    
		// This is an arbitrary id assigned by the client. It will be used by
		// the server in error messages. It has no other purpose.
		public int dwReqId;
    
		// Number of procedures in the request
		public short wProcCount;

		public BeginRequest(short ProcCount,int Reqid)
		{
			wProcCount= ProcCount;
			dwReqId= Reqid;
			hdr = new MsgHeader(6,msgTypes.BeginRequest);

		}
	};

	[StructLayout(LayoutKind.Sequential)]
	public  class EndRequest:WireData
	{
		public int dwReqId;
	};

	// ReqProcCall
	// A procedure in a request
	[StructLayout(LayoutKind.Sequential)]
	public class ProcCall:WireData
	{
		// hdr.wMsgType = LbspIdReqProcCall
		[WireInfo(Serialize=false)]
		public MsgHeader hdr= null;
    
		// The id of the server procedure 
		[WireInfo(Serialize=false)]
		public int dwProcId;
	
		// Number of parameters in rgParam
		[WireInfo(Serialize=false)]
		public short  ParamsLen;
	
		// Procedure parameters
		// (this array is part of this message and should be taken in 
		// consideration when specifying the size of the message in the header)
		[WireInfo(Serialize=false)]
		public ProcParam[] Params;

		[WireInfo(Serialize=false)]
		short PCount=0; 

		public ProcCall(int ProcID, short ParamCount)
		{
			dwProcId=ProcID;
			ParamsLen=ParamCount;
			Params = new ProcParam[ParamCount];

		}

		public void AddParam(byte data)
		{
			Params[PCount++]= new ProcParam(data);
		}

		public void AddParam(short data)
		{
			Params[PCount++]= new ProcParam(data);
		}

		public void AddParam(int data)
		{
			Params[PCount++]= new ProcParam(data);
		}
		public void AddParam(long data)
		{
			Params[PCount++]= new ProcParam(data);
		}
		public void AddParam(double data)
		{
			Params[PCount++]= new ProcParam(data);
		}
		public void AddParam(string data)
		{
			Params[PCount++]= new ProcParam(data);
		}

		
		override public void WriteStream(BinaryWriter writer)
		{
			MemoryStream tmp = new MemoryStream();
			BinaryWriter twriter= new BinaryWriter(tmp);

			twriter.Write(dwProcId);
			twriter.Write(ParamsLen);
			for(int i=0;i<Params.Length;i++)
				Params[i].WriteStream(twriter);
			hdr = new MsgHeader((short)tmp.Length,msgTypes.ReqProcCall);

			hdr.WriteStream(writer);
			writer.Write(tmp.ToArray());

		}
	};

	// response of ProcCall
	[StructLayout(LayoutKind.Sequential)]
	public class ProcCallResp:WireData
	{
		[WireInfo(Serialize=false)]
		public Message ErrMsg= null;
		[WireInfo(Serialize=false)]
		public ArrayList RowsetRows= new ArrayList();

		override public WireData ReadStream(BinaryReader reader)
		{
			// read header
			MsgHeader hr =(MsgHeader) new MsgHeader().ReadStream(reader);
			if(hr.wMsgType== msgTypes.RepMessage)
			{
				// error message recived.
				ErrMsg =(Message) new Message().ReadStream(reader);
				
			}
			else if(hr.wMsgType== msgTypes.RepRowsetStart)
			{
				while(true)
				{
					MsgHeader head = (MsgHeader)new MsgHeader().ReadStream(reader);
					if(head.wMsgType==msgTypes.RepRowsetRow)
					{
						RowsetRow tmp =(RowsetRow) new RowsetRow().ReadStream(reader);
						RowsetRows.Add(tmp);
					}
					else if (head.wMsgType==msgTypes.RepRowsetEnd)
					{
						break;
					}
					else
						throw new Exception("Invalid message Recived");
				}
			}
			else if(hr.wMsgType== msgTypes.EndRequest)
			{
				EndRequest tmp = (EndRequest)new EndRequest().ReadStream(reader);
				return null;
			}
			else
			{
				throw new Exception("Unexpected message recived #:"+hr.wMsgType.ToString());
			}
			
				return this;


		}
		
	};


	// response of ProcCall
	[StructLayout(LayoutKind.Sequential)]
	public class RowsetRow :WireData
	{
		public short rgColumnsLen;
		public ProcParam[] rgColumns;
	};

	[StructLayout(LayoutKind.Sequential)]
	public class Message :WireData
	{
		public int dwErrorId;
		public short textLen;
		public string text;

			
	};


	// ProcParam
	// A parameter in a procedure call
	[StructLayout(LayoutKind.Sequential)]
	public class ProcParam:WireData
	{
		// The type of the parameter. One of the LbspTypeId* constants.
		public byte bParamType;
		public Param pvalue= null;
		
		public ProcParam()
		{
		}

		public ProcParam(byte data)
		{
			bParamType =(byte)TypeID.Int8;
			pvalue = new ParamINT8(data);
 		}
		public ProcParam(short data)
		{
			bParamType =(byte)TypeID.Int16;
			pvalue = new ParamINT16(data);
 		}
		public ProcParam(int data)
		{
			bParamType =(byte)TypeID.Int32;
			pvalue = new ParamINT32(data);
		}
		public ProcParam(long data)
		{
			bParamType =(byte)TypeID.Int64;
			pvalue = new ParamINT64(data);
		}
		public ProcParam(double data)
		{
			bParamType =(byte)TypeID.Double;
			pvalue = new ParamDouble(data);
		}
		public ProcParam(string data)
		{
			bParamType =(byte)TypeID.String;
			pvalue = new ParamString(data);
		}


		override public WireData ReadStream(BinaryReader reader)
		{
			
			bParamType = reader.ReadByte();

			if((bParamType & (byte)TypeID.NullFlag) ==(byte)TypeID.NullFlag)
			{
				// parameter is null ignore it .
			}
			else
			{
				switch (bParamType)
				{
					case (byte)TypeID.Int8:
						pvalue = (Param)new ParamINT8().ReadStream(reader);
						break;
					case (byte)TypeID.Int16:
						pvalue = (Param)new ParamINT16().ReadStream(reader);
						break;
					case (byte)TypeID.Int32:
						pvalue = (Param)new ParamINT32().ReadStream(reader);
						break;
					case (byte)TypeID.Int64:
						pvalue = (Param)new ParamINT64().ReadStream(reader);
						break;
					case (byte)TypeID.Double:
						pvalue = (Param)new ParamDouble().ReadStream(reader);
						break;
					case (byte)TypeID.String:
						pvalue = (Param)new ParamString().ReadStream(reader);
						break;
				}
			}

			return this;
		}

		override public void WriteStream(BinaryWriter writer)
		{
			writer.Write(bParamType);
			if (pvalue != null)
				pvalue.WriteStream(writer);
		}

	}

	public enum TypeID
	{
		Int8	 = 0x01,
		Int16	 = 0x02,
		Int32	 = 0x03,
		Int64	 = 0x04,
		Double	 = 0x05,
		String	 = 0x06,
		NullFlag = 0x80

	}

	// This is the value of the parameter. The value type and its size on the 
	// wire depends entirely on bParamType. For example, if bParamType ==
	// LbspTypeIdInt16, then the size of the parameter on the wire is 
	// sizeof(bParamType) + sizeof(i16Param) == 3.
	[StructLayout(LayoutKind.Sequential)]
	public class Param:WireData
	{
	}

	[StructLayout(LayoutKind.Sequential)]
	public class ParamINT8:Param
	{
		public byte val;
		public ParamINT8(){}
		public ParamINT8(byte data)
		{
			val=data;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public class ParamINT16:Param
	{
		public short val;
		public ParamINT16(){}
		public ParamINT16(short data)
		{
			val=data;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public class ParamINT32:Param
	{
		public int val;
		public ParamINT32(){}
		public ParamINT32(int data)
		{
			val=data;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public class ParamINT64:Param
	{
		public long val;
		public ParamINT64(){}
		public ParamINT64(long data)
		{
			val=data;
		}
	}
	
	[StructLayout(LayoutKind.Sequential)]
	public class ParamDouble:Param
	{
		public double val;
		public ParamDouble(){}
		public ParamDouble(double data)
		{
			val=data;
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	public class ParamString:Param
	{
		[WireInfo(Serialize=false)]
		public string val;

		public ParamString(){}
		public ParamString(string data)
		{
			val=data;
		}
		override public WireData ReadStream(BinaryReader reader)
		{
			short len = reader.ReadInt16(); // length of the string 
			if(len>0)
			{
				byte[] bytes= reader.ReadBytes(len);
				val = new string(Encoding.ASCII.GetChars(bytes));
			}
			return this;
		}
		override public void WriteStream(BinaryWriter writer)
		{
			if(val.Length>0)
			{
				writer.Write((short)Encoding.ASCII.GetByteCount(val));
				writer.Write(Encoding.ASCII.GetBytes(val));
			}
			else
				writer.Write((short)0);
		}
	}








	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\liveinfo\XRLGetLiveConfig.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService.LiveInfo
{
    /// <summary>
    /// This class is for getting live config data from the live registry.
    /// </summary>
    public class XRLGetLiveConfig: XRLPayload<GetLiveConfigRequest, GetLiveConfigResponse>
    {
        /// <summary>
        /// default constructor for XRLGetLiveConfig
        /// normally will be used for negative test cases
        /// </summary>
        public XRLGetLiveConfig(string Configname)
        {
            SetConfigName(Configname);

            Slot.machinePuid=0;
            Slot.ClearServices();
            Slot.AddService(XOService.Liveinfo);
        }

        public XRLGetLiveConfig(): this("default")
        {
        }

        public void SetConfigName(string name)
        {
            Request.configname=name;
            Request.confignameLen=(ushort)name.Length;
        }

        public void SetBetaGroupFlag(bool value)
        {
            if (value)
            {
                Slot.authDataFlags|=CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
            else
            {
                Slot.authDataFlags&=~CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
        }

        public void SetClientVersion(ushort major, ushort minor, ushort build, ushort qfe)
        {
            Slot.wMajorVersion=major;
            Slot.wMinorVersion=minor;
            Slot.wBuildNumber=build;
            Slot.wQFENumber=qfe;
        }

        public override bool Execute()
        {
            System.Net.IPEndPoint ep=Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.liveinfo);
            if (Execute(ep))
            {
                xonline.common.protocol.BlockDeserializer deserializer=new xonline.common.protocol.BlockDeserializer(Response.configBlocks);
                byte []blob=deserializer.Deserialize();
                Response.config=System.Text.UTF8Encoding.UTF8.GetString(blob);
                return true;
            }

            return false;
        }

        public System.Collections.Generic.Dictionary<string, string> ParseResponseSettings ()
        {
            return ParseResponseSettings(true);
        }

        //parses the response into a dictionary of strings representing the settings
        public System.Collections.Generic.Dictionary<string, string> ParseResponseSettings (bool toLowerNames)
        {
            xonline.common.protocol.BlockDeserializer deserializer=new xonline.common.protocol.BlockDeserializer(Response.configBlocks);
            byte []deserializedBytes=deserializer.Deserialize();
            string liveinfoResponse=System.Text.UTF8Encoding.UTF8.GetString(deserializedBytes);

            return ParseResponseString(liveinfoResponse, toLowerNames);
        }

        public static System.Collections.Generic.Dictionary<string, string> ParseResponseString (string responseString)
        {
            return ParseResponseString(responseString, true);
        }

        //parses a string taken from a liveinfo response into a dictionary of strings
        public static System.Collections.Generic.Dictionary<string, string> ParseResponseString(string responseString, bool toLowerNames)
        {
            System.Collections.Generic.Dictionary<string, string> settings = new System.Collections.Generic.Dictionary<string, string>();
            System.Collections.Generic.Dictionary<string, string> settingsCased = new System.Collections.Generic.Dictionary<string, string>();
            string splitMe = responseString;
            int startIndex = 0;

            while(splitMe.IndexOfAny(new char[] { ';' }, startIndex) != -1)
            {
                int toSplit = splitMe.IndexOfAny(new char[] { ';' }, startIndex);


                if((splitMe[toSplit -1]) != '^')
                {
                    string settingString = splitMe.Substring(0, toSplit+1);

                    settingString = EscapeReplacementReverse(settingString);

                    //
                    // Split apart the setting and value
                    // then remove the semi that is supposed to seperate settings.
                    string setting = settingString.Substring(0, settingString.IndexOfAny(new char[] {'='}));
                    string value = settingString.Substring(settingString.IndexOfAny(new char[] {'='}) + 1);
                    value = value.Remove(value.Length - 1);

                    //
                    // Only insert if the setting doesn't already exist
                    // We don't want to write over the build specific
                    // values.
                    //
                    if(!settings.ContainsKey(setting.ToLower()))
                    {
                        settings.Add(setting.ToLower(), value);
                        settingsCased.Add(setting, value);
                    }

                    splitMe = splitMe.Remove(0, toSplit+1);
                    startIndex = 0;
                }
                else
                {
                    startIndex = toSplit+1;
                }
            }

            return (toLowerNames ? settings : settingsCased);
        }

        private static string EscapeReplacementReverse(string _setting)
        {
            _setting = _setting.Replace("^=", "=");
            _setting = _setting.Replace("^;", ";");
            _setting = _setting.Replace("^^", "^");

            return _setting;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\LBServer\LBSClient.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Net.Sockets;
using ServerTestFramework;
using ServerTestFramework.LiveService;


namespace ServerTestFramework.LiveService.LBServer
{
    /// <summary>
    /// Summary description for LBSClient.
    /// </summary>
    public class LBSClient
    {
        protected TcpClient client=null;
        public int ReciveTimeOut= 35000;
        public int SendTimeOut=35000;
        public string Name;
        public int ClientID=0;
        System.Net.Sockets.NetworkStream outStream=null;

        public LBSClient(string name)
        {
            Name=name;
        }

        public void Connect(IPEndPoint endPoint)
        {
            if (null != client)
            {
                client.Close();
            }

            client = new TcpClient();
            client.ReceiveTimeout = ReciveTimeOut;
            client.SendTimeout    = SendTimeOut;

            try
            {
                client.Connect(endPoint);
                
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                throw e;
            }

            try
            {
                // send LBSHellomessage
                outStream=client.GetStream();
                ReqHello hello= new ReqHello(Name);
                byte[] req= (byte[])hello;
                outStream.Write(req,0,req.Length);

                byte []responseData=new byte[client.ReceiveBufferSize];
                outStream.Read(responseData,0,responseData.Length);

                RepHello resp =(RepHello)new RepHello().ReadBytes(responseData);

                if(resp.hdr.wMsgType ==msgTypes.RepHello)
                    ClientID=resp.dwCid;
                else
                {
                    throw new Exception("Invalid Response from server expected RepHello recived #:"+resp.hdr.wMsgType.ToString());

                }
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);

                DisConnect();

                throw new Exception(e.Message, e);
            }
        }

        public void DisConnect()
        {
            if (outStream != null)
            {
                outStream.Close();
                outStream = null;
            }

            if (client != null)
            {
                client.Close();
                client = null;
            }
        }

        public ArrayList Execute(LBSRequest Req, int reqid)
        {
            ArrayList Resps = new ArrayList();

            if (outStream != null)
            {
                //send a beginrequest message
                short ProcCount = (short)Req.ProcCalls.Count;

                BeginRequest breq = new BeginRequest(ProcCount, reqid);
                byte[] req0 = (byte[])breq;
                outStream.Write(req0, 0, req0.Length);

                //send all calls to LBServer.
                foreach (ProcCall proc in Req.ProcCalls)
                {
                    byte[] req = (byte[])proc;
                    outStream.Write(req, 0, req.Length);
                }
                // read the Response and build the ProcResp.

                BinaryReader reader = new BinaryReader(outStream);
                while (true)
                {
                    ProcCallResp tmp = (ProcCallResp)new ProcCallResp().ReadStream(reader);
                    if (tmp == null)
                        break;
                    else
                        Resps.Add(tmp);

                }
            }
            else
            {
                throw new Exception("call connect before calling Execute");
            }
            

            return Resps;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\liveinfo\XRLGetNetworkAuthorizationList.cs ===
using System;
using System.Collections;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.config;

namespace ServerTestFramework.LiveService.LiveInfo
{
    /// <summary>
    /// Wraps the GetNetworkAuthorizationList which provides a set of endpoints that 
    /// a title is able to connect to and some additional metadata about them.
    /// </summary>
    public class XRLGetNetworkAuthorizationList : XRLPayload<GetNetworkAuthorizationListRequest, GetNetworkAuthorizationListResponse>
    {
        /// <summary>
        /// Represents the title that the request is being made from
        /// </summary>
        public UInt32 TitleId { get; set; }

        /// <summary>
        /// Create an empty GetNetworkAuthorizationList request
        /// </summary>
        public XRLGetNetworkAuthorizationList() { }

        /// <summary>
        /// Create a GetNetworkAuthorizationList request for the given title id
        /// </summary>
        /// <param name="titleId">The title to request an authorization list for</param>
        public XRLGetNetworkAuthorizationList(UInt32 titleId)
        {
            this.TitleId = titleId;
        }

        /// <summary>
        /// Execute a GetNetworkAuthorizationList request against the default LiveInfo interface
        /// </summary>
        /// <returns></returns>
        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(Interface.liveinfo));
        }

        public override void PopulateSlot(ref ServerTestFramework.LiveService.FakeSG.CSGInfo slot)
        {
            base.PopulateSlot(ref slot);

            slot.titleId = this.TitleId;
        }

        protected override void SetServices()
        {
            Slot.ClearServices();
            Slot.AddService(XOService.Liveinfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\MatchPartUtil.cs ===
using System;
using ServerTestFramework.LiveService;


namespace ServerTestFramework.LiveService.Matchmaking
{
    public class MatchPartUtil {
        const long DEFAULT_TYPE = Constants.X_ATTRIBUTE_GAME_TYPE_RANKED;
        
        const long DEFAULT_FIRST_MODE = Constants.CONTEXT_GAME_MODE_MODEA;
        const long DEFAULT_SECOND_MODE = Constants.CONTEXT_GAME_MODE_MODEB;

        public const uint DEFAULT_TITLEID = Constants.XENON_PARTITIONED_TITLE;

        public static MatchSession CreateGenericSession(string name) {
            return CreateGenericSession(name, DEFAULT_TYPE, DEFAULT_FIRST_MODE); //this is the
                                                                   //default in XRL2CreateUpdateSession.cs
        }
        
        //generic form that takes a starting type and mode as well.
        public static MatchSession CreateGenericSession(string name, long type, long mode) {
            return CreateGenericSession(name, type, mode, DEFAULT_TITLEID);
        }

        //super-generic form that takes titleid too.  Should be used rarely, as partitioning tests
        //should use the partitioning title.
        public static MatchSession CreateGenericSession(string name, long type, long mode, uint titleid) {
            // create a session with no custom attributes first
            uint titleID = titleid;
            MatchSession testSession = new MatchSession(false);
            testSession.TitleID = titleID;
            //let's add an attribute we expect no one else to have, so we can ID this session later
            testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, 
                                                          new XRLXeStringValue(name)),
                                     false); //Don't update!  Wait till creation.
            //set the initial type
            testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                          new XRLXeIntValue(type)),
                                     false); //Don't update!  Wait till creation.
            //set the initial mode.
            testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                          new XRLXeIntValue(mode)),
                                     false); //Don't update!  Wait till creation.
            if (!testSession.Create()) { //now create.
                throw new Exception("Error on creating an ordinary session!  Err Msg:" + 
                                    testSession.GetErrorMsg());
            }
            return testSession;
        }

        //Create a breadcrumbed session.  This will have started on the server for mode A and moved
        //to the server for mode B.
        public static MatchSession CreateBreadcrumbedSession(string name) {
            return CreateBreadcrumbedSession(name, DEFAULT_TYPE, DEFAULT_FIRST_MODE, DEFAULT_SECOND_MODE);
        }

        //more generic form that can take any two modes.
        public static MatchSession CreateBreadcrumbedSession(string name, long type, long firstMode, long secondMode) {
            MatchSession testSession = CreateGenericSession(name, type, firstMode);
            if (! testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                new XRLXeIntValue(secondMode)))) {
                throw new Exception("Could not create a breadcrumbed session!  Update of game mode failed!");
            }
            return testSession;

        }

        //verify that a session is present, on the correct server, and can be found through
        //appropriate calls.
        public static bool PositiveVerify(MatchSession testSession) {
            bool success = true;
            success = MatchUtil.VerifySearchByID(testSession) && success;
            success = MatchUtil.VerifySearchByQuery(testSession) && success;
            success = MatchUtil.VerifyServerAndPartitionInfo(testSession) && success;

            return success;
        }

        //Like PostiveVerify, but it retries the query search multiple times.  This is
        //for round-robining verifies, because standard sessions get thrown on multiple servers.
        public static bool PositiveVerifyAndRetryQuery(MatchSession testSession) {
            bool success = true;
            success = MatchUtil.VerifySearchByID(testSession) && success;
            success = MatchUtil.VerifyServerAndPartitionInfo(testSession) && success;
            bool foundByQuery = false;
            for (int i=0; i<5; i++) {
                Global.RO.Info("Searching by query, attempt " + i + ".  Round-robining through servers to hit the session.  Errors can be ignored while retrying.");
                if (MatchUtil.VerifySearchByQuery(testSession)) {
                    foundByQuery = true;
                    break;
                }
            }
            return success && foundByQuery;
        }


        //verify a session is not present.
        public static bool NegativeVerify(MatchSession testSession) {
            bool success = true;
            success = MatchUtil.VerifySessionNotPresent(testSession) && success;
            return success;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\MatchSession.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Matchmaking
{

    public enum SessionType {
        Social,
        Ranked
    };

    /// <summary>
    /// MatchSessionMgr keeps track of all sessions created by Create and Split.
    /// It can then check the expected delay in time for a session ID to be deleted and
    /// verify the session no longer exists after that inverval has elapsed.
    /// </summary>
    public class MatchSessionMgr
    {
        /// <summary>
        /// Makes the code in this class a little more legible, otherwise adds nothing new to the conversation
        /// </summary>
        private class SessionIdList : Queue<long> { }

        /// <summary>
        /// Stores all registered sessions' IDs bucketed by Title ID
        /// </summary>
        private Dictionary<uint, SessionIdList> sessionIdsByTitleId = new Dictionary<uint, SessionIdList>();

        /// <summary>
        /// Returns the total number of sessions registered with the session manager
        /// </summary>
        public int RegisteredSessionsCount
        {
            get
            {
                lock (this)
                {
                    int count = 0;
                    foreach (SessionIdList sessionIdList in sessionIdsByTitleId.Values)
                    {
                        count += sessionIdList.Count;
                    }
                    return count;
                }
            }
        }

        /// <summary>
        /// RegisterSession stores the title and session IDs of a newly created/split session in order to 
        /// confirm the session's subsequent deferred deletion
        /// </summary>
        /// <param name="titleId">The title ID; used to get the expected delete delay seconds for this session ID</param>
        /// <param name="sessionId">The newly created or split session ID</param>
        public void RegisterSession(uint titleId, long sessionId)
        {
            lock (this)
            {
                if (!sessionIdsByTitleId.ContainsKey(titleId))
                {
                    sessionIdsByTitleId[titleId] = new SessionIdList();
                }
                sessionIdsByTitleId[titleId].Enqueue(sessionId);
            }
        }

        private void SortTitleInfoListByDelay(List<MatchTitle> matchTitles)
        {
            if (matchTitles == null)
            {
                throw new UnexpectedTestResultException("SortTitleInfoListByDelay: matchTitles cannot be null");
            }
            matchTitles.Sort(
                // Reflexivity, anti-symmetry, and transivity all in one convenient method
                delegate(MatchTitle x, MatchTitle y)
                {
                    if (x.DeleteDelaySeconds == y.DeleteDelaySeconds)
                    {
                        return 0;
                    }
                    else if (x.DeleteDelaySeconds < y.DeleteDelaySeconds)
                    {
                        return -1;
                    }
                    else
                    {
                        return 1;
                    }
                }
                );
        }

        /// <summary>
        /// Verifies all sessions registered via RegisterSession() get cleaned up.
        /// </summary>
        /// <returns>true: all sessions were cleaned up; false: a session existed after it should have been deleted</returns>
        public bool VerifyAllSessionsDeleted()
        {
            lock (this)
            {
                int slept = 0;
                List<MatchTitle> matchTitles = MatchTitleMgr.GetMatchTitlesByIds(sessionIdsByTitleId.Keys);
                SortTitleInfoListByDelay(matchTitles);
                foreach (MatchTitle matchTitle in matchTitles)
                {
                    if (matchTitle.DeleteDelaySeconds - slept > 0)
                    {
                        System.Threading.Thread.Sleep((matchTitle.DeleteDelaySeconds - slept) * 1000);
                        slept += matchTitle.DeleteDelaySeconds;
                    }

                    // Force a DeadXbox msg through the server to enable server session clean-up code
                    XRLDeadXBox deadXboxReq = new XRLDeadXBox((uint)matchTitle.TitleId);
                    deadXboxReq.sgaddr = new SGADDR();
                    if (!deadXboxReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        throw new Exception("DeadXBox failed with XErr == " + deadXboxReq.XErr);
                    }

                    SessionIdList sessionIds = sessionIdsByTitleId[(uint)matchTitle.TitleId];
                    System.Diagnostics.Debug.Assert(sessionIds.Count != 0, "It should be impossible to register a title w/o sessions");
                    for (int i = 0; i < sessionIds.Count; i++)
                    {
                        long sessionId = sessionIds.Dequeue();
                        if (MatchUtil.VerifySessionExists(matchTitle.DbList.Split(';'), (uint)matchTitle.TitleId, sessionId))
                        {
                            // Session should NOT exist at this point in time
                            return false;
                        }
                    }
                }
            }
            return true;
        }
    }


    //Class to represent SessionIDs.  They are transmitted down the wire in byte[], but are most
    //useful for debugging in long.  
    public class SessionID
    {
        private long _sessionID;

        public SessionID(byte[] sessionID)
        {
            _sessionID = sessionIDConvert(sessionID);
        }

        public SessionID(long sessionID)
        {
            _sessionID = sessionID;
        }

        // convert byte[8] to long; integer is little endian on the wire:
        // 01020304 on the wire is actually interpreted as int=0x04030201 internally
        // little endian locally
        public static long sessionIDConvert(byte[] sessID)
        {
            long lSessID = 0;
            for (int i = 7; i >= 0; i--)
            {
                lSessID <<= 8;
                lSessID += sessID[i];
            }
            return lSessID;
        }

        private static byte[] sessionIDConvert(long lSessID)
        {
            byte[] sessID = new byte[8];
            for (int i = 0; i < 8; i++)
            {
                sessID[i] = (byte)(lSessID & 0xFF);
                lSessID >>= 8;
            }
            return sessID;
        }

        public static explicit operator byte[](SessionID sessionID)
        {
            return sessionIDConvert(sessionID._sessionID);
        }

        public static implicit operator long(SessionID sessionID)
        {
            return sessionID._sessionID;
        }

        public override string ToString()
        {
            return "0x" + ((long)this).ToString("X");
        }
    }


    //A class to represent all match sessions.  Handles creation, update, and deletion.  Something
    //of a wrapper for createUpdate(which is itself a wrapper.  This one's smaller though.)
    public class MatchSession {
        //this single MatchSessionMgr entity keeps track of all sessions created.  On Creates, sessions are registered with
        //the manager.  The manager can then query the DB for each created session to ensure it was
        //deleted properly.
        public static MatchSessionMgr MatchSessionMgr = new MatchSessionMgr();

        private bool created;
        private bool skipCleanup = false; //if this is set, don't bother deleting the session on
                                          //deconstruction
        private bool allowUpdateAtAllTimes = false;  //if this is set, allow updates even on
                                                     //non-created or deleted sessions.  (useful in
                                                     //concurrency cases where you delete and then update)
        private bool requestsNeedMultiplayerPrivilege = false; //if this is set, the split and
                                                               //search will also have the
                                                               //multiplayer privilege given in the
                                                               //SGInfo.  Without it the
                                                               //search/split would not find the
                                                               //session.  Create/update stores this
                                                               //privilege so it's unnecessary.

        private XRL2CreateUpdateSession createUpdateReq;
        private uint titleID = Constants.XENON_TITLE; //the usual default

        private string initialServer;  //this holds either the whole session, or the breadcrumb of the
        //session, if the session has moved.
        private string sandwichServer; //when null, should correspond to a non-breadcrumbed session.
        //Otherwise holds the location of the sandwich.


        private InterfaceBucket initialBucket;  //this holds the bucket on which the session was
                                                //created.  The bucketID will never change, although
                                                //migrations may modify the actual bucket and will
                                                //require this to be synced.
        private InterfaceBucket sandwichBucket; //This holds the bucket which the session's type and
                                                //mode should point to.  For round-robined servers
                                                //the actual DBs must be searched to find which RRID
                                                //it happened to be on.


        //PERFORMANCE OPTIONS
        private static bool perfOverride = false;  //if set, this prevents debug output, and prevents
        //verification calls to the database.  This prepares
        //MatchSession to be used in a stress
        //environment.  Note that much of the bookkeeping
        //is disabled if this flag is true, and outside
        //verify calls will fail.  TODO:Bring the verify
        //calls out of MatchUtilities and in here!

        private static bool debugOutput = false; //if set, this will print some debug output to the
                                                 //STF Console while sessions are created, split,
                                                 //updated, etc.

        private static bool enableLogging = true;  //determines whether all created sessions should
        //have all their calls logged.
        private ArrayList sessionLog;  //a log of all calls related to this session.

        public class LogEntry {
            public string name;
            public WireData sentXRL;  //this is optional data.  Be careful to clone re-used XRLs.
            //store the responses too?
            public LogEntry(string name, WireData sentXRL) {
                this.name = DateTime.Now + name;
                this.sentXRL = sentXRL;
            }
        }

        //////////////////////////////
        ////////  ACCESSORS  /////////
        //////////////////////////////
        public SessionID GetSessionID() {
            return new SessionID(GetBaseSession().SessionID); //on this line, SessionID is a
                                                              //variable name.  Above, it's a return
                                                              //type.  Sorry.
        }

        public long GetSessionMode() {
            const int INVALID_VALUE = -1;
            XRLXeAttribParam gameMode = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                             new XRLXeIntValue(INVALID_VALUE));
            GetAttrib(gameMode);
            long returnedVal = ((XRLXeIntValue) (gameMode.aValue)).intValue;
            if (returnedVal != INVALID_VALUE) {
                return returnedVal;
            } else throw new ArgumentException("Error!  Retrieving the game mode attribute failed!");
        }
        
        public uint TitleID {
            get {
                return titleID;
            }
            set { 
                if (created) {
                    Global.RO.Warn("Cannot change titleID after this session has been created!");
                } else {
                    this.titleID = value;
                    createUpdateReq.baseCreateUpdate.baseSession.dwTitleID = value;
                }
            }
        }

        //shortcut for outside to set what platform(Xenon, XBox1, etc.) created this session
        public void SetClientType(CSGInfo.ClientType creatorType) {
            createUpdateReq.SetClientType(creatorType);  //set the info in the request.
            createUpdateReq.Slot.SetClientType(creatorType);  //set the info in FakeSG.
        }
        //shortcut to retriving the HostAddress
        public XRLxnaddr HostAddress { 
            get {
                return GetBaseSession().HostAddress;
            }
        }

        //internal shortcut for getting at the baseSession.
        private XRLBaseSession GetBaseSession() {
            return createUpdateReq.baseCreateUpdate.baseSession;
        }

        //if we delete the session in the DB by other means, let the MatchSession know so it doesn't
        //try to delete it.
        public void SkipCleanup() {
            skipCleanup = true;
            //tell the match session mgr?
        }

        public void AllowUpdateAtAllTimes() {
            allowUpdateAtAllTimes = true;
        }

        //if there's an Xerr returned in the CreateUpdate request, return it here.
        public string GetErrorMsg() {
            return MatchUtil.ErrMsgFromXRLPayload("Error from create request:", createUpdateReq);
        }

        public string GetServer() { 
            if (perfOverride) Global.RO.Warn("Warning!  Server variable is not accurate, as perfOverride flag prevents updates!");
            return initialServer;
        }
        public string GetSandwichServer() { 
            if (perfOverride) Global.RO.Warn("Warning!  Sandwich server variable is not accurate, as perfOverride flag prevents updates!");
            return sandwichServer;
        }

        public InterfaceBucket GetBucket() { return initialBucket; }
        public InterfaceBucket GetSandwichBucket() { return sandwichBucket; }



        /////////////////////////////////
        ////////  CONSTRUCTORS  /////////
        /////////////////////////////////

        //we default to non-delayed creation
        public MatchSession() : this(true) {

        }

        //Standard constructor.
        public MatchSession(bool createNow) {
            created = false;
            createUpdateReq = new XRL2CreateUpdateSession();
            if (createNow) {
                Create();
            }
            sessionLog = new ArrayList();            
            if (enableLogging) sessionLog.Add(new LogEntry("Create:Normal", null));
        }
        
        //Create using a search result(such as a SplitSession response).  This session has already 
        //been created for us, so we just need to set up an XRL2CreateUpdateSession to hold all
        //the appropriate info.  Note that this does *not* actually create the session.  
        //However, we need to make sure the session acts like it was created.
        public MatchSession(uint titleID, XRL2SingleSearchResult existingSession)
        {
            //remove the many nulls that pad out the attrib list.
            XRLXeAttribParam [] filteredAttribs = 
                MatchUtil.FilterOutAttribs(existingSession.Attribs, Constants.X_ATTRIBUTE_DATATYPE_NULL);

            //constructor handles the attribs
            createUpdateReq = new XRL2CreateUpdateSession(filteredAttribs);

            //fill in everything else
            this.titleID = titleID;
            GetBaseSession().dwTitleID = titleID;
            GetBaseSession().SessionID = existingSession.SessionID;  //shallow copy ok, dropping search result
//            SessionInfo.KeyExchangeKey = existingSession.KeyExchangeKey;  //dropping exchange key.
            GetBaseSession().HostAddress = existingSession.HostAddress;
            GetBaseSession().dwPublicOpen = existingSession.dwPublicOpen;
            GetBaseSession().dwPrivateOpen = existingSession.dwPrivateOpen;
            GetBaseSession().dwPublicFilled = existingSession.dwPublicFilled;
            GetBaseSession().dwPrivateFilled = existingSession.dwPrivateFilled;

            DoPostCreatePaperwork();
            if (enableLogging) sessionLog.Add(new LogEntry("Create:From Existing Session", existingSession));
        }

        //Create a MatchSession if someone's gone to the trouble of making the entire
        //createUpdateRequest for us.
        public MatchSession(uint titleID, XRL2CreateUpdateSession createUpdateReq, XRLSessionInfo sessionInfo) {
            this.createUpdateReq = createUpdateReq;
            Array.Copy(sessionInfo.SessionID, 
                       createUpdateReq.baseCreateUpdate.baseSession.SessionID,8);
            this.TitleID = titleID;
            DoPostCreatePaperwork();
            if (enableLogging) sessionLog.Add(new LogEntry("Create:From Existing CreateUpdate request.", null));
        }

        //let's make sure we clean up after ourselves.  This only is called when
        //garbage collection occurs, so don't rely on this for test cleanup.  It
        //will guarantee that when STF ends the sessions will be cleared, however.

        //EDIT:This has always proven to be more trouble than it's worth.  Forget the cleanup.
        ~MatchSession() {
            if (created && !skipCleanup) {
//                Delete();  
            }
        }

        //Tell the create to be run with the cross platform multiplayer privilege in the SGInfo.  This can only be done
        //*before* the create is called.
        public void SetCrossPlatformPrivilege() {
            if (created) {
                Global.RO.Warn("Warning!  Attempt to set cross platform privilege after the session is created!" +
                               "  This can only be done before creation.  Ignoring.");
                return;
            }
            createUpdateReq.ManualPopulateSlot();
            createUpdateReq.Slot.SetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
            requestsNeedMultiplayerPrivilege = true;
        }

        //CREATION METHODS
        //when a session has been created, certain changes need to be done...
        //1)Save the initial game mode for breadcrumb purposes.
        //2)Set the sessionID in the saved XRL request so that subsequent executes will act as updates.
        public bool Create() {
            //call this *only* when creating
            if (created) {
                Global.RO.Warn("Warning!  Attempt to create an already-created session!");
                return false;
            }
            if (!ExecuteCreateXRL()) {
                Global.RO.Error("Create session failed with error code:" + ErrMsgFromXRLPayload("", createUpdateReq));
                Global.RO.Error("No exception thrown--check event viewer for more details");
                return false;
            }
            DoPostCreatePaperwork();
            return true;
        }

        //a shortcut for creating sessions with a certain game type.  Added for backwards
        //compatibility with existing commands and code.
        public bool Create(SessionType sessionType) {
            if (sessionType == SessionType.Ranked) {
                this.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                       new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)),
                                  false);
            } else if (sessionType == SessionType.Social) {
                this.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                       new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD)),
                                  false);
            } else {Global.RO.Warn("Attempt to set create session with invalid game type!");}
            return Create();
        }

        private bool ExecuteCreateXRL() {
            XRLSessionInfo sessionInfo;
            bool success = createUpdateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                                                   out sessionInfo);
            //save the sesionID in the baseCreateUpdate.  Future executes will now perform updates.
            if (success) {
                Array.Copy(sessionInfo.SessionID, 
                           createUpdateReq.baseCreateUpdate.baseSession.SessionID,8);
                PrintDebugOutput("Creating session with ID " + this.GetSessionID());
            }
            return success;
        }

        //do the note-keeping that modifies internal variables so we know this is a created session.
        private void DoPostCreatePaperwork() {
            created = true;
            MatchSessionMgr.RegisterSession(titleID, GetSessionID());
            RecordInitialServerLocation();
            if (enableLogging) sessionLog = new ArrayList();
        }

        //This simplified method is called during creations(Create, Split), to record where the
        //session is created.
        private void RecordInitialServerLocation() {
            if (perfOverride) return;   //if perf override, we do nothing here.  Verifies will fail.

            //if migrating record vc_next_server.  Otherwise, vc_server.  Set sandwich server to
            //null--nobody is created with a sandwich.
            this.initialBucket = MatchUtil.FindInterfaceBucketForSession(this, true);
            this.sandwichBucket = initialBucket;

            //if migration date is in past...take nextServer.  Note that most of the time,
            //nextServer will be the same as Server
            initialServer = MatchUtil.SelectServerFromBucket(initialBucket);
            sandwichServer = initialServer;  //we always start with one session.
            PrintDebugOutput("Recording location of sessionID " + GetSessionID() + " as on server " + initialServer);
        }

        //This method handles all Updates, and will store the location of the session.  It will also
        //handle locate and store the location of both pieces of breadcrumbed sessions.
        public void UpdateServerLocation() {
            if (perfOverride) return;   //if perf override, we do nothing here.  Verifies will fail.

            //find the buckets.
            this.initialBucket = MatchUtil.FindInterfaceBucketForSession(this, true);
            this.sandwichBucket = MatchUtil.FindInterfaceBucketForSession(this, false);

            //Convert these to servers
            string newServer = MatchUtil.SelectServerFromBucket(initialBucket);
            string newSandwichServer = MatchUtil.SelectServerFromBucket(sandwichBucket);
            if (initialServer != newServer) {
                PrintDebugOutput("Moving session " + this.GetSessionID() + " from " + initialServer + " to " + newServer);//DEBUG
            }

            //mention the sandwich if the sandwich is different
            if ((sandwichServer != newSandwichServer) && (newSandwichServer != newServer)) { 
                PrintDebugOutput("Moving sandwich of session " + this.GetSessionID() + " from " + sandwichServer + " to " + newSandwichServer);//DEBUG
            }

            if (newServer.Equals("")) {
                throw new Exception("Invalid server found when attempting to update server location!");
            }
            initialServer = newServer;

            if (newSandwichServer.Equals("")) {
                throw new Exception("Invalid server found when attempting to update sandwich server location!");                
            }
            sandwichServer = newSandwichServer;

            if (enableLogging) sessionLog.Add(new LogEntry("[Internal]UpdateServerLocation:buckets old vs. new:\n" +
                                                           initialBucket + ", " + sandwichBucket + "\n" +
                                                           "initialServer old vs. new:" + "\n" + 
                                                           initialServer + ", " + newServer + "\n" +
                                                           "  currentSserver old vs. new:" + "\n" +
                                                           sandwichServer + ", " + newSandwichServer + "\n", null));

        }
        
        //UPDATE METHODS
        public bool Update() {
            if (!allowUpdateAtAllTimes) {
                if (!created) {
                    Global.RO.Warn("Warning!  Attempt to update a session that is not created!");
                    return false;
                }
            }
            if (!ExecuteUpdateXRL()) {
                Global.RO.Error("Update Session failed!  HR result below--Check event viewer for more details.");
                Global.RO.Error(GetErrorMsg());
                return false;
            }
            UpdateServerLocation();
            if (enableLogging) sessionLog.Add(new LogEntry("Update:Updating server session to match data.", null));
            return true;
        }

        //Run the same XRL, but expecting no response.  This is required for updates.
        private bool ExecuteUpdateXRL() {
            return createUpdateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
        }
        

        //default to adding attribs as they are made.  Note that this method requires the attrib to *not*
        //be present.
        public bool AddAttrib(XRLXeAttribParam newParam) {
            return AddAttrib(newParam, true);
        }

        public bool AddAttrib(XRLXeAttribParam newParam, bool addNow) {
            createUpdateReq.AddAttrib(newParam);
            if (addNow) {
                if (!Update()) {
                    Global.RO.Error("Error adding an attribute to this session!  Check event viewer for more details.");
                    return false;
                }
            }
            if (enableLogging) sessionLog.Add(new LogEntry("Update:Adding attribute " + newParam.ToString(), null));
            return true;
        }

        public bool AddAttribs(XRLXeAttribParam[] newParams, bool addNow) {
            createUpdateReq.AddAttribs(newParams);
            if (addNow) {
                if (!Update()) {
                    Global.RO.Error("Error adding attributes to this session!  Check event viewer for more details.");
                    return false;
                }
            }
            string paramText = "";
            for (int i=0; i<newParams.Length; i++) {
                paramText = paramText + newParams[i].ToString() + "|";
            }
            if (enableLogging) sessionLog.Add(new LogEntry("Update:Adding attributes:" + paramText , null));
            return true;            
        }

        //default to updating attribs as they are made.  Note that this method requires the attrib to be present.
        public bool UpdateAttrib(XRLXeAttribParam newParam) {
            return UpdateAttrib(newParam, true);
        }

        public bool UpdateAttrib(XRLXeAttribParam newParam, bool updateNow) {
            createUpdateReq.UpdateAttrib(newParam);
            if (updateNow) {
                if (!Update()) {
                    Global.RO.Error("Error updating an attribute to this session!  Check event viewer for more details.");
                    return false;
                }
            }
            if (enableLogging) sessionLog.Add(new LogEntry("Update:Updating attribute " + newParam.ToString(), null));
            return true;
        }

        //Fill the passed in attribute's value with the corresponding value of the attribute for this session.
        //Leaves the value unchanged if there is no attribute here.
        //Eessentially forwards the call to the contained class.
        public void GetAttrib(XRLXeAttribParam attribToFill) {
            createUpdateReq.RetrieveCurrentValue(attribToFill);
        }

        
        //Create a new session with identical characteristics of the old one, but a new host.
        //Default host to a 360.
        public MatchSession Split(bool changeHost)
        {
            return Split(changeHost, CSGInfo.ClientType.Xenon);
        }

        //Create a new session with identical characteristics of the old one, but a new host.
        //Returns a session that, by the split call, is already-created.
        public MatchSession Split(bool changeHost, CSGInfo.ClientType clientType)
        {
            XRLSplitSession splitReq = CreateSplitSessionRequest(changeHost, clientType);
            if (requestsNeedMultiplayerPrivilege) {
                splitReq.Slot.SetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
            }
            MatchSession newSession = ExecuteSplitAndReturnNewSession(splitReq);
            return newSession;
        }

        //Create a split request to be executed on this session.
        private XRLSplitSession CreateSplitSessionRequest(bool changeHost, CSGInfo.ClientType clientType) {
            XRLxnaddr newHostAddr = GetBaseSession().HostAddress;
            if (changeHost)
            {
                newHostAddr = MatchUtil.CreateRandomXNADDR();
                //TODO: Update attributes GAMER_PUID and HOST_NAME
            }
            //note the attribs(and potentially address) are shallow copied.  This doesn't matter,
            //because we eventually forget the request, and use the response to generate the new
            //MatchSession.  The response carries all the attributes of the existing session.
            XRLSplitSession splitReq = new XRLSplitSession((byte []) GetSessionID(), titleID, newHostAddr,
                                                           createUpdateReq.baseCreateUpdate.Attribs);
            splitReq.Slot.SetClientType(clientType);
            return splitReq;
        }

        //Execute a split request and return the new MatchSession.
        private MatchSession ExecuteSplitAndReturnNewSession(XRLSplitSession splitReq) {
            XRL2SingleSearchResult splitResp;
            PrintDebugOutput("Attempting to split off of session ID " + GetSessionID().ToString() + " for title ID " +
                             splitReq.dwTitleID.ToString("X"));
            if (!splitReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out splitResp))
            {
                throw new Exception(ErrMsgFromXRLPayload("SplitSession failed", splitReq));
            }
            MatchSession newSession = new MatchSession(titleID, splitResp);
            PrintDebugOutput("Split has created a new session with ID " + newSession.GetSessionID().ToString() + " for title ID " + 
                             newSession.titleID.ToString("X"));
            if (enableLogging) sessionLog.Add(new LogEntry("Split:oldSessID " + GetSessionID().ToString() + 
                                                           ", newSessID:" + newSession.GetSessionID().ToString(), splitReq));
            return newSession;
        }

        public void Join(int publicJoins, int privateJoins) {
            uint currentPublicOpen = (uint) GetBaseSession().dwPublicOpen;
            uint newPublicOpen = (uint) (currentPublicOpen - publicJoins);
            if (newPublicOpen < 0) {
                Global.RO.Warn("Warning!  Attempt to join more players than this session has available(public slots)!");
            }

            uint currentPrivateOpen = (uint) GetBaseSession().dwPrivateOpen;
            uint newPrivateOpen = (uint) (currentPrivateOpen - privateJoins);
            if (newPrivateOpen < 0) {
                Global.RO.Warn("Warning!  Attempt to join more players than this session has abailable(private slots)!");
            }

            //warn, but in case a negative test case wants this, allow.
            GetBaseSession().dwPublicOpen = newPublicOpen;
            GetBaseSession().dwPrivateOpen = newPrivateOpen;
            GetBaseSession().dwPublicFilled = (uint) (GetBaseSession().dwPublicFilled + publicJoins);
            GetBaseSession().dwPrivateFilled = (uint) (GetBaseSession().dwPrivateFilled + privateJoins);
            if (enableLogging) sessionLog.Add(new LogEntry("Update:Joining public:" + publicJoins + " private:" + privateJoins, null));
            Update();
        }
        
        //These methods will open/close the session forcefully.  Note that this doesn't take into
        //account the number of joins, so use only if you don't care about joining users.
        public bool IsClosed() {
            return (GetBaseSession().dwPublicOpen == 0);
        }

        //close the session by setting the public open slots to 0.
        public void ForceClose(bool closeNow) {
            GetBaseSession().dwPublicOpen = 0;
            if (closeNow) {
                Update();
            }
        }

        //open the session by setting the public open slots to 8.
        public void ForceOpen(bool openNow) {
            GetBaseSession().dwPublicOpen = 8;
            if (openNow) {
                Update();
            }
        }


        //create a search designed to target this one session.  Basically, generate a search and
        //throw all of this session's attributes into it.  This *only* works for Xenon sessions, as
        //it forces a typecast on the base attribs.
        public XRL2SearchSession CreateSearchSession(uint spIndex) {
            //clone the attributes, and place them in the child class.
            XRLXeAttribParam [] searchAttribs = GetAttribs();
            //this copies only pointers--we rely on XRL2SearchSession to make a deep copy of these attributes.
            XRL2SearchSession ans = new XRL2SearchSession(searchAttribs, spIndex);
            ans.baseSearchSession.dwTitleID = TitleID;
            if (requestsNeedMultiplayerPrivilege) {
                ans.Slot.SetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
            }
            return ans;
        }

        //return a list of pointers to the attribs.  DO NOT MODIFY THE DATA.  These are references to
        //the data, and changing it will bring the session out of sync with the database.
        public XRLXeAttribParam [] GetAttribs() {
            XRLXeAttribParam [] attribs= new XRLXeAttribParam[createUpdateReq.baseCreateUpdate.Attribs.Length];
            for(int i=0; i<createUpdateReq.baseCreateUpdate.Attribs.Length; i++) {
                attribs[i] = (XRLXeAttribParam) createUpdateReq.baseCreateUpdate.Attribs[i];
            }
            return attribs;
        }

        //get the numeric value of the attrib in the attribID.  Returns -1 if not found, throws
        //exception if the attrib is not numeric.
        public double GetNumericValueOfAttrib(uint attribID) {
            XRLXeAttribParam [] attribs = this.GetAttribs();
            for (int i=0; i< attribs.Length; i++) {
                if (attribs[i].attribParamID == attribID) {
                    return attribs[i].aValue.GetNumericValue();
                }
            }
            return -1;
        }
        
        //call down to the wrapped class.  Verify what's in the request vs. what came back from the
        //search.Note that the search must be the standard SearchByID query, because the existing 
        //verify code is very stringent about the size of the response.
        public bool Verify(XRL2SearchResults searchResults) {
            if (!created) {
                Global.RO.Warn("Warning!  Attempt to verify session that has not been created!");
                return false;
            }
            return createUpdateReq.Verify(searchResults, this.IsRanked());
        }
        
        //timeout is how many milliseconds to wait for the server to succesfully finish the operation
        public bool Delete(int timeout) {
            PrintDebugOutput("Deleting session " + GetSessionID());
            if (!created) {
                Global.RO.Warn("Attempt to delete a session that was not created yet!");
                return false;
            } else {
                bool deleteSuccess = MatchUtil.DeleteSession((byte[]) GetSessionID(), titleID, timeout);
                if (deleteSuccess) {
                    created = false;
                }
                if (enableLogging) sessionLog.Add(new LogEntry("Delete: successful?:" + deleteSuccess, null));
                return deleteSuccess;
            }
        }

        public bool Delete()
        {
            return Delete(FDTransaction.sReceiveTimeOut);
        }

        //the signal we get if someone turns off their xbox unexpectedly
        public void DeadXbox() {
            XRLDeadXBox req = new XRLDeadXBox(titleID);
            req.sgaddr.ReadBytes(createUpdateReq.baseCreateUpdate.baseSession.HostAddress.abOnline);
            if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) {
                throw new Exception(ErrMsgFromXRLPayload("DeadXBox failed", req));
            }
            PrintDebugOutput("DeadXboxed session ID " + GetSessionID().ToString() + " for title ID " + titleID.ToString("X"));

            if (enableLogging) sessionLog.Add(new LogEntry("DeadXbox", null));
            this.created = false;  //don't forget, we shouldn't exist anymore.
        }

        //kill every session that hooks up to this SG.  This could be a lot.
        public bool DeadSG() {
            XRLDeadXBox req = new XRLDeadXBox(titleID);
            req.sgaddr.ReadBytes(createUpdateReq.baseCreateUpdate.baseSession.HostAddress.abOnline);
            req.sgaddr.dwSpiSg = 0;  //set these values to 0
            req.sgaddr.qwXboxID = 0; //so that the FD knows it's a DeadSG call.
            if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) {
                throw new Exception(ErrMsgFromXRLPayload("DeadSG failed", req));
            }
            PrintDebugOutput("DeadSGed session ID " + GetSessionID().ToString() + " for title ID " + titleID.ToString("X"));

            if (enableLogging) sessionLog.Add(new LogEntry("DeadSG", null));
            this.created = false;  //don't forget, we shouldn't exist anymore.
            return true;
        }


        /////////////////////////////////
        //////////   UTILITY   //////////
        /////////////////////////////////

        //helpful messages.  Move this to MatchUtil?
        private static string ErrMsgFromXRLPayload(string prepend, XRLPayload xrlPayload) {
            return (prepend + " [HTTP Status: " + xrlPayload.xAct.httpStatus +
                    ", XErr: " + Global.XErrToString(xrlPayload.XErr) + "]");
        }

        //simple predicate.  True if ranked, false otherwise.
        public bool IsRanked() {
            const long INVALID_VALUE = -1;
            XRLXeAttribParam rankedAttrib = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                                 new XRLXeIntValue(INVALID_VALUE));
            GetAttrib(rankedAttrib); //fill rankedAttrib
                                     //with the value.
            if (((XRLXeIntValue) rankedAttrib.aValue).intValue == INVALID_VALUE) {
                throw new ArgumentException("Error!  IsRanked retrieved a bad value, or failed to retrieve one at all!");
            }
            if (((XRLXeIntValue) rankedAttrib.aValue).intValue == Constants.X_ATTRIBUTE_GAME_TYPE_RANKED) {
                return true;
            } else return false;
        }

        //true if the session's mode moves it to a different server.
        public bool IsBreadcrumbed() {
            return initialBucket.Bucket != sandwichBucket.Bucket;
        }

        public string GetSessionInfo() {
            return "Game Type(ranked or standard):" + MatchUtil.GetBits(GetSessionID(), 8, 9) + "\n" +
                "Game Mode(CTF, etc.)):" + MatchUtil.GetBits(GetSessionID(), 10, 15) +  "\n" +
                "Server Type(xbl, system link):" + MatchUtil.GetBits(GetSessionID(), 4, 7) +  "\n" +
                "Round RobinID:" + MatchUtil.GetBits(GetSessionID(), 0, 3);
        }

        //return info on this session by enumerating all of its attributes.
        public string EnumerateAttribs() {
            string ans = "";
            foreach (XRLXeAttribParam attrib in createUpdateReq.baseCreateUpdate.Attribs) {
                ans += attrib.attribParamID.ToString("X") + ":" + attrib.aValue.ToString() + " \n ";
            }
            return ans;
        }

        //potentially create a log class to wrap the arraylist up?
        public string PrintLog() {
            string ans = "";
            foreach (LogEntry entry in sessionLog) {
                ans = ans + entry.name + "\n";
            }
            return ans;
        }

        private void PrintDebugOutput(string str) {
            if (debugOutput) Global.RO.Debug(str);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\matchsessionset.cs ===
using System.Collections;
using System.Collections.Generic;

//A simple class to hold a set of MatchSessions.  Uses for this might include ensuring batches of
//sessions are created, deleted, etc.  Sessions are keyed in the hashtable by the ToStringed version
//of SessionIDs.

namespace ServerTestFramework.LiveService.Matchmaking {

    public class MatchSessionSet {
        private Hashtable sessions;

        public MatchSessionSet() {
            sessions = new Hashtable();
        }
        
        //returns a list of all SessionIDs in the hashtable.
        public ArrayList GetSessionIDs() {
            ArrayList allIds = new ArrayList();
            foreach (MatchSession session in sessions.Values) {
                allIds.Add(session.GetSessionID());
            }
            return allIds;
        }
        public void AddSession(MatchSession session) {
            sessions.Add(session.GetSessionID().ToString(), session);
        }
        
        public bool DeleteSession(MatchSession session) {
            return DeleteSession(session.GetSessionID());
        }

        public bool DeleteSession(SessionID id) {
            if (!sessions.ContainsKey(id.ToString())) {
                return false;
            }
            sessions.Remove(id.ToString());
            return true;
        }
        public bool IsEmpty() {
            return (sessions.Count == 0);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRL2AttribParamWeighted.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// This class is basically a copy of XRL2AttribParam.  It could inherit, except that all the
    /// logic is really in constructors, and the write/readstream can't be reused either.
    /// </summary>
    public sealed class XRLXeAttribParamWeighted : XrlAttributeBase, IDeepCloneable
    {
        public float weight;
        public uint  attribParamID;
        public XRLXeAttribParamValue	aValue;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(weight);
            binaryWriter.Write(attribParamID);
            aValue.WriteStream(binaryWriter);
        }

        public override uint CalculateSize()
        {
            const uint ATTRIBUTE_HEADER_SIZE = 8; //4 bytes for the attribParamID, 4 bytes for the weight.
            switch(attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK)
            {
                case Constants.X_ATTRIBUTE_DATATYPE_INTEGER:
                    return (uint)ATTRIBUTE_HEADER_SIZE + 8;
                case Constants.X_ATTRIBUTE_DATATYPE_STRING:
                    return (uint)ATTRIBUTE_HEADER_SIZE + 2 + ((XRLXeStringValue)aValue).strValueLen;
                case Constants.X_ATTRIBUTE_DATATYPE_BLOB:
                    return (uint)ATTRIBUTE_HEADER_SIZE + 2 + ((XRLXeBlobValue)aValue).blobLen;
                case Constants.X_ATTRIBUTE_DATATYPE_NULL:
                    return (uint)ATTRIBUTE_HEADER_SIZE;
                default:
                    throw new Exception("Unknown datatype in attribute ID: 0x" + attribParamID.ToString("x"));
            }
        }

        // default constructor needs by readValue in wiredata.cs
        public XRLXeAttribParamWeighted()
        {
            attribParamID = 0;
            weight = 0;
            aValue = null;
        }

        public XRLXeAttribParamWeighted(uint ID, float weightValue, XRLXeAttribParamValue paramValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = (XRLXeAttribParamValue)paramValue.DeepClone();
        }

        // Overloaded constructors for easy wiredata param construction
        public XRLXeAttribParamWeighted(uint ID, float weightValue, int intValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, uint intValue)
        {
            attribParamID = ID;
             weight = weightValue;
           aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, long intValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, ulong intValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, bool intValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeIntValue((long)(intValue ? 1 : 0));
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, float floatValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeFloatValue(floatValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, double doubleValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeDoubleValue(doubleValue);
        }
        public XRLXeAttribParamWeighted(uint ID, float weightValue, string strValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeStringValue(strValue);
        }

        public XRLXeAttribParamWeighted(uint ID, float weightValue, byte[] binValue)
        {
            attribParamID = ID;
            weight = weightValue;
            aValue = new XRLXeBlobValue(binValue);
        }

        public object DeepClone()
        {
            // Start with a shallow clone to avoid WireData::.ctor
            XRLXeAttribParamWeighted clone = (XRLXeAttribParamWeighted)this.MemberwiseClone();
            //clone the reference object.
            clone.aValue = (XRLXeAttribParamValue)this.aValue.DeepClone();  
            return(clone);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            weight = binaryReader.ReadSingle();
            attribParamID = binaryReader.ReadUInt32();
            if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_INTEGER) 
            {
                if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT32 ||
                   ((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT64))
                    aValue = new XRLXeIntValue();
                else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT32)
                    aValue = new XRLXeFloatValue();
                else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT64)
                    aValue = new XRLXeDoubleValue();
                else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_DATETIME)
                    aValue = new XRLXeDateTimeValue();
                else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_CONTEXT)
                    aValue = new XRLXeIntValue();
            }
            else if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_STRING)
            {
                aValue = new XRLXeStringValue();
            }
            else if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_NULL)
            {
                aValue = new XRLXeNullValue();
            }
            aValue.ReadStream(binaryReader);
            return this;
        }
            
        public override string ToString() {
            return "attrib:0x" + attribParamID.ToString("X") + ", weight:" + weight + ", value:" + aValue.ToString();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRL2DeleteSession.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// counterPart for XMATCH_DELETE_SESSION
    /// </summary>
    public class XRL2DeleteSession : XRLPayload
    {
        public	uint	dwMessageLength;
        [XRLPayloadFld(ArraySize=8)]
        public	byte[]	SessionID;
        public	uint	dwTitleID;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwMessageLength);
            if (SessionID != null)
            {
                binaryWriter.Write(SessionID);
            }
            binaryWriter.Write(dwTitleID);
        }

        protected override string GetServiceName()
        {
            return "/xmatch/xmatchhostDelete2.ashx";
        }

        /// <summary>
        /// delete session with specified sessionID
        /// </summary>
        /// <param name="sessID"></param>
        public XRL2DeleteSession(byte[] sessID, uint TitleID)
        {
            this.dwMessageLength = Constants.SIZEDELETESESSION;
            this.dwTitleID = TitleID;
            this.SessionID = (byte[])sessID.Clone();
            this.ServiceId = XOService.Matchmaking;
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
        }

        /// <summary>
        /// send deleteSession request to matchmaking front door
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <returns></returns>
        public void BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, dwTitleID, null);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );
            
            BeginInternalExecute(sServer, reqStream, callback);
        }
        
        public bool EndExecute(IAsyncResult ar) {
            bool bRet = EndInternalExecute(ar);
            bool uRet = false;

            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRL2AttribParam.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.LiveService.Matchmaking
{
	/// <summary>
	/// This class is used to represent both attributes in schema AND
	/// search parameters in the search requests.
	/// In Xenon: 
	///	Search Parameters:	int32/int64/float32/float64/dateTime are allowed, while string and blobs are not.
	///	Session Attributes: string/int32/int64/float32/float64/dateTime/null are allowed, blobs are not.
	///	Search Results: same as Session Attributes.
	/// </summary>
    public sealed class XRLXeAttribParam : XrlAttributeBase, IDeepCloneable
	{
		//public XRLXeAttribParamID		aID;
		public uint						attribParamID;
		public XRLXeAttribParamValue	aValue;

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(attribParamID);
			aValue.WriteStream(binaryWriter);
		}

        public override uint CalculateSize()
        {
            switch(attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK)
            {
                case Constants.X_ATTRIBUTE_DATATYPE_INTEGER:
                    return (uint)4 + 8;
                case Constants.X_ATTRIBUTE_DATATYPE_STRING:
                    return (uint)4 + 2 + ((XRLXeStringValue)aValue).strValueLen;
                case Constants.X_ATTRIBUTE_DATATYPE_BLOB:
                    return (uint)4 + 2 + ((XRLXeBlobValue)aValue).blobLen;
                case Constants.X_ATTRIBUTE_DATATYPE_NULL:
                    return (uint)4;
                default:
                    throw new Exception("Unknown datatype in attribute ID: 0x" + attribParamID.ToString("x"));
            }
        }

		// default constructor needs by readValue in wiredata.cs
		public XRLXeAttribParam()
		{
			//aID = new XRLXeAttribParamID(0);
			attribParamID = 0;
			aValue = null;
		}

		public XRLXeAttribParam(uint ID, XRLXeAttribParamValue paramValue)
		{
			attribParamID = ID;
            aValue = (XRLXeAttribParamValue)paramValue.DeepClone();
		}

        // Overloaded constructors for easy wiredata param construction
        public XRLXeAttribParam(uint ID, int intValue)
        {
            attribParamID = ID;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParam(uint ID, uint intValue)
        {
            attribParamID = ID;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParam(uint ID, long intValue)
        {
            attribParamID = ID;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParam(uint ID, ulong intValue)
        {
            attribParamID = ID;
            aValue = new XRLXeIntValue((long)intValue);
        }
        public XRLXeAttribParam(uint ID, bool intValue)
        {
            attribParamID = ID;
            aValue = new XRLXeIntValue((long)(intValue ? 1 : 0));
        }
        public XRLXeAttribParam(uint ID, float floatValue)
        {
            attribParamID = ID;
            aValue = new XRLXeFloatValue(floatValue);
        }
        public XRLXeAttribParam(uint ID, double doubleValue)
        {
            attribParamID = ID;
            aValue = new XRLXeDoubleValue(doubleValue);
        }
        public XRLXeAttribParam(uint ID, string strValue)
        {
            attribParamID = ID;
            aValue = new XRLXeStringValue(strValue);
        }

        public XRLXeAttribParam(uint ID, byte[] binValue)
        {
            attribParamID = ID;
            aValue = new XRLXeBlobValue(binValue);
        }

		public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLXeAttribParam clone = (XRLXeAttribParam)this.MemberwiseClone();
			//clone.aID = (XRLXeAttribParamID)this.aID.DeepClone();
			clone.aValue = (XRLXeAttribParamValue)this.aValue.DeepClone();
			return(clone);
		}

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			//aID.ReadStream(binaryReader);
			attribParamID = binaryReader.ReadUInt32();
			if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_INTEGER) 
			{
				if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT32 ||
					((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT64))
					aValue = new XRLXeIntValue();
				else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT32)
					aValue = new XRLXeFloatValue();
				else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT64)
					aValue = new XRLXeDoubleValue();
				else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_DATETIME)
					aValue = new XRLXeDateTimeValue();
				else if((attribParamID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_CONTEXT)
					aValue = new XRLXeIntValue();
			}
			else if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_STRING)
			{
				aValue = new XRLXeStringValue();
			}
			else if ((attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK) == Constants.X_ATTRIBUTE_DATATYPE_NULL)
			{
				aValue = new XRLXeNullValue();
			}
			aValue.ReadStream(binaryReader);
			return this;
		}
            
            public override string ToString() {
                return "attrib:0x" + attribParamID.ToString("X") + ", value:" + aValue.ToString();
            }

            //if this is a numeric type, set the value to the parameter.  Throws exception
            //otherwise.  This is a passthrough to the paramValue's implementation.
            public void SetNumericValue(double value) {
                this.aValue.SetNumericValue(value);
            }

	}

	public abstract class XRLXeAttribParamValue : WireData, IDeepCloneable
	{
            public abstract object DeepClone();
            //if this is a numeric type, set the value to the parameter.  If this is not a numeric
            //type, throw a ClassCastException.  Int types will floor the argument.
            public void SetNumericValue(double value) {
                if (this is XRLXeIntValue) {
                    ((XRLXeIntValue) this).intValue = (long) value;
                } else if (this is XRLXeFloatValue) {
                    ((XRLXeFloatValue) this).fValue = (float) value;
                } else if (this is XRLXeDoubleValue) {
                    ((XRLXeDoubleValue) this).dValue = (double) value;
                } else {
                    throw new InvalidCastException("Exception in attempting to setNumericValue--This XRLXeAttribParamValue is not numeric!");
                }
            }

            //return the numeric value for this XRLXeAttribParamValue.
            public double GetNumericValue() {
                if (this is XRLXeIntValue) {
                    return ((XRLXeIntValue) this).intValue;
                } else if (this is XRLXeFloatValue) {
                    return ((XRLXeFloatValue) this).fValue;
                } else if (this is XRLXeDoubleValue) {
                    return ((XRLXeDoubleValue) this).dValue;
                } else {
                    throw new InvalidCastException("Exception in attempting to getNumericValue--This XRLXeAttribParamValue is not numeric!");
                }
            }


            //overloaded operator so we can add params.  Only add params of the same
            //type, and only double + double, float + float, and int + int.  Mismatched types or date/string
            //subtractions will cause run+time exceptions!
            public static XRLXeAttribParamValue operator +(XRLXeAttribParamValue param1, XRLXeAttribParamValue param2) {
                if ((param1 is XRLXeIntValue) && (param2 is XRLXeIntValue)) {
                    return new XRLXeIntValue(((XRLXeIntValue) param1).intValue + ((XRLXeIntValue)param2).intValue);
                } else if ((param1 is XRLXeFloatValue) && (param2 is XRLXeFloatValue)) {
                    return new XRLXeFloatValue(((XRLXeFloatValue) param1).fValue + ((XRLXeFloatValue)param2).fValue);
                } else if ((param1 is XRLXeDoubleValue) && (param2 is XRLXeDoubleValue)) {
                    return new XRLXeDoubleValue(((XRLXeDoubleValue) param1).dValue + ((XRLXeDoubleValue)param2).dValue);
                } else {
                    throw new InvalidCastException("Exception in attempting to add--Either mismatched or non-numeric XRLXeAttribParamValue types!");
                }
            }

            //overloaded operator so we can subtract params.  Only subtract params of the same
            //type, and only double - double, float - float, and int - int.  Mismatched types or date/string
            //subtractions will cause run-time exceptions!
            public static XRLXeAttribParamValue operator -(XRLXeAttribParamValue param1, XRLXeAttribParamValue param2) {
                if ((param1 is XRLXeIntValue) && (param2 is XRLXeIntValue)) {
                    return new XRLXeIntValue(((XRLXeIntValue) param1).intValue - ((XRLXeIntValue)param2).intValue);
                } else if ((param1 is XRLXeFloatValue) && (param2 is XRLXeFloatValue)) {
                    return new XRLXeFloatValue(((XRLXeFloatValue) param1).fValue - ((XRLXeFloatValue)param2).fValue);
                } else if ((param1 is XRLXeDoubleValue) && (param2 is XRLXeDoubleValue)) {
                    return new XRLXeDoubleValue(((XRLXeDoubleValue) param1).dValue - ((XRLXeDoubleValue)param2).dValue);
                } else {
                    throw new InvalidCastException("Exception in attempting to subtract--Either mismatched or non-numeric XRLXeAttribParamValue types!");
                }
            }


            //The following two convert to double before the compare.
            //overloaded operator so we can compare params.
            public static bool operator >(XRLXeAttribParamValue param1, XRLXeAttribParamValue param2) {
                return (param1.GetNumericValue() > param2.GetNumericValue());
            }

            //overloaded operator so we can compare params.
            public static bool operator <(XRLXeAttribParamValue param1, XRLXeAttribParamValue param2) {
                return (param1.GetNumericValue() < param2.GetNumericValue());
            }

	}

	/// <summary>
	/// can be used represent both int32 and int64 values
	/// </summary>
	public class XRLXeIntValue : XRLXeAttribParamValue
	{
		public long			intValue;

		/// <summary>
		/// create an intParam with specified value
		/// </summary>
		/// <param name="val"></param>
		public XRLXeIntValue(long val)
		{
			intValue = val;
		}

		public XRLXeIntValue()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(intValue);
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}

                public override string ToString()
                {
                    return intValue.ToString();
                }
	}
	public class XRLXeFloatValue : XRLXeAttribParamValue
	{
        // To avoid breaking the Xbox 1 protocol, which didn't support floats, a special bitmask
        // is used to detect a float by the Xenon code, but the legacy Xbox 1 code still wants to
        // read it in as a 64-bit unsigned int, so padding to 64 bits on the wire is necessary.
		public float			fValue;
		public int				padTo64Bits = 0;

		/// <summary>
		/// create an intParam with specified value
		/// </summary>
		/// <param name="val"></param>
		public XRLXeFloatValue(float val)
		{
			fValue = val;
		}

		public XRLXeFloatValue()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(fValue);
            binaryWriter.Write(padTo64Bits);
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}

                public override string ToString()
                {
                    return fValue.ToString();
                }

	}

	public class XRLXeDoubleValue : XRLXeAttribParamValue
	{
		public double			dValue;

		/// <summary>
		/// create an intParam with specified value
		/// </summary>
		/// <param name="val"></param>
		public XRLXeDoubleValue(double val)
		{
			dValue = val;
		}

		public XRLXeDoubleValue()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(dValue);
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}

                public override string ToString()
                {
                    return dValue.ToString();
                }

	}

	public class XRLXeStringValue : XRLXeAttribParamValue
	{
		private ushort	_strValueLen;
		private string	_strValue;
        public ushort strValueLen
        {
            get {
                return _strValueLen;
            }
        }
        public string strValue
        {
            set {
                _strValue = value;

                if(null == value)
                {
                    _strValueLen = 1;
                }
                else
                {
                    byte []utf8 = Encoding.UTF8.GetBytes(_strValue);
                    if((utf8.Length + 1) > ushort.MaxValue)
                    {
                        throw new ArgumentException("String value + nul byte will overflow the protocol length specifier");
                    }
                    _strValueLen = (ushort)(utf8.Length + 1);
                }
            }
            get {
                return _strValue;
            }
        }

		/// <summary>
		/// create a stringParam with specified string value
		/// </summary>
		/// <param name="val"></param>
		public XRLXeStringValue(string val)
		{
            if(val.EndsWith("\0"))
            {
                // Skip explicit measurement, many tests
                // pass in "abc\0"
                _strValue = val;
                _strValueLen = (ushort)val.Length;
            }
            else
            {
		        strValue = val;	
            }
		}

		public XRLXeStringValue()
		{
            strValue = null;
		}

        // special constructor to allow invalid wiredata
        public XRLXeStringValue(string strValue, ushort strValueLen)
        {
            _strValue = strValue;
            _strValueLen = strValueLen;
        }

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (_strValue == null)
			{
                // Even empty strings should have a nul byte in the protocol unless
                // we've been told to not send it (for negative cases)
                binaryWriter.Write(_strValueLen);
				if(_strValueLen > 0)
                {
                    binaryWriter.Write((byte)0);
                }
			}
			else
			{
				binaryWriter.Write(_strValueLen);
                byte[] utf8 = Encoding.UTF8.GetBytes(_strValue);
				binaryWriter.Write(utf8);

                // If the string has not be explicitly terminated by the constructor or has
                // been left intentionally without room for the null (negative case constructor)
                // do not write the nul.
                if(!_strValue.EndsWith("\0") && _strValueLen == (utf8.Length + 1))
                {
                    binaryWriter.Write((byte)0);
                }
			}
		}

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _strValueLen = binaryReader.ReadUInt16();
            byte []utf8 = binaryReader.ReadBytes(_strValueLen);
            _strValue = Encoding.UTF8.GetString(utf8);

            return this;
        }

		public override object DeepClone()
		{
			// Start with a shallow clone
			XRLXeStringValue clone = (XRLXeStringValue)this.MemberwiseClone();
			// Can't use String.Clone():  "The return value is not an independent copy of this instance;
			// it is simply another view of the same data."
			clone._strValue = null == _strValue ? null : string.Copy(this._strValue);
			return(clone);
		}

                public override string ToString()
                {
                    return _strValue;
                }

	}

    public class XRLXeBlobValue : XRLXeAttribParamValue
    {
        public ushort blobLen;
        public byte[] blob;

        public XRLXeBlobValue()
        {
        }

        public XRLXeBlobValue(byte[] blob)
        {
            if(null == blob)
            {
                blobLen = 0;
                this.blob = null;
            }
            else
            {
                blobLen = (ushort) blob.Length; //this better be smaller than a ushort!
                this.blob = new byte[blobLen];
                Array.Copy(blob, this.blob, blobLen);
            }
        }

        //if for some reason you wanted to not use all of the array in a blob for the attrib.
        //Disabled for now.  Who would use this?
        private XRLXeBlobValue(byte[] blob, ushort len)
        {
            blobLen = len;
            this.blob = new byte[blobLen];
            Array.Copy(blob, this.blob, blobLen);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(blobLen);

            if(null != blob)
            {
                binaryWriter.Write(blob);
            }
        }

        public override object DeepClone()
        {
            byte []cloneBlobData = new byte[blob.Length];

            Array.Copy(blob, cloneBlobData, blob.Length);
            XRLXeBlobValue clone = new XRLXeBlobValue(cloneBlobData, blobLen);

            return clone;
        }

        public override string ToString()
        {
            string val = "0x";
            for (int i=0; i< blobLen; i++) {
                val += blob[i].ToString("X");
            }
            return val;
        }

    }

    public class XRLXeDateTimeValue : XRLXeAttribParamValue
    {
        public long			dateValue;

		/// <summary>
		/// create an intParam with specified value
		/// </summary>
		/// <param name="val"></param>
		public XRLXeDateTimeValue(long val)
		{
			dateValue = val;
		}

		public XRLXeDateTimeValue()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(dateValue);
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}

                public override string ToString()
                {
                    return dateValue.ToString(); //convert to readable time someday.  what format is it?
                }


	}

	public class XRLXeNullValue : XRLXeAttribParamValue
	{
		public XRLXeNullValue()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}
                public override string ToString()
                {
                    return "nullValue";
                }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRL2CreateUpdateSession.cs ===
using System;
using System.Collections;
using System.Net;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// Since WireData doesn't support inheritance (it doesn't serialize parent class's fields),
    /// Instead of inheriting from XRLCreateUpdateSession, we create a wrapper of that
    /// </summary>
    public class XRL2CreateUpdateSession : XRLPayload
    {
        public XRLCreateUpdateSession	baseCreateUpdate;
        [WireInfo(Serialize = false)]
        private CSGInfo.ClientType _clientType = CSGInfo.ClientType.Xenon;
        public CSGInfo.ClientType ClientType
        {
            get
            {
                return _clientType;
            }
        }

        protected override string GetServiceName()
        {
            return "/xmatch/xmatchhost2.ashx";
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            baseCreateUpdate.WriteStream(binaryWriter);
        }

        //set the underlying baseCreateUpdate requests to have some good basic structures.
        private void InitializeXenonBaseCreateUpdate() {
            baseCreateUpdate = new XRLCreateUpdateSession();
            baseCreateUpdate.baseSession.HostAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();  
            baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE;
        }

        /// <summary>
        /// create session with 9 mandatory session attributes.
        /// </summary>
        public XRL2CreateUpdateSession()
        {
            InitializeXenonBaseCreateUpdate();

            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));
//            Attribs[9] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_TYPE, new XRLXeIntValue(1)); //1==Xenon
//            Attribs[10] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_LOCK, new XRLXeIntValue(0)); //0==can
                                                                                                          //be crossplatform

            this.AddAttribs(Attribs);

            this.ServiceId = XOService.Matchmaking;
        }

        /// <summary>
        /// create session with provided attributes: this might or might not have the above 8 default attribs
        /// </summary>
        public XRL2CreateUpdateSession(XRLXeAttribParam[] Attribs)
        {
            InitializeXenonBaseCreateUpdate();

            this.AddAttribs(Attribs);

            this.ServiceId = XOService.Matchmaking;
        }

        /// <summary>
        /// update session constructor
        /// </summary>
        public XRL2CreateUpdateSession(byte [] sessID)
        {
            InitializeXenonBaseCreateUpdate();

            Array.Copy(sessID,baseCreateUpdate.baseSession.SessionID,8);

            this.ServiceId = XOService.Matchmaking;
        }

        //Change this create so it appears to come from a different platform.
        public void SetToPlatform(CSGInfo.ClientType platformType) {
            baseCreateUpdate.baseSession.HostAddress.abOnline = new SGADDR(platformType).toByteArray();
        }

        public void AddAttrib(XRLXeAttribParam attrib)
        {
            XRLXeAttribParam[] attribs = new XRLXeAttribParam[1];
            attribs[0] = attrib;
            AddAttribs(attribs);
        }

        public void AddAttribs(XRLXeAttribParam[] attribs)
        {
            if ((attribs == null) || (attribs.Length == 0))
            {
                return;
            }

            uint	dwExistingAttribs = this.baseCreateUpdate.AttribOffsetsLen;
            uint	dwNewAttribs = (uint)attribs.Length;

            uint	dwTotalAttribs = this.baseCreateUpdate.AttribOffsetsLen = dwNewAttribs + dwExistingAttribs;
	
            XRLXeAttribParam [] fullAttribs = new XRLXeAttribParam[dwTotalAttribs];
            for (uint i = 0; i < dwExistingAttribs; i++)
            {
                fullAttribs[i] = (XRLXeAttribParam)this.baseCreateUpdate.Attribs[i];
            }
            for (uint i = dwExistingAttribs, j = 0; i < dwTotalAttribs; i++, j++)
            {
                fullAttribs[i] = attribs[j];
            }
            this.baseCreateUpdate.AttribOffsets = new uint[dwTotalAttribs];
            this.baseCreateUpdate.Attribs = new XrlAttributeBase[dwTotalAttribs];
            this.baseCreateUpdate.AttribOffsets[0] = Constants.SIZEBASESESSION + dwTotalAttribs * 4;
            this.baseCreateUpdate.baseSession.dwMessageLength = Constants.SIZEBASESESSION + dwTotalAttribs*4;

            XRLXeIntValue		intTemp;
            XRLXeFloatValue		fTemp;
            XRLXeDoubleValue	doubleTemp;
            XRLXeDateTimeValue	dateTemp;
            XRLXeStringValue	stringTemp;
            XRLXeNullValue		nullTemp;

            for(uint i = 0; i < dwTotalAttribs; i++)
            {
                if((nullTemp = fullAttribs[i].aValue as XRLXeNullValue) != null)
                {
                    this.baseCreateUpdate.baseSession.dwMessageLength += 4;
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,nullTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4;
                }
                if((intTemp = fullAttribs[i].aValue as XRLXeIntValue) != null)
                {
                    this.baseCreateUpdate.baseSession.dwMessageLength += 4+8;
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,intTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4+8;
                }
                else if((stringTemp = fullAttribs[i].aValue as XRLXeStringValue) != null)
                {
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,stringTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4+2+stringTemp.strValueLen;
                    // update total message length
                    this.baseCreateUpdate.baseSession.dwMessageLength += (uint)(4+2+stringTemp.strValueLen);
                }
                else if ((fTemp = fullAttribs[i].aValue as XRLXeFloatValue) != null)
                {
                    this.baseCreateUpdate.baseSession.dwMessageLength += 4+8;
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,fTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4+8;
                }
                else if ((doubleTemp = fullAttribs[i].aValue as XRLXeDoubleValue) != null)
                {
                    this.baseCreateUpdate.baseSession.dwMessageLength += 4+8;
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,doubleTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4+8;
                }
                else if ((dateTemp = fullAttribs[i].aValue as XRLXeDateTimeValue) != null)
                {
                    this.baseCreateUpdate.baseSession.dwMessageLength += 4+8;
                    this.baseCreateUpdate.Attribs[i] = new XRLXeAttribParam(fullAttribs[i].attribParamID,dateTemp);
                    if(i != (dwTotalAttribs-1))
                        this.baseCreateUpdate.AttribOffsets[i+1] = this.baseCreateUpdate.AttribOffsets[i]+4+8;
                }
            }
        }

            
        /// <summary>
        /// Fills in the given XRLXeAttribParam with the value of the current one, if it exists.
        /// Leaves it unchanged otherwise.
        /// </summary>
        /// <param name="attribToFind">An XRLXeAttribParam to look for, and fill with the value.</param>
        public void RetrieveCurrentValue(XRLXeAttribParam attribToFill) {
            XRLXeAttribParam currentAttrib = FindAttrib(attribToFill);
            if (currentAttrib != null) {
                attribToFill.aValue = (XRLXeAttribParamValue)currentAttrib.aValue.DeepClone();
            }
        }

        /// <summary>
        /// Find a single attribute with the given parameter.  Does not use the passed-in value of
        /// that attribute.
        /// </summary>
        /// <param name="attribToFind">An XRLXeAttribParam to look for</param>
        /// <returns>A handle to the XRLXeAttribParam that currently exists and matches the name of the
        /// passed-in attribute.  Think before assigning to this!  Returns null if none is found.</returns>
        private XRLXeAttribParam FindAttrib(XRLXeAttribParam attribToFind) {
            foreach (XRLXeAttribParam currentAttrib in baseCreateUpdate.Attribs) {
                if (attribToFind.attribParamID == currentAttrib.attribParamID) {
                    if (attribToFind.GetType() != currentAttrib.GetType()) {
                        throw new Exception("AttributeID: " + attribToFind.attribParamID.ToString("x") +
                                            " does not match type in input: " + currentAttrib.GetType().Name);
                    }
                    return currentAttrib;
                }
            }
            return null;
        }
            
        /// <summary>
        /// Updates a single attribute.  Unlike UpdateAttribs(), the attribute must be found in the
        /// base attribs array
        /// </summary>
        /// <param name="updateAttrib"></param>
        public void UpdateAttrib(XRLXeAttribParam targetAttrib)
        {
            if (targetAttrib == null)
            {
                return;
            }

            XRLXeAttribParam currentAttrib = FindAttrib(targetAttrib);
            if (currentAttrib != null) 
            {
                currentAttrib.aValue = (XRLXeAttribParamValue)targetAttrib.aValue.DeepClone();
            } 
            else 
            {
                throw new ArgumentException("Attribute ID 0x" + targetAttrib.attribParamID.ToString("X") +
                                            " not found.", "targetAttrib");
            }
            
            MatchUtil.CalculateOffsets(
                Constants.SIZEBASESESSION,
                baseCreateUpdate.Attribs,
                out baseCreateUpdate.AttribOffsets,
                out baseCreateUpdate.baseSession.dwMessageLength);
        }
            
        public void UpdateAttribs(XRLXeAttribParam[] attribs)
        {
            if(attribs == null)
            {
                return;
            }

            ArrayList newAttribs = new ArrayList();
            XRLXeAttribParam addParam;

            foreach(XRLXeAttribParam attr in attribs)
            {
                addParam = attr;

                // Look for an existing parameter to use (update its value if found first)
                foreach(XRLXeAttribParam current in baseCreateUpdate.Attribs)
                {
                    if(attr.attribParamID == current.attribParamID)
                    {
                        if(attr.GetType() != current.GetType())
                        {
                            throw new Exception("AttributeID: " + current.attribParamID.ToString("x") + 
                                                " does not match type in input: " + attr.GetType().Name);
                        }
                        current.aValue = (XRLXeAttribParamValue)attr.aValue.DeepClone();
                        addParam = current;
                        break;
                    }
                }

                newAttribs.Add(addParam);
            }

            XRLXeAttribParam []attrs = (XRLXeAttribParam[])newAttribs.ToArray(typeof(XRLXeAttribParam));
            MatchUtil.CalculateOffsets(
                Constants.SIZEBASESESSION, 
                attrs, 
                out baseCreateUpdate.AttribOffsets, 
                out baseCreateUpdate.baseSession.dwMessageLength);
            baseCreateUpdate.AttribOffsetsLen = (uint)baseCreateUpdate.AttribOffsets.Length;
            baseCreateUpdate.Attribs = attrs;
        }

        public void RemoveAttrib(XRLXeAttribParam targetAttrib)
        {
            if (targetAttrib == null)
            {
                return;
            }

            ArrayList newAttribs = new ArrayList();
            XRLXeAttribParam addParam;

            bool found = false;
            // Look for an existing parameter to use (update it's value if found first)
            foreach (XRLXeAttribParam currentAttrib in baseCreateUpdate.Attribs)
            {
                addParam = currentAttrib;
                if (targetAttrib.attribParamID == currentAttrib.attribParamID)
                {
                    if (targetAttrib.GetType() != currentAttrib.GetType())
                    {
                        throw new Exception("AttributeID: " + currentAttrib.attribParamID.ToString("x") +
                                            " does not match type in input: " + targetAttrib.GetType().Name);
                    }
                    found = true;
                    continue;
                }
                newAttribs.Add(addParam);
            }
            if (!found)
            {
                throw new ArgumentException("Attribute ID 0x" + targetAttrib.attribParamID.ToString("X") +
                                            " not found.", "targetAttrib");
            }

            XRLXeAttribParam[] attrs = (XRLXeAttribParam[])newAttribs.ToArray(typeof(XRLXeAttribParam));
            MatchUtil.CalculateOffsets(
                Constants.SIZEBASESESSION,
                attrs,
                out baseCreateUpdate.AttribOffsets,
                out baseCreateUpdate.baseSession.dwMessageLength);
            baseCreateUpdate.AttribOffsetsLen = (uint)baseCreateUpdate.AttribOffsets.Length;
            baseCreateUpdate.Attribs = attrs;
        }

        public void CopySGInfoFrom(XRL2CreateUpdateSession src)
        {
            ManualPopulateSlot();
            Slot = src.Slot.ShallowClone();
            baseCreateUpdate.baseSession.HostAddress =
                (XRLxnaddr)src.baseCreateUpdate.baseSession.HostAddress.DeepClone();
        }

        public void SetClientType(CSGInfo.ClientType clientType)
        {
            _clientType = clientType;
            SGADDR sgAddr = new SGADDR(baseCreateUpdate.baseSession.HostAddress.abOnline);
            sgAddr.qwXboxID = MatchUtil.RandomGen.GenerateRandomMachineId(clientType);
            baseCreateUpdate.baseSession.HostAddress.abOnline = sgAddr.toByteArray();
        }

        /// <summary>
        /// send createSession requests
        /// </summary>
        /// <param name="sServer"></param>
        /// <param name="Response"></param>
        /// <returns></returns>
        public bool Execute(IPEndPoint sServer, out XRLSessionInfo Response)
        {
            MatchUtil.SetSGInfo(this, _clientType, baseCreateUpdate.baseSession.dwTitleID, 
                                baseCreateUpdate.baseSession.HostAddress);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLSessionInfo();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);
                    uRet = true;
                }
            }
            return uRet;
        }

        /// <summary>
        /// Send CreateSession requests asynchronously.
        /// </summary>
        /// <param name="sServer"></param>
        /// <returns></returns>
        public IAsyncResult BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MatchUtil.SetSGInfo(this, _clientType, baseCreateUpdate.baseSession.dwTitleID, 
                                baseCreateUpdate.baseSession.HostAddress);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            return BeginInternalExecute(sServer,reqStream, callback);
        }

        //For creates, read the XRLSessionInfo out of the response buffer.
        public bool EndExecute(IAsyncResult ar, out XRLSessionInfo Response)
        {
            bool uRet = false;
            Response = null;
            bool bRet = EndInternalExecute(ar);
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLSessionInfo();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);
                    uRet = true;
                }
            }
            return uRet;
        }

        //For updates, and callers that don't care about responses, read nothing back.
        public bool EndExecute(IAsyncResult ar)
        {
            bool uRet = false;
            bool bRet = EndInternalExecute(ar);
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }


        /// <summary>
        /// send updateSession requests
        /// </summary>
        /// <param name="sServer"></param>
        /// <returns></returns>
        public override bool Execute(IPEndPoint sServer)
        {
            MatchUtil.SetSGInfo(this, _clientType, baseCreateUpdate.baseSession.dwTitleID,
                                baseCreateUpdate.baseSession.HostAddress);
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }

        // this function assumes that 1. only one session returned
        // 2. no addtional attributes returned along with the session and
        // 3. this is called relatively soon after a create/update(it may advance closer to expiration date)
        public bool Verify(XRL2SearchResults searchRes, bool ranked)
        {
            long	expDate = DateTime.UtcNow.AddHours(24).ToFileTime();
            byte	expected_isavailable = 0;
            if(this.baseCreateUpdate.baseSession.dwPublicOpen > 0)
                expected_isavailable = 1;
            /*******************************************************************
             * The following checks columns that are returned in searchResults
             *******************************************************************/
            uint expectedResultsLen = Constants.SIZEBASESEARCHRESULT+Constants.SIZESEARCHHEADER;
            if(searchRes.dwMessageLength != expectedResultsLen)
            {
                Global.RO.Warn("dwMessageLength in search Results is not wrong:"+searchRes.dwMessageLength);
                return false;
            }
            if(searchRes.resultsLen != 1)
            {
                Global.RO.Warn("resultsLen (nNumSearchResults) is not 1:"+searchRes.resultsLen);
                return false;
            }
            if(searchRes.results[0].dwResultLength != Constants.SIZEBASESEARCHRESULT)
            {
                Global.RO.Warn("dwResultLength in the searchResult is wrong:"+searchRes.results[0].dwResultLength);
                return false;
            }
            if(!searchRes.results[0].HostAddress.compare(this.baseCreateUpdate.baseSession.HostAddress))
            {
                Global.RO.Warn("hostAddress in the searchResult is not the one sent in the create Request");
                return false;
            }
            if(searchRes.results[0].dwPrivateOpen != this.baseCreateUpdate.baseSession.dwPrivateOpen)
            {
                Global.RO.Warn("dwPrivateOpen in the searchResult is not the one sent in the createSession request");
                return false;
            }
            if(searchRes.results[0].dwPrivateFilled != this.baseCreateUpdate.baseSession.dwPrivateFilled)
            {
                Global.RO.Warn("dwPrivateFilled in the searchResult is not the one sent in the createSession request");
                return false;
            }
            if(searchRes.results[0].dwPublicFilled != this.baseCreateUpdate.baseSession.dwPublicFilled)
            {
                Global.RO.Warn("dwPublicFilled in the searchResult is not the one sent in the createSession request");
                return false;
            }
            if(searchRes.results[0].dwPublicOpen != this.baseCreateUpdate.baseSession.dwPublicOpen)
            {
                Global.RO.Warn("dwPublicOpen in the searchResult is not the one sent in the createSession request");
                return false;
            }
            if(searchRes.results[0].AttribOffsetsLen != 0)
            {
                Global.RO.Warn("dwNumAttributes in the searchResult is not 0:"+searchRes.results[0].AttribOffsetsLen);
                return false;
            }
            /**************************************************************************
             * The following send inquiries to db directly to check additional columns
             * i_sg_ip,b_box_id,dt_session_expiration;ti_is_available
             **************************************************************************/
            uint	titleID = this.baseCreateUpdate.baseSession.dwTitleID;
            string	hexTitleID = "0x"+titleID.ToString("X");
            bool	found = false;
            long	lSessID = 0;
            for(int i = 7; i >= 0; i--)
            {
                lSessID <<=8;
                lSessID += searchRes.results[0].SessionID[i];
            }
            int				r_sgip = 0, expectedSgIp = 0;
            byte[]			r_boxid = new byte[8], expectedBoxID = new byte[8];
            long			r_ExpirationDate = 0;
            byte			r_isavailable = 0;
            // in xenon, we might not have title tables created across all servers, 
            // instead, we will only have title tables created in the actual servers that they live
//            string		[]	dbList = Constants.getDBListForTitle(titleID);
            //no attributes returned, so we can only check on the server that the ID points o.
            string dbList = MatchUtil.FindServerForSession(new MatchSession(titleID, searchRes.results[0]), true);
            if(dbList == "")
            {
                Global.RO.Warn("Can't find the title in the npdb");
                return false;
            }

            string myQuery = "Query not set";

            string server = dbList;
            { //connect to server
                found = false;
                // connect to the db
                string myConnStr = "Data Source=" + server + ";Database=xmatch;Trusted_Connection=true";
                SqlConnection	mySqlConn;
                mySqlConn =  new SqlConnection(myConnStr);
                // get the row according to bi_session_id
                if(ranked)
                    myQuery = @"SELECT s.i_sg_ip, s.b_box_id, s.dt_session_expiration,s.ti_is_available
    FROM dbo.t_match_sessions_" + hexTitleID + @"_ranked s
    WHERE s.bi_session_id=" + lSessID;
                else //standard
                    myQuery = @"SELECT s.i_sg_ip, s.b_box_id, s.dt_session_expiration,s.ti_is_available
    FROM dbo.t_match_sessions_" + hexTitleID + @"_standard s
    WHERE s.bi_session_id=" + lSessID;

                SqlCommand		myCommand = new SqlCommand(myQuery, mySqlConn);
                myCommand.Connection.Open();
                SqlDataReader	myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    found = true;
                    r_sgip = IPAddress.NetworkToHostOrder(myReader.GetInt32(0));
                    myReader.GetBytes(1,0,r_boxid,0,8);
                    // The datetime we get back from the DB is UTC, regardless of whether the DB server thinks it's in that timezone.
                    // ToFileTime() assumes that it's a local time, which screws things up.  ToFileTimeUtc() assumes that it's
                    // a UTC time, which is correct... but I'd rather explictly set the kind.
                    r_ExpirationDate = DateTime.SpecifyKind(myReader.GetDateTime(2), DateTimeKind.Utc).ToFileTimeUtc();
                    r_isavailable = myReader.GetByte(3);
                }
                myReader.Close();
                myCommand.Connection.Close();
            }

            if (!found)
            {
                Global.RO.Warn("Did not find session using query:\r\n" + myQuery);
                return false;
            }
            for(int i = 3; i >= 0 ; i--)
            {
                expectedSgIp <<= 8;
                expectedSgIp += this.baseCreateUpdate.baseSession.HostAddress.abOnline[i];
            }
            for(int i = 4; i < 12; i++)
                expectedBoxID[i-4] = this.baseCreateUpdate.baseSession.HostAddress.abOnline[i];
            if(found)
            {
                for(int i = 0; i < r_boxid.Length; i++)
                    if(r_boxid[i] != expectedBoxID[i])
                    {
                        Global.RO.Warn("b_box_id is not set correctly");
                        return false;
                    }
                if(expectedSgIp != r_sgip)
                {
                    Global.RO.Warn("i_sg_ip is not set correctly:"+r_sgip);
                    return false;
                }
                if(r_isavailable != expected_isavailable)
                {
                    Global.RO.Warn("ti_is_available is not set correctly:"+r_isavailable);
                    return false;
                }
                // time difference is within 5 minute(300s) is tolerable
                if(((r_ExpirationDate > expDate) && ((r_ExpirationDate-expDate)/10000000>300)) // TODO: Allowing an additional hour of time skew until Testnet clocks are fixed, then should be 300
                   ||((r_ExpirationDate < expDate) && ((expDate-r_ExpirationDate)/10000000>300)))
                {
                    Global.RO.Warn("The dt_expiration_time is not set correctly: (" + r_ExpirationDate.ToString() + ", " + expDate.ToString() + ")!");
                    return false;
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\MatchUtilities.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
	/// <summary>
	/// Summary description for XRLxnaddr.
	/// </summary>
	public class XRLxnaddr : WireData, IDeepCloneable
	{
		[XRLPayloadFld(ArraySize=4)]
		public byte[]	ina;			// IP address(zero is not static/dhcp)
		[XRLPayloadFld(ArraySize=4)]
		public byte[]	inaOnline;		// online IP address (zero if not online)
		public ushort	wPortOnline;	// online port
		[XRLPayloadFld(ArraySize=6)]
		public byte[]	abEnet;			// ethernet mac address
		[XRLPayloadFld(ArraySize=20)]
		public byte[]	abOnline;		// online identification

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(ina);
			binaryWriter.Write(inaOnline);
			binaryWriter.Write(wPortOnline);
			binaryWriter.Write(abEnet);
			binaryWriter.Write(abOnline);
		}

        public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLxnaddr clone = (XRLxnaddr)this.MemberwiseClone();
			// All arrays of value types, built-in shallow clone is fine
			clone.ina = (byte[])this.ina.Clone();
			clone.inaOnline = (byte[])this.inaOnline.Clone();
			clone.abEnet = (byte[])this.abEnet.Clone();
			clone.abOnline = (byte[])this.abOnline.Clone();
			return(clone);
		}

		public bool compare(XRLxnaddr hostAddr)
		{
			for(int i = 0; i < this.abEnet.Length; i++)
				if(this.abEnet[i] != hostAddr.abEnet[i])
					return false;
			for(int i = 0; i < this.abOnline.Length; i++)
				if(this.abOnline[i] != hostAddr.abOnline[i])
					return false;
			for(int i = 0; i < this.ina.Length; i++)
				if(this.ina[i] != hostAddr.ina[i])
					return false;
			for(int i = 0; i < this.inaOnline.Length; i++)
				if(this.inaOnline[i] != hostAddr.inaOnline[i])
					return false;
			return true;
		}
	}

	public class SGADDR : WireData
	{
        [XRLPayloadFld(ArraySize = 4)]
        public byte[] inaSg;			// IP address of the SG for the client
        public uint dwSpiSg;		// Pseudo-random id assigned by SG
        public ulong qwXboxID;		// unique id of client machine account
        [XRLPayloadFld(ArraySize = 4)]
        public byte[] abReserved;		// Reserved (must be zero)
		
		public SGADDR()
		{
            Initialize(CSGInfo.ClientType.Xenon);
		}

        public SGADDR(CSGInfo.ClientType clientType)
        {
            Initialize(clientType);
        }

        private void Initialize(CSGInfo.ClientType clientType)
        {
            inaSg = new byte[4] { 1, 2, 3, 4 };
            dwSpiSg = (uint)MatchUtil.RandomGen.Next();
            qwXboxID = MatchUtil.RandomGen.GenerateRandomMachineId(clientType);
            abReserved = new byte[4] { 0, 0, 0, 0 };
        }

        public SGADDR(byte[] sgByteArray)
        {
            inaSg = new byte[4];
            Array.Copy(sgByteArray, inaSg, 4);

            byte[] temp = new byte[4];
            Array.Copy(sgByteArray, 4, temp, 0, 4);
            dwSpiSg = MatchUtil.ByteArrayToUInt(temp);

            temp = new byte[8];
            Array.Copy(sgByteArray, 8, temp, 0, 8);
            qwXboxID = MatchUtil.ByteArrayToULong(temp);

            abReserved = new byte[4];
            Array.Copy(sgByteArray, 16, abReserved, 0, 4);
        }

        // need to be careful about the byte order
		// little endian on the wire and locally:
		// on the wire: 01020304 will be interpreted as 0x04030201 locally
		public byte[] toByteArray()
		{
			byte [] sgByteArray = new byte[Constants.SIZESGADDR];
			Array.Copy(inaSg,sgByteArray,inaSg.Length);
			uint	temp1 = dwSpiSg; ulong temp2 = qwXboxID;
			for(int i = 0; i < 4; i++)
			{
				sgByteArray[i+inaSg.Length] = (byte)(temp1 & 255);
				temp1 >>=8;
			}
			for(int i = 0; i < 8; i++)
			{
				sgByteArray[i+4+inaSg.Length] = (byte)(temp2 & 255);
				temp2 >>=8;
			}
			// the rest are all 0s by default
			return sgByteArray;
		}

        public void CopyTo(byte[] dest)
        {
            toByteArray().CopyTo(dest, 0);
        }
	}

	public class	Constants
	{
		// convert byte[8] to long; integer is little endian on the wire:
		// 01020304 on the wire is actually interpreted as int=0x04030201 internally
		// little endian locally
		public static long sessionIDConvert(byte[] sessID)
		{
			long	lSessID = 0;
			for(int i = 7; i >=0; i--)
			{
				lSessID <<=8;
				lSessID += sessID[i];
			}
			return lSessID;
		}

        public static byte[] sessionIDConvert(long lSessID)
        {
            byte[] sessID = new byte[8];
            for (int i = 0; i < 8; i++)
            {
                sessID[i] = (byte)(lSessID & 0xFF);
                lSessID >>= 8;
            }
            return sessID;
        }

		// Xenon: this change is to make xmatchtest works in any enviroment (for example, xblob)
		/// <summary>
		/// return the number of database that a particular title resides
		/// </summary>
		/// <param name="titleID"></param>
		/// <returns></returns>
		public static uint getNumDBForTitle(uint titleID)
		{
			// convert titleID to int
			uint		numDB = 1;
			int			title = (int)titleID;
			string		dbList = "";
            Npdb        npdb = new Npdb();
			bool		found = false;
			//establish a connection to npdb and query t_match_titles table
            npdb.ConnectToServer();

			string			myQuery = @"SELECT vc_db_list
										FROM t_match_titles t
										WHERE t.i_title_id=" + title;
            try
            {
                SqlDataReader myReader;
                npdb.ReadData(myQuery, out myReader);

                using (myReader)
                {
                    while (myReader.Read())
                    {
                        found = true;
                        dbList = myReader.GetString(0);
                    }
                }
            }
            finally
            {
                npdb.Close();
            }

			if(found)
			{
				for(int i = 0; i < dbList.Length; i++)
				{
					if(dbList[i]==';')
						numDB++;
				}
				return numDB;
			}
			else
			{
				Global.RO.Warn("No title was found in t_match_titles in npdb!");
				return 0;
			}
		}

            //This is deprecated, and replaced by FindServersForSession in the future.
		public static string [] getDBListForTitle(uint titleID)
		{
			// convert titleID to int
			int			title = (int)titleID;
			string	[]	dbList;
			string		dbStr="";
            Npdb        npdb = new Npdb();
            bool        found = false;
			//establish a connection to npdb and query t_match_titles table

			string      myQuery = @"SELECT vc_db_list
										FROM t_match_titles t
										WHERE t.i_title_id=" + title;

            npdb.ConnectToServer();
            try
            {
                
                SqlDataReader myReader;
                npdb.ReadData(myQuery, out myReader);

                using (myReader)
                {
                    while (myReader.Read())
                    {
                        found = true;
                        dbStr = myReader.GetString(0);
                    }
                }
            }
            finally
            {
                npdb.Close();
            }

			if(found)
			{
				char [] separator=new char[1]{';'};
				dbList = dbStr.Split(separator);
				return dbList;
			}
			else
			{
				Global.RO.Warn("No title was found in t_match_titles in npdb!");
				return null;
			}
		}

		// test specific constants
		public const uint	UNKNOWN_TITLE = 0xaaaaaaaa;
		public const uint	TITLE_ID = 0xffed0001;
		public const uint	SAMPLE_INT_ATTRIB = 0x1;	// TITLE_ID has it
		public const uint	SAMPLE_STRING_ATTRIB = 0x100001;	//1048577 decimal
		public const uint	SAMPLE_BLOB_ATTRIB = 0x200002;	//2097154
		public const uint	SAMPLE_STRING_ATTRIB2 = 0x10AAAB;// max length in xms is 20
		public const uint	SAMPLE_BLOB_ATTRIB2 = 0x20AAAC;// max length in xms is 40

		public const uint	SIZESGADDR = 20;
		public const uint	SIZEXNADDR = 36;
		// the size of XMATCH_SESSION_DELETE
		public const uint	SIZEDELETESESSION = 16;
		// the size of XMATCH_SEARCHRESULT_HEADER
		public const uint	SIZESEARCHHEADER = 12;
		// the size of XMATCH_SEARCHRESULT
		public const uint	SIZEBASESEARCHRESULT = 84;
		// the size of XMATCH_SEARCH (including dwNumParameters)
		public const uint	SIZEBASESEARCH = 56;
		// the size of XMATCH_SESSION (including dwNumAttributes)
		public const uint	SIZEBASESESSION = 4*7 + 8 + Constants.SIZEXNADDR;
		// the size of XMATCH_DEAD_XBOX
		public const uint	SIZEDEADXBOX = 8 + Constants.SIZESGADDR;
		// the size of XMATCH_DEADSG
		public const uint	SIZEDEADSG = 8 + Constants.SIZESGADDR;
		// the size of XMATCH_TITLECHANGE
		public const uint	SIZETITLECHANGE = 12 + Constants.SIZESGADDR;
        // the size of XMATCH_SPLIT
        public const uint   SIZESPLIT = 64;

		// got from matchprot.cs
		public const int	XONLINE_MAX_LOGON_USERS = 4;
		public const uint	X_ATTRIBUTE_DATATYPE_MASK = 0x00F00000;
		public const uint	X_ATTRIBUTE_ID_MASK = 0x0000FFFF;

		public const uint	X_MAX_STRING_ATTRIBUTE_LEN = 400;
		public const uint	X_MAX_BLOB_ATTRIBUTE_LEN = 800;
		public const uint	X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC = 0x00000000;
		public const uint	X_ATTRIBUTE_DATATYPE_INTEGER = 0x00000000;
		public const uint	X_ATTRIBUTE_DATATYPE_STRING = 0x00100000;
		public const uint	X_ATTRIBUTE_DATATYPE_BLOB = 0x00200000;
		public const uint	X_ATTRIBUTE_DATATYPE_NULL = 0x00F00000;
		public const uint	X_SSINDEX_GET_SESSION = 0xFFFFFFFF;
                public const uint       X_SSINDEX_GET_SESSION_LIST = 0xFFFFFFFD; // special sproc to retrieve a list of sessions by id
                public const uint       X_MATCH_MAX_QUERY_RESULTS = 50;

		// XNKID definitions
		public const byte XNET_XNKID_MASK                             = 0xF0;    // Mask of flag bits in first byte of XNKID
		public const byte XNET_XNKID_NAT_MASK                         = 0x30;    // Mask of NAT bits for Match create in first byte of XNKID
		public const byte XNET_XNKID_DBINDEX_MASK                     = 0x0F;    // Mask of DB index the session is on for Match-created XNKIDs
		public const byte XNET_XNKID_SYSTEM_LINK                      = 0x00;    // Peer to peer system link session
		public const byte XNET_XNKID_ONLINE_PEER                      = 0x80;    // Peer to peer online session
		public const byte XNET_XNKID_ONLINE_SERVER                    = 0xC0;    // Client to server online session
		public const byte XNET_XNKID_ONLINE_TITLESERVER               = 0xE0;    // Client to title server online session

		// Values for MatchSearch.wFlags
		public const ushort XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK   = 0x0003; // Contains the NAT type of the calling client, one of XONLINE_NAT_xxx
		public const ushort XONLINE_MATCH_SEARCH_FLAG_NO_CACHE        = 0x8000; // Don't use the session cache for this search
                public const ushort XONLINE_MATCH_SEARCH_WEIGHTED             = 0x4000; // if on, search uses weights provided in the array.
		public const ushort XONLINE_MATCH_SEARCH_FLAGS_RESERVED       = 0x3FFC;
		public enum	XONLINE_NAT_TYPE :ushort {XONLINE_NAT_OPEN=1,XONLINE_NAT_MODERATE,XONLINE_NAT_STRICT}

        // Values for DeadXbox/DeadSg messages
		public const ushort SGMSG_TYPE_NOTIFY_CLI_DEL                 = 0x4712;  // CSgMsgNotifyCliDelete
		public const ushort SGMSG_TYPE_NOTIFY_CLI_TCHG				  = 0x4714;  // CSgMsgNotifyCliTitleChange

		/**************************************************************************************
		 * The followings are used by all Xenon tests
		 *************************************************************************************/
		//Xenon M3 changes: copy/paste from Matchprot.cs
		// Xenon supports the extended datatypes below. In order to not change the
		// protocol for existing clients, these extended types are all considered
		// to be X_ATTRIBUTE_DATATYPE_INTEGER by this class. The front door 
		// checks these extended bits (which were previously unused) 
		// to interpret each of the 64 bit chunks of type INTEGER correctly.
		public const uint X_ATTRIBUTE_XE_SUBTYPE_MASK                = 0x70000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_CONTEXT             = 0x00000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_UINT32              = 0x10000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_UINT64              = 0x20000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_FLOAT32             = 0x50000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_FLOAT64             = 0x30000000;
		public const uint X_ATTRIBUTE_XE_SUBTYPE_DATETIME            = 0x70000000;

		public const ushort XONLINE_MATCH_SEARCH_FLAG_USE_PRESENCE_EMU = 0x4000;

		/// <summary>
		/// The following const are system defined context/properties
		/// </summary>		
		
		// the attribute id used by the system FindById stored proc, type is UINT64
		public const uint X_ATTRIBUTE_SESSION_ID                     = 0x20008003;
                // the attribute id used by the system FindByIDs, type is blob.
		public const uint X_ATTRIBUTE_SESSION_ID_LIST                          = 0x60208012;
		public const uint X_ATTRIBUTE_GAMER_ZONE                               = 0x10008101;	// uint32
		public const uint X_ATTRIBUTE_GAMER_COUNTRY                            = 0x10008102;	// uint32
		public const uint X_ATTRIBUTE_GAMER_LANGUAGE                           = 0x10008103;	// uint32
		public const uint X_ATTRIBUTE_GAMER_RATING                             = 0x50008104;	// float32
		public const uint X_ATTRIBUTE_GAMER_MU	                               = 0x30008105;	// float64
		public const uint X_ATTRIBUTE_GAMER_SIGMA                              = 0x30008106;	// float64
		public const uint X_ATTRIBUTE_GAMER_PUID                               = 0x20008107;	// uint64
		public const uint X_ATTRIBUTE_AFFILIATE_VALUE                          = 0x20008108;	// uint64
		public const uint X_ATTRIBUTE_HOST_NAME                                = 0x40108109;	// string
                public const uint X_ATTRIBUTE_SESSION_SCORE                            = 0x5000810A;    // float32
		public const uint X_ATTRIBUTE_GAME_TYPE	                               = 0x0000800A;	// context
		public const uint X_ATTRIBUTE_GAME_MODE	                               = 0x0000800B;	// context
		public const long X_ATTRIBUTE_GAME_TYPE_RANKED	                       = 0;
		public const long X_ATTRIBUTE_GAME_TYPE_STANDARD                       = 1;
		public const uint PROPERTY_GAMERNAME                                   = 0x40100002;
                public const uint X_ATTRIBUTE_PLATFORM_TYPE                            = 0x10008201;
                public const uint X_ATTRIBUTE_PLATFORM_LOCK                            = 0x10008202;


        public static uint[] BaseSessionAttributes = new uint[] {
            X_ATTRIBUTE_GAME_TYPE,
            X_ATTRIBUTE_GAME_MODE,
            X_ATTRIBUTE_GAMER_ZONE,
            X_ATTRIBUTE_GAMER_COUNTRY,
            X_ATTRIBUTE_GAMER_LANGUAGE,
            X_ATTRIBUTE_GAMER_RATING,
            X_ATTRIBUTE_GAMER_MU,
            X_ATTRIBUTE_GAMER_SIGMA,
            X_ATTRIBUTE_GAMER_PUID,
            X_ATTRIBUTE_HOST_NAME,
        };

		public const uint XENON_TEST_DEFAULT_GAMER_ZONE				 = 1;
		public const uint XENON_TEST_DEFAULT_GAMER_COUNTRY			 = 1;
		public const uint XENON_TEST_DEFAULT_GAMER_LANG				 = 8;
		public const float XENON_TEST_DEFAULT_GAMER_RATING			 = 1f;
		public const float XENON_TEST_MAX_GAMER_RATING			     = 100.0f;
		public const double XENON_TEST_DEFAULT_GAMER_MU				 = 1.0;
		public const double XENON_TEST_MAX_GAMER_MU				     = 6.0;
		public const double XENON_TEST_DEFAULT_GAMER_SIGMA			 = 1.0;
		public const double XENON_TEST_MAX_GAMER_SIGMA			     = 1.0;
		public const long  XENON_TEST_DEFAULT_GAMER_PUID			 = 0x12345678;

		public const uint XENON_TITLE								 = 0xffed94b2;
		public const uint XENON_TITLE2								 = 0xffedAAAC;
                public const uint XENON_PARTITIONED_TITLE                                                = 0xffed94b3;
                //this title is both round robined and partitioned
                public const uint XENON_ROUND_ROBINED_TITLE                                                = 0xffed94b4;
		
		/// <summary>
		/// The following const are copied from xenonmatchTest.spa.h file
		/// </summary>
		// Context ids
		public const uint CONTEXT_MYCONTEXT1                         = 0x00000002;
		public const uint CONTEXT_MYCONTEXT2                         = 0x00000003;
		
		// Values for CONTEXT_MYCONTEXT1
		public const long CONTEXT_MYCONTEXT1_TRACKA                  = 0;
		public const long CONTEXT_MYCONTEXT1_TRACKB                  = 1;
		public const long CONTEXT_MYCONTEXT1_TRACKC                  = 2;

		// Values for X_X_ATTRIBUTE_GAME_MODE
		public const long CONTEXT_GAME_MODE_MODEA                    = 0;
		public const long CONTEXT_GAME_MODE_MODEB                    = 1;
		public const long CONTEXT_GAME_MODE_MODEC                    = 2;

		// Values for CONTEXT_MYCONTEXT2
		public const long  CONTEXT_MYCONTEXT2_ROUNDA                 = 0;
		public const long  CONTEXT_MYCONTEXT2_ROUNDB                 = 1;
		public const long  CONTEXT_MYCONTEXT2_ROUNDC                 = 2;

		// Property ids for XENON_TITLE
		public const uint PROPERTY_MYINT32PROP1                      = 0x10000002;
		public const uint PROPERTY_MYINT32PROP2                      = 0x1000000D;
		public const uint PROPERTY_MYINT64PROP1                      = 0x20000003;
		public const uint PROPERTY_MYINT64PROP2                      = 0x20000010;
		public const uint PROPERTY_MYFLOAT64PROP1                    = 0x30000008;
		public const uint PROPERTY_MYFLOAT64PROP2                    = 0x3000000F;
		public const uint PROPERTY_MYFLOAT32PROP1                    = 0x50000007;
		public const uint PROPERTY_MYFLOAT32PROP2                    = 0x5000000E;
		public const uint PROPERTY_MYDATETIMEPROP1                   = 0x70000006;
		public const uint PROPERTY_MYDATETIMEPROP2                   = 0x70000011;
		public const uint PROPERTY_MYINT64PROP3                      = 0x20000012;
		public const uint PROPERTY_MYINT64PROP4                      = 0x20000013;
		public const uint PROPERTY_MYINT64PROP5                      = 0x20000014;
		public const uint PROPERTY_MYINT64PROP6                      = 0x20000015;
		public const uint PROPERTY_MYINT64PROP7                      = 0x20000016;
		public const uint PROPERTY_MYINT64PROP8                      = 0x20000017;
		public const uint PROPERTY_MYINT64PROP9                      = 0x20000018;
		public const uint PROPERTY_MYINT64PROP10                     = 0x20000019;
		public const uint PROPERTY_MYINT64PROP11                     = 0x2000001a;
		public const uint PROPERTY_MYINT64PROP12                     = 0x2000001b;
		public const uint PROPERTY_MYINT64PROP13                     = 0x2000001c;
		public const uint PROPERTY_MYINT64PROP14                     = 0x2000001d;
		public const uint PROPERTY_MYINT64PROP15                     = 0x2000001e;
		public const uint PROPERTY_MYINT64PROP16                     = 0x2000001f;
		public const uint PROPERTY_MYINT64PROP17                     = 0x20000020;
		public const uint PROPERTY_MYINT64PROP18                     = 0x20000021;
		public const uint PROPERTY_MYINT64PROP19                     = 0x20000022;
		public const uint PROPERTY_MYINT64PROP20                     = 0x20000023;
		public const uint PROPERTY_MYINT64PROP21                     = 0x20000024;
		public const uint PROPERTY_MYINT64PROP22                     = 0x20000025;
		public const uint PROPERTY_MYINT64PROP23                     = 0x20000026;
		public const uint PROPERTY_MYINT64PROP24                     = 0x20000027;
		public const uint PROPERTY_MYINT64PROP25                     = 0x20000028;
		public const uint PROPERTY_MYINT64PROP26                     = 0x20000029;
		public const uint PROPERTY_MYINT64PROP27                     = 0x2000002a;
		public const uint PROPERTY_MYINT64PROP28                     = 0x2000002b;
		public const uint PROPERTY_MYINT64PROP29                     = 0x2000002c;
		public const uint PROPERTY_MYINT64PROP30                     = 0x2000002d;
		public const uint PROPERTY_MYINT64PROP31                     = 0x2000002e;
		public const uint PROPERTY_MYINT64PROP32                     = 0x2000002f;
		public const uint PROPERTY_MYINT64PROP33                     = 0x20000030;
		public const uint PROPERTY_MYINT64PROP34                     = 0x20000031;
		public const uint PROPERTY_MYINT64PROP35                     = 0x20000032;
		public const uint PROPERTY_MYINT64PROP36                     = 0x20000033;
		public const uint PROPERTY_MYINT64PROP37                     = 0x20000034;
                public const uint PROPERTY_MYINT64PROP38                     = 0x20000035;
		public const uint PROPERTY_MYINT64PROP39                     = 0x20000036;
		public const uint PROPERTY_MYINT64PROP40                     = 0x20000037;
		public const uint PROPERTY_MYINT64PROP41                     = 0x20000038; //this is the
                                                                                           //last one in xlast

		public const uint PROPERTY_MYINT64PROP42                     = 0x20000039;
		public const uint PROPERTY_MYINT64PROP43                     = 0x2000003a;
		public const uint PROPERTY_MYINT64PROP44                     = 0x2000003b;
		public const uint PROPERTY_MYINT64PROP45                     = 0x2000003c;
		public const uint PROPERTY_MYINT64PROP46                     = 0x2000003d;
		public const uint PROPERTY_MYINT64PROP47                     = 0x2000003e;
		public const uint PROPERTY_MYINT64PROP48                     = 0x2000003f;
		public const uint PROPERTY_MYINT64PROP49                     = 0x20000040;
		public const uint PROPERTY_MYINT64PROP50                     = 0x20000041;
		public const uint PROPERTY_MYINT64PROP51                     = 0x20000042;
		public const uint PROPERTY_MYINT64PROP52                     = 0x20000043;
		public const uint PROPERTY_MYINT64PROP53                     = 0x20000044;
		public const uint PROPERTY_MYINT64PROP54                     = 0x20000045;
		public const uint PROPERTY_MYINT64PROP55                     = 0x20000046;
		public const uint PROPERTY_MYINT64PROP56                     = 0x20000047;
		public const uint PROPERTY_MYINT64PROP57                     = 0x20000048;
		public const uint PROPERTY_MYINT64PROP58                     = 0x20000049;
		public const uint PROPERTY_MYINT64PROP59                     = 0x2000004a;
		public const uint PROPERTY_MYINT64PROP60                     = 0x2000004b;
		public const uint PROPERTY_MYINT64PROP61                     = 0x2000004c;
		public const uint PROPERTY_MYINT64PROP62                     = 0x2000004d;
		public const uint PROPERTY_MYINT64PROP63                     = 0x2000004e;
		public const uint PROPERTY_MYINT64PROP64                     = 0x2000004f;
		public const uint PROPERTY_MYINT64PROP65                     = 0x20000050;
		public const uint PROPERTY_MYINT64PROP66                     = 0x20000051;
		public const uint PROPERTY_MYINT64PROP67                     = 0x20000052;
		public const uint PROPERTY_MYINT64PROP68                     = 0x20000053;
		public const uint PROPERTY_MYINT64PROP69                     = 0x20000054;
		public const uint PROPERTY_MYINT64PROP70                     = 0x20000055;
		public const uint PROPERTY_MYINT64PROP71                     = 0x20000056;
		public const uint PROPERTY_MYINT64PROP72                     = 0x20000057;
		public const uint PROPERTY_MYINT64PROP73                     = 0x20000058;
		public const uint PROPERTY_MYINT64PROP74                     = 0x20000059;

		public const uint XENON_TEST_NONEXIST_ATTRIBID               = 0x100000FF;

		// Property ids for XENON_TITLE2
		// the id is the same as xenon_title1: public const uint PROPERTY_MYINT32PROP1                      = 0x10000002;
		public const uint PROPERTY_MYFLOAT32PROP1_XENON_TITLE2       = 0x50000004;
		public const uint PROPERTY_MYDATETIMEPROP1_XENON_TITLE2      = 0x70000003;

		// Matchmaking queries for xenon title 1
		public const uint SESSION_MATCH_QUERY_QUERY1                    = 0;
		public const uint SESSION_MATCH_QUERY_NOPARAMQUERY              = 1;
		public const uint SESSION_MATCH_QUERY_RETURNSTRINGFIRST         = 2;
		public const uint SESSION_MATCH_QUERY_RETURNSTRINGLAST          = 3;
		public const uint SESSION_MATCH_QUERY_CONTEXTVALUEINFILTER      = 4;
		public const uint SESSION_MATCH_QUERY_FUZZYMATCHSAMETYPE        = 5;
		public const uint SESSION_MATCH_QUERY_NOCUSTRETURN              = 6;
		public const uint SESSION_MATCH_QUERY_STRINGATTRIBQUERY         = 7;
		public const uint SESSION_MATCH_QUERY_FUZZYMATCHCROSSTYPE       = 8;
		public const uint SESSION_MATCH_QUERY_FUZZYMATCHDATETIME        = 9;
		public const uint SESSION_MATCH_QUERY_CROSSTYPEFILTER           = 10;
		public const uint SESSION_MATCH_QUERY_FUZZYMATCHMULTISORT       = 11;
		public const uint SESSION_MATCH_QUERY_SOCIALMATCHQUERY1	        = 12;
		public const uint SESSION_MATCH_QUERY_QUERYSORTNOTINRETURN      = 13;
		public const uint SESSION_MATCH_QUERY_CONSTANTVALUEINFILTER     = 14;
		public const uint SESSION_MATCH_QUERY_MAXPARAMS                 = 15;
                public const uint SESSION_MATCH_QUERY_QUERY1WITHGAMERPUID       = 16;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_3INT64_WEIGHTS   = 17;
                //In this next query,2 weighted int32s, 21 int 64s, and all the allowed system attribs
                public const uint SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY    = 18; 
                public const uint SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS      = 19;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES=20;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_INTS_BINARY      = 21;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_ILLEGAL_DATETIME = 22;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_FILTER_AND_PARAM = 23;
                public const uint SESSION_MATCH_QUERY_WEIGHTED_WITH_NORMAL_SORT = 24;
                public const uint SESSION_MATCH_QUERY_OMAHA_USE_CASE            = 25;
                public const uint SESSION_MATCH_QUERY_DEMO                      = 26;
            


		// for xenon title 2
		public const uint SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB = 1;
		public const uint SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB = 2;
		public const uint SESSION_MATCH_QUERY_RANKEDMATCHWITHTITLEDEFINEDSORT	 = 3;


            
	}

    public class MatchUtil
    {
        public static RandomEx RandomGen = new RandomEx();

        public static string ErrMsgFromXRLPayload(string prepend, XRLPayload xrlPayload)
        {
            return (prepend + " [HTTP Status: " + xrlPayload.xAct.httpStatus +
                             ", XErr: " + Global.XErrToString(xrlPayload.XErr) + "]");
        }

        /// <summary>
        /// SQL statement template for determining if a session exists in a particular table
        /// </summary>
        private const string verifySessionExistsCmd =
            @"SELECT count(*) FROM [XMatch].[dbo].[__TABLE_NAME__] where bi_session_id = 0x__SESSION_ID__";


        //convert type, mode, and RRID to a bucketid.
        public static int ConvertToBucketId(long type, long mode, long RRID) {
            //type is bits 23-16
            type = type & 0xFF;  //take eight bits each
            mode = mode & 0xFF;
            RRID = RRID & 0xFF;
            return (int) ((type << 16) | (mode << 8) | RRID);
        }

        //retrieve a certain number of bits from a long.  bits are measured from least significant
        //to most significant, and start from zero.  i.e. calling with 0,3 would be the equivalent
        //of returning a mask of 0x000...000F.  calling with 3,3 would return the third bit, or a
        //mask of 0xA.  Calling with 0,63 would return the number unchanged.
        public static long GetBits(long number, int start, int end) {
            long ans;
            if (end < start) {
                Global.RO.Warn("GetBits called with end < start!");
                return 0;
            } else {
                ans = number << 63 - end;
                ans = ans >> (63 - end) + start;
            }
            return ans;
        }

        public static uint ByteArrayToUInt(byte[] src)
        {
            uint dest = 0;
            for (int i = 3; i >= 0; i--)
            {
                dest <<= 8;
                dest += src[i];
            }
            return dest;
        }

        public static ulong ByteArrayToULong(byte[] src)
        {
            ulong dest = 0;
            for (int i = 7; i >= 0; i--)
            {
                dest <<= 8;
                dest += src[i];
            }
            return dest;
        }

        public static void SetSGInfo_OLD(XRLPayload payload, CSGInfo.ClientType defaultClientType, 
            uint dwTitleID, XRLxnaddr hostAddr)
        {
            if (!payload.ManualSlotSetup)
            {
                payload.ManualPopulateSlot();
                if (payload.Slot.machinePuid == CSGInfo.DefaultMachineId)
                {
                    payload.Slot.SetClientType(defaultClientType);
                }
                payload.Slot.titleId = dwTitleID;
                payload.Slot.AddService(XOService.Matchmaking);
                if (hostAddr != null)
                {
                    payload.Slot.ipaI = ByteArrayToUInt(hostAddr.inaOnline);
                    SGADDR sgAddr = new SGADDR(hostAddr.abOnline);
                    sgAddr.qwXboxID = payload.Slot.machinePuid;
                    hostAddr.abOnline = sgAddr.toByteArray();
                }
            }
        }

        public static void SetSGInfo(XRLPayload payload, CSGInfo.ClientType defaultClientType,
            uint dwTitleID, XRLxnaddr hostAddr)
        {
            if (!payload.ManualSlotSetup)
            {
                payload.ManualPopulateSlot();
                payload.Slot.titleId = dwTitleID;
                payload.Slot.AddService(XOService.Matchmaking);
                if (hostAddr != null)
                {
                    if (payload.Slot.machinePuid == CSGInfo.DefaultMachineId)
                    {
                        SGADDR sgAddr = new SGADDR(hostAddr.abOnline);
                        payload.Slot.machinePuid = sgAddr.qwXboxID;
                        payload.Slot.SetClientType(defaultClientType);
                    }
                    payload.Slot.ipaI = ByteArrayToUInt(hostAddr.inaOnline);
                }
                else if (payload.Slot.machinePuid == CSGInfo.DefaultMachineId)
                {
                    payload.Slot.SetClientType(defaultClientType);
                }
            }
        }

        public static WireData GetAttributeById(WireData []attrs, uint attributeId)
        {
            WireData attr = null;

            for(int i = 0; null == attr && i < attrs.Length; i++)
            {
                WireData wd = attrs[i];
                if(typeof(XRLIntAttribute) == wd.GetType())
                {
                    if(attributeId == ((XRLIntAttribute)wd).AttributeID)
                    {
                        attr = wd;
                    }
                }
                else if(typeof(XRLStringAttribute) == wd.GetType())
                {
                    if(attributeId == ((XRLStringAttribute)wd).AttributeID)
                    {
                        attr = wd;
                    }
                }
                else if(typeof(XRLBlobAttribute) == wd.GetType())
                {
                    if(attributeId == ((XRLBlobAttribute)wd).AttributeID)
                    {
                        attr = wd;
                    }
                }
            }

            return attr;
        }

        public static bool IsRankedGameType(WireData[] attrs)
        {
            bool ranked = false;
            WireData gameTypeAttr = MatchUtil.GetAttributeById(attrs, Constants.X_ATTRIBUTE_GAME_TYPE);

            if(null != gameTypeAttr)
            {
                ranked = (gameTypeAttr as XRLXeIntValue).intValue == Constants.X_ATTRIBUTE_GAME_TYPE_RANKED;
            }

            return ranked;
        }

        /// <summary>
        /// Calculate a set of offsets given a base message size and collection of attributes.
        /// The total message size is and offset collection are returned as out parameters.
        /// </summary>
        public static void CalculateOffsets(uint baseSize, XrlAttributeBase[] attrs, out uint[] offsets, out uint messageLength)
        {
            if (attrs == null) {
                offsets = null;
                messageLength = baseSize;
                return;
            }
            offsets = new uint[attrs.Length];
            messageLength = (uint)(baseSize + (attrs.Length * 4));

            uint offsetIndex = 0;

            foreach (XrlAttributeBase attr in attrs)
            {
                offsets[offsetIndex++] = messageLength;
                messageLength += attr.CalculateSize();
            }
        }

        //This should end up being called if schema version is > 5.3.
        public static void CalculateSearchOffsets(uint baseSize, XrlAttributeBase[] attrs, XrlAttributeBase [] weightedAttrs,
                                                  out uint[] offsets, out uint[] weightedOffsets, out uint messageLength)
        {
            CalculateOffsets(baseSize, attrs, out offsets, out messageLength);
            if (weightedAttrs == null) {
                weightedOffsets = null;
                messageLength += 4; // add 4 for the offsets length.
                return;
            }


            weightedOffsets = new uint[weightedAttrs.Length];
            if (weightedOffsets.Length > 0) {
                weightedOffsets[0] = 0;  //the first offset is always 0.
            }
            //messageLength is now the message prior to any of the weighted offset data.  Now add
            //those on.
            messageLength += (uint)(4 + (4 * weightedAttrs.Length)); //add 4 bytes for the offsets length, plus 4 for each weighted search offset.
            uint offsetIndex = 0;
            foreach (XrlAttributeBase attr in weightedAttrs)
            {
                weightedOffsets[offsetIndex++] = messageLength; //offset 0 is always 0, offset 1 is
                messageLength += attr.CalculateSize();          //where attr 0 has ended.
            }
        }
/*
        public static SGADDR CreateRandomSGADDR()
        {
            SGADDR sgAddr = new SGADDR();
            RandomGen.NextBytes(sgAddr.inaSg);
            sgAddr.dwSpiSg = (uint)RandomGen.Next();
            sgAddr.qwXboxID = RandomGen.NextUlong();
            //sgAddr.abReserved;  // Reserved (must be zero)
            return sgAddr;
        }
*/      

        //Creates a Xenon XNADDR.
        public static XRLxnaddr CreateRandomXNADDR()
        {
            XRLxnaddr xnaddr = new XRLxnaddr();
            xnaddr.ina = new byte[4];
            xnaddr.inaOnline = new byte[4];
            xnaddr.abEnet = new byte[6];
            xnaddr.abOnline = new byte[20];

            RandomGen.NextBytes(xnaddr.ina);
            RandomGen.NextBytes(xnaddr.inaOnline);
            xnaddr.wPortOnline = (ushort)RandomGen.Next(Int32.MinValue, Int32.MaxValue);
            RandomGen.NextBytes(xnaddr.abEnet);
            xnaddr.abOnline = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();  //create all
                                                                                   //xenon at the moment. 
            return (xnaddr);
        }

        //Creates a new set of attributes with any of the given type filtered out.
        public static XRLXeAttribParam[] FilterOutAttribs(XRLXeAttribParam [] attribs, uint type) {
            ArrayList ans = new ArrayList();
            foreach (XRLXeAttribParam attrib in attribs) {
                if (attrib.attribParamID != type) {
                    ans.Add(attrib);
                }
            }
            return (XRLXeAttribParam []) (ans.ToArray(typeof(XRLXeAttribParam)));
        }

        //This method allows us to override DefaultConfig with Xblob, if we need to.  This is a
        //super-nasty hack, but it's required until we add Xblob as a webstore config.
        public static string GetNpdbEnvironment() {
            if ((Global.CurrentEnvironment.Environment).Equals("DefaultConfig")) {
                return "Xblob";
            }
            return Global.CurrentEnvironment.Environment;
        }


        //Verify this session exists via a direct SQL query.  Use t_match_titles to grab the
        //server(s) the session can exist on.  This will *not* work with partitioning
        static public bool VerifySessionExists(uint titleId, long sessionId)
        {
            MatchTitle matchTitle = MatchTitleMgr.GetMatchTitle(titleId);
            return VerifySessionExists(matchTitle.DbList.Split(';'), titleId, sessionId);
        }

        //Verify this session exists via a direct SQL query.  Use t_match_titles to grab the
        //server(s) the session can exist on.  This will *not* work with partitioning.
        static public bool VerifySessionExists(string[] dbList, uint titleId, long sessionId)
        {
            bool exists = false;
            foreach (string serverName in dbList)
            {
                XMatch xmatch = new XMatch();
                xmatch.ConnectToServer(serverName);
                string tables = xmatch.GetMatchTables((uint)titleId);
                foreach (string table in tables.Split(','))
                {
                    string sql = verifySessionExistsCmd.Trim();
                    sql = sql.Replace("__TABLE_NAME__", table);
                    sql = sql.Replace("__SESSION_ID__", sessionId.ToString("X"));
                    int count = (int)xmatch.ExecuteScalar(sql);
                    if (count != 0)
                    {
                        exists = true;
                    }
                }
                xmatch.Close();
            }
            return exists;
        }

        //Create a MatchQuery or MatchVerify object to put these in?
        //search by direct ID
        public static void FindExistingSessionByID(MatchSession session, out XRL2SearchResults searchResults) {
            XRL2SearchSession searchReq = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);
            XRLXeAttribParam[] Params = new XRLXeAttribParam[1] {
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                                     new XRLXeIntValue(session.GetSessionID())) };
            searchReq.AddParams(Params);
            searchReq.baseSearchSession.dwTitleID = session.TitleID;
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                throw new Exception("search for the newly created session failed:" + Global.XErrToString(searchReq.XErr));
            }
        }

        //search by query.  The goal of this is to use all the attributes in the session in an
        //attempt to find just that one.  For it to work, we should leave a unique attribute in the session.
        public static void FindExistingSessionByAllAttribs(MatchSession testSession,
                                                         out XRL2SearchResults searchResults) {
            //create a search designed to find our session.
            XRL2SearchSession searchReq = testSession.CreateSearchSession(Constants.SESSION_MATCH_QUERY_QUERY1);
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                throw new Exception("Find by query failed with error:" + Global.XErrToString(searchReq.XErr));
            }
        }


        //this is for use for breadcrumbStates.
        public enum RowState {
            ORIGINAL_ROW = 1,     //this means this is the master row.  The lock is stored
            //here.  This is a "same bucket, same server" and "different
            //bucket, different server" situation.

            SANDWICH_ROW = 2,     //This means this is a session that has moved buckets and is on
            //a different server.  It is pointed to by its master row.

            DIFF_BUCKET_SAME_SERVER_ROW = 3   //This means this is a session where the sandwich would exist,
            //but it happens to be on the same server as the original
            //row.  i.e. "different bucket, same server".  
        }

        public class SessionDBData {
            public SessionID sessID;
            public int sw_bucket;
            public int breadcrumbState;
            public bool isDeleted;



            public override string ToString() {
                string ans = "DBData--sessID:" + sessID.ToString();
                ans += "   sw_bucket:" + sw_bucket;
                ans += "   breadcrumbState:" + breadcrumbState;
                ans += "   isDeleted:" + isDeleted;
                return ans;
            }
        }
        
        //return a unique set of the servers this title relies on.
        public static ArrayList GetAllSqlServersForThisTitle(uint titleID) {
            InterfaceBucketCollection buckets = GetAllMatchBucketsForThisTitle(titleID);
            Hashtable servernames = new Hashtable();
            //put all the servers involved into a hashtable.
            foreach (InterfaceBucket bucket in buckets) {
                servernames[bucket.Server] = 1;
                servernames[bucket.NextServer] = 1;
            }

            ArrayList ans = new ArrayList();
            foreach (string server in servernames.Keys) {
                ans.Add(server);
            }
            return ans;
        }

        //return all the match buckets for this title.
        public static InterfaceBucketCollection GetAllMatchBucketsForThisTitle(uint titleID) {
            Npdb npdbHandle = new Npdb();
            npdbHandle.ConnectToServer();
            InterfaceBucketCollection allBuckets = npdbHandle.GetInterfaceBuckets(titleID, GetNpdbEnvironment());
            npdbHandle.Close();

            if (allBuckets.Count == 0) {
                Global.RO.Warn("Warning!  No buckets found for " + titleID.ToString("X") + " in " + GetNpdbEnvironment() + 
                               ".  Check title and ensure environment name matches the environment in t_interface_buckets!");
            }

            InterfaceBucketCollection matchBuckets = new InterfaceBucketCollection();
            foreach(InterfaceBucket bucket in allBuckets) {
                if (bucket.Interface.Equals("xmatch")) {
                    matchBuckets.Add(bucket);
                }
            }
            return matchBuckets;
        }

        //Return all the buckets for a specific mode and type for the title.
        public static InterfaceBucketCollection GetMatchBucketsForModeAndType(uint titleID, uint type, uint mode) {
            InterfaceBucketCollection buckets = GetAllMatchBucketsForThisTitle(titleID);
            int baseBucketID = ConvertToBucketId(type, mode, 0);  //all target buckets should match
                                                                  //this, minus the RRID.
            InterfaceBucketCollection answer = new InterfaceBucketCollection();
            foreach (InterfaceBucket bucket in buckets) {
                if ((bucket.Bucket & 0xFFFF00) == baseBucketID) { //compare non RRID parts.
                    answer.Add(bucket);
                }
            }
            return answer;
        }

        //Get a bucket, given its ID and title.  Not the most efficient, but gets the job done.
        public static InterfaceBucket GetInterfaceBucketFromId(uint titleID, int bucketIDToFind) {
            InterfaceBucketCollection buckets = GetAllMatchBucketsForThisTitle(titleID);
            foreach (InterfaceBucket bucket in buckets) {
                if (bucket.Bucket == bucketIDToFind) return bucket;
            }
            return null;
        }


        //given a session and a collection of possible buckets, see if the session is on any of
        //these servers.  Returns null if it's on none of them.  The purpose of this method is for
        //round-robined servers, to see where the server actually is, and should only be used for
        //looking by query.  For migrating round-robined servers, we need to poke both the server
        //and the next server.
        //
        //We'll need to look for two items.  First priority is a breadcrumbstate != 1--a
        //sandwich.  If that's present, we know that's the right one and we return it.  If not, then
        //a breadcrumbState 1 among these servers--that means it's an un-breadcrumbed session.  If
        //neither of those are present, fail and return null.
        //
        //TODO:if by some terrible misfortune, we're trying to find-by-query and the two buckets are on
        //the same server, we have no way to determinte what bucket it's on.  in that case we have
        //no choice but to trust i_sw_bucket in the breadcrumb row.
        private static InterfaceBucket FindActualServerByDBPoking(MatchSession session, InterfaceBucketCollection matches) {
//            InterfaceBucket nonOriginalRowBucket = null; //we'll take the non-original-row bucket if
                                                         //we find it--this guarantees it's the one
                                                         //we findByQuery.

            InterfaceBucket originalRowBucket = null;    //if there aren't any others, return this one.
                                                         //This means the findByQuery may point to the
                                                         //original row after all.            
            
            foreach (InterfaceBucket bucket in matches) {
                SessionDBData data = QueryDBForSessionData(bucket.Server, session);
                if ((data != null) && (!data.isDeleted)) {
                    if (data.breadcrumbState != (int) RowState.ORIGINAL_ROW) {
                        return bucket;
                    } else {
                        originalRowBucket = bucket;
                    }
                }

                //skip out if we're not migrating
                if ((bucket.Server == bucket.NextServer) || (bucket.MigrationStart.CompareTo(DateTime.Now) > 0)) continue;

                //otherwise check the migrating-to server too
                data = QueryDBForSessionData(bucket.NextServer, session);
                if ((data != null) && (!data.isDeleted)) {
                    if (data.breadcrumbState != (int) RowState.ORIGINAL_ROW) {
                        return bucket;
                    } else {
                        originalRowBucket = bucket;                        
                    }
                }
            }

            if (originalRowBucket != null) {
                return originalRowBucket;
            } else {
                Global.RO.Error("FindActualServerByDBPoking:Could not find session " + session.GetSessionID() + 
                                " on any of the buckets for its type/mode!  If during findbyquery, session not findable!");
                return null;
            }
        }

        //Return the interface bucket for this session.  For useSessionID is false, there is a case
        //of round-robining where more than one bucket may apply.  There is no way to find the
        //server without 1)relying on the breadcrumb, or 2)poking the database.
        //In the case of multiple matches, this method will poke each of the buckets to see if the
        //session is there, and will then return the matching bucket.  The performance loss is okay,
        //given that this is a special case scenario.  In addition, returning multiple buckets would
        //not suffice, because we need to know the exact server--it could be breadcrumbed or not
        //depending on this information.
        //
        //This does create an element of circularity when verifying partition info, but it can't be
        //helped for the specific case of round-robined sessions.
        public static InterfaceBucket FindInterfaceBucketForSession(MatchSession session, bool useSessionID) {
            Npdb npdbHandle = new Npdb();
            npdbHandle.ConnectToServer();
            InterfaceBucketCollection buckets = npdbHandle.GetInterfaceBuckets(session.TitleID, GetNpdbEnvironment());
            npdbHandle.Close();

            long sessionType = (long) GetBits(session.GetSessionID(), 8,9);
            long sessionMode;
            long sessionRRID;
            if (useSessionID) {
                sessionMode = (long) GetBits(session.GetSessionID(), 10,15);
                sessionRRID = (long) GetBits(session.GetSessionID(), 0,3);
            } else {
                sessionMode = session.GetSessionMode();
                sessionRRID = -1;  //we cannot tell, for a session, which round-robined server it
                                   //will be on
            }
            
            InterfaceBucketCollection matches = new InterfaceBucketCollection();

            //in one case, we just cycle through the buckets looking for a match.
            if (useSessionID) {
                foreach (InterfaceBucket bucket in buckets) {
                    if (bucket.Interface != "xmatch") continue;
/*                Global.RO.Info("Searching bucket:" + (long) GetBits(bucket.Bucket, 16, 23) + 
                  "  mode:" + (long) GetBits(bucket.Bucket, 8, 15) + 
                  "  RRID:" + (long) GetBits(bucket.Bucket, 0, 7)); */
                    if ( (sessionType == (long) GetBits(bucket.Bucket, 16, 23)) && //type
                         (sessionMode == (long) GetBits(bucket.Bucket, 8, 15)) && //mode
                         (sessionRRID == (long) GetBits(bucket.Bucket, 0, 7)))  //RRID
                        return bucket;
                }
                //TO FIX!  Brandenburg has changed the way we get interface buckets.  Look into this!
//                Global.RO.Warn("No matching bucket found for session " + session.GetSessionID().ToString() + 
//                               " when searching by sessionID!");
//                Global.RO.Warn("looking for type:" + sessionType + 
//                               "  mode:" + sessionMode + 
//                               "  RRID:" + sessionRRID);
                return null;
            } else {
                //in this one, we poke each of the servers, provided there are more than one.
                foreach (InterfaceBucket bucket in buckets) {
                    if (bucket.Interface != "xmatch") continue;
                    if ( (sessionType == (long) GetBits(bucket.Bucket, 16, 23)) && //type
                         (sessionMode == (long) GetBits(bucket.Bucket, 8, 15)))
                        matches.Add(bucket);
                }
                if (matches.Count == 0) {
                //TO FIX!  Brandenburg has changed the way we get interface buckets.  Look into this!
//                    Global.RO.Warn("No matching bucket found for session " + session.GetSessionID().ToString() + 
//                                   " when searching by mode/type!");
//                    Global.RO.Warn("looking for type:" + sessionType + 
//                                   "  mode:" + sessionMode + 
//                                   "  RRID:any");
                    return null;
                } else if (matches.Count == 1) {
                    return matches[0]; //return just the one we've got
                } else {
                    //OLD:we must be in a round-robined case.  Look through each of the RRs for where
                    //the session actually is.
                    //return FindActualServerByDBPoking(session, matches);

                    //NEW:the poking doesn't work if the buckets are on the same server.  Instead we're
                    //going to return the server that the original bucket *thinks* the sandwich
                    //should be on.

                    //this is inefficient--but it guarantees we don't depend on those calling us
                    InterfaceBucket breadcrumbBucket = FindInterfaceBucketForSession(session, true);

                    SessionDBData breadcrumbRow = QueryDBForSessionData(breadcrumbBucket.NextServer, session);
                    //if migrating, let's check the old server.
                    if ((breadcrumbRow == null) && (breadcrumbBucket.Server != breadcrumbBucket.NextServer)) {
                        breadcrumbRow = QueryDBForSessionData(breadcrumbBucket.Server, session);
                    }
                    //alright, if the row's still not around, that's a problem.
                    if (breadcrumbRow == null) {
                        Global.RO.Error("Could not use breadcrumb row to find sandwich row, because breacrumb row is missing!");
                        return null;
                    }
                    //if the breadcrumb bucket is null, set the sandwich bucket to equal the
                    //breadcrumb bucket.
                    if (breadcrumbRow.sw_bucket == -1) return breadcrumbBucket; 
                    InterfaceBucket sandwichBucket = GetInterfaceBucketFromId(session.TitleID, breadcrumbRow.sw_bucket);
                    return sandwichBucket;
                }
            }
        }

        //returns, according to the migration rules, which server is the active one in an InterfaceBucket.
        public static string SelectServerFromBucket(InterfaceBucket bucket) {
            if (bucket == null) return "";
            if (bucket.MigrationStart.CompareTo(DateTime.Now) <= 0) {
                return bucket.NextServer;
            } else {
                return bucket.Server;
            }
        }

        //Call the above session, but return a server instead of the bucket.
        public static string FindServerForSession(MatchSession session, bool useSessionID) {
            InterfaceBucket bucket = FindInterfaceBucketForSession(session, useSessionID);
            return SelectServerFromBucket(bucket);
        }

        //Find all the servers this session should be on.  This is one if non-breadcrumbed, and two
        //if it is breadcrumbed.
        public static string [] FindServersForSession(MatchSession session) {
            string origServer = FindInterfaceBucketForSession(session, true).Server;
            string secondServer = FindInterfaceBucketForSession(session, false).Server;
            if (origServer == "") {
                return null;
            }
            if (origServer == secondServer) {
                string [] ans = new string[1];
                ans[0] = origServer;
                return ans;
            } else {
                string [] ans = new string[2];
                ans[0] = origServer;
                ans[1] = secondServer;
                return ans;
            }
        }

        //given a session and an attribute, retrieve the value of that attribute.  Since the data
        //type varies, the caller will be given an SqlDataReader and asked to parse.  Note that when
        //finished, the caller MUST CLOSE the returned Xmatch handle.
        public static SqlDataReader QueryDBForAttribute(XMatch xmatchHandle, MatchSession session, uint attribute) {
            string sql = "select att_0x" + attribute.ToString("X") + " from t_match_sessions_0x" + 
                session.TitleID.ToString("X") + "_" + (session.IsRanked() ? "ranked" : "standard") +
                " where bi_session_id = " + session.GetSessionID();
            SqlDataReader reader;
            xmatchHandle.ReadData(sql, out reader);
            return reader;
        }

        //Given a server and a sessionID, return the SessionDBData for that sessionID.  If the
        //session isn't present, return null.
        public static SessionDBData QueryDBForSessionData(string server, MatchSession session) {
            //generate the sql

            string sql = "select bi_session_id, i_sw_bucket, ti_breadcrumb_state, dt_deletion_time from t_match_sessions_0x" + 
                session.TitleID.ToString("X") + "_" + (session.IsRanked() ? "ranked" : "standard") + 
                " where bi_session_id = " + session.GetSessionID();
/*
            string sql = "select bi_session_id, vc_current_server, ti_breadcrumb_state,  " +
                "from t_match_sessions_0x" + session.TitleID.ToString("X") + "_" + (session.IsRanked() ? "ranked" : "standard") +
                " where bi_session_id = " + session.GetSessionID();
*/
//            Global.RO.Info("Executing sql on server " + server + ":" + sql);
            //execute
            XMatch xmatchHandle = new XMatch();
            xmatchHandle.ConnectToServer(server);
            SqlDataReader reader;
            xmatchHandle.ReadData(sql, out reader);

            //parse
            SessionDBData ans = null;
            if (reader.Read()) {
                ans = new SessionDBData();
                ans.sessID = new SessionID((long) reader.GetInt64(0));
                if (reader.IsDBNull(1)) {
                    ans.sw_bucket = -1;
                } else {
                    ans.sw_bucket = reader.GetInt32(1);
                }
                ans.breadcrumbState = (int) reader.GetSqlByte(2);
                ans.isDeleted = !(reader.IsDBNull(3)); //is deleted if the date != null.
            }
            xmatchHandle.Close();

            return ans;
        }

        //poke a database for a match session.  Normally FindbyID and find by query will be
        //sufficient, but this allows us to verify that a breadcrumb *really* exists or not.
        //Returns information on that row.  In the future this can be modified to return more data.
        //The flag determines if we use the SessionID or the mode.  For non-breadcrumbed sessions
        //they are the same.  But breadcrumbed sessions, using the sessionID returns the breadcrumb,
        //whereas using the mode returns the sandwich.
        public static SessionDBData FindSessionByDirectDBQuery(MatchSession session, bool useSessionID) {
            //find the DB we should hit.
            string servername = FindServerForSession(session, useSessionID);
            if (servername == "") {
                throw new Exception("No server found for a session of this type!  Error in either configuration of " +
                                    "t_interface_buckets or sessionID generation!");
            }
            return QueryDBForSessionData(servername, session);
        }

        //here, we check to ensure there is no session like the testSession by both search-by-ID and
        //search-by-query.  This should work for sessions that are even in the delayed-delete state.
        public static bool VerifySessionNotPresent(MatchSession testSession) {
            XRL2SearchResults searchResults;
            bool success = true;
            FindExistingSessionByID(testSession, out searchResults);
            if (searchResults != null) {
                Global.RO.Error("Session " + testSession.GetSessionID() + 
                                " found when searching by ID, when session should not be present!");
                success = false;
            }
            FindExistingSessionByAllAttribs(testSession, out searchResults);
            if (searchResults != null) {
                //since queries can bring many results, loop through and ensure our sessionID is not
                //among those returned
                foreach (XRL2SingleSearchResult result in searchResults.results) {
                    if ((Constants.sessionIDConvert(result.SessionID) == //match sessionID
                         testSession.GetSessionID())) { 
                        Global.RO.Error("Session " + testSession.GetSessionID() + 
                                        " found when searching by query, when session should not be present!");
                        success = false;
                    }
                }
            }
            return success;
        }

        //Verify that there is absolutely no trace of the session in the database.  This should be
        //true after a session has expired, or has been deleted and is past the delete state.
        public static bool VerifySessionNotInDB(MatchSession testSession) {
            bool success = true;
            if (FindSessionByDirectDBQuery(testSession, false) != null) {
                Global.RO.Error("Session " + testSession.GetSessionID() + 
                                " found when searching by sql(on the server pointed to by mode attribute), " + 
                                "when session should not be present!");
                success = false;
            }
            if (FindSessionByDirectDBQuery(testSession, true) != null) {
                Global.RO.Error("Session " + testSession.GetSessionID() + 
                                " found when searching by sql(on the server pointed to be Session ID), " + 
                                "when session should not be present!");
                success = false;
            }
            return success;
        }

        //Retrieve the session via a search, using the sessionID, and ensure it verifies against the
        //MatchSession's variables.
        public static bool VerifySearchByID(MatchSession testSession) {
            XRL2SearchResults searchResults;
            FindExistingSessionByID(testSession, out searchResults);
            if (searchResults == null) {
                Global.RO.Error("Error!  No matching session found!  Was expecting sessionID " + testSession.GetSessionID());
                return false;
            }
            if (!testSession.Verify(searchResults)) {
                Global.RO.Error("Session values for session " + testSession.GetSessionID() + " are different than expected!");
                return false;
            }
            return true;
        }
        
        //run a search and print out just the sessionIDs returned.  This allows a debugger to
        //re-execute searches easily.
        private static string DebugExecuteSearch(MatchSession testSession) {
            XRL2SearchResults searchResults;
            FindExistingSessionByAllAttribs(testSession, out searchResults);
            if (searchResults == null) {
                return "";
            }

            string sessionIDsFound = "";
            foreach (XRL2SingleSearchResult result in searchResults.results) {
                sessionIDsFound += " 0x" + Constants.sessionIDConvert(result.SessionID).ToString("X");
            }
            return sessionIDsFound;
        }

        //default to expecting a single call, and erroring on failures.
        public static bool VerifySearchByQuery(MatchSession testSession) {
            return VerifySearchByQuery(testSession, false);
        }

        //Retrieve the session via a search using attributes.  This is a different codepath than by
        //ID.  For now verify we get the SessionID that we expect(custom queries provide varying
        //numbers of attributes back, and we can't leverage existing verify code for that.
        //note this may still have issues if we have too many sessions and the query won't return
        //them all.
        //
        //Quiet retries suppresses output of "not-finding the session", so it can be called multiple
        //times without spew.  Specifically for round-robining calls.
        public static bool VerifySearchByQuery(MatchSession testSession, bool quietRetries) {
            XRL2SearchResults searchResults;
            FindExistingSessionByAllAttribs(testSession, out searchResults);

            //if we have no results...
            if (searchResults == null) {
                if (testSession.IsClosed()) {
                    return true;  //it's a good thing if we don't find it and the session's closed.
                }
                if (!quietRetries) Global.RO.Error("Error!  No matching session found!  Was expecting sessionID " + 
                                                   testSession.GetSessionID());
                return false;
            }

            //let's make sure we don't have more than the maxResults.  This should be an argument
            //passed in, but we know it's 50 because this is hardcoded into a constant in the XLAST
            //files..
            //ignoring for now
//            const int MAX_RESULTS = 50;
//            if (searchResults.results.Length > MAX_RESULTS) {
//                Global.RO.Error("Got " + searchResults.results.Length + 
//                                " results in search by query when max should be " + MAX_RESULTS + "!");
//                return false;
//            }

            //if we have lots of results...  first let's check to ensure we don't get
            //duplicates(which shouldn't happen during migrations)
            Hashtable uniqueChecker = new Hashtable();

            foreach (XRL2SingleSearchResult result in searchResults.results) {
                if (uniqueChecker.Contains(Constants.sessionIDConvert(result.SessionID))) {
                    Global.RO.Error("Error!  Found a session of ID 0x" + Constants.sessionIDConvert(result.SessionID).ToString("X") + 
                                    "multiple times in this search result!");
                    return false;
                } else {
                    uniqueChecker.Add(Constants.sessionIDConvert(result.SessionID), "found");
                }
            }


            //now let's check if the session's found.
            string sessionIDsFound = "";
            foreach (XRL2SingleSearchResult result in searchResults.results) {
                if ((Constants.sessionIDConvert(result.SessionID) == //match sessionID
                     testSession.GetSessionID())) {
                    return true;
                } else {
                    sessionIDsFound += " 0x" + Constants.sessionIDConvert(result.SessionID).ToString("X");
                }
            }
            
            //if we didn't find any that matched, that could be good if the session's closed.
            if (testSession.IsClosed()) {
                return true;
            } else {
                if (!quietRetries) Global.RO.Error("Expected sessionID " + testSession.GetSessionID().ToString() + 
                                                   " in search by query, " + "but received IDs:" + sessionIDsFound);
                return false;
            }
        }

        //Verify the breadcrumb and server information.  That is, ensure it's on the correct server
        //by querying the expected servers directly, and verify the breadcrumb states are as expected.
        public static bool VerifyServerAndPartitionInfo(MatchSession testSession) {
            string initialServer = testSession.GetServer();
            string currentServer = testSession.GetSandwichServer();
            //these variables are out here so they stay in scope if we toss an exception and need to debug.
            SessionDBData breadcrumbData;
            SessionDBData sandwichData;
            SessionDBData sessionData;

            //currently we store the server it should have moved to, and the server it was created
            //on.  When an update occurs we find those servers again.

            //we verify the breadcrumb states, plus the fact that the breadcrumb points to the
            //sandwich, if necessary.


            //now:


            //use initial server to find the original row.
            //if the current server is different, use the current server to find the current row.

            //if the current server is different, it's breadcrumbed--initial server is 1, current is
            //2, and the sw_bucket points from 1 to 2.
            //if they're the same, sw_bucket should be null or points to the current bucket.  We
            //should store buckets instead of servers.

            //find the sandwich row, if it exists
            //   2)find by query.  Compare buckets.  if the bucket is the same, 
            //        

            try {
                if (initialServer != currentServer) { //we're in a breadcrumb situation
                    //check the breadcrumb has state 1, current_server == second server.
                    breadcrumbData = QueryDBForSessionData(initialServer, testSession);
                    if (breadcrumbData == null) 
                        throw new ExpectedValueCheckException("Breadcrumb not found on " + initialServer + 
                                                              " with ID " + testSession.GetSessionID());
                    InterfaceBucket expectedSandwichBucket = GetInterfaceBucketFromId(testSession.TitleID, breadcrumbData.sw_bucket);
                    if ((currentServer != expectedSandwichBucket.Server) &&
                        (currentServer != expectedSandwichBucket.NextServer))
                        throw new ExpectedValueCheckException("Breadcrumb should contain pointer to current server:Got " +
                                                              currentServer + ", expecting " + expectedSandwichBucket.Server +
                                                              " or if migrating, possibly " + expectedSandwichBucket.NextServer);
                    ValueCheck.Test("Breadcrumb should contain breadcrumbState ", (int) RowState.ORIGINAL_ROW, breadcrumbData.breadcrumbState);
                    //check the sandwich has state 2, current_server == null.
                    sandwichData = QueryDBForSessionData(currentServer, testSession);
                    if (sandwichData == null) 
                        throw new ExpectedValueCheckException("Sandwich not found on " + currentServer + 
                                                              " with ID " + testSession.GetSessionID());
                    ValueCheck.Test("Sandwich should contain breadcrumbState ", (int) RowState.SANDWICH_ROW, sandwichData.breadcrumbState);
                } else {
                    //we're on the same server--check that the sw_bucket points to self.
                    sessionData = QueryDBForSessionData(initialServer, testSession);
                    if (sessionData == null) 
                        throw new ExpectedValueCheckException("Session not found on " + initialServer + 
                                                              " with ID " + testSession.GetSessionID());
                    
                    //so we're on the same server--but are we on the same bucket?  
                    if (testSession.GetBucket().Bucket == testSession.GetSandwichBucket().Bucket) {
                        //same bucket--we should see 1.
                        ValueCheck.Test("Session should have breadcrumbState ", (int) RowState.ORIGINAL_ROW, sessionData.breadcrumbState);
                        if ((sessionData.sw_bucket != -1) && (sessionData.sw_bucket != testSession.GetBucket().Bucket)) {
                            throw new ExpectedValueCheckException("i_sw_bucket is " + sessionData.sw_bucket + " but should be " + 
                                                                  testSession.GetBucket().Bucket + " for ID " + testSession.GetSessionID());
                        }
                    } else {
                        //different buckets--we should see 3
                        ValueCheck.Test("Session should have breadcrumbState ", 
                                        (int) RowState.DIFF_BUCKET_SAME_SERVER_ROW, sessionData.breadcrumbState);                        
                        if ((sessionData.sw_bucket != -1) && (sessionData.sw_bucket != testSession.GetSandwichBucket().Bucket)) {
                            throw new ExpectedValueCheckException("i_sw_bucket is " + sessionData.sw_bucket + " but should be " + 
                                                                  testSession.GetSandwichBucket().Bucket + " for ID " + testSession.GetSessionID());
                        }
                    }

/*
                    sessionData = QueryDBForSessionData(initialServer, testSession);
                    if (sessionData == null) 
                        throw new ExpectedValueCheckException("Session not found on " + initialServer + 
                                                              " with ID " + testSession.GetSessionID());
                    ValueCheck.Test("Session should have breadcrumbState 0", 0, sessionData.breadcrumbState);
//                    ValueCheck.Test("i_sw_bucket", -1, sessionData.sw_bucket);  //we might not
//                    care if it's nto breadcrumbed...
*/
                }
            } catch (ExpectedValueCheckException e) {
                Global.RO.Error("Error!  VerifyServerAndPartitionInfo fails with following message:" + e.Message);
                return false;
            }
            return true;
        }

        //hack--if the breadcrumbstate is broken, force it to be fixed here.  Should not be used
        //except in emergencies of blocking bugs.
/*
        public static void SetBreadcrumbState(MatchSession testSession, uint newState) {
            XMatch xmatchHandle = new XMatch();
            xmatchHandle.ConnectToServer(testSession.GetServer());
            string sql = "update t_match_sessions_0x" + 
                testSession.TitleID.ToString("X") + "_" + (testSession.IsRanked() ? "ranked" : "standard") +
                " set ti_breadcrumb_state = " + newState + " where bi_session_id = " + testSession.GetSessionID();
            xmatchHandle.IssueCommand(sql);
            xmatchHandle.Close();
        }
*/

        //Create a search and execute it, given the arguments passed in.
        public static XRL2SearchResults CustomSearch(uint titleID, CSGInfo.ClientType clientType, 
                                                     XRLXeAttribParam[] searchParams, uint spIndex)
        {
            XRL2SearchSession searchReq = CreateSearchRequest(titleID, clientType, searchParams, spIndex);
            return CustomSearch(searchReq);
        }

        //Create a search request and return it.  This allows you to create a request and make final
        //modifications before passing it into CustomSearch.
        public static XRL2SearchSession CreateSearchRequest(uint titleID, CSGInfo.ClientType clientType, 
                                                            XRLXeAttribParam[] searchParams, uint spIndex) {
            XRL2SearchSession searchReq = new XRL2SearchSession(true, spIndex);
            searchReq.baseSearchSession.dwTitleID = titleID;
            searchReq.Slot.SetClientType(clientType);
            if (searchParams != null)
            {
                searchReq.AddParams(searchParams);
            }
            return searchReq;
        }

        //Execute a pre-created your search request.
        public static XRL2SearchResults CustomSearch(XRL2SearchSession searchReq) {
            XRL2SearchResults searchResults;
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                throw new Exception(ErrMsgFromXRLPayload("SearchSession failed", searchReq));
            }
            return searchResults;
        }

        //Delete a session from the DB.
        public static bool DeleteSession(byte [] sessionID, uint titleID) {
            return DeleteSession(sessionID, titleID, FDTransaction.sReceiveTimeOut);
        }

        public static bool DeleteSession(byte[] sessionID, uint titleID, int timeout)
        {
            XRL2DeleteSession session = new XRL2DeleteSession(sessionID, titleID);
            session.xAct.ReceiveTimeOut = timeout;
            if (!session.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Session 0x" + Constants.sessionIDConvert(sessionID).ToString("X") + " failed to delete!");
                return false;
            }
            return true;
        }

        //Clean the table of all sessions.  Useful for starting fresh.  Perform this by a TRUNCATE
        //TABLE command issued directly to all sql servers this title is currently on.
        public static bool TruncateSessionsForTitle(uint titleID, SessionType type) {
            string tableToTruncate = "t_match_sessions_0x" + titleID.ToString("X") + "_" + 
                ((type == SessionType.Ranked) ? "ranked" : "standard");
            string command = "TRUNCATE TABLE " + tableToTruncate;

            TitleSqlServerSet servers = new TitleSqlServerSet(titleID);
            servers.IssueCommand(command);
            return true;
        }

    }


    //A class to handle forcefully, and temporarily setting the InterfaceBuckets of a title

    //A class to handle modifying the cross platform revoke switch, located in
    //npdb..t_match_titles.  It's meant to work on one title at a time.
    public class TitleCrossPlatformRevoker
    {
        private NpdbUtility npdb;
        private uint TitleId;
        private bool Locked = false;
        private byte? PreviousSetting;

        public void Revoke(uint titleId)
        {
            TitleId = titleId;
            MatchTitle thisTitle = MatchTitleMgr.GetMatchTitle(titleId);
            if (thisTitle == null) {
                Global.RO.Error("Title not found in NPDB!  Please ensure this title is propped.");
                throw new Exception("Title not found in NPDB when attempting to revoke cross platform privilege.");
            }
            PreviousSetting = thisTitle.RevokeCrossPlatform;

            npdb = new NpdbUtility();
            npdb.ConnectToServer();
            npdb.SetMatchTitleRevokeCrossPlatform(titleId, 1);
            Locked = true;
            try
            {
                Global.XEnv.ExecuteXmgmtCommand("xmatchfd", "e :xmatchfd reloadtitleinfo", 3);
            }
            catch
            {
                try
                {
                    Restore();
                }
                catch { }
                throw;
            }
        }

        /// <summary>
        /// Unlocked should restore a Title ID to it's original cross-platform revocation setting.
        /// Currently it sets the cross-platform revocation setting to NULL (x-plat allowed).
        /// If Lock() was not called first, calling Unlock() is a no-op.
        /// </summary>
        public void Restore()
        {
            if (Locked)
            {
                npdb = new NpdbUtility();
                npdb.ConnectToServer();
                npdb.SetMatchTitleRevokeCrossPlatform(TitleId, PreviousSetting);
                Locked = false;
                npdb.Close();
                Global.XEnv.ExecuteXmgmtCommand("xmatchfd", "e :xmatchfd reloadtitleinfo", 3);
            }
        }
    }

    static public class MatchTitleMgr
    {
        static private Dictionary<uint, MatchTitle> matchTitlesSnapshots = new Dictionary<uint, MatchTitle>();

        /// <summary>
        /// Retrieves a single match title's info from NPDB
        /// </summary>
        /// <param name="titleId">A valid Match title ID (i.e. defined in the npdb.dbo.t_match_titles table)</param>
        /// <returns>An instance of MatchTitle initialized with the values retrieve from the NPDB server</returns>
        static public MatchTitle GetMatchTitle(uint titleId)
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            MatchTitle matchTitle;
            try
            {
                matchTitle = npdb.GetMatchTitle(titleId);
            }
            finally
            {
                try
                {
                    npdb.Close();
                }
                catch { }
            }
            return matchTitle;
        }

        /// <summary>
        /// Retrieves match title info for all match titles
        /// </summary>
        /// <returns>The requested match title info</MatchTitle></returns>
        static public List<MatchTitle> GetMatchTitles()
        {
            List<MatchTitle> matchTitles;
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                matchTitles = npdb.GetMatchTitles();
            }
            finally
            {
                try
                {
                    npdb.Close();
                }
                catch { }
            }
            return matchTitles;
        }

        /// <summary>
        /// Retrieves match title info for the caller-provided match title IDs
        /// </summary>
        /// <param name="titleIds">An enumerable container of (uint) title IDs</param>
        /// <returns>The requested match title info</MatchTitle></returns>
        static public List<MatchTitle> GetMatchTitlesByIds(IEnumerable titleIds)
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            List<MatchTitle> matchTitles;
            try
            {
                matchTitles = new List<MatchTitle>();
                foreach (uint titleId in titleIds)
                {
                    MatchTitle matchTitle = npdb.GetMatchTitle(titleId);
                    if (matchTitle == null)
                    {
                        throw new UnexpectedTestResultException(
                            "GetMatchTitles: npdb.GetMatchTitle returned null for title ID 0x" + titleId.ToString("X"));
                    }
                    matchTitles.Add(matchTitle);
                }
            }
            finally
            {
                try
                {
                    npdb.Close();
                }
                catch { }
            }
            return matchTitles;
        }

        static public MatchTitle SnapshotMatchTitle(uint titleId)
        {
            lock (matchTitlesSnapshots)
            {
                if (matchTitlesSnapshots.ContainsKey(titleId))
                {
                    throw new ArgumentException("Snapshot for title ID 0x" + titleId.ToString("X") +
                        " already exists.", "titleId");
                }

                NpdbUtility npdb = new NpdbUtility();
                npdb.ConnectToServer();
                MatchTitle matchTitle = GetMatchTitle(titleId);
                matchTitlesSnapshots.Add(titleId, matchTitle);
                return new MatchTitle(matchTitle);
            }
        }

        static public void RestoreMatchTitleFromSnapshot(uint titleId)
        {
            lock (matchTitlesSnapshots)
            {
                if (!matchTitlesSnapshots.ContainsKey(titleId))
                {
                    //throw new ArgumentException("Snapshot for title ID 0x" + titleId.ToString("X") +
                    //" does not exist.", "titleId");
                    Global.RO.Warn("Warning, snapshot for title 0x " + titleId.ToString("X") + "does not exist!");
                }

                if (matchTitlesSnapshots[titleId] == null) {
                    Global.RO.Warn("Warning!  Attempt to restore a null MatchTitle!");
                } else {
                    UpdateMatchTitle(matchTitlesSnapshots[titleId]);
                }
                matchTitlesSnapshots.Remove(titleId);
            }
        }

        static public void UpdateMatchTitle(MatchTitle matchTitle)
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            try
            {
                npdb.UpdateMatchTitle(matchTitle);
            }
            finally
            {
                try
                {
                    npdb.Close();
                }
                catch { }
            }
        }
    }

    //represents a set of identically named sprocs across multiple match servers.  Methods called
    //here are passed on to each sproc in the sproc set.
    public class XmatchSprocSet {
        private ArrayList sprocs;
        
        public XmatchSprocSet(string name, params string [] servers) {
            sprocs = new ArrayList();
            foreach (string server in servers) {
                sprocs.Add(new XmatchSproc(name, server));
            }
        }

        //Create a set based only on the server(s) that this session is on.
        public XmatchSprocSet(string name, MatchSession session) {
            sprocs = new ArrayList();
            string firstServer = MatchUtil.FindServerForSession(session, true);
            string secondServer = MatchUtil.FindServerForSession(session, false);
            sprocs.Add(new XmatchSproc(name, firstServer));
            if (secondServer != firstServer) { 
                sprocs.Add(new XmatchSproc(name, secondServer));               
            }
        }

        public void ResetSprocToOriginal() {
            foreach (XmatchSproc sproc in sprocs) {
                sproc.ResetSprocToOriginal();
            }
        }


        public void SetSprocToTimeout() {
            foreach (XmatchSproc sproc in sprocs) {
                sproc.SetSprocToTimeout();
            }
        }
        public void SetSprocToTimeout(string keyString) {
            foreach (XmatchSproc sproc in sprocs) {
                sproc.SetSprocToTimeout(keyString);
            }
        }


        public void SetSprocToDelayedExecution() {
            foreach (XmatchSproc sproc in sprocs) {
                sproc.SetSprocToDelayedExecution();
            }
        }
        public void SetSprocToDelayedExecution(string keyString) {
            foreach (XmatchSproc sproc in sprocs) {
                sproc.SetSprocToDelayedExecution(keyString);
            }
        }

    }

    //represents a single sproc on a single Xmatch server.  Stores the contents of the sproc on
    //creation, and will restore it on either deletion or when instructed to.
    public class XmatchSproc {
        private string name;
        private string server;
        private const string waitBody = 
            "BEGIN\n" + 
            "  -- Force a timeout by sleeping for 1 minute\n" +
            "  WAITFOR DELAY '00:01:00'\n" +
            "END\n";

        private const string delayBody =
            "\n  WAITFOR DELAY '00:00:10'\n";

        private string alterToOriginalSproc;
        private string newContents;
        private bool modified = false;
        private bool sprocPreviouslyExists = false;
        public XmatchSproc(string name, string server) {
            this.name = name;
            this.server = server;
            XMatch xmatchConn = new XMatch();
            xmatchConn.ConnectToServer(server);
            string originalSprocContents = xmatchConn.GetStoredProc(name);

            if (originalSprocContents.Equals("")) {
                //we store something that lets us know we should delete the sproc when we're done
                //with it.
                sprocPreviouslyExists = false;
                alterToOriginalSproc = "DROP PROCEDURE dbo." + name;
            } else {
                sprocPreviouslyExists = true;
                alterToOriginalSproc = CreateToAlterSproc(originalSprocContents);
            }
            xmatchConn.Close();
        }
        
        //Safety--when this gets cleaned up, check if it was modified and re-set the sproc if that
        //hasn't been done already.  Because C# manages memory, it's only guaranteed on a clean exit
        //of xonline.
        ~XmatchSproc() {
            if (modified) {
                ResetSprocToOriginal();
            }
        }

        //Reset the sproc to what it was before modifications.
        public void ResetSprocToOriginal() {
            Global.RO.Info("Resetting sproc named " + name + " on " + server + " to original states.");
            modified = false;
            IssueCommand(alterToOriginalSproc);
        }


        //Set this sproc to timeout
        public void SetSprocToTimeout() {
            SetSprocToTimeout("BEGIN");
        }

        public void SetSprocToTimeout(string keyString) {
            if (!sprocPreviouslyExists) {
                throw new ArgumentException("Cannot set this sproc to delayed execution if no sproc previously existed!");
            }
            Global.RO.Info("Modifying sproc named " + name + " on " + server + " to a timeout");
            string delaySproc = alterToOriginalSproc.Substring(0, alterToOriginalSproc.IndexOf(keyString));
            delaySproc += waitBody;
            delaySproc += GenerateCommentedRepairSproc();
            newContents = delaySproc;
            IssueCommand(delaySproc);
            modified = true;
        }

        //Set this sproc to wait ten seconds before excuting the remainder of its block.
        public void SetSprocToDelayedExecution() {
            SetSprocToDelayedExecution("BEGIN");
        }

        //Set this sproc to wait ten seconds by inserting a wait after the given keystring.  This can easily
        //create invalid sql, so *use with caution*.  Best if it's added to a section with a comment.
        public void SetSprocToDelayedExecution(string keyString) {
            if (!sprocPreviouslyExists) {
                throw new ArgumentException("Cannot set this sproc to delayed execution if no sproc previously existed!");
            }
            Global.RO.Info("Modifying sproc named " + name + " on " + server + " to delayed execution");
            string delaySproc = alterToOriginalSproc.Substring(0, alterToOriginalSproc.IndexOf(keyString) + keyString.Length);
            delaySproc += delayBody;
            delaySproc += alterToOriginalSproc.Substring(alterToOriginalSproc.IndexOf(keyString) + keyString.Length);
            delaySproc += GenerateCommentedRepairSproc();
            newContents = delaySproc;
            IssueCommand(delaySproc);
            modified = true;
        }

        //Set this sproc to be custom, based on a string that is passed in.  Add below it the
        //original sproc text.  This is the only method that can perform a create.  We expect the
        //sproc text to come in the form of ALTER, and we set it to CREATE if we need to.
        public void SetSprocToCustom(string sprocName, string customSprocText) {
            if (!sprocPreviouslyExists) {
                customSprocText = AlterToCreateSproc(customSprocText);
            }            
            Global.RO.Info("Modifying sproc named " + name + " on " + server + " to custom execution");
            string customSproc = customSprocText;
            customSproc += GenerateCommentedRepairSproc();
            newContents = customSproc;
            IssueCommand(customSproc);
            modified = true;
            //after we create the sproc, we need to grant execute permissions.
//            if (!sprocPreviouslyExists) {
                IssueCommand("GRANT EXECUTE ON [" + sprocName + "] TO ClientLib");
//            }            
        }

        //Xmatch helpers//
        public void IssueCommand(string sql) {
            XMatch xmatchConn = new XMatch();
            try {
                xmatchConn.ConnectToServer(server);
                xmatchConn.IssueCommand(sql);
            } catch (Exception) {
                Global.RO.Error("Failed sql command.  Entire SQL statement follows:");
                Global.RO.Error(sql);
                throw;
            } finally {
                xmatchConn.Close();
            }
        }

        //String modification helpers//

        private string GenerateCommentedRepairSproc() {
            return  "\n\n\n" + 
                "--This sproc modified by an automated Match test.  Repair this sproc by running the commented\n" +
                "--command below\n" +
                "/*" +
                alterToOriginalSproc + "\n" + 
                "*/\n";
        }

        private string CreateToAlterSproc(string createSproc)
        {
            if (!createSproc.Trim().ToUpper().StartsWith("CREATE"))
            {
                throw new UnexpectedTestResultException("CREATE not found in expected location");
            }
            createSproc = createSproc.Trim().Remove(0, "CREATE".Length);
            return "ALTER" + createSproc;
        }

        private string AlterToCreateSproc(string alterSproc) {
            if (!alterSproc.Trim().ToUpper().StartsWith("ALTER"))
            {
                throw new UnexpectedTestResultException("ALTER not found in expected location");
            }
            alterSproc = alterSproc.Trim().Remove(0, "ALTER".Length);
            return "CREATE" + alterSproc;
        }

    }


    //A title sql server class, which should encapsulate talking to all match servers for a given title.  Potential dupe
    //of XMatch.cs in the database folder.
    public class TitleSqlServerSet
    {
        private uint titleId;
        private ArrayList matchDBs;

        //construct by grabbing all title sql servers for this title.
        public TitleSqlServerSet(uint titleId) {
            this.titleId = titleId;
            matchDBs = MatchUtil.GetAllSqlServersForThisTitle(titleId);       
        }
        
        //executes command, but drops return.
        public void IssueCommand(string sql) {
            Global.RO.Debug("IssueCommand: Executing statement: " + sql);
            foreach (string serverName in matchDBs) {
                XMatch server = new XMatch();
                server.ConnectToServer(serverName);
                server.IssueCommand(sql);
                server.Close();
            }
        }
        
        public string[] ExecuteScalar(string sql) {
            Global.RO.Debug("ExecuteScalar: Executing statement: " + sql);
            ArrayList results = new ArrayList();
            foreach (string serverName in matchDBs) {
                XMatch server = new XMatch();
                server.ConnectToServer(serverName);
                results.Add(server.ExecuteScalar(sql));
                server.Close();
            }
            return (string[]) results.ToArray(typeof(string));
        }        

        //we're going to make an assumption that they are identical across servers.  Return only the
        //first server's sproc.
        public string[] GetCreateSproc(string sprocName) {
            MatchTitle matchTitle = MatchTitleMgr.GetMatchTitle(titleId);
            if (matchTitle == null) {
                throw new UnexpectedTestResultException("matchTitle == null for title ID 0x" + titleId.ToString("X"));
            }
            string sql = @"SELECT OBJECT_DEFINITION(object_id) FROM sys.procedures WHERE OBJECT_NAME(object_id) = '" + sprocName + "'";

            return ExecuteScalar(sql);
        }


    }

    static public class MatchFDs
    {
        static public void ConfigCacheRefresh()
        {
            Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd configcacherefresh", 3);
        }

        static public void ReloadTitleInfo()
        {
            Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo", 3);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLDeadXBox.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// counterPart for XMATCH_DEAD_XBOX
    /// </summary>
    public class XRLDeadXBox : XRLPayload
    {
        public ushort		wType;
        public ushort		cbEnt;
        public SGADDR		sgaddr;
        public uint		dwTitleID;

        protected override string GetServiceName()
        {
            return "/xmatch/deadxbox.ashx";
        }

        /// <summary>
        /// create a deadxbox request with random values
        /// </summary>
        public XRLDeadXBox()
        {
            this.wType = Constants.SGMSG_TYPE_NOTIFY_CLI_DEL;
            this.cbEnt = (ushort) Constants.SIZEDEADXBOX;
            this.sgaddr = new SGADDR();
            this.dwTitleID = Constants.TITLE_ID;
            this.ServiceId = XOService.Matchmaking;
        }
        public XRLDeadXBox(uint titleID)
        {
            this.wType = Constants.SGMSG_TYPE_NOTIFY_CLI_DEL;
            this.cbEnt = (ushort) Constants.SIZEDEADXBOX;
            this.sgaddr = new SGADDR();
            this.dwTitleID = titleID;
            this.ServiceId = XOService.Matchmaking;
        }
        /// <summary>
        /// send individual deadxbox request to matchmaking front door
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <returns></returns>
        public override bool Execute(IPEndPoint sServer)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }

        /// <summary>
        /// send individual deadxbox request to matchmaking front door asynchronously
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <returns></returns>
        public void BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            BeginInternalExecute(sServer, reqStream, callback);
        }

        public bool EndExecute(IAsyncResult ar) {
            bool bRet = EndInternalExecute(ar);
            bool uRet = false;

            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRL2SearchSession.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    public class XRL2SearchSession : XRLPayload, IDeepCloneable
    {
        public	XRLBaseSearchSession	baseSearchSession;
        public	uint					searchParamsOffsetsLen;	//dwNumParameters
        public	uint[]					searchParamsOffsets;
        [WireInfo(SizeParam="searchParamsOffsetsLen")]
        public	XRLXeAttribParam[]		searchParams;

        //Weighted search params, which are not always used.
        //If before Geneva(Spring 2009), the weightedSearchParamsLen does not exist, nor
        //does the array.  After Geneva, it may or may not exist, depending on wFlags.
        public uint weightedSearchParamsOffsetsLen;
        public	uint[] weightedSearchParamsOffsets;
        [WireInfo(SizeParam="weightedSearchParamsOffsetsLen")]
        public XRLXeAttribParamWeighted[] weightedSearchParams;


        /// <summary>
        /// This is being used for stress test: redirect queryAffiliate call to presence emulator
        /// </summary>
        [XRLPayloadFld(Serialize=false)]
        public IPEndPoint AlternatePresenceUrl = null;

        /// <summary>
        /// This allows you to specify a version to write into the custom header.  This is separate from the
        /// version that it actually is, allowing you to advertise as this version, but send
        /// data as a different one.
        /// </summary>
        [XRLPayloadFld(Serialize=false)]
        public uint spoofSchemaVersionNumber = 0xFFFFFFFF;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            baseSearchSession.WriteStream(binaryWriter);
            if (searchParamsOffsets != null)
            {
                searchParamsOffsetsLen = (uint)searchParamsOffsets.Length;
                binaryWriter.Write(searchParamsOffsetsLen);
                for (int i = 0; i < searchParamsOffsetsLen; i++)
                {
                    binaryWriter.Write(searchParamsOffsets[i]);
                }
                for (int i = 0; i < searchParams.Length; i++)
                {
                    searchParams[i].WriteStream(binaryWriter);
                }
            }
            else
            {
                binaryWriter.Write(searchParamsOffsetsLen);
            }

            //if schema-version >= Geneva, then write out the weighted search params as
            //well.
            if (this.SchemaVersion >= MakeSchemaVersion(5,1)) 
            {
                if (weightedSearchParamsOffsets != null) {
                    weightedSearchParamsOffsetsLen = (uint)weightedSearchParamsOffsets.Length;
                    binaryWriter.Write(weightedSearchParamsOffsetsLen);
                    for (int i = 0; i < weightedSearchParamsOffsetsLen; i++)
                    {
                        binaryWriter.Write(weightedSearchParamsOffsets[i]);
                    }
                    for (int i=0; i<weightedSearchParams.Length; i++) 
                    {
                        weightedSearchParams[i].WriteStream(binaryWriter);
                    }
                }
                else 
                {
                    binaryWriter.Write(weightedSearchParamsOffsetsLen);                               
                }

            }
        }

        public object DeepClone()
        {
            // Start with a shallow clone to avoid WireData::.ctor
            XRL2SearchSession clone = (XRL2SearchSession)this.MemberwiseClone();
            // Clone XRLPayload objects
            XRLPayload clonePayload = (XRLPayload)clone;
            base.DeepCloneTo(ref clonePayload);

            // Clone XRL2SearchSession properties
            clone.baseSearchSession = (XRLBaseSearchSession)this.baseSearchSession.DeepClone();
            clone.searchParamsOffsetsLen = this.searchParamsOffsetsLen;
            if (this.searchParamsOffsets != null)
            {
                // Array of value types, built-in shallow clone is fine
                clone.searchParamsOffsets = (uint[])this.searchParamsOffsets.Clone();
            }
            if (this.searchParams != null)
            {
                clone.searchParams = new XRLXeAttribParam[this.searchParams.Length];
                for (int i = 0; i < this.searchParams.Length; i++)
                {
                    clone.searchParams[i] = (XRLXeAttribParam)this.searchParams[i].DeepClone();
                }
            }
            if (this.AlternatePresenceUrl != null)
            {
                clone.AlternatePresenceUrl = (IPEndPoint)this.AlternatePresenceUrl.Create(
                    this.AlternatePresenceUrl.Serialize()
                    );
            }

            clone.weightedSearchParamsOffsetsLen = this.weightedSearchParamsOffsetsLen;
            if (this.weightedSearchParamsOffsets != null)
            {
                // Array of value types, built-in shallow clone is fine
                clone.searchParamsOffsets = (uint[])this.searchParamsOffsets.Clone();
            }
            if (this.weightedSearchParams != null)
            {
                for (int i = 0; i < this.weightedSearchParams.Length; i++)
                {
                    clone.weightedSearchParams[i] = (XRLXeAttribParamWeighted)this.weightedSearchParams[i].DeepClone();
                }

            }
            return(clone);
        }

        protected override string GetServiceName()
        {
            return "/xmatch/xmatchClient2.ashx";
        }

        // Used only by DeepClone()
        private XRL2SearchSession()
        {
            this.ServiceId = XOService.Matchmaking;
        }
        private void InitializeBaseSearchSession(uint spIndex) {
            baseSearchSession = new XRLBaseSearchSession();
            baseSearchSession.dwMessageLength = Constants.SIZEBASESEARCH;
            baseSearchSession.wNumUsers = 4;	// required slots
            baseSearchSession.wFlags = (ushort)Constants.XONLINE_NAT_TYPE.XONLINE_NAT_OPEN;
            baseSearchSession.dwTitleID = Constants.XENON_TITLE;
            baseSearchSession.dwProcedureIndex = spIndex;
            baseSearchSession.ClientAddress = new XRLxnaddr();
            baseSearchSession.ClientAddress.ina = new byte[4]{0,0,0,0};
            baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x07,0x08,0x09,0x0a};
            baseSearchSession.ClientAddress.wPortOnline = 0x0506;
            baseSearchSession.ClientAddress.abEnet = new byte[6]{0x01,0x02,0x03,0x04,0x05,0x06};

            //default to Xenon search
            baseSearchSession.ClientAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();

            RecalculateOffsets();
        }
        public XRL2SearchSession(bool defaultSearchParams, uint spIndex)
        {
            InitializeBaseSearchSession(spIndex);
            // for xenon search: game_mode/game_type/gamer_zone/country/lang/rating/mu/sigma are added as search parameters for every 
            // customized query, except X_SSINDEX_GET_SESSION
            if(spIndex != Constants.X_SSINDEX_GET_SESSION && defaultSearchParams)
            {
                XRLXeAttribParam []	searchParams = new XRLXeAttribParam[10];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));
                searchParams[9] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));

                this.AddParams(searchParams);
            }

            this.ServiceId = XOService.Matchmaking;
        }

        public XRL2SearchSession(XRLXeAttribParam [] searchParams, uint spIndex)
        {
            InitializeBaseSearchSession(spIndex);
            this.AddParams(searchParams);
            this.ServiceId = XOService.Matchmaking;
        }

        public XRL2SearchSession(bool defaultSearchParams,
                                 XRLXeAttribParamWeighted [] weightedSearchParams, uint spIndex) : this(defaultSearchParams, spIndex) {
            this.SetWeightedFlag(true);
            this.SetSchemaVersion(5,3);  //assume if we construct in this manner, we want the
            //version that has the weights.
            this.AddWeightedParams(weightedSearchParams);
        }

        public XRL2SearchSession(XRLXeAttribParam [] searchParams,
                                 XRLXeAttribParamWeighted [] weightedSearchParams, uint spIndex) : this(searchParams, spIndex) {
            this.SetWeightedFlag(true);
            this.SetSchemaVersion(5,3);  //assume if we construct in this manner, we want the
            //version that has the weights.
            this.AddWeightedParams(weightedSearchParams);
        }

        //If you ever change a parmeter, you'll need to call this, so that the sizes match.
        public void RecalculateOffsets() {
            if (this.SchemaVersion >= MakeSchemaVersion(5,3)) 
            {
                MatchUtil.CalculateSearchOffsets(
                    Constants.SIZEBASESEARCH,
                    searchParams, weightedSearchParams, 
                    out searchParamsOffsets, out weightedSearchParamsOffsets, 
                    out baseSearchSession.dwMessageLength);

            } else {
                MatchUtil.CalculateOffsets(
                    Constants.SIZEBASESEARCH,
                    searchParams,
                    out searchParamsOffsets,
                    out baseSearchSession.dwMessageLength);
            }
        }

        //Change this search so it appears to come from a different platform.
        public void SetToPlatform(CSGInfo.ClientType platformType) {
            baseSearchSession.ClientAddress.abOnline = new SGADDR(platformType).toByteArray();
        }

        public void SetWeightedFlag(bool flag) {
            if (flag) {
                baseSearchSession.wFlags |= Constants.XONLINE_MATCH_SEARCH_WEIGHTED;
            } else {
                baseSearchSession.wFlags &= (0xFFFF ^ Constants.XONLINE_MATCH_SEARCH_WEIGHTED);
            }
        }

        //Force the request to be of a certain schema version.  When set in this manner the
        //request advertises and uses the protocol of this schema version.
        public void SetSchemaVersion(ushort major, ushort minor) {
            this.SchemaVersion = MakeSchemaVersion(major, minor);
        }

        //clone an XRLXeAttribParamWeighted array.
        private XRLXeAttribParamWeighted[] CloneWeightedArray(XRLXeAttribParamWeighted[] source, 
                                                              out XRLXeAttribParamWeighted[] dest) {
            dest = new XRLXeAttribParamWeighted[source.Length];
            for (int i=0; i<source.Length; i++) {
                dest[i] = ((XRLXeAttribParamWeighted) source[i].DeepClone());
            }
            return dest;
        }

        //append a weighted search param.
        public void AddWeightedParams(XRLXeAttribParamWeighted[] paramArray) {
            //Merge the two handles into a larger array.
            XRLXeAttribParamWeighted[] tempArray = new XRLXeAttribParamWeighted[weightedSearchParamsOffsetsLen + 
                                                                                paramArray.Length];
            for (int i=0; i<weightedSearchParamsOffsetsLen; i++) {
                tempArray[i] = (XRLXeAttribParamWeighted) weightedSearchParams[i];
            }
            for (int i=0; i<paramArray.Length; i++) {
                tempArray[i+weightedSearchParamsOffsetsLen] = (XRLXeAttribParamWeighted) paramArray[i];
            }
            //Clone this array, so nobody has any handles onto the data.  Technically we
            //shouldn't need this for the oldparams, but this is just to be safe.
            CloneWeightedArray(tempArray, out weightedSearchParams);

            RecalculateOffsets();
        }
            
        //Remove a param from the normal param list.
        public void RemoveParam(uint paramID) {
            int paramToRemoveIndex = -1;
            for (int i=0; i< searchParamsOffsetsLen; i++) {
                if (paramID == ((XRLXeAttribParam) this.searchParams[i]).attribParamID) {
                    paramToRemoveIndex = i;
                }
            }
            if (paramToRemoveIndex == -1) {
                throw new Exception("Attribute ID " + paramID + " cannot be removed from this XRL2SearchSession because it is " + 
                                    "not in the filter params array!");
            }
            XRLXeAttribParam [] newParamList = new XRLXeAttribParam[this.searchParamsOffsetsLen - 1];
            //copy up to the param we want to remove
            for(int i=0; i<paramToRemoveIndex; i++) {
                newParamList[i] = this.searchParams[i];
            }
            //copy after the param we want to remove
            for (int i=paramToRemoveIndex+1; i<this.searchParamsOffsetsLen; i++) {
                newParamList[i-1] = this.searchParams[i];
            }
            this.searchParamsOffsetsLen --;
            this.searchParams = newParamList;
            RecalculateOffsets();
        }


        /// <summary>
        /// append search parameters at the end of search requests
        /// </summary>
        /// <param name="Params"></param>
        public void AddParams(XRLXeAttribParam[] Params)
        {
            if(Params == null)
                return;
            uint	dwExistingParams = this.searchParamsOffsetsLen;
            uint	dwNewParams = (uint)Params.Length;

            uint	dwTotalParams = this.searchParamsOffsetsLen = dwExistingParams + dwNewParams;
	
            XRLXeAttribParam [] fullParams = new XRLXeAttribParam[dwTotalParams];
            for (uint i = 0; i < dwExistingParams; i++)
            {
                fullParams[i] = (XRLXeAttribParam)this.searchParams[i];
            }
            for (uint i = dwExistingParams, j = 0; i < dwTotalParams; i++, j++)
            {
                fullParams[i] = Params[j];
            }
            this.searchParamsOffsets = new uint[dwTotalParams];
            this.searchParams = new XRLXeAttribParam[dwTotalParams];
            this.searchParamsOffsets[0] = Constants.SIZEBASESEARCH + dwTotalParams * 4;
            this.baseSearchSession.dwMessageLength = Constants.SIZEBASESEARCH + dwTotalParams*4;

            // then add additional search parameters
            XRLXeIntValue		intTemp;
            XRLXeStringValue	stringTemp;
            XRLXeFloatValue		fTemp;
            XRLXeDoubleValue	doubleTemp;
            XRLXeDateTimeValue	dateTemp;
            XRLXeNullValue		nullTemp;
            XRLXeBlobValue          blobTemp;   //this is for FindSessionByIDs

            for(int i = 0; i < dwTotalParams; i++)
            {
                if((nullTemp = fullParams[i].aValue as XRLXeNullValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,new XRLXeNullValue());
                }
                if((intTemp = fullParams[i].aValue as XRLXeIntValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeIntValue(intTemp.intValue));
                }
                else if((fTemp = fullParams[i].aValue as XRLXeFloatValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeFloatValue(fTemp.fValue));
                }
                else if((doubleTemp = fullParams[i].aValue as XRLXeDoubleValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeDoubleValue(doubleTemp.dValue));
                }
                else if((dateTemp = fullParams[i].aValue as XRLXeDateTimeValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeDateTimeValue(dateTemp.dateValue));
                }
                else if((stringTemp = fullParams[i].aValue as XRLXeStringValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeStringValue(stringTemp.strValue));
                }
                else if((blobTemp = fullParams[i].aValue as XRLXeBlobValue) != null)
                {
                    this.searchParams[i] = new XRLXeAttribParam(fullParams[i].attribParamID,
                                                                new XRLXeBlobValue(blobTemp.blob));
                }
            }
            RecalculateOffsets();
        }

        /// <summary>
        /// Find a single attribute with the given parameter.  Does not use the passed-in value of
        /// that attribute.
        /// </summary>
        /// <param name="attribToFind">An XRLXeAttribParam to look for</param>
        /// <returns>A handle to the XRLXeAttribParam that currently exists and matches the name of the
        /// passed-in attribute.  Think before assigning to this!  Returns null if none is found.</returns>
        private XRLXeAttribParam FindAttrib(XRLXeAttribParam attribToFind) {
            foreach (XRLXeAttribParam currentAttrib in searchParams) {
                if (attribToFind.attribParamID == currentAttrib.attribParamID) {
                    if (attribToFind.GetType() != currentAttrib.GetType()) {
                        throw new Exception("AttributeID: " + attribToFind.attribParamID.ToString("x") +
                                            " does not match type in input: " + currentAttrib.GetType().Name);
                    }
                    return currentAttrib;
                }
            }
            return null;
        }

        //Updates an existing attribute.  If not found, throw an exception.
        public void UpdateAttrib(XRLXeAttribParam targetAttrib)
        {
            if (targetAttrib == null)
            {
                return;
            }

            XRLXeAttribParam currentAttrib = FindAttrib(targetAttrib);
            if (currentAttrib != null) 
            {
                currentAttrib.aValue = (XRLXeAttribParamValue)targetAttrib.aValue.DeepClone();
            } 
            else 
            {
                throw new ArgumentException("Attribute ID 0x" + targetAttrib.attribParamID.ToString("X") +
                                            " not found.", "targetAttrib");
            }

            RecalculateOffsets();
        }

        public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
        {
            //make sure we fill in the schema-version for this API.  Use the spoof number if
            //it's set.
            if (!this.CustomHeader.Contains("X-Schema-Ver:")) {
                if (this.spoofSchemaVersionNumber == 0xFFFFFFFF) {
                    this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
                } else {
                    this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(spoofSchemaVersionNumber) + "\r\n";
                } 
            }


            if (AlternatePresenceUrl == null)
            {
                return base.GenerateHttpHeader(endPoint,reqStream);
            }

            byte[]			completeHeader;
            ASCIIEncoding	AE = new ASCIIEncoding();
            string			sURL = AE.GetString(base.GenerateHttpHeader(endPoint,reqStream));
            StringBuilder	sbURL = new StringBuilder(sURL);
            if(sbURL.Length >= 2)
            {
                sbURL.Remove(sbURL.Length-2,2);  //remove last /r/n
            }
            if(AlternatePresenceUrl != null) 
            {
                sbURL.Append("AlternatePresenceDestination: http://"+AlternatePresenceUrl.Address.ToString()+
                             ":"+AlternatePresenceUrl.Port.ToString()+ "/xmatch/xmatchClient2.ashx\r\n\r\n");
            }

            completeHeader = AE.GetBytes(sbURL.ToString());

            return completeHeader;
        }

        public bool Execute(IPEndPoint sServer, out XRL2SearchResults Response)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, baseSearchSession.dwTitleID, 
                                baseSearchSession.ClientAddress);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRL2SearchResults();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    // searchResults could be zero
                    if(xAct.ResponseContents.Length != 0)
                        Response.ReadStream(respBuff);
                    else
                        Response = null;
                    uRet = true;
                }
            }
            return uRet;
        }

        /// <summary>
        /// For stress testing, we don't care what's being returned in the results
        /// </summary>
        /// <param name="stress"></param>
        /// <param name="sServer"></param>
        /// <param name="Response"></param>
        /// <returns></returns>
        public bool Execute(bool stress, IPEndPoint sServer, out XRL2SearchResults Response)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, baseSearchSession.dwTitleID,
                                baseSearchSession.ClientAddress);
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                    if(stress == false)
                    {
                        Response = new XRL2SearchResults();
                        MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                        // searchResults could be zero
                        if(xAct.ResponseContents.Length != 0)
                            Response.ReadStream(respBuff);
                        else
                            Response = null;
                    }
                }
            }
            return uRet;
        }

        /// <summary>
        /// For stress testing, we don't care what's being returned in the results.  This version is
        /// async, so we can send requests even more aggressively.
        /// </summary>
        /// <param name="stress"></param>
        /// <param name="sServer"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public void BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, baseSearchSession.dwTitleID,
                                baseSearchSession.ClientAddress);
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream( reqStream );

            BeginInternalExecute(sServer,reqStream, callback);
        }

        /// <summary>
        /// Tha matching EndExecute for the BeginExecute.  Call this to complete a request started
        /// via BeginExecute.
        /// </summary>
        /// <param name="ar"></param>
        /// <param name="Response"></param>
        /// <returns></returns>
        public bool EndExecute(IAsyncResult ar, out XRL2SearchResults Response) {
            bool bRet = EndInternalExecute(ar);
            bool uRet = false;
            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRL2SearchResults();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    // searchResults could be zero
                    if(xAct.ResponseContents.Length != 0)
                        Response.ReadStream(respBuff);
                    else
                        Response = null;
                    uRet = true;
                }
            }
            return uRet;
        }


        /// <summary>
        /// send searchSession http request to matchmaking front door and get results back
        /// This one is used by functional test to check search results' details.
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <param name="dwExpectedNumResults">expected number of sessions in the searchResults</param>
        /// <param name="ExpectedAttribs">expected number of attributes in the returned session</param>
        /// <param name="Response">actual response got back from match servers</param>
        /// <returns></returns>
        public bool Execute(IPEndPoint sServer, uint dwExpectedNumResults,
                            XRLXeAttribParam []ExpectedAttribs, out XRL2SearchResults Response)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, baseSearchSession.dwTitleID,
                                baseSearchSession.ClientAddress);
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);
            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRL2SearchResults();
                    Response.results = new XRL2SingleSearchResult[dwExpectedNumResults];
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    // searchResults could be zero
                    if(xAct.ResponseContents.Length != 0)
                    {
                        for(int j = 0; j < Response.results.Length; j++)
                        {
                            Response.results[j] = new XRL2SingleSearchResult();
                            Response.results[j].Attribs = new XRLXeAttribParam[ExpectedAttribs.Length];
                            for(int i = 0; i < ExpectedAttribs.Length; i++)
                            {
                                if((ExpectedAttribs[i].aValue as XRLXeIntValue) != null)
                                {
                                    Response.results[j].Attribs[i] = new XRLXeAttribParam(
                                        ExpectedAttribs[i].attribParamID,
                                        new XRLXeIntValue());
                                }
                                else if((ExpectedAttribs[i].aValue as XRLXeDoubleValue) != null)
                                {
                                    Response.results[j].Attribs[i] = new XRLXeAttribParam(
                                        ExpectedAttribs[i].attribParamID,
                                        new XRLXeDoubleValue());
                                }
                                else if((ExpectedAttribs[i].aValue as XRLXeDateTimeValue) != null)
                                {
                                    Response.results[j].Attribs[i] = new XRLXeAttribParam(
                                        ExpectedAttribs[i].attribParamID,
                                        new XRLXeDateTimeValue());
                                }
                                else if((ExpectedAttribs[i].aValue as XRLXeStringValue) != null)
                                {
                                    Response.results[j].Attribs[i] = new XRLXeAttribParam(
                                        ExpectedAttribs[i].attribParamID,
                                        new XRLXeStringValue());
                                }
                                else if((ExpectedAttribs[i].aValue as XRLXeNullValue) != null)
                                {
                                    Response.results[j].Attribs[i] = new XRLXeAttribParam(
                                        Constants.X_ATTRIBUTE_DATATYPE_NULL,
                                        new XRLXeNullValue());
                                }
                            }
                        }
                        Response.ReadStream(respBuff);
                    }
                    else
                        Response = null;
                    uRet = true;
                }
            }
            return uRet;
        }
    }

    public class XRL2SingleSearchResult : WireData
    {
        public	uint		dwResultLength;
        [XRLPayloadFld(ArraySize=8)]
        public	byte[]		SessionID;
        public	XRLxnaddr	HostAddress;
        [XRLPayloadFld(ArraySize=16)]
        public	byte[]		KeyExchangeKey;
        public	uint		dwPublicOpen;
        public	uint		dwPrivateOpen;
        public	uint		dwPublicFilled;
        public	uint		dwPrivateFilled;
        public	uint		AttribOffsetsLen;	// dwNumAttributes
        public	uint[]		AttribOffsets;
        [WireInfo(SizeParam="AttribOffsetsLen")]
        public  XRLXeAttribParam[] Attribs;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            long startPos = binaryReader.BaseStream.Position;
            base.ReadStream(binaryReader);
            long endPos = binaryReader.BaseStream.Position;

            int numPadding = (int)(dwResultLength -(endPos - startPos));

            binaryReader.ReadBytes(numPadding);
            return this;
        }
    }

    public class XRL2SearchResults : XRLPayload
    {
        public	uint				dwMessageLength;
        public	ushort				resultsLen;	// nNumSearchResults
        public	ushort				fFlags;
        public	uint				dwLoggingThreshold;
        public	XRL2SingleSearchResult[]	results;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLDeleteSession.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
	/// <summary>
	/// counterPart for XMATCH_DELETE_SESSION
	/// </summary>
	public class XRLDeleteSession : XRLPayload
	{
		public	uint	dwMessageLength;
		[XRLPayloadFld(ArraySize=8)]
		public	byte[]	SessionID;
		public	uint	dwTitleID;
		
		protected override string GetServiceName()
		{
			return "/xmatch/xmatchhostDelete.srf";
		}

		/// <summary>
		/// delete session with specified sessionID
		/// </summary>
		/// <param name="sessID"></param>
		public XRLDeleteSession(byte[] sessID)
		{
			this.dwMessageLength = Constants.SIZEDELETESESSION;
			this.dwTitleID = Constants.TITLE_ID;
			this.SessionID = new byte[sessID.Length];
			Array.Copy(sessID,SessionID,sessID.Length);
			this.ServiceId = XOService.Matchmaking;
		}
		/// <summary>
		/// send deleteSession request to matchmaking front door
		/// </summary>
		/// <param name="sServer">matchmaking front door</param>
		/// <returns></returns>
		public override bool Execute(IPEndPoint sServer)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					uRet = true;
				}
			}
			return uRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLSplitSession.cs ===
using System;
using System.Collections;
using System.Net;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// XRL for splitting a session during host migration
    /// </summary>
    public class XRLSplitSession : XRLPayload
    {
        public uint                 dwMessageLength;

        // default is to create "online xbox hosted session"
        // the NAT type of the host is "open" 1001
        [XRLPayloadFld(ArraySize=8)]
        public byte[]               SessionID = {0x90,0,0,0,0,0,0,0};

        [XRLPayloadFld(ArraySize=8)]
        public byte[]               SplitSessionID = new byte[8];
        public uint                 dwTitleID;
        public XRLxnaddr            HostAddress;

        public uint                 AttribOffsetsLen = 0;           //dwNumAttributes
        public uint[]               AttribOffsets = new uint[0];    // an array of attributes offset

        [WireInfo(SizeParam="AttribOffsetsLen")]
        public XRLXeAttribParam[]   Attribs = new XRLXeAttribParam[0];

        [WireInfo(Serialize=false)]
        public bool WriteStreamCalculatesOffsetsLen = true;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwMessageLength);
            if (SessionID != null)
            {
                binaryWriter.Write(SessionID);
            }
            if (SplitSessionID != null)
            {
                binaryWriter.Write(SplitSessionID);
            }
            binaryWriter.Write(dwTitleID);
            if (HostAddress != null)
            {
                HostAddress.WriteStream(binaryWriter);
            }
            if (WriteStreamCalculatesOffsetsLen)
            {
                AttribOffsetsLen = (uint)AttribOffsets.Length;
            }
            binaryWriter.Write(AttribOffsetsLen);
            if (AttribOffsets != null)
            {
                for (int i = 0; i < AttribOffsets.Length; i++)
                {
                    binaryWriter.Write(AttribOffsets[i]);
                }
            }
            if (Attribs != null)
            {
                for (int i = 0; i < Attribs.Length; i++)
                {
                    Attribs[i].WriteStream(binaryWriter);
                }
            }
        }

        protected override string GetServiceName()
        {
            return "/xmatch/xmatchsplit.ashx";
        }

        public XRLSplitSession()
        {
            ServiceId = XOService.Matchmaking;
        }

        /// <summary>
        /// create session with 9 mandatory session attributes.
        /// </summary>
        public XRLSplitSession(byte[] origSessionID, uint titleID, XRLxnaddr hostAddress, WireData[] attribs)
        {
            SplitSessionID = origSessionID;
            dwTitleID = titleID;
            HostAddress = hostAddress;

            ArrayList createAttrs = new ArrayList();
            for(int i = 0; i < Constants.BaseSessionAttributes.Length; ++i)
            {
                WireData attr = MatchUtil.GetAttributeById(attribs, Constants.BaseSessionAttributes[i]);
                if(null != attr)
                {
                    createAttrs.Add(attr);
                }
            }

            Attribs = ((XRLXeAttribParam[])createAttrs.ToArray(typeof(XRLXeAttribParam)));
            AttribOffsetsLen = (uint)Attribs.Length;
            AttribOffsets = new uint[Attribs.Length];
            
            // Calculate offsets
            uint dwTotalMessageLen = Constants.SIZESPLIT;
            for(uint i = 0; i < Attribs.Length; ++i)
            {
                AttribOffsets[i] = dwTotalMessageLen;
                dwTotalMessageLen += (uint)Attribs[i].Size();
            }

            dwMessageLength = dwTotalMessageLen;
            this.ServiceId = XOService.Matchmaking;
        }

        /// <summary>
        /// create session with 9 mandatory session attributes.
        /// </summary>
        public XRLSplitSession(XRL2CreateUpdateSession createUpdate)
        {
            SplitSessionID = createUpdate.baseCreateUpdate.baseSession.SessionID;
            dwTitleID = createUpdate.baseCreateUpdate.baseSession.dwTitleID;

            ArrayList createAttrs = new ArrayList();

            for(int i = 0; i < Constants.BaseSessionAttributes.Length; ++i)
            {
                WireData attr = createUpdate.baseCreateUpdate.GetAttribute(Constants.BaseSessionAttributes[i]);
                if(null != attr)
                {
                    createAttrs.Add((XRLXeAttribParam)attr);
                }
            }

            Attribs = ((XRLXeAttribParam[])createAttrs.ToArray(typeof(XRLXeAttribParam)));
            AttribOffsetsLen = (uint)Attribs.Length;

            MatchUtil.CalculateOffsets(
                    Constants.SIZESPLIT, 
                    Attribs, 
                    out AttribOffsets, 
                    out dwMessageLength);
            
            this.ServiceId = XOService.Matchmaking;
        }

        /// <summary>
        /// Send SplitSession request
        /// </summary>
        /// <param name="sServer"></param>
        /// <param name="Response"></param>
        /// <returns></returns>
        public bool Execute(IPEndPoint sServer, out XRL2SingleSearchResult Response)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, dwTitleID, HostAddress);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRL2SingleSearchResult();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);
                    uRet = true;
                }
            }
            return uRet;
        }

        /// <summary>
        /// Send SplitSession request asynchronously
        /// </summary>
        /// <param name="sServer"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public void BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MatchUtil.SetSGInfo(this, CSGInfo.ClientType.Xenon, dwTitleID, HostAddress);
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            BeginInternalExecute(sServer, reqStream, callback);
        }
        
        public bool EndExecute(IAsyncResult ar, out XRL2SingleSearchResult Response) {
            bool bRet = EndInternalExecute(ar);
            bool uRet = false;
            Response = null;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRL2SingleSearchResult();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLCreateUpdateSession.cs ===
using System;
using System.Net;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    public abstract class XrlAttributeBase : WireData
    {
        public abstract uint CalculateSize();
    }

	/// <summary>
	/// int attribute when creating or updating a session
	/// </summary>
    public class XRLIntAttribute : XrlAttributeBase
	{
		public uint		AttributeID;
		public long		intValue;
		/// <summary>
		/// XRLIntAttribute constructor
		/// </summary>
		/// <param name="attribID"></param>
		/// <param name="attribValue"></param>
		public XRLIntAttribute(uint attribID, long attribValue)
		{
			AttributeID = attribID;
			intValue = attribValue;
		}

        public override uint CalculateSize()
        {
            return (uint)4 + 8;
        }
	}
	/// <summary>
	/// string attribute when creating or updateing a session
	/// </summary>
    public class XRLStringAttribute : XrlAttributeBase
	{
		public uint		AttributeID;
		public ushort	strValueLen;
		public string	strValue;
		/// <summary>
		/// XRLStringAttribute constructor
		/// </summary>
		/// <param name="attribID"></param>
		/// <param name="attribValue"></param>
		public XRLStringAttribute(uint attribID, string	attribValue)
		{
			AttributeID = attribID;
			strValue = attribValue;
			strValueLen = (ushort)attribValue.Length;
		}

        public override uint CalculateSize()
        {
            return (uint)4 + 2 + strValueLen;
        }
	}
	/// <summary>
	/// blob attribute when creating or updating a session
	/// </summary>
    public class XRLBlobAttribute : XrlAttributeBase
	{
		public uint		AttributeID;
		public ushort	blobLen;
		public byte[]	blob;
		/// <summary>
		/// XRLBlobAttribute constructor
		/// </summary>
		/// <param name="attribID"></param>
		/// <param name="attribValue"></param>
		public XRLBlobAttribute(uint attribID, byte[] attribValue)
		{
			AttributeID = attribID;
			blobLen = (ushort)attribValue.Length;
			blob = new byte[blobLen];
			Array.Copy(attribValue,blob,blobLen);
		}

        public override uint CalculateSize()
        {
            return (uint)4 + 2 + blobLen;
        }
	}

	/// <summary>
	/// basic fields of createSession request
	/// </summary>
	public class XRLBaseSession : WireData, IDeepCloneable
	{
		public uint			dwMessageLength;
		// default is to create "online xbox hosted session"
		// the NAT type of the host is "open" 1001
		[XRLPayloadFld(ArraySize=8)]
		public byte[]		SessionID = {0x90,0,0,0,0,0,0,0};
		public uint			dwTitleID;
		public XRLxnaddr	HostAddress;
		public uint			dwPublicOpen;
		public uint			dwPrivateOpen;
		public uint			dwPublicFilled;
		public uint			dwPrivateFilled;

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(dwMessageLength);
			binaryWriter.Write(SessionID);
			binaryWriter.Write(dwTitleID);
			HostAddress.WriteStream(binaryWriter);
			binaryWriter.Write(dwPublicOpen);
			binaryWriter.Write(dwPrivateOpen);
			binaryWriter.Write(dwPublicFilled);
			binaryWriter.Write(dwPrivateFilled);
		}

		public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLBaseSession clone = (XRLBaseSession)this.MemberwiseClone();
			// Array of value types, built-in shallow clone is fine
			clone.SessionID = (byte[])this.SessionID.Clone();
			clone.HostAddress = (XRLxnaddr)this.HostAddress.DeepClone();
			return(clone);
		}
	}

	/// <summary>
	/// counterPart of XMATCH_SESSION
	/// </summary>
    public class XRLCreateUpdateSession : XRLPayload
	{
		public XRLBaseSession		baseSession;
		public uint					AttribOffsetsLen = 0;			//dwNumAttributes
		public uint[]				AttribOffsets = new uint[0];	// an array of attributes offset
		[WireInfo(SizeParam="AttribOffsetsLen")]
        public XrlAttributeBase[] Attribs = new XrlAttributeBase[0];	// attrib can be XRLIntAttribute/XRLStringAttribute/XRLBlobAttribute

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			baseSession.WriteStream(binaryWriter);
			if (AttribOffsets != null)
			{
                //Removed: this breaks negative testing
				//AttribOffsetsLen = (uint)AttribOffsets.Length;
				binaryWriter.Write(AttribOffsetsLen);
                for (int i = 0; i < AttribOffsets.Length; i++)
				{
					binaryWriter.Write(AttribOffsets[i]);
				}
				for (int i = 0; i < Attribs.Length; i++)
				{
					Attribs[i].WriteStream(binaryWriter);
				}
			}
			else
			{
				binaryWriter.Write(AttribOffsetsLen);
			}
		}

		protected override string GetServiceName()
		{
			return "/xmatch/xmatchhost.srf";
		}

		/// <summary>
		/// default constructor
		/// </summary>
		public XRLCreateUpdateSession()
		{
			baseSession = new XRLBaseSession();
			baseSession.dwMessageLength = Constants.SIZEBASESESSION;
			baseSession.dwPrivateFilled = 0;
			baseSession.dwPrivateOpen = 8;
			baseSession.dwPublicFilled = 0;
			baseSession.dwPublicOpen = 8;
			baseSession.dwTitleID = Constants.TITLE_ID;
			baseSession.HostAddress = new XRLxnaddr();
			baseSession.HostAddress.ina = new byte[4]{0,0,0,0};
			baseSession.HostAddress.inaOnline = new byte[4]{0x01,0x02,0x03,0x04};
			baseSession.HostAddress.wPortOnline = 0x0506;
			baseSession.HostAddress.abEnet = new byte[6]{0x01,0x02,0x03,0x04,0x05,0x06};
                        //set to an Xbox1 session
//                        baseSession.HostAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xbox).toByteArray();
                        //for now, create Xenon sessions.  Later, don't set the hostaddress at all,
                        //because we will never create this except if it's under an XRL2CreateUpdateSession.
                        baseSession.HostAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();
			this.ServiceId = XOService.Matchmaking;
		}

		public override byte[] GenerateHttpHeader(IPEndPoint sServer, MemoryStream reqStream)
		{
			if(this.CustomHeader == String.Empty)
				return base.GenerateHttpHeader(sServer, reqStream);
			else    // there is PUserAgent test case
			{
				byte[]			header;
				StringBuilder	sbURL;
				string			temp;
				sbURL = new StringBuilder();
				sbURL.Append( "POST " );
				sbURL.Append( GetServiceName() );
				sbURL.Append( " HTTP/1.0\r\n" );
				sbURL.Append( "Relja: true\r\n");  // This header was requested by SLamb to differentiate tools/tests and real clients
				sbURL.Append( "Host: "+sServer.ToString()+"\r\n");
				temp = sbURL.ToString();

				sbURL=new StringBuilder(temp);
				sbURL.Append( "Content-Type: xon/" + ((int)ServiceId).ToString("x")+"\r\n");
				sbURL.Append( CustomHeader );
				sbURL.Append( "Content-Length: " +  reqStream.Length+"\r\n\r\n");

				System.Text.ASCIIEncoding	AE=new System.Text.ASCIIEncoding();

				header=AE.GetBytes(sbURL.ToString());
				return header;
			}
		}

		/// <summary>
		/// send CreateSession requests to matchmaking front door
		/// </summary>
		/// <param name="sServer">matchmaking front door</param>
		/// <param name="Response">createSession response</param>
		/// <returns></returns>
		public bool Execute(IPEndPoint sServer, out XRLSessionInfo Response)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			Response = null;
			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					Response = new XRLSessionInfo();
					MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
					Response.ReadStream(respBuff);
					uRet = true;
				}
			}
			return uRet;
		}
		/// <summary>
		/// send updateSession request to matchmaking front door
		/// </summary>
		/// <param name="sServer">matchmaking front door</param>
		/// <returns></returns>
		public override bool Execute(IPEndPoint sServer)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					uRet = true;
				}
			}
			return uRet;
		}

        public void CopySGInfoFrom(XRLCreateUpdateSession src)
        {
            ManualPopulateSlot();
            Slot = src.Slot.ShallowClone();
            baseSession.HostAddress = (XRLxnaddr)src.baseSession.HostAddress.DeepClone();
        }

		/// <summary>
		/// append title attributes at the end of create/updateSession requests
		/// </summary>
		/// <param name="attribs"></param>
		public void AddAttribs(WireData[] attribs)
		{
			// update total message length first;
			this.baseSession.dwMessageLength += (uint)attribs.Length*4;

			// then add attributes
			XRLIntAttribute		intTemp;
			XRLStringAttribute	stringTemp;
			XRLBlobAttribute	blobTemp;
			uint	dwNumAttribs = (uint)attribs.Length;
			this.AttribOffsetsLen = dwNumAttribs;
			this.AttribOffsets = new uint[dwNumAttribs];
            this.Attribs = new XrlAttributeBase[dwNumAttribs];
			this.AttribOffsets[0] = Constants.SIZEBASESESSION + dwNumAttribs * 4;
			for(int i = 0; i < dwNumAttribs; i++)
			{
				if((intTemp = attribs[i] as XRLIntAttribute) != null)
				{
					this.baseSession.dwMessageLength += 4+8;
					this.Attribs[i] = new XRLIntAttribute(intTemp.AttributeID,intTemp.intValue);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+8;
				}
				else if((stringTemp = attribs[i] as XRLStringAttribute) != null)
				{
					this.Attribs[i] = new XRLStringAttribute(stringTemp.AttributeID,stringTemp.strValue);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+2+stringTemp.strValueLen;
					// update total message length
					this.baseSession.dwMessageLength += (uint)(4+2+stringTemp.strValueLen);
				}
				else if((blobTemp = attribs[i] as XRLBlobAttribute) != null)
				{
					this.Attribs[i] = new XRLBlobAttribute(blobTemp.AttributeID, blobTemp.blob);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+2+blobTemp.blobLen;
					// update total message length
					this.baseSession.dwMessageLength += (uint)(4+2+blobTemp.blobLen);
				}
			}
		}

        /// <summary>
		/// Change the attributes of a session object
		/// </summary>
		/// <param name="attribs"></param>
		public void SetAttribs(WireData[] attribs)
		{
            if(null == attribs)
            {
                return;
            }

			// Set the base message length
			this.baseSession.dwMessageLength = (uint)attribs.Length*4;

			// Then add attributes
			XRLIntAttribute		intTemp;
			XRLStringAttribute	stringTemp;
			XRLBlobAttribute	blobTemp;

			uint	dwNumAttribs = (uint)attribs.Length;
			this.AttribOffsetsLen = dwNumAttribs;
			this.AttribOffsets = new uint[dwNumAttribs];
            this.Attribs = new XrlAttributeBase[dwNumAttribs];
			this.AttribOffsets[0] = Constants.SIZEBASESESSION + dwNumAttribs * 4;

			for(int i = 0; i < dwNumAttribs; i++)
			{
				if((intTemp = attribs[i] as XRLIntAttribute) != null)
				{
					this.baseSession.dwMessageLength += 4+8;
					this.Attribs[i] = new XRLIntAttribute(intTemp.AttributeID,intTemp.intValue);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+8;
				}
				else if((stringTemp = attribs[i] as XRLStringAttribute) != null)
				{
					this.Attribs[i] = new XRLStringAttribute(stringTemp.AttributeID,stringTemp.strValue);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+2+stringTemp.strValueLen;
					// update total message length
					this.baseSession.dwMessageLength += (uint)(4+2+stringTemp.strValueLen);
				}
				else if((blobTemp = attribs[i] as XRLBlobAttribute) != null)
				{
					this.Attribs[i] = new XRLBlobAttribute(blobTemp.AttributeID, blobTemp.blob);
					if(i != (dwNumAttribs-1))
						this.AttribOffsets[i+1] = this.AttribOffsets[i]+4+2+blobTemp.blobLen;
					// update total message length
					this.baseSession.dwMessageLength += (uint)(4+2+blobTemp.blobLen);
				}
			}
        }

        /// <summary>
        /// append title attributes at the end of create/updateSession requests
        /// </summary>
        /// <param name="attribs"></param>
        public void AppendAttribs(XrlAttributeBase[] appendAttribs)
        {
            int attribCount = Attribs.Length + appendAttribs.Length;
            XrlAttributeBase[] combinedAttribs = new XrlAttributeBase[attribCount];

            for (int i = 0; i < Attribs.Length; i++)
            {
                combinedAttribs[i] = Attribs[i];
            }
            for (int i = 0; i < appendAttribs.Length; i++)
            {
                combinedAttribs[i + Attribs.Length] = appendAttribs[i];
            }
            Attribs = combinedAttribs;

            // Update the rest of the attribute related fields
            MatchUtil.CalculateOffsets(Constants.SIZEBASESESSION,
                Attribs,
                out AttribOffsets,
                out baseSession.dwMessageLength);
            AttribOffsetsLen = (uint)AttribOffsets.Length;
        }
	
        /// <summary> 
        /// Retrieve an attribute wiredata based on the ID
        /// </summary>
        /// <param name='attributeId'>Match AttributeID to retrieve</param>
        /// <returns>Attribute wiredata object or null if none exists</returns>
		public WireData GetAttribute(uint attributeId)
        {
            return MatchUtil.GetAttributeById(Attribs, attributeId);
        }

		// this function assumes that 1. only one session returned
		// 2. no addtional attributes returned along with the session
		public bool Verify(XRLSearchResults searchRes)
		{
			long	expDate = DateTime.UtcNow.AddHours(24).ToFileTime();
			byte	expected_isavailable = 0;
			if(this.baseSession.dwPublicOpen > 0)
				expected_isavailable = 1;
			/*******************************************************************
			 * The following checks columns that are returned in searchResults
			 *******************************************************************/
			uint expectedResultsLen = Constants.SIZEBASESEARCHRESULT+Constants.SIZESEARCHHEADER;
			if(searchRes.dwMessageLength != expectedResultsLen)
			{
				Global.RO.Warn("dwMessageLength in search Results is not wrong:"+searchRes.dwMessageLength);
				return false;
			}
			if(searchRes.resultsLen != 1)
			{
				Global.RO.Warn("resultsLen (nNumSearchResults) is not 1:"+searchRes.resultsLen);
				return false;
			}
			if(searchRes.results[0].dwResultLength != Constants.SIZEBASESEARCHRESULT)
			{
				Global.RO.Warn("dwResultLength in the searchResult is wrong:"+searchRes.results[0].dwResultLength);
				return false;
			}
			if(!searchRes.results[0].HostAddress.compare(this.baseSession.HostAddress))
			{
				Global.RO.Warn("hostAddress in the searchResult is not the one sent in the create Request");
				return false;
			}
			if(searchRes.results[0].dwPrivateOpen != this.baseSession.dwPrivateOpen)
			{
				Global.RO.Warn("dwPrivateOpen in the searchResult is not the one sent in the createSession request");
				return false;
			}
			if(searchRes.results[0].dwPrivateFilled != this.baseSession.dwPrivateFilled)
			{
				Global.RO.Warn("dwPrivateFilled in the searchResult is not the one sent in the createSession request");
				return false;
			}
			if(searchRes.results[0].dwPublicFilled != this.baseSession.dwPublicFilled)
			{
				Global.RO.Warn("dwPublicFilled in the searchResult is not the one sent in the createSession request");
				return false;
			}
			if(searchRes.results[0].dwPublicOpen != this.baseSession.dwPublicOpen)
			{
				Global.RO.Warn("dwPublicOpen in the searchResult is not the one sent in the createSession request");
				return false;
			}
			if(searchRes.results[0].AttribOffsetsLen != 0)
			{
				Global.RO.Warn("dwNumAttributes in the searchResult is not 0:"+searchRes.results[0].AttribOffsetsLen);
				return false;
			}
			/**************************************************************************
			 * The following send inquiries to db directly to check additional columns
			 * i_sg_ip,b_box_id,dt_session_expiration;ti_is_available
			 **************************************************************************/
			uint	titleID = this.baseSession.dwTitleID;
			bool	found = false;
			long	lSessID = 0;
			for(int i = 7; i >= 0; i--)
			{
				lSessID <<=8;
				lSessID += searchRes.results[0].SessionID[i];
			}
			int				r_sgip = 0, expectedSgIp = 0;
			byte[]			r_boxid = new byte[8], expectedBoxID = new byte[8];
			long			r_ExpirationDate = 0;
			byte			r_isavailable = 0;
			foreach (IPEndPoint server in Global.XEnv.GetInterface(Interface.xmatch))
			{
				found = false;
				// connect to the db
				string myConnStr = "Data Source=" +server.Address.ToString()+ @";Database=xmatch;" +
					"Trusted_Connection=true";
				SqlConnection	mySqlConn;
				mySqlConn =  new SqlConnection(myConnStr);
				// get the row according to bi_session_id
				string			myQuery = @"SELECT s.i_sg_ip, s.b_box_id, s.dt_session_expiration,
											s.ti_is_available
											FROM t_match_sessions_"+titleID+@" s
											WHERE s.bi_session_id=" + lSessID;
				SqlCommand		myCommand = new SqlCommand(myQuery, mySqlConn);
				myCommand.Connection.Open();
				SqlDataReader	myReader = myCommand.ExecuteReader();
				while (myReader.Read())
				{
					found = true;
					r_sgip = IPAddress.NetworkToHostOrder(myReader.GetInt32(0));
					myReader.GetBytes(1,0,r_boxid,0,8);
					r_ExpirationDate = myReader.GetDateTime(2).ToFileTime(); // The time is already in UTC, using ToFileTimeUtc would do a 2nd conversion
					r_isavailable = myReader.GetByte(3);
				}
				myReader.Close();
				myCommand.Connection.Close();
				if(found)
					break;
			}
			for(int i = 3; i >= 0 ; i--)
			{
				expectedSgIp <<= 8;
				expectedSgIp += this.baseSession.HostAddress.abOnline[i];
			}
			for(int i = 4; i < 12; i++)
				expectedBoxID[i-4] = this.baseSession.HostAddress.abOnline[i];
			if(found)
			{
				for(int i = 0; i < r_boxid.Length; i++)
					if(r_boxid[i] != expectedBoxID[i])
					{
						Global.RO.Warn("b_box_id is not set correctly");
						return false;
					}
				if(expectedSgIp != r_sgip)
				{
					Global.RO.Warn("i_sg_ip is not set correctly:"+r_sgip);
					return false;
				}
				if(r_isavailable != expected_isavailable)
				{
					Global.RO.Warn("ti_is_available is not set correctly:"+r_isavailable);
					return false;
				}
				// time difference is within 5 minute(300s) is tolerable
				if(((r_ExpirationDate > expDate) && ((r_ExpirationDate-expDate)/10000000>300)) // TODO: Allowing an additional hour of time skew until Testnet clocks are fixed, then should be 300
					||((r_ExpirationDate < expDate) && ((expDate-r_ExpirationDate)/10000000>300)))
				{
					Global.RO.Warn("The dt_expiration_time is not set correctly: (" + r_ExpirationDate.ToString() + ", " + expDate.ToString() + ")!");
					return false;
				}
			}
			return true;
		}
	}
	/// <summary>
	/// counterPart for XMATCH_SESSIONINFO
	/// </summary>
	public class XRLSessionInfo : XRLPayload
	{
		[XRLPayloadFld(ArraySize=8)]
		public byte[]		SessionID;
		[XRLPayloadFld(ArraySize=16)]
		public byte[]		KeyExchangeKey;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLSearchSession.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
	/// <summary>
	/// This class is used to represent BOTH session attributes returned in search Results
	/// AND search parameters in the search requests
	/// </summary>
	public class XRLAttribParam : WireData, IDeepCloneable
	{
		public uint type;
		public XRLAttribParamValue aValue;

		// default constructor needs by readValue in wiredata.cs
		public XRLAttribParam()
		{
			type = 0;
			aValue = null;
		}

		public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLAttribParam clone = (XRLAttribParam)this.MemberwiseClone();
			clone.aValue = (XRLAttribParamValue)this.aValue.DeepClone();
			return(clone);
		}

		public XRLAttribParam(uint valType, XRLAttribParamValue paramValue)
		{
			XRLIntParam	intParam;
			XRLStringParam	stringParam;
			XRLBlobParam	blobParam;
			XRLNullParam	nullParam;

			type = valType;
			if((intParam = (paramValue as XRLIntParam)) != null)
			{
				aValue = new XRLIntParam(intParam.intValue);
			}
			else if ((stringParam = (paramValue as XRLStringParam)) != null)
			{
				aValue = new XRLStringParam(stringParam.strValue);
			}
			else if ((blobParam = (paramValue as XRLBlobParam)) != null)
			{
				aValue = new XRLBlobParam(blobParam.blob);
			}
			else if ((nullParam = (paramValue as XRLNullParam)) != null)
			{
				aValue = new XRLNullParam();
			}
		}

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			type = binaryReader.ReadUInt32();
			if (type == Constants.X_ATTRIBUTE_DATATYPE_INTEGER) 
			{
				aValue = new XRLIntParam();
			}
			else if (type == Constants.X_ATTRIBUTE_DATATYPE_STRING)
			{
				aValue = new XRLStringParam();
			}
			else if (type == Constants.X_ATTRIBUTE_DATATYPE_BLOB)
			{
				aValue = new XRLBlobParam();
			}
			else if (type == Constants.X_ATTRIBUTE_DATATYPE_NULL)
			{
				aValue = new XRLNullParam();
			}
			aValue.ReadStream(binaryReader);
			return this;
		}
	}
/*
	public class XRLAttribParamType : WireData
	{
		public uint		type;
		public XRLAttribParamType(uint t)
		{
			type = t;
		}
	}
*/
	public abstract class XRLAttribParamValue : WireData, IDeepCloneable
	{
		public abstract object DeepClone();
	}

	public class XRLIntParam : XRLAttribParamValue
	{
		public long			intValue;

		/// <summary>
		/// create an intParam with specified value
		/// </summary>
		/// <param name="val"></param>
		public XRLIntParam(long val)
		{
			intValue = val;
		}

		public XRLIntParam()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(intValue);
		}

		public override object DeepClone()
		{
			// Value type only, built-in shallow clone is fine
			return(this.MemberwiseClone());
		}
	}

	public class XRLStringParam : XRLAttribParamValue
	{
		public ushort	strValueLen;
		public string	strValue;
		/// <summary>
		/// create a stringParam with specified string value
		/// </summary>
		/// <param name="val"></param>
		public XRLStringParam(string val)
		{
			if(val != null)
			{
				strValueLen = (ushort)val.Length;
			}
			else
			{
				strValueLen = 0;
			}
			strValue = val;
		}

		public XRLStringParam()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (strValue == null)
			{
				strValueLen = 0;
				binaryWriter.Write(strValueLen);
			}
			else
			{
				System.Diagnostics.Debug.Assert(strValue.Length <= ushort.MaxValue);
				strValueLen = (ushort)strValue.Length;
				binaryWriter.Write(strValueLen);
				binaryWriter.Write(strValue.ToCharArray());
			}
		}

		public override object DeepClone()
		{
			// Start with a shallow clone
			XRLStringParam clone = (XRLStringParam)this.MemberwiseClone();
			// Can't use String.Clone():  "The return value is not an independent copy of this instance;
			// it is simply another view of the same data."
			clone.strValue = string.Copy(this.strValue);
			return(clone);
		}
	}

	public class XRLBlobParam : XRLAttribParamValue
	{
		public ushort	blobLen;
		public byte[]	blob;

		/// <summary>
		/// create a blob parameter with specified blob value
		/// </summary>
		/// <param name="val"></param>
		public XRLBlobParam(byte[] val)
		{
			if(val != null)
			{
				blobLen = (ushort)val.Length;
				blob = new byte[blobLen];
				Array.Copy(val,blob,blobLen);
			}
			else
			{
				blobLen = 0;
				blob = null;
			}
		}

		public XRLBlobParam()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (blob == null)
			{
				blobLen = 0;
				binaryWriter.Write(blobLen);
			}
			else
			{
				System.Diagnostics.Debug.Assert(blob.Length <= ushort.MaxValue);
				blobLen = (ushort)blob.Length;
				binaryWriter.Write(blobLen);
				binaryWriter.Write(blob);
			}
		}

		public override object DeepClone()
		{
			// Start with a shallow clone
			XRLBlobParam clone = (XRLBlobParam)this.MemberwiseClone();
			if (blob != null)
			{
				clone.blob = (byte[])this.blob.Clone();
			}
			return(clone);
		}
	}

	public class XRLNullParam : XRLAttribParamValue
	{
		public XRLNullParam()
		{
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
		}

		public override object DeepClone()
		{
			// Start with a shallow clone
			XRLNullParam clone = (XRLNullParam)this.MemberwiseClone();
			return(clone);
		}
	}

	/// <summary>
	/// basic fields of search session request
	/// </summary>
	public class XRLBaseSearchSession : WireData, IDeepCloneable
	{
		public	uint		dwMessageLength;
		public	uint		dwTitleID;
		public	uint		dwProcedureIndex;
		public	XRLxnaddr	ClientAddress;
		public	ushort		wNumUsers;
		public	ushort		wFlags;

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(dwMessageLength);
			binaryWriter.Write(dwTitleID);
			binaryWriter.Write(dwProcedureIndex);
			ClientAddress.WriteStream(binaryWriter);
			binaryWriter.Write(wNumUsers);
			binaryWriter.Write(wFlags);
		}

		public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLBaseSearchSession clone = (XRLBaseSearchSession)this.MemberwiseClone();
			// Fix-up for ClientAddress which is not a value type
			clone.ClientAddress = (XRLxnaddr)this.ClientAddress.DeepClone();
			return(clone);
		}
	}
	/// <summary>
	/// counter part of XMATCH_SEARCH_SESSION
	/// </summary>
	public class XRLSearchSession : XRLPayload, IDeepCloneable
	{
		public	XRLBaseSearchSession	baseSearchSession;
		public	uint					searchParamsOffsetsLen;	//dwNumParameters
		public	uint[]					searchParamsOffsets;
		[WireInfo(SizeParam="searchParamsOffsetsLen")]
		public	XRLAttribParam[]		searchParams;

		protected override string GetServiceName()
		{
			return "/xmatch/xmatchClient.srf";
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			baseSearchSession.WriteStream(binaryWriter);
			if (searchParamsOffsets != null)
			{
				searchParamsOffsetsLen = (uint)searchParamsOffsets.Length;
				binaryWriter.Write(searchParamsOffsetsLen);
				for (int i = 0; i < searchParamsOffsetsLen; i++)
				{
					binaryWriter.Write(searchParamsOffsets[i]);
				}
				for (int i = 0; i < searchParams.Length; i++)
				{
					searchParams[i].WriteStream(binaryWriter);
				}
			}
			else
			{
				binaryWriter.Write(searchParamsOffsetsLen);
			}
		}

		public object DeepClone()
		{
			// Start with a shallow clone to avoid WireData::.ctor
			XRLSearchSession clone = (XRLSearchSession)this.MemberwiseClone();
			// Clone XRLPayload objects
			XRLPayload clonePayload = (XRLPayload)clone;
			base.DeepCloneTo(ref clonePayload);

			// Clone XRLSearchSession properties
			clone.baseSearchSession = (XRLBaseSearchSession)this.baseSearchSession.DeepClone();
			clone.searchParamsOffsetsLen = this.searchParamsOffsetsLen;
			if (this.searchParamsOffsets != null)
			{
				// Array of value types, built-in shallow clone is fine
				clone.searchParamsOffsets = (uint[])this.searchParamsOffsets.Clone();
			}
			if (this.searchParams != null)
			{
				clone.searchParams = new XRLAttribParam[this.searchParams.Length];
				for (int i = 0; i < this.searchParams.Length; i++)
				{
					clone.searchParams[i] = (XRLAttribParam)this.searchParams[i].DeepClone();
				}
			}
			return(clone);
		}

		/// <summary>
		/// create a search session request with specified spIndex
		/// </summary>
		/// <param name="spIndex">stored procedure index that used for search request</param>
		public XRLSearchSession(uint spIndex)
		{
			baseSearchSession = new XRLBaseSearchSession();
			baseSearchSession.dwMessageLength = Constants.SIZEBASESEARCH;
			baseSearchSession.wNumUsers = Constants.XONLINE_MAX_LOGON_USERS;
			baseSearchSession.wFlags = (ushort)Constants.XONLINE_NAT_TYPE.XONLINE_NAT_OPEN;
			baseSearchSession.dwTitleID = Constants.TITLE_ID;
			baseSearchSession.dwProcedureIndex = spIndex;
			baseSearchSession.ClientAddress = new XRLxnaddr();
			baseSearchSession.ClientAddress.ina = new byte[4]{0,0,0,0};
			baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x07,0x08,0x09,0x0a};
			baseSearchSession.ClientAddress.wPortOnline = 0x0506;
			baseSearchSession.ClientAddress.abEnet = new byte[6]{0x01,0x02,0x03,0x04,0x05,0x06};
//			baseSearchSession.ClientAddress.abOnline = new byte[20]{0x08,0x08,0x08,0x08,0x08,
//															   0x06,0x07,0x08,0x09,0x0a,
//															   0x0b,0x0c,0x0d,0x0e,0x0f,
//															   0x10,0x11,0x12,0x13,0x14};
			 baseSearchSession.ClientAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xbox).toByteArray();
			this.ServiceId = XOService.Matchmaking;
		}

		/// <summary>
		/// append search parameters at the end of search requests
		/// </summary>
		/// <param name="Params"></param>
		public void AddParams(XRLAttribParam[] Params)
		{
			// add searchParamsOffsets to the total length
			this.baseSearchSession.dwMessageLength += (uint)Params.Length * 4;

			// then add search parameters
			XRLIntParam		intTemp;
			XRLStringParam	stringTemp;
			XRLBlobParam	blobTemp;
			uint	dwNumParams = (uint)Params.Length;
			this.searchParamsOffsetsLen = dwNumParams;
			this.searchParamsOffsets = new uint[dwNumParams];
			this.searchParams = new XRLAttribParam[dwNumParams];
			this.searchParamsOffsets[0] = Constants.SIZEBASESEARCH + dwNumParams * 4;
			
			for(int i = 0; i < dwNumParams; i++)
			{
				if((intTemp = Params[i].aValue as XRLIntParam) != null)
				{
					this.baseSearchSession.dwMessageLength += 4+8;
					this.searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intTemp.intValue));
					if(i != (dwNumParams-1))
						this.searchParamsOffsets[i+1] = this.searchParamsOffsets[i]+4+8;
				}
				else if((stringTemp = Params[i].aValue as XRLStringParam) != null)
				{
					this.searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(stringTemp.strValue));
					if(i != (dwNumParams-1))
						this.searchParamsOffsets[i+1] = this.searchParamsOffsets[i]+4+2+stringTemp.strValueLen;
					// update total message length
					this.baseSearchSession.dwMessageLength += (uint)(4+2+stringTemp.strValueLen);
				}
				else if((blobTemp = Params[i].aValue as XRLBlobParam) != null)
				{
					this.searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobTemp.blob));
					if(i != (dwNumParams-1))
						this.searchParamsOffsets[i+1] = this.searchParamsOffsets[i]+4+2+blobTemp.blobLen;
					// update total message length
					this.baseSearchSession.dwMessageLength += (uint)(4+2+blobTemp.blobLen);
				}
				else if(Params[i].aValue as XRLNullParam != null)
				{
					this.searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam());
					if( i != (dwNumParams-1))
						this.searchParamsOffsets[i+1] = this.searchParamsOffsets[i]+4;
					// update total message length
					this.baseSearchSession.dwMessageLength += 4;
				}
			}
		}
		/// <summary>
		/// send searchSession http request to match front door and get response
		/// This one assumes nothing about search results. i.e. it works for both
		/// returned session with and without attributes.
		/// So it can be used by both functional and stress tests
		/// </summary>
		/// <param name="sServer">matchmaking front door</param>
		/// <param name="Response">search result</param>
		/// <returns></returns>
		public bool Execute(IPEndPoint sServer, out XRLSearchResults Response)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			Response = null;
			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					Response = new XRLSearchResults();
					MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
					// searchResults could be zero
					if(xAct.ResponseContents.Length != 0)
						Response.ReadStream(respBuff);
					else
						Response = null;
					uRet = true;
				}
			}
			return uRet;
		}
		/// <summary>
		/// For stress test, we don't care what's being returned in the search results
		/// </summary>
		/// <param name="sServer"></param>
		/// <param name="Response"></param>
		/// <returns></returns>
		public bool Execute(bool stress, IPEndPoint sServer, out XRLSearchResults Response)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			Response = null;
			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					uRet = true;
					if(stress == false)
					{
						Response = new XRLSearchResults();
						MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
						// searchResults could be zero
						if(xAct.ResponseContents.Length != 0)
							Response.ReadStream(respBuff);
						else
							Response = null;
					}
				}
			}
			return uRet;
		}
		/// <summary>
		/// send searchSession http request to matchmaking front door and get results back
		/// This one is used by functional test to check search results' details.
		/// </summary>
		/// <param name="sServer">matchmaking front door</param>
		/// <param name="dwExpectedNumResults">expected number of sessions in the searchResults</param>
		/// <param name="ExpectedAttribs">expected number of attributes in the returned session</param>
		/// <param name="Response">actual response got back from match servers</param>
		/// <returns></returns>
		public bool Execute(IPEndPoint sServer, uint dwExpectedNumResults,WireData []ExpectedAttribs, out XRLSearchResults Response)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			bool uRet = false;
			bool bRet=InternalExecute(sServer,reqStream);

			Response = null;
			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					Response = new XRLSearchResults();
					Response.results = new XRLSingleSearchResult[dwExpectedNumResults];
					MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
					// searchResults could be zero
					if(xAct.ResponseContents.Length != 0)
					{
						for(int j = 0; j < Response.results.Length; j++)
						{
							Response.results[j] = new XRLSingleSearchResult();
							Response.results[j].Attribs = new XRLAttribParam[ExpectedAttribs.Length];
							for(int i = 0; i < ExpectedAttribs.Length; i++)
							{
								if((ExpectedAttribs[i] as XRLIntParam) != null)
								{
									Response.results[j].Attribs[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,
																						new XRLIntParam());
								}
								else if((ExpectedAttribs[i] as XRLStringParam) != null)
								{
									Response.results[j].Attribs[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,
																						new XRLStringParam());
								}
								else if((ExpectedAttribs[i] as XRLBlobParam) != null)
								{
									Response.results[j].Attribs[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,
																						new XRLBlobParam());
								}
								else if((ExpectedAttribs[i] as XRLNullParam) != null)
								{
									Response.results[j].Attribs[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,
																						new XRLNullParam());
								}
							}
						}
						Response.ReadStream(respBuff);
					}
					else
						Response = null;
					uRet = true;
				}
			}
			return uRet;
		}
	}

	/// <summary>
	/// counterPart of XMATCH_SEARCH_RESULT
	/// </summary>
	public class XRLSingleSearchResult : WireData
	{
		public	uint		dwResultLength;
		[XRLPayloadFld(ArraySize=8)]
		public	byte[]		SessionID;
		public	XRLxnaddr	HostAddress;
		[XRLPayloadFld(ArraySize=16)]
		public	byte[]		KeyExchangeKey;
		public	uint		dwPublicOpen;
		public	uint		dwPrivateOpen;
		public	uint		dwPublicFilled;
		public	uint		dwPrivateFilled;
		public	uint		AttribOffsetsLen;	// dwNumAttributes
		public	uint[]		AttribOffsets;
		[WireInfo(SizeParam="AttribOffsetsLen")]
		public  XRLAttribParam[] Attribs;
	}

	/// <summary>
	/// XMATCH_SEARCHRESULT_HEADER + sessions returned
	/// </summary>
	public class XRLSearchResults : XRLPayload
	{
		public	uint				dwMessageLength;
		public	ushort				resultsLen;	// nNumSearchResults
		public	ushort				fFlags;
		public	uint				dwLoggingThreshold;
		public	XRLSingleSearchResult[]	results;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Matchmaking\XRLTitleChange.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Matchmaking
{
    /// <summary>
    /// Xenon: 1st new API for Xenon
    /// </summary>
    public class XRLTitleChange : XRLPayload
    {
        public ushort		wType;
        public ushort		cbEnt;
        public SGADDR		sgaddr;
        public uint			dwOldTitleID;
        public uint			dwNewTitleID;	// is the newTItleID being used somewhere???

        protected override string GetServiceName()
        {
            return "/xmatch/titlechange.ashx";
        }

        public XRLTitleChange()
        {
            this.wType = Constants.SGMSG_TYPE_NOTIFY_CLI_TCHG;
            this.cbEnt = (ushort) Constants.SIZETITLECHANGE;
            this.sgaddr = new SGADDR();
            this.dwOldTitleID = Constants.TITLE_ID;
            this.dwNewTitleID = this.dwOldTitleID + 1;	
            this.ServiceId = XOService.Matchmaking;
        }
        public XRLTitleChange(uint dwTitle)
        {
            this.wType = Constants.SGMSG_TYPE_NOTIFY_CLI_TCHG;
            this.cbEnt = (ushort) Constants.SIZETITLECHANGE;
            this.sgaddr = new SGADDR();
            this.dwOldTitleID = dwTitle;
            this.dwNewTitleID = dwTitle + 1;	
            this.ServiceId = XOService.Matchmaking;
        }
        /// <summary>
        /// send individual deadxbox request to matchmaking front door
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <returns></returns>
        public override bool Execute(IPEndPoint sServer)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(sServer,reqStream);

            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }

        /// <summary>
        /// send individual deadxbox request to matchmaking front door
        /// </summary>
        /// <param name="sServer">matchmaking front door</param>
        /// <returns></returns>
        public void BeginExecute(IPEndPoint sServer, AsyncCallback callback)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            BeginInternalExecute(sServer, reqStream, callback);
        }

        public bool EndExecute(IAsyncResult ar) {
            bool bRet = EndInternalExecute(ar);
            bool uRet = false;
            if( bRet )
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }
            return uRet;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\msnrr\msnrr.cs ===
using System;
using System.Net;
using System.Web.Services.Protocols;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.msnrr.single;
using ServerTestFramework.LiveService.msnrr.multi;
using ServerTestFramework.LiveService.msnrr.aggregator;

using xonline.common.config;


namespace ServerTestFramework.LiveService.msnrr
{
    public class MsnRRClient
    {
        public static void SaveRating(Guid contentTypeId, 
                                      object itemId, 
                                      long authorsPuid, 
                                      int ratingValue)
        {
            MsnRRServiceWrapper service = new MsnRRServiceWrapper();
            try 
            {
                service.SaveRating(contentTypeId, 
                                   itemId, 
                                   authorsPuid, 
                                   ratingValue);
            } 
            catch (MsnRRException) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        public static void GetRatingByUserWithAverage(
            Guid contentTypeId, 
            object itemId, 
            long puid, 
            out int userRating, 
            out float averageRating, 
            out int count)
        {
        
            MsnRRServiceWrapper service = new MsnRRServiceWrapper();
            try 
            {
                service.GetRatingByUserWithAverage(contentTypeId, 
                                                   itemId, 
                                                   puid, 
                                                   out userRating, 
                                                   out averageRating, 
                                                   out count);
            } 
            catch (MsnRRException) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        // returns true if there is more results (use transactionToken) 
        // or false if everything has been returned...
        public static bool GetRatingAverages(Guid contentTypeId, 
                                             DateTime fromTime, 
                                             ref string transactionToken, 
                                             out DateTime transactionStartTime,
                                             out XmlNode result)
        {
            MsnRRServiceWrapper service = new MsnRRServiceWrapper();
            try 
            {
                return service.GetRatingAverages(contentTypeId, 
                                                 fromTime, 
                                                 ref transactionToken, 
                                                 out transactionStartTime, 
                                                 out result);
            } 
            catch (MsnRRException) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }
    }



    public class MsnRRServiceWrapper
    {
        private SingleRating m_msnRRService;
        private Aggregator m_msnRRAggregatorService;

        /* ************************************************************** */
        /* **********                CTOR                     *********** */
        /* ************************************************************** */
        public MsnRRServiceWrapper()
        {
            m_msnRRService = new SingleRating();
            m_msnRRAggregatorService = new Aggregator();

            m_msnRRService.Url = 
                Config.GetSetting("msnrr_serviceSingleRatingUrl");
            m_msnRRService.PreAuthenticate = true; 

            m_msnRRAggregatorService.Url = 
                Config.GetSetting("msnrr_serviceAggregatorUrl");
            m_msnRRAggregatorService.PreAuthenticate = true;
        }
        
        /* ************************************************************** */
        /* **********                SINGLE RATING APIS       *********** */
        /* ************************************************************** */
        public void SaveRating(Guid contentTypeId, object itemId, long puid, int ratingValue)
        {
            try
            {
                m_msnRRService.Timeout = 30 * 1000;
                
                int returnCode = m_msnRRService.SaveRating(contentTypeId, itemId, (long)puid, Guid.Empty, ratingValue);
                
                MsnRRException error = MsnRRException.FromMsnRRReturnCode(returnCode);
                if(error != null) 
                {
                    throw error;
                }

                return;
            }
            catch (SoapException se)
            {
                MsnRRException e = MsnRRException.FromSoapException(se);
                throw e;
            }
            catch (WebException)
            {
                throw;
            }
        }



        public void GetRatingByUserWithAverage(Guid contentTypeId, object itemId, long puid, out int userRating, out float averageRating, out int count)
        {
            userRating = 0;
            averageRating = 0.0F;
            count = 0;

            try
            {
                int timeout = 30 * 1000;
                m_msnRRService.Timeout = timeout;


                int returnCode = m_msnRRService.GetRatingByUserWithAverage(contentTypeId, itemId, 
                    (long)puid, Guid.Empty, out userRating, out averageRating, out count);

                MsnRRException error = MsnRRException.FromMsnRRReturnCode(returnCode);
                if(error != null) 
                {
                    throw error;
                }

                return;
            }
            catch (SoapException se)
            {
                MsnRRException e = MsnRRException.FromSoapException(se);
                throw e;
            }
            catch (WebException)
            {
                throw;
            }
        }


        /* ************************************************************** */
        /* **********                AGGREGATOR   APIS         ********** */
        /* ************************************************************** */
        public bool GetRatingAverages(Guid contentTypeId, DateTime fromTime, 
            ref string transactionToken, out DateTime transactionStartTime, out XmlNode result)
        {
            bool hasMoreResults = false;

            transactionStartTime = DateTime.UtcNow;
            result = null;

            try
            {
                int timeout = 30 * 1000;
                m_msnRRAggregatorService.Timeout = timeout;


                int returnCode = m_msnRRAggregatorService.GetRatingAverages(contentTypeId, fromTime, false,
                    ref transactionToken, out transactionStartTime, out result);

                // resultCode == 0 means Method was successful, but not all items have been served
                // 20001 means : "Transaction is complete, all items have been served"
                if(returnCode == 0) 
                {
                    hasMoreResults = true;
                }

                MsnRRException error = MsnRRException.FromMsnRRReturnCode(returnCode);
                if(error != null) 
                {
                    throw error;
                }

                return hasMoreResults;
            }
            catch (SoapException se)
            {
                MsnRRException e = MsnRRException.FromSoapException(se);
                throw e;
            }
            catch (WebException)
            {
                throw;
            }
        }
    }

    public class MsnRRException : Exception
    {
        public MsnRRException(string message, SoapException e)
            : base(message, e)
        {
        }


        public static MsnRRException FromSoapException(SoapException e)
        {
            return new MsnRRException(e.Message, e);
        }

        public static MsnRRException FromMsnRRReturnCode(int returnCode)
        {
            switch(returnCode)
            {
                case 0: // means success in most cases
                case 20001: // means "Transaction is complete, all items have been served", another success case
                    return null;
                case 10003:
                    return new MsnRRException(
                        "Invalid content type id. This error also occurs if content type does not have a rating attribute or review field.",
                        null
                        );
                case 10005:
                    return new MsnRRException(
                        "Invalid item id",
                        null
                        );
                case 10007:
                    return new MsnRRException(
                        "Puid cannot be zero",
                        null
                        );
                case 10029:
                    return new MsnRRException(
                        "Content type has multiple rating attribute ids, use the Multiple Rating Interface.",
                        null
                        );
                case 20003:
                    return new MsnRRException(
                        "Token does not match request parameters, start over with no token.",
                        null
                        );
                case 99999:
                default:
                    return new MsnRRException(
                        "Unknown error",
                        null
                        );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\msnrr\msnrr-wsdl-aggregator.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.msnrr.aggregator {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AggregatorSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Aggregator : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAveragesWithReviewCountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesWithReviewCountOperationCompleted;
        
        /// <remarks/>
        public Aggregator() {
            this.Url = "http://rr.msn-int.com/rrwebservice/Aggregator.asmx";
        }
        
        /// <remarks/>
        public event GetRatingAveragesCompletedEventHandler GetRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesCompletedEventHandler GetDeltaRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingAveragesCompletedEventHandler GetUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaUnauthRatingAveragesCompletedEventHandler GetDeltaUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetRatingAveragesWithReviewCountCompletedEventHandler GetRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesWithReviewCountCompletedEventHandler GetDeltaRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesOperationCompleted == null)) {
                this.GetRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesOperationCompleted(object arg) {
            if ((this.GetRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesCompleted(this, new GetRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesOperationCompleted == null)) {
                this.GetDeltaRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesCompleted(this, new GetDeltaRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetUnauthRatingAveragesOperationCompleted == null)) {
                this.GetUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingAveragesCompleted(this, new GetUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetDeltaUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetDeltaUnauthRatingAveragesOperationCompleted == null)) {
                this.GetDeltaUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetDeltaUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaUnauthRatingAveragesCompleted(this, new GetDeltaUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAveragesWithReviewCo" +
            "unt", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesWithReviewCountCompleted(this, new GetRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAveragesWithRev" +
            "iewCount", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetDeltaRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesWithReviewCountCompleted(this, new GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesCompletedEventHandler(object sender, GetRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesCompletedEventHandler(object sender, GetDeltaRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingAveragesCompletedEventHandler(object sender, GetUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaUnauthRatingAveragesCompletedEventHandler(object sender, GetDeltaUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetDeltaRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\MsgDetails.cs ===
// MsgDetails.cs
//
//  Message details protocol data
//

using System;
using System.IO;
using System.Text;
using System.Collections;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    /// <summary>
    /// Message details data (a collection of Message Properties)
    /// </summary>
    public class MsgDetails : WireData
    {
        // Protocol Data
        public ushort        propertiesLen;
        public ushort        propertyDataLen;
        public MsgProperty[] properties;
        public byte[]        propertyData;

        /// <summary>
        /// Better than Size with a capital S that lives in WireData
        /// </summary>
        public ushort size
        {
            get
            {
                if( _writePropList != null )
                {
                    return (ushort)(4 + (_writePropList.Count * MsgProperty.size) + _writeData.Length);
                }
                else
                {
                    return (ushort)(4 + (propertiesLen * MsgProperty.size) + propertyDataLen);
                }
            }
        }

        // Dynamic storage used by "AddProperty" methods.
        private ArrayList    _writePropList = null;
        private MemoryStream _writeData     = null;
        private BinaryWriter _writer        = null;

        /// <summary>
        /// Create a blank set of message details that's ready to have properties added.
        /// Use of static factory, allows default constructor used by input serialization
        /// to not have to create the dynamic storage crap
        /// </summary>
        public static MsgDetails CreateBlank()
        {
            MsgDetails details      = new MsgDetails();
            details._writePropList  = new ArrayList();
            details._writeData      = new MemoryStream();
            details._writer         = new BinaryWriter( details._writeData, Encoding.UTF8 );
            details.properties      = new MsgProperty[0];
            details.propertyData    = new byte[0];

            return details;
        }

        /// <summary>
        /// Output serializion overload that first loads portocol data member variable form
        /// dynamic storage variable use by AddPorperty methods before calling base version
        /// </summary>
        /// <param name="binaryWriter">Output serializer</param>
        public override void WriteStream( BinaryWriter binaryWriter )
        {
            properties   = (MsgProperty[]) _writePropList.ToArray( typeof( MsgProperty ) );
            propertyData = _writeData.ToArray();

            base.WriteStream( binaryWriter );
        }


        /// <summary>
        /// Add a wrapped property type, the data will be extracted
        /// from the extra bytes and put into the details by way of
        /// another AddProperty call with the stored type.
        /// </summary>
        public void AddProperty(MsgPropertyWrapped wrappedProperty)
        {
            BinaryReader reader = null;

            switch(wrappedProperty.type)
            {
                case XonPresNoti.MSG_PROP_TYPE_NULL:
                    AddProperty(wrappedProperty.tag);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_I1:
                    AddProperty(wrappedProperty.tag, wrappedProperty.byteData);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_I2:
                    AddProperty(wrappedProperty.tag, wrappedProperty.wordData);
                    break;;

                case XonPresNoti.MSG_PROP_TYPE_I4:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt32());
                    break;

                case XonPresNoti.MSG_PROP_TYPE_I8:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt64());
                    break;

                case XonPresNoti.MSG_PROP_TYPE_STRING:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyString propString = new MsgPropertyString();
                    propString.ReadStream( reader );
                    AddProperty(wrappedProperty.tag, propString.s);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_FILETIME:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, DateTime.FromFileTime(reader.ReadInt64()));
                    break;

                case XonPresNoti.MSG_PROP_TYPE_BINARY:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyBinary propBinary = new MsgPropertyBinary();
                    propBinary.ReadStream(reader);
                    AddProperty(wrappedProperty.tag, propBinary.data);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
                    propAttach.ReadStream( reader );
                    AddProperty(wrappedProperty.tag, propAttach.cbAttach, propAttach.dwFlags, propAttach.url);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_BOOL:
                    AddProperty(wrappedProperty.tag, wrappedProperty.boolData);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt32());
                    break;

                default:
                    throw new Exception( "Can't convert wrapped property, invalid property type: " + wrappedProperty.type);
            }
        }

        /// <summary>
        /// Add an empty property
        /// </summary>
        /// <param name="tag">Property tag</param>
        public void AddProperty( ushort tag )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.data         = 0;

            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add an 8-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u8">8-bit value</param>
        public void AddProperty( ushort tag, byte u8 )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.byteData     = u8;

            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a 16-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u16">16-bit value</param>
        public void AddProperty( ushort tag, ushort u16 )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.wordData     = u16;

            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a 32-bit property
        /// (Also works for String Server ID's)
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u32">32-bit value</param>
        public void AddProperty( ushort tag, uint u32 )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( u32 );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a 64-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u64">64-bit value</param>
        public void AddProperty( ushort tag, ulong u64 )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( u64 );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a string property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="sz">String value</param>
        public void AddProperty( ushort tag, string sz )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyString propString = new MsgPropertyString();
            propString.s = sz;

            propString.WriteStream( _writer );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a DataTime property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="dt">DateTime value</param>
        public void AddProperty( ushort tag, DateTime dt )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( dt.ToFileTime() );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a Binary Blob property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="blob">Binary array</param>
        public void AddProperty( ushort tag, byte[] blob )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyBinary propBinary = new MsgPropertyBinary();
            propBinary.data = blob;

            propBinary.WriteStream( _writer );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add an Attachment property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="size"></param>
        /// <param name="flags"></param>
        /// <param name="url"></param>
        public void AddProperty( ushort tag, uint size, uint flags, string url )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyAttachment propAttachment = new MsgPropertyAttachment();
            propAttachment.cbAttach = size;
            propAttachment.dwFlags  = flags;
            propAttachment.url      = url;

            propAttachment.WriteStream( _writer );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a Bool property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="b">Bool value</param>
        public void AddProperty( ushort tag, bool b )
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.boolData     = b;

            _writePropList.Add( prop );
        }

        // Wraps binary property data blob for use by "Get" methodes
        private MemoryStream _propData = null;
        private BinaryReader _reader   = null;

        /// <summary>
        /// Input serialization that first loads up the protocol data members then set up
        /// buffer/reader wrapper for binary data blob
        /// </summary>
        /// <param name="binaryReader">Input serializer</param>
        /// <returns>Self</returns>
        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            _propData = new MemoryStream( propertyData );
            _reader   = new BinaryReader( _propData, Encoding.UTF8 );

            return this;
        }

        /// <summary>
        /// Checks if a Null type property is present.  Because this type of property has no data all
        /// we can do is see if it's there
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>true if property found and type is null</returns>
        public bool HasNullProperty( ushort tag )
        {
            try
            {
                byte index = GetPropertyIndex( tag );
                if( XonPresNoti.MSG_PROP_TYPE_NULL == properties[index].wPropTag.type )
                {
                    return true;
                }
            }
            catch( InvalidMsgPropertyException ) {}

            return false;
        }

        /// <summary>
        /// Returns the byte value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public byte GetByteProperty( ushort tag )
        {
            return (byte)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I1 );
        }

        /// <summary>
        /// Returns the word value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public ushort GetWordProperty( ushort tag )
        {
            return (ushort)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I2 );
        }

        /// <summary>
        /// Returns the dword value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public uint GetDwordProperty( ushort tag )
        {
            return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I4 );
        }

        /// <summary>
        /// Returns the qword value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public ulong GetQwordProperty( ushort tag )
        {
            return (ulong)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I8 );
        }

        /// <summary>
        /// Returns the string value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public string GetStringProperty( ushort tag )
        {
            return (string)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING );
        }

        /// <summary>
        /// Returns the DateTime value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public DateTime GetDateTimeProperty( ushort tag )
        {
            return (DateTime)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_FILETIME );
        }

        /// <summary>
        /// Returns the byte array value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public byte[] GetBinaryProperty( ushort tag )
        {
            return (byte[])GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BINARY );
        }

        /// <summary>
        /// Returns the Attachment info value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public MsgPropertyAttachment GetAttachmentProperty( ushort tag )
        {
            return (MsgPropertyAttachment)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_ATTACHMENT );
        }

        /// <summary>
        /// Returns the boolean value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public bool GetBoolProperty( ushort tag )
        {
            return (bool)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BOOL );
        }

        /// <summary>
        /// Returns the String ID value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public uint GetStringIdProperty( ushort tag )
        {
            return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING_ID );
        }

        /// <summary>
        /// Finds the index of a given property tag in the properties list
        /// </summary>
        /// <param name="tag">Property Id</param>
        /// <returns>Index into properties list</returns>
        public byte GetPropertyIndex( ushort tag )
        {
            for( byte i = 0; i < properties.Length; ++i )
            {
                if( properties[i].wPropTag.tag == tag )
                {
                    return i;
                }
            }

            throw new InvalidMsgPropertyException( null, "Msg Prop "+tag.ToString( "X04" )+" Not Found" );
        }

        public MsgProperty GetProperty(ushort tag)
        {
            for(byte i = 0; i < properties.Length; ++i)
            {
                if(properties[i].wPropTag.tag == tag)
                {
                    return properties[i];
                }
            }
            throw new InvalidMsgPropertyException( null, "Msg Prop "+tag.ToString( "X04" )+" Not Found" );
        }

        /// <summary>
        /// Returns the value of the property at given index as the type indicated in the property tag
        /// </summary>
        /// <param name="index">Index into MsgProperty array</param>
        /// <returns>Value of property in type specified by index</returns>
        public object GetPropertyData( byte index, byte type )
        {
            if( index >= properties.Length )
                throw new ArgumentOutOfRangeException( "index" );

            if( type != properties[index].wPropTag.type )
            {
                throw new InvalidMsgPropertyException( properties[index],
                    "Msg Prop "+properties[index].wPropTag.tag.ToString( "X04" )+" Invalid - "+
                    "Expected type: "+type+", Got type: "+properties[index].wPropTag.type );
            }

            // Create the reader if it doesn't exist yet
            if(null == _reader)
            {
                _propData = new MemoryStream( propertyData );
                _reader   = new BinaryReader( _propData, Encoding.UTF8 );
            }

            switch( type )
            {
                case XonPresNoti.MSG_PROP_TYPE_NULL:
                    throw new Exception( "Can't Get Property Data, Null properties have no value" );

                case XonPresNoti.MSG_PROP_TYPE_I1:
                    return properties[index].byteData;

                case XonPresNoti.MSG_PROP_TYPE_I2:
                    return properties[index].wordData;

                case XonPresNoti.MSG_PROP_TYPE_I4:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt32();

                case XonPresNoti.MSG_PROP_TYPE_I8:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt64();

                case XonPresNoti.MSG_PROP_TYPE_STRING:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyString propString = new MsgPropertyString();
                    propString.ReadStream( _reader );
                    return propString.s;

                case XonPresNoti.MSG_PROP_TYPE_FILETIME:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return DateTime.FromFileTime( _reader.ReadInt64() );

                case XonPresNoti.MSG_PROP_TYPE_BINARY:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyBinary propBinary = new MsgPropertyBinary();
                    propBinary.ReadStream( _reader );
                    return propBinary.data;

                case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
                    propAttach.ReadStream( _reader );
                    return propAttach;

                case XonPresNoti.MSG_PROP_TYPE_BOOL:
                    return properties[index].boolData;

                case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt32();

                default:
                    throw new Exception( "Can't Get Property, Invalid Prop Type: "+properties[index].wPropTag.type );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\MsgUtils.cs ===
// MsgUtils.cs
//
//	Utiliy classes and functions used by messaging that dont' have a better place to be
//

using System;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message notification flags in lower 24 bits and message type in upperbyte
	/// </summary>
	public class MsgNotification : WireData
	{
		MsgNotification( uint dw ) { dwTypeAndFlags = dw; }

		public uint dwTypeAndFlags;

		public byte type  {get{ return (byte)( dwTypeAndFlags >> 24 ); }}
		public uint flags {get{ return  dwTypeAndFlags & 0x00FFFFFF;   }}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Utility functions taken from macros found in xonlinep.h
	/// </summary>
	public class MsgUtility
	{
		public static bool IsMessageTransient( uint msgId )
		{
			return 0 != (msgId & XonPresNoti.MSG_ID_TRANSIENT_MESSAGE );
		}

		public static bool IsNotifyMsgType( byte type ) 
		{
			return (type == XonPresNoti.MSG_TYPE_GAME_INVITE);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Custom Exception class to carry and identify failures due to invalid message properties 
	/// </summary>
	public class InvalidMsgPropertyException : Exception
	{
		public MsgProperty Prop; 
		public InvalidMsgPropertyException( MsgProperty prop ) : base() { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message) : base(message) { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message, Exception inner) : base(message, inner) { Prop = prop; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\Message.cs ===
// Message.cs
//
//  Friendly wrapper for an invidual message
//

using System;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    public abstract class Message
    {
        public const uint MANY_RECIPIENTS = 0xffffffff;

        // Priority type, used to set appropiate flag
        public enum Priority { Normal, Required, Recomended }

        // Message data common to derived message types (sytem and user)
        public byte                 Type;
        public ulong                Context;
        public uint                 TitleID;
        public DateTime             SentTime;
        public ushort               ExpireMinutes;  // An offset in minutes from the sent time
        public string               SenderName;
        public uint                 Flags;
        public uint                 ID;             // ID may be MANY_RECIPIENTS when a message is sent to multiple recipients (see Recipients)
        public RecipientResult[]    Recipients;     // Set on Send()

        // Must be created to send or retrieved separately on recieve
        public MsgDetails Details;

        //////////////////////////////////////
        /// <summary>
        /// Checks current summary contents
        /// </summary>
        /// <param name="msg"></param>
        public void Check( Message msg )
        {
            ValueCheck.Test( "Type",          Type,          msg.Type );
            ValueCheck.Test( "Context",       Context,       msg.Context );
            ValueCheck.Test( "Title ID",      TitleID,       msg.TitleID );
            ValueCheck.Test( "ExpireMinutes", ExpireMinutes, msg.ExpireMinutes );
            ValueCheck.Test( "Flags",         Flags,         msg.Flags );
            ValueCheck.Test( "SenderName",    SenderName,    msg.SenderName );
            ValueCheck.Test( "ID",            ID,            msg.ID );
            ValueCheck.Test( "SentTime",      SentTime,      msg.SentTime, new TimeSpan(0, 1, 0));
        }

        /// <summary>
        /// Displays metadata about the message as a comma separated list of values
        /// </summary>
        /// <returns>Message metadata string</returns>
        public override string ToString()
        {
            return String.Format(
                "Type = {0}, Context = {1}, TitleID = 0x{2:X08}, ExpireMinutes = {3}, Flags = 0x{4:X08}, SenderName = \"{5}\", ID = {6}, SentTime = {7}",
                Type,
                Context,
                TitleID,
                ExpireMinutes,
                Flags,
                SenderName,
                ID,
                SentTime
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\MsgProperty.cs ===
// MsgProperty.cs
//
//	Message property protocol data
//
//
using System;
using System.IO;
using System.Text;

using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	/// <summary>
	/// Message Property tags occupy a word where the upper byte indicates the property's 
	/// data type, and the lower byte indicates a unique identifier for the property.
	/// Property identifiers only need to be unique within a given message type.
	/// </summary>
	public class MsgPropertyTag : WireData
	{
		public ushort tag;

		public const ushort size = 2;

		public static ushort Make( byte type, byte id ) 
		{ 
			return (ushort)( ((ushort)type << 8) | id ); 
		}
			
		public byte id   {get{ return (byte)( tag & 0xff ); }}
		public byte type {get{ return (byte)( tag >> 8 );   }}
	}

    
	/// <summary>
	/// Message Property contains the tag and a value who's meaning depends on property
	/// type. 
	/// </summary>
	public class MsgProperty : WireData
	{
		// This property's type and unique identifier
		public MsgPropertyTag wPropTag = new MsgPropertyTag();
		
		// Value depends on property type
		public ushort _data;     

		public const ushort size = MsgPropertyTag.size + 2;

        public byte id      { get { return wPropTag.id; } }
        public byte type    { get { return wPropTag.type; } }

        public ushort tag
        {
            get { return wPropTag.tag; }
            set { wPropTag.tag = value; }
        }

        public ushort data 
        {
            get { return _data; }
            set { _data = value; }
        }

		// For type XONLINE_MSG_PROP_TYPE_I2
		public ushort wordData 
		{
			get{ return _data;  }
			set{ _data = value; }
		}
		
		// For type XONLINE_MSG_PROP_TYPE_I1
		public byte byteData 
		{
			get{ return (byte)_data; }
			set{ _data = value;      }
		}

		// For type XONLINE_MSG_PROP_TYPE_BOOL
		public bool boolData 
		{
			get{ return _data == 1;       }
			set{ _data = (ushort)(value ? 1 : 0); }
		}
	
		// For all other types the offset from the start of MsgDeatails property data blob 
		public ushort offset 
		{
			get{ return _data;  }
			set{ _data = value; }
		}

        public static MsgPropertyWrapped NULLProperty()
        {
            return NULLProperty(1 | (XonPresNoti.MSG_PROP_TYPE_NULL << 8));
        }
        public static MsgPropertyWrapped NULLProperty(ushort tag)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.data = 0;
            return prop;
        }

        public static MsgPropertyWrapped I1Property(byte data)
        {
            return I1Property(1 | (XonPresNoti.MSG_PROP_TYPE_I2 << 8), data);
        }
        public static MsgPropertyWrapped I1Property(ushort tag, byte data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.byteData = data;
            return prop;
        }

        public static MsgPropertyWrapped I2Property(ushort data)
        {
            return I2Property(1 | (XonPresNoti.MSG_PROP_TYPE_I2 << 8), data);
        }
        public static MsgPropertyWrapped I2Property(ushort tag, ushort data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.wordData = data;
            return prop;
        }

        public static MsgPropertyWrapped I4Property(uint data)
        {
            return I4Property(1 | (XonPresNoti.MSG_PROP_TYPE_I4 << 8), data);
        }
        public static MsgPropertyWrapped I4Property(ushort tag, uint data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(4);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        public static MsgPropertyWrapped I8Property(ulong data)
        {
            return I8Property(1 | (XonPresNoti.MSG_PROP_TYPE_I8 << 8), data);
        }
        public static MsgPropertyWrapped I8Property(ushort tag, ulong data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(8);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        public static MsgPropertyWrapped StringProperty(string data)
        {
            return StringProperty(1 | (XonPresNoti.MSG_PROP_TYPE_STRING << 8), data);
        }
        public static MsgPropertyWrapped StringProperty(ushort tag, string data)
        {
            MsgPropertyString str = new MsgPropertyString();
            str.sLen = (ushort)data.Length;
            str.s = data;

            MsgPropertyWrapped prop = new MsgPropertyWrapped(str);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped FileTimeProperty(DateTime data)
        {
            return FileTimeProperty(1 | (XonPresNoti.MSG_PROP_TYPE_FILETIME << 8), data);
        }
        public static MsgPropertyWrapped FileTimeProperty(ushort tag, DateTime data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(8);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data.ToFileTime());
            return prop;
        }

        public static MsgPropertyWrapped BinaryProperty(byte [] data)
        {
            return BinaryProperty(1 | (XonPresNoti.MSG_PROP_TYPE_BINARY << 8), data);
        }

        public static MsgPropertyWrapped BinaryProperty(ushort tag, byte[] data)
        {
            MsgPropertyBinary binary = new MsgPropertyBinary();
            binary.dataLen = (ushort)data.Length;
            binary.data = data;
                
            MsgPropertyWrapped prop = new MsgPropertyWrapped(binary);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped AttachmentProperty(uint cbAttach, uint dwFlags, string url)
        {
            return AttachmentProperty(1 | (XonPresNoti.MSG_PROP_TYPE_ATTACHMENT << 8), cbAttach, dwFlags, url);
        }

        public static MsgPropertyWrapped AttachmentProperty(ushort tag, uint cbAttach, uint dwFlags, string url)
        {
            MsgPropertyAttachment attachment = new MsgPropertyAttachment();
            attachment.cbAttach = cbAttach;
            attachment.dwFlags = dwFlags;
            attachment.urlLen = (uint)url.Length;
            attachment.url = url;

            MsgPropertyWrapped prop = new MsgPropertyWrapped(attachment);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped BoolProperty(bool data)
        {
            return BoolProperty(1 | (XonPresNoti.MSG_PROP_TYPE_BOOL << 8), data);
        }
        public static MsgPropertyWrapped BoolProperty(ushort tag, bool data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.boolData = data;
            return prop;
        }
        
        public static MsgPropertyWrapped StringIdProperty(uint data)
        {
            return StringIdProperty(1 | (XonPresNoti.MSG_PROP_TYPE_STRING_ID << 8), data);
        }
        public static MsgPropertyWrapped StringIdProperty(ushort tag, uint data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(4);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        /// <summary>
        /// Do a specific read for the type of data stored in this property. If it
        /// exists outside this property than it must preceed this property in the
        /// stream. This is the case for msg properties passed as parameters in
        /// wire protocol. For handling a group of properties in a details blob
        /// use MsgDetails.GetPropertyData() which can handle the stream seek and object
        /// conversion.
        /// </summary>
        public byte[] ReadExtraData(BinaryReader reader)
        {
            byte []exdata = new byte[0];

            switch(wPropTag.type)
			{
				case XonPresNoti.MSG_PROP_TYPE_NULL:
				case XonPresNoti.MSG_PROP_TYPE_BOOL:
				case XonPresNoti.MSG_PROP_TYPE_I1:
				case XonPresNoti.MSG_PROP_TYPE_I2:
                    // Types under 2 bytes are stored directly in the property data
                    break;
				case XonPresNoti.MSG_PROP_TYPE_I4:
				case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    exdata = reader.ReadBytes(4);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_FILETIME:
				case XonPresNoti.MSG_PROP_TYPE_I8:
                    exdata = reader.ReadBytes(8);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_STRING:
                    MsgPropertyString propString = new MsgPropertyString();
                    exdata = (byte[])propString.ReadStream(reader);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_BINARY:
					MsgPropertyBinary propBinary = new MsgPropertyBinary();
					exdata = (byte[])propBinary.ReadStream(reader);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
					MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
					exdata = (byte[])propAttach.ReadStream(reader);
					break;
				default:
					throw new StfException( "Invalid property type:  " + wPropTag.type.ToString("x"));
			}

            return exdata;
        }
	}

    /// <summary>
    ///  Wraps a message property with some extra data to hold
    ///  the actual property data. This can be used for passing
    ///  around properties and using them for parameters to APIs
    ///  such as RevokeMsgEx
    /// </summary>
    public class MsgPropertyWrapped : WireData
    {
        public MsgProperty Property;
        [WireInfo(ArraySize=0)]
        public byte[]      ExtraData;

        public ushort tag {
            get { return Property.tag; }
            set { Property.tag = value; }
        }

        public ushort data {
            get { return Property.data; }
            set { Property.data = value; }
        }

        public byte byteData {
            get { return Property.byteData; }
            set { Property.byteData = value; }
        }

        public ushort wordData {
            get { return Property.wordData; }
            set { Property.wordData = value; }
        }

        public bool boolData {
            get { return Property.boolData; }
            set { Property.boolData = value; }
        }

        public byte type {
            get { return Property.type; }
        }

        /// <summary>
        /// Create the wrapped msg property, allocate cb extra
        /// bytes for the payload.
        /// </summary>
        public MsgPropertyWrapped(uint cb)
        {
            Property  = new MsgProperty();
            ExtraData = new byte[cb];
        }

        /// <summary>
        /// Create the wrapped message property, the extra
        /// wire data will be serialized new into the payload
        /// of this property.
        /// </summary>
        public MsgPropertyWrapped(WireData extraWireData)
        {
            Property = new MsgProperty();

            // Allocate the extra buffer to hold the wiredata
            // and serialize into this buffer
            uint cbytes = (uint)extraWireData.Size();
            ExtraData = new byte[cbytes];
            BinaryWriter writer = new BinaryWriter(new MemoryStream(ExtraData));
            extraWireData.WriteStream(writer);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            // Read the property object and get extra fixed or variable length
            // data stored after the property.
            Property.ReadStream(reader);
            ExtraData = Property.ReadExtraData(reader);
            return this;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            // Write the property and then the extra data
            // immediately after
            Property.WriteStream(writer);
            writer.Write(ExtraData);
        }

        /// <summary>
        /// Return a writer that allows writing to the allocated
        /// extra block. 
        /// </summary>
        public BinaryWriter GetWriter()
        {
            return new BinaryWriter(new MemoryStream(ExtraData), Encoding.UTF8);
        }
        /// <summary>
        /// Return a reader that allows reading from the
        /// extra block.
        /// </summary>
        public BinaryReader GetReader()
        {
            return new BinaryReader(new MemoryStream(ExtraData));
        }

    }

	/// <summary>
	/// Format of MSG_PROP_TYPE_BINARY property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyBinary : WireData
	{
		public ushort dataLen;
		public byte[] data;
	}

	/// <summary>
	/// Format of MSG_PROP_TYPE_ATTACHMENT property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyAttachment : WireData
	{
		public uint   cbAttach;
		public uint   dwFlags;
		public uint   urlLen;
		[WireInfo(NullTerminated=true)] 
		public string url;
	}

	/// <summary>
	/// Format of MSG_PROP_TYPE_STRING property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyString : WireData
	{
		public ushort sLen;
        [WireInfo(NullTerminated = true)]
		public string s;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgAdd.cs ===
// QMsgAdd.cs
//
//	Notification Add Item Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Tell Notificaion to add a new item of the given item type to one or more users' 
	/// queues. (Only needed when isolating notification.  Presence normally does this 
	/// for it's QTypes.)
	/// </summary>
	public class QMsgAdd : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="qType">One of the available Message Queue types</param></param>
		/// <param name="users">PUIDS of users to get Message</param>
		/// <param name="itemData">Message Data</param>
		public QMsgAdd( ushort qType, ulong[] users, byte[] itemData )
		{
			SentFrom    = Requestor.PresInh;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ADD;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			QAddMsgData data = new QAddMsgData();
			data.QType    = qType;
			data.Users    = users;
			data.ItemData = itemData;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add request
	/// </summary>
	public class QAddMsgData : PNMsgData
	{
		public ushort  QType; // const: PQUEUE_xxx
		public ushort  UsersLen; 
		public ulong[] Users;
		public byte[]  ItemData;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\msnrr\msnrr-wsdl-multiple-rating.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.msnrr.multi {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MultiRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class MultiRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public MultiRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/multirating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out Rating[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out Rating[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, out ValidationError[] errors) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ValidationError {
        
        private Field dataFieldField;
        
        private Type codeField;
        
        private System.Guid idField;
        
        private int maxLengthField;
        
        /// <remarks/>
        public Field DataField {
            get {
                return this.dataFieldField;
            }
            set {
                this.dataFieldField = value;
            }
        }
        
        /// <remarks/>
        public Type Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Field {
        
        /// <remarks/>
        empty,
        
        /// <remarks/>
        nickname,
        
        /// <remarks/>
        ratingItemID,
        
        /// <remarks/>
        reviewFieldID,
        
        /// <remarks/>
        title,
        
        /// <remarks/>
        customProperty,
        
        /// <remarks/>
        name,
        
        /// <remarks/>
        email,
        
        /// <remarks/>
        comments,
        
        /// <remarks/>
        score,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Type {
        
        /// <remarks/>
        RequiredFieldMissing,
        
        /// <remarks/>
        TextTooLong,
        
        /// <remarks/>
        TextInvalidChars,
        
        /// <remarks/>
        TextProfanity,
        
        /// <remarks/>
        InvalidFormat,
        
        /// <remarks/>
        TooManyChanges,
        
        /// <remarks/>
        AlreadyTaken,
        
        /// <remarks/>
        ReviewsRequireRatings,
        
        /// <remarks/>
        ReviewsRequireOneField,
        
        /// <remarks/>
        UserCannotRateOwnReview,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Helpfulness {
        
        private int countField;
        
        private int sumField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private bool currentUserField;
        
        private bool currentUserFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Sum {
            get {
                return this.sumField;
            }
            set {
                this.sumField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool CurrentUser {
            get {
                return this.currentUserField;
            }
            set {
                this.currentUserField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CurrentUserSpecified {
            get {
                return this.currentUserFieldSpecified;
            }
            set {
                this.currentUserFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ReviewField {
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int maxLengthField;
        
        private bool maxLengthFieldSpecified;
        
        private int colsField;
        
        private bool colsFieldSpecified;
        
        private int rowsField;
        
        private bool rowsFieldSpecified;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        private string descriptionField;
        
        private string valueField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool MaxLengthSpecified {
            get {
                return this.maxLengthFieldSpecified;
            }
            set {
                this.maxLengthFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Cols {
            get {
                return this.colsField;
            }
            set {
                this.colsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ColsSpecified {
            get {
                return this.colsFieldSpecified;
            }
            set {
                this.colsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rows {
            get {
                return this.rowsField;
            }
            set {
                this.rowsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RowsSpecified {
            get {
                return this.rowsFieldSpecified;
            }
            set {
                this.rowsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class User {
        
        private string nicknameField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Nickname {
            get {
                return this.nicknameField;
            }
            set {
                this.nicknameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Review {
        
        private ItemID itemField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private User userField;
        
        private ReviewField customPropertyField;
        
        private Rating ratingField;
        
        private ReviewField titleField;
        
        private ReviewField[] fieldField;
        
        private Helpfulness helpfulnessField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public User User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField CustomProperty {
            get {
                return this.customPropertyField;
            }
            set {
                this.customPropertyField = value;
            }
        }
        
        /// <remarks/>
        public Rating Rating {
            get {
                return this.ratingField;
            }
            set {
                this.ratingField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Field")]
        public ReviewField[] Field {
            get {
                return this.fieldField;
            }
            set {
                this.fieldField = value;
            }
        }
        
        /// <remarks/>
        public Helpfulness Helpfulness {
            get {
                return this.helpfulnessField;
            }
            set {
                this.helpfulnessField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ItemID {
        
        private string stringIDField;
        
        private long[] longIDField;
        
        private System.Guid guidIDField;
        
        private bool guidIDFieldSpecified;
        
        /// <remarks/>
        public string StringID {
            get {
                return this.stringIDField;
            }
            set {
                this.stringIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LongID")]
        public long[] LongID {
            get {
                return this.longIDField;
            }
            set {
                this.longIDField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid GuidID {
            get {
                return this.guidIDField;
            }
            set {
                this.guidIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool GuidIDSpecified {
            get {
                return this.guidIDFieldSpecified;
            }
            set {
                this.guidIDFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Rating {
        
        private ItemID itemField;
        
        private RatingAttribute[] ratingItemField;
        
        private OverallRating overallRatingField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private int totalCountField;
        
        private bool totalCountFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RatingItem")]
        public RatingAttribute[] RatingItem {
            get {
                return this.ratingItemField;
            }
            set {
                this.ratingItemField = value;
            }
        }
        
        /// <remarks/>
        public OverallRating OverallRating {
            get {
                return this.overallRatingField;
            }
            set {
                this.overallRatingField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int TotalCount {
            get {
                return this.totalCountField;
            }
            set {
                this.totalCountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool TotalCountSpecified {
            get {
                return this.totalCountFieldSpecified;
            }
            set {
                this.totalCountFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingAttribute : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private int userValueField;
        
        private bool userValueFieldSpecified;
        
        private int countField;
        
        private bool countFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CountSpecified {
            get {
                return this.countFieldSpecified;
            }
            set {
                this.countFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OverallRating))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingAttribute))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingItem {
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private string descriptionField;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class OverallRating : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private float userValueField;
        
        private bool userValueFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgDeleteMsg.cs ===
// QMsgDeleteMsg.cs
//
//	Notification (Messaging) Delete Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete message for a user
	/// </summary>
	public class QMsgDeleteMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="msgId">Id of message</param>
		/// <param name="flags"></param>
		public QMsgDeleteMsg( PNUser user, uint msgId, uint flags )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QDeleteMsgMsgData data = new QDeleteMsgMsgData();
			data.UserID    = user.UserId;
			data.MessageID = msgId;
			data.Flags     = flags;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Msg request
	/// </summary>
	public class QDeleteMsgMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
		public uint  Flags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Msg reply
	/// </summary>
	public class QDeleteMsgReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgDeleteTitle.cs ===
// QMsgDeleteTitle.cs
//
//	Notification (Messaging) Delete Title Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete title
	/// </summary>
	public class QMsgDeleteTitle : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		/// <param name="titleId">Id of title</param>
		public QMsgDeleteTitle( PNUser user, uint titleId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_TITLE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QDeleteTitleMsgData data = new QDeleteTitleMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Title request
	/// </summary>
	public class QDeleteTitleMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Title reply
	/// </summary>
	public class QDeleteTitleReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\msnrr\msnrr-wsdl-single-rating.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.msnrr.single {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SingleRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class SingleRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public SingleRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/singlerating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out int rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int userRating, out float averageRating, out int count) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out int userRating, out float averageRating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out int[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out int[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIDs, reviewFieldValues, ratingValue, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ValidationError {
        
        private Field dataFieldField;
        
        private Type codeField;
        
        private System.Guid idField;
        
        private int maxLengthField;
        
        /// <remarks/>
        public Field DataField {
            get {
                return this.dataFieldField;
            }
            set {
                this.dataFieldField = value;
            }
        }
        
        /// <remarks/>
        public Type Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Field {
        
        /// <remarks/>
        empty,
        
        /// <remarks/>
        nickname,
        
        /// <remarks/>
        ratingItemID,
        
        /// <remarks/>
        reviewFieldID,
        
        /// <remarks/>
        title,
        
        /// <remarks/>
        customProperty,
        
        /// <remarks/>
        name,
        
        /// <remarks/>
        email,
        
        /// <remarks/>
        comments,
        
        /// <remarks/>
        score,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Type {
        
        /// <remarks/>
        RequiredFieldMissing,
        
        /// <remarks/>
        TextTooLong,
        
        /// <remarks/>
        TextInvalidChars,
        
        /// <remarks/>
        TextProfanity,
        
        /// <remarks/>
        InvalidFormat,
        
        /// <remarks/>
        TooManyChanges,
        
        /// <remarks/>
        AlreadyTaken,
        
        /// <remarks/>
        ReviewsRequireRatings,
        
        /// <remarks/>
        ReviewsRequireOneField,
        
        /// <remarks/>
        UserCannotRateOwnReview,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Helpfulness {
        
        private int countField;
        
        private int sumField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private bool currentUserField;
        
        private bool currentUserFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Sum {
            get {
                return this.sumField;
            }
            set {
                this.sumField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool CurrentUser {
            get {
                return this.currentUserField;
            }
            set {
                this.currentUserField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CurrentUserSpecified {
            get {
                return this.currentUserFieldSpecified;
            }
            set {
                this.currentUserFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ReviewField {
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int maxLengthField;
        
        private bool maxLengthFieldSpecified;
        
        private int colsField;
        
        private bool colsFieldSpecified;
        
        private int rowsField;
        
        private bool rowsFieldSpecified;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        private string descriptionField;
        
        private string valueField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool MaxLengthSpecified {
            get {
                return this.maxLengthFieldSpecified;
            }
            set {
                this.maxLengthFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Cols {
            get {
                return this.colsField;
            }
            set {
                this.colsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ColsSpecified {
            get {
                return this.colsFieldSpecified;
            }
            set {
                this.colsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rows {
            get {
                return this.rowsField;
            }
            set {
                this.rowsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RowsSpecified {
            get {
                return this.rowsFieldSpecified;
            }
            set {
                this.rowsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class User {
        
        private string nicknameField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Nickname {
            get {
                return this.nicknameField;
            }
            set {
                this.nicknameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Review {
        
        private ItemID itemField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private User userField;
        
        private ReviewField customPropertyField;
        
        private Rating ratingField;
        
        private ReviewField titleField;
        
        private ReviewField[] fieldField;
        
        private Helpfulness helpfulnessField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public User User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField CustomProperty {
            get {
                return this.customPropertyField;
            }
            set {
                this.customPropertyField = value;
            }
        }
        
        /// <remarks/>
        public Rating Rating {
            get {
                return this.ratingField;
            }
            set {
                this.ratingField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Field")]
        public ReviewField[] Field {
            get {
                return this.fieldField;
            }
            set {
                this.fieldField = value;
            }
        }
        
        /// <remarks/>
        public Helpfulness Helpfulness {
            get {
                return this.helpfulnessField;
            }
            set {
                this.helpfulnessField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ItemID {
        
        private string stringIDField;
        
        private long[] longIDField;
        
        private System.Guid guidIDField;
        
        private bool guidIDFieldSpecified;
        
        /// <remarks/>
        public string StringID {
            get {
                return this.stringIDField;
            }
            set {
                this.stringIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LongID")]
        public long[] LongID {
            get {
                return this.longIDField;
            }
            set {
                this.longIDField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid GuidID {
            get {
                return this.guidIDField;
            }
            set {
                this.guidIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool GuidIDSpecified {
            get {
                return this.guidIDFieldSpecified;
            }
            set {
                this.guidIDFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Rating {
        
        private ItemID itemField;
        
        private RatingAttribute[] ratingItemField;
        
        private OverallRating overallRatingField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private int totalCountField;
        
        private bool totalCountFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RatingItem")]
        public RatingAttribute[] RatingItem {
            get {
                return this.ratingItemField;
            }
            set {
                this.ratingItemField = value;
            }
        }
        
        /// <remarks/>
        public OverallRating OverallRating {
            get {
                return this.overallRatingField;
            }
            set {
                this.overallRatingField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int TotalCount {
            get {
                return this.totalCountField;
            }
            set {
                this.totalCountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool TotalCountSpecified {
            get {
                return this.totalCountFieldSpecified;
            }
            set {
                this.totalCountFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingAttribute : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private int userValueField;
        
        private bool userValueFieldSpecified;
        
        private int countField;
        
        private bool countFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CountSpecified {
            get {
                return this.countFieldSpecified;
            }
            set {
                this.countFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OverallRating))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingAttribute))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingItem {
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private string descriptionField;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class OverallRating : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private float userValueField;
        
        private bool userValueFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int userRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public float averageRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgDequeue.cs ===
// QMsgDequeue.cs
//
//	Notification Dequeue Message
//

using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Retrieves and deletes notificaion messege queue items for a user
	/// </summary>
	public class QMsgDequeue : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of queue</param>
		/// <param name="qType">One of the available Message Queue types (see XonPresNoti)</param>
		public QMsgDequeue( PNUser user, ushort qType )  : this(user, qType, 0, 100, UInt16.MaxValue)
		{
		}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of queue</param>
		/// <param name="qType">One of the available Message Queue types (see XonPresNoti)</param>
		/// <param name="startItemID">First queue item in list to dequeue</param>
		/// <param name="maxItems">The maximum number of items that can dequeue</param>
		/// <param name="maxTotalItemDataSize">The maximum number of bytes to allocate for the item buffer on the server</param>
		public QMsgDequeue( PNUser user, ushort qType, uint startItemID, ushort maxItems, uint maxTotalItemDataSize)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Notification;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DEQUEUE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QDequeueMsgData data = new QDequeueMsgData();
			data.UserID               = user.UserId;
			data.QType                = qType;
			data.StartItemID          = startItemID;
			data.MaxItems             = maxItems;
			data.MaxTotalItemDataSize = maxTotalItemDataSize;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dequeue request
	/// </summary>
	public class QDequeueMsgData : PNMsgData
	{
		public ulong  UserID;
		public ushort QType; // const: PQUEUE_xxx
		public uint   StartItemID;
		public ushort MaxItems;
		public uint   MaxTotalItemDataSize;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Top level of message data specific to Dequeue reply
	/// </summary>
	public class QDequeueReplyMsgData : PNMsgData
	{
		public ListReplyHdr Hdr;
		public ushort       ItemsLen;
		public ListItem[]   Items;

		public override WireData ReadStream( BinaryReader reader )
		{
			Hdr = (ListReplyHdr) new ListReplyHdr().ReadStream( reader );
			ItemsLen = Hdr.ItemsLen;
			Items = new ListItem[ ItemsLen ];
			
			for( int i = 0; i < Items.Length; i++ )
			{
				Items[i] = new ListItem();
				Items[i].Hdr = new ListItemHdr();
				Items[i].Hdr.ReadStream( reader );

				// Get rest of data from stream
				byte[] itemData = new byte[ Items[i].Hdr.ItemLen ];
				reader.Read( itemData, 0, itemData.Length );

				switch( Hdr.QType )
				{
					case XonPresNoti.PQUEUE_PRESENCE:
						Items[i].Data = new PresenceItem();
						break;

					case XonPresNoti.PQUEUE_BUDDY_REQ:
					case XonPresNoti.PQUEUE_LIST_CHANGE:
						Items[i].Data = new ListChangeItem();
						break;

					case XonPresNoti.PQUEUE_INVITE:
						Items[i].Data = new InvitationItem();
						break;
					
					case XonPresNoti.PQUEUE_INVITE_ANSWER:
						Items[i].Data = new InvitationAnswerItem();
						break;

					case XonPresNoti.PQUEUE_PEER_PRESENCE:
						Items[i].Data = new PeerPresenceItem();
						break;
					
					case XonPresNoti.PQUEUE_PRESENCE_2:
						Items[i].Data = new Presence2Item();
						break;
					
					default:
						throw new Exception( "List reply queue type unknown" );
				}
				Items[i].Data.ReadBytes( itemData );
			}

			return this;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Header portion of message data specific to Dequeue reply.
	/// </summary>
	public class ListReplyHdr : WireData
	{
		public ulong     UserID;
		public ushort    QType;
		public uint      HR;
		public uint      NextItemID;
		public ushort    QLeft;
		public ushort    ItemsLen;
		public uint      TotalItemDataSize;
		public uint	     QValsLen;
		public uint[]    QVals;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Top level of List Item. One or more of these follow ListReplyHdr in message data 
	/// specific to Dequeue reply.
	/// </summary>
	public class ListItem	
	{
		public ListItemHdr  Hdr;
		public ListItemData Data;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common header for all QType specific list items
	/// </summary>
	public class ListItemHdr : WireData
	{
		public uint   ItemID;
		public ushort ItemLen;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Base class for QType specific list items
	/// </summary>
	abstract public class ListItemData : WireData
	{
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Presence list item specific data
	/// </summary>
	public class PresenceItem : ListItemData
	{
		public ulong  BuddyID;
		public uint   TitleID;
		public uint   State;
		public ulong  MatchSessionID;
		public ushort NicknameLen;
		public ushort TitleStuffLen;
		public byte[] Nickname;
		public byte[] TitleStuff;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Presence2 list item specific data
	/// </summary>
	public class Presence2Item : ListItemData
	{
		public ulong    BuddyID;
		public uint     TitleID;
		public uint     State;
		public ulong    MatchSessionID;
        public uint     BuddyStateTime;        
        public ushort   RichPresenceLen;
        public ushort   DataLen;
        public string   RichPresence;        
        public byte[]   Data;
		
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Peer Presence list item specific data
	/// </summary>
	public class PeerPresenceItem : ListItemData
	{
		public ulong  UserID;
		public uint   TitleID;
		public uint   State;
		public ulong  MatchSessionID;
		public ushort TitleStuffLen;
		public byte[] TitleStuff;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// List Change list item specific data. (Also used for buddy requests.)
	/// </summary>
	public class ListChangeItem : ListItemData
	{
		public uint   ListVersion;
		public ulong  TargetID;
		public ushort OperationID; // const: PLIST_BUDDY_xxx
		public uint   HR;
		public ushort TargetAcctNameLen;
		public string TargetAcctName;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inivitation list item specific data
	/// </summary>
	public class InvitationItem : ListItemData
	{
		public ulong       HostID;
		public ulong       MatchSessionID;
		public uint        TitleID;
		public DateTime    TimeSent;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inivitation Answer list item specific data
	/// </summary>
	public class InvitationAnswerItem : ListItemData
	{
		public ulong       InviteeID;
		public ulong       MatchSessionID;
		public DateTime    TimeSent;
		public ushort      Answer; // const: PINVITE_REPLY_xxx
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgEnumMsgs.cs ===
// QMsgEnumMsgs.cs
//
//	Notification (Messaging) Enumerate Messages message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerates messages for a user
	/// </summary>
	public class QMsgEnumMsgs : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User messages are to</param>
		public QMsgEnumMsgs( PNUser user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QEnumMsgsMsgData data = new QEnumMsgsMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs request
	/// </summary>
	public class QEnumMsgsMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs reply
	/// </summary>
	public class QEnumMsgsReplyMsgData : PNMsgData
	{
		public uint             HR;
		public ushort           MessagesLen;
		public UserMsgSummary[] Messages;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgDetails.cs ===
// QMsgDetails.cs
//
//    Notification (Messaging) Details Message
//

using System;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Get details of specified message for a user
    /// </summary>
    public class QMsgDetails : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">Owner of message</param>
        /// <param name="msgId">Id of message</param>
        /// <param name="setFlags"></param>
        /// <param name="unsetFlags"></param>
        public QMsgDetails( PNUser user, uint msgId, uint setFlags, uint unsetFlags )
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.Messaging;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Messaging;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_DETAILS;
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

            QDetailsMsgData data = new QDetailsMsgData();
            data.UserID     = user.UserId;
            data.MessageID  = msgId;
            data.SetFlags   = setFlags;
            data.UnsetFlags = unsetFlags;
            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Details request
    /// </summary>
    public class QDetailsMsgData : PNMsgData
    {
        public ulong UserID;
        public uint  MessageID;
        public uint  SetFlags;
        public uint  UnsetFlags;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Details reply
    /// </summary>
    public class QDetailsReplyMsgData : PNMsgData
    {
        public uint           HR;
        public UserMsgSummary Summary;
        public MsgDetails     Details;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            // Read HR
            HR = binaryReader.ReadUInt32();

            // Read summary
            Summary = new UserMsgSummary();
            Summary.ReadStream(binaryReader);

            // Conditionally read details
            if(Summary.cbDetails > 0)
            {
                Details = new MsgDetails();
                Details.ReadStream(binaryReader);
            }

            return this;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgDeleteSystemMsg.cs ===
// QMsgDeleteSystemMsg.cs
//
//	Notification (Messaging) Delete System Msg message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete specified system message
	/// </summary>
	public class QMsgDeleteSystemMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="titleId">Title responsible for message</param>
		/// <param name="msgId">Id of message</param>
		public QMsgDeleteSystemMsg( uint titleId, uint msgId, bool RevokeAlso )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_SYSTEM_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			QDeleteSystemMsgMsgData data = new QDeleteSystemMsgMsgData();
			data.TitleID = titleId;
			data.MsgID   = msgId;
			data.Flags   = RevokeAlso ? XonPresNoti.DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL : 0x0;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete System Msg request
	/// </summary>
	public class QDeleteSystemMsgMsgData : PNMsgData
	{
		public uint TitleID;
		public uint MsgID;
		public uint Flags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete System Msg reply
	/// </summary>
	public class QDeleteSystemMsgReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgEnumMsgs2.cs ===
// QMsgEnumMsgs.cs
//
//	Notification (Messaging) Enumerate Messages message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerates messages for a user
	/// </summary>
	public class QMsgEnumMsgs2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User messages are to</param>
		public QMsgEnumMsgs2( PNUser user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_MESSAGES_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QEnumMsgs2MsgData data = new QEnumMsgs2MsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs request
	/// </summary>
	public class QEnumMsgs2MsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs reply
	/// </summary>
	public class QEnumMsgs2ReplyMsgData : PNMsgData
	{
		public uint             HR;
		public ushort           MessagesLen;
		public UserMsgSummary2[] Messages;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgEnumSystemMsgs.cs ===
// QMsgEnumSystemMsgs.cs
//
//	Notification (Messaging) Enumerate System Messages Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerate non user specific messages for a particular title. 
	/// System will be 0 or Dash title ID - TBD.
	/// </summary>
	public class QMsgEnumSystemMsgs : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="titleId">Title responsible for message</param>
		public QMsgEnumSystemMsgs( uint titleId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_SYSTEM_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			QEnumSystemMsgsMsgData data = new QEnumSystemMsgsMsgData();
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate System Msgs request
	/// </summary>
	public class QEnumSystemMsgsMsgData : PNMsgData
	{
		public uint TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate System Msgs reply
	/// </summary>
	public class QEnumSystemMsgsReplyMsgData : PNMsgData
	{
		public uint               HR;
		public ushort             SummariesLen;
		public SystemMsgSummary[] Summaries;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgFlags.cs ===
// QMsgFlags.cs
//
//    Notification (Messaging) Flags Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Set flags of specified message for a user
    /// </summary>
    public class QMsgFlags : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">Owner of message</param>
        /// <param name="msgId">Id of message</param>
        /// <param name="setFlags"></param>
        /// <param name="unsetFlags"></param>
        public QMsgFlags( PNUser user, uint msgId, uint setFlags, uint unsetFlags )
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.Messaging;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Messaging;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_FLAGS;
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

            QFlagsMsgData data = new QFlagsMsgData();
            data.UserID     = user.UserId;
            data.MessageID  = msgId;
            data.SetFlags   = setFlags;
            data.UnsetFlags = unsetFlags;
            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Flags request
    /// </summary>
    public class QFlagsMsgData : PNMsgData
    {
        public ulong UserID;
        public uint  MessageID;
        public uint  SetFlags;
        public uint  UnsetFlags;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Flags reply
    /// </summary>
    public class QFlagsReplyMsgData : PNMsgData
    {
        public uint hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgRevokeMsg.cs ===
// QMsgRevokeMsg.cs
//
//	Notification (Messaging) Revoke Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Revoke a message for a user
	/// </summary>
	public class QMsgRevokeMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">Sender of message</param>
		/// <param name="context">Message context</param>
		/// <param name="type">Message type</param>
		/// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
		public QMsgRevokeMsg( PNUser sender, ulong context, byte type, RecipientResult[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;

			QRevokeMsgMsgData data = new QRevokeMsgMsgData();
			data.SenderID      = sender.UserId;
			data.SenderContext = context;
			data.MessageType   = type;
			data.Recipients    = recipients;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg request
	/// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
	/// and context are deleted
	/// </summary>
	public class QRevokeMsgMsgData : PNMsgData
	{
		public ulong             SenderID;
		public ulong			 SenderContext;  // Never used, must be zero
		public ushort            RecipientsLen;
		public byte	             MessageType;    // Never used, must be zero
		public RecipientResult[] Recipients;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg reply
	/// </summary>
	public class QRevokeMsgReplyMsgData : PNMsgData
	{
		public uint hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgRevokeMsgByProp.cs ===
// QMsgRevokeMsgByProp.cs
//
//	Notification (Messaging) Revoke by Property Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Revoke a message for a user
	/// </summary>
	public class QMsgRevokeMsgByProp : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">Sender of message</param>
		/// <param name="context">Message context</param>
		/// <param name="type">Message type</param>
		/// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
		public QMsgRevokeMsgByProp( PNUser sender, ulong context, byte type, RecipientResult[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;

			QRevokeMsgByPropMsgData data = new QRevokeMsgByPropMsgData();
			// TBD! Figure out how to load this
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg request
	/// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
	/// and context are deleted
	/// </summary>
	public class QRevokeMsgByPropMsgData : PNMsgData
	{
		public ulong  SenderID; // XPNFD requires that UserID be the first member
		public ushort RecipientIdsLen;
		public byte   MessageType; // If4 recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted
		public uint   Flags;
		public ushort PropTag;
		// TBD! Figure out how to get the property setup for wiredata, not doing this now 
		//		because this is not valid from the FD so I won't be using this message
		// WORD cbProp;
		// BYTE rgbProp[];
		public ulong RecipientIds;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg By Prop reply
	/// </summary>
	public class QRevokeMsgByPropReplyMsgData : PNMsgData
	{
		public uint hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgRevokeExMsg.cs ===
// QMsgRevokeMsgEx.cs
//
//  Notification (Messaging) Revoke Ex Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Revoke a message for a user
    /// </summary>
    public class QMsgRevokeMsgEx : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="sender">Sender of message</param>
        /// <param name="context">Message context</param>
        /// <param name="type">Message type</param>
        /// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
        public QMsgRevokeMsgEx( PNUser user, 
                                ulong senderContext, 
                                uint revokeFlags,
                                byte msgType, 
                                MsgPropertyWrapped prop,
                                RecipientResult[] recipients )
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.Messaging;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Messaging;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE_EX;
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = PresSeqNum;
            
            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;


            QRevokeExMsgMsgData data = new QRevokeExMsgMsgData();
            data.SenderID       = user.UserId;
            data.SenderContext  = senderContext;
            data.Flags          = revokeFlags;
            data.MessageType    = msgType;

            if(null == prop)
            {
                data.PropTag        = 0;
                data.cbProp         = 0;
                data.rgbProp        = new byte[0];
            }
            else
            {
                data.PropTag        = prop.tag;
                switch (prop.type)
                {
                    case XonPresNoti.MSG_PROP_TYPE_NULL:
                    case XonPresNoti.MSG_PROP_TYPE_I1:
                    case XonPresNoti.MSG_PROP_TYPE_I2:
                    case XonPresNoti.MSG_PROP_TYPE_BOOL:
                        data.cbProp = sizeof(ushort);
                        data.rgbProp = BitConverter.GetBytes(prop.data);
                        break;
                    default:
                        data.cbProp = (ushort)prop.ExtraData.Length;
                        data.rgbProp = prop.ExtraData;
                        break;
                }
            }
            if(null == recipients)
            {
                data.RecipientsLen  =  0;
                data.Recipients     = null;
            }
            else
            {
                data.RecipientsLen  = (ushort)recipients.Length;
                data.Recipients     = recipients;
            }

            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Revoke Msg request
    /// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
    /// and context are deleted
    /// </summary>
    public class QRevokeExMsgMsgData : PNMsgData
    {
        public ulong                SenderID;
        public ulong                SenderContext;
        public uint                 Flags;
        public ushort               PropTag;
        public ushort               RecipientsLen;
        public ushort               cbProp;
        public byte                 MessageType;
        
        public RecipientResult[]    Recipients;
        [WireInfo(SizeParam="cbProp")]
        public byte[]               rgbProp;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Revoke Msg By Prop reply
    /// </summary>
    public class QRevokeExMsgReplyMsgData : PNMsgData
    {
        public uint hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgEnumTitles.cs ===
// QMsgEnumTitles.cs
//
//	Notification (Messaging) Enumerate Titles Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerate titles
	/// </summary>
	public class QMsgEnumTitles : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		public QMsgEnumTitles( PNUser user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_TITLES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QDeleteTitleMsgData data = new QDeleteTitleMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Titles request
	/// </summary>
	public class QEnumTitlesMsgData : PNMsgData
	{
		public ulong UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Titles reply
	/// </summary>
	public class QEnumTitlesReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ushort      TitlesLen;
		public UserTitle[] Titles;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Per title info retruned when a user enumerates titlte.
	/// </summary>
	public class UserTitle : WireData
	{
		public uint     TitleID;
		public DateTime LastLogon;
		public uint     Flags;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgSendMsg.cs ===
// QMsgSendMsg.cs
//
//	Notification (Messaging) Send Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Send a message for a user
	/// </summary>
	public class QMsgSendMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">User sending message</param>
		/// <param name="msg">Message being sent</param>
		/// <param name="recipients">UserIds message is too</param>
		public QMsgSendMsg( PNUser sender, UserMessage msg, ulong[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();

            // Possible system message
            if(null == sender || null == sender.Xbox)
            {
			    Msg.Hdr.Sgaddr.inaSg  = 0;
			    Msg.Hdr.Sgaddr.SpiSg  = 0;
			    Msg.Hdr.Sgaddr.XboxID = 0;
            }
            else
            {
			    Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			    Msg.Hdr.Sgaddr.SpiSg  = sender.Xbox.SpiSg;
			    Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;
            }

			QSendMsgMsgData data = new QSendMsgMsgData();
			data.SenderID      = msg.SenderID;
			data.SenderName    = msg.SenderName;
			data.SenderTitleID = msg.TitleID;
			data.SenderContext = msg.Context;
			data.MessageFlags  = msg.Flags;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.MessageType   = msg.Type;
			data.Recipients    = recipients;
			data.Details       = msg.Details;
			data.cbDetails	   = msg.Details.size; 
			Msg.Data = data;
		}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Message being sent</param>
		/// <param name="recipients">UserIds message is too</param>
		public QMsgSendMsg( UserMessage msg, ulong[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			QSendMsgMsgData data = new QSendMsgMsgData();
			data.SenderID      = msg.SenderID;
			data.SenderName    = msg.SenderName;
			data.SenderTitleID = msg.TitleID;
			data.SenderContext = msg.Context;
			data.MessageFlags  = msg.Flags;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.MessageType   = msg.Type;
			data.Recipients    = recipients;
			data.Details       = msg.Details;
			data.cbDetails	   = msg.Details.size; 
			Msg.Data = data;
		}
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send Msg request
	/// </summary>
	public class QSendMsgMsgData : PNMsgData
	{
		public ulong      SenderID;
		public ulong      SenderContext;
		public uint       MessageFlags;
		public uint       SenderTitleID;
		public ushort     ExpireMinutes;
		public ushort     cbDetails; 
		public ushort     RecipientsLen;
		public byte       MessageType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string     SenderName;
		public ulong[]    Recipients;
		public MsgDetails Details;
	}

//	//
//	// Invite Messages between Presence & Notification clusters include the following information
//	//  tacked on to the end of a Q_SEND_MESSAGE_MSG, one per recipient.
//	//
//	struct Q_SEND_MESSAGE_ADDENDUM 
//	{
//		BYTE        fFriend;
//		ULONGLONG   qwWebID;
//	};

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send Msg reply
	/// </summary>
	public class QSendMsgReplyMsgData : PNMsgData
	{
		public uint              hr;
		public ushort            recipientsLen;
		public RecipientResult[] recipients;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Recipient result is message Id on success and HR on failure
	/// </summary>
	public class RecipientResult : WireData
	{
		public ulong  userId;
		public uint   data;

		public uint msgId {
            get{ return data; }
            set{ data = value; }
        }
		public uint hr {
            get{ return data; }
            set{ data = value; }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgSummary2.cs ===
// QMsgSummary.cs
//
//	Notification (Messaging) Summary Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get summary of specified message for a user
	/// </summary>
	public class QMsgSummary2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="messageId">Id of message</param>
		public QMsgSummary2( PNUser user, uint messageId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_SUMMARY_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QSummary2MsgData data = new QSummary2MsgData();
			data.UserID    = user.UserId;
			data.MessageID = messageId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary request
	/// </summary>
	public class QSummary2MsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary reply
	/// </summary>
	public class QSummary2ReplyMsgData : PNMsgData
	{
		public uint           HR;
		public UserMsgSummary2 Summary;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\SystemMsgSummary.cs ===
// SystemMsgSummary.cs
//
//	Message summary protocol data 
//

using System;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// System message summary data
	/// </summary>
	public class SystemMsgSummary : WireData
	{
		public uint     TitleID;
		public ulong    SenderContext;
		public DateTime SentTime;
		public uint     Region;
		public uint     MessageID;
		public uint     MessageFlags;
		public ushort   ExpireMinutes; // An offset in minutes from the sent time
		public ushort   cbDetails;
		public byte     MessageType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string   SenderName;
		[WireInfo(ArraySize=64)] // XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN
		public string   Description;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgSummary.cs ===
// QMsgSummary.cs
//
//	Notification (Messaging) Summary Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get summary of specified message for a user
	/// </summary>
	public class QMsgSummary : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="messageId">Id of message</param>
		public QMsgSummary( PNUser user, uint messageId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_SUMMARY;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			QSummaryMsgData data = new QSummaryMsgData();
			data.UserID    = user.UserId;
			data.MessageID = messageId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary request
	/// </summary>
	public class QSummaryMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary reply
	/// </summary>
	public class QSummaryReplyMsgData : PNMsgData
	{
		public uint           HR;
		public UserMsgSummary Summary;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgSendSystemMsg.cs ===
// QMsgSendSystemMsg.cs
//
//	Notification (Messaging) Send System Msg message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Send a system message
	/// </summary>
	public class QMsgSendSystemMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">System Message Object</param>
		public QMsgSendSystemMsg( SystemMessage msg )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_SYSTEM_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			QSendSystemMsgMsgData data = new QSendSystemMsgMsgData();
			data.TitleID       = msg.TitleID;
			data.SentTime      = msg.SentTime;
			data.SenderContext = msg.Context;
			data.Region        = msg.Region;
			data.MsgFlags      = msg.Flags;
			data.MsgType       = msg.Type;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.SenderName    = msg.SenderName;
			data.cbDetails     = msg.Details.size;
			data.Details       = msg.Details;
			data.Description   = msg.Description;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send System Msg request
	/// </summary>
	public class QSendSystemMsgMsgData : PNMsgData
	{
		public uint       TitleID;
		public ulong      SenderContext;
		public DateTime	  SentTime;
		public uint       Region; 
		public uint       MsgFlags;
		public ushort     ExpireMinutes;
		public ushort     cbDetails;
		public byte       MsgType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string     SenderName;
		[WireInfo(ArraySize=64)] // XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN
		public string   Description;
		public MsgDetails Details;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send System Msg reply
	/// </summary>
	public class QSendSystemMsgReplyMsgData : PNMsgData
	{
		public uint HR;
		public uint MsgID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\QMsgSystemDetails.cs ===
// QMsgSystemDetails.cs
//
//    Notification (Messaging) System Msg Details message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Get details of specified system message
    /// </summary>
    public class QMsgSystemDetails : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="titleId">Title responsible for message</param>
        /// <param name="msgId">Id of message</param>
        public QMsgSystemDetails( uint titleId, uint msgId )
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.Messaging_DC;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Messaging;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.QMSG_SYSTEM_MESSAGE_DETAILS;
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = 0;
            Msg.Hdr.Sgaddr.SpiSg  = 0;
            Msg.Hdr.Sgaddr.XboxID = 0;

            QSystemDetailsMsgData data = new QSystemDetailsMsgData();
            data.TitleID = titleId;
            data.MsgID   = msgId;
            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to System Msg Details request
    /// </summary>
    public class QSystemDetailsMsgData : PNMsgData
    {
        public uint TitleID;
        public uint MsgID;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to System Msg Details reply
    /// </summary>
    public class QSystemDetailsReplyMsgData : PNMsgData
    {
        public uint             HR;
        public SystemMsgSummary Summary;
        public MsgDetails       Details;

        public override WireData ReadStream(System.IO.BinaryReader binaryReader)
        {
            // Read HR
            HR = binaryReader.ReadUInt32();

            // Read summary
            Summary = new SystemMsgSummary();
            Summary.ReadStream(binaryReader);

            // Conditionally read details
            if (Summary.cbDetails > 0)
            {
                Details = new MsgDetails();
                Details.ReadStream(binaryReader);
            }

            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\SystemMessage.cs ===
// SystemMessage.cs
//
//    System Message storage and mainipulation
//

using System;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// System Message Wrapper
    /// </summary>
    public class SystemMessage : Message
    {
        // Used by Delete to specify clearing of messages from user queues as well
        public enum RevokeAlso { Yes, No }

        // Message data unique to system messages
        public uint   Region;
        public string Description;

        // Default constructor only used by static factory methods
        private SystemMessage() {}

        /// <summary>
        /// Displays metadata about the message as a comma separated list of values
        /// </summary>
        /// <returns>Message metadata string</returns>
        public override string ToString()
        {
            return base.ToString() + String.Format(", Region = {0}, Description = \"{1}\"", Region, Description);
        }

        //////////////////////////////////////
        /// <summary>
        /// Creates a blank System message
        /// </summary>
        /// <returns>Blank system message ready to be loaded for sending</returns>
        public static SystemMessage CreateBlank()
        {
            SystemMessage msg = new SystemMessage();
            msg.Details = MsgDetails.CreateBlank();
            return msg;
        }

        //////////////////////////////////////
        /// <summary>
        /// Fully parametarized creation of sytem message
        /// </summary>
        /// <param name="senderName">Name of sender</param>
        /// <param name="titleID">Title message is for</param>
        /// <param name="region">Region message is for</param>
        /// <param name="context">Message specific context</param>
        /// <param name="sentTime">Message activation time</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires after it is activated</param>
        /// <param name="type">Message Type</param>
        /// <param name="description">Message Descripion</param>
        /// <param name="details">Collection of message properties</param>
        /// <returns>A system message loaded and ready for sending</returns>
        public static SystemMessage Create(
            string     senderName,
            uint       titleID,
            uint       region,
            ulong      context,
            DateTime   sentTime,
            uint       flags,
            ushort     expireMinutes,
            byte       type,
            string     description,
            MsgDetails details )
        {
            SystemMessage msg = new SystemMessage();

            msg.SenderName    = senderName;
            msg.TitleID       = titleID;
            msg.Region        = region;
            msg.Context       = context;
            msg.SentTime      = sentTime;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Description   = description;
            msg.Details       = details;

            return msg;
        }

        //////////////////////////////////////
        /// <summary>
        /// Fully parametarized creaton of Live type system message
        /// </summary>
        /// <param name="priority">Message priority, used to set flags</param>
        /// <param name="senderName">Name of Sender</param>
        /// <param name="titleId">Title message is for</param>
        /// <param name="region">Region message is for</param>
        /// <param name="description">Message Descripion</param>
        /// <param name="stringId">ID for string server lookup</param>
        /// <param name="delayedSendMinutes">Minutes from now message will activate</param>
        /// <param name="expireMinutes">Minutes until message expires after it is activated</param>
        /// <returns>A complete Live type system message loaded and ready for sending</returns>
        public static SystemMessage CreateLiveMsg(
            Priority priority,
            string   senderName,
            uint     titleId,
            uint     region,
            string   description,
            uint     stringId,
            ushort   delayedSendMinutes,
            ushort   expireMinutes )
        {
            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty( XonPresNoti.MSG_PROP_SYSTEM_TEXT, stringId );

            uint flags = 0;
            switch( priority )
            {
                case Priority.Required:   flags = XonPresNoti.MSG_FLAG_REQUIRED;   break;
                case Priority.Recomended: flags = XonPresNoti.MSG_FLAG_RECOMMENDED; break;
            }

            return Create(
                senderName,
                titleId,
                region,
                0, // context required for Live Message type
                DateTime.UtcNow.AddMinutes( delayedSendMinutes ),
                flags,
                expireMinutes,
                XonPresNoti.MSG_TYPE_LIVE_MESSAGE,
                description,
                details );
        }

        //////////////////////////////////////
        /// <summary>
        /// Constuct with received message summary
        /// </summary>
        /// <param name="summary">Message summary wire data</param>
        public SystemMessage( SystemMsgSummary summary )
        {
            TitleID       = summary.TitleID;
            Context       = summary.SenderContext;
            SentTime      = summary.SentTime;
            Region        = summary.Region;
            ID            = summary.MessageID;
            Flags         = summary.MessageFlags;
            ExpireMinutes = summary.ExpireMinutes; // An offset in minutes from the sent time
            Type          = summary.MessageType;
            SenderName    = summary.SenderName;
            Description   = summary.Description;
        }

        //////////////////////////////////////
        /// <summary>
        /// Constuct with system details message
        /// </summary>
        /// <param name="titleId">Title message was for</param>
        /// <param name="msgId">ID of message</param>
        public SystemMessage( uint titleId, uint msgId )
        {
            QMsgSystemDetails detailsMsg = new QMsgSystemDetails( titleId, msgId );

            PNMsg replyMsg;
            detailsMsg.TransactFD( out replyMsg );

            QSystemDetailsReplyMsgData replyData = (QSystemDetailsReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException(
                    replyData.HR,
                    String.Format("System Details Message HR = 0x{0:X08}", replyData.HR)
                    );

            TitleID       = replyData.Summary.TitleID;
            Context       = replyData.Summary.SenderContext;
            Region        = replyData.Summary.Region;
            ID            = replyData.Summary.MessageID;
            Flags         = replyData.Summary.MessageFlags;
            ExpireMinutes = replyData.Summary.ExpireMinutes;
            Type          = replyData.Summary.MessageType;
            SenderName    = replyData.Summary.SenderName;
            Description   = replyData.Summary.Description;
            SentTime      = replyData.Summary.SentTime;
            Details       = replyData.Details;
        }

        //////////////////////////////////////
        /// <summary>
        /// Send message based on current contents. Changes Message ID if send succedes
        /// </summary>
        /// <returns>Message ID if succesfull</returns>
        public uint Send()
        {
            QMsgSendSystemMsg sendMsg = new QMsgSendSystemMsg( this );

            PNMsg replyMsg;
            sendMsg.TransactFD( out replyMsg );

            QSendSystemMsgReplyMsgData replyData = (QSendSystemMsgReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException(
                    replyData.HR,
                    String.Format("Send System Message HR = 0x{0:X08}", replyData.HR)
                    );

            ID = replyData.MsgID;

            return ID;
        }

        //////////////////////////////////////
        /// <summary>
        /// Static fully parametarized deletion
        /// </summary>
        /// <param name="titleId">Title message was sent to</param>
        /// <param name="msgId">ID of message</param>
        /// <param name="revoke">option to also delete message already delivered to users</param>
        /// <param name="useDatacenterPort">Whether to use the datacenter port on the FD</param>
        public static void Delete( uint titleId, uint msgId, RevokeAlso revoke, bool useDatacenterPort )
        {
            QMsgDeleteSystemMsg delMsg = new QMsgDeleteSystemMsg( titleId, msgId, revoke == RevokeAlso.Yes );

            if (useDatacenterPort)
                delMsg.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;

            PNMsg replyMsg;
            delMsg.TransactFD( out replyMsg );

            QDeleteSystemMsgReplyMsgData replyData = (QDeleteSystemMsgReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException(
                    replyData.HR,
                    String.Format("Delete System Message HR = 0x{0:X08}", replyData.HR)
                    );
        }

        public static void Delete(uint titleId, uint msgId, RevokeAlso revoke)
        {
            Delete(titleId, msgId, revoke, false);
        }

        //////////////////////////////////////
        /// <summary>
        /// Delete this message (based on current contents)
        /// </summary>
        /// <param name="revoke">Option to also delete message already delivered to users</param>
        public void Delete( RevokeAlso revoke )
        {
            Delete( TitleID, ID, revoke, false );
        }

        //////////////////////////////////////
        /// <summary>
        /// Gets details and stores them, validates Summary recieved with current contents
        /// </summary>
        public void GetDetails()
        {
            QMsgSystemDetails detailsMsg = new QMsgSystemDetails( TitleID, ID );

            PNMsg replyMsg;
            detailsMsg.TransactFD( out replyMsg );

            QSystemDetailsReplyMsgData replyData = (QSystemDetailsReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException(
                    replyData.HR,
                    String.Format("System Details Message HR = 0x{0:X08}", replyData.HR)
                    );

            CheckSummary( replyData.Summary );

            Details = replyData.Details;
        }

        //////////////////////////////////////
        /// <summary>
        /// Checks current contents against Wire Data summary
        /// </summary>
        /// <param name="summary">System message summary wire data</param>
        public void CheckSummary( SystemMsgSummary summary )
        {
            ValueCheck.Test( "Title ID",       TitleID,       summary.TitleID );
            ValueCheck.Test( "Context",        Context,       summary.SenderContext );
            ValueCheck.Test( "Region",           Region,        summary.Region );
            ValueCheck.Test( "ID",             ID,            summary.MessageID );
            ValueCheck.Test( "Flags",          Flags,         summary.MessageFlags );
            ValueCheck.Test( "ExpireMinutes",  ExpireMinutes, summary.ExpireMinutes );
            ValueCheck.Test( "Type",           Type,          summary.MessageType );
            ValueCheck.Test( "SenderName",     SenderName,    summary.SenderName );
            ValueCheck.Test( "Description",    Description,   summary.Description );
            ValueCheck.Test( "SentTime",       SentTime,      summary.SentTime, new TimeSpan(0, 1, 0));
        }

        //////////////////////////////////////
        /// <summary>
        /// Checks current summary contents against that of another system message
        /// </summary>
        /// <param name="sysMsg">Other system message that should be identical (at least summary part)</param>
        public void CheckSystemMessage( SystemMessage sysMsg )
        {
            ValueCheck.Test( "Region",        Region,      sysMsg.Region );
            ValueCheck.Test( "Description", Description, sysMsg.Description );

            Check( sysMsg );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\SystemMsgFolder.cs ===
// SystemMsgFolder.cs
//
//    System message container
//

using System;
using System.Collections;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Collection of a particular title's system messages
    /// </summary>
    public class SystemMsgFolder
    {
        // Title ID set by constrctor and can't change
        private uint titleId;
        public  uint TitleId {get{ return titleId; }}

        // Table of messages
        private Hashtable messages = new Hashtable();
        public ushort Count {get{ return (ushort)(messages.Count); }}
        public SystemMessage this[uint msgId] { get { return (SystemMessage)messages[msgId]; } }

        public SystemMessage[] Messages
        {
            get
            {
                SystemMessage[] msgList = new SystemMessage[messages.Count];
                messages.Values.CopyTo(msgList, 0);
                return msgList;
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Cretae empty folder for given title ID
        /// </summary>
        /// <param name="titleId">Title ID messages are for</param>
        public SystemMsgFolder( uint titleId )
        {
            this.titleId = titleId;
        }

        //////////////////////////////////////
        /// <summary>
        /// Enumerate messages from server
        /// </summary>
        /// <returns>Number of messages retrieved</returns>
        public ushort Load(bool useDatacenterPort)
        {
            messages.Clear();

            QMsgEnumSystemMsgs enumMsg = new QMsgEnumSystemMsgs( titleId );

            if (useDatacenterPort)
                enumMsg.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;

            PNMsg replyMsg;
            enumMsg.TransactFD( out replyMsg );

            if (replyMsg.Data.GetType() != typeof(QEnumSystemMsgsReplyMsgData))
                throw new UnexpectedTestResultException(
                    String.Format(
                        "Mismatched reply data type; expected {0}, got {1}",
                        typeof(QEnumSystemMsgsReplyMsgData).Name,
                        replyMsg.Data.GetType().Name
                        )
                        );

            QEnumSystemMsgsReplyMsgData replyData = (QEnumSystemMsgsReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Enum System Messages HR = 0x"+Hexer.tohex( replyData.HR ));

            foreach( SystemMsgSummary summary in replyData.Summaries )
            {
                if( messages[ summary.MessageID ] == null )
                {
                    messages[ summary.MessageID ] = new SystemMessage( summary );

                    Console.WriteLine( "SystemMsgFolder: Loading MsgId: {0}", summary.MessageID );
                }
                else
                {
                    throw new UnexpectedTestResultException( "SystemMsgFolder: Duplicate MsgId: "+summary.MessageID );
                }
            }

            return Count;
        }

        public ushort Load()
        {
            return Load(false);
        }

        //////////////////////////////////////
        /// <summary>
        /// Delete all loaded messages from server
        /// </summary>
        /// <param name="revoke">Option to also delete message already delivered to users</param>
        public void DeleteAll( SystemMessage.RevokeAlso revoke )
        {
            DateTime timeoutTime = DateTime.Now.AddSeconds(15);

            do
            {
                foreach (uint msgId in messages.Keys)
                {
                    try
                    {
                        ((SystemMessage)messages[msgId]).Delete(revoke);
                    }
                    catch (Exception ex)
                    {
                        // Deleting each message is best effort
                        Global.RO.Warn("Exception deleting system message {0}: {1}", msgId, ex.Message);
                    }
                }
            } while (Load() > 0 && DateTime.Now < timeoutTime);

            messages.Clear();

            if (Count > 0)
                throw new UnexpectedTestResultException("System message folder still has " + Count + " messages after deletion timeout");
        }

        //////////////////////////////////////
        /// <summary>
        /// Delete all messages for specified title from server
        /// </summary>
        /// <param name="titleId">Title messages are for</param>
        /// <param name="revoke">Option to also delete message already delivered to users</param>
        public static void DeleteAll( uint titleId, SystemMessage.RevokeAlso revoke )
        {
            SystemMsgFolder folder = new SystemMsgFolder( titleId );
            folder.Load();
            folder.DeleteAll( revoke );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\UserMessage.cs ===
// UserMessage.cs
//
//  User Message storage and mainipulation
//

using System;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    public class UserMessage : Message
    {
        // Message data unique to user messages
        public ulong             SenderID;
        public string            Subject;

        // Default constructor only used by static factory methods
        private UserMessage() {}

        /// <summary>
        /// Displays metadata about the message as a comma separated list of values
        /// </summary>
        /// <returns>Message metadata string</returns>
        public override string ToString()
        {
            return base.ToString() + String.Format(", SenderID = {0:X}, Subject = \"{1}\"", SenderID, Subject);
        }

        /// <summary>
        /// Create and load a new message for recpient with message ID
        /// </summary>
        /// <returns>New message object with details and summary or exception</return>
        public static UserMessage CreateAndLoad(PNUser recipient, uint inID)
        {
            return CreateAndLoad(recipient, inID, 0, 0);
        }

        /// <summary>
        /// Create and load a new message for recpient with message ID, set flags and
        /// unsetflags are passed to details request.
        /// </summary>
        /// <returns>New message object with details and summary or exception</return>
        public static UserMessage CreateAndLoad(PNUser recipient, uint inID, uint setFlags, uint unsetFlags)
        {
            UserMessage msg = new UserMessage();

            uint hr = msg.GetDetails(recipient, inID, setFlags, unsetFlags);
            if(!HResult.Succeeded(hr))
            {
                throw new HResultException(hr, "CreateAndLoad(): Failed to load message details");
            }

            return msg;
        }

        /// <summary>
        /// Creates a blank User message
        /// </summary>
        /// <returns>Blank user message ready to be loaded for sending</returns>
        public static UserMessage CreateBlank()
        {
            UserMessage msg = new UserMessage();
            msg.Details = MsgDetails.CreateBlank();
            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xbox 1 user message with details
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="type">Message Type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <param name="details">Collection of message properties</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNUser     sender,
            byte       type,
            ulong      context,
            uint       flags,
            ushort     expireMinutes,
            MsgDetails details )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;

            // Live  messages are sent as xbox 1 dash
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0xfffe0000;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = details;

            return msg;
        }

        public static UserMessage Create(PNUser sender, byte type, ulong context, uint flags, ushort expireMinutes, uint titleId)
        {
            UserMessage msg = new UserMessage();

            msg.SenderID = sender.UserId;
            msg.SenderName = sender.Name;
            msg.TitleID = titleId;
            msg.Context = context;
            msg.Flags = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type = type;
            msg.Details = MsgDetails.CreateBlank(); 

            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xbox 1 user message without details
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="type">Message Type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNUser sender,
            byte   type,
            ulong  context,
            uint   flags,
            ushort expireMinutes )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = MsgDetails.CreateBlank();

            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xenon user message with details
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="subject">Subject from message summary</param>
        /// <param name="type">Message type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <param name="details">Collection of message properties</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNUser     sender,
            string     subject,
            byte       type,
            ulong      context,
            uint       flags,
            ushort     expireMinutes,
            MsgDetails details)
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Subject       = subject;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = details;

            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xenon user message without details
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="subject">Subject from message summary</param>
        /// <param name="type">Message type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNUser sender,
            string subject,
            byte   type,
            ulong  context,
            uint   flags,
            ushort expireMinutes )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Subject       = subject;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = MsgDetails.CreateBlank();

            return msg;
        }

        /// <summary>
        /// Creation of basic custom message type
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <returns>Most basic custom message</returns>
        public static UserMessage CreateTitleCustomMsg( PNUser sender )
        {
            return Create( sender, XonPresNoti.MSG_TYPE_TITLE_CUSTOM, 0, 0, 0 );
        }

        /// <summary>
        /// Creation of basic friends request message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <returns>Most basic friend request message</returns>
        public static UserMessage CreateFriendsRequestMsg( PNUser sender )
        {
            UserMessage msg = Create( sender, XonPresNoti.MSG_TYPE_FRIEND_REQUEST, 0, 0, 0 , Presence.FriendsCommon.XenonDashTitleId);
            return msg;
        }

        /// <summary>
        /// Creation of basic team recruit message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="teamId">Id of team being recruited into</param>
        /// <returns>Most basic team recruit message</returns>
        public static UserMessage CreateTeamRecruitMsg( PNUser sender, ulong teamId )
        {
            return Create( sender, XonPresNoti.MSG_TYPE_TEAM_RECRUIT, teamId, XonPresNoti.MSG_FLAG_TEAM_CONTEXT, 0);
        }

        /// <summary>
        /// Creation of a service originated comp reminder, see comps\query\elimination.cs
        /// </summary>
        public static UserMessage CreateCompReminderMsg(
                ulong entityId,  // Round that entry should join
                string compName,
                ushort round,
                DateTime roundStart,
                uint titleId,
                ushort expireMin)
        {
            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_NAME, compName);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_START, roundStart);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_ROUND, round);

            UserMessage msg = Create(
                    PNUser.Service,
                    XonPresNoti.MSG_TYPE_COMP_REMINDER,
                    entityId,                           // sender context
                    XonPresNoti.MSG_FLAG_COMP_CONTEXT,
                    expireMin,
                    details);
            msg.TitleID = titleId;

            return msg;
        }

        /// <summary>
        /// Creation of a user originated competition join request to another user he would
        /// like to join the competition.
        /// </summary>
        public static UserMessage CreateCompRequestMsg(
                PNUser sender,
                ulong compEntityId,
                string compName,
                DateTime compStart,
                DateTime compRegClose,
                uint titleId,
                ushort expireMin)
        {
            return CreateCompRequestMsg(sender, compEntityId, compName, compStart, compRegClose, titleId, 0, expireMin, MsgDetails.CreateBlank());
        }

        public static UserMessage CreateCompRequestMsg(
                PNUser sender,
                ulong compEntityId,
                string compName,
                DateTime compStart,
                DateTime compRegClose,
                uint titleId,
                uint flags,
                ushort expireMin,
                MsgDetails details)
        {
            UserMessage msg = Create(
                    sender,
                    XonPresNoti.MSG_TYPE_COMP_REQUEST,
                    compEntityId,
                    flags,
                    expireMin,
                    details);
            msg.TitleID = titleId;

            details.AddProperty(XonPresNoti.MSG_PROP_COMP_NAME, compName);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_START, compStart);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_REG_CLOSE, compRegClose);
            msg.Flags |= XonPresNoti.MSG_FLAG_COMP_CONTEXT;

            return msg;
        }

        /// <summary>
        /// Creation of basic game invite message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="sessionId">Id of session being invited to</param>
        /// <returns>Most basic game invite message</returns>
        public static UserMessage CreateGameInviteMsg( PNUser sender, ulong sessionId )
        {
            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty( XonPresNoti.MSG_PROP_SESSION_ID, sessionId );

            return Create( sender, XonPresNoti.MSG_TYPE_GAME_INVITE, 0, 0, 0, details );
        }

        /// <summary>
        /// Creation of basic game invite message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="sessionId">Id of session being invited to</param>
        /// <returns>Most basic game invite message</returns>
        public static UserMessage CreatePersonalMessage( PNUser sender, string text )
        {
            UserMessage msg = Create( sender, XonPresNoti.MSG_TYPE_PERSONAL_MESSAGE, 0, 0, 0, null );
            UserMessage.AttachText(msg, text);
            return msg;
        }

        /// <summary>
        /// Attach a basic string text summary to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        /// <param name="strData">String to attach as a text property</param>
        public static void AttachText(UserMessage msg, string strData)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add text summary
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT, strData);
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT_LANGUAGE, (int)1);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_TEXT;
        }

        /// <summary>
        /// Deprecated, call specific voice attachment function per platform
        /// </summary>
        public static void AttachVoice(UserMessage msg)
        {
            AttachXboxVoice(msg);
        }

        /// <summary>
        /// Attach a generic xbox 1 fake voice attachment to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        public static void AttachXboxVoice(UserMessage msg)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add voice
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA, 10*1024, 0/*flags*/, "http://xonline.msgbuilder/attachment.wav");
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_CODEC, (ushort)2);
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_DURATION, (int)200);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_VOICE;
        }

        /// <summary>
        /// Attach a generic fake voice attachment to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        public static void AttachXenonVoice(UserMessage msg)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add voice
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA, 10*1024, 0/*flags*/, "http://xonline.msgbuilder/attachment.wav");
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_CODEC, (ushort)2);
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_DURATION, (int)200);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_VOICE;
        }

        /// <summary>
        /// Constuct with received xbox 1 message summary
        /// </summary>
        /// <param name="summary">Message summary wire data</param>
        public UserMessage( UserMsgSummary summary )
        {
            SenderID      = summary.SenderID;
            Context       = summary.SenderContext;
            SentTime      = summary.SentTime.dt;
            ID            = summary.MessageID;
            Flags         = summary.MessageFlags;
            TitleID       = summary.SenderTitleID;
            ExpireMinutes = summary.ExpireMinutes;
            Type          = summary.MessageType;
            SenderName    = summary.SenderName;
        }

        /// <summary>
        /// Constuct with received xenon message summary
        /// </summary>
        /// <param name="summary">Message summary wire data</param>
        public UserMessage( UserMsgSummary2 summary2 )
        {
            PopulateMetadata(summary2);

        }

        public uint GetSummary( PNUser recipient, uint msgId )
        {
            uint hr = HResult.S_OK;

            //
            // Retreive the message summary
            //
            PNMsg replyMsg;
            QMsgSummary summaryMsg = new QMsgSummary( recipient, msgId );
            summaryMsg.TransactFD(out replyMsg);

            QSummaryReplyMsgData summaryReplyData = (QSummaryReplyMsgData)replyMsg.Data;
            hr = summaryReplyData.HR;

            if(!HResult.Succeeded(hr))
            {
                Global.RO.Error("GetSummary2(): failed for User: {0:x}, MsgID: {1}, HR = {2:x8}",
                        recipient.UserId,
                        msgId,
                        hr);
            }
            else
            {
                PopulateMetadata(summaryReplyData.Summary);
            }

            return hr;
        }

        public uint GetSummary2( PNUser recipient, uint msgId )
        {
            uint hr = HResult.S_OK;

            //
            // Retreive the message summary
            //
            PNMsg replyMsg;
            QMsgSummary2 summaryMsg = new QMsgSummary2( recipient, msgId );
            summaryMsg.TransactFD(out replyMsg);

            QSummary2ReplyMsgData summaryReplyData = (QSummary2ReplyMsgData)replyMsg.Data;
            hr = summaryReplyData.HR;

            if(!HResult.Succeeded(hr))
            {
                Global.RO.Error("GetSummary2(): failed for User: {0:x}, MsgID: {1}, HR = {2:x8}",
                        recipient.UserId,
                        msgId,
                        hr);
            }
            else
            {
                PopulateMetadata(summaryReplyData.Summary);
            }

            return hr;
        }

        public uint GetDetails( PNUser recipient )
        {
            return GetDetails( recipient, 0, 0 );
        }

        public uint GetDetails( PNUser recipient, uint setFlags, uint unsetFlags )
        {
            return GetDetails( recipient, ID, setFlags, unsetFlags );
        }

        public uint GetDetails( PNUser recipient, uint inID)
        {
            return GetDetails( recipient, inID, 0, 0 );
        }

        public uint GetDetails( PNUser recipient, uint inID, uint setFlags, uint unsetFlags)
        {
            uint hr = HResult.S_OK;

            // Allow loading when ID is not yet known (message hasn't been enumerated but
            // we can load directly from messaging QVals.
            if(ID != inID)
            {
                ID = inID;
            }

            QMsgDetails detailsMsg = new QMsgDetails( recipient, ID, setFlags, unsetFlags );

            PNMsg replyMsg;
            detailsMsg.TransactFD(out replyMsg);

            QDetailsReplyMsgData replyData = (QDetailsReplyMsgData)(replyMsg.Data);
            hr = replyData.HR;

            if(HResult.Succeeded(hr))
            {
                // These checks are used when when the message has been enumerated to validate
                // that the details match the enumerated summary data.
                if(0 != SenderID)
                {
                    ValueCheck.Test( "Sender ID",       SenderID,      replyData.Summary.SenderID );
                    ValueCheck.Test( "Context",         Context,       replyData.Summary.SenderContext );
                    ValueCheck.Test( "Type",            Type,          replyData.Summary.MessageType );
                    ValueCheck.Test( "Sent Time",       SentTime,      replyData.Summary.SentTime.dt, new TimeSpan(0, 1, 0) );
                    ValueCheck.Test( "ID",              ID,            replyData.Summary.MessageID );
                    ValueCheck.Test(
                        "Expiration",
                        ExpireMinutes == 0 ? XonPresNoti.GetDefaultExpirationForMsgType(Type) : ExpireMinutes,
                        replyData.Summary.ExpireMinutes
                        );
                    ValueCheck.Test( "Sender Name",     SenderName,    replyData.Summary.SenderName );
                    ValueCheck.Test( "Sender Title ID", TitleID,       replyData.Summary.SenderTitleID );

                    uint expFlags = (Flags | setFlags) & ~unsetFlags;
                    ValueCheck.Test( "Flags", expFlags, replyData.Summary.MessageFlags );
                }
                else
                {
                    // Populate the metadata from included summary
                    PopulateMetadata(replyData.Summary);
                }

                Details = replyData.Details;
                Flags = replyData.Summary.MessageFlags;
            }

            return hr;
        }


        public uint Send(PNUser recipient)
        {
            return Send(PNUser.Find(SenderID), new PNUser[]{recipient}, PNRequestMsg.FDPort.Messaging);
        }
        public uint Send(PNUser recipient, PNRequestMsg.FDPort port)
        {
            return Send(PNUser.Find(SenderID), new PNUser[]{recipient}, port);
        }
        public uint Send(PNUser sender, PNUser recipient)
        {
            return Send(sender, new PNUser[]{recipient}, PNRequestMsg.FDPort.Messaging);
        }
        public uint Send(PNUser sender, PNUser recipient, PNRequestMsg.FDPort port)
        {
            return Send(sender, new PNUser[]{recipient}, PNRequestMsg.FDPort.Messaging);
        }
        public uint Send(PNUser sender, PNUser []recipients)
        {
            return Send(sender, recipients, PNRequestMsg.FDPort.Messaging);
        }

        public uint Send( PNUser sender, PNUser []recipients, PNRequestMsg.FDPort port)
        {
            ulong[] recipientIds = new ulong[recipients.Length];

            // Copy the recipient IDs
            for(uint i = 0; i < recipients.Length; ++i)
            {
                recipientIds[i] = recipients[i].UserId;
            }

            QMsgSendMsg sendMsg = new QMsgSendMsg( sender, this, recipientIds );
            sendMsg.PortOnFD = port;
            PNMsg replyMsg;
            sendMsg.TransactFD(out replyMsg);

            QSendMsgReplyMsgData replyData = (QSendMsgReplyMsgData)(replyMsg.Data);

            // Validate the basic message reply
            ValueCheck.Test("QMsgSendMsgReply.RecipientsLen", (ushort)replyData.recipients.Length, replyData.recipientsLen);

            // Store the recipients and sent time
            Recipients = replyData.recipients;
            SentTime = DateTime.UtcNow;

            if(Recipients.Length == 1)
            {
                // Check reply results
                if (HResult.Failed(replyData.recipients[0].hr))
                {
                    throw new HResultException(replyData.recipients[0].hr, "QMsgSendMsgReply.Recipient.HR");
                }
                ID = replyData.recipients[0].msgId;
            }
            else if (Recipients.Length > 1)
            {
                ID = MANY_RECIPIENTS;
            }

            // Check reply results
            if(HResult.Failed(replyData.hr))
            {
                throw new HResultException(replyData.hr, "QMsgSendMsgReply.HR");
            }

            // Validate all the recipients
            for(uint i = 0; i < replyData.recipientsLen; ++i)
            {
                RecipientResult result = replyData.recipients[i];
                ValueCheck.TestNonZero("QMsgSendMsgReply.RecipientResult[" + i +"].msgId", result.msgId);
            }


            return ID;
        }

        public void Delete( PNUser deleter )
        {
            Delete( deleter, false, false );
        }

        public void Delete(PNUser deleter, bool block)
        {
            Delete( deleter, block, false );
        }

        public void Delete( PNUser deleter, bool block, bool useDatacenterPort )
        {
            uint flags = block ? XonPresNoti.DELETE_MESSAGE_FLAG_BLOCK_SENDER : 0;
            QMsgDeleteMsg deleteMsg = new QMsgDeleteMsg( deleter, ID, flags );

            if (useDatacenterPort)
                deleteMsg.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;

            PNMsg replyMsg;
            deleteMsg.TransactFD(out replyMsg);

            QDeleteMsgReplyMsgData replyData = (QDeleteMsgReplyMsgData)(replyMsg.Data);
            if( replyData.HR != HResult.S_OK )
            {
                throw new HResultException( replyData.HR, "Delete Message HR = "+replyData.HR.ToString( "x" ) );
            }
        }

        public void PopulateMetadata(UserMsgSummary summary)
        {
            SenderID      = summary.SenderID;
            Context       = summary.SenderContext;
            SentTime      = summary.SentTime.dt;
            ID            = summary.MessageID;
            Flags         = summary.MessageFlags;
            TitleID       = summary.SenderTitleID;
            ExpireMinutes = summary.ExpireMinutes;
            Type          = summary.MessageType;
            SenderName    = summary.SenderName;
            Subject       = "";
        }

        public void PopulateMetadata(UserMsgSummary2 summary2)
        {
            SenderID      = summary2.SenderID;
            Context       = summary2.SenderContext;
            SentTime      = summary2.SentTime.dt;
            ID            = summary2.MessageID;
            Flags         = summary2.MessageFlags;
            TitleID       = summary2.SenderTitleID;
            ExpireMinutes = summary2.ExpireMinutes;
            Type          = summary2.MessageType;
            SenderName    = summary2.SenderName;
            Subject       = summary2.Subject;
        }

        public void CreateRecipients(int count)
        {
            Recipients = new RecipientResult[count];
            for(int i = 0; i < count; ++i)
            {
                Recipients[i] = new RecipientResult();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\usermsgsummary2.cs ===
// UserMsgSummary.cs
//
//	Message summary protocol data 
//

using System;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message summary data
	/// </summary>
	public class UserMsgSummary2 : WireData
	{
		public ulong   SenderID;
		public ulong   SenderContext;
		public MsgTime SentTime;
		public uint    MessageID;
		public uint    MessageFlags;
		public uint    SenderTitleID;
		public ushort  ExpireMinutes; // An offset in minutes from the sent time
		public ushort  cbDetails;
		public byte    MessageType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string  SenderName;
		[WireInfo(UnicodeEncoded=true,NullTerminated=false,ArraySize=40)] // XONLINE_MAX_SUBJECT_SIZE * 2 bytes
		public string  Subject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\UserMsgSummary.cs ===
// UserMsgSummary.cs
//
//	Message summary protocol data 
//

using System;

namespace ServerTestFramework.LiveService.Notification
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Messaging protocol time is a shortened offset from 1/1/2003
	/// </summary>
	public class MsgTime : WireData
	{
		public uint time;

		// 1/1/2003 - used for conversion between FILETIME and MSGTIME
		public const ulong FT_MSGTIME_BEGIN = 0x01C2B128BA2B4000;

		public DateTime dt
		{
			set{ time = (uint)( ((ulong)(value.ToFileTimeUtc()) - FT_MSGTIME_BEGIN) / 10000000 ); }
			get{ return DateTime.FromFileTimeUtc( (long)( ((ulong)(time) * 10000000) + FT_MSGTIME_BEGIN ) ); }
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message summary data
	/// </summary>
	public class UserMsgSummary : WireData
	{
		public ulong   SenderID;
		public ulong   SenderContext;
		public MsgTime SentTime;
		public uint    MessageID;
		public uint    MessageFlags;
		public uint    SenderTitleID;
		public ushort  ExpireMinutes; // An offset in minutes from the sent time
		public ushort  cbDetails;
		public byte    MessageType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string  SenderName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Notification\UserMsgFolder.cs ===
// UserMsgFolder.cs
//
//    User message container
//

using System;
using System.Collections;
using System.Threading;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Notification
{
    /// <summary>
    /// Collection of a particular user's messages
    /// </summary>
    public class UserMsgFolder
    {
        public static Report Report;

        static UserMsgFolder()
        {
            Report = new Report("UserMsgFolder");
            Report.DisableFilter(Report.DEBUG);

            // Debugging can be enabled at runtime with a call to UserMsgFolder.Report.EnableFilter(Report.DEBUG)
        }

        //------------------------------------------------------------------------------
        // Public property accessors
        //------------------------------------------------------------------------------

        public PNUser Owner
        {
            get {
                return _Owner;
            }
        }

        public ushort InboxCount {
            get {
                return (ushort)(_Inbox.Count);
            }
        }
        // Alias for inbox count
        public ushort Count {
            get {
                return (ushort)_Inbox.Count;
            }
        }

        public ushort OutboxCount {
            get {
                return (ushort)(_Outbox.Count);
            }
        }

        public UserMessage [] Inbox {
            get {
                return (UserMessage[])_Inbox.ToArray(typeof(UserMessage));
            }
        }

        public UserMessage [] Outbox {
            get {
                return (UserMessage[])_Outbox.ToArray(typeof(UserMessage));
            }
        }

        public UserMessage FirstMessage {
            get {
                if(0 == _Inbox.Count)
                {
                    throw new StfException("No messages in the inbox");
                }
                return (UserMessage)_Inbox[0];
            }
        }


        //------------------------------------------------------------------------------
        // Internal properties
        //------------------------------------------------------------------------------
        private PNUser      _Owner;
        private ArrayList   _Inbox = new ArrayList();
        private ArrayList   _Outbox = new ArrayList();


        //------------------------------------------------------------------------------
        // Public API
        //------------------------------------------------------------------------------

        /// <summary>
        /// Construct an empty folder for a user, by PUID.
        /// </summary>
        /// <param name="ownerId">PUID of owning user</param>
        public UserMsgFolder( ulong ownerId )
        {
            _Owner = PNUser.Find( ownerId );
            if( _Owner == null )
            {
                Report.Debug("Generated new owner object for puid: {0:x}", ownerId);
                _Owner = new PNUser( "MsgFolderDummy", ownerId ); // Name doesn't matter here
                _Owner.Xbox = new PNXbox( 0, 0, 0 );  // Also doesn't matter, just needs to be something
            }
        }


        /// <summary>
        /// Construct an empty folder for a user
        /// </summary>
        /// <param name="owner">Owner user</param>
        public UserMsgFolder( PNUser owner )
        {
            _Owner = owner;
        }

        /// <summary>
        /// Deletes all messages from the server
        /// </summary>
        public void DeleteInbox()
        {
            DeleteInbox(false);
        }

        // Alias for DeleteInbox()
        public void DeleteAllMessages()
        {
            DeleteInbox();
        }
        // Alias for DeleteInbox()
        public void DeleteAllMessages(bool block)
        {
            DeleteInbox(block);
        }

        /// <summary>
        /// Deletes all messages from the server
        /// </summary>
        public void DeleteInbox(bool block)
        {
            try
            {
                foreach(UserMessage msg in _Inbox)
                {
                    msg.Delete(_Owner, block);
                }
            }
            finally
            {
                _Inbox.Clear();
            }
        }

        /// <summary>
        /// Clear all of the sent messages stored
        /// </summary>
        public void ClearOutbox()
        {
            _Outbox.Clear();
        }

        /// <summary>
        /// Manually add a message to the collection.
        /// </summary>
        public void AddSentMessage(UserMessage msg)
        {
            _Outbox.Add(msg);
        }

        /// <summary>
        /// Indexer to sent message table
        /// </summary>
        public UserMessage this[ uint msgId ]
        {
            get {
                UserMessage msg = FindMessage(msgId);
                if(null == msg)
                {
                    throw new IndexOutOfRangeException( "MsgId: "+msgId+", is not in folder" );
                }

                return msg;
            }
        }


        /// <summary>
        /// Enumerate messages from server
        /// </summary>
        /// <returns>Number of messages present </returns>
        public ushort Load()
        {
            _Inbox.Clear();

            QMsgEnumMsgs enumMsg = new QMsgEnumMsgs( _Owner );

            PNMsg replyMsg;
            enumMsg.TransactFD(out replyMsg);

            QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Enum Messages HR = 0x"+Hexer.tohex( replyData.HR ));

            foreach( UserMsgSummary summary in replyData.Messages )
            {
                CacheSummary(summary);
            }

            return InboxCount;
        }

        /// <summary>
        /// Enumerate messages from server using new enum2 message type
        /// </summary>
        /// <returns>Number of messages present </returns>
        public ushort Load2()
        {
            _Inbox.Clear();

            QMsgEnumMsgs2 enumMsg = new QMsgEnumMsgs2( _Owner );

            PNMsg replyMsg;
            enumMsg.TransactFD(out replyMsg);

            QEnumMsgs2ReplyMsgData replyData = (QEnumMsgs2ReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Enum Messages HR = 0x"+Hexer.tohex( replyData.HR ));

            foreach( UserMsgSummary2 summary in replyData.Messages )
            {
                CacheSummary(summary);
            }

            return InboxCount;
        }

        /// <summary>
        /// Enumerate messages from server using new enum2 message type if the user is
        /// a xenon user or enumerate using old API for xbox 1 user.
        /// </summary>
        /// <returns>Number of messages present </returns>
        public ushort LoadEx()
        {
            if(_Owner.Xbox.IsXenonTitle)
            {
                return Load2();
            }
            else
            {
                return Load();
            }
        }


        /// <summary>
        /// Finds messages in folder that match given criteria
        /// </summary>
        /// <param name="type">Messsage type</param>
        /// <param name="senderId">User ID of sender</param>
        /// <returns>Array of messages that match</returns>
        public UserMessage[] FindBySender( byte type, ulong senderId )
        {
            ArrayList msgList = new ArrayList();
            foreach(UserMessage msg in _Inbox)
            {
                if( (msg.SenderID == senderId) && ((0 == type) || (msg.Type == type)) )
                {
                    msgList.Add( msg );
                }
            }

            return (UserMessage[])msgList.ToArray(typeof(UserMessage));
        }


        /// <summary>
        /// Finds messages in folder that match given criteria
        /// </summary>
        /// <param name="type">Messsage type</param>
        /// <param name="context">Message type specific context (ie. comp ID)</param>
        /// <returns>Array of messages that match</returns>
        public UserMessage[] FindByContext( byte type, ulong context )
        {
            ArrayList msgList = new ArrayList();
            foreach(UserMessage msg in _Inbox)
            {
                if( (msg.Type    == type) && (msg.Context == context) )
                {
                    msgList.Add( msg );
                }
            }

            return (UserMessage[])msgList.ToArray(typeof(UserMessage));
        }


        /// <summary>
        /// Finds messages in folder that match given criteria
        /// </summary>
        /// <param name="type">Messsage type</param>
        /// <param name="senderId">User ID of sender</param>
        /// <param name="context">Message type specific context (ie. comp ID)</param>
        /// <returns>Array of messages that match</returns>
        public UserMessage[] Find( byte type, ulong senderId, ulong context )
        {
            ArrayList msgList = new ArrayList();
            foreach(UserMessage msg in _Inbox)
            {
                if( (msg.SenderID == senderId) && (msg.Type == type) && (msg.Context  == context) )
                {
                    msgList.Add( msg );
                }
            }

            return (UserMessage[])msgList.ToArray(typeof(UserMessage));
        }


        /// <summary>
        /// Waits for a message that matches given criteria
        /// </summary>
        /// <param name="type">Message type</param>
        /// <param name="senderId">User ID of sender</param>
        /// <param name="waitSec">Seconds to wait</param>
        /// <returns>The first message found that matches</returns>
        public UserMessage WaitForMsgBySender( byte type, ulong senderId, ushort waitSec )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

            while( true )
            {
                Load();
                UserMessage[] msgs = FindBySender( type, senderId );
                if( msgs.Length != 0 )
                {
                    return msgs[0];
                }

                if( DateTime.Now > abortTime )
                    throw new TimeOutException( waitSec, "Timed out waiting for Message" );

                Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
            }
        }


        /// <summary>
        /// Waits for a message that matches given criteria
        /// </summary>
        /// <param name="type">Message type</param>
        /// <param name="context">Message type specific context (ie. comp ID)</param>
        /// <param name="waitSec">Seconds to wait</param>
        /// <returns>The first message found that matches</returns>
        public UserMessage WaitForMsgByContext( byte type, ulong context, ushort waitSec )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

            while( true )
            {
                Load();
                UserMessage[] msgs = FindByContext( type, context );
                if( msgs.Length != 0 )
                {
                    return msgs[0];
                }

                if( DateTime.Now > abortTime )
                    throw new TimeOutException( waitSec, "Timed out waiting for Message" );

                Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
            }
        }


        /// <summary>
        /// Waits for a message that matches given criteria
        /// </summary>
        /// <param name="type">Message type</param>
        /// <param name="senderId">User ID of sender</param>
        /// <param name="context">Message type specific context (ie. comp ID)</param>
        /// <param name="waitSec">Seconds to wait</param>
        /// <returns>The first message found that matches</returns>
        public UserMessage WaitForMsg( byte type, ulong senderId, ulong context, ushort waitSec )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

            while( true )
            {
                Load();
                UserMessage[] msgs = Find( type, senderId, context );
                if( msgs.Length != 0 )
                {
                    return msgs[0];
                }

                if( DateTime.Now > abortTime )
                    throw new TimeOutException( waitSec, "Timed out waiting for Message" );

                Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
            }
        }

        /// <summary>
        /// Look for a message matching the ID with parameters matching the input
        /// template.
        ///
        /// This method does not do any waiting so it is best to pair with something like
        /// WaitForNewMessage() on the PNUser to get the message ID.
        /// </summary>
        public void ValidateContainsMessage(uint msgId, UserMessage template)
        {
            bool bMsgFound = false;

            if(_Owner.Xbox.IsXenonTitle)
            {
                Load();
            }
            else
            {
                Load2();
            }


            foreach(UserMessage msg in _Inbox)
            {
                if(msg.ID == msgId)
                {
                    bMsgFound = true;

                    // compare against template
                    ValueCheck.Test("UserMessage.Type", template.Type, msg.Type);
                    ValueCheck.Test("UserMessage.Context", template.Context, msg.Context);
                    ValueCheck.Test("UserMessage.TitleID", template.TitleID, msg.TitleID);
                    ValueCheck.Test("UserMessage.SenderName", template.SenderName, msg.SenderName);
                    ValueCheck.Test("UserMessage.Flags", template.Flags, msg.Flags);

                    // conditional template checks
                    if(template.SentTime > DateTime.Now.AddHours(-1000))
                    {
                        ValueCheck.Test("UserMessage.SentTime", template.SentTime, msg.SentTime, new TimeSpan(0, 1, 0));
                    }
                    if(template.ExpireMinutes > 0)
                    {
                        ValueCheck.Test("UserMessage.ExpireMinutes", template.ExpireMinutes, msg.ExpireMinutes);
                    }
                }
            }

            if(!bMsgFound)
            {
                throw new UnexpectedTestResultException("A message with ID: " + msgId + " was not found in the user message folder");
            }
        }

        public bool ContainsMessage(uint msgId)
        {
            bool found = false;
            foreach(UserMessage msg in _Inbox)
            {
                if(msg.ID == msgId)
                {
                    found = true;
                    break;
                }
            }

            return found;
        }

        //------------------------------------------------------------------------------
        // Internal API
        //------------------------------------------------------------------------------
        UserMessage FindMessage(uint msgId)
        {
            foreach(UserMessage msg in _Inbox)
            {
                if(msg.ID == msgId)
                {
                    return msg;
                }
            }
            return null;
        }

        void CacheSummary(UserMsgSummary summary) {
            UserMessage msg = FindMessage(summary.MessageID);
            if(null == msg)
            {
                Report.Debug( "CacheSummary[{0:x}] (NEW) MsgId: {1:x}, SenderId: {2:x}, Expire(Min): {3}",
                    _Owner.UserId, summary.MessageID, summary.SenderID, summary.ExpireMinutes);
                msg = new UserMessage(summary);
            }
            else
            {
                Report.Debug( "CacheSummary[{0:x}] (UPDATE) MsgId: {1:x}, SenderId: {2:x}, Expire(Min): {3}",
                    _Owner.UserId, summary.MessageID, summary.SenderID, summary.ExpireMinutes);
                msg.PopulateMetadata(summary);
            }
            _Inbox.Add(msg);
        }

        void CacheSummary(UserMsgSummary2 summary)
        {
            UserMessage msg = FindMessage(summary.MessageID);
            if(null == msg)
            {
                Report.Debug( "CacheSummary2[{0:x}] (NEW) MsgId: {1:x}, SenderId: {2:x}, Expire(Min): {3}",
                    _Owner.UserId, summary.MessageID, summary.SenderID, summary.ExpireMinutes);
                msg = new UserMessage(summary);
            }
            else
            {
                Report.Debug( "CacheSummary2[{0:x}] (UPDATE) MsgId: {1:x}, SenderId: {2:x}, Expire(Min): {3}",
                    _Owner.UserId, summary.MessageID, summary.SenderID, summary.ExpireMinutes);
                msg.PopulateMetadata(summary);
            }
            _Inbox.Add(msg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAcceptBuddy.cs ===
// PMsgAcceptBuddy.cs
//
//	Presence Accept Buddy Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Accept a request to be someone's buddy
	/// </summary>
	public class PMsgAcceptBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User accepting the request</param>
		/// <param name="buddy">Buddy that made the request</param>
		public PMsgAcceptBuddy( PNUser user, PNUser buddy ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ACCEPT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PAcceptBuddyMsgData data = new PAcceptBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Accept buddy request
	/// </summary>
	public class PAcceptBuddyMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BuddyID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAddAffiliates.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgAddAffiliates : PNRequestMsg
	{
        public PMsgAddAffiliates( PNUser user, uint dwFlags, uint dwTitleId, PNUser[] pnuAffiliates ) 
        {
            ulong[] Affiliates = new ulong[pnuAffiliates.Length];
            for (int i=0; i<pnuAffiliates.Length; i++)
            {
                Affiliates[i] = pnuAffiliates[i].UserId;
            }
            this.Initialize(user, dwFlags, dwTitleId, Affiliates);
        }
        public PMsgAddAffiliates( PNUser user, uint dwFlags, uint dwTitleId, ulong[] Affiliates )
        {
            this.Initialize(user, dwFlags, dwTitleId, Affiliates);
        }
        private void Initialize( PNUser user, uint dwFlags, uint dwTitleId, ulong[] Affiliates ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			Msg.Hdr.MsgType = XonPresNoti.PMSG_ADD_AFFILIATES;
			PAddAffiliatesMsgData data = new PAddAffiliatesMsgData();

			data.qwSenderID = user.UserId;
			data.dwMessageFlags = dwFlags;
			data.dwTitleID = dwTitleId;
			data.cwAffiliates = (ushort)(Affiliates.Length);
            data.pqwAffiliates = Affiliates;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AddAffiliates request
	/// </summary>
	public class PAddAffiliatesMsgData : PNMsgData
	{
            public ulong            qwSenderID;
            public uint               dwMessageFlags;
            public uint               dwTitleID;
            public ushort           cwAffiliates;
     
            [WireInfo(SizeParam="cwAffiliates")]
            public ulong[]          pqwAffiliates;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\AffiliateState.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Presence
{

	[Flags]
	public enum AffiliateFlags : uint {
		// Actual Affiliate Lists
		Encountered      = 0x00000001, 
		CompletedGame    = 0x00000002,
		PositiveFeedback = 0x00000004,
		NegativeFeedback = 0x00000008,
		AvoidingMe       = 0x00000010,
        Favorites        = 0x00000020,
		// Emulated Affiliate Lists
		Friend           = 0x00010000, 
		Block            = 0x00020000, 
		Mute             = 0x00040000, 
		Any              = 0xffffffff
	}
	
	// Affiliate state tracks affialiation for a given user. This is 
	// a heavy class but intended to be used across tests to do deep validation
	// of affiliation records
	public class AffiliateState
	{
        static uint[] MaxAffiliates = {
            50,    // encountered
            100,    // completed game
            50,    // positive feedback
            50,    // negative feedback
            50,    // avoiding me
            50     // favorites
        };

		//
		// One item indexed into multiple hash tables based on the 
		// loaded or populated Add() calls
		//
		public class AffiliateHashItem
		{
			void ClearMembers()
			{
				User         = null;
				AffiliateId  = 0;
				ListFlags    = 0;
				TitleId      = 0;
				SessionId    = 0;
				DateUpdated  = 0;
				GamerTag     = null;
			}

			public AffiliateHashItem()
			{
				ClearMembers();
			}

			public AffiliateHashItem(PNUser user)
			{
				ClearMembers();
				User = user;
				if(null != User.Xbox)
				{
					TitleId = User.Xbox.TitleId;
				}

				SessionId = User.MatchSessionId;
				GamerTag = User.Name;
				AffiliateId = User.UserId;
			}

			public AffiliateHashItem(PNUser user, QueryAffiliatesReplyData replyData)
			{
				this.User 		= user;
				AffiliateId 	= replyData.qwAffiliateID;
				ListFlags 	    = replyData.dwListFlags;
				TitleId 		= replyData.dwTitleID;
				SessionId 	    = replyData.qwSessionID;
				DateUpdated 	= replyData.mtDateUpdated;
				GamerTag 		= replyData.szGamerTag;
			}

			public PNUser	User;
			public ulong 	AffiliateId;
			public uint 	ListFlags;
			public uint 	TitleId;
			public ulong 	SessionId;
			public uint 	DateUpdated;
			public string 	GamerTag;
		}

		static Report _Report = new Report(typeof(AffiliateState).Name);

		FriendsCommon _FriendsCommon;
		PNUser _Owner;
		Hashtable _Unknown;            // Should not be in any affiliate list
		Hashtable _All;                // All affiliations stored (the master list)
		Hashtable _Encountered;        // Was Encountered
		Hashtable _CompletedGame;      // Was Preferred player
		Hashtable _PositiveFeedback;   // Feedback Server: Positive
		Hashtable _NegativeFeedback;   // Feedback Server: Negative
		//Hashtable _AvoidingMe;         // Feedback Server: Negative (reverse assoc)
        Hashtable _Favorites;          // Favorites List 

		bool _Initialized;
		int _AddPostSleep = 2000;

		//------------------------------------------------------------------------------
		// 
		// Internal methods
		//
		void CheckInitialized()
		{
			if(!_Initialized)
			{
				throw new UnexpectedTestResultException("AffiliatesState was not correctly initialized"); 
			}
		}

		void CheckExists(string tableName, Hashtable table, ulong [] list)
		{
			foreach(ulong puid in list)
			{
				if(!table.Contains(puid))
				{
					throw new UnexpectedTestResultException("User: " + puid.ToString("x") + " not found in table: " + tableName);
				}
			}
		}

		void CheckNotExists(string tableName, Hashtable table, ulong [] list)
		{
			foreach(ulong puid in list)
			{
				if(table.Contains(puid))
				{
					throw new UnexpectedTestResultException("User: " + puid.ToString("x") + " should not not found in table: " + tableName);
				}
			}
		}

		void AddToHash(Hashtable table, PNUser [] list, uint flags, uint titleId, uint MaxEntries)
		{
			foreach(PNUser u in list) 
			{
				// First ensure that the hash item is in the global index, notify
				// the test client if the flags or title ID is changing.
				AffiliateHashItem hashItem = _All[u.UserId] as AffiliateHashItem;
				if(null != hashItem)
				{
					uint preFlags = hashItem.ListFlags;
					uint preTitleId = hashItem.TitleId;

					hashItem.ListFlags |= flags;
					hashItem.TitleId = titleId;

					if(hashItem.ListFlags != preFlags)
					{
						_Report.Debug("AddToHash(): Modifying HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}", 
								u.UserId, preFlags, hashItem.ListFlags);
					}
					if(hashItem.TitleId != preTitleId)
					{
						_Report.Debug("AddToHash(): Modifying HashItem[{0:x}].TitleId: {1:x8}->{2:x8}", 
								u.UserId, preTitleId, hashItem.TitleId);
					}
				}
				else
				{
					hashItem = new AffiliateHashItem(u);
					hashItem.ListFlags = flags;
					hashItem.TitleId = titleId;
                    hashItem.DateUpdated = GetDateUpdated(table);
					_All[u.UserId] = hashItem;
				}

				// Index the new or existing hash item into the request hash table
                if (table.Count == MaxEntries)
                {
                    RemoveOldestFromHash(table, flags);
                }
				table[u.UserId] = hashItem;
			}
		}

        uint GetDateUpdated(Hashtable table)
        {
            if (table.Count == 0)
                return 0;

            AffiliateHashItem hi = null;
            foreach (AffiliateHashItem hashItem in table.Values)
            {
                if (hi == null)
                {
                    hi = hashItem;
                    continue;
                }
                if (hi.DateUpdated < hashItem.DateUpdated)
                {
                    hi = hashItem;
                }
            }
            return hi.DateUpdated + 1;
        }

        void RemoveOldestFromHash(Hashtable table, uint flags)
        {
            if(table.Count == 0)
                return;

            AffiliateHashItem hi = null;
            foreach(AffiliateHashItem hashItem in table.Values)
            {
                if (hi == null)
                {
                    hi = hashItem;
                    continue;
                }
                if (hi.DateUpdated > hashItem.DateUpdated)
                {
                    hi = hashItem;
                }
            }
            RemoveFromHash(table, hi.AffiliateId, flags);
        }

        void RemoveFromHash(Hashtable table, ulong UserId, uint flags)
        {
            AffiliateHashItem hashItem = _All[UserId] as AffiliateHashItem;
            if (null != hashItem)
            {
                uint preFlags = hashItem.ListFlags;
                hashItem.ListFlags &= ~flags;
                _Report.Debug("RemoveFromHash(): HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}",
                        UserId, preFlags, hashItem.ListFlags);
            }
            else
            {
                _Report.Warn("RemoveFromHash() on non-hashed user: {0:x}", UserId);
            }

            table.Remove(UserId);
        }

		void RemoveFromHash(Hashtable table, PNUser[] list, uint flags)
		{
			foreach(PNUser u in list)
			{
                RemoveFromHash(table, u.UserId, flags);
			}
		}


		//------------------------------------------------------------------------------
		//
		// Public methods
		//

		public AffiliateState()
		{
		}

		public AffiliateState(PNUser user)
		{
			Initialize(user);
		}


		public AffiliateState(AffiliateState copyState)
		{
			Initialize(copyState);
		}


		public void Initialize()
		{
			Initialize((PNUser)null);
		}

		public void Initialize(AffiliateState copyState)
		{
			Initialize(copyState._Owner);
		}

		public void Initialize(PNUser owner)
		{
			if(!_Initialized)
			{
				_FriendsCommon = new FriendsCommon();

				if(null == owner)
				{
					_Owner = _FriendsCommon.CreateXenonUser(true);
				}
				else
				{
					_Owner = owner;
				}

				_Unknown = new Hashtable();
				_All = new Hashtable();
				_Encountered = new Hashtable();
				_CompletedGame = new Hashtable();
				_PositiveFeedback = new Hashtable();
				_NegativeFeedback = new Hashtable();
                _Favorites = new Hashtable();
				_Report.Debug("Initialized state Owner Puid: " + _Owner.UserId.ToString("x") + ", TitleId: " + _Owner.Xbox.TitleId);
				_Initialized = true;
			}
		}

		// Clear all of the user hashes and reload them from the actual
		// server supplied data.
		public void Restore()
		{
			// Clear all hashes
			ClearHashTables();

			// Load hashtables
			Load(UInt32.MaxValue, false);
		}

		public void SetAddPostSleep(int millis)
		{
			_AddPostSleep = millis;
		}


		// Compare this state with another state. This would be used for
		// loading state from the query API and populating another state
		// from the Add API and comparing them piece by piece.
		public void Compare(AffiliateState inputState)
		{
			Compare(inputState, (uint)AffiliateFlags.Any);
		}

		public void Compare(AffiliateState inputState, uint flags)
		{
			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				// Compare each item in the hash tables to the input state
				foreach(AffiliateHashItem hashItem in _Encountered.Values)
				{
					if(!inputState._Encountered.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the encountered players table");
					}
				}
			}

			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				foreach(AffiliateHashItem hashItem in _CompletedGame.Values)
				{
					if(!inputState._CompletedGame.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the CompletedGame players table");
					}
				}
			}

            if (0 != (flags & (uint)AffiliateFlags.Favorites))
            {
                foreach (AffiliateHashItem hashItem in _Favorites.Values)
                {
                    if (!inputState._Favorites.Contains(hashItem.AffiliateId))
                    {
                        throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " +
                                hashItem.AffiliateId.ToString("x") + ", in the Favorite players table");
                    }
                }
            }

			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				foreach(AffiliateHashItem hashItem in _PositiveFeedback.Values)
				{
					if(!inputState._PositiveFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the positive feedback table");
					}

					if(inputState._NegativeFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state contains positive AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the negative feedback table");
					}
				}
			}

			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				foreach(AffiliateHashItem hashItem in _NegativeFeedback.Values)
				{
					if(!inputState._NegativeFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the negative feedback table");
					}

					if(inputState._PositiveFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state contains negative AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the positive feedback table");
					}
				}
			}
		}



		//------------------------------------------------------------------------------
		// 
		// User management
		//

		public PNUser[] GetFreeUserList(uint count)
		{
			return GetFreeUserList(count, false);
		}

		public PNUser[] GetFreeUserList(uint count, bool alive)
		{
			PNUser[] list = new PNUser[count];
			for(uint i = 0; i < count; ++i)
			{
				list[i] = GetFreeUser(alive);
			}

			return list;
		}

		public PNUser GetFreeUser()
		{
			return GetFreeUser(false);
		}

		public PNUser GetFreeUser(bool alive)
		{
			// Do the alive here (non-fatal)
			PNUser user = _FriendsCommon.CreateUser(alive);
			return user;
		}

		public void ReleaseUsers(PNUser[] list)
		{
			_FriendsCommon.ReleaseUsers(list);	
		}

		public void ReleaseUser(PNUser user)
		{
			_FriendsCommon.ReleaseUser(user);
		}


		//------------------------------------------------------------------------------
		// 
		// Load existing affiliate properties
		//
		
		void ValidateAndLoadHash(string name, uint flags, PQueryAffiliatesReplyMsgData replyData, Hashtable hashTable)
		{
			if(HResult.Failed(replyData.hr))
			{
				throw new HResultException(replyData.hr, "Failed to load affiliates data: "  + name);
			}

			_Report.Debug("ValidateAndLoadHash: "  + name + ", count: " + replyData.cdwResults);	

			for(uint i = 0; i < replyData.cdwResults; ++i)
			{
				QueryAffiliatesReplyData data = replyData.rgResults[i];
					
				// Validate the affiliate flags
				if((data.dwListFlags & flags) == 0)
				{
					throw new UnexpectedTestResultException("The list flags did not match the queried flags: " + name + ", " + data.dwListFlags.ToString("x"));
				}

				// TODO: these items require peer presence
				// Validate the affiliate ID
				// Validate the affiliate session ID
				// Validate the affiliate date updated
				
				// Find an existing hash item matching the input data
				AffiliateHashItem hashItem = _All[data.qwAffiliateID] as AffiliateHashItem;
				if(null == hashItem)
				{
				 	hashItem = new AffiliateHashItem(null, data);
					_All[data.qwAffiliateID] = hashItem;
				}
				else
				{
					_Report.Debug("Updating existing hash item for AffiliateId: " + data.qwAffiliateID.ToString("x"));

					hashItem.ListFlags = data.dwListFlags;
					hashItem.TitleId = data.dwTitleID;
					hashItem.SessionId = data.qwSessionID;
					hashItem.DateUpdated = data.mtDateUpdated;
				}

				// Store off the affiliate hash item
				hashTable[data.qwAffiliateID] = hashItem;
			}
		}

		// Default load ignores TitleId and grabs as much as possible
		public void Load()
		{
			Load(UInt32.MaxValue, false);
		}

		public PQueryAffiliatesReplyMsgData LoadExternal(uint limit, bool useTitleId, uint flags)
		{
			return LoadExternal(limit, useTitleId, flags, false);
		}

		public PQueryAffiliatesReplyMsgData LoadExternal(uint limit, bool useTitleId, uint flags, bool dataCenter)
		{
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			PMsgQueryAffiliates request = new PMsgQueryAffiliates(_Owner, limit, flags, queryTitleId);

			if(true == dataCenter)
			{
				request.AuthMethod  = PNRequestMsg.FDAuth.HttpHdr;
				request.PortOnFD    = PNRequestMsg.FDPort.PresNoti_DC;
			}

			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;
            request.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;

			return replyData;
		}

		public void Load(uint limit, bool useTitleId)
		{
			// This could all be done in one shot but I'm going to validate that each query only returns the set of players
			// that I'm interested in. Also going to query all to compare against what I got from individual queries.
			
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			// Create the query messages
			PMsgQueryAffiliates queryEncountered = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.Encountered, queryTitleId);
			PMsgQueryAffiliates queryCompletedGame = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.CompletedGame, queryTitleId);
			PMsgQueryAffiliates queryPositive = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.PositiveFeedback, queryTitleId);
			PMsgQueryAffiliates queryNegative = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.NegativeFeedback, queryTitleId);
            PMsgQueryAffiliates queryFavorites = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.Favorites, queryTitleId);
			PMsgQueryAffiliates queryAll = new PMsgQueryAffiliates(_Owner, limit, 0xffffffff, queryTitleId);
			

			// Issue all of the messages, validate and load them into the correct hash table
			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;

            queryEncountered.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("Encountereds", (uint)AffiliateFlags.Encountered, replyData, _Encountered);

            queryPositive.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("PositiveFeedback", (uint)AffiliateFlags.PositiveFeedback, replyData, _PositiveFeedback);

            queryCompletedGame.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("CompletedGames", (uint)AffiliateFlags.CompletedGame, replyData, _CompletedGame);

            queryFavorites.TransactFD(out replyMsg);
            replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
            ValidateAndLoadHash("Favorites", (uint)AffiliateFlags.Favorites, replyData, _Favorites);

            queryNegative.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("NegativeFeedback", (uint)AffiliateFlags.NegativeFeedback, replyData, _NegativeFeedback);

			// Do a full query and make sure that there aren't any users that are with unsupported flags
			
		}

		public void ClearHashTables()
		{
			_Unknown.Clear();
			_PositiveFeedback.Clear();
			_NegativeFeedback.Clear();
			_Encountered.Clear();
			_CompletedGame.Clear();
            _Favorites.Clear();
			_All.Clear();
		}

		public void ValidateAllServerAffiliates()
		{
			_Report.Debug("Validating all affiliates on server using IsAffiliate query");
			foreach(AffiliateHashItem hashItem in _All.Values)
			{
				PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, hashItem.AffiliateId);
				PNMsg reply;
                request.TransactFD(out reply);
				PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;

				if(HResult.Failed(data.hr))
				{
					throw new HResultException(data.hr, "IsAffiliate query failed");
				}
				if(data.hr == HResult.S_FALSE)
				{
					throw new HResultException(data.hr, "IsAffiliate return S_FALSE for affiliate that should exist.");
				}

				ValueCheck.Test("AffiliateId", hashItem.AffiliateId, data.qwAffiliateID);
				ValueCheck.TestBits("ListFlags", hashItem.ListFlags, data.dwListFlags);

				// Make sure that the user is in the appropriate hash tables
				Check(hashItem.AffiliateId, data.dwListFlags);

				_Report.Debug("Matched: " + data.qwAffiliateID.ToString("x") + ", dwListFlags: " + data.dwListFlags.ToString("x"));
			}
		}

		//------------------------------------------------------------------------------
		//
		// Affiliate list management
		//

		public void Add(PNUser user, uint flags)
		{
			Add(new PNUser[]{user}, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNUser user, uint flags, uint titleId)
		{
			Add(new PNUser[]{user}, flags, titleId);
		}

		public void Add(PNUser [] list, uint flags)
		{
			Add(list, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNUser [] list, uint flags, uint titleId)
		{
			CheckInitialized();

			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				AddToHash(_Encountered, list, flags, titleId, MaxAffiliates[0]);
			}
			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				RemoveFromHash(_NegativeFeedback, list, (uint)AffiliateFlags.NegativeFeedback);
				AddToHash(_PositiveFeedback, list, flags, titleId, MaxAffiliates[2]);
			}
			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				RemoveFromHash(_PositiveFeedback, list, (uint)AffiliateFlags.PositiveFeedback);
				AddToHash(_NegativeFeedback, list, flags, titleId, MaxAffiliates[3]);
			}
			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				// If you complete a game you also belong in the set of encountered
				// players
				AddToHash(_CompletedGame, list, (uint)AffiliateFlags.CompletedGame, titleId, MaxAffiliates[1]);
				AddToHash(_Encountered, list, (uint)AffiliateFlags.Encountered, titleId, MaxAffiliates[0]);
			}
            if (0 != (flags & (uint)AffiliateFlags.Favorites))
            {
                AddToHash(_Favorites, list, flags, titleId, MaxAffiliates[5]);
            }

			PMsgAddAffiliates req = new PMsgAddAffiliates(
					_Owner, 
					flags,
					titleId, 
					list);
			req.TransactFD();

			// Give the server time to complete the async transaction
			Thread.Sleep(_AddPostSleep);
		}

		public void Check(PNUser user, uint flags)
		{
			if(null == user)
			{
				throw new NullReferenceException("user");
			}

			Check(new PNUser[]{user}, flags);
		}

		public void Check(ulong userId, uint flags)
		{
			Check(new ulong[]{userId}, flags);
		}

		public void Check(PNUser[] list, uint flags)
		{
			if(null == list)
			{
				throw new NullReferenceException("list");
			}
			
			ulong []puids = new ulong[list.Length];
			uint count = 0;
			foreach(PNUser u in list)
			{
				puids[count++] = u.UserId;
			}
			
		}

		public void Check(ulong[] list, uint flags)
		{
			CheckExists("All users", _All, list);

			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				CheckExists("Encountered", _Encountered, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				CheckExists("CompletedGame", _CompletedGame, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				CheckNotExists("NegativeFeedback", _NegativeFeedback, list);
				CheckExists("PositiveFeedback", _PositiveFeedback, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				CheckNotExists("PositiveFeedback", _PositiveFeedback, list);
				CheckExists("NegativeFeedback", _NegativeFeedback, list);
			}
            if (0 != (flags & (uint)AffiliateFlags.Favorites))
            {
                CheckExists("Favorites", _Favorites, list);
            }
		}


		public void ValidateIsAffiliate(PNUser[] list)
		{
			foreach(PNUser user in list)
			{
				ValidateIsAffiliate(user);
			}
		}

		public void ValidateIsAffiliate(PNUser user)
		{
			PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, user);
			PNMsg reply;
            request.TransactFD(out reply);
			PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;
			if(HResult.Failed(data.hr))
			{
				throw new HResultException(data.hr, "IsAffiliate query failed");
			}

			ValueCheck.Test("IsAffiliate.AffiliateId mismatch", user.UserId, data.qwAffiliateID);
			ValueCheck.TestNonZero("IsAffiliate.ListFlags non-zero", data.dwListFlags);
		}

		public PIsAffiliateReplyMsgData ValidateIsAffiliateExternal(PNUser user)
		{
			PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, user);
			PNMsg reply;
            request.TransactFD(out reply);
			PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;
			return data;	
		}

		public void ValidateIsNotAffiliate(PNUser []list)
		{
			foreach(PNUser user in list)
			{
				ValidateIsNotAffiliate(user);
			}
		}

		public void ValidateIsNotAffiliate(PNUser user)
		{
			PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, user);
			PNMsg reply;
            request.TransactFD(out reply);
			PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;
			if(HResult.Failed(data.hr))
			{
				throw new HResultException(data.hr, "IsAffiliate query failed");
			}

			if(data.qwAffiliateID != user.UserId)
			{
				throw new UnexpectedTestResultException("IsAffiliate AffiliateId mismatch: " + data.qwAffiliateID + " != " + user.UserId);
			}

			ValueCheck.TestZero("IsAffiliate.ListFlags zero", data.dwListFlags);
			ValueCheck.Test("IsAffiliateHR(S_FALSE)", HResult.S_FALSE, data.hr);
		}

		public void ValidateAffiliateFlags(PNUser []list, uint flags)
		{
			foreach(PNUser user in list)
			{
				ValidateAffiliateFlags(user, flags);
			}
		}

		public void ValidateAffiliateFlags(PNUser user, uint flags)
		{
			bool found = false;
			PQueryAffiliatesReplyMsgData data = LoadExternal(UInt32.MaxValue, false, flags);
			foreach(QueryAffiliatesReplyData item in data.rgResults)
			{
				if(item.qwAffiliateID == user.UserId)
				{
					found = true;
					if((item.dwListFlags & flags) == 0)
					{
						throw new UnexpectedTestResultException("ValidateAffiliateFlags(): Affiliate found but dwListFlags: " + 
								item.dwListFlags.ToString("x") + " do not match input flags: " + flags.ToString("x"));
					}
					else
					{
						break;
					}
				}
			}

			if(!found)
			{
				throw new UnexpectedTestResultException("ValidateAffiliateFlags(): Affiliate not found: " + user.UserId.ToString("x")  +
								" for Owner: " + _Owner.UserId.ToString("x"));
			}
		}

		// Get the actual number of combined instances across all of the
		// specified lists in the flags 
		public uint GetInstanceCount(uint flags)
		{
			uint count = 0;


			CheckInitialized();

			count += (uint)_Encountered.Count;
			count += (uint)_CompletedGame.Count;
			count += (uint)_PositiveFeedback.Count;
			count += (uint)_NegativeFeedback.Count;
            count += (uint)_Favorites.Count;

			return count;
		}

		public PNUser GetOwner()
		{
			CheckInitialized();
			return _Owner;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAddBuddy.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgAddBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor, defaults to old style add, by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		public PMsgAddBuddy( PNUser user, PNUser buddy ) 
			: this( user, buddy, false ) 
		{} 

		//////////////////////////////////////
		/// <summary>
		/// Constructor, defaults to old style add 
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="byName">Ask using buddy name instead of PUID</param>
		public PMsgAddBuddy( PNUser user, PNUser buddy, bool byName )
            : this(user, buddy, 0, MsgDetails.CreateBlank(), byName)
		{}

		//////////////////////////////////////
		/// <summary>
		/// Constructor, allows flags and details for add2, defaults to add by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		public PMsgAddBuddy( PNUser user, PNUser buddy, uint flags, MsgDetails details ) 
			: this( user, buddy, flags, details, false ) 
		{} 

		/// <summary>
		/// Constructor, allows flags and details for add2, defaults to add by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		/// <param name="byName">Ask using buddy name instead of PUID</param>
		public PMsgAddBuddy( PNUser user, PNUser buddy, uint flags, MsgDetails details, bool byName ) 
			: this( user, 
					byName ? 0 : buddy.UserId, 
					byName ? buddy.Name : null,
					flags, 
					details )
		{}

		/// <summary>
		/// Constructor, buddyId or buddyName can be specified. Leave
		/// the either of them blank to change the behavior (add by name, add by id)
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddyId">User being asked to be buddies</param>
		/// <param name="buddyName">User being asked to be buddies</param>
		public PMsgAddBuddy( PNUser user, ulong buddyId, string buddyName)
            : this(user, buddyId, buddyName, 0, MsgDetails.CreateBlank())
		{}

		/// <summary>
		/// Constructor, allows flags and details for add2, buddyId or buddyName can be specified. Leave
		/// the either of them blank to change the behavior (add by name, add by id)
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddyId">User being asked to be buddies</param>
		/// <param name="buddyName">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		public PMsgAddBuddy( PNUser user, ulong buddyId, string buddyName, uint flags, MsgDetails details)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			Msg.Hdr.MsgType = XonPresNoti.PMSG_ADD_2;
			PAddBuddyMsgData2 data = new PAddBuddyMsgData2();

			data.UserID       = user.UserId;
			data.BuddyID      = buddyId;
			data.BuddyName    = buddyName;

                                                            if (details != null)
                                                            {
                                                                  data.Details = details;
                                                                  data.cbDetails = details.size;
                                                             }
           
                                                            data.MessageFlags = flags;

			Msg.Data          = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add buddy request
	/// </summary>
	public class PAddBuddyMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  BuddyID;
		public ushort BuddyNameLen;
		public string BuddyName; // ASCII Null terminated, only used if qwBuddyID == 0
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add buddy 2 request
	/// </summary>
	public class PAddBuddyMsgData2 : PNMsgData
	{
		public ulong      UserID;
		public ulong      BuddyID;
		public uint       MessageFlags;
		public ushort     cbDetails;
		[WireInfo(ArraySize=16)] // XONLINE_GAMERTAG_SIZE
		public string     BuddyName; // ASCII Null terminated, only used if qwBuddyID == 0
		public MsgDetails Details;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\FriendsCommon.cs ===
// FriendsCommon.cs
//
//  High level manipulation of presance and notification features
//
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Transactions;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.protocol.SubNoti;
using xonline.common.community;


namespace ServerTestFramework.LiveService.Presence
{
    /// <summary>
    /// Friends Common: high-level presence operation wrapper
    /// </summary>
    public class FriendsCommon
    {
        //
        // Default XBOX/XENON title ids.
        //
        // TODO: need a title store system that will give presence xlast data (currently
        // only way to do this is run the rich presence tests)
        //
        public const uint DefaultXenonTitleId = 0x20B00002;
        public const uint XenonDashTitleId = 0xFFFE07D1;
        public const uint MAXFRIENDS = 100;

        //
        // Pool user creations using bulk user creation
        //
        private static Queue _UserPool = new Queue();
        private static Report _Report = new Report(typeof(FriendsCommon).Name);
        public static uint UserAllocBlockSize = 128;
        public static string BlockAllocPrefix = "AA";

        //
        // Friends Common helper objects
        //
        public UacsCommon    UACS   = null;
        public RandomEx      Random = new RandomEx();

        /// <summary>
        /// Default constructor, friends common creates its own UACSCommon.
        /// </summary>
        public FriendsCommon() : this( new UacsCommon() ) {}

        /// <summary>
        /// Constructor, friends common uses given UACSCommon
        /// </summary>
        /// <param name="uacs">Provides access to high level uacs support</param>
        public FriendsCommon( UacsCommon uacs )
        {
            UACS = uacs;
        }

        /// <summary>
        /// Creates a new PNUser out of a newly createed UODB user
        /// </summary>
        /// <returns>New User</returns>
        public PNUser CreateUser()
        {
            return CreateUser( false );
        }

        /// <summary>
        /// Create a new xenon user in a online/offline state.
        /// <param name="alive">Alive new user</param>
        /// <returns>New User</returns>
        /// </summary>
        public PNUser CreateUser( bool alive )
        {
            return CreateXenonUser(alive);
        }


        /// <summary>
        /// Create a xenon version user using the last released version of the XDK.
        /// </summary>
        public PNUser CreateXenonUser(bool alive)
        {
            return CreateUser(alive, DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, CSGInfo.ClientType.Xenon);
        }

        /// <summary>
        /// Create a xenon version user using the last released version of the XDK.
        /// </summary>
        public PNUser CreateXenonUser(bool alive, uint titleId)
        {
            return CreateUser(alive, titleId, ClientVersions.LatestXenonClientVersion, CSGInfo.ClientType.Xenon);
        }

        /// <summary>
        /// Create a block of users using the CreateXenonUser() method
        /// </summary>
        public PNUser[] CreateXenonUsers(uint count, bool alive)
        {
            PNUser []users = new PNUser[count];
            for(uint i = 0; i < count; ++i)
            {
                users[i] = CreateXenonUser(alive);
            }
            return users;
        }

        /// <summary>
        /// Create a panorama version user using the last released version of the XDK.
        /// </summary>
        public PNUser CreatePanoramaUser(bool alive)
        {
            return CreateUser(alive, DefaultXenonTitleId, ClientVersions.LatestPCClientVersion, CSGInfo.ClientType.PC);
        }

        /// <summary>
        /// Create a panorama version user using the last released version of the XDK.
        /// </summary>
        public PNUser CreatePanoramaUser(bool alive, uint titleId)
        {
            return CreateUser(alive, titleId, ClientVersions.LatestPCClientVersion, CSGInfo.ClientType.PC);
        }

        /// <summary>
        /// Create a block of users using the CreateXenonUser() method
        /// </summary>
        public PNUser[] CreatePanoramaUsers(uint count, bool alive)
        {
            PNUser[] users = new PNUser[count];
            for (uint i = 0; i < count; ++i)
            {
                users[i] = CreatePanoramaUser(alive);
            }
            return users;
        }

        /// <summary>
        /// Legacy.  Use ClientType.
        /// </summary>
        public PNUser CreateUser(bool logon, uint titleId, ulong clientVersion, bool isXenon)
        {
            return CreateUser(logon, titleId, clientVersion, CSGInfo.ClientType.Xenon);
        }

        /// <summary>
        /// Explicitly create a user in a known title, client version and using xenon/xbox authdataflags
        /// </summary>
        public PNUser CreateUser( bool logon, uint titleId, ulong clientVersion, CSGInfo.ClientType clientType)
        {
            PNUser user = null;
            lock(_UserPool)
            {
                if(0 == _UserPool.Count)
                {
                    _Report.Debug("CreateUser(): out of free user objects");
                    AllocateUsers(UserAllocBlockSize);
                    WaitForXCache();
                }
                user = _UserPool.Dequeue() as PNUser;
            }

            if(user == null)
            {
                throw new UnexpectedTestResultException("Fatal: could not get an allocated user from the user pool");
            }

            this.UserChangeTitle(user, titleId, clientVersion, clientType);

            if( logon )
            {
                LogonUser( user, user.Xbox, false );
            }

            return user;
        }

        /// <summary>
        /// Release a block of users see ReleaseUser(PNUser user)
        /// </summary>
        public void ReleaseUsers(PNUser [] list)
        {
            foreach(PNUser user in list)
            {
                ReleaseUser(user);
            }
        }

        /// <summary>
        /// Release a user back the global shared user pool. Don't do this
        /// unless you know this user is clean for another test. This is mainly
        /// used a test case speed optimization or could be used during stress.
        ///
        /// In practice this is rarely neccessary.
        /// </summary>
        public void ReleaseUser(PNUser user)
        {
            lock(_UserPool)
            {
                _UserPool.Enqueue(user);
            }
        }

        /// <summary>
        /// Creates a new PNUser out of a newly createed Web Linked UODB user
        /// </summary>
        /// <returns>New User</returns>
        public PNUser CreateLinkedUser()
        {
            return CreateLinkedUser( false );
        }

        /// <summary>
        /// Creates a new PNUser out of a newly createed Web Linked UODB user,
        /// and optionally logs that user on.
        /// </summary>
        /// <param name="logon">Log on (Alive) new user</param>
        /// <returns>New User</returns>
        public PNUser CreateLinkedUser( bool logon )
        {
            Owner owner = new Owner( Random.GenerateRandomString( "StfPN", 15 ) );
            ulong userId = UACS.CreateUser( owner );
            byte[] webId = UACS.GenerateWebId( userId );

            LinkUser( owner, userId, webId );

            // Wait for link to propegate
            WaitForXCache();

            PNUser user = new PNUser( owner.gamertag, userId );
            user.WebId = webId;

            if( logon )
            {
                LogonUser( user );
            }

            return user;
        }

        /// <summary>
        /// Link an account using the owner puid and owner object
        /// return the user puid (used for testing minor accounts).
        /// </summary>
        protected void LinkUser(Owner owner, ulong userPuid, byte[] webPuid)
        {
            XRLLinkWebAccountResponse resp;
            XRLLinkWebAccount req = new XRLLinkWebAccount();
            req.cardHolder = owner.cardHolder;
            req.cardNumber = owner.cardNumber;
            req.postalCode = owner.postalCode;
            req.phoneExtension = owner.phoneExtension;
            req.phoneNumber = owner.phoneNumber;
            req.phonePrefix = owner.phonePrefix;
            req.gamertag = owner.gamertag;
            req.webId = webPuid;

            if(!req.Execute(out resp))
            {
                UnexpectedXRLTestResultException e = new UnexpectedXRLTestResultException("FriendsCommon.LinkUser() failed to link owner account: " + req.GetDumpString());
                e.xrl=req;
                throw e;
            }

            Global.RO.Debug("Account linked: OwnerPuid: " + resp.OwnerPuid.ToString("x") + ", UserPuid: " + resp.UserPuid.ToString("x") + ", WebPuid: " + Hexer.tohex(webPuid));
        }

        /// <summary>
        /// Alives a user into presence seting up a new PNXbox for the user to connect to the
        /// FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser( PNUser user )
        {
            return LogonUser( user, user.Xbox, false );
        }

        /// <summary>
        /// Alives a user into presence seting up a new PNXbox for the user to connect to the
        /// FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <param name="appearOffline">Set this flag to logon cloaked</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser(PNUser user, bool appearOffline)
        {
            return LogonUser( user, user.Xbox, appearOffline);
        }

        /// <summary>
        /// Alives a user into presence with a particular Tittle ID, seting up a new PNXbox for the user to
        /// connect to the FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <param name="titleId">Title to log into</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser( PNUser user, uint titleId )
        {
            return LogonUser( user, titleId, false );
        }

        /// <summary>
        /// Alives a user into presence with a particular Tittle ID, seting up a new PNXbox for the user to
        /// connect to the FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <param name="titleId">Title to log into</param>
        /// <param name="appearOffline">Set this flag to logon cloaked</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser( PNUser user, uint titleId, bool appearOffline)
        {
            PNXbox xbox = null;

            // If the user has a Xbox change their title ID
            // else log them in on a brand new xbox
            if(null != user.Xbox)
            {
                xbox = user.Xbox;
                xbox.ChangeTitle(titleId);
            }
            else
            {
                 xbox = new PNXbox( titleId );
            }
            return LogonUser( user, xbox, appearOffline);
        }

        /// <summary>
        /// Alives a user into presence, optionally seting up a new PNXbox for the user
        /// to connect to the FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <param name="xbox">Xbox to connect user through, null to create one</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser( PNUser user, PNXbox xbox )
        {
            return LogonUser(user, xbox, false);
        }

        /// <summary>
        /// Alives a user into presence, optionally seting up a new PNXbox for the user
        /// to connect to the FakeSG with.
        /// </summary>
        /// <param name="user">User to logon</param>
        /// <param name="xbox">Xbox to connect user through, null to create one</param>
        /// <param name="appearOffline">Set this flag to logon cloaked</param>
        /// <returns>Success Flavor of HR returned in alive reply msg</returns>
        public uint LogonUser( PNUser user, PNXbox xbox, bool appearOffline)
        {
            if( user.LoggedOn )
            {
                Global.RO.Error( "FriendsCommon.LoginUser(): User Already Logged On" );
                return HResult.S_OK;
            }

            // If the user passes a null xbox create a default xbox
            if( xbox == null )
            {
                xbox = new PNXbox();
            }

            // Make sure they exist on the xbox both in the STF appdomain and in the
            // FakeSG appdomain
            user.Connect(xbox);

            // By default when you alive you are cloaked, this is enforced on
            // the server
            uint hr = user.Alive();
            if(HResult.Succeeded(hr))
            {
                if(appearOffline)
                {
                    // Don't change the state bits
                    user.SetTitleData();
                }
                else
                {
                    user.State &= ~(XonPresNoti.P_STATE_MASK_CLOAKED);
                    user.SetTitleData();
                }
            }

            return hr;
        }

        /// <summary>
        /// Disconnect the user on the xbox living in the fake sg (clears their user
        /// slot) and clear the user's internal presence state.
        /// </summary>
        /// <param name="user"></param>
        public void LogoffUser( PNUser user )
        {
            if( ! user.LoggedOn )
            {
                Global.RO.Error( "FriendsCommon: User already logged off" );
            }
            else
            {
                user.Disconnect();
                user.ClearState();
            }
        }

        /// <summary>
        /// Used to setup operations that require users to be logged on and stores their
        /// initail state so it can be restored
        /// </summary>
        /// <param name="user1">First user</param>
        /// <param name="wasOffline1">Original logon state of first user</param>
        /// <param name="user2">Second user</param>
        /// <param name="wasOffline2">Original logon state of second user</param>
        private void PrepUserPair( PNUser user1, out bool wasOffline1, PNUser user2, out bool wasOffline2 )
        {
            wasOffline1 = !user1.LoggedOn;
            if( wasOffline1 )
            {
                LogonUser( user1 );
            }

            wasOffline2 = !user2.LoggedOn;
            if( wasOffline2 )
            {
                LogonUser( user2 );
            }
        }

        /// <summary>
        /// Used to cleanup after operations that required users to be logged on based on
        /// their initail state
        /// </summary>
        /// <param name="user1">First user</param>
        /// <param name="wasOffline1">Original logon state of first user</param>
        /// <param name="user2">Second user</param>
        /// <param name="wasOffline2">Original logon state of second user</param>
        private void RestoreUserPair( PNUser user1, bool wasOffline1, PNUser user2, bool wasOffline2 )
        {
            if( wasOffline1 && user1.LoggedOn )
            {
                LogoffUser( user1 );
            }

            if( wasOffline2 && user2.LoggedOn )
            {
                LogoffUser( user2 );
            }
        }

        /// <summary>
        /// Asks someone who isn't already a buddy to be one or just verifies that the
        /// request has been made
        /// </summary>
        /// <param name="requestor">User doing asking</param>
        /// <param name="requestee">User being asked</param>
        public void RequestFriend( PNUser requestor, PNUser requestee )
        {
            // Get initial logon state of users and log them in if they're not
            bool requestorOffline;
            bool requesteeOffline;
            PrepUserPair( requestor, out requestorOffline, requestee, out requesteeOffline );

            // Make sure we're not already buddies
            if( requestor.BuddyStatusOK( requestee ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Making a request to someone who's arleady a buddy." );
            }
            if( requestee.BuddyStatusOK( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Asking someone to be my buddy who thinks I already am." );
            }

            // If requestor hasn't arleady made the request do it
            if( ! requestor.BuddyStatusPending( requestee ) )
            {
                requestor.AddBuddy( requestee );
                requestor.WaitForBuddyStatusPending( requestee );
                requestee.WaitForBuddyStatusRequested( requestor );
            }

            // Requestee had to have been asked by now
            if( ! requestee.BuddyStatusRequested( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Buddy with request status missing." );
            }

            // Restore users original logon state
            RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
        }

        /// <summary>
        /// Verifies tht a buddy request can be accepted and does it
        /// </summary>
        /// <param name="requestee">User that been asked</param>
        /// <param name="requestor">User that did asking</param>
        public void AcceptFriend( PNUser requestee, PNUser requestor )
        {
            // Get initial logon state of users and log them in if they're not
            bool requestorOffline;
            bool requesteeOffline;
            PrepUserPair( requestor, out requestorOffline, requestee, out requesteeOffline );

            // Make sure we're not already buddies
            if( requestee.BuddyStatusOK( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Accepting a buddy request from someone that arleady a buddy." );
            }
            if( requestor.BuddyStatusOK( requestee ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Getting a reaquest from someone who thinks we're already buddies." );
            }

            // Make sure request is pending
            if( ! requestee.BuddyStatusRequested( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Trying to accept a request when I haven't been asked." );
            }
            if( ! requestor.BuddyStatusPending( requestee ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Trying to accept a request from someone that doesn't think they asked." );
            }

            // Seal the deal
            requestee.AcceptBuddy( requestor );
            requestee.WaitForBuddyStatusOK( requestor );
            requestor.WaitForBuddyStatusOK( requestee );

            // Restore users original logon state
            RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
        }

        /// <summary>
        /// Verifies tht a buddy request can be rejected and does it
        /// </summary>
        /// <param name="requestee">User that been asked</param>
        /// <param name="requestor">User that did asking</param>
        public void RejectFriend( PNUser requestee, PNUser requestor )
        {
            RejectFriend( requestee, requestor, false);
        }

        /// <summary>
        /// Verifies tht a buddy request can be rejected and does it
        /// </summary>
        /// <param name="requestee">User that been asked</param>
        /// <param name="requestor">User that did asking</param>
        /// <param name="never">Put them on never list?</param>
        public void RejectFriend( PNUser requestee, PNUser requestor, bool never )
        {
            // Get initial logon state of users and log them in if they're not
            bool requestorOffline;
            bool requesteeOffline;
            PrepUserPair( requestor, out requestorOffline, requestee, out requesteeOffline );

            // Make sure we're not already buddies
            if( requestee.BuddyStatusOK( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Rejecting a buddy request from someone that arleady a buddy." );
            }
            if( requestor.BuddyStatusOK( requestee ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Getting a reject from someone who thinks we're already buddies." );
            }

            // Make sure request is pending
            if( ! requestee.BuddyStatusRequested( requestor ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Trying to reject a request when I haven't been asked." );
            }
            if( ! requestor.BuddyStatusPending( requestee ) )
            {
                RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                throw new Exception( "Buddy status problem. Trying to reject a request from someone that doesn't think they asked." );
            }

            // Seal the deal
            requestee.RejectBuddy( requestor, never );
            requestee.WaitForBuddyStatusDeleted( requestor );
            requestor.WaitForBuddyStatusDeleted( requestee );

            // Restore users original logon state
            RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
        }

        /// <summary>
        /// Establish a one to many friend relationship
        /// </summary>
        public void MakeFriends( PNUser requestor, PNUser []requestee)
        {
            foreach(PNUser f in requestee)
            {
                MakeFriend(requestor, f);
            }
        }

        /// <summary>
        /// Verifies, Finishes, or completes from the start the exstablishment of buddy
        /// relationship for two users.
        /// </summary>
        /// <param name="requestor">User doing asking</param>
        /// <param name="requestee">User being asked</param>
        public void MakeFriend( PNUser requestor, PNUser requestee )
        {
            // Get initial logon state of users and log them in if they're not
            bool requestorOffline;
            bool requesteeOffline;
            PrepUserPair( requestor, out requestorOffline, requestee, out requesteeOffline );

            // if requestor areledy thinks requestee is a buddy
            bool friendsAlready = false;
            if( requestor.BuddyStatusOK( requestee ) )
            {
                // Make sure requestee agrees they are and flag the deal as done
                if( ! requestee.BuddyStatusOK( requestor ) )
                {
                    RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                    throw new Exception( "Buddy status mismatch. If one is OK, both should be." );
                }
                friendsAlready = true;
            }
            else
            {
                // Make Sure requestee also thinks they're not buddies yet
                if( requestee.BuddyStatusOK( requestor ) )
                {
                    RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                    throw new Exception( "Buddy status mismatch. If one isn't OK, both should be." );
                }
            }

            // Do the Deal
            if( ! friendsAlready )
            {
                // If requestor has arleady recived request, accept it
                if( requestor.BuddyStatusRequested( requestee ) )
                {
                    requestor.AcceptBuddy( requestee );
                }
                else
                {
                    // If requestor hasn't arleady made the request do it
                    if( ! requestor.BuddyStatusPending( requestee ) )
                    {
                        requestor.AddBuddy( requestee );
                        requestor.WaitForBuddyStatusPending( requestee );
                        requestee.WaitForBuddyStatusRequested( requestor );
                    }

                    // Requestee had to have been asked by now
                    if( ! requestee.BuddyStatusRequested( requestor ) )
                    {
                        RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                        throw new Exception( "Buddy status problem. Buddy with request status missing." );
                    }

                    requestee.AcceptBuddy( requestor );
                }
                requestee.WaitForBuddyStatusOK( requestor );
                requestor.WaitForBuddyStatusOK( requestee );

                requestor.Xbox.SendSubscribeForUser(requestor.UserId, new DATA_OBJECT_SPECIFIER[] { requestor.GetBasicPresenceDataObjectSpecifier(requestee.UserId) });
                Thread.Sleep(100);
                requestor.Xbox.SendSubscribeForUser(requestor.UserId, new DATA_OBJECT_SPECIFIER[] { requestor.GetRichPresenceDataObjectSpecifier(requestee.UserId) });
                requestee.Xbox.SendSubscribeForUser(requestee.UserId, new DATA_OBJECT_SPECIFIER[] { requestee.GetBasicPresenceDataObjectSpecifier(requestor.UserId) });
                Thread.Sleep(100);
                requestee.Xbox.SendSubscribeForUser(requestee.UserId, new DATA_OBJECT_SPECIFIER[] { requestee.GetRichPresenceDataObjectSpecifier(requestor.UserId) });

                ProcessInitialAnnounce(requestee, requestor);
                ProcessInitialAnnounce(requestor, requestee);
            }

            // Restore users original logon state
            RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );



        }

        /// <summary>
        /// Makes 2 users friends of each other, given their puids.
        /// This version is much faster to execute than MakeFriend:
        ///   It pokes directly at the uodb sproc rather than going through the normal process.
        ///   No major verification is done.
        /// </summary>
        public void MakeFriendFast(ulong puid0, ulong puid1)
        {
            //get gamertags for these users
            string tag0 = UodbWS.GetGamertag(puid0);
            string tag1 = UodbWS.GetGamertag(puid1);

            //add friend request from 0 to 1
            {
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_pres_add_friend_V2";
                ws.SetHashVal(puid0);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", puid0);
                ws.AddParameter("@bi_friend_puid", puid1);
                ws.AddParameter("@vc_friend_gamertag", tag1);

                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    string extraInfo="";
                    if (hr==2148868098) extraInfo+=" (E_NOTIFICATION_LIST_FULL)";

                    throw new System.Exception("MakeFriendFast: sproc failed: p_pres_add_friend_V2: hr=" + hr + extraInfo);
                }
            }

            //1 gets friend request from 0
            {
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_pres_added_friend_V2";
                ws.SetHashVal(puid1);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", puid1);
                ws.AddParameter("@bi_friend_puid", puid0);
                ws.AddParameter("@vc_friend_gamertag", tag0);

                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    string extraInfo="";
                    if (hr==2148868105) extraInfo+=" (E_NOTIFICATION_OTHER_LIST_FULL)";

                    throw new System.Exception("MakeFriendFast: sproc failed: p_pres_added_friend: hr=" + hr + extraInfo);
                }
            }

            //1 accepts friend request from 0
            {
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_pres_accept_friend_V2";
                ws.SetHashVal(puid1);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", puid1);
                ws.AddParameter("@bi_friend_puid", puid0);

                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new System.Exception("MakeFriendFast: sproc failed: p_pres_accept_friend: hr=" + hr);
                }
            }

            //0 gets acceptance of friend request from 1
            {
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);

                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_pres_accepted_friend_V2";
                ws.SetHashVal(puid0);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", puid0);
                ws.AddParameter("@bi_friend_puid", puid1);

                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new System.Exception("MakeFriendFast: sproc failed: p_pres_accepted_friend: hr=" + hr);
                }
            }
        }

        // The buddy setup will do an initial announce/subscribed and we
        // receive a single presence item which we should dequeue to keep
        // from interfering with tests that will be expecting later presence
        // items
        public void ProcessInitialAnnounce(PNUser user, PNUser target)
        {
            UserNotification unoti = null ;
            PNUser.BuddyInfo bi = null;

            bi = user.GetBuddyInfo(target.UserId);
            ValueCheck.TestNotNull("BuddyInfo", bi);
            if(user.Xbox.CanConsumeRichPresence())
            {
                // Make sure we've gotten a presence item
                if(null == bi.RichPresenceData)
                {
                    unoti = user.WaitForUserNotifications(DATA_TYPES.eRichPresenceString);
                }
            }
            else
            {
                if(0== bi.BasicPresenceData.State)
                {
                    unoti = user.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
                }
            }

            // Process the initial presence item dequeue if it hasn't already been handled
            if(null != unoti)
            {
                user.HandleTCPNotification(unoti);
            }
        }

        /// <summary>
        /// Verifies or does the removal of a buddy relationship for two uesrs
        /// </summary>
        /// <param name="requestor">User doing asking</param>
        /// <param name="requestee">User being asked</param>
        public void DeleteFriend( PNUser requestor, PNUser requestee )
        {
            // Get initial logon state of users and log them in if they're not
            bool requestorOffline;
            bool requesteeOffline;
            PrepUserPair( requestor, out requestorOffline, requestee, out requesteeOffline );

            // if requestor areledy thinks requestee isn't a buddy
            bool estrangedAlready = false;
            if( ! requestor.IsBuddy( requestee ) )
            {
                // Make sure requestee aggrees they're not and flag the delete already done
                if( requestee.IsBuddy( requestor ) )
                {
                    RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                    throw new Exception( "Buddy status mismatch. If one is missing, both should be." );
                }
                estrangedAlready = true;
            }
            else
            {
                // Make Sure requestee thinks they're buddies
                if( ! requestee.IsBuddy( requestor ) )
                {
                    RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
                    throw new Exception( "Buddy status mismatch. If one is there, both should be." );
                }
            }

            // Do the delete
            if( ! estrangedAlready )
            {
                if( requestor.BuddyStatusRequested( requestee ) )
                {
                    requestor.RejectBuddy( requestee );
                }
                else
                {
                    requestor.DeleteBuddy( requestee );
                }
                requestor.WaitForBuddyStatusDeleted( requestee );
                requestee.WaitForBuddyStatusDeleted( requestor );
            }

            // Restore users original logon state
            RestoreUserPair( requestor, requestorOffline, requestee, requesteeOffline );
        }

        /// <summary>
        /// Manually allocate users in the global PNUser queue using the bulk user allocator
        /// </summary>
        private void AllocateUsers(uint count)
        {
            _Report.Debug("Allocating {0} users...", count);
            ProgressInfo progress = new ProgressInfo("Allocating users", count, 1);

            // Create the new bulk user set
            BulkUserSet userSet;
            UodbWS.CreateBulkUsers(
                /*GT Prefix*/BlockAllocPrefix, 
                count,
                /*OfferID. we are using OfferType.StarterKit12Month*/ 0xFFFE000080000008, 
                /*Country code*/(byte)103, 
                /*isXenon*/true, 
                /*Partner Optin*/false, 
                /*Out userset*/out userSet
                );
            for(uint i = 0; i < userSet.Count; ++i)
            {
                // Create the user object
                PNUser user = new PNUser(userSet.IndexToGamertag(i), userSet.IndexToPuid(i));

                // Put user onto free stack
                _UserPool.Enqueue(user);
                progress.Step();
            }

            progress.Finish();
            _Report.Debug("Allocated {0} users", count);
        }

        /// <summary>
        /// Manually allocate a block of xenon users. These users will not be populated
        /// in the default user pool.
        /// <summary>
        public PNUser[] CreateXenonUsers(string prefix, uint count, byte countryCode)
        {
            prefix = prefix.Trim().Substring(0, 2);
            PNUser[] returned = new PNUser[count];

            // Create the new bulk user set
            BulkUserSet userSet;
            UodbWS.CreateBulkUsers(
                /*GT Prefix*/BlockAllocPrefix,
                count,
                /*OfferID. we are using OfferType.StarterKit12Month*/ 0xFFFE000080000008,
                /*Country code*/countryCode,
                /*isXenon*/true,
                /*Partner Optin*/false,
                /*Out userset*/out userSet
                );

            for(uint i = 0; i < userSet.Count; ++i)
            {
                // Create the user object, connect user to xenon version xbox
                PNUser user = new PNUser(userSet.IndexToGamertag(i), userSet.IndexToPuid(i));
                PNXbox xbox = new PNXbox(DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, true);
                user.Connect(xbox);
                returned[i] = user;
            }

            return returned;
        }


        /// <summary>
        ///  Legacy.  Use ClientType
        /// </summary>
        public void UserChangeTitle(PNUser user, uint titleId, ulong clientVersion, bool isXenon)
        {
            UserChangeTitle(user, titleId, clientVersion, CSGInfo.ClientType.Xenon );
        }

        /// <summary>
        /// High level title change function. Automatically changes title of the currently connected
        /// xbox on the user or intantiates a new xbox with the provided title information.
        /// </summary>
        public void UserChangeTitle(PNUser user, uint titleId, ulong clientVersion, CSGInfo.ClientType clientType )
        {
            // Create a new xbox for the user if one is not linked or it is not the correct
            // type of client
            //
            // else reconnect to existing xbox
            if(     null == user.Xbox ||
                (user.Xbox.ClientType != clientType) ||
                (user.Xbox.ClientVersion != clientVersion))
            {
                user.Xbox = new PNXbox(titleId, clientVersion, clientType);
            }
            else
            {
                if(user.Xbox.TitleId != titleId)
                {
                    user.Xbox.ChangeTitle(titleId);
                }
            }
        }

        /// <summary>
        /// Wait for time for xcache.
        /// </summary>
        public static void WaitForXCache()
        {
            int wait = Config.GetIntSetting(Setting.xcache_db_pollingInterval);
            Global.RO.Debug("Sleeping " + wait.ToString() + "s (for Xcache)");
            Thread.Sleep(wait * 1000);
        }

        /// <summary>
        /// Makes two users friends by hitting the databases directly 
        /// Cache layer is NOT updated.
        /// </summary>
        public static void LightWeightMakeFriends(ulong userId, ulong friendId, string userGamertag, string friendGamertag)
        {
            LightWeightFriendAdd(userId, friendId, userGamertag, friendGamertag);
            LightWeightFriendAccept(friendId, userId);
        }

        /// <summary>
        /// Adds a friend relationship by doing inserts on both UODB partitions by passing the cache layer. 
        /// </summary>
        /// <param name="userId">xuid of user requesting friendship</param>
        /// <param name="friendId">xuid of target user</param>
        /// <param name="userGamertag">gamertag of requesting user</param>
        /// <param name="friendGamertag">request target gamertag</param>
        public static void LightWeightFriendAdd(ulong userId, ulong friendId, string userGamertag, string friendGamertag)
        {
            if (string.IsNullOrEmpty(userGamertag) || userGamertag.Length >= PresDefs.XONLINE_GAMERTAG_SIZE)
            {
                throw new ArgumentException("userGamertag is the wrong length", "userGamertag");
            }

            if (string.IsNullOrEmpty(friendGamertag) || friendGamertag.Length >= PresDefs.XONLINE_GAMERTAG_SIZE)
            {
                throw new ArgumentException("friendGamertag is the wrong length", "friendGamertag");
            }

            using (TransactionScope txnScope = new TransactionScope())
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE),
                        ws2 = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    /*
                    * Do the sproc calls in the same order as the xuids.
                    * This prevents issues if both users are making friend requests to each other at the same time.
                    */
                    ws.ClearParameters();

                    ws.StoredProc = "dbo.p_pres_add_friend_V2";
                    ws.Partition = ws.CalcPartition(userId);

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter("@bi_user_puid", userId);
                    ws.AddParameter("@bi_friend_puid", friendId);
                    ws.AddParameter("@vc_friend_gamertag", friendGamertag);
                    ws.AddParameter("@i_friend_limit", Config.GetSetting("presence_MaxFriends"));

                    WstDataReader reader = ws.Execute();
                    uint hr = (uint)ws.GetIntParameter("@RETVAL");

                    if (HResult.Failed(hr))
                    {
                        throw new Exception("Error calling p_pres_add_friend_V2");
                    }
                    reader.Close();

                    ws2.StoredProc = "dbo.p_pres_added_friend_V2";
                    ws2.Partition = ws2.CalcPartition(friendId);

                    ws2.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws2.AddParameter("@bi_user_puid", friendId);
                    ws2.AddParameter("@bi_friend_puid", userId);
                    ws2.AddParameter("@vc_friend_gamertag", userGamertag);
                    ws2.AddParameter("@i_friend_limit", Config.GetSetting("presence_MaxFriends"));

                    WstDataReader reader2 = ws2.Execute();
                    hr = (uint)ws2.GetIntParameter("@RETVAL");

                    if (HResult.Failed(hr))
                    {
                        throw new Exception("Error calling p_pres_added_friend_V2");
                    }
                    reader.Close();
                }

                txnScope.Complete();
            }

            return;
        }

        /// <summary>
        /// Accepts an existing friend request by passing the cache layer
        /// </summary>
        /// <param name="userId">xuid of user doing the accepting</param>
        /// <param name="friendId">xuid of user who sent the request</param>
        public static void LightWeightFriendAccept(ulong userId, ulong friendId)
        {
            using (TransactionScope txnScope = new TransactionScope())
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE),
                        ws2 = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                        ws.ClearParameters();

                        ws.StoredProc = "dbo.p_pres_accept_friend_V2";
                        ws.Partition = ws.CalcPartition(userId);

                        ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                        ws.AddParameter("@bi_user_puid", userId);
                        ws.AddParameter("@bi_friend_puid", friendId);

                        WstDataReader reader = ws.Execute();
                        uint hr = (uint)ws.GetIntParameter("@RETVAL");

                        if (HResult.Failed(hr))
                        {
                            throw new Exception("Error calling p_pres_accept_friend_V2");
                        }

                        reader.Close();
                        ws2.ClearParameters();

                        ws2.StoredProc = "dbo.p_pres_accepted_friend_V2";
                        ws2.Partition = ws2.CalcPartition(friendId);

                        ws2.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                        ws2.AddParameter("@bi_user_puid", friendId);
                        ws2.AddParameter("@bi_friend_puid", userId);

                        WstDataReader reader2 = ws2.Execute();
                        hr = (uint)ws2.GetIntParameter("@RETVAL");

                        if (HResult.Failed(hr))
                        {
                            throw new Exception("Error calling p_pres_accepted_friend_V2");
                        }
                }

                txnScope.Complete();
            }
        }


        // gets the list of titles propped to the service 
        public static uint[] GetListOfProppedTitleIds()
        {
            //TitleConfig tcfg = TitleConfig();
            List<uint> titleIds = new List<uint>();

            using (WSClient ws = new WSClient(ConfigUtil.NpdbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.CommandSql = "select i_title_id from t_game_config where i_title_id < 3131943500 and i_title_id > 570425359 and not (i_title_id  >= 1347420161 and i_title_id <= 1347420677) and not (i_title_id  >= 1480675328 and i_title_id <= 1480679425) and not (i_title_id  >= 1481770961 and i_title_id <= 1481953281)";
                using (WstDataReader reader = ws.Execute())
                {
                    int titleIdOrd = reader.GetOrdinal("i_title_id");

                    while (reader.Read())
                    {
                        uint titleId = (uint)reader.GetInt32(titleIdOrd);
                        titleIds.Add(titleId);
                    }
                }
            }

            return titleIds.ToArray();
        }

        public SettingState SetMaxFriends(uint newVal)
        {
            XConfig xconfig = new XConfig();
            SettingState st =  xconfig.OverrideSetting("ALL", "ALL", Setting.presence_MaxFriends, newVal.ToString());
            Thread.Sleep(5000);
            xconfig.ForceConfigReload(VirtualInterface.xpnfd_presence);
            xconfig.ForceConfigReload(VirtualInterface.xpnfd_presence_int);
            xconfig.CheckForUpdates();
            return st;
        }
        public bool ResetMaxFriends(SettingState  originalState)
        {
            XConfig xconfig = new XConfig();
            xconfig.RestoreOverrideSettingState(originalState);
            Thread.Sleep(5000);
            xconfig.ForceConfigReload(VirtualInterface.xpnfd_presence);
            xconfig.ForceConfigReload(VirtualInterface.xpnfd_presence_int);
            xconfig.CheckForUpdates();
            return true;
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMMsgFriendsLimitedPresence.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
    /// <summary>
    /// GetFriends Limited Presence
    /// </summary>
    public class PMMsgFriendsLimitedPresence : PNRequestMsg
	{
        /// <summary>
        /// ctor
        /// </summary>
        /// <param name="sender">sender</param>
        public PMMsgFriendsLimitedPresence(PNUser sender) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.PMSG_FRIENDSLIST_LIMITED_PRECENSE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;

            PFriendsLimitedPresenceMsgData data = new PFriendsLimitedPresenceMsgData();
			data.SenderId = sender.UserId;
			Msg.Data = data;
		}
	}

    /// <summary>
    /// GetFriends Limited Presence request data
    /// </summary>
    public class PFriendsLimitedPresenceMsgData : PNMsgData
    {
        public ulong SenderId;
    }

    /// <summary>
    /// Response data for GetFriends Limited Presence request
    /// </summary>
    public class PFriendsLimitedPresenceReplyMsgData : PNMsgData
    {
        public uint HR;
        public ulong UserID;
        public uint cdwFriends;

        [WireInfo(SizeParam = "cdwFriends")]
        public PFriendsLimitedPresenceData[] rgFriends;
    }

    /// <summary>
    /// PFriendsLimitedPresenceData
    /// </summary>
    public class PFriendsLimitedPresenceData : WireData
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        [WireInfo(ArraySize = 16)]
        public string szGamerTag;
    }   

    /// <summary>
    /// GetFriends Limited Presence
    /// </summary>
    public class PMMsgFriendsNoPresence : PNRequestMsg
    {
        /// <summary>
        /// ctor
        /// </summary>
        /// <param name="sender">sender</param>
        public PMMsgFriendsNoPresence(PNUser sender)
        {
            SentFrom = Requestor.Client;
            PortOnFD = FDPort.PresNoti_DC;
            AuthMethod = FDAuth.HttpHdr;
            ServiceOnFD = FDService.Presence;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.PMSG_FRIENDSLIST_NO_PRECENSE;
            Msg.Hdr.MsgLen = 0;
            Msg.Hdr.SeqNum = PresSeqNum;

            // Fill out the SGADDR so we can resolve the psuedo 
            // XBOX info from the FakeSG for creating HTTP auth
            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg = sender.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg = sender.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;

            PFriendsNoPresenceMsgData data = new PFriendsNoPresenceMsgData();
            data.SenderId = sender.UserId;
            Msg.Data = data;
        }
    }

    /// <summary>
    /// GetFriends Limited Presence request data
    /// </summary>
    public class PFriendsNoPresenceMsgData : PNMsgData
    {
        public ulong SenderId;
    }

    /// <summary>
    /// Response data for GetFriends Limited Presence request
    /// </summary>
    public class PFriendsNoPresenceReplyMsgData : PNMsgData
    {
        public uint HR;
        public ulong UserID;
        public uint cdwFriends;

        [WireInfo(SizeParam = "cdwFriends")]
        public PFriendsNoPresenceData[] rgFriends;
    }

    /// <summary>
    /// PFriendsLimitedPresenceData
    /// </summary>
    public class PFriendsNoPresenceData : WireData
    {
        public ulong Puid;
        public uint FriendStatus;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgBlockVoice.cs ===
// PMsgBlockVoice.cs
//
//	Presence Block voice (Mute) Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Add a user to my block (mute) list
	/// </summary>
	public class PMsgBlockVoice : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		/// <param name="block">User being blocked</param>
		public PMsgBlockVoice( PNUser user, PNUser block ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_BLOCK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PBlockVoiceMsgData data = new PBlockVoiceMsgData();
			data.UserID  = user.UserId;
			data.BlockID = block.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Block voice request
	/// </summary>
	public class PBlockVoiceMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BlockID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAlive.cs ===
// PMsgAlive.cs
//
//	Presence Alive Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	The pre aftershock way to establish a user's Presence in the system. 
	///	Translated to P_ALIVE_INTERNAL_MSG by the Front Door. Old unused fields were 
	/// kept for client compatability, but they've never actually been relied upon
	/// </summary>
	public class PMsgAlive : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAlive( PNUser user ) 
		{
			SentFrom      = Requestor.Client;
			PortOnFD      = FDPort.PresNoti;
			AuthMethod    = FDAuth.SGMsg;
			ServiceOnFD   = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PAliveMsgData data = new PAliveMsgData();
			data.UserID           = user.UserId;
			data.TitleID          = user.Xbox.TitleId;
			data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
			data.State            = XonPresNoti.P_STATE_MASK_ONLINE | 
				                    XonPresNoti.P_STATE_MASK_CLOAKED;           
			data.MatchSessionID   = 0;           // dropped 
			data.AcctName         = user.Name;
			data.TitleStuff       = new byte[0]; // dropped 
			data.Nickname         = new byte[0]; // dropped 
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Alive request
	/// </summary>
	public class PAliveMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint   TitleID;
		[WireInfo(NullTerminated=true)]
		public ushort AcctNameLen;
		public uint   BuddyListVersion;
		public uint   BlockListVersion;
		public uint   State;            // const: (P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED)
		public ulong  MatchSessionID;   // Must be zero
		public ushort NicknameLen;      // Must be zero
		public ushort TitleStuffLen;    // Must be xero
		[WireInfo(NullTerminated=true)] 
		public string AcctName;
		public byte[] TitleStuff;
		public byte[] Nickname;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to all Alive replies
	/// </summary>
	public class PAliveReplyMsgData : PNMsgData
	{
		public uint        HR;
		public uint        BuddyListVersion;
		public ushort      BuddiesLen;
		public uint        BlockListVersion;
		public ushort      BlocksLen;
		public BuddyData[] Buddies;
		public ulong[]     Blocks;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Buddy data included in Alive replies
	/// </summary>
	public class BuddyData : WireData
	{
		public ulong  BuddyID;
		public ushort NameLen;
		public byte   Status; // const: P_BUDDY_STATUS_xxx
		public string Name;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAlive2.cs ===
// PMsgAlive2.cs
//
//	Presence Alive Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	The post aftershock way to establish a user's Presence in the system. 
	///	Translated to P_ALIVE_INTERNAL_MSG by the Front Door. 
	/// </summary>
	public class PMsgAlive2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAlive2( PNUser user ) 
		{
			SentFrom      = Requestor.Client;
			PortOnFD      = FDPort.PresNoti;
			AuthMethod    = FDAuth.SGMsg;
			ServiceOnFD   = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PAlive2MsgData data = new PAlive2MsgData();
			data.UserID           = user.UserId;
			data.xnaddr           = user.Xbox.XnAddr;
			data.xnkid			  = user.Xbox.XnKId;
			data.xnkey            = user.Xbox.XnKey;
			data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
            data.ClientVersion = user.Xbox.ClientVersion;
			data.TitleID          = user.Xbox.TitleId;
			data.TitleVersion     = user.Xbox.TitleVer;
			data.TitleRegion      = user.Xbox.TitleRegion;
			data.PortI            = 0; // TBD!!
			data.IpI              = 0; // TBD!!
			data.Nonce            = 0; // TBD!!
			data.TimeInit         = DateTime.Now;
			data.AcctName         = user.Name;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Alive_2 request
	/// </summary>
	public class PAlive2MsgData : PNMsgData
	{
		public ulong    UserID;
		[WireInfo(NullTerminated=true)]
		public ushort   AcctNameLen;
		public XNADDR   xnaddr;
		public XNKID    xnkid;
		public XNKEY    xnkey;
		public uint     BuddyListVersion;
		public uint     BlockListVersion;
		public ulong    ClientVersion; // XBOX_LIBRARY_VERSION
		public uint     TitleID;
		public uint     TitleVersion;
		public uint     TitleRegion;
		public ushort   PortI; 
		public uint     IpI; // IN_ADDR 
		public long     Nonce; 
		public DateTime TimeInit; // FILETIME
		[WireInfo(NullTerminated=true)]
		public string   AcctName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgAliveInternal.cs ===
// PMsgAlive.cs
//
//	Presence Alive Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Establishes the user's Presence in the system.  This version of alive only goes from 
	/// FD to INH. FD maps what it can from client alives and adds SG session data such as 
	/// alternate title ID's and client winsockx enpoint info.
	/// </summary>
	public class PMsgAliveInternal : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAliveInternal( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE_INTERNAL;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PAliveInternalMsgData data = new PAliveInternalMsgData();
			data.UserID           = user.UserId;
			data.xnaddr           = user.Xbox.XnAddr;
			data.xnkid			  = user.Xbox.XnKId;
			data.xnkey            = user.Xbox.XnKey;
			data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
			data.ClientVersion    = user.Xbox.ClientVersion;
			data.TitleID          = user.Xbox.TitleId;
			data.AltTitleID1      = 0; // TBD!!
			data.AltTitleID2      = 0; // TBD!!
			data.AltTitleID3      = 0; // TBD!!
			data.AltTitleID4      = 0; // TBD!!
			data.TitleVersion     = user.Xbox.TitleVer;
			data.TitleRegion      = user.Xbox.TitleRegion;
			data.PortI            = 0; // TBD!!
			data.IpI              = 0; // TBD!!
			data.Nonce            = 0; // TBD!!
			data.TimeInit         = DateTime.Now;
			data.AcctName         = user.Name;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AliveInternal request
	/// </summary>
	public class PAliveInternalMsgData : PNMsgData
	{
		public ulong    UserID;
		[WireInfo(NullTerminated=true)]
		public ushort   AcctNameLen;
		public XNADDR   xnaddr;
		public XNKID    xnkid;
		public XNKEY    xnkey;
		public uint     BuddyListVersion;
		public uint     BlockListVersion;
		public ulong    ClientVersion; // XBOX_LIBRARY_VERSION
		public uint     TitleID;
		public uint     AltTitleID1;
		public uint     AltTitleID2;
		public uint     AltTitleID3;
		public uint     AltTitleID4;
		public uint     TitleVersion;
		public uint     TitleRegion;
		public ushort   PortI; 
		public uint     IpI; // IN_ADDR 
		public long     Nonce; 
		public DateTime TimeInit; // FILETIME
		[WireInfo(NullTerminated=true)]
		public string   AcctName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgCheckTitleMessages.cs ===
// PMsgCheckTitleMessages.cs
//
//	Presence CheckTitleMessages Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgCheckTitleMessages : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgCheckTitleMessages( PNUser user, uint dwTitleId, uint dwTitleRegion ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_CHECK_TITLE_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PCheckTitleMessagesMsgData data = new PCheckTitleMessagesMsgData();
			data.UserID = user.UserId;
			data.TitleID = dwTitleId;
			data.TitleRegion = dwTitleRegion;
			data.AltTitleID1 = 0;
			data.AltTitleID2 = 0;
			data.AltTitleID3 = 0;
			data.AltTitleID4 = 0;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PCheckTitleMessagesMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint  TitleID;
		public uint  AltTitleID1;
		public uint  AltTitleID2;
		public uint  AltTitleID3;
		public uint  AltTitleID4;
		public uint  TitleVersion;
		public uint  TitleRegion;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PCheckTitleMessagesReplyMsgData : PNMsgData
	{
		public uint        HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgCancelInvite.cs ===
// PMsgCancelInvite.cs
//
//	Presence Cancel Game Invite Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Cancel invitaion of 1 or more users to a particular session
	/// </summary>
	public class PMsgCancelInvite : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User canceling invitation</param>
		/// <param name="buddies">Array of buddies getting uninvited</param>
		public PMsgCancelInvite( PNUser user, PNUser[] buddies ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_CANCEL;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PCancelInviteMsgData data = new PCancelInviteMsgData();
			data.UserID         = user.UserId;
			data.MatchSessionID = user.MatchSessionId;
			data.Invitees       = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Cancel invite request
	/// </summary>
	public class PCancelInviteMsgData : PNMsgData
	{
		public ulong   UserID;
		public ulong   MatchSessionID;
		public ushort  InviteesLen;
		public ulong[] Invitees;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgDeleteBuddy.cs ===
// PMsgDeleteBuddy.cs
//
//	Presence Delete Buddy Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete a buddy from my buddy list
	/// </summary>
	public class PMsgDeleteBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User deleting the buddy</param>
		/// <param name="buddy">Buddy being deleted</param>
		public PMsgDeleteBuddy( PNUser user, PNUser buddy ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DELETE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PDeleteBuddyMsgData data = new PDeleteBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete buddy request
	/// </summary>
	public class PDeleteBuddyMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BuddyID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgFindUser.cs ===
// PMsgFindUser.cs
//
//  Presence FindUser Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Allows update of title specific data stored by Presence for a particular user. 
    /// Title initiates immediate update all the way to server. Because of this and the 
    /// potential for misuse this message has been phased out for new titles.
    /// </summary>
    public class PMsgFindUser : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgFindUser( PNUser user, ulong puid, string gamertag ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_FIND_USER;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID   = user.Xbox.XboxId;

            PFindUserMsgData data   = new PFindUserMsgData();
            data.UserID             = user.UserId;

            data.FindID             = puid;
            data.GamerTag           = gamertag;
            Msg.Data                = data;
        }
    }

    public class PMsgFindUsers : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgFindUsers( PNUser user, ulong[] puids, string[] gamertags ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_FIND_USERS;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID   = user.Xbox.XboxId;

            if (puids.Length != gamertags.Length)
            {
                throw new ArgumentException("puid and gamertag arrays must be identical lengths.");
            }

            PFindUsersMsgData data   = new PFindUsersMsgData();
            data.UserID             = user.UserId;
            data.cdwQueries = (uint)puids.Length;
            data.rgQueries = new PFindUsersData[puids.Length];

            for (int iQuery = 0; iQuery < puids.Length; iQuery++)
            {
                data.rgQueries[iQuery] = new PFindUsersData();
                data.rgQueries[iQuery].FindID = puids[iQuery];
                data.rgQueries[iQuery].GamerTag = gamertags[iQuery];
            }
            
            Msg.Data                = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUser request
    /// </summary>
    public class PFindUserMsgData : PNMsgData
    {
        public ulong    UserID;

        public ulong    FindID;         // UserID to find, 0 if use GamerTag
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user to find
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUser response
    /// </summary>
    public class PFindUserReplyMsgData : PNMsgData
    {
        public ulong    FoundID;        // PUID of found user. 0 if not found
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user found
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUsers request
    /// </summary>
    public class PFindUsersMsgData : PNMsgData
    {
        public ulong    UserID;
        public uint cdwQueries;
        [WireInfo(SizeParam="cdwQueries")]
        public PFindUsersData[] rgQueries;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUsers response
    /// </summary>
    public class PFindUsersReplyMsgData : PNMsgData
    {
        public uint cdwResults;
        [WireInfo(SizeParam="cdwResults")]
        public PFindUsersData[] rgResults;
    }

    public class PFindUsersData : PNMsgData
    {
        public ulong    FindID;         // UserID to find, 0 if use GamerTag
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user to find
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgGetFriendsList.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
    
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgGetFriendsList : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgGetFriendsList( PNUser sender, PNUser target ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_FRIENDS_LIST;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = sender.Xbox.XboxId;

			PGetFriendsListMsgData data = new PGetFriendsListMsgData();
			data.SenderID = sender.UserId;
			data.TargetID = target.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PGetFriendsListMsgData : PNMsgData
	{
		public ulong  SenderID;
		public ulong  TargetID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PGetFriendsListReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
		public uint        Version;
		public uint      cdwFriends;
        
              [WireInfo(SizeParam="cdwFriends")]
		public GetFriendsListData[] rgFriends;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class GetFriendsListData : WireData
	{
		public ulong  BuddyID;
		public uint   Status;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgInvalidateUser.cs ===
// PMsgInvalidateUser.cs
//
//  Presence InvalidateUser Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
    /// <summary>
    /// Allows update of title specific data stored by Presence for a particular user. 
    /// Title initiates immediate update all the way to server. Because of this and the 
    /// potential for misuse this message has been phased out for new titles.
    /// </summary>
    public class PMsgInvalidateUser : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgInvalidateUser( PNUser user ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti_DC;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_INVALIDATE_USER;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID   = user.Xbox.XboxId;

            PInvalidateUserMsgData data = new PInvalidateUserMsgData();
            data.UserID             = user.UserId;
            Msg.Data                = data;
        }
    }

    /// <summary>
    /// Message data specific to InvalidateUser request
    /// </summary>
    public class PInvalidateUserMsgData : PNMsgData
    {
        public ulong    UserID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgGetPresenceInfo.cs ===
// PMsgWebFriends.cs
//
//	Presence Web Friends Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgGetPresenceInfo : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgGetPresenceInfo( PNUser user, PNUser target ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_PRESENCE_INFO;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;
                        
			PGetPresenceInfoMsgData data = new PGetPresenceInfoMsgData();
			data.dwContext = 0;
			data.qwSenderID = user.UserId;
			data.cdwUsers = 1;
			data.rgUsers = new ulong[1];
			data.rgUsers[0] = target.UserId;
            
			Msg.Data = data;
		}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgGetPresenceInfo( PNUser user, PNUser[] target ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_PRESENCE_INFO;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;
                        
			PGetPresenceInfoMsgData data = new PGetPresenceInfoMsgData();
			data.dwContext = 0;
			data.qwSenderID = user.UserId;
			data.cdwUsers = (uint)target.Length;
			data.rgUsers = new ulong[target.Length];
			for(int i = 0; i < target.Length; ++i)
			{
                data.rgUsers[i] = target[i].UserId;
			}
            
			Msg.Data = data;
		}

		// Craft all fields of get presence info request
		public PMsgGetPresenceInfo(uint dwContext, ulong qwXboxId, ulong qwSenderId, uint cdwPuids, ulong[] rgqwPuids)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_PRESENCE_INFO;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;
			
			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = qwXboxId;
                        
			PGetPresenceInfoMsgData data = new PGetPresenceInfoMsgData();
			data.dwContext = dwContext;
			data.qwSenderID = qwSenderId;
			data.cdwUsers = cdwPuids;
			data.rgUsers = rgqwPuids;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PGetPresenceInfoMsgData : PNMsgData
	{
            public uint dwContext;
            public ulong qwSenderID;
            public uint cdwUsers;

            [WireInfo(SizeParam="cdwUsers")]
            public ulong[] rgUsers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PPresenceInfoReplyMsgData : PNMsgData
	{
            public uint dwContext;
            public ulong qwSenderID;
            public uint cdwUsers;

            [WireInfo(SizeParam="cdwUsers")]
            public PresenceInfo[] rgUsers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class PresenceInfo : WireData
	{
		public ulong  SenderID;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ulong  qwSessionID;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgInvite.cs ===
// PMsgInvite.cs
//
//	Presence Game Invite Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Invite 1 or more users to a title session
	/// </summary>
	public class PMsgInvite : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User sending the invitaion</param>
		/// <param name="buddies">Array of buddies being invited</param>
		public PMsgInvite( PNUser user, PNUser[] buddies ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PInviteMsgData data = new PInviteMsgData();
			data.UserID         = user.UserId;
			data.TitleID        = user.Xbox.TitleId;
			data.MatchSessionID = user.MatchSessionId;
            data.Invitees       = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite request
	/// </summary>
	public class PInviteMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint    TitleID;
		public ulong   MatchSessionID;
		public ushort  InviteesLen;
		public ulong[] Invitees;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Invite 1 or more users to a session, new version that supports messaging and team
	/// and competition invitations
	/// </summary>
	public class PMsgInvite2 : PNRequestMsg
	{
		public PMsgInvite2( PNUser user, PNUser[] buddies, ulong context, uint flags, MsgDetails details ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PInvite2MsgData data = new PInvite2MsgData();
			data.UserID        = user.UserId;
			data.SenderContext = context;
			data.TitleID       = user.Xbox.TitleId;
			data.MessageFlags  = flags;
            data.Invitees      = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			data.cbDetails = details.size;
			data.Details   = details;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite 2 request
	/// </summary>
	public class PInvite2MsgData : PNMsgData
	{
		public ulong      UserID;
		public ulong      SenderContext;
		public uint       TitleID;
		public uint	      MessageFlags;
		public ushort     InviteesLen;
		public ushort     cbDetails; 
		public ulong[]    Invitees;
		public MsgDetails Details;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgInviteAnswer.cs ===
// PMsgInviteAnswer.cs
//
//	Presence Game Invite Answer Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Single user answers an invitaion to a particular session
	/// </summary>
	public class PMsgInviteAnswer : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User responding to the invitation</param>
		/// <param name="host">Session host that made the invitaion</param>
		/// <param name="accept">Is invitaion accepted</param>
		public PMsgInviteAnswer( PNUser user, PNUser host, bool accept ) :
			this( user, host, (accept ? XonPresNoti.PINVITE_REPLY_YES : XonPresNoti.PINVITE_REPLY_NO) )
		{}
		
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User responding to the invitation</param>
		/// <param name="host">Session host that made the invitaion</param>
		/// <param name="reply">Reply code for yes, no, or never</param>
		public PMsgInviteAnswer( PNUser user, PNUser host, ushort reply ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE_ANSWER;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PInviteAnswerMsgData data = new PInviteAnswerMsgData();
			data.UserID         = user.UserId;
			data.HostID         = host.UserId;
			data.MatchSessionID = host.MatchSessionId;
			data.Answer         = reply;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite Answer request
	/// </summary>
	public class PInviteAnswerMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  HostID;
		public ulong  MatchSessionID;
		public ushort Answer; // const: PINVITE_REPLY_NO or PINVITE_REPLY_YES
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgKick.cs ===
// PMSGKick.cs
//
//	Presence Kick Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	public class PMSGKick : PNRequestMsg
	{
        public PMSGKick(PNUser u) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = u.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = u.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = u.Xbox.XboxId;

            Msg.Hdr.MsgType = (uint)xonline.common.protocol.P_MSG_TYPES.PMSG_KICK;
            PKickMsgData data = new PKickMsgData();

            data.qwUserID = u.UserId;
			
            Msg.Data = data;
		}
	}

	public class PKickMsgData : PNMsgData
	{
        public ulong  qwUserID;
        public uint fFlush = 1;    
	}

	public class PKickReplyMsgData : PNMsgData
	{
            public uint             hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgIsAffiliate.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	determine if a user is on the sender's buddy list
	/// </summary>
	public class PMsgIsAffiliate : PNRequestMsg
	{
		public PMsgIsAffiliate( PNUser user, PNUser affiliate) : this(user, affiliate.UserId)
		{
		}
		
		public PMsgIsAffiliate( PNUser user, ulong qwAffiliateId ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			Msg.Hdr.MsgType = XonPresNoti.PMSG_IS_AFFILIATE;
			PIsAffiliateMsgData data = new PIsAffiliateMsgData();

			data.qwSenderID = user.UserId;
			data.qwAffiliateID = qwAffiliateId;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to IsAffiliate request
	/// </summary>
	public class PIsAffiliateMsgData : PNMsgData
	{
            public ulong            qwSenderID;
            public ulong            qwAffiliateID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to IsAffiliate reply
	/// </summary>
	public class PIsAffiliateReplyMsgData : PNMsgData
	{
            public uint             hr;
            public ulong            qwAffiliateID;
            public uint             dwListFlags;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgNickname.cs ===
// PMsgNickname.cs
//
//	Presence Set Nickname (UserData) Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows update of title specific data stored by Presence for a particular user. 
	/// Title initiates immediate update all the way to server. Because of this and the 
	/// potential for misuse this message has been phased out for new titles.
	/// </summary>
	public class PMsgNickname : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's data is being updated</param>
		/// <param name="nickname">new nickname data</param>
		public PMsgNickname( PNUser user, byte[] nickname ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_NICKNAME;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PNicknameMsgData data = new PNicknameMsgData();
			data.UserID   = user.UserId;
			data.Nickname = nickname;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Nickname request
	/// </summary>
	public class PNicknameMsgData : PNMsgData
	{
		public ulong  UserID;
		public ushort NicknameLen;
		public byte[] Nickname;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgPeerSubscribe.cs ===
// PMsgPeerSubscribe.cs
//
//	Presence Subscibe to peer presence info Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows user to subscribe to presence notifications for other users that are not 
	/// friends
	/// </summary>
	public class PMsgPeerSubscribe : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting presence notifications</param>
		/// <param name="peers">Users who's presence will be provided</param>
		//////////////////////////////////////
		public PMsgPeerSubscribe( PNUser user, PNUser[] peers ) : this(user, ConvertToPuids(peers))
		{
		}

		static ulong[] ConvertToPuids(PNUser[] peers)
		{
			ulong []rgqw = null;
			
			if(null != peers)
			{
				rgqw = new ulong[peers.Length];

				for(int i = 0; i < peers.Length; ++i)
				{
					rgqw[i] = peers[i].UserId;
				}
			}
			else
			{
				rgqw = new ulong[0];
			}

			return rgqw;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting presence notifications</param>
		/// <param name="peers">Users who's presence will be provided</param>
		public PMsgPeerSubscribe( PNUser user, ulong[] peers ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SUBSCRIBE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PPeerSubscribeMsgData data = new PPeerSubscribeMsgData();
			data.UserID = user.UserId;
			data.Peers  = peers;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Subscribe request
	/// </summary>
	public class PPeerSubscribeMsgData : PNMsgData
	{
		public ulong   UserID;
		public ushort  PeersLen = 0;
		public ulong[] Peers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Subscribe reply
	/// </summary>
	public class PPeerSubscribeReplyMsgData : PNMsgData
	{
		public uint HR = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgLogonCheck.cs ===
// PMsgLogonCheck.cs
//
//	Presence LogonCheck Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// determines if a user is already logged in at another location.
	/// </summary>
	public class PMsgLogonCheck : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">user to query logon status</param>
		public PMsgLogonCheck( PNUser user, ulong xboxid ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_LOGON_CHECK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = xboxid;

			PLogonCheckMsgData data = new PLogonCheckMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to LogonCheck request
	/// </summary>
	public class PLogonCheckMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to LogonCheck reply
	/// </summary>
	public class PLogonCheckReplyMsgData : PNMsgData
	{
		public uint        HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgPeerSession.cs ===
// PMsgPeerSession.cs
//
//	Presence Get Peer Session info Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows Retrieval of Client Winsock Endpoint info sent up with alives starting 
	/// with the aftershock release.
	/// </summary>
	public class PMsgPeerSession : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making the request for data</param>
		/// <param name="host">User who's endpoint data is requested</param>
		public PMsgPeerSession( PNUser user, PNUser host ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SESSION;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PPeerSessionMsgData data = new PPeerSessionMsgData();
			data.UserID     = user.UserId;
			data.HostUserID = host.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Session request
	/// </summary>
	class PPeerSessionMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong HostUserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Session reply
	/// </summary>
	class PPeerSessionReplyMsgData : PNMsgData
	{
		public ulong  HostUserID   = 0;
		public uint   TitleID      = 0;
		public uint   TitleVersion = 0;
		public uint   TitleRegion  = 0;
		public XNADDR XnAddr       = new XNADDR();
		public XNKID  XnKId        = new XNKID();
		public XNKEY  XnKey        = new XNKEY();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgPeerUnsubscribe.cs ===
// PMsgPeerUnsubscribe.cs
//
//	Presence Unsubscibe to peer presence info Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Cancels subcription to presence notifications for other users that are not 
	/// friends
	/// </summary>
	public class PMsgPeerUnsubscribe : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting to cancel presence notifications</param>
		public PMsgPeerUnsubscribe( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_UNSUBSCRIBE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PPeerUnsubscribeMsgData data = new PPeerUnsubscribeMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Unsubscribe request
	/// </summary>
	class PPeerUnsubscribeMsgData : PNMsgData
	{
		public ulong UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Unsubscribe reply
	/// </summary>
	class PPeerUnsubscribeReplyMsgData : PNMsgData
	{
		public uint HR = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgQueryAffiliates.cs ===
// PMsgAddBuddy.cs
//
//  Presence Add Buddy Request Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// determine if a user is on the sender's buddy list
    /// </summary>
    public class PMsgQueryAffiliates : PNRequestMsg
    {
        public PMsgQueryAffiliates( PNUser user, uint cdwLimit, uint dwListFlags, uint dwOnlineTitleID ) 
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.PresNoti;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Presence;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

            Msg.Hdr.MsgType = XonPresNoti.PMSG_QUERY_AFFILIATES;
            PQueryAffiliatesMsgData data = new PQueryAffiliatesMsgData();

            data.qwSenderID = user.UserId;
            data.cdwLimit = cdwLimit;
            data.dwListFlags = dwListFlags;
            data.dwOnlineTitleID = dwOnlineTitleID;

            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates request
    /// </summary>
    public class PQueryAffiliatesMsgData : PNMsgData
    {
        public ulong            qwSenderID;
        public uint             dwListFlags;
        public uint             cdwLimit;
        public uint             dwOnlineTitleID;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates reply
    /// </summary>
    public class PQueryAffiliatesReplyMsgData : PNMsgData
    {
        public uint             hr;
        public uint            cdwResults;

        [WireInfo(SizeParam="cdwResults")]
        public QueryAffiliatesReplyData[]      rgResults;
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class QueryAffiliatesReplyData : WireData
    {
        public ulong            qwAffiliateID;
        public uint             dwListFlags;
        public uint             dwTitleID;
        public ulong            qwSessionID;
        public uint             mtDateUpdated;

        [WireInfo(ArraySize=16)]
        public string           szGamerTag; // ASCII Null terminated
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgState.cs ===
// PMsgState.cs
//
//	Presence Set State (TitleData) Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.GI;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows update of title specific data stored by Presence for a particular user similar 
	/// to nickname.  However timing is not immediate or title initiated.  Instead the data 
	/// rides in periodic SG heatbeat messages.
	/// </summary>
	public class PMsgState : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgState( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_STATE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PStateMsgData data = new PStateMsgData();
			data.UserID         = user.UserId;
			data.State          = user.State;
			data.MatchSessionID = user.MatchSessionId;
			data.TitleStuff     = user.TitleStuff;
			Msg.Data = data;
		}
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to State request
	/// </summary>
	public class PStateMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint    State;
		public ulong   MatchSessionID;
		public ushort  TitleStuffLen;
		public byte[]  TitleStuff;
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Xenon version of state message. This message functions like state, but deprecates the 
	/// rgbTitleStuff member, and replaces it with the Rich Presence related contexts and properties. 
	/// </summary>
	public class PMsgState2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgState2( PNUser user ) 
		{
			SentFrom               = Requestor.Client;
			PortOnFD               = FDPort.PresNoti_DC;
			AuthMethod             = FDAuth.None;
			ServiceOnFD            = FDService.Presence;

			Msg.Hdr                = new PNMsgHdr();
			Msg.Hdr.MsgType        = XonPresNoti.PMSG_STATE_2;
			Msg.Hdr.MsgLen         = 0;
			Msg.Hdr.SeqNum         = PresSeqNum;

			Msg.Hdr.Sgaddr         = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg   = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg   = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID  = user.Xbox.XboxId;

			PState2MsgData data    = new PState2MsgData();
			data.UserID            = user.UserId;
			data.State             = user.State;
			data.MatchSessionID    = user.MatchSessionId;
			
			data.TitleID           = user.Xbox.TitleId;
			data.cbRichPresence    = 0;
			data.TitlePresence     = 0;

			data.cProperties       = 0;
			data.cContexts         = 0;
            
			Msg.Data               = data;
		}

	}
	

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to State2 request
	/// </summary>
    public class PState2MsgData : PNMsgData
    {
        public ulong   UserID;
        public uint    State;
        public ulong   MatchSessionID;

        public uint    TitleID;
        public uint    cbRichPresence;     // Count of bytes in RP data

        public uint    TitlePresence;

        public ushort  cContexts;
        public ushort  cProperties;
        
        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;

        public uint RPSize()
        {
            // sizeof( RichPresence )
            int cb = 8;
        
            // add all the contexts
            cb += cContexts * 8;
            
            // add all the props
            if (cProperties > 0)
            {
                foreach (GIProperty prop in rgProps)
                {
                    cb += prop.Size();
                }
            }

            return (uint)cb;
        }

    }


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows for the retrieval of State data about a user, including the Rich Presence contexts and properties
	/// this message is currently only consumed by the FD in response to a Dequeue or Alive so that 
	/// the Rich Presence string can be created for a user. 
	/// </summary>
	public class PMsgGetState : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgGetState( PNUser user ) 
		{
			SentFrom               = Requestor.Client;
			PortOnFD               = FDPort.PresNoti_DC;
			AuthMethod             = FDAuth.None;
			ServiceOnFD            = FDService.Presence;

			Msg.Hdr                = new PNMsgHdr();
			Msg.Hdr.MsgType        = XonPresNoti.PMSG_GET_STATE;
			Msg.Hdr.MsgLen         = 0;
			Msg.Hdr.SeqNum         = PresSeqNum;

			Msg.Hdr.Sgaddr         = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg   = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg   = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID  = user.Xbox.XboxId;

			PGetStateMsgData data  = new PGetStateMsgData();
			data.UserID            = user.UserId;
            
			Msg.Data               = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get State request
	/// </summary>
	public class PGetStateMsgData : PNMsgData
	{
		public ulong UserID;
	}
	

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get State reply
	/// </summary>
	public class PGetStateReplyMsgData : PNMsgData
	{
		public uint             HR;

        public uint             State;            // See P_STATE_MASK_XXX
        public ulong            MatchSessionID;

        public uint             TitleID;          // Xenon state now conveys title changes
        
        public uint             TitlePresence;
        
        public ushort           cContexts;
        public ushort           cProperties;

        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgPeerSubscribeEx.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgPeerSubscribeEx : PNRequestMsg
	{
        public const uint X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS = 0x1;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK = 0xFF00000000000000;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD = 0x0100000000000000;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE = 0x0200000000000000;
        
        public PMsgPeerSubscribeEx( PNUser user, PNUser[] pnuAdds, PNUser[] pnuSubs ) 
        {
            ulong[] targets = new ulong[pnuAdds.Length + pnuSubs.Length];
            for (int i=0; i<pnuAdds.Length; i++)
            {
                targets[i] = pnuAdds[i].UserId | X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD;
            }
            for (int i=pnuAdds.Length; i<pnuAdds.Length+pnuSubs.Length; i++)
            {
                targets[i] = pnuSubs[i-pnuAdds.Length].UserId | X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE;
            }
            this.Initialize(user, X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS, targets);
        }
        public PMsgPeerSubscribeEx( PNUser user, PNUser[] pnuAbsolute ) 
        {
            ulong[] targets = new ulong[pnuAbsolute.Length];
            for (int i=0; i<pnuAbsolute.Length; i++)
            {
                targets[i] = pnuAbsolute[i].UserId;
            }
            this.Initialize(user, 0, targets);
        }
        public PMsgPeerSubscribeEx( PNUser user, uint dwFlags, ulong[] targets )
        {
            this.Initialize(user, dwFlags, targets);
        }
        private void Initialize( PNUser user, uint dwFlags, ulong[] targets ) 
	{
		SentFrom    = Requestor.Client;
		PortOnFD    = FDPort.PresNoti;
		AuthMethod  = FDAuth.SGMsg;
		ServiceOnFD = FDService.Presence;

		Msg.Hdr = new PNMsgHdr();
		Msg.Hdr.MsgLen  = 0;
		Msg.Hdr.SeqNum  = PresSeqNum;

		Msg.Hdr.Sgaddr = new SGADDR();
		Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
		Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
		Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

		Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SUBSCRIBE_EX;
		PPeerSubscribeExMsgData data = new PPeerSubscribeExMsgData();

		data.qwUserID = user.UserId;
		data.dwFlags = dwFlags;
		data.cwTargets = (ushort)(targets.Length);
              data.pqwTargets = targets;
        
		Msg.Data = data;
	}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AddAffiliates request
	/// </summary>
	public class PPeerSubscribeExMsgData : PNMsgData
	{
            public ulong            qwUserID;
            public uint               dwFlags;
            public ushort           cwTargets;
     
            [WireInfo(SizeParam="cwTargets")]
            public ulong[]          pqwTargets;
	}

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates reply
    /// </summary>
    public class PPeerSubscribeExReplyMsgData : PNMsgData
    {
        public uint             hr;
        public ushort         cwResults;

        [WireInfo(SizeParam="cwResults")]
        public PeerSubscribeExReplyData[]      rgResults;
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class PeerSubscribeExReplyData : WireData
    {
        public ulong            qwUserID;
        public uint             dwState;
        public uint             dwTitleID;
        public uint             mtUserTime;

        [WireInfo(ArraySize=16)]
        public string           szGamerTag; // ASCII Null terminated
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\ClientInfo.cs ===
// ClientInfo.cs
//
//	Test Client informaion and state.  
//	(Needed for PresNoti framework and test cases but might be generally usefull)
//

using System;
using System.Net;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	//////////////////////////////////////
	// PN Client Info
	//	Info that is or needs to be made unique for each client test machine
	//
	public class PNClientInfo
	{
		private static uint _LocalIP = 0;
		public static uint LocalIP
		{
			get 
			{
				if(_LocalIP == 0)
				{
					// Get local IP to use as that of the SG connected too.
					IPHostEntry hostEntry = Dns.GetHostEntry( Dns.GetHostName() );

					if( Global.SGIPMatchAddr != IPAddress.Any )
					{
						// A "match" pattern was found in the config xml file
						byte[] matchBytes = Global.SGIPMatchAddr.GetAddressBytes();

						for(int i = 0; i < hostEntry.AddressList.Length; ++i)
						{
							byte[] ipBytes = hostEntry.AddressList[i].GetAddressBytes();
							
							if (ipBytes.Length!=4)
							{
								// No support for IPv6 addresses
								continue;
							}

							// Match the bytes in the address to what we want to find (0 indicates a skip)
							int j;
							for(j = 0; j < ipBytes.Length; ++j)
							{
								if(matchBytes[j] != 0 && ipBytes[j] != matchBytes[j])
								{
									break;
								}
							}

							if(j == ipBytes.Length)
							{
								_LocalIP = ((uint) ipBytes[3]<<24) |
									((uint) ipBytes[2]<<16) |
									((uint) ipBytes[1]<< 8) |
									((uint) ipBytes[0]<< 0);
							}
						}
					}
					else 
					{
						// Use the first address in the list
						_LocalIP = uint.MaxValue;
						IPAddress[] addressList = hostEntry.AddressList;
						foreach( IPAddress ip in addressList )
						{
							byte[] ipBytes = ip.GetAddressBytes();
							if (ipBytes.Length == 4) 
							{
								uint IP = 
									((uint) ipBytes[3]<<24) |
									((uint) ipBytes[2]<<16) |
									((uint) ipBytes[1]<< 8) |
									((uint) ipBytes[0]<< 0);
					
								uint hoOld = (uint)IPAddress.NetworkToHostOrder( (int)_LocalIP );
								uint hoNew = (uint)IPAddress.NetworkToHostOrder( (int)IP );

								if( hoNew < hoOld )
								{
									_LocalIP = IP;
								}
							}
						}
					}
				}
				return _LocalIP;
			}
		}

		///////////////////////////////////////////////////////////////////////
		// Static Property: Client ID
		//	Used to differentiate test clients for ID generation
		public static ushort ClientId
		{
			get{ return clientId; }
		}
		private static ushort clientId = 1;

		static PNClientInfo()
		{
			int randomId = new RandomEx().Next();
			clientId = (ushort)(((randomId >> 16) + randomId) & 0xffff);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgUnblockVoice.cs ===
// PMsgUnblockVoice.cs
//
//	Presence Unblock voice (un-Mute) Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Remove a particular user (or all users) from my blocklist.
	/// </summary>
	public class PMsgUnblockVoice : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants someone unblocked</param>
		/// <param name="block">User being unblocked</param>
		public PMsgUnblockVoice( PNUser user, PNUser block )
			: this( user, block.UserId ) 
		{}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants blocklist emptied</param>
		public PMsgUnblockVoice( PNUser user )
			: this( user, 0 ) 
		{}
		
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants someone unblocked</param>
		/// <param name="blockId">User PUID being unblocked</param>
		private PMsgUnblockVoice( PNUser user, ulong blockId ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_UNBLOCK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PNUnblockVoiceMsgData data = new PNUnblockVoiceMsgData();
			data.UserID  = user.UserId;
			data.BlockID = blockId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Unblock request
	/// </summary>
	public class PNUnblockVoiceMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BlockID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgRejectBuddy.cs ===
// PMsgRejectBuddy.cs
//
//	Presence Reject Buddy Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Reject a request to be someone's buddy. If never is indicated all future buddy 
	/// requests from the user being rejected will be blocked at the server.  The "never"
	/// list is stored on the server and there is no way to remove someone explicitly from 
	/// it, but sending someone on it a buddy request will remove them implicitly.
	/// </summary>
	public class PMsgRejectBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User rejecting the buddy</param>
		/// <param name="buddy">Buddy being rejected</param>
		/// <param name="never">Block all future requests</param>
		public PMsgRejectBuddy( PNUser user, PNUser buddy, bool never ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_REJECT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PRejectBuddyMsgData data = new PRejectBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			data.Never   = never;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Reject buddy request
	/// </summary>
	public class PRejectBuddyMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  BuddyID;
		public int    _Never;  // BOOL

		public bool Never
		{
			get{ return( (_Never == 0) ? false : true ); }
			set{ _Never = ( value ? 1 : 0 ); }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\WebFriendData.cs ===
// WebFriends.cs
//
//	Common container for web data from cache or FD
//

using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	//////////////////////////////////////
	// Web Friend List
	//	Wrapper for a user's friend list info from web cache or FD
	//
	public class WebFriendData
	{
		// Source of friend data 
		public enum From { None, Widget, FD };
		public From Source = From.None;
		
		// Web Cache Friend Data (Source = Widget)
		private FriendsInfo _fi = null ;
		private uint        _validSec = 0;

		// Frond Door Friend Data (Source = FD)
		private PWebFriendReplyMsgData _replyData = null;

		//////////////////////////////////////
		// Entry 
		//	Wrapper for individual list entries
		//
		public class Entry
		{
			private From Source       = From.None;
			private OnlineFriend  _of = null;
			private WebFriend     _wf = null; 

			public Entry( OnlineFriend of )	{ Source = From.Widget; _of = of; }
			public Entry( WebFriend wf    ) { Source = From.FD;     _wf = wf; }

			public uint TitleId
			{
				get
				{
					uint titleId = 0;
					switch( Source )
					{
						case From.Widget: 
							titleId = _of.T; break;
						case From.FD:     
							titleId = _wf.TitleID; break;
						case From.None:
							throw new UnexpectedTestResultException( "WebFriendData Emtry not ready" );
					}
					return titleId;
				}
			}
			
			public uint State
			{
				get
				{
					uint state = 0;
					switch( Source )
					{
						case From.Widget: 
							state = _of.S; break;
						case From.FD:     
							state = _wf.OnlineState; break;
						case From.None:
							throw new UnexpectedTestResultException( "WebFriendData Emtry not ready" );
					}
					return state;
				}
			}
		
			public byte[] TitleInfo
			{
				get
				{
					byte[] titleInfo = {};
					switch( Source )
					{
						case From.Widget: 
							throw new UnexpectedTestResultException( "WebFriendData Emtry, Widget Data does not contain Title Info" );
						case From.FD:     
							titleInfo = _wf.szRichPresence; break;
						case From.None:
							throw new UnexpectedTestResultException( "WebFriendData Emtry not ready" );
					}
					return titleInfo;
				}
			}
		}

		////////////////////////////////////////////////
		// Ctor (from WebCache FriendsInfo)
		//
		public WebFriendData( FriendsInfo fi, uint validSec ) 
		{
			Source    = From.Widget;
			_fi       = fi;
			_validSec = validSec;
		}

		////////////////////////////////////////////////
		// Ctor (from FD Msg reply data)
		//
		public WebFriendData( PWebFriendReplyMsgData replyData )
		{
			Source     = From.FD;
			_replyData = replyData;
		}

		////////////////////////////////////////////////
		// Count Properties
		//
		public byte Count
		{
			get
			{
				byte count = 0;
				switch( Source )
				{
					case From.Widget: 
						count = (byte)( _fi.OfflineFriends.Length + _fi.OnlineFriends.Length ); break;
					case From.FD:     
						count = (byte)( _replyData.cdwFriends); break;
					case From.None:
						throw new UnexpectedTestResultException( "WebFriend Data not ready" );
				}
				return count;
			}
		}

		////////////////////////////////////////////////
		// Check Count
		//
		public void CheckCount( byte online, byte offline )
		{
			if( (online + offline) != Count)
			{
				string msg = 
					"Web Friend Data Validation Error - "+
					"Expected on+off: "+online+"+"+offline+
					" Not equal to "+Count;
				throw new UnexpectedTestResultException( msg );
			}
		}

		////////////////////////////////////////////////
		// Valid Sec Property
		//
		public uint ValidSec 
		{
			get
			{ 
				switch( Source )
				{
					case From.Widget: 
						break;
					case From.FD:     
						throw new UnexpectedTestResultException( "Valid Sec not in FD Data" );
					case From.None:
						throw new UnexpectedTestResultException( "WebFriend Data not ready" );
				}
				return _validSec;
			}
		}
		

		////////////////////////////////////////////////
		// HR Property
		//
		public uint HR 
		{
			get
			{ 
				switch( Source )
				{
					case From.Widget: 
						throw new UnexpectedTestResultException( "HR not in Web Cache Data" );
					case From.FD:     
						break;
					case From.None:
						throw new UnexpectedTestResultException( "WebFriend Data not ready" );
				}
				return _replyData.HR;
			}
		}


		////////////////////////////////////////////////
		// Check HR
		//
		public void CheckHR( uint hr )
		{
			if( hr != HR )
			{
				string msg = 
					"Web Friend Data Validation Error - "+
					"Expected HR: "+hr+
					" Not "+HR;
				throw new UnexpectedTestResultException( msg );
			}
		}


		////////////////////////////////////////////////
		// List Version Property
		//
		public uint ListVersion 
		{
			get
			{ 
				switch( Source )
				{
					case From.Widget: 
						throw new UnexpectedTestResultException( "List Version not in Cache Data" );
					case From.FD:     
						break;
					case From.None:
						throw new UnexpectedTestResultException( "WebFriend Data not ready" );
				}
				return _replyData.Version;
			}
		}
	

		////////////////////////////////////////////////
		// Title Id (of online user at index)
		//
		public uint TitleId( byte i )
		{
			uint titleId = 0;
			switch( Source )
			{
				case From.Widget: 
					titleId = _fi.OnlineFriends[i].T; break;
				case From.FD:     
					titleId = _replyData.rgFriends[i].TitleID; break;
				case From.None:
					throw new UnexpectedTestResultException( "Web Friend Data not ready" );
			}
			return titleId;
		}

		////////////////////////////////////////////////
		// State (of online user at index)
		//
		public uint State( byte i )
		{
			uint state = 0;
			switch( Source )
			{
				case From.Widget: 
					state = _fi.OnlineFriends[i].S; break;
				case From.FD:     
					state = _replyData.rgFriends[i].OnlineState; break;
				case From.None:
					throw new UnexpectedTestResultException( "Web Friend Data not ready" );
			}
			return state;
		}

		////////////////////////////////////////////////
		// Find Online User
		//
		public bool FindOnlineUser( PNUser user, out Entry friend )
		{
			bool found = false;
			friend     = null;

			if( Source == From.None )
			{
				throw new UnexpectedTestResultException( "Web Friend Data not ready" );
			}
			else if( Source == From.FD )
			{
				for( int i = 0; i < _replyData.cdwFriends; ++i )
				{
					if(user.UserId == _replyData.rgFriends[i].BuddyID)
					{
						friend = new Entry( _replyData.rgFriends[i] );
						found = true;
						break;
					}
				}
			}
			else // Soruce == From.Widget
			{
				for( int i = 0; i < _fi.OnlineFriends.Length; ++i )
				{
					if( user.Name == _fi.OnlineFriends[i].G )
					{
						friend = new Entry( _fi.OnlineFriends[i] );
						found = true;
						break;
					}
				}
			}
			return found;
		}


		////////////////////////////////////////////////
		// Find Offline User
		//
		public bool FindOfflineUser( PNUser user )
		{
			bool found = false;

			if( Source == From.None )
			{
				throw new UnexpectedTestResultException( "Web Friend Data not ready" );
			}
			else if( Source == From.FD )
			{
				for( int i = 0; i < _replyData.cdwFriends; ++i )
				{
					if( user.UserId == _replyData.rgFriends[i].BuddyID)
					{
						found = true;
						break;
					}
				}
			}
			else // Soruce == From.Widget
			{
				for( int i = 0; i < _fi.OfflineFriends.Length; ++i )
				{
					if( user.Name == _fi.OfflineFriends[i].G )
					{
						found = true;
						break;
					}
				}
			}
			return found;
		}


		////////////////////////////////////////////////
		// Check User
		//
		public void CheckUser( PNUser user )
		{
			if( Source == From.None )
				throw new UnexpectedTestResultException( "Web Friend Data not ready" );

			if( user.LoggedOn )
			{
				Entry friend = null;

				if( ! FindOnlineUser( user, out friend ) )
				{
					string msg =
						"Web Friend Data Validation Error - "+
						user.Name+" ("+user.UserId+") "+
						"is not an online friend";
					throw new UnexpectedTestResultException( msg );
				}

				if( friend.State != user.State )
				{
					string msg =
						"Web Friend Data Validation Error - "+
						user.Name+" ("+user.UserId+"): "+
						"User State is "+user.State+" Not "+friend.State;
					throw new UnexpectedTestResultException( msg );
				}

				if( friend.TitleId != user.Xbox.TitleId )
				{
					string msg =
						"Web Friend Data Validation Error - "+
						user.Name+" ("+user.UserId+") "+
						"User Title ID  is "+user.Xbox.TitleId+" Not "+friend.TitleId;
					throw new UnexpectedTestResultException( msg );
				}

				if( (Source == From.FD) && 
					(!ArrayEx.Compare( friend.TitleInfo, user.TitleStuff )) )
				{
					string msg =
						"Web Friend Data Validation Error - "+
						user.Name+" ("+user.UserId+") "+
						"User Title Stuff is "+
						ArrayEx.ToString( user.TitleStuff )+" Not "+
						ArrayEx.ToString( friend.TitleInfo );
					throw new UnexpectedTestResultException( msg );
				}
			}
			else
			{
				if( ! FindOfflineUser( user ) )
				{
					string msg =
						"Web Friend Data Validation Error - "+
						user.Name+" ("+user.UserId+") "+
						"is not an offline friend";
					throw new UnexpectedTestResultException( msg );
				}
			}
		}


		////////////////////////////////////////////////
		// Dump
		//
		public void Dump()
		{
			Console.WriteLine( "Dumping Web Friends:" );
			switch( Source )
			{
				case From.None:
					Console.WriteLine( "\tNot loaded" ); 
					return;
				case From.Widget:
					Console.WriteLine( "\tSource: Web Cache" ); 
					Console.WriteLine( "\tValid Seconds: "+_validSec ); 
					break;
				case From.FD:
					Console.WriteLine( "\tSource: Front Door" ); 
					Console.WriteLine( "\tHR: "+_replyData.HR );
					Console.WriteLine( "\tList Version: "+_replyData.Version );
					break;
			}

			if( Source == From.Widget )
			{
				Console.WriteLine("\tOnline Friends:");
				foreach( OnlineFriend f in _fi.OnlineFriends )
				{
					Console.WriteLine( 
						"\t\t"+f.G+
						" is playing "+f.T+
						" with State "+f.S );
				}
				Console.WriteLine("\tOffline friends:");
				if( Source == From.Widget )
				{
					foreach( OfflineFriend f in _fi.OfflineFriends )
					{
						Console.WriteLine( "\t\t"+f.G );
					}
				}
			}
			else if( Source == From.FD )
			{
    				Console.WriteLine("\tFriends:");
    				foreach( WebFriend w in _replyData.rgFriends)
    				{
    					Console.WriteLine( 
    						"\t\t"+w.BuddyID+
    						" is playing "+w.TitleID+
    						" with State "+w.OnlineState+
    						" and Rich Presence Data "+ArrayEx.ToString( w.szRichPresence) );
    				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNConditionalWaitState.cs ===
using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace ServerTestFramework.LiveService.Presence
{
	/// <summary>
	/// Create a multi-value wait state where all conditions must be
	/// met for the wait to complete.
	/// </summary>
	public partial class PNConditionalWaitState
	{
		protected abstract class Condition
		{
			public bool   Active;
			public PNUser Source;
			public PNUser Target;

			public abstract bool Check(QValPacket qval);
            public abstract bool CheckNotification(UserNotification noti);
		}

		ArrayList  _Conditions;
		ArrayList  _Completed;

		public uint MaxTimeout;


		/// <summary>
		/// Create a new conditional wait state for a target user. A default of 5 seconds
		/// will be used for the wait timeout.
		/// </summary>
		/// <param name="user">User to act as the target</param>
		public PNConditionalWaitState() : this(60)
		{
		}
		
		
		/// <summary>
		/// Create a new conditional wait state for a target user.
		/// </summary>
		/// <param name="user">User to act as the target</param>
		/// <param name="maxTimeoutSeconds">Timeout in seconds for the wait state</param>
		public PNConditionalWaitState(uint maxTimeoutSeconds)
		{
			_Conditions = new ArrayList();
			_Completed = new ArrayList();
			MaxTimeout = maxTimeoutSeconds;
		}

		/// <summary>
		/// Add a new required qflag that should arive based on the action of 
		/// a certain sender.
		/// </summary>
		/// <param name="qFlagMask">Bits to wait on, usually this will be a single bit. See XonPresNoti for bit definitions.</param>
		/// <param name="sender">Initiator of the action.</param>
        public void AddRequiredNotification(DATA_TYPES notificationType, PNUser source, PNUser target)
        {
            QFlagCondition cond = new QFlagCondition();
            cond.Source = source;
            cond.Target = target;
            cond.NotificationType = notificationType;
            _Conditions.Add(cond);
        }

		/// <summary>
		/// Build a condition string.
		/// </summary>
		/// <returns>A string representing all conditions currently unsatisfied</returns>
		public override string ToString()
		{
			StringBuilder buffer = new StringBuilder(512);
			uint count = 0;

			foreach(Condition cond in _Conditions)
			{
				if(cond.Active)
				{
					buffer.Append(String.Format("[{0}]: {1}\n", 
								count, 
								cond.ToString()));
				}
				count++;
			}

			return buffer.ToString();
		}

        public void WaitOnConditions()
        {
            WaitOnConditions(false);
        }

		/// <summary>
		/// Wait on all conditions.
		/// </summary>
		public void WaitOnConditions(bool ErrorOnUnexpectedQval)
		{
			DateTime abortTime = DateTime.Now.AddSeconds(MaxTimeout);
			ProgressInfo progress = new ProgressInfo("Waiting on conditions", (uint)_Conditions.Count, 1);

			Global.RO.Debug("PNConditionalWaitState.WaitOnConditions(): begin wait duration {0} seconds", MaxTimeout);

			if(0 == _Conditions.Count)
			{
				Global.RO.Warn("WaitOnConditions(): No conditions have been set.");
				goto lbDone;
			}

			Hashtable targetsHash = new Hashtable();
			ArrayList toRemove = new ArrayList();
			uint activeCount = 0;

			// Mark all conditions active and collect the set 
			// of all targets hashed to target ID
			foreach(Condition cond in _Conditions)
			{
				// Mark condition active cond.Active = true;
				activeCount++;
				cond.Active = true;
				
				// Hang array of conditions off of target ID in hash
				ArrayList conditions = (ArrayList)targetsHash[cond.Target.UserId];
				if(null == conditions)
				{
					conditions = new ArrayList();
					targetsHash[cond.Target.UserId] = conditions;
				}
				conditions.Add(cond);
				Global.RO.Debug("PNConditionalWaitState.WaitOnConditions(): added condition: {0}", cond.ToString());
			}
			
			try
			{
				ArrayList targetsHashToRemove = new ArrayList();

                while(activeCount > 0 && abortTime > DateTime.Now)
				{
                    // Poll qvals for all target users
					//QValPacket qval = null;

					targetsHashToRemove.Clear();

					// Loop over each distinct target type
					IDictionaryEnumerator enumerator = targetsHash.GetEnumerator();
					while(enumerator.MoveNext())
					{
						ulong targetId        = (ulong)enumerator.Key; 
						ArrayList conditions  = enumerator.Value as ArrayList;

						// Get the first condition and the target for group of conditions
						PNUser target = (conditions[0] as Condition).Target;


                        List<UserNotification> notis = new List<UserNotification>();
                        target.Xbox.GetUserNotificationFromQueue(target.UserId, out notis);

                        foreach (UserNotification n in notis)
                        {
                            Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): processing notification: From:{0}, To:{1}, Type:{2}, RecievedOn:{3}", n.FromXuid, n.ForXuid, n.NotificationDataType.ToString(), n.NotificationReceivedTime);
                            target.Xbox.ProcessTCPNotification(n);
                            foreach (Condition cond in conditions)
                            {
                                if (cond.CheckNotification(n))
                                {
                                    cond.Active = false;
                                    activeCount--;
                                    toRemove.Add(cond);
                                    progress.Step();
                                    Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): matched cond: {0}", cond.ToString());
                                }
                            }

                            if (toRemove.Count > 0)
                            {
                                // Remove the matched conditions
                                foreach (Condition cond in toRemove)
                                {
                                    conditions.Remove(cond);
                                }

                                // Clear conditions to remove array
                                toRemove.Clear();
                            }
                            else if (ErrorOnUnexpectedQval)
                            {
                                throw new UnexpectedTestResultException(String.Format("QVal received by User {0} did not match any conditions.", target.UserId));
                            }

                        }
                        ////if (target.Xbox.GetUserNotificationFromQueue(target.UserId, out
                        //// First check for and process any qvals on target
                        //if(target.Xbox.ReadUserQValPacket(target.UserId, out qval))
                        //{
                        //    Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): processing packet: QVal: 0x{0:x8}, QFlags: 0x{1:x8} ({2}), Ids: ({3:x}, {4:x}, {5:x}), Data: ({6:x}, {7:x}, {8:x}), Deleted: ({9:x}, {10:x}, {11:x})", 
                        //                qval.QVal, 
                        //                qval.QFlags, 
                        //                XonPresNoti.BuildQFlagsString(qval.QFlags),
                        //                qval.NewMessageId(0),
                        //                qval.NewMessageId(1),
                        //                qval.NewMessageId(2),
                        //                qval.NewMessageData(0),
                        //                qval.NewMessageData(1),
                        //                qval.NewMessageData(2),
                        //                qval.DeletedMessageId(0),
                        //                qval.DeletedMessageId(1),
                        //                qval.DeletedMessageId(2));

                        //    target.HandleQValPacket(qval);

                        //    // Process the conditions linked to target
                        //    foreach(Condition cond in conditions)
                        //    {
                        //        if(cond.Check(qval))
                        //        {
                        //            cond.Active = false;
                        //            activeCount--;
                        //            toRemove.Add(cond);
                        //            progress.Step();
                        //            Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): matched cond: {0}", cond.ToString());
                        //        }
                        //    }

                        //    if(toRemove.Count > 0)
                        //    {
                        //        // Remove the matched conditions
                        //        foreach(Condition cond in toRemove)
                        //        {
                        //            conditions.Remove(cond);
                        //        }

                        //        // Clear conditions to remove array
                        //        toRemove.Clear();
                        //    }
                        //    else if (ErrorOnUnexpectedQval)
                        //    {
                        //        throw new UnexpectedTestResultException(String.Format("QVal received by User {0} did not match any conditions.", target.UserId));
                        //    }
						
                        //} // end qval read

						// Satisfied all of this targets conditions, make for removal
						// and go to next item.
						if(0 == conditions.Count)
						{
							targetsHashToRemove.Add(targetId);
						}
					} // End target hash loop

					// Process any removal targets from the target hash (this cannot be done
					// while using collection enumeration so we do it out of the while loop
					// here.)
					//
					foreach(UInt64 targetId in targetsHashToRemove)
					{
						targetsHash.Remove(targetId);
					}

					Thread.Sleep(PNUser.NotificationPollingInterval);
				} // End active timeout loop
			} 
			catch(Exception)
			{
				// Log uncaught conditions and re-throw
				progress.Finish();
				Global.RO.Error("PNConditionalWaitState.WaitForConditions(): unexpected exception, current state: \n" + this.ToString());
				throw;
			}

			// Catch timeout condition
			if(activeCount > 0 && abortTime < DateTime.Now)
			{
				progress.Finish();
				throw new TimeOutException((ushort)MaxTimeout, "Timed out waiting on conditions:\n" + this.ToString());
			}

lbDone:
			// Normal or early exit
			progress.Finish();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Presence\PMsgWebFriends.cs ===
// PMsgWebFriends.cs
//
//	Presence Web Friends Message
//

using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace ServerTestFramework.LiveService.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// login a user from the web
	/// </summary>
	public class PMsgWebAlive : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants to log in</param>
		public PMsgWebAlive( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;
			if (user.PlatformType == PNUser.UserPlatformType.Mobile)
				SenderPlatform = SenderPlatformType.Mobile;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_WEB_ALIVE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PWebAliveMsgData data = new PWebAliveMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}


    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// login a user from the web (WebAlive 2)
    /// </summary>
    public class PMsgWebAlive2 : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User that wants to log in</param>
        public PMsgWebAlive2(PNUser user)
        {
            SentFrom = Requestor.Client;
            PortOnFD = FDPort.PresNoti_DC;
            AuthMethod = FDAuth.HttpHdr;
            ServiceOnFD = FDService.Presence;
            if (user.PlatformType == PNUser.UserPlatformType.Mobile)
                SenderPlatform = SenderPlatformType.Mobile;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.PMSG_WEB_ALIVE2;
            Msg.Hdr.MsgLen = 0;
            Msg.Hdr.SeqNum = PresSeqNum;

            // Fill out the SGADDR so we can resolve the psuedo 
            // XBOX info from the FakeSG for creating HTTP auth
            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.SpiSg = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

            PWebAlive2MsgData data = new PWebAlive2MsgData();
            data.UserID = user.UserId;
            data.TitleID = user.Xbox.TitleId;
            Msg.Data = data;
        }
    }

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Alive request
	/// </summary>
	public class PWebAliveMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Alive reply
	/// </summary>
	public class PWebAliveReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
	}

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Web Alive2 request
    /// </summary>
    public class PWebAlive2MsgData : PNMsgData
    {
        public ulong UserID;
        public uint TitleID;
    }
    
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgWebFriends : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgWebFriends( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_WEB_FRIENDS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PWebFriendsMsgData data = new PWebFriendsMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PWebFriendsMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PWebFriendReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
		public uint        Version;
		public uint      cdwFriends;
        
              [WireInfo(SizeParam="cdwFriends")]
		public WebFriend[] rgFriends;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class WebFriend : WireData
	{
		public ulong  BuddyID;
		public uint   Status;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNMsgDeadSG.cs ===
// PNMsgDeadSG.cs
//
//	Dead SG Message
//

using System;
using ServerTestFramework;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inform the servers that the given SG just went offline, so any users who were on 
	/// this SG should be considered offline also.  
	/// </summary>
	public class PNMsgDeadSG : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		public PNMsgDeadSG() 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DEAD_SG;
			Msg.Hdr.SeqNum  = PresSeqNum;
			Msg.Hdr.MsgLen = 0;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			Msg.Data = new PNDeadSGMsgData();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dead SG request
	/// </summary>
	public class PNDeadSGMsgData : PNMsgData
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNMsgHello.cs ===
// PNMsgHello.cs
//
//	Presence or Notification Hello Message
//

using System;
using ServerTestFramework;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Must be the first message sent between servers after establishing a TCP connection.
	/// Format is the same for both Presence and Notification
	/// </summary>
	public class PNMsgHello : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		public PNMsgHello() 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_HELLO;
			Msg.Hdr.SeqNum  = PresSeqNum;
			Msg.Hdr.MsgLen = 0;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.SpiSg  = 0;
			Msg.Hdr.Sgaddr.XboxID = 0;

			PNHelloMsgData data = new PNHelloMsgData();
			data.ProtocolVersion = XonPresNoti.CURRENT_XPPROTOCOL_VER;
			data.Description     = "V1.0";
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Hello request
	/// </summary>
	public class PNHelloMsgData : PNMsgData
	{
		public uint   ProtocolVersion;  // const: CURRENT_XPPROTOCOL_VER
		[WireInfo(NullTerminated=true, WriteOnlyVarLenString=true)] 
		public string Description;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNMsgDeadUser.cs ===
// PNMsgDeadUser.cs
//
//	Presence or Notification Dead User Message
//

using System;
using ServerTestFramework;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inform the presence or notification server that the given user just went offline.
	/// Format is the same for both Presence and Notification
	///
	/// DeadUser is a forged user message, it requires a valid auth data response from the
	/// SG but the user ID cannot be in the ticket.
	/// </summary>
	public class PNMsgDeadUser : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that is offline</param>
		/// <param name="service">Presence or Notificaion</param>
		public PNMsgDeadUser( PNUser user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DEAD_USER;
			Msg.Hdr.SeqNum  = PresSeqNum;
			Msg.Hdr.MsgLen  = 0;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = user.Xbox.XboxId;

			PNDeadUserMsgData data = new PNDeadUserMsgData();
			data.UserID = user.UserId;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dead User request
	/// </summary>
	public class PNDeadUserMsgData : PNMsgData
	{
		public ulong UserID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNMsgDeadXbox.cs ===
// PNMsgDeadXbox.cs
//
//	Presence or Notification Dead Xbox Message
//

using System;
using ServerTestFramework;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inform the servers that the given XBox just went offline. Any users who were on this 
	/// XBox should be considered offline also. Notification will consider items pertaining 
	/// to this address no longer relevant and delete them.
	/// Format is the same for both Presence and Notification
	/// </summary>
	public class PNMsgDeadXbox : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="xbox">Xbox going offiline</param>
		/// <param name="service">Presence or Notificaion</param>
		public PNMsgDeadXbox( PNXbox xbox ) 
		{
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DEAD_XBOX;
			Msg.Hdr.SeqNum  = PresSeqNum;
			Msg.Hdr.MsgLen = 0;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = xbox.IpSg;
			Msg.Hdr.Sgaddr.SpiSg  = xbox.SpiSg;
			Msg.Hdr.Sgaddr.XboxID = xbox.XboxId;

			Msg.Data = new PNDeadXboxMsgData();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dead Xbox request
	/// </summary>
	public class PNDeadXboxMsgData : PNMsgData
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNMsg.cs ===
// PNMsg.cs
//
//	Common Presence and Notification message classes
//

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Unique SG session Identifier
	/// </summary>
	public class SGADDR : WireData
	{
		public uint  inaSg;    // IP address of the SG for the client
		public uint  SpiSg;    // Pseudo-random identifier assigned by the SG
		public ulong XboxID;   // Unique identifier of client machine account
		public uint  Reserved; // Reserved (must be zero)
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNADDR : WireData
	{
		public XNADDR() : this( 1, 2, 3, 10, 15 ) {}
		public XNADDR( uint ip, uint oip, ushort oport, byte enet0, byte oid0 )
		{
			ina = ip; inaOnline = oip; wPortOnline = oport; abEnet[0] = enet0; abOnline[0] = oid0; 
		}

		public uint   ina;         // IN_ADDR: IP address (zero if not static/DHCP)
		public uint   inaOnline;   // IN_ADDR: Online IP address (zero if not online)
		public ushort wPortOnline; // Online port
		[WireInfo(ArraySize=6)]  
		public byte[] abEnet = new byte[6];   // Ethernet MAC address
		[WireInfo(ArraySize=20)] 
		public byte[] abOnline = new byte[20]; // Online identification

		///////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Validates given value agaist current state
		/// </summary>
		/// <param name="xnAddr">Test value</param>
		public void Check( XNADDR xnAddr )
		{
			if( ina != xnAddr.ina )
			{
				throw new Exception( "Check XNADDR: ina - Expected "+ina+", Given "+xnAddr.ina );
			}
			if( inaOnline != xnAddr.inaOnline )
			{
				throw new Exception( "Check XNADDR: inaOnline - Expected "+inaOnline+", Given "+xnAddr.inaOnline );
			}
			if( wPortOnline != xnAddr.wPortOnline )
			{
				throw new Exception( "Check XNADDR: wPortOnline - Expected "+wPortOnline+", Given "+xnAddr.wPortOnline );
			}
			if( ! ArrayEx.Compare( abEnet, xnAddr.abEnet ) )
			{
				throw new Exception( "Check XNADDR: abEnet - Expected "+ArrayEx.ToString( abEnet )+", Given "+ArrayEx.ToString( xnAddr.abEnet ) );
			}
			if( ! ArrayEx.Compare( abOnline, xnAddr.abOnline ) )
			{
				throw new Exception( "Check XNADDR: abOnline - Expected "+ArrayEx.ToString( abOnline )+", Given "+ArrayEx.ToString( xnAddr.abOnline ) );
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNKID : WireData
	{
		public XNKID() : this( 0xacae1dee ) {}
		public XNKID( ulong ul ) { ab = ul; }
			
		public ulong ab; // byte[8]: xbox to xbox key identifier

		///////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Validates given value agaist current state
		/// </summary>
		/// <param name="xnKID">Test value</param>
		public void Check( XNKID xnKID )
		{
			if( ab != xnKID.ab )
			{
				throw new Exception( "Check XNKID: ab - Expected "+ab+", Given "+xnKID.ab );
			}
		} 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNKEY : WireData
	{
		public XNKEY() : this( 0xcccccccc, 0xeeeeeeee ) {}
		public XNKEY( ulong ul1, ulong ul2 ) { ab1 = ul1; ab2 = ul2; }

		public ulong ab1; // byte[16]: xbox to xbox key exchange key
		public ulong ab2; 

		///////////////////////////////////////////////////////////////////////
		// Check
		//
		public void Check( XNKEY xnKey )
		{
			if( ab1 != xnKey.ab1 )
			{
				throw new Exception( "Check XNKEY: ab1 - Expected "+ab1+", Given "+xnKey.ab1 );
			}
			if( ab2 != xnKey.ab2 )
			{
				throw new Exception( "Check XNKEY: ab2 - Expected "+ab2+", Given "+xnKey.ab2 );
			}
		} 
	} 

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common header for Pres and Noti messages (BASE_MSG_HEADER)
	/// </summary>
	public class PNMsgHdr : WireData
	{
		public uint   MsgType; // Unique Msg ID: PMSG_xxx, QMSG_xxx, or MSGTYPE_ACK
		public uint   MsgLen;  // Amount of data in message following this header
		public uint   SeqNum;  // Distinguishes individual messages within a session (incremented by client)
		public SGADDR Sgaddr;  // Unique session identifier (Set up by SG when client connects)
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Base class for specific Pres and Noti message data.
	/// </summary>
	public abstract class PNMsgData : WireData
	{
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common wrapper for commom Presence and notication message header and custom data.
	/// (Duplicates Read and Write stream semantics without derivation or specific
	/// overloading becuse the Wiredata constructor did not like some of the stuff
	/// that needed to be ddone here. The PresNoti protocol is not very stream friendly.)
	/// </summary>
	public class PNMsg
	{
		public PNMsgHdr  Hdr  = null;
		public PNMsgData Data = null;

		//////////////////////////////////////
		/// <summary>
		/// Loads known Pres and Noit reply messaages from a data stream.
		/// </summary>
		/// <param name="stream">Reply message data stream</param>
		public void ReadStream( Stream stream )
		{
			// Get header from stream
			Hdr = new PNMsgHdr();
			Hdr.ReadStream( stream );
			
			// Get rest of data from stream
			byte[] data = new byte[ Hdr.MsgLen ];
			stream.Read( data, 0, data.Length );
			
			// Load specific message data
			switch( Hdr.MsgType )
			{
				case XonPresNoti.PMSG_ALIVE_REPLY:
					Data = new PAliveReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_LIST_REPLY:
					Data = new QDequeueReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_WEB_FRIENDS_REPLY:
					Data = new PWebFriendReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_WEB_ALIVE_REPLY:
					Data = new PWebAliveReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SESSION_REPLY:
					Data = new PPeerSessionReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.MSGTYPE_ACK:
					Data = new PNBaseAckReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_MESSAGES_REPLY:
					Data = new QEnumMsgsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_MESSAGES_2_REPLY:
					Data = new QEnumMsgs2ReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_SUMMARY_REPLY:
					Data = new QSummaryReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_SUMMARY_2_REPLY:
					Data = new QSummary2ReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_DETAILS_REPLY:
					Data = new QDetailsReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_DELETE_MESSAGE_REPLY:
					Data = new QDeleteMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_SEND_MESSAGE_REPLY:
					Data = new QSendMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_REVOKE_MESSAGE_REPLY:
					Data = new QRevokeMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_DELETE_TITLE_REPLY:
					Data = new QDeleteTitleReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_ENUM_TITLES_REPLY:
					Data = new QEnumTitlesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_FLAGS_REPLY:
					Data = new QFlagsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_SYSTEM_MESSAGES_REPLY:
					Data = new QEnumSystemMsgsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_SYSTEM_MESSAGE_DETAILS_REPLY:
					Data = new QSystemDetailsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_DELETE_SYSTEM_MESSAGE_REPLY:
					Data = new QDeleteSystemMsgReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_SEND_SYSTEM_MESSAGE_REPLY:
					Data = new QSendSystemMsgReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SUBSCRIBE_REPLY:
					Data = new PPeerSubscribeReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_UNSUBSCRIBE_REPLY:
					Data = new PPeerUnsubscribeReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_GET_STATE_REPLY:
					Data = new PGetStateReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_IS_AFFILIATE_REPLY:
					Data = new PIsAffiliateReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_QUERY_AFFILIATES_REPLY:
					Data = new PQueryAffiliatesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PRESENCE_INFO_REPLY:
					Data = new PPresenceInfoReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_FIND_USER_REPLY:
					Data = new PFindUserReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_CHECK_TITLE_MESSAGES_REPLY:
					Data = new PCheckTitleMessagesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_LOGON_CHECK_REPLY:
					Data = new PLogonCheckReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_FIND_USERS_REPLY:
					Data = new PFindUsersReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SUBSCRIBE_EX_REPLY:
					Data = new PPeerSubscribeExReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_GET_FRIENDS_LIST_REPLY:
					Data = new PGetFriendsListReplyMsgData();
					Data.ReadBytes( data );
					break;
                case XonPresNoti.PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY:
                    Data = new PFriendsLimitedPresenceReplyMsgData();
                    Data.ReadBytes(data);
                    break;
                case XonPresNoti.PMSG_GET_FRIENDS_NO_PRESENCE_REPLY:
                    Data = new PFriendsNoPresenceReplyMsgData();
                    Data.ReadBytes(data);
                    break;

				default:
					throw new Exception( "PN reply message type unknown" );
			}
		}

		//////////////////////////////////////
		/// <summary>
		/// Serializes Pres and Noti request messages to a data stream.
		/// </summary>
		/// <param name="stream">Request message data stream</param>
		public void WriteStream( Stream stream )
		{
			// Write Msg Data to intermediate stream
			MemoryStream DataStream = new MemoryStream();
			Data.WriteStream( DataStream );

			// Set Msg Data length
			Hdr.MsgLen = (uint)DataStream.Length;
			
			// Write header and data
			Hdr.WriteStream( stream );
			DataStream.WriteTo( stream );
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to the common Base Ack Reply
	/// </summary>
	public class PNBaseAckReplyMsgData : PNMsgData
	{
		public uint  AckMsgType; // MsgType of message being acknowledged
		public uint  AckSeqNum;  // SeqNum of message being acknowledged
		public ulong AckUserID;
		public uint  HRAck;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Combines Msg data with properties needed to process requests
	/// </summary>
	public abstract class PNRequestMsg
	{
        // Unique ascending message sequnece number
        public static uint PresSeqNum
        {
            get { return (uint)System.Threading.Interlocked.Increment(ref _SeqNum); }
        }
        private static int _SeqNum = 0;

		public PNMsg Msg = new PNMsg();

		//////////////////////////////////////
		/// <summary>
		/// Source of request
		/// </summary>
		public enum Requestor { Client, PresInh }
		public Requestor SentFrom = Requestor.Client;

		//////////////////////////////////////
		/// <summary>
		/// FD Port to use when sending to FD 
		/// </summary>
		public enum FDPort { None, PresNoti, Teams, Messaging, PresNoti_DC, Teams_DC, Messaging_DC }
		public FDPort PortOnFD = FDPort.None;

		public enum SenderPlatformType { Default, Web, Mobile }
		public SenderPlatformType SenderPlatform = SenderPlatformType.Default;
		//////////////////////////////////////
		/// <summary>
		/// Auth Method to use when sending to FD
		/// </summary>
		public enum FDAuth { None, SGMsg, HttpHdr };
		public FDAuth AuthMethod = FDAuth.None;

		//////////////////////////////////////
		/// <summary>
		/// Service Url used to create http header
		/// </summary>
		public string ServiceUrl 
		{
			get{ return serviceUrl; }
			set
			{
				if( serviceUrl != value )
				{
					serviceUrl = value;
				}
			}
		}
		private string serviceUrl = "";

		//////////////////////////////////////
		/// <summary>
		/// Service User agent used in http header
		/// </summary>
		public string ServiceUA
		{
			get{ return serviceUA; }
			set
			{
				if( serviceUA != value )
				{
					serviceUA = value;
				}
			}
		}
		private string serviceUA  = "";

		//////////////////////////////////////
		/// <summary>
		/// FD Service to request, Loads Url, service ID, and UA (based on service ID)
		/// </summary>
		public enum FDService {	None, Presence, Notification, Messaging, Teams }
		public FDService ServiceOnFD
		{
			set
			{ 
				switch( value )
				{
					case FDService.Presence:
						ServiceId  = (byte)XOService.PresNotification;
						ServiceUrl = XonPresNoti.PRESENCE_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.PresServ_VER_MAJOR+"."+
							XonPresNoti.PresServ_VER_MINOR.ToString("00");
						break;
					case FDService.Notification:
						ServiceId  = (byte)XOService.PresNotification;
						ServiceUrl = XonPresNoti.NOIFICATION_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.PresServ_VER_MAJOR+"."+
							XonPresNoti.PresServ_VER_MINOR;
						break;
					case FDService.Teams:
						ServiceId  = (byte)XOService.Teams;
						ServiceUrl = XonPresNoti.TEAMS_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.TeamServ_VER_MAJOR+"."+
							XonPresNoti.TeamServ_VER_MINOR;
						break;
					case FDService.Messaging:
						ServiceId  = (byte)XOService.MessagingService;
						ServiceUrl = XonPresNoti.MESSAGING_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.MessServ_VER_MAJOR+"."+
							XonPresNoti.MessServ_VER_MINOR;
						break;
					case FDService.None:
					default:
						ServiceId  = (byte)XOService.InvalidService;
						ServiceUrl = "";
						ServiceUA  = "";
						break;
				}
			}
		}
		private byte ServiceId = 0;

		/// <summary>
		/// Makes an Http Header for this request, using cached version of everything
		/// but content length and auth data if the auth is HttpHdr.  If there is no 
		/// builder cached a new one is made based on current FD Service 
		/// </summary>
		/// <param name="lContentLength">Length of post data</param>
		/// <returns>hhtp header for FD request</returns>
        public byte[] GetFDHttpHdr(ref CSGInfo slot, long lContentLength)
		{
            ushort clientVersion = slot.wBuildNumber;
			StringBuilder sb = new StringBuilder(256);
				
			sb.Append( "POST " );
			sb.Append( ServiceUrl );
			sb.Append( " HTTP/1.0\r\n" );

			sb.Append("Connection: Close\r\n");

			sb.Append( "User-Agent: "+ServiceUA );
			if( clientVersion != 0 )
			{
				sb.Append( "."+clientVersion );
			}
			sb.Append( "\r\n" );

			sb.Append( "Content-Type: xon/" );
			sb.Append( ServiceId.ToString( "x" ) );
			sb.Append( "\r\n");
			
			sb.Append( "Content-Length: " );
			sb.Append( lContentLength );
			sb.Append( "\r\n");

			if (this.SenderPlatform == SenderPlatformType.Web || this.SenderPlatform == SenderPlatformType.Mobile)
			{
			    sb.Append(XHttpHdr.XPLT + ":");
			    sb.Append(XOn.XPLT_INTERNAL_LIVEN.ToString());
			    sb.Append("\r\n");
			}

			if (this.SenderPlatform == SenderPlatformType.Mobile)
			{
			    sb.Append(XHttpHdr.XPLT_I + ":");
			    sb.Append(XOn.XPLT_MOBILE.ToString());
			    sb.Append("\r\n");
			}
			if( AuthMethod == FDAuth.HttpHdr )
			{
				HTTPAuthData authData = new HTTPAuthData(0, 0, 0, slot.userPuid0, slot.titleId, ServiceId, 0);

				// Setup additional properties
				authData.wLanguageID = slot.languageID;
				authData.dwAuthDataFlags = slot.authDataFlags;

				// Populate user slot info
				authData.xUsers[0].qwUserID = slot.userPuid0;
				authData.xUsers[1].qwUserID = slot.userPuid1;
				authData.xUsers[2].qwUserID = slot.userPuid2;
				authData.xUsers[3].qwUserID = slot.userPuid3;

				authData.xUsers[0].dwUserFlags = slot.userFlag0;
				authData.xUsers[1].dwUserFlags = slot.userFlag1;
				authData.xUsers[2].dwUserFlags = slot.userFlag2;
				authData.xUsers[3].dwUserFlags = slot.userFlag3;

				sb.Append(HTTPAuthData.HTTP_HEADER_AUTH_DATA);
				sb.Append(": ");
				sb.Append(authData.GetBase64EncodedString());
				sb.Append("\r\n");
			}
				
			sb.Append( "\r\n");

			System.Text.ASCIIEncoding asciEncoder = new System.Text.ASCIIEncoding();
			return asciEncoder.GetBytes( sb.ToString() );
		}

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, not expecting a reply.
        /// </summary>
        public void TransactFD()
        {
            PNMsg Reply;
            uint xDelay;
            TransactFD(out Reply, out xDelay);
            if (Reply.Hdr != null)
            {
                throw new Exception("Transact FD got reply contents when none was expected");
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, not expecting a reply.
        /// </summary>
        /// <param name="xDelay">XDelay in response Hdr</param>
        public void TransactFD(out uint xDelay)
        {
            PNMsg Reply;
            TransactFD(out Reply, out xDelay);
            if (Reply.Hdr != null)
            {
                throw new Exception("Transact FD got reply contents when none was expected");
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="reply">Response contents as PNMsg</param>
        public void TransactFD(out PNMsg reply)
        {
            uint xDelay;
            TransactFD(out reply, out xDelay);
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="reply">Response contents as PNMsg</param>
        /// <param name="xDelay">XDelay in response Hdr</param>
        public void TransactFD(out PNMsg reply, out uint xDelay)
        {
            // Setup SG Auth if needed
            CSGInfo slot = new CSGInfo();

            // If we have some mappable SGAUTH and we are requesting a valid auth
            // method load the slot from the FakeSG
            if (AuthMethod != PNRequestMsg.FDAuth.None
                    && 0 != Msg.Hdr.Sgaddr.XboxID)
            {
                GlobalFakeSG.FakeSG.LoadSlot(ref slot, Msg.Hdr.Sgaddr.XboxID);
            }

            TransactFD(ref slot, out reply, out xDelay);
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="slot">Customized SGInfo</param>
        /// <param name="reply">Response contents as PNMsg</param>
        /// <param name="xDelay">XDelay in response Hdr</param>
        private void TransactFD(ref CSGInfo slot, out PNMsg reply, out uint xDelay)
        {
            // Web messages should have sgignore set on the message so they
            // don't fail the CheckSgAddr() on INH
            if (PNRequestMsg.FDAuth.HttpHdr == AuthMethod)
            {
                Msg.Hdr.Sgaddr.inaSg = 0;
                Msg.Hdr.Sgaddr.SpiSg = 0;
                Msg.Hdr.Sgaddr.XboxID = 0;
                Msg.Hdr.Sgaddr.Reserved = 0;
            }

            // Write request message to memory stream
            MemoryStream stream = new MemoryStream();
            Msg.WriteStream(stream);

            // Build Http Header
            byte[] httpHdr = GetFDHttpHdr(ref slot, stream.Length);

            // Whether to use HTTP auth
            bool fUseHttpAuth = false;

            // Setup FD tranaction
            FDTransaction fd = new FDTransaction();
            switch (PortOnFD)
            {
                case PNRequestMsg.FDPort.PresNoti:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence);
                    break;
                case PNRequestMsg.FDPort.Teams:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_teams);
                    break;
                case PNRequestMsg.FDPort.Messaging:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_messaging);
                    break;
                case PNRequestMsg.FDPort.PresNoti_DC:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int);
                    fUseHttpAuth = true;
                    break;
                case PNRequestMsg.FDPort.Teams_DC:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_teams_int);
                    fUseHttpAuth = true;
                    break;
                case PNRequestMsg.FDPort.Messaging_DC:
                    fd.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_messaging_int);
                    fUseHttpAuth = true;
                    break;
                case PNRequestMsg.FDPort.None:
                default:
                    throw new Exception("Transact FD doesn't know what port to talk to.");
            }

            // Do FD transaction
            fd.Execute(httpHdr, stream, ref slot, fUseHttpAuth);
            xDelay = fd.XDelay;

            // Check results and reply
            reply = new PNMsg();
            switch (fd.httpStatus)
            {
                case HttpStatusCode.OK:
                    if (fd.ResponseContents.Length > 0)
                    {
                        MemoryStream inStream = new MemoryStream(fd.ResponseContents);
                        reply.ReadStream(inStream);
                    }
                    break;

                case HttpStatusCode.InternalServerError:
                    throw new XErrException(fd.XErr, "Transact FD failed with X-Err: 0x" + fd.XErr.ToString("X8") + ", " + Global.XErrToString(fd.XErr));
                default:
                    throw new HttpStatusCodeException(fd.httpStatus, "Transact FD Failed with server: " + fd.endPoint.ToString() + ", status Code: " + fd.httpStatus);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNXbox.cs ===
// PNXbox.cs
//
//    Presence and Notification Xbox Sim object
//

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using ServerTestFramework.LiveService.FakeSG;

using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.protocol.SubNoti;
using xonline.common.community;
using xonline.common.utilities2;


namespace ServerTestFramework.LiveService.PresNotiCommon
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Consolodates session info (title and client endpoint)
    /// </summary>
    public class XSessionInfo
    {
        public uint TitleId = PNXbox.DefTitleId;
        public uint TitleVer = PNXbox.DefTitleVersion;
        public uint TitleRegion = PNXbox.DefTitleRegion;

        public XNADDR XnAddr = new XNADDR();
        public XNKID XnKId = new XNKID();
        public XNKEY XnKey = new XNKEY();

        //////////////////////////////////////
        /// <summary>
        /// Compares current with given state and throws exception when differences found
        /// </summary>
        /// <param name="sessInfo">Data to compare against</param>
        public void Check(XSessionInfo sessInfo)
        {
            if (TitleId != sessInfo.TitleId)
            {
                throw new Exception("Check XSessionInfo: TitleId - Expected " + TitleId + ", Given " + sessInfo.TitleId);
            }
            if (TitleVer != sessInfo.TitleVer)
            {
                throw new Exception("Check XSessionInfo: TitleVer - Expected " + TitleVer + ", Given " + sessInfo.TitleVer);
            }
            if (TitleRegion != sessInfo.TitleRegion)
            {
                throw new Exception("Check XSessionInfo: TitleRegion - Expected " + TitleRegion + ", Given " + sessInfo.TitleRegion);
            }
            XnAddr.Check(sessInfo.XnAddr);
            XnKId.Check(sessInfo.XnKId);
            XnKey.Check(sessInfo.XnKey);
        }
    }

    // Client Library Version
    public class ClientVersions
    {
        public static ulong LatestXenonClientVersion = ClientVersion.Create(2, 0, 0, 8498);
        //public static ulong LatestXboxClientVersion = ClientVersion.Create(0, 0, 6, 5849);
        public static ulong LatestPCClientVersion = ClientVersion.Create(2, 0, 0, 687);

        public static ulong PCNoPartyInvitesVersion = ClientVersion.Create(1, 2, 0, 241); // supported with wMajorVersion >= 2
        public static ulong XenonNoPartyInvitesVersion = ClientVersion.Create(2, 0, 0, 7220); // supported with wBuildNumber > 7220
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Simulation state for an Xbox in the the presence and notificatiion system
    /// </summary>
    public class PNXbox
    {
        static public readonly uint DefTitleId = 0xFFC0FE00;  // Test title populated into UODB.
        static public readonly uint DefTitleVersion = 1;
        static public readonly uint DefTitleRegion = 1;

        // SGAddr related state data
        private uint _IpSg = 0;
        private uint _SpiSg = 0;
        private ulong _XboxId = 0;
        private uint _Reserved = 0;
        public uint IpSg { get { return _IpSg; } }
        public uint SpiSg { get { return _SpiSg; } }
        public ulong XboxId { get { return _XboxId; } }
        public uint Reserved { get { return _Reserved; } }

        // Session Info state data (and Accessors for commonly used values)
        public XSessionInfo SessInfo = new XSessionInfo();
        public uint TitleId { get { return SessInfo.TitleId; } }
        public uint TitleVer { get { return SessInfo.TitleVer; } }
        public uint TitleRegion { get { return SessInfo.TitleRegion; } }
        public XNADDR XnAddr { get { return SessInfo.XnAddr; } }
        public XNKID XnKId { get { return SessInfo.XnKId; } }
        public XNKEY XnKey { get { return SessInfo.XnKey; } }

        // Alt title storage
        private uint[] _AltTitles = new uint[4];

        // TBD!!! maybe this is the same as XnKey
        public byte[] Key = DefaultKey;
        public static byte[] DefaultKey = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
        public static byte[] AnotherKey = { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 };

        // type of client is this xbox
        private CSGInfo.ClientType _ClientType;
        public CSGInfo.ClientType ClientType
        {
            get
            {
                return _ClientType;
            }
        }

        public bool IsXenonTitle
        {
            get
            {
                return _ClientType == CSGInfo.ClientType.Xenon;
            }
        }

        protected ulong _ClientVersion = ClientVersions.LatestXenonClientVersion;
        public ulong ClientVersion
        {
            get { return _ClientVersion; }
            set
            {
                _ClientVersion = value;
                UpdateFakeSG();
            }
        }

        public uint[] AltTitles
        {
            get { return _AltTitles; }
            set
            {
                // Ensure we are connected to the fake sg, issue extra call to set alt titles
                _AltTitles = value;
                UpdateFakeSG();
                GlobalFakeSG.FakeSG.SetAltTitles(XboxId, _AltTitles);
            }
        }

        /// <summary>
        /// Is xbox connected to SG (fakeSG)
        /// </summary>
        public bool ConnectedToFakeSG
        {
            get { return _SpiSg != 0; }
        }

        // Default language to english
        protected uint _LanguageId = 1;
        public bool RestrictLanguageToSupported = true;
        public byte LanguageId
        {
            get { return (byte)_LanguageId; }
            set
            {
                // these values, at least max, should be pulled from xon.cs
                if ((value < 1 || value > 12) & (RestrictLanguageToSupported))
                {
                    // currently NPDB has locales 1-12
                    throw new ArgumentException("LanguageId must be between 1 and 12");
                }
                // Modify
                _LanguageId = (uint)value;
                UpdateFakeSG();
            }
        }

        /// <summary>
        /// Static initializer for clearing any Xbox that the FakeSG is tracking
        /// this should cleanup the corresponding data in presence the first time
        /// any PNXbox is used.
        /// </summary>
        static PNXbox()
        {
            GlobalFakeSG.FakeSG.ClearXboxes();
        }

        /// <summary>
        /// Creates an xbox with default data in connected state
        /// </summary>
        public PNXbox()
            : this(DefTitleId, ClientVersions.LatestXenonClientVersion, CSGInfo.ClientType.Xenon)
        {
        }

        /// <summary>
        /// Creates an xbox with default data in connected state with specified titleID
        /// </summary>
        /// <param name="titleId">Title ID to be initially connected with</param>
        public PNXbox(uint titleId)
            : this(titleId, ClientVersions.LatestXenonClientVersion, CSGInfo.ClientType.Xenon)
        {
        }


        /// <summary>
        /// Creates an existing xbox with default data in a connect state.
        /// </summary>
        public PNXbox(ulong machineID, uint titleId, CSGInfo.ClientType clientType)
        {
            _IpSg = PNClientInfo.LocalIP;
            _XboxId = machineID;
            _SpiSg = 0;
            SessInfo.TitleId = titleId;
            _ClientVersion = ClientVersions.LatestXenonClientVersion;
            _ClientType = clientType;

            ConnectToFakeSG();
        }

        /// <summary>
        /// Creates an xbox with default data in connected state with titleId and clientVersion
        /// </summary>
        /// <param name="titleId">Title ID to be initially connected with</param>
        /// <param name="clientVersion">Version of client, default is 5936</param>
        public PNXbox(uint titleId, ulong clientVersion)
            : this(titleId, clientVersion, CSGInfo.ClientType.Xenon)
        {
        }

        /// <summary>
        /// Creates an xbox with default data in connected state with titleId and clientVersion and Xenon client
        /// </summary>
        /// <param name="titleId">Title ID to be initially connected with</param>
        /// <param name="clientVersion">Version of client, default is 5936</param>
        /// <param name="isXenonTitle">Is this a Xenon title (client) or Xbox</param>
        public PNXbox(uint titleId, ulong clientVersion, bool isXenonTitle)
            : this(titleId, clientVersion, CSGInfo.ClientType.Xenon)
        {
        }
        public PNXbox(uint titleId, ulong clientVersion, CSGInfo.ClientType clientType)
            : this(titleId, clientVersion, CSGInfo.ClientType.Xenon, false)
        { 
        }
        public PNXbox(uint titleId, ulong clientVersion, CSGInfo.ClientType clientType, bool autoProcessNotifications)
        {
            _IpSg = PNClientInfo.LocalIP;
            _XboxId = baseBoxId | ((ulong)PNClientInfo.ClientId << 16) | masterBoxId++;
            _SpiSg = 0;
            SessInfo.TitleId = titleId;
            _ClientVersion = clientVersion;
            _ClientType = clientType;
            AutoProcessNotifications = autoProcessNotifications;

            _XboxId &= ~CSGInfo.ClientInfo.Mask;

            switch (clientType)
            {
                case CSGInfo.ClientType.Xenon:
                case CSGInfo.ClientType.XenonBackCompat:
                    _XboxId |= CSGInfo.ClientInfo.XenonMachineBase;
                    break;
                case CSGInfo.ClientType.PC:
                    _XboxId |= CSGInfo.ClientInfo.PcMachineBase;
                    break;
                default:
                    throw new Exception("Unknown client type: " + clientType.ToString());
            }

            ConnectToFakeSG();
        }

        private const ulong baseBoxId = 0x00090c5500000000; // default to xbox1
        private static uint masterBoxId = 1;
        private static uint masterSpi = 1;

        /// <summary>
        /// Create with raw values provided, intended for invalid test cases.
        /// Not initially connected
        /// </summary>
        /// <param name="ipsg">SgAddr IP</param>
        /// <param name="spisg">SgAddr SPI</param>
        /// <param name="xboxId">SgAddr Xbox ID</param>
        public PNXbox(uint ipsg, uint spisg, ulong xboxId)
        {
            _IpSg = ipsg;
            _SpiSg = spisg;
            _XboxId = xboxId;
        }



        public PNXbox(bool autoProcessNotifs)
            : this(DefTitleId, ClientVersions.LatestXenonClientVersion, CSGInfo.ClientType.Xenon, autoProcessNotifs)
        {
        }

        /// <summary>
        /// Establish this xbox in the fake SG. This method can be called more than once
        /// to update the associated information about this Xbox in the SG.
        /// </summary>
        public void ConnectToFakeSG()
        {
            // If we don't have a SPI get a new one
            if (!ConnectedToFakeSG)
            {
                _SpiSg = masterSpi++;
            }

            GlobalFakeSG.FakeSG.AddXbox(_IpSg, _SpiSg, _XboxId, TitleId, TitleVer, TitleRegion, Key, ClientVersion, _ClientType, _LanguageId);
        }

        /// <summary>
        /// Refresh data in Fake SG will throw if a SPI has not been generated
        /// indicating a 'disconnected' state.
        /// </summary>
        public void UpdateFakeSG()
        {
            if (!ConnectedToFakeSG)
            {
                throw new Exception("Xbox Id: " + XboxId.ToString("x") + " has not been connected to the FakeSG yet.");
            }
            GlobalFakeSG.FakeSG.AddXbox(_IpSg, _SpiSg, _XboxId, TitleId, TitleVer, TitleRegion, Key, ClientVersion, _ClientType, _LanguageId);
        }

        /// <summary>
        /// Clear SPI, remove this Xbox instance from the FakeSG
        /// </summary>
        public void DisconnectFromFakeSG()
        {
            _SpiSg = 0;
            GlobalFakeSG.FakeSG.RemoveXbox(_XboxId);
        }


        /// <summary>
        /// Send dead xbox message via the CSgMsgNotifyCliDelete
        /// </summary>
        public void DeadXbox()
        {
            GlobalFakeSG.FakeSG.DeadXbox(_XboxId);
            // SG should no longer report data for this xbox
            DisconnectFromFakeSG();
        }

        /// <summary>
        /// Change the Title ID, using the default title version and region
        /// </summary>
        /// <param name="titleId">New Title ID</param>
        public void ChangeTitle(uint titleId)
        {
            ChangeTitle(titleId, PNXbox.DefTitleVersion, PNXbox.DefTitleRegion);
        }

        /// <summary>
        /// Change title information on the local xbox object and in the fake sg
        /// </summary>
        /// <param name="titleId">New title Id</param>
        /// <param name="titleVer">New title version</param>
        /// <param name="titleRegion">New Title Region</param>
        public void ChangeTitle(uint titleId, uint titleVer, uint titleRegion)
        {
            SessInfo.TitleId = titleId;
            SessInfo.TitleVer = titleVer;
            SessInfo.TitleRegion = titleRegion;
            ConnectToFakeSG();
        }

        /// <summary>
        /// Returns True if this XBox is expecting to dequeue Presenece 2 items
        /// </summary>
        public bool CanConsumeRichPresence()
        {
//            if (_ClientType == CSGInfo.ClientType.XenonBackCompat)
//            {
//                return false;
//            }
            return true;
        }


        // all the following code is used to merge Connection Server and XPServer Testing.
        //private bool _fUseConnectionServer = false;
        public PNConnection ConnectionServerConnection = null;
        //private Queue QValQueue = Queue.Synchronized(new Queue());

        public void AddUser(ulong UserId, uint UserFlags)
        {
            GlobalFakeSG.FakeSG.AddUser(XboxId, UserId, UserFlags);

            this.InitConnectionServerIfNeeded();

            int[] userIndices;
            ulong[] userIds;
            GetConnecteduserIndicesAndUserIds(out userIndices, out userIds);

            CONNECT_REPLY reply = ConnectionServerConnection.Connect(userIndices, userIds);
            if (!HResult.Equals((uint)reply.hr, HResult.S_OK))
                throw new HResultException((uint)reply.hr, "AddUser: XConnSrv Connect failed for user " + UserId);

        }

        public void RemoveUser(ulong UserId)
        {
            GlobalFakeSG.FakeSG.RemoveUser(XboxId, UserId);

            if (ConnectionServerConnection == null)
                return;

            int[] userIndices;
            ulong[] userIds;
            this.GetConnecteduserIndicesAndUserIds(out userIndices, out userIds);

            CONNECT_REPLY reply = ConnectionServerConnection.Connect(userIndices, userIds);
            if (!HResult.Equals((uint)reply.hr, HResult.S_OK))
                throw new HResultException((uint)reply.hr, "RemoveUser: Connect failed for user " + UserId);

            //remove all remaining notifications.
            List<UserNotification> removeme = new List<UserNotification>();
            foreach (UserNotification un in NotificationReceived)
            {
                if (un.ForXuid == UserId)
                {
                    removeme.Add(un);
                }
            }
            foreach (UserNotification un in removeme)
            {
                lock (NotificationReceived)
                {
                    NotificationReceived.Remove(un);
                }
            }
        }

        private int GetUserIndexForUserId(ulong UserId, int[] userIndices, ulong[] userIds)
        {
            for (int i = 0; i < userIds.Length; i++)
            {
                if (UserId == userIds[i])
                    return userIndices[i];
            }

            // TODO: unexpected behaviour
            return -1;
        }

        //Build userindices and userid array to pass it to connect.
        private void GetConnecteduserIndicesAndUserIds(out int[] userIndices, out ulong[] userIds)
        {
            CSGInfo csg = GlobalFakeSG.FakeSG.GetSlot();
            GlobalFakeSG.FakeSG.LoadSlot(ref csg, XboxId);

            ulong[] connectedusers = new ulong[4] { csg.userPuid0, csg.userPuid1, csg.userPuid2, csg.userPuid3 };

            //Find out how many are connected first.
            int numConnected = 0;
            for (int i = 0; i < connectedusers.Length; i++)
            {
                if (connectedusers[i] != 0)
                {
                    numConnected++;
                }
            }

            //Init our array with numConnected. We are going to send this array to Connect.
            userIndices = new int[numConnected];
            userIds = new ulong[numConnected];

            //Fill in the values to array.
            int current = 0;
            for (int i = 0; i < connectedusers.Length; i++)
            {
                if (connectedusers[i] != 0)
                {
                    userIndices[current] = i;
                    userIds[current] = connectedusers[i];
                    current++;
                }
            }
        }

        public bool ReadUserQValPacket(ulong UserId, out QValPacket retPacket)
        {
            bool fServerQVAL = false;
            fServerQVAL = GlobalFakeSG.FakeSG.ReadUserQValPacket(XboxId, UserId, out retPacket);
            if (fServerQVAL)
                return true;
            return false;
        }

        public void conn_Notified(object oSender, ConnSrvConnection.NotifiedEventArgs oArgs)
        {
            DATA_NOTIFICATION dn = oArgs.In as DATA_NOTIFICATION;
            if (dn != null)
            {
                uint dwUserIndexFlags = dn.header.dwUserIndexFlags;
                int[] indexes = SubNotiDefs.UserFlagsToIndices(dwUserIndexFlags);
                foreach(int index in indexes)
                {
                    PNUser user = null;   
                    try
                    {
                        user = GetUserByIndex(index);
                    }
                    catch (Exception e)
                    {
                        //In case the user is not found in SG, we dont have to do anything. Continue in that case.
                        //This is the case where iether fakesg crashed big time or 'Dead' was called.
                        Global.RO.Error(e.Message);
                        continue;
                    }
                    
                    if (user == null)
                        continue;
                    if (dn.rgDataObjects[0] != null)
                    {
                        DATA_TYPES notityp = (DATA_TYPES)dn.rgDataObjects[0].wDataType;
                        Global.RO.Info("Notification Received for user: {0}, Type:{1}", user.UserId, notityp.ToString());
                        QueueTCPNotification(user.UserId, dn.rgDataObjects);
                    }
                    else
                        Global.RO.Warn("0 length rgDataObject found in received notification.");
                }
            }
        }

        private void QueueTCPNotification(ulong userId, SUBSCRIPTION_DATA[] received)
        {
            foreach (SUBSCRIPTION_DATA dr in received)
            {
                UserNotification un = new UserNotification();
                un.ForXuid = userId;
                un.FromXuid = dr.qwOwnerXUID;
                un.NotificationDataType = (DATA_TYPES)dr.wDataType;
                un.NotificationReceivedTime = DateTime.Now;
                un.SubscriptionData = dr;
                lock (NotificationReceived)
                {
                    NotificationReceived.Add(un);
                }
                if (AutoProcessNotifications)
                {
                    ProcessTCPNotification(un);
                }
            }

        }

        public void ProcessTCPNotification(ulong forXuid)
        {
            lock (NotificationReceived)
            {
                foreach (UserNotification un in NotificationReceived)
                {
                    if (un.ForXuid == forXuid)
                    {
                        ProcessTCPNotification(un);
                    }
                }
            }
        }

        public void ProcessTCPNotification(ulong forXuid, DATA_TYPES typ)
        {
            lock (NotificationReceived)
            {
                foreach (UserNotification un in NotificationReceived)
                {
                    if (un.ForXuid == forXuid && un.NotificationDataType == typ)
                    {
                        ProcessTCPNotification(un);
                    }
                }
            }
        }

        public void ProcessTCPNotification(ulong forXuid, ulong fromXuid, DATA_TYPES typ)
        {
            lock (NotificationReceived)
            {
                foreach (UserNotification un in NotificationReceived)
                {
                    if (un.ForXuid == forXuid && un.NotificationDataType == typ && un.FromXuid == fromXuid)
                    {
                        ProcessTCPNotification(un);
                    }
                }
            }
        }

        public void GetUserNotificationFromQueue(ulong forXuid, ulong fromXuid, DATA_TYPES notificationType, out List<UserNotification> notis)
        {
            notis = new List<UserNotification>();
            lock (NotificationReceived)
            {
                foreach (UserNotification n in NotificationReceived)
                {
                    if (n.ForXuid == forXuid && n.NotificationDataType == notificationType && n.FromXuid == fromXuid)
                        notis.Add(n);
                }
            }
        }
        public void GetUserNotificationFromQueue(ulong forXuid, DATA_TYPES notificationType, out List<UserNotification> notis)
        {
            notis = new List<UserNotification>();
            lock (NotificationReceived)
            {
                foreach (UserNotification n in NotificationReceived)
                {
                    if (n.ForXuid == forXuid && n.NotificationDataType == notificationType)
                        notis.Add(n);
                }
            }
        }
        public void GetUserNotificationFromQueue(ulong forXuid, out List<UserNotification> notis)
        {
            notis = new List<UserNotification>();
            lock (NotificationReceived)
            {
                foreach (UserNotification n in NotificationReceived)
                {
                    if (n.ForXuid == forXuid)
                        notis.Add(n);
                }
            }
        }
        
        public void ProcessTCPNotification(UserNotification notif)
        {
            PNUser user = PNUser.Find(notif.ForXuid);
            switch (notif.NotificationDataType)
            {
                case DATA_TYPES.eAvatar:
                    break;
                case DATA_TYPES.eBasicPresence:
                    {

                        BasicPresenceNotificationData bp = BasicPresenceNotificationData.Get(notif.SubscriptionData);
                        PNUser.BuddyInfo buddy = user.GetBuddyInfo(notif.FromXuid);
                        if (null != buddy)
                            buddy.BasicPresenceData = bp;
                        PNUser.PeerInfo peer = user.GetPeerInfo(notif.FromXuid);
                        if (null != peer)
                            peer.BasicPresenceData = bp;
                        if (buddy == null && peer == null)
                            Global.RO.Warn("Unexpected basic Notification.");

                        break;
                    }
                case DATA_TYPES.eBasicProfile:
                    break;
                case DATA_TYPES.eConnSrvLocation:
                    break;
                case DATA_TYPES.eExtendedPresence:
                    break;
                case DATA_TYPES.eExtendedProfile:
                    break;
                case DATA_TYPES.eFriendsList:
                        break;
                case DATA_TYPES.ePartyInfo:
                    break;
                case DATA_TYPES.eRichPresenceString:
                    {

                        RichPresenceNotificationData rp = RichPresenceNotificationData.Get(notif.SubscriptionData);
                        PNUser.BuddyInfo buddy = user.GetBuddyInfo(notif.FromXuid);
                        if (null != buddy)
                        {
                            buddy.RichPresenceData = rp;
                        }
                        PNUser.PeerInfo peer = user.GetPeerInfo(notif.FromXuid);
                        if (null != peer)
                        {
                            peer.RichPresenceData = rp;
                        }
                        break;
                    }
                default:
                    break;
            }

            //Once processed, remove the notification from the list.
            lock (NotificationReceived)
            {
                NotificationReceived.Remove(notif);
            }
        }


        private void InitConnectionServerIfNeeded()
        {
            if (ConnectionServerConnection == null)
            {
                ConnectionServerConnection = new PNConnection(XboxId);
                ConnectionServerConnection.Notified += new ConnSrvConnection.NotifiedEventHandler(conn_Notified);
            }
        }

        private UserData[] ExtractUserDataFromSubscriptionData(byte[] subData)
        {
            unsafe
            {
                fixed (byte* data = &subData[0])
                {
                    uint* dwListVersion = (uint*)data;
                    uint ver = *dwListVersion;

                    uint numuser = 0;
                    byte* pb2 = data + sizeof(uint);
                    uint* dwNumUsers = (uint*)pb2;
                    numuser = *dwNumUsers;

                    pb2 = pb2 + sizeof(uint);

                    UserData[] uds = new UserData[numuser];

                    MemoryStream ms = new MemoryStream(subData, (int)(pb2 - data), subData.Length - (int)(pb2 - data)); 
                    for (int i = 0; i < numuser; ++i)
                    {
                        uds[i] = new UserData();
                        uds[i].ReadStream(ms);
                    }

                    return uds;
                }
            }
        }
        
        //private DATA_OBJECT_SPECIFIER[] GetFriendsListDataObjectSpecifierArray(ulong qwUserXuid)
        //{
        //    //Get Dataobject Specifier for friends list.
        //    DATA_OBJECT_SPECIFIER[] friendsSpecifier = new DATA_OBJECT_SPECIFIER[1];
        //    DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
        //    dos.wDataType = (ushort)DATA_TYPES.eFriendsList;
        //    dos.dwDataSubType = 0;
        //    dos.qwOwnerXUID = qwUserXuid;
        //    unsafe
        //    {
        //        dos.wObjectSize = (ushort)(sizeof(USER_LIST_DATA) + (sizeof(USER_DATA) * 100) + sizeof(BASE_DATA_HEADER));
        //    }
        //    friendsSpecifier[0] = dos;
        //    return friendsSpecifier;
        //}
        //public void SubscribetoFriendsList(ulong userId, int userIndex)
        //{
        //    DATA_OBJECT_SPECIFIER[] friendsSpecifier = GetFriendsListDataObjectSpecifierArray(userId);
        //    SUBSCRIBE_REPLY flSubscribeReply = ConnectionServerConnection.Subscribe(friendsSpecifier, new int[]{userIndex} );
        //    if (flSubscribeReply.hr == HResult.S_OK)
        //    {
        //        Global.RO.Info("Subscribed from PNXbox returns S_OK. Trying to GetNotificationPair and create P2Item.");
        //    }
        //    else
        //    {
        //        Global.RO.Warn("Subscription failed with HR: " + flSubscribeReply.hr);
        //    }

        //}

        public void SendSubscribeForUser(ulong UserId, DATA_OBJECT_SPECIFIER[] rgDataObjects)
        {
            this.SendSubscribeForUser(UserId, rgDataObjects, false);
        }
        public void SendSubscribeForUser(ulong UserId, DATA_OBJECT_SPECIFIER[] rgDataObjects, bool isAbsolute)
        {
            SUBSCRIBE_REPLY reply;
            this.SendSubscribeForUser(UserId, rgDataObjects, false, out reply);
        }
        public void SendSubscribeForUser(ulong UserId, DATA_OBJECT_SPECIFIER[] rgDataObjects, bool isAbsolute, out SUBSCRIBE_REPLY subreply)
        {
            PNUser user = PNUser.Find(UserId);
            int userIndex = user.UserControllerIndex;
            SUBSCRIBE_REPLY reply;
            if (! isAbsolute)
                reply = this.ConnectionServerConnection.Subscribe(rgDataObjects, new int[]{userIndex});
            else
                reply = this.ConnectionServerConnection.Subscribe(rgDataObjects, new int[]{userIndex}, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);
            subreply = reply;
            if (reply.hr == HResult.S_OK)
            {
                Global.RO.Info("Subscribed from PNXbox returns S_OK. Opening reply...");
                foreach (SUBSCRIPTION_DATA s in reply.rgDataObjects)
                {
                    switch ((DATA_TYPES)s.wDataType)
                    {
                        case DATA_TYPES.eAvatar:
                            break;
                        case DATA_TYPES.eBasicPresence:
                            {
                                BasicPresenceNotificationData bp = BasicPresenceNotificationData.Get(s);
                                PNUser.BuddyInfo buddy = user.GetBuddyInfo(s.qwOwnerXUID);
                                if (null != buddy)
                                    buddy.BasicPresenceData = bp;
                                PNUser.PeerInfo peer = user.GetPeerInfo(s.qwOwnerXUID);
                                if (null != peer)
                                    peer.BasicPresenceData = bp;
                                if (buddy == null && peer == null)
                                    Global.RO.Warn("Unexpected basic Notification.");

                                break;
                            }
                        case DATA_TYPES.eBasicProfile:
                            break;
                        case DATA_TYPES.eConnSrvLocation:
                            break;
                        case DATA_TYPES.eExtendedPresence:
                            break;
                        case DATA_TYPES.eExtendedProfile:
                            break;
                        case DATA_TYPES.eFriendsList:
                            break;
                        case DATA_TYPES.ePartyInfo:
                            break;
                        case DATA_TYPES.eRichPresenceString:
                            {
                                RichPresenceNotificationData rp = RichPresenceNotificationData.Get(s);
                                PNUser.BuddyInfo buddy = user.GetBuddyInfo(s.qwOwnerXUID);
                                if (buddy == null)
                                    Global.RO.Warn("Not in buddy list. How did we get this?");
                                else
                                    buddy.RichPresenceData = rp; 
                                break;
                            }
                        default:
                            break;
                    }
                }
            }
            else
            {
                Global.RO.Warn("Subscription failed with HR: " + reply.hr);
            }
        }

        public void SendUnsubscribeForUser(ulong UserId, DATA_OBJECT_SPECIFIER[] rgDataObjects)
        {
            UNSUBSCRIBE_REPLY rep;
            this.SendUnsubscribeForUser(UserId, rgDataObjects, out rep);
        }

        public void SendUnsubscribeForUser(ulong UserId, DATA_OBJECT_SPECIFIER[] rgDataObjects, out UNSUBSCRIBE_REPLY unsubReply)
        {
            int userIndex = PNUser.Find(UserId).UserControllerIndex;

            UNSUBSCRIBE_REPLY reply = this.ConnectionServerConnection.Unsubscribe(rgDataObjects, new int[] { userIndex });
            if (reply.hr != HResult.S_OK)
            {
                Global.RO.Warn("UnSubscribe failed with HR: " + reply.hr);
            }
            unsubReply = reply;
        }

        /// <summary>
        /// Return user on certain index on this controller.
        /// </summary>
        /// <param name="userIndex"></param>
        /// <returns></returns>
        public PNUser GetUserByIndex(int userIndex)
        {
            int[] userindices;
            ulong[] userids;

            GetConnecteduserIndicesAndUserIds(out userindices, out userids);

            int found = -1;
            for(int i = 0; i < userindices.Length ; i++)
            {
                if (userindices[i] == userIndex)
                    found = i;
            }

            if (found != -1)
            {
                return PNUser.Find(userids[found]);
            }
            Global.RO.Warn("No user found at this userindex.");
            return null;
        }

        public List<UserNotification> NotificationReceived = new List<UserNotification>();
        public bool AutoProcessNotifications = false;
    }

    public class UserNotification
    {
        public ulong ForXuid;
        public ulong FromXuid;
        public DATA_TYPES NotificationDataType;
        public SUBSCRIPTION_DATA SubscriptionData;
        public DateTime NotificationReceivedTime;
    }

    public class BasicPresenceNotificationData
    {
        public uint TitleId = 0;
        public uint State = XonPresNoti.P_STATE_MASK_NONE;
        public ulong MatchSessionId = 0;
        public uint mtLastSeen;
        public static BasicPresenceNotificationData Get(SUBSCRIPTION_DATA notificationSubData)
        {
            BasicPresenceNotificationData result = new BasicPresenceNotificationData();
            if (notificationSubData.data == null || notificationSubData.data.Length == 0)
            {
                Global.RO.Warn("Basic Notification with Null data received.");
                return result;
            }

            BasicPresence basic = new BasicPresence();
            basic.ReadBytes((byte[])notificationSubData);
            result.TitleId = basic.dwTitleID;
            result.mtLastSeen = basic.mtLastSeen;
            result.MatchSessionId = basic.qwSessionID;
            result.State = basic.dwState;

            return result;
        }
    }
    public class RichPresenceNotificationData
    {
        public ushort RichPresenceStringLength;
        public string RichPresenceString;

        public static RichPresenceNotificationData Get(SUBSCRIPTION_DATA notificationSubData)
        {
            RichPresenceNotificationData result = new RichPresenceNotificationData();
            if (notificationSubData.data == null || notificationSubData.data.Length == 0)
            {
                Global.RO.Warn("Rich Notification with Null data received.");
                return result;
            }

            RichPresenceData richPresence = new RichPresenceData();
            richPresence.ReadBytes((byte[])notificationSubData);
            result.RichPresenceStringLength = (ushort)richPresence.sRichPresence.Length;
            result.RichPresenceString = richPresence.sRichPresence;

            return result;
        }

    }
    public class FriendsListNotificationData
    {
        public uint ListVersion = 0;
        public uint NumUsers = 0;
        public UserData[] userData;

        public static FriendsListNotificationData Get(SUBSCRIPTION_DATA notificationSubData)
        {
            FriendsListNotificationData result = new FriendsListNotificationData();
            if (notificationSubData.data == null || notificationSubData.data.Length == 0)
            {
                Global.RO.Warn("FriendsList Notification with Null data received.");
            }
            UserListData ulData = new UserListData(DATA_TYPES.eFriendsList);
            ulData.ReadBytes((byte[])notificationSubData);
            
            result.ListVersion = ulData.dwListVersion;
            result.NumUsers = ulData.dwNumUsers;
            result.userData = ulData.rgUsers;

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNQValConditionalWaitState.cs ===
using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace ServerTestFramework.LiveService.Presence
{
	/// <summary>
	/// Create a multi-value wait state where all conditions must be
	/// met for the wait to complete.
	/// </summary>
	public  partial class PNConditionalWaitState
	{
		/// <summary>
		/// Condition class that wraps a qflag change on a user. This condition
		/// will be satisified when that qflag is delivered to the user.
		/// </summary>
		protected class QFlagCondition  : Condition
		{
			public uint QFlagMask;
            public DATA_TYPES NotificationType;

			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder().Append(
						"QFlagCondition: Source: ").Append(
						Source.UserId.ToString("x")).Append(
						", Target: ").Append(
						Target.UserId.ToString("x")).Append(
						", QFlags: ").Append(
						QFlagMask.ToString("x8")).Append(
						", Active: ").Append(
						Active);

				return buffer.ToString();
			}

            public override bool CheckNotification(UserNotification noti)
            {
                bool check = false;
                switch (noti.NotificationDataType)
                {
                    case DATA_TYPES.eAvatar:
                        break;
                    case DATA_TYPES.eBasicPresence:
                        {
                            PNUser.BuddyInfo buddyInfo = Target.GetBuddyInfo(Source.UserId);
                            check = (null != buddyInfo) && (noti.SubscriptionData.data != null);

                            // Check peers fallthrough
                            if (!check)
                            {
                                PNUser.PeerInfo peerInfo = Target.GetPeerInfo(Source.UserId);
                                check = (null != peerInfo) && (noti.SubscriptionData.data != null);
                            }

                            break;
                        }
                    case DATA_TYPES.eBasicProfile:
                        break;
                    case DATA_TYPES.eConnSrvLocation:
                        break;
                    case DATA_TYPES.eExtendedPresence:
                        break;
                    case DATA_TYPES.eExtendedProfile:
                        break;
                    case DATA_TYPES.eFriendsList:
                        break;
                    case DATA_TYPES.ePartyInfo:
                        break;
                    case DATA_TYPES.eRichPresenceString:
                        {
                            PNUser.BuddyInfo buddyInfo = Target.GetBuddyInfo(Source.UserId);
                            check = (null != buddyInfo) && (noti.SubscriptionData.data != null);

                            // Check peers fallthrough
                            if (!check)
                            {
                                PNUser.PeerInfo peerInfo = Target.GetPeerInfo(Source.UserId);
                                check = (null != peerInfo) && (noti.SubscriptionData.data != null);
                            }

                            break;
                        }

                    default:
                        break;
                }

                if (check)
                {
                    Global.RO.Debug("Matched Notification: 0x{0:x} for Source: {1:x}, Target: {2:x}",
                            noti.NotificationDataType.ToString(), Source.UserId, Target.UserId);
                }

                return check;
                
            }

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check = false;
				if((qval.QFlags & QFlagMask) != 0)
				{
					// See if the correct target user was dequeued
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_BUDDY_REQ))
					{
						PNUser.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = ((null != info) && (XonPresNoti.P_BUDDY_STATUS_PENDING == info.Status));
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_LIST_CHANGE))
					{
						PNUser.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = (null != info); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PRESENCE))
					{
						PNUser.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = (null != info) ; //&& (null != info.Presence); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_INVITE))
					{
						PNUser.InvitationInfo info = Target.GetInvitationInfo(Source.UserId);
						check = (null != info) && (null != info.Invitation);
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_INVITE_ANSWER))
					{
						PNUser.InvitationInfo info = Target.GetInvitationInfo(Target.UserId);
						check = (null != info) && (info.InvitationAnswers.ContainsKey(Source.UserId));
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PEER_PRESENCE))
					{
						PNUser.PeerInfo info = Target.GetPeerInfo(Source.UserId);
						check = (null != info);// && (null != info.PeerPresence); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PRESENCE_2))
					{
						PNUser.BuddyInfo buddyInfo = Target.GetBuddyInfo(Source.UserId);
						check = (null != buddyInfo) && (buddyInfo.RichPresenceData != null); 

						// Check peers fallthrough
						if(!check)
						{
							PNUser.PeerInfo peerInfo = Target.GetPeerInfo(Source.UserId);
							check = (null != peerInfo) && (null != peerInfo.RichPresenceData); 
						}
					}
				}

				if(check)
				{
					Global.RO.Debug("Matched QFlagMask: 0x{0:x} for Source: {1:x}, Target: {2:x}", 
							qval.QFlags, Source.UserId, Target.UserId);
				}

				return check;
			}
		}

		/// <summary>
		/// Condition class that wraps a messaging qval change.
		/// will be satisified when that qval data is delivered to the user.
		/// </summary>
		protected class MessagingCondition : Condition
		{
			public uint DataFlags;
			public uint MsgType;

            public override bool CheckNotification(UserNotification noti)
            {
                throw new Exception("Call Check with Qval");
            }
			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder();

                buffer.Append("MessagingCondition: Source: ");
                buffer.Append(Source.UserId.ToString("x"));

                buffer.Append(", Target: ");
                buffer.Append(Target.UserId.ToString("x"));

                buffer.Append(", DataFlags: ");
                buffer.Append(DataFlags.ToString("x8"));

                buffer.Append(", MsgType: ");
                buffer.Append(MsgType.ToString("x2"));

                buffer.Append(", Active: ");
                buffer.Append(Active);

				return buffer.ToString();
			}

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check   = false;
				uint msgId   = 0;
				uint msgData = 0;

				PNUser.MessageInfo []rgInfo = Target.GetMessageInfoFrom(Source);
				foreach(PNUser.MessageInfo info in rgInfo)
				{
					// Check the found item from the sender
					// and the dataflags specified match
					if(    (0 == DataFlags || DataFlags == (info.Data & DataFlags)) 
						&& (0 == MsgType || ((info.Data >> 24 & 0xff) == MsgType))
						&& (null == info.Message || info.Message.SenderID == Source.UserId))
					{
						check    = true;
						msgId    = info.Id;
						msgData  = info.Data;
					}
				}

				if(check)
				{
					Global.RO.Debug("Matched MsgId: {0:x}, MsgData: {1:x}, Source: {2:x}, Target: {3:x}", 
							msgId,
							msgData,
							Source.UserId,
							Target.UserId);
				}

				return check;
			}
		}

		/// <summary>
		/// Condition class that wraps a deleted message qval change.
		/// will be satisified when that qval data is delivered to the user.
		/// </summary>
		protected class DeletedMessagingCondition : Condition
		{
			public uint MsgId;

			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder().Append(
						"DeletedMessagingCondition: Source: ").Append(
						Source.UserId.ToString("x")).Append(
						", Target: ").Append(
						Target.UserId.ToString("x")).Append(
						", MsgId: ").Append(
						MsgId.ToString("x8")).Append(
						"Active: ").Append(
						Active);

				return buffer.ToString();
			}

            public override bool CheckNotification(UserNotification noti)
            {
                throw new Exception("Call Check with Qval");
            }

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check   = false;
				uint msgId   = 0;
				uint msgData = 0;

				PNUser.MessageInfo []rgInfo = Target.GetMessageInfoFrom(Source);
				foreach(PNUser.MessageInfo info in rgInfo)
				{
					// Match message ID, ensure message has been marked deleted
					// by deleted message qval and if the message has been retrieved
					// check that the source ID matches
					if(info.Id == MsgId && true == info.Deleted && (null != info.Message || info.Message.SenderID == Source.UserId))
					{
						check    = true;
						msgId    = info.Id;
						msgData  = info.Data;
					}
				}

				if(check)
				{
					Global.RO.Debug("Matched Deleted MsgId: {0:x}, MsgData: {1:x}, Source: {2:x}, Target: {3:x}", 
							msgId,
							msgData,
							Source.UserId,
							Target.UserId);
				}

				return check;
			}
		}

		/// <summary>
		/// Add a new required qflag that should arive based on the action of 
		/// a certain sender.
		/// </summary>
		/// <param name="qFlagMask">Bits to wait on, usually this will be a single bit. See XonPresNoti for bit definitions.</param>
		/// <param name="sender">Initiator of the action.</param>
		public void AddRequiredQFlag(uint qFlagMask, PNUser source, PNUser target)
		{
			QFlagCondition cond = new QFlagCondition();
			cond.Source = source;
			cond.Target = target;
			cond.QFlagMask = qFlagMask;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required messaging qval that should arive based on the action
		/// of the sender. Match the type of the message.
		/// </summary>
		public void AddRequiredMessageType(uint msgType, PNUser source, PNUser target)
		{
			MessagingCondition cond = new MessagingCondition();
			cond.Source    = source;
			cond.Target    = target;
			cond.MsgType   = msgType;
			cond.DataFlags = 0;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required messaging qval that should arive based on the action
		/// of the sender. Match the data flags in the message
		/// </summary>
		public void AddRequiredMessageData(uint dataFlags, PNUser source, PNUser target)
		{
			MessagingCondition cond = new MessagingCondition();
			cond.Source    = source;
			cond.Target    = target;
			cond.MsgType   = 0;
			cond.DataFlags = dataFlags;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required deleted messaging qval that should arive based on the action
		/// of the sender.
		/// </summary>
		public void AddRequiredDeletedMessageId(uint msgId, PNUser source, PNUser target)
		{
			DeletedMessagingCondition cond = new DeletedMessagingCondition();
			cond.Source = source;
			cond.Target = target;
			cond.MsgId = msgId;
			_Conditions.Add(cond);
		}

        public void WaitOnQValConditions()
        {
            WaitOnQValConditions(false);
        }

        public void WaitOnQValConditions(bool ErrorOnUnexpectedQval)
		{
			DateTime abortTime = DateTime.Now.AddSeconds(MaxTimeout);
			ProgressInfo progress = new ProgressInfo("Waiting on conditions", (uint)_Conditions.Count, 1);

			Global.RO.Debug("PNConditionalWaitState.WaitOnConditions(): begin wait duration {0} seconds", MaxTimeout);

			if(0 == _Conditions.Count)
			{
				Global.RO.Warn("WaitOnConditions(): No conditions have been set.");
				goto lbDone;
			}

			Hashtable targetsHash = new Hashtable();
			ArrayList toRemove = new ArrayList();
			uint activeCount = 0;

			// Mark all conditions active and collect the set 
			// of all targets hashed to target ID
			foreach(Condition cond in _Conditions)
			{
				// Mark condition active cond.Active = true;
				activeCount++;
				cond.Active = true;
				
				// Hang array of conditions off of target ID in hash
				ArrayList conditions = (ArrayList)targetsHash[cond.Target.UserId];
				if(null == conditions)
				{
					conditions = new ArrayList();
					targetsHash[cond.Target.UserId] = conditions;
				}
				conditions.Add(cond);
				Global.RO.Debug("PNConditionalWaitState.WaitOnConditions(): added condition: {0}", cond.ToString());
			}
			
			try
			{
				ArrayList targetsHashToRemove = new ArrayList();

                while(activeCount > 0 && abortTime > DateTime.Now)
				{
                    // Poll qvals for all target users
					QValPacket qval = null;

					targetsHashToRemove.Clear();

					// Loop over each distinct target type
					IDictionaryEnumerator enumerator = targetsHash.GetEnumerator();
					while(enumerator.MoveNext())
					{
						ulong targetId        = (ulong)enumerator.Key; 
						ArrayList conditions  = enumerator.Value as ArrayList;

						// Get the first condition and the target for group of conditions
						PNUser target = (conditions[0] as Condition).Target;

						
						// First check for and process any qvals on target
						if(target.Xbox.ReadUserQValPacket(target.UserId, out qval))
						{
							Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): processing packet: QVal: 0x{0:x8}, QFlags: 0x{1:x8} ({2}), Ids: ({3:x}, {4:x}, {5:x}), Data: ({6:x}, {7:x}, {8:x}), Deleted: ({9:x}, {10:x}, {11:x})", 
										qval.QVal, 
										qval.QFlags, 
										XonPresNoti.BuildQFlagsString(qval.QFlags),
										qval.NewMessageId(0),
										qval.NewMessageId(1),
										qval.NewMessageId(2),
										qval.NewMessageData(0),
										qval.NewMessageData(1),
										qval.NewMessageData(2),
										qval.DeletedMessageId(0),
										qval.DeletedMessageId(1),
										qval.DeletedMessageId(2));

							target.HandleQValPacket(qval);

							// Process the conditions linked to target
							foreach(Condition cond in conditions)
							{
								if(cond.Check(qval))
								{
									cond.Active = false;
									activeCount--;
									toRemove.Add(cond);
									progress.Step();
									Global.RO.Debug("PNConditionalWaitState.WaitForConditions(): matched cond: {0}", cond.ToString());
								}
							}

							if(toRemove.Count > 0)
							{
								// Remove the matched conditions
								foreach(Condition cond in toRemove)
								{
									conditions.Remove(cond);
								}

								// Clear conditions to remove array
								toRemove.Clear();
							}
                            else if (ErrorOnUnexpectedQval)
                            {
                                throw new UnexpectedTestResultException(String.Format("QVal received by User {0} did not match any conditions.", target.UserId));
                            }
						
						} // end qval read

						// Satisfied all of this targets conditions, make for removal
						// and go to next item.
						if(0 == conditions.Count)
						{
							targetsHashToRemove.Add(targetId);
						}
					} // End target hash loop

					// Process any removal targets from the target hash (this cannot be done
					// while using collection enumeration so we do it out of the while loop
					// here.)
					//
					foreach(UInt64 targetId in targetsHashToRemove)
					{
						targetsHash.Remove(targetId);
					}

					Thread.Sleep(PNUser.QValPollingInterval);
				} // End active timeout loop
			} 
			catch(Exception)
			{
				// Log uncaught conditions and re-throw
				progress.Finish();
				Global.RO.Error("PNConditionalWaitState.WaitForConditions(): unexpected exception, current state: \n" + this.ToString());
				throw;
			}

			// Catch timeout condition
			if(activeCount > 0 && abortTime < DateTime.Now)
			{
				progress.Finish();
				throw new TimeOutException((ushort)MaxTimeout, "Timed out waiting on conditions:\n" + this.ToString());
			}

lbDone:
			// Normal or early exit
			progress.Finish();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\QueryAndLsp\XRLLspAdvertise.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.QueryAndLsp
{
    public class LspProtocolConstants
    {
        public const uint XONLINE_LSP_MAX_USER_DATA_LEN         = 200;
        public const uint XONLINE_LSP_MAX_LSP_INFO              = 1000;
        public const uint XONLINE_LSP_XNKID_LEN                 = 8;
        public const uint XONLINE_LSP_XNKEY_LEN                 = 16;
        public const uint XONLINE_LSP_MAX_EXPIRATION_SECONDS    = 100000;
        public const uint XONLINE_LSP_DEFAULT_DATASET           = 0xAAAA;
        public const uint XONLINE_LSP_ATTR_TSADDR               = 0x80200001;
        public const uint XONLINE_LSP_ATTR_XNKID                = 0x80200002;
        public const uint XONLINE_LSP_ATTR_KEK                  = 0x80200003;
        public const uint XONLINE_LSP_ATTR_USER                 = 0x80100004;
        public const uint XONLINE_LSP_ATTR_PARAM_USER           = 0x02100004;
    }

    public class XRLLspAdvertiseRequest : XRLPayload
    {
        // Advertise to this titleId
        //[WireInfo(Min=1, Max=UInt32.MaxValue)]
        [XRLPayloadFld(IsTitleId=true)]
        public UInt32       titleId;
        
        // You can find me at this IP (Network byte order)
        //[WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;
        
        // Expire after this many seconds
        //[WireInfo(Min=10, Max=LspProtocolConstants.XONLINE_LSP_MAX_EXPIRATION_SECONDS)]
        public UInt32       ttlInSeconds;

        // Reserved. Zero for now.
        //[WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       flags;

        // XNKID for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKID_LEN)]
        public byte[]       xnkid;

        // XNKEY for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKEY_LEN)]
        public byte[]       xnkey;

        // Length in bytes for user data (it's UTF8 encoded)
        //[WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN * XOn.UTF8_MULT)]
        public ushort       userDataLength;

        // User data.
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

		private string serviceName = "/lsp/advertise.ashx";
		public string ServiceName {
			get { return serviceName; }
			set { serviceName = value; }
		}

        protected override string GetServiceName()
        {
            return serviceName;
        }

        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xqry_int));
        }

        protected override void SetServices()
        {
            base.SetServices ();
            Slot.AddService(XOService.Query);
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\XonPresNoti.cs ===
// XonPresNoti.cs
//
//  Duplication of constants found in Presence and Notification
//  sectoin of Xonlinep.h
//
//  NOTE: Does not include internal constants not usefull for testing purposes.

using System;


namespace ServerTestFramework.LiveService.PresNotiCommon
{
    //////////////////////////////////////
    // XonPresNoti
    //
    //  Container for constants
    //
    public class XonPresNoti
    {
        // XPNF Service Urls
        // -----------------
        public static readonly string PRESENCE_URL    = "/xpnfront/xpresence.srf";
        public static readonly string NOIFICATION_URL = "/xpnfront/xnotification.srf";
        public static readonly string TEAMS_URL       = "/xpnfront/xteams.srf";
        public static readonly string MESSAGING_URL   = "/xpnfront/xmessaging.srf";
        public static readonly string STATE_URL       = "/xpnfront/state.ashx";

        // Current protocol versions
        // -------------------------
        public const uint   CURRENT_XPPROTOCOL_VER = 0x00010000; // v1.0
        public const ushort PresProt_VER_MAJOR = 1;
        public const ushort PresProt_VER_MINOR = 0;

        // Current service versions
        // ------------------------
        public const uint   PRESENCE_SERVICE_VER = 0x00010000; //  1 = XONLINE_PRESENCE_SERVICE
        public const ushort PresServ_VER_MAJOR = 1;
        public const ushort PresServ_VER_MINOR = 0;
        public const uint MESSAGING_SERVICE_VER  = 0x00010000; // 18 = XONLINE_MESSAGING_SERVICE
        public const ushort MessServ_VER_MAJOR = 1;
        public const ushort MessServ_VER_MINOR = 0;
        public const uint TEAM_SERVICE_VER       = 0x00010000; // 19 = XONLINE_TEAM_SERVICE
        public const ushort TeamServ_VER_MAJOR = 1;
        public const ushort TeamServ_VER_MINOR = 0;

        // Presence Message Types (IDs)
        // ----------------------------
        // ... Incoming
        public const uint PMSG_HELLO              = 1000;
        public const uint PMSG_ALIVE              = 1001;
        public const uint PMSG_SYNC               = 1002;
        public const uint PMSG_REFRESH            = 1003;
        public const uint PMSG_ADD                = 1004;
        public const uint PMSG_DELETE             = 1005;
        public const uint PMSG_ACCEPT             = 1006;
        public const uint PMSG_REJECT             = 1007;
        public const uint PMSG_BLOCK              = 1008;
        public const uint PMSG_UNBLOCK            = 1009;
        public const uint PMSG_INVITE             = 1010;
        public const uint PMSG_CANCEL             = 1011;
        public const uint PMSG_INVITE_ANSWER      = 1012;
        public const uint PMSG_NICKNAME           = 1013;
        public const uint PMSG_STATE              = 1014;
        public const uint PMSG_DEAD_XBOX          = 1015;
        public const uint PMSG_DEAD_SG            = 1016;
        public const uint PMSG_DEAD_USER          = 1024;
        public const uint PMSG_ALIVE_2            = 1025;
        public const uint PMSG_WEB_FRIENDS        = 1026;
        public const uint PMSG_WEB_ALIVE          = 1027;
        public const uint PMSG_PEER_SESSION       = 1031;
        public const uint PMSG_TEAM_LIST_TEAMS    = 1032;
        public const uint PMSG_TEAM_LIST_MEMBERS  = 1033;
        public const uint PMSG_TEAM_CREATE        = 1034;
        public const uint PMSG_TEAM_DELETE        = 1035;
        public const uint PMSG_TEAM_REMOVE        = 1036;
        public const uint PMSG_TEAM_MANAGE_TEAM   = 1037;
        public const uint PMSG_TEAM_MANAGE_MEMBER = 1038;
        public const uint PMSG_TEAM_RECRUIT       = 1039;
        public const uint PMSG_TEAM_JOIN          = 1040;
        public const uint PMSG_TEAM_GET_TICKET    = 1041;
        public const uint PMSG_PEER_SUBSCRIBE     = 1042;
        public const uint PMSG_PEER_UNSUBSCRIBE   = 1043;
        public const uint PMSG_WATCH_START        = 1044;
        public const uint PMSG_WATCH_STOP         = 1045;
        public const uint PMSG_ADD_2              = 1046;
        public const uint PMSG_INVITE_2           = 1047;
        public const uint PMSG_ALIVE_INTERNAL     = 1048;
        public const uint PMSG_STATE_2            = 1049;
        public const uint PMSG_GET_STATE          = 1050;
        public const uint PMSG_TEAM_CREATE_TEAM_XE= 1051;
        public const uint PMSG_TEAM_MANAGE_TEAM_XE= 1052;
        public const uint PMSG_ADD_AFFILIATES     = 1053;
        public const uint PMSG_IS_AFFILIATE       = 1054;
        public const uint PMSG_QUERY_AFFILIATES         = 1055;
        public const uint PMSG_GET_PRESENCE_INFO        = 1056;
        public const uint PMSG_PRESENCE_INFO_REPLY             = 1057;
        public const uint PMSG_INVALIDATE_USER          = 1058;
        public const uint PMSG_FIND_USER                = 1059;
        public const uint PMSG_CHECK_TITLE_MESSAGES     = 1060;
        public const uint PMSG_TEAM_LIST_USER_TEAMS     = 1061;
        public const uint PMSG_USER_PRE_MIGRATION            = 1062;
        public const uint PMSG_USER_FULL_MIGRATION           = 1063;
        public const uint PMSG_LOGON_CHECK                   = 1064;
        public const uint PMSG_FIND_USERS                    = 1065;
        public const uint PMSG_ALIVE_INTERNAL_2              = 1066;
        public const uint PMSG_PEER_SUBSCRIBE_EX             = 1067;
        public const uint PMSG_PURGE_USER                    = 1068;
        public const uint PMSG_GET_FRIENDS_LIST              = 1069;
        public const uint PMSG_WEB_ALIVE2                    = 1075;
        public const uint PMSG_FRIENDSLIST_NO_PRECENSE  = 1076;
        public const uint PMSG_FRIENDSLIST_LIMITED_PRECENSE  = 1077;

        // ... Outgoing
        public const uint PMSG_ALIVE_REPLY              = 1101;
        public const uint PMSG_SYNC_REPLY               = 1102;
        public const uint PMSG_WEB_FRIENDS_REPLY        = 1103;
        public const uint PMSG_WEB_ALIVE_REPLY          = 1104;
        public const uint PMSG_PEER_SESSION_REPLY       = 1105;
        public const uint PMSG_INVITE_REPLY             = 1106;
        public const uint PMSG_TEAM_LIST_TEAMS_REPLY    = 1107;
        public const uint PMSG_TEAM_LIST_MEMBERS_REPLY  = 1108;
        public const uint PMSG_TEAM_CREATE_REPLY        = 1109;
        public const uint PMSG_TEAM_DELETE_REPLY        = 1110;
        public const uint PMSG_TEAM_REMOVE_REPLY        = 1111;
        public const uint PMSG_TEAM_MANAGE_TEAM_REPLY   = 1112;
        public const uint PMSG_TEAM_MANAGE_MEMBER_REPLY = 1113;
        public const uint PMSG_TEAM_RECRUIT_REPLY       = 1114;
        public const uint PMSG_TEAM_JOIN_REPLY          = 1115;
        public const uint PMSG_TEAM_GET_TICKET_REPLY    = 1116;
        public const uint PMSG_PEER_SUBSCRIBE_REPLY     = 1117;
        public const uint PMSG_PEER_UNSUBSCRIBE_REPLY   = 1118;
        public const uint PMSG_GET_STATE_REPLY          = 1119;
        public const uint PMSG_IS_AFFILIATE_REPLY       = 1120;
        public const uint PMSG_QUERY_AFFILIATES_REPLY   = 1121;
        public const uint PMSG_FIND_USER_REPLY          = 1122;
        public const uint PMSG_CHECK_TITLE_MESSAGES_REPLY= 1123;
        public const uint PMSG_TEAM_LIST_USER_TEAMS_REPLY = 1124;
        public const uint PMSG_LOGON_CHECK_REPLY             = 1125;
        public const uint PMSG_FIND_USERS_REPLY              = 1126;
        public const uint PMSG_PEER_SUBSCRIBE_EX_REPLY       = 1127;
        public const uint PMSG_PURGE_USER_REPLY              = 1128;
        public const uint PMSG_GET_FRIENDS_LIST_REPLY        = 1129;
        public const uint PMSG_GET_FRIENDS_NO_PRESENCE_REPLY = 1132;
        public const uint PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY = 1133;

        // Notification Message Types (IDs)
        // --------------------------------
        // ... Incoming
        public const uint QMSG_HELLO                  = 0;
        public const uint QMSG_USER_INFO              = 1;
        public const uint QMSG_ADD                    = 2;
        public const uint QMSG_DELETE                 = 3;
        public const uint QMSG_DELETE_MATCHES         = 4;
        public const uint QMSG_DEAD_XBOX              = 5;
        public const uint QMSG_DEAD_SG                = 6;
        public const uint QMSG_LIST                   = 7;
        public const uint QMSG_DEQUEUE                = 8;
        public const uint QMSG_DEAD_USER              = 9;
        public const uint QMSG_WEB_USER_INFO          = 10;
        public const uint QMSG_WEB_PRESENCE           = 11;
        public const uint QMSG_WEB_LIST               = 12;
        public const uint QMSG_ENUM_MESSAGES          = 13;
        public const uint QMSG_MESSAGE_SUMMARY        = 14;
        public const uint QMSG_MESSAGE_DETAILS        = 15;
        public const uint QMSG_DELETE_MESSAGE         = 16;
        public const uint QMSG_SEND_MESSAGE           = 17;
        public const uint QMSG_REVOKE_MESSAGE         = 18;
        public const uint QMSG_DELETE_TITLE           = 19;
        public const uint QMSG_ENUM_TITLES            = 20;
        public const uint QMSG_MESSAGE_FLAGS          = 21;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES   = 22;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS = 23;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE  = 24;
        public const uint QMSG_SEND_SYSTEM_MESSAGE    = 25;
        public const uint QMSG_REVOKE_MESSAGE_EX      = 26;
        public const uint QMSG_ENUM_MESSAGES_2        = 27;
        public const uint QMSG_MESSAGE_SUMMARY_2      = 28;

        // ... Outgoing
        public const uint QMSG_LIST_REPLY                   = 100;
        public const uint QMSG_WEB_LIST_REPLY               = 101;
        public const uint QMSG_ENUM_MESSAGES_REPLY          = 102;
        public const uint QMSG_MESSAGE_SUMMARY_REPLY        = 103;
        public const uint QMSG_MESSAGE_DETAILS_REPLY        = 104;
        public const uint QMSG_DELETE_MESSAGE_REPLY         = 105;
        public const uint QMSG_SEND_MESSAGE_REPLY           = 106;
        public const uint QMSG_REVOKE_MESSAGE_REPLY         = 107;
        public const uint QMSG_DELETE_TITLE_REPLY           = 108;
        public const uint QMSG_ENUM_TITLES_REPLY            = 109;
        public const uint QMSG_MESSAGE_FLAGS_REPLY          = 110;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES_REPLY   = 111;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS_REPLY = 112;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE_REPLY  = 113;
        public const uint QMSG_SEND_SYSTEM_MESSAGE_REPLY    = 114;
        public const uint QMSG_ENUM_MESSAGES_2_REPLY        = 115;
        public const uint QMSG_MESSAGE_SUMMARY_2_REPLY      = 116;
        public const uint QMSG_LIST_REPLY_2                 = 117;

        // Misc protocol related constants
        // --------------------------------
        // ... Max Sizes
        public const uint MAX_HELLO_DESCRIPTION_LEN  = 80;
        public const uint MAX_ACCTNAME_BYTES         = 16; // XONLINE_GAMERTAG_SIZE
        public const uint MAX_NICKNAME_BYTES         = 24;
        public const uint MAX_TITLE_STATE_BYTES      = 32;
        public const uint MAX_TITLE_DATA_BYTES       = 256;
        public const uint MAX_NOT_TITLE_STATE_BYTES  = 8;  // Constants for spliting state
        public const uint MAX_NOT_NICKNAME_BYTES     = 24; //   into the old notification message
        public const uint MAX_BUDDIES                = 100;
        public const uint MAX_BLOCKS                 = 250;
        public const uint MAX_PEER_SUBSCRIPTIONS     = 1000;
        public const uint MAX_NUM_MESSAGES           = 125;
        public const uint MAX_MESSAGE_RECIPIENTS     = 100;
        public const uint MAX_MESSAGE_DETAILS        = 4096;
        public const uint MAX_RETURNED_USER_TITLES   = 100; // max that QMSG_ENUM_TITLES will return
        public const uint MAX_RETURNED_SYSTEM_MSGS   = 100; // max that QMSG_ENUM_SYSTEM_MESSAGES will return
        public const uint MAX_TRANSIENT_MESSAGES     = 25;
        public const uint MAX_PERSISTENT_MESSAGES    = 100;
        public const uint MAX_TOTAL_USER_MESSAGES    = (MAX_TRANSIENT_MESSAGES + MAX_PERSISTENT_MESSAGES);
        public const uint MAX_SYSTEM_MSG_DESC_LEN    = 64;
        public const uint MAX_TEAM_COUNT             = 8;
        public const uint MAX_TEAM_RECRUIT_COUNT     = 100;
        public const uint MAX_TEAM_MEMBER_COUNT      = 64;
        public const uint MIN_MAX_TEAM_MEMBER_COUNT  = 2;
        public const uint MAX_TEAM_NAME_SIZE         = 16;
        public const uint MAX_TEAM_NAME_BYTES        = 32;
        public const uint MAX_TEAM_DESCRIPTION_SIZE  = 256;
        public const uint MAX_TEAM_DESCRIPTION_BYTES = 512;
        public const uint MAX_TEAM_MOTTO_SIZE        = 256;
        public const uint MAX_TEAM_MOTTO_BYTES       = 512;
        public const uint MAX_TEAM_URL_SIZE          = 256;
        public const uint MAX_TEAM_URL_BYTES         = 512;
        public const uint MAX_TEAM_DATA_SIZE         = 100;
        public const uint MAX_TEAM_MEMBER_DATA_SIZE  = 100;
        public const uint MAX_SUBJECT_SIZE           = 20;
        // ... Invites expire after 1-day
        public const uint INVITE_EXPIRATION_MINUTES = 1440;
        // ... Friend requests and Team recruits expire after 30 days
        public const uint FRIEND_REQUEST_EXPIRATION_MINUTES  = 43200;
        public const uint TEAM_RECRUIT_EXPIRATION_MINUTES    = 43200;
        // ... Invalid Match Session ID
        public const ulong IGNOREME_SESSID = 0;
        // ... Common Ack Message Type (ID)
        public const uint MSGTYPE_ACK = 0xffffffff;
        // ... Flag to block a sender when deleting a message
        public const uint DELETE_MESSAGE_FLAG_BLOCK_SENDER = 0x00000001;
        // ... Flags for Revoke Ex messages
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID       = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER   = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT  = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP     = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE     = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED    = 0xFFFFFFC0;
        // ... Flag to clean our user queues as well when deleting a system message
        public const uint DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL = 0x00000001;
        // ... Flag that user has opted in to marketing for a title when enrumerating titles
        public const uint USER_TITLE_FLAG_ACCEPT_MARKETING = 0x00000001;

        /// <summary>
        /// Gets the default expiration time, in minutes, for the given message type
        /// </summary>
        /// <param name="bMsgType">Message type</param>
        /// <returns>Default expiration time, in minutes</returns>
        public static uint GetDefaultExpirationForMsgType(byte bMsgType)
        {
            switch (bMsgType)
            {
                // 30 days
                case MSG_TYPE_TITLE_CUSTOM:
                case MSG_TYPE_FRIEND_REQUEST:
                case MSG_TYPE_TEAM_RECRUIT:
                case MSG_TYPE_LIVE_MESSAGE:
                case MSG_TYPE_PERSONAL_MESSAGE:
                case MSG_TYPE_VIDEO_MESSAGE:
                    return 43200;

                // 1 day
                case MSG_TYPE_GAME_INVITE:
                case MSG_TYPE_COMP_REMINDER:
                case MSG_TYPE_QUICK_CHAT_INVITE:
                case MSG_TYPE_VIDEO_CHAT_INVITE:
                case MSG_TYPE_PARTY_CHAT_INVITE:
                    return 1440;

                // 7 days
                case MSG_TYPE_COMP_REQUEST:
                    return 10080;

                default:
                    return 0;
            }
        }

        // Presence State Masks
        // --------------------
        public const uint P_STATE_MASK_NONE                         = 0x00000000;
        public const uint P_STATE_MASK_ONLINE                       = 0x00000001;
        public const uint P_STATE_MASK_PLAYING                      = 0x00000002;
        public const uint P_STATE_MASK_CLOAKED                      = 0x00000004;
        public const uint P_STATE_MASK_VOICE                        = 0x00000008;
        public const uint P_STATE_MASK_JOINABLE                     = 0x00000010;
        public const uint P_STATE_MASK_GUESTS                       = 0x00000060;
        public const uint P_STATE_MASK_RESERVED0                    = 0x00000080;
        public const uint P_STATE_MASK_JOINABLE_FRIENDS_ONLY        = 0x00000100;
        public const uint P_STATE_MASK_PARTY_JOINABLE               = 0x00000200;
        public const uint P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY  = 0x00000400;
        public const uint P_STATE_MASK_PARTY_PLAYING                = 0x00000800;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;

        // console types
        public const uint P_STATE_MASK_CONSOLE_TYPE        = 0x00007000;
        public const uint P_STATE_ENUM_CONSOLE_XBOX        = 0x00000000;
        public const uint P_STATE_ENUM_CONSOLE_XENON       = 0x00001000;
        public const uint P_STATE_ENUM_CONSOLE_WINPC       = 0x00002000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD1       = 0x00003000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD2       = 0x00004000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD3       = 0x00005000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD4       = 0x00006000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD5       = 0x00007000;

        public const uint P_STATE_MASK_PARTY_COUNTER       = 0x00300000;

        public const uint P_STATE_MASK_SENTREQUEST     = 0x40000000;
        public const uint P_STATE_MASK_RECEIVEDREQUEST = 0x80000000;

        // Buddy Status
        // ------------
        public const byte NOT_A_BUDDY            = 0xff;
        public const byte P_BUDDY_STATUS_OK      = 0;  // Mutualy accepted buddy
        public const byte P_BUDDY_STATUS_PENDING = 1;  // Buddy request pending acceptance
        public const byte P_BUDDY_STATUS_REQUEST = 2;  // Buddy request to accept or reject
        public const byte P_BUDDY_STATUS_ACCEPTED = 3; // Client only status to avoid multiple accepts


        /// <summary>
        /// Get the friendly name for a buddy status byte
        /// </summary>
        public static string BuddyStatusToString(byte status)
        {
            switch(status)
            {
                case NOT_A_BUDDY:
                    return "NotABuddy";
                case P_BUDDY_STATUS_OK:
                    return "BuddyOk";
                case P_BUDDY_STATUS_PENDING:
                    return "BuddyPending";
                case P_BUDDY_STATUS_REQUEST:
                    return "BuddyRequested";
                default:
                    return "Unknown";
            }
        }

        // Invitation Replies
        // ------------------
        public const ushort PINVITE_REPLY_NO    = 0;
        public const ushort PINVITE_REPLY_YES   = 1;
        public const ushort PINVITE_REPLY_NEVER = 2;

        // Generic Reply Values
        // ------------------
        public const byte REPLY_NO    = 0;
        public const byte REPLY_YES   = 1;
        public const byte REPLY_NEVER = 2;

        // Team Member Privliges
        // ---------------------
        public const uint TEAM_DELETE                    = 0x00000001;
        public const uint TEAM_MODIFY_DATA               = 0x00000002;
        public const uint TEAM_MODIFY_MEMBER_PERMISSIONS = 0x00000004;
        public const uint TEAM_DELETE_MEMBER             = 0x00000008;
        public const uint TEAM_RECRUIT_MEMBERS           = 0x00000010;
        public const uint TEAM_LIVE_PERMISSIONS_FORCE_DWORD = 0xFFFFFFFF;

        // Notification Queue Types and Masks
        // ----------------------------------
        // ... Request IDs
        public const ushort PQUEUE_BUDDY_REQ      = 0;
        public const ushort PQUEUE_LIST_CHANGE    = 1;
        public const ushort PQUEUE_PRESENCE       = 2;
        public const ushort PQUEUE_INVITE         = 3;
        public const ushort PQUEUE_INVITE_ANSWER  = 4;
        public const ushort PQUEUE_TRANSIENT_MSGS = 5;
        public const ushort PQUEUE_PEER_PRESENCE  = 6;
        public const ushort PQUEUE_PRESENCE_2     = 7;


        /// <summary>
        /// Get the friendly name for a presence QType ID
        /// </summary>
        public static string QTypeToString(uint qType)
        {
            switch(qType)
            {
                case PQUEUE_BUDDY_REQ:
                    return "BuddyRequest";
                case PQUEUE_LIST_CHANGE:
                    return "ListChange";
                case PQUEUE_PRESENCE:
                    return "Presence";
                case PQUEUE_INVITE:
                    return "Invite";
                case PQUEUE_INVITE_ANSWER:
                    return "InviteAnswer";
                case PQUEUE_TRANSIENT_MSGS:
                    return "TransientMessages";
                case PQUEUE_PEER_PRESENCE:
                    return "PeerPresence";
                case PQUEUE_PRESENCE_2:
                    return "RichPresence";
                default:
                    return "Unknown";
            }
        }

        // ... Qflag Masks
        public const uint QFLAG_MASK_BUDDY_REQ      = 0x00000001;
        public const uint QFLAG_MASK_LIST_CHANGE    = 0x00000002;
        public const uint QFLAG_MASK_PRESENCE       = 0x00000004;
        public const uint QFLAG_MASK_INVITE         = 0x00000008;
        public const uint QFLAG_MASK_INVITE_ANSWER  = 0x00000010;
        public const uint QFLAG_MASK_TRANSIENT_MSGS = 0x00000020;
        public const uint QFLAG_MASK_PEER_PRESENCE  = 0x00000040;
        public const uint QFLAG_MASK_PRESENCE_2     = 0x00000080;
        public const uint QFLAG_MASK_ANY            = 0x000000FF;

        /// <summary>
        /// Build a string representation of a qflags bit set
        /// </summary>
        public static string BuildQFlagsString(uint flags)
        {
            string strFlags = "";
            if((flags & XonPresNoti.QFLAG_MASK_BUDDY_REQ) != 0)
                strFlags += "+BuddyRequest";
            if((flags & XonPresNoti.QFLAG_MASK_LIST_CHANGE) != 0)
                strFlags += "+ListChange";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE) != 0)
                strFlags += "+Presence";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE) != 0)
                strFlags += "+Invite";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE_ANSWER) != 0)
                strFlags += "+InviteAnswer";
            if((flags & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS) != 0)
                strFlags += "+TransientMsgs";
            if((flags & XonPresNoti.QFLAG_MASK_PEER_PRESENCE) != 0)
                strFlags += "+PeerPresence";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE_2) != 0)
                strFlags += "+Presence2";

            return strFlags;
        }

        // List Change Operations
        // ----------------------
        public const ushort PLIST_BUDDY_NOP    = 0;
        public const ushort PLIST_BUDDY_ADD    = 1;
        public const ushort PLIST_BUDDY_ADDED  = 2;
        public const ushort PLIST_BUDDY_ACCEPT = 3;
        public const ushort PLIST_BUDDY_REJECT = 4;
        public const ushort PLIST_BUDDY_DELETE = 5;

        /// <summary>
        /// Get the friendly name for a list change operation
        /// </summary>
        public static string ListChangeOpToString(ushort listChangeOp)
        {
            switch(listChangeOp)
            {
                case PLIST_BUDDY_NOP:
                    return "Noop";
                case PLIST_BUDDY_ADD:
                    return "BuddyAdd";
                case PLIST_BUDDY_ADDED:
                    return "BuddyAdded";
                case PLIST_BUDDY_ACCEPT:
                    return "BuddyAccept";
                case PLIST_BUDDY_REJECT:
                    return "BuddyReject";
                case PLIST_BUDDY_DELETE:
                    return "BuddyDelete";
                default:
                    return "Unknown";
            }
        }

        //
        // Affiliates
        //
        public const ushort X_ADD_AFFILIATE_MAX = 16;

        // Message IDs
        // -----------
        public const uint MSG_ID_SEND_FAILED       = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint MSG_ID_SYSTEM_MESSAGE    = 0x40000000; // A message sent by the Live service or a publisher
        public const uint MSG_ID_TRANSIENT_MESSAGE = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint MSG_ID_BASE_MASK         = 0x00FFFFFF;
        public const uint MSG_ID_RESERVED_MASK     = 0x1F000000;

        // Message Notifications
        // ---------------------
        public const uint MSG_NOTIFICATION_FLAG_SAME_TITLE         = 0x000001;
        public const uint MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     = 0x000002;
        public const uint MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND = 0x000004;
        public const uint MSG_NOTIFICATION_FLAG_HAS_VOICE          = 0x000008;
        public const uint MSG_NOTIFICATION_FLAG_HAS_TEXT           = 0x000010;
        public const uint MSG_NOTIFICATION_FLAG_ALT_TITLE          = 0x000020;
        public const uint MSG_NOTIFICATION_FLAG_TITLE_RESERVED     = 0xFF0000;
        public const uint MSG_NOTIFICATION_FLAG_RESERVED           = 0x00FFC0;

        /// <summary>
        /// Build a string representation of the messaging qval notification flags.
        /// </summary>
        public static string BuildMsgNotificationFlagsString(uint dataFlags)
        {
            string strFlags = "";

            // Pull out the type from high byte
            strFlags += "Type[" + MessageTypeToString((uint)(0xff & (dataFlags >> 24))) + "] ";

            // Pull metadata flags from flags from low 3 bytes
            strFlags += "Flags[" + (0x00ffffff & dataFlags).ToString("x8") + "] ";

            // Standard flags
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_TITLE) != 0)
                strFlags += "+SameTitle";
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_PUBLISHER) != 0)
                strFlags += "+SamePublisher";
            if((dataFlags & MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND) != 0)
                strFlags += "+FromFriend";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_VOICE) != 0)
                strFlags += "+HasVoice";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_TEXT) != 0)
                strFlags += "+HasText";
            if((dataFlags & MSG_NOTIFICATION_FLAG_ALT_TITLE) != 0)
                strFlags += "+AltTitle";

            return strFlags;
        }

        // Message Types
        // -------------
        // A message type establishes the purpose of the message and the properties that
        // are required for a message of that type.
        public const byte MSG_TYPE_TITLE_CUSTOM      = 1;  // context: title defined;    required props: title defined
        public const byte MSG_TYPE_FRIEND_REQUEST    = 2;  // context: 0;                required props: none
        public const byte MSG_TYPE_GAME_INVITE       = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte MSG_TYPE_TEAM_RECRUIT      = 4;  // context: inviting team ID; required props: none
        public const byte MSG_TYPE_COMP_REMINDER     = 5;  // context: comp event ID;    required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_EVENT_START
        public const byte MSG_TYPE_COMP_REQUEST      = 6;  // context: comp entity ID;   required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_START, MSG_PROP_COMP_REG_CLOSE
        public const byte MSG_TYPE_LIVE_MESSAGE      = 7;  // context: 0                 required props: MSG_PROP_SYSTEM_TEXT
        public const byte MSG_TYPE_PERSONAL_MESSAGE  = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte MSG_TYPE_VIDEO_MESSAGE     = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte MSG_TYPE_QUICK_CHAT_INVITE = 10; // context: 0
        public const byte MSG_TYPE_VIDEO_CHAT_INVITE = 11; // context: 0
        public const byte MSG_TYPE_PARTY_CHAT_INVITE = 12; // context: 0

        public static string MessageTypeToString(uint msgType)
        {
            switch(msgType)
            {
                case MSG_TYPE_TITLE_CUSTOM:
                    return "TitleCustom";
                case MSG_TYPE_FRIEND_REQUEST:
                    return "FriendRequest";
                case MSG_TYPE_GAME_INVITE:
                    return "GameInvite";
                case MSG_TYPE_TEAM_RECRUIT:
                    return "TeamRecruit";
                case MSG_TYPE_COMP_REMINDER:
                    return "CompReminder";
                case MSG_TYPE_COMP_REQUEST:
                    return "CompRequest";
                case MSG_TYPE_LIVE_MESSAGE:
                    return "LiveMessage";
                case MSG_TYPE_PERSONAL_MESSAGE:
                    return "PersonalMessage";
                case MSG_TYPE_VIDEO_MESSAGE:
                    return "VideoMessage";
                case MSG_TYPE_QUICK_CHAT_INVITE:
                    return "ChatInvite";
                case MSG_TYPE_VIDEO_CHAT_INVITE:
                    return "VideoChatInvite";
                case MSG_TYPE_PARTY_CHAT_INVITE:
                    return "PartyInvite";
                default:
                    return "UnknownType";
            }
        }

        // Message Flags
        // -------------
        public const uint MSG_FLAG_REQUIRED              = 0x00000001; // User required to read this message
        public const uint MSG_FLAG_RECOMMENDED           = 0x00000002; // User has a system recommended message
        public const uint MSG_FLAG_HAS_VOICE             = 0x00000004; // Message contains a voice attachment
        public const uint MSG_FLAG_HAS_TEXT              = 0x00000008; // Message contains a text body
        public const uint MSG_FLAG_READ                  = 0x00000010; // Message has been read
        public const uint MSG_FLAG_NON_EXPORTABLE        = 0x00000020; // Message should only be displayed on Xbox consoles, not the web
        public const uint MSG_FLAG_TEAM_CONTEXT          = 0x00000040; // Message's sender context refers to a team ID
        public const uint MSG_FLAG_COMP_CONTEXT          = 0x00000080; // This message's sender context refers to a competition event or entity ID
        public const uint MSG_FLAG_ALTERNATE_TITLE       = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint MSG_FLAG_MARKETING             = 0x00000200; // Used on title-sent messages to indicate the message is marketing-related and opt-in settings should be checked
        public const uint MSG_FLAG_MS_MARKETING          = 0x00000400; // Used on title-sent messages to indicate the message is MS marketing-related and opt-in settings should be checked
        public const uint MSG_FLAG_HAS_PHOTO             = 0x00000800; // Message contains a photo attachment
        public const uint MSG_FLAG_XENON_COMPATIBLE      = 0x00001000; // This message is xenon only
        public const uint MSG_FLAGS_TITLE_RESERVED       = 0xFF000000; // Flags reserved for title custom messages
        // ... Internal
        public const uint MSG_FLAG_SENDER_IS_FRIEND      = 0x00800000; // Used by Notification to detect invites that should go to V1 clients, also used by clients to allow cross-title invites
        public const uint MSG_FLAG_RECV_DETAILS_NEEDED   = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint MSG_FLAG_SEND_MSG_OWNED        = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint MSG_FLAGS_RESERVED             = 0x005FF000; // Flags reserved for future use
        // ... Flags valid in a call to send a message
        public const uint MSG_FLAGS_VALID_SEND_MASK =
            MSG_FLAGS_TITLE_RESERVED |
            MSG_FLAG_NON_EXPORTABLE |
            MSG_FLAG_REQUIRED |
            MSG_FLAG_RECOMMENDED |
            MSG_FLAG_HAS_VOICE |
            MSG_FLAG_HAS_TEXT |
            MSG_FLAG_TEAM_CONTEXT |
            MSG_FLAG_COMP_CONTEXT |
            MSG_FLAG_MARKETING |
            MSG_FLAG_MS_MARKETING |
            MSG_FLAG_HAS_PHOTO |
            MSG_FLAG_XENON_COMPATIBLE;
        // ... Flags a title is allowed to set on an already sent message
        public const uint MSG_FLAGS_TITLE_SETABLE =
            MSG_FLAG_READ |
            MSG_FLAGS_TITLE_RESERVED;
        // ... Flags a title is allowed to clear on an already sent message
        public const uint MSG_FLAGS_TITLE_CLEARABLE =
            MSG_FLAGS_TITLE_RESERVED;
        // ... Test: Flags expected in a V1 iinvite message
        public const uint MSG_FLAGS_TEST_V1INVITE_EXPECTED =
            MSG_FLAG_SENDER_IS_FRIEND;

        // Attachment Flags
        // ----------------
        // ... This attachment should not be visible when the message is displayed on the web
        public const uint MSG_ATTACHMENT_FLAG_NON_EXPORTABLE = 0x00000001;
        // ... The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint MSG_ATTACHMENT_FLAG_DIRECTORY      = 0x00000002;
        // ... Flags reserved for future use
        public const uint MSG_ATTACHMENT_FLAGS_RESERVED      = 0xFFFFFFFC;

        // Message Property Types
        // ----------------------
        public const byte MSG_PROP_TYPE_NULL       =  1; // no data
        public const byte MSG_PROP_TYPE_I1         =  2; // 8-bits of data
        public const byte MSG_PROP_TYPE_I2         =  3; // 16-bits of data
        public const byte MSG_PROP_TYPE_I4         =  4; // 32-bits of data
        public const byte MSG_PROP_TYPE_I8         =  5; // 64-bits of data
        public const byte MSG_PROP_TYPE_STRING     =  6; // NULL-terminated wide character string
        public const byte MSG_PROP_TYPE_FILETIME   =  7; // time value
        public const byte MSG_PROP_TYPE_BINARY     =  8; // binary blob that fits in the message details
        public const byte MSG_PROP_TYPE_ATTACHMENT =  9; // binary blob (or directory path, depending on attachment flags)
                                                         //  that will be uploaded to storage during XOnlineMessageSend
        public const byte MSG_PROP_TYPE_BOOL       = 10; // boolean value (1=TRUE, 0=FALSE)
        public const byte MSG_PROP_TYPE_STRING_ID  = 11; // A string ID whose text can be requested from the string service

        // Message Property IDs
        // --------------------
        // Property IDs should adhere to the following ranges:
        // Range      Purpose
        // 0x00-0x7F  Reserved for use by titles
        // 0x80-0xBF  Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF  Reserved for use by Microsoft for properties that span all message types
        public const byte MSG_PROP_ID_BUILTIN = 0x80; // Used for properties defined by Microsoft
        public const byte MSG_PROP_ID_GLOBAL  = 0x40; // Used for properties that can span all message types

        // Message Property Tags
        // ---------------------
        // ... Global property tags, allowed in any message type
        // All message types can contain a voice attachment specified in the following properties.  All three
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_VOICE message
        // flag can be used to test for the presence of these properties before the message details have been
        // retrieved.
        public const ushort MSG_PROP_VOICE_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_VOICE_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_VOICE_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 3);

        // All message types can contain a text summary specified in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_TEXT message
        // flag can be used to test for the presence of these properties before the message details have been
        // retrieved.  The text should be 256 characters or less and may be used by Live anywhere that a text
        // summary of the message is useful, such as in a Messenger Alert, on the web, or in the Dashboard.
        public const ushort MSG_PROP_TEXT                = ((ushort)MSG_PROP_TYPE_STRING     << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_TEXT_LANGUAGE       = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 5);

        // ... Invite message properties
        public const ushort MSG_PROP_SESSION_ID          = ((ushort)MSG_PROP_TYPE_I8     << 8) | (MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_SESSION_DESCRIPTION = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_SESSION_HOST_XNADDR = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_SESSION_HOST_KEY    = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 4);

        // ... Party session properties
        public const ushort MSG_PROP_PARTY_SESSION_ID          = ((ushort)MSG_PROP_TYPE_I8     << 8) | (MSG_PROP_ID_BUILTIN | 5);
        public const ushort MSG_PROP_PARTY_SESSION_HOST_XNADDR = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 6);
        public const ushort MSG_PROP_PARTY_SESSION_HOST_KEY    = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 7);

        // ... HUD message properties
        public const ushort HUD_MSG_PROP_SESSION_ID          = ((ushort)MSG_PROP_TYPE_I8     << 8) | (MSG_PROP_ID_BUILTIN | 1);
        public const ushort HUD_MSG_PROP_SESSION_DESCRIPTION = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort HUD_MSG_PROP_SESSION_HOST_XNADDR = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort HUD_MSG_PROP_SESSION_HOST_KEY    = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 4);
        public const ushort HUD_MSG_PROP_VOICECHAT_PORT      = ((ushort)MSG_PROP_TYPE_I2     << 8) | (MSG_PROP_ID_BUILTIN | 5);

        // ... Custom message properties
        public const ushort MSG_PROP_GAME_MESSAGE   = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_PLAYER_MESSAGE = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_CUSTOM_ACTIONS = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_CUSTOM_PAYLOAD = ((ushort)MSG_PROP_TYPE_BINARY << 8) | (MSG_PROP_ID_BUILTIN | 4);

        // ... Live system message properties
        public const ushort MSG_PROP_SYSTEM_TEXT         = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Team Recruit message properties
        public const ushort MSG_PROP_TEAM_NAME           = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Competitions message properties
        public const ushort MSG_PROP_COMP_DATASET        = ((ushort)MSG_PROP_TYPE_I4        << 8) | (MSG_PROP_ID_BUILTIN | 0x1);
        public const ushort MSG_PROP_COMP_NAME           = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0x2);
        public const ushort MSG_PROP_COMP_START          = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x3);
        public const ushort MSG_PROP_COMP_ROUND          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x4);
        public const ushort MSG_PROP_COMP_OPPONENT       = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 0x5);
        public const ushort MSG_PROP_COMP_ADMIN          = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x6);
        public const ushort MSG_PROP_COMP_REG_CLOSE      = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x7);
        public const ushort MSG_PROP_COMP_PRIVATE_SLOTS  = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x8);
        public const ushort MSG_PROP_COMP_PUBLIC_SLOTS   = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x9);
        public const ushort MSG_PROP_COMP_UNITS          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xA);
        public const ushort MSG_PROP_COMP_INTERVAL       = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xB);
        public const ushort MSG_PROP_COMP_DAYMASK        = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xC);
        public const ushort MSG_PROP_COMP_DESCRIPTION    = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xD);
        public const ushort MSG_PROP_COMP_URL            = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xE);
        public const ushort MSG_PROP_COMP_EVENT_ID       = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x10);
        public const ushort MSG_PROP_COMP_EVENT_START    = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x11);

        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        // ----------------------------------------------------------------
        public const ushort PROP_VOICE_DATA_CODEC_WMAVOICE_V90 = 1;
        public const ushort PROP_VOICE_DATA_CODEC_SASE3200     = 2;
        // All message types can contain a photo attachment in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_PHOTO message
        // flag can be used to test for the presence of these properties before the message details have been
        // retrieved.
        public const ushort MSG_PROP_PHOTO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT<< 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 6);
        public const ushort MSG_PROP_PHOTO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 7);

        public const ushort PROP_PHOTO_DATA_CODEC_PNG    = 1;

        //
        // Video Message Properties
        //
        public const ushort MSG_PROP_VIDEO_FRAME_DATA    = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 1);
        //This defines the First Frame of the Video as JPG, BMP�etc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort MSG_PROP_VIDEO_FRAME_CODEC   = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_VIDEO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_VIDEO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_VIDEO_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_BUILTIN | 5);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\QueryAndLsp\XRLLSPProxyAdvertise.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.QueryAndLsp {

	public class XRLLSPProxyAdvertiseRequest : XRLPayload {
		public XRLLSPProxyAdvertiseRequest () {
			ServiceId = XOService.InvalidService;
		}

		// Advertise to this titleId
		//[WireInfo(Min=1, Max=UInt32.MaxValue)]
		[XRLPayloadFld(IsTitleId=true)]
		public UInt32 titleId;

		// You can find me at this IP (Network byte order)
		//[WireInfo(Min=1, Max=UInt32.MaxValue)]
		public UInt32 ipSgLsp;

		// Expire after this many seconds
		//[WireInfo(Min=10, Max=LspProtocolConstants.XONLINE_LSP_MAX_EXPIRATION_SECONDS)]
		public UInt32 ttlInSeconds;

		// Reserved. Zero for now.
		//[WireInfo(Min=0, Max=UInt32.MaxValue)]
		public UInt32 flags;

		// XNKID for backwards compatibility with old clients
		[WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKID_LEN)]
		public byte[] xnkid;

		// XNKEY for backwards compatibility with old clients
		[WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKEY_LEN)]
		public byte[] xnkey;

		// Length in bytes for user data (it's UTF8 encoded)
		//[WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN * XOn.UTF8_MULT)]
		public ushort userDataLength;

		// User data.
		[WireInfo(SizeParam="userDataLength")]
		public string userData;

		private string serviceName = "/LiveProxy/LSPAdvertise.aspx";
		public string ServiceName {
			get { return serviceName; }
			set { serviceName = value; }
		}

		protected override string GetServiceName () {
			return serviceName;
		}

		public override bool Execute (IPEndPoint proxyEndPoint) {
			return base.Execute(proxyEndPoint);
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\QueryAndLsp\XRLLspEnumerate.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.QueryAndLsp
{
    public class XRLLspEnumerateRequest : XRLPayload
    {
        // Title-id
        //[WireInfo(Min=1, Max=UInt32.MaxValue)]
        [XRLPayloadFld(IsTitleId=true)]
        public UInt32       titleId;
        
        // Length of user data
        //[WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN * XOn.UTF8_MULT)]
        public UInt16       userDataLength;

        // If specified (not empty, userDataLength > 0), only entries with 
        // matching userData will be enumerated. If not specified 
        // (userDataLength == 0), all entries will be enumerated
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

        // Return 'resultCount' results starting at 'resultIndex'. Zero is the 
        // first entry. One is the second and so on...
        //[WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       resultIndex;

        // Maximum number of results to be returned
        //[WireInfo(Min=1, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       resultCount;

        // The response. Not serialized.
        [XRLPayloadFld(Serialize=false)]
        public XRLLspEnumerateReply Response=null;

		private string serviceName = "/lsp/enumerate.ashx";
		public string ServiceName {
			get { return serviceName; }
			set { serviceName = value; }
		}

        protected override string GetServiceName()
        {
            return serviceName;
        }

        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xqry));
        }

        protected override void SetServices()
        {
            base.SetServices ();
            Slot.AddService(XOService.Query);
        }

        protected override void ReadResponse(MemoryStream responseStream)
        {
            Response = new XRLLspEnumerateReply();
            Response.ReadStream(responseStream);
        }

    }

    public class XRLLspEnumerateReply : XRLPayload
    {
        // Number of LspInfos returned in 'lspInfo'
        //[WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       lspInfoCount;
        
        // Array with information on Lsp Servers
        [WireInfo(SizeParam="lspInfoCount")]
        public LspEnumerateServerInfo[] lspInfo;
    }

    public class LspEnumerateServerInfo : XRLPayload
    {
        // Ip of the SGLSP (Network byte order)
        //[WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;

        // Reserved. Zero for now.
        public UInt32       flags;

        // Length of user data
        //[WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN * XOn.UTF8_MULT)]
        public UInt32       userDataLength;

        // User data - the same user data that the server passed in 
        // LspAdvertiseRequest
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\PresNotiCommon\PNUser.cs ===
// PNUser.cs
//
//  Presence and Notification User Sim Object
//

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.Web.Presence;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol.SubNoti;
using xonline.common.protocol.socialquery;
using xonline.common.community;
using xonline.common.utilities2;

using xonline.common.service;
using xonline.common.stfutil;

using AddUsersToNeverListMsg = xonline.common.protocol.AddUsersToNeverListMsg;
using RemoveUsersFromNeverListMsg = xonline.common.protocol.RemoveUsersFromNeverListMsg;
using CanSendMessageToUsersMsg = xonline.common.protocol.CanSendMessageToUsersMsg;
using CanSendMessageToUsersResponse = xonline.common.protocol.CanSendMessageToUsersResponse;

using MsgDefs = xonline.common.protocol.MsgDefs;

namespace ServerTestFramework.LiveService.PresNotiCommon
{
    /// <summary>
    /// Simulation state for a user in the the presence and notificatiion system.
    /// This is state storage, the methods here to not attempt to maintain consistency
    /// or correctness of User state data.
    /// </summary>
    public class PNUser : IDisposable
    {
        public static uint   DefaultUserFlags = 0x02606700;       // English (1<<25), Silver tier (0x6) user in the US (0x67)
        public static double DefaultNotificationWait = 60.0;             // 60 seconds
        public static bool   Verbose=true;

        private bool _disposed = false;

        // Polling interval for qval changes in milliseconds(Dependent on QVal updates from
        // presence, but this is the rate that we will request qval updates from the
        // FakeSG over the remoting port.)
        public static int QValPollingInterval = 100;
        public static int NotificationPollingInterval = 100;
        public static Report RO = new Report(typeof(PNUser).Name);

        // Static Lookup table for All users
        public static Hashtable Lookup = new Hashtable();
        public static PNUser Find( ulong id )
        {
            return (PNUser)( Lookup.Contains( id ) ? Lookup[ id ] : null );
        }
        public static PNUser Service = new PNUser("LiveService", 0);

        /// <summary>
        /// Enumerated flags passed or'd together can be passed
        /// to HandleQValPacket to control how qval data is processed
        /// </summary>
        public const uint HQV_ReadMessages   = 0x00000001;   // Mark messages processed as read
        public const uint HQV_DeleteMessages = 0x00000002;   // Delete messages as read


        /// <summary>
        /// Used to store information about users buddies
        /// </summary>
        public class BuddyInfo
        {
            public PNUser User;
            public byte   Status = XonPresNoti.NOT_A_BUDDY; // or const: P_BUDDY_STATUS_xxx
            public string Name;
            public InvitationItem Invitation;   // Dequeued invitation record from presence.
            public BasicPresenceNotificationData BasicPresenceData;
            public RichPresenceNotificationData RichPresenceData;

            //public bool             Validate;

            ////May not need this since PNUser already has it.
            //public uint TitleId = 0;
            //public uint State = XonPresNoti.P_STATE_MASK_NONE;
            //public ulong MatchSessionId = 0;
            //public uint mtLastSeen;
            //public string RichPresence;

            public BuddyInfo( byte status, string name)
            {
                Status = status;
                Name   = name;
            }

            public BuddyInfo( byte status, PNUser user)
            {
                Status = status;
                Name = user.Name;
                User = user;
            }
        }

        /// <summary>
        /// Represents an invitation from a user to a game session. If the Host == this then this is
        /// an out going InvitationItem
        /// </summary>
        public class InvitationInfo
        {
            public bool            Owns;                  // True when the user created this invitation
            public PNUser          Host;                  // Host of the match session
            public ulong           MatchSession;          // Outgoing invites will have this field set but no dequeud invite item
            public ulong           Context;               // Extra context for use with competitions
            public PNUser[]        Invited;               // List of invited users
            public InvitationItem  Invitation;            // Dequeued invitation record from presence.
            public Hashtable       InvitationAnswers;     // Dequeued invitation answers from presence.
            public uint            MessageId;             // Message ID of the invitation

            public InvitationInfo()
            {
                Host         = null;
                MatchSession = 0;
                Invitation   = null;
                InvitationAnswers = new Hashtable();
            }

            public InvitationInfo(PNUser host)
            {
                Host         = host;
                MatchSession = 0;
                Invitation   = null;
                InvitationAnswers = new Hashtable();
            }

            public InvitationInfo(PNUser host, ulong sessionId)
            {
                Host         = host;
                MatchSession = sessionId;
                Invitation   = null;
                InvitationAnswers = new Hashtable();
            }
        }

        /// <summary>
        /// Represents a peer subscription to another user
        /// </summary>
        public class PeerInfo
        {
            public PNUser           User;         // Reference to peer

            ////May not need this since PNUser already has it.
            //public uint TitleId = 0;
            //public uint State = XonPresNoti.P_STATE_MASK_NONE;
            //public ulong MatchSessionId = 0;
            //public uint mtLastSeen;
            //public string RichPresence;

            public BasicPresenceNotificationData BasicPresenceData;
            public RichPresenceNotificationData RichPresenceData;
            public InvitationItem Invitation;   // Dequeued invitation record from presence.
            public PeerInfo()
            {
                User           = null;
            }

            public PeerInfo(PNUser user)
            {
                User           = user;
            }
        }

        /// <summary>
        /// Represents message data that was received in a messaging QVAL
        /// </summary>
        public class MessageInfo
        {
            public bool            Deleted;
            public uint            Id;
            public uint            Data;
            public UserMessage     Message;

            public byte MessageType
            {
                get {
                    return (byte)(Data >> 24);
                }
            }

            public bool IsSameTitle
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_SAME_TITLE));
                }
            }
            public bool IsSamePublisher
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_SAME_PUBLISHER));
                }
            }
            public bool IsInviteFromFriend
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND));
                }
            }
            public bool HasVoice
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_HAS_VOICE));
                }
            }
            public bool HasText
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_HAS_TEXT));
                }
            }
            public bool IsAltTitle
            {
                get {
                    return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_ALT_TITLE));
                }
            }

            public override string ToString()
            {
                return "Id: " + Id + "(" + XonPresNoti.BuildMsgNotificationFlagsString(Data) + "), Del?: " + Deleted.ToString();
            }

        }


        // Fixed state data
        public ulong     UserId;
        public uint      UserFlags;
        public string    Name;
        public PNXbox    Xbox;

        // Variable state data
        public byte[]    WebId          = {};
        public uint TitleId             = 0;
        public uint      State          = XonPresNoti.P_STATE_MASK_NONE;
        public byte[]    TitleStuff     = {};
        public byte[]    Nickname       = {};
        public ulong     MatchSessionId = 0;
        public uint      BuddyListVer   = 0;
        public uint      BlockListVer   = 0;
        //Basic presence
        public uint mtLastSeen;

        // When true use HttpHdr auth, set with WebAlive/unset with WebLogoff
        public enum UserPlatformType { Default, Web, Mobile }
        public UserPlatformType PlatformType = UserPlatformType.Default; 

        private Hashtable Buddies       = null; // Hash of friend PUID to BuddyInfo objects
        private ArrayList Blocks = null; // List of blocks created by this user
        private Hashtable Invites       = null; // Hash of invitee PUID to InviteInfo objects
        private Hashtable Peers         = null; // Hash of peer PUID to PeerInfo objects
        private Hashtable Messages      = null; // Hash of message ID to MessageInfo objects
        private GIBlob    _GIBlob       = null;
        private static Hashtable EmptyHash  = new Hashtable();
        private static ArrayList EmptyList  = new ArrayList();


        public IDictionaryEnumerator BuddyEnumerator
        {
            get {
                return (Buddies!=null) ? Buddies.GetEnumerator() : EmptyHash.GetEnumerator();
            }
        }

        public IEnumerator BlocksEnumerator
        {
            get {
                return (Blocks!=null) ? Blocks.GetEnumerator() : EmptyList.GetEnumerator();
            }
        }

        public IDictionaryEnumerator InviteEnumerator
        {
            get {
                return (Invites!=null) ? Invites.GetEnumerator() : EmptyHash.GetEnumerator();
            }
        }

        public IDictionaryEnumerator PeerEnumerator
        {
            get {
                return (Peers!=null) ? Peers.GetEnumerator() : EmptyHash.GetEnumerator();
            }
        }

        public IDictionaryEnumerator MessageEnumerator
        {
            get {
                return (Messages!=null) ? Messages.GetEnumerator() : EmptyHash.GetEnumerator();
            }
        }

        // counts on classes of buddies
        public uint BuddiesOK           // 0
        {
            get
            {
                uint c = 0;
                IDictionaryEnumerator enumerator = BuddyEnumerator;
                while(enumerator.MoveNext())
                {
                    BuddyInfo bi = enumerator.Value as BuddyInfo;
                    if(bi.Status == 0)
                    {
                        c++;
                    }
                }
                return c;
            }
        }

        public uint BuddiesPending      // 1
        {
            get
            {
                uint c = 0;
                IDictionaryEnumerator enumerator = BuddyEnumerator;
                while(enumerator.MoveNext())
                {
                    BuddyInfo bi = enumerator.Value as BuddyInfo;
                    if(bi.Status == 1)
                    {
                        c++;
                    }
                }
                return c;
            }
        }

        public uint BuddiesRequested    // 2
        {
            get
            {
                uint c = 0;
                IDictionaryEnumerator enumerator = BuddyEnumerator;
                while(enumerator.MoveNext())
                {
                    BuddyInfo bi = enumerator.Value as BuddyInfo;
                    if(bi.Status == 2)
                    {
                        c++;
                    }
                }
                return c;
            }
        }

        public uint BuddiesAny
        {
            get
            {
                return (uint)(null != Buddies ? Buddies.Count : 0);
            }
        }

        public uint PeerSubscriptions
        {
            get
            {
                return (uint)(null != Peers ? Peers.Count : 0);
            }
        }

        public PNUser[] PeerSubscribes
        {
            get
            {
                PNUser[] peerSubscribes = new PNUser[Peers != null ? Peers.Count : 0];
                int iPeer = 0;
                foreach (PeerInfo peerInfo in Peers.Values)
                {
                    peerSubscribes[iPeer] = peerInfo.User;
                    iPeer++;
                }

                return peerSubscribes;
            }
        }

        // counts on invitation that received
        public uint NumberOfInvitations
        {
            get
            {
                return (this.Invites != null) ? ((uint)this.Invites.Count) : 0;
            }
        }
        // Invitation signal count
        private uint LastInviteBlipCount;
        private QValPacket _LastQValPacket = new QValPacket();


        // Lastest QVal packet delivery
        public QValPacket LastQValPacket
        {
            get
            {
                ProcessQVals();
                return _LastQValPacket;
            }
        }

        public UserNotification LastNotification
        {
            get
            {
                List<UserNotification> notis = new List<UserNotification>();
                Xbox.GetUserNotificationFromQueue(UserId, out notis);
                return notis[0];
            }
        }

        public byte CountryId
        {
            set {
                UserFlags = UserFlagsUtil.SetUserCountryId(UserFlags, (uint)value);
                Reconnect();
            }
            get {
                return (byte)UserFlagsUtil.UserCountryId(UserFlags);
            }
        }

        public byte Tier
        {
            set {
                UserFlags = UserFlagsUtil.SetUserTierId(UserFlags, (uint)value);
                Reconnect();
            }
            get {
                return (byte)UserFlagsUtil.UserTierId(UserFlags);
            }
        }

        public byte LanguageId
        {
            set {
                UserFlags = UserFlagsUtil.SetUserLanguageId(UserFlags, (uint)value);
                Reconnect();
            }
            get {
                return (byte)UserFlagsUtil.UserTierId(UserFlags);
            }
        }

        // TODO-jacobr: Add the rest of the flags from XUIAndTrust when their effects are well understood
        // Xbox user is connected with

        public GIBlob GIBlob {
            get {
                if(null == _GIBlob)
                {
                    _GIBlob = new GIBlob();
                }
                return _GIBlob;
            }
            set {
                _GIBlob = value;
            }
        }

        public bool PartyPlaying
        {
            get
            {
                return ((State & XonPresNoti.P_STATE_MASK_PARTY_PLAYING) == XonPresNoti.P_STATE_MASK_PARTY_PLAYING);
            }

            set
            { 
                if (value && !PartyPlaying) 
                {
                    State |= XonPresNoti.P_STATE_MASK_PARTY_PLAYING;
                    SetTitleData();
                }
                else if (!value && PartyPlaying)
                {
                    State &= ~XonPresNoti.P_STATE_MASK_PARTY_PLAYING;
                    SetTitleData();
                }
            }
        }

        /// <summary>
        /// Creates an user with default data.
        /// Intended for PN testing only. (Real users get there Ids from UACS.)
        /// </summary>
        public PNUser()
        {
            UacsCommon UACS = new UacsCommon();
            RandomEx   Random = new RandomEx();

            Name = Random.GenerateRandomString( "StfPN", 15 );
            Owner owner = new Owner( Name );
            UserId = UACS.CreateUser( owner );
            UserFlags = DefaultUserFlags;

            Lookup[ UserId ] = this;
        }

        /// <summary>
        /// Create with name raw values provided
        /// </summary>
        /// <param name="name">User's gamertag</param>
        /// <param name="userId">User's PUID</param>
        public PNUser( string name, ulong userId )
        {
            Name   = name;
            UserId = userId;
            UserFlags = DefaultUserFlags;
          
            Lookup[ UserId ] = this;
        }

        /// <summary>
        /// Create with name raw values provided, link user to provided console
        /// </summary>
        /// <param name="name">User's gamertag</param>
        /// <param name="userId">User's PUID</param>
        /// <param name="xbox">Linked console</param>
        public PNUser( string name, ulong userId, PNXbox xbox)
        {
            Name = name;
            UserId = userId;
            UserFlags = DefaultUserFlags;
            Connect(xbox);

            Lookup[ UserId ] = this;
        }

        /// <summary>
        /// Create with users made using framework's UODB stuff
        /// </summary>
        /// <param name="puidName"></param>
        public PNUser( PuidName puidName )
        {
            Name   = puidName.GamerTag;
            UserId = puidName.Puid;
            UserFlags = DefaultUserFlags;
            WebId  = puidName.WebId;

            Lookup[ UserId ] = this;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    Disconnect();
                    Lookup.Remove(this.UserId);
                }

                _disposed = true;
            }
        }

        /// <summary>
        /// Checks users state bits to see in online flag is set
        /// </summary>
        public bool LoggedOn
        {
            get{ return( 0 != (State & XonPresNoti.P_STATE_MASK_ONLINE) ); }
        }

        /// <summary>
        /// Checks if an xbox is set for this user
        /// </summary>
        public bool Connected
        {
            get{ return( Xbox != null ); }
        }

        /// <summary>
        /// Establish connection with FakeSG so it will start collecting QVals
        /// for this user
        /// </summary>
        /// <param name="xbox">Xbox that user will connect to FakeSG through</param>
        public void Connect( PNXbox xbox )
        {
            // Clear user off existing xbox
            if(null != Xbox)
            {
                Xbox.RemoveUser(UserId);
            }

            // Replace our xbox reference
            Xbox = xbox;

            // Reconnect the new xbox
            Reconnect();
        }

        /// <summary>
        /// Manually reconnect a user to an xbox
        /// </summary>
        public void Reconnect()
        {
            if(null != Xbox)
            {
                Xbox.ConnectToFakeSG();
                Xbox.AddUser(UserId, UserFlags);
            }
        }

        /// <summary>
        /// Remove association with fake SG, QVal reply will start reporting this
        /// user as not found
        /// </summary>
        public void Disconnect()
        {
            if(null != Xbox)
            {
                //
                // Do a simulated SG disconnection for the user (DeadUser)
                // ----
                // Clear the user ID on the Xbox in the fake SG, the xbox stays registered
                // in the fake SG until it is explicitly removed. This can be solved with the
                // DisconnectFromFakeSG() method on PNXbox or by calling ClearXboxes() on the
                // FakeSG object.
                //
                // Presence FD wants to see 0 users in the ticket but wants to
                // do SG auth for the dead user message.
                //
                Xbox.RemoveUser(UserId);

                PNMsgDeadUser deadUser = new PNMsgDeadUser(this);
                deadUser.TransactFD();

                // Keep the pointer to the xbox so we can re-use it at a later time and our
                // title/language etc does not change underneath us
            }

            ClearState();
        }

        /// <summary>
        /// Reload the online presence record.
        /// </summary>
        public void Invalidate()
        {
            // Async message request
            PMsgInvalidateUser req = new PMsgInvalidateUser(this);
            req.TransactFD();
        }

        /// <summary>
        /// Cleans out user login state
        /// </summary>
        public void ClearState()
        {
            // Notify that the user is clearing state as this has impacts on testing
            // internal state between calls to presence
            if(XonPresNoti.P_STATE_MASK_NONE != State && null != Buddies)
            {
                if (Verbose)
                {
                    RO.Debug("ClearState[{0:x}]", UserId);
                }

                State          = XonPresNoti.P_STATE_MASK_NONE;
                TitleStuff     = new byte[0];
                Nickname       = new byte[0];
                MatchSessionId = 0;
                BuddyListVer   = 0;
                Buddies        = null;
                BlockListVer   = 0;
                Blocks         = null;
                Peers          = null;
                Invites        = null;
                Messages       = null;
            }
        }

        /// <summary>
        /// Build and send alive msg, then update state with default presecne flags and buddy
        /// and block list info returned
        /// </summary>
        public uint Alive()
        {
            PNMsg replyMsg;
            PMsgAlive2 aliveMsg = new PMsgAlive2( this );
            aliveMsg.TransactFD(out replyMsg);

            PAliveReplyMsgData reply = (PAliveReplyMsgData)replyMsg.Data;

            if( HResult.Failed( reply.HR ) )
            {
                throw new HResultException( reply.HR, "User[" + UserId.ToString("x") + "] Alive failed with HR = " + reply.HR.ToString( "X" ) + " in reply. " );
            }

            // Validate counts against actual data sent
            ValueCheck.Test("Alive BuddiesLen Consistency", reply.BuddiesLen, (ushort)reply.Buddies.Length);
            ValueCheck.Test("Alive BlocksLen Consistency", reply.BlocksLen, (ushort)reply.Blocks.Length);

            // Default State after a successfull alive
            State = XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_CLOAKED;

            BuddyListVer = reply.BuddyListVersion;
            Buddies = new Hashtable( reply.Buddies.Length );
            DATA_OBJECT_SPECIFIER[] doSpecs = new DATA_OBJECT_SPECIFIER[reply.Buddies.Length*2];
            int ctr = 0;
            foreach( BuddyData buddy in reply.Buddies )
            {
                PNUser user = Find(buddy.BuddyID);
                if(user != null)
                {
                    Buddies[ buddy.BuddyID ] = new BuddyInfo( buddy.Status, user );
                }
                else
                {
                    Buddies[ buddy.BuddyID ] = new BuddyInfo( buddy.Status, buddy.Name );
                }
                doSpecs[ctr] = GetBasicPresenceDataObjectSpecifier(buddy.BuddyID);
                ctr++;
                doSpecs[ctr] = GetRichPresenceDataObjectSpecifier(buddy.BuddyID);
                ctr++;
            }
            if (doSpecs.Length !=0 )
                this.Xbox.SendSubscribeForUser(UserId, doSpecs);


            BlockListVer = reply.BlockListVersion;
            Blocks = new ArrayList( reply.Blocks );

            if (Verbose)
            {
                RO.Debug("Alive[{0:x}]: Title: {1:x}, IsXenon: {2}, HR: {3:x}",
                    UserId,
                    Xbox.TitleId,
                    Xbox.IsXenonTitle ? "yes" : "no",
                    reply.HR);
            }
            
            _LastQValPacket.Clear();

            return reply.HR;
        }

        public uint PhoneAlive()
        {
            PlatformType = UserPlatformType.Mobile;
            return WebAlive();
        }
        public uint WebAlive()
        {
            //If this is not set to Mobile, then set it to Web so that it doesn't break old test code.
            if (this.PlatformType == UserPlatformType.Default)
                PlatformType = UserPlatformType.Web;

            // Do a quick Xbox check, if it doesn't exist create
            // a dummy entry so we can use existing message constructors
            // without changing them
            if(null == Xbox)
            {
                Xbox = new PNXbox();
            }

            // Send the web alive request
            PMsgWebAlive aliveMsg = new PMsgWebAlive( this );
            PNMsg replyMsg;
            aliveMsg.TransactFD(out replyMsg);

            PWebAliveReplyMsgData reply = (PWebAliveReplyMsgData)replyMsg.Data;

            if( HResult.Failed( reply.HR ) )
            {
                throw new HResultException( reply.HR, "User[" + UserId.ToString("x") + "] WebAlive failed with HR = " + reply.HR.ToString( "X" ) + " in reply. " );
            }

            ValueCheck.Test("Reply.UserId", reply.UserID, UserId);

            if (Verbose)
            {
                RO.Debug("WebAlive[{0:x}]: HR: {1:x}", UserId, reply.HR);
            }

            return reply.HR;
        }

        public uint WebAlive2()
        {
            //If this is not set to Mobile, then set it to Web so that it doesn't break old test code.
            if (this.PlatformType == UserPlatformType.Default)
                PlatformType = UserPlatformType.Web;

            // Do a quick Xbox check, if it doesn't exist create
            // a dummy entry so we can use existing message constructors
            // without changing them
            if (null == Xbox)
            {
                Xbox = new PNXbox();
            }

            // Send the web alive request
            PMsgWebAlive2 aliveMsg = new PMsgWebAlive2(this);
            PNMsg replyMsg;
            aliveMsg.TransactFD(out replyMsg);

            PWebAliveReplyMsgData reply = (PWebAliveReplyMsgData)replyMsg.Data;

            if (HResult.Failed(reply.HR))
            {
                throw new HResultException(reply.HR, "User[" + UserId.ToString("x") + "] WebAlive2 failed with HR = " + reply.HR.ToString("X") + " in reply. ");
            }

            ValueCheck.Test("Reply.UserId", reply.UserID, UserId);

            if (Verbose)
            {
                RO.Debug("WebAlive2[{0:x}]: HR: {1:x}", UserId, reply.HR);
            }

            return reply.HR;
        }

        public void PhoneLogoff()
        {
            PlatformType = UserPlatformType.Default;
        }
        public void WebLogoff()
        {
            PlatformType = UserPlatformType.Default;
        }

        public void InternalTransactFD(PNRequestMsg request)
        {
            PNMsg reply;
            InternalTransactFD(request, out reply);
        }

        public void InternalTransactFD(PNRequestMsg request, out PNMsg reply)
        {
            if(PlatformType == UserPlatformType.Mobile || PlatformType == UserPlatformType.Web)
            {
                // Change the authentication type
                request.AuthMethod = PNRequestMsg.FDAuth.HttpHdr;

                // Convert the port
                switch(request.PortOnFD)
                {
                    case PNRequestMsg.FDPort.PresNoti:
                        request.PortOnFD = PNRequestMsg.FDPort.PresNoti_DC;
                        break;
                    case PNRequestMsg.FDPort.Messaging:
                        request.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;
                        break;
                }
            }
            request.TransactFD(out reply);
        }

        public uint CheckTitleMessages()
        {
            PMsgCheckTitleMessages req = new PMsgCheckTitleMessages( this, Xbox.TitleId, Xbox.TitleRegion);
            PNMsg resp;
            req.TransactFD(out resp);
            PCheckTitleMessagesReplyMsgData data = (PCheckTitleMessagesReplyMsgData)resp.Data;
            return data.HR;
        }


        /// <summary>
        /// Send dead user message to presence and notification clusters
        /// </summary>
        public void Dead()
        {
            if (Verbose)
            {
                RO.Debug("User: {0:x} sending DeadUser", UserId);
            }

            //UnSubscribe from all existing subscriptions on connection server.
            int totalSubscriptions = this.Xbox.ConnectionServerConnection.SubscribedUsers[0].Count;
            DATA_OBJECT_SPECIFIER[] dos = new DATA_OBJECT_SPECIFIER[totalSubscriptions];
            this.Xbox.ConnectionServerConnection.SubscribedUsers[0].Values.CopyTo(dos, 0);
            this.Xbox.ConnectionServerConnection.Unsubscribe(dos, new int[] { 0 });

            PNMsgDeadUser deadUserMsg = new PNMsgDeadUser( this );
            deadUserMsg.TransactFD();
        }

        /// <summary>
        /// Generate HTTP auth data block for this user
        /// </summary>
        public HTTPAuthData GetAuthData()
        {
            HTTPAuthData auth = new HTTPAuthData( 0xffff, 0, Xbox.XnKId.ab, UserId, Xbox.TitleId, 1, 5);
            auth.dwTitleRegion = Xbox.TitleRegion;
            auth.dwTitleVersion = Xbox.TitleVer;
            return auth;
        }

        /// <summary>
        /// Send a request to add a buddy.
        /// Buddy list update happens if/when notificaiton is handled
        /// </summary>
        /// <param name="buddy">User being asked to be a buddy</param>
        public void AddBuddy( PNUser buddy )
        {
            PMsgAddBuddy addMsg = new PMsgAddBuddy( this, buddy );
            InternalTransactFD(addMsg);

            ////Connection server Subscribe to eachother.
            //if (this.Xbox != null && this.Xbox.UseConnectionServer)
            //{
            //    this.Xbox.SendSubscribeForUser(this.UserId, new DATA_OBJECT_SPECIFIER[] { this.GetBasicPresenceDataObjectSpecifier(buddy.UserId) });
            //    this.Xbox.SendSubscribeForUser(this.UserId, new DATA_OBJECT_SPECIFIER[] { this.GetRichPresenceDataObjectSpecifier(buddy.UserId) });
            //}
        }

        public void ClearBuddyInfos()
        {
            Buddies.Clear();
        }

        public void AddBuddyInfo(BuddyInfo bi)
        {
            Buddies.Add(bi.User.UserId, bi);
        }

        public void RemoveBuddyInfo(ulong xuid)
        {
            Buddies.Remove(xuid);
        }

        /// <summary>
        /// Send accept of a buddy request.
        /// Buddy list update happens if/when notificaiton is handled
        /// </summary>
        /// <param name="buddy">User that asked to be buddies</param>
        public void AcceptBuddy( PNUser buddy )
        {
            PMsgAcceptBuddy acceptMsg = new PMsgAcceptBuddy( this, buddy );
            InternalTransactFD( acceptMsg );

            //if (this.Xbox != null && this.Xbox.UseConnectionServer)
            //{
            //    this.Xbox.SendSubscribeForUser(this.UserId, new DATA_OBJECT_SPECIFIER[] { this.GetBasicPresenceDataObjectSpecifier(buddy.UserId) });
            //    this.Xbox.SendSubscribeForUser(this.UserId, new DATA_OBJECT_SPECIFIER[] { this.GetRichPresenceDataObjectSpecifier(buddy.UserId) });
            //}
        }

        /// <summary>
        /// Send reject of a buddy request.
        /// Buddy list update happens if/when notificaiton is handled
        /// </summary>
        /// <param name="buddy">User that asked to be buddies</param>
        public void RejectBuddy( PNUser buddy )
        {
            RejectBuddy( buddy, false );
        }

        /// <summary>
        /// Send reject of a buddy request.
        /// Buddy list update happens if/when notificaiton is handled
        /// </summary>
        /// <param name="buddy">User that asked to be buddies</param>
        /// <param name="never">Never see buddy request from that user again</param>
        public void RejectBuddy( PNUser buddy, bool never )
        {
            PMsgRejectBuddy rejectMsg = new PMsgRejectBuddy( this, buddy, never );
            InternalTransactFD( rejectMsg );
        }

        /// <summary>
        /// Send delete of requested buddy (accepted or not).
        /// Buddy list update happens if/when notificaiton is handled
        /// </summary>
        /// <param name="buddy">Buddy being deleted</param>
        public void DeleteBuddy( PNUser buddy )
        {
            PMsgDeleteBuddy deletetMsg = new PMsgDeleteBuddy( this, buddy );
            InternalTransactFD( deletetMsg );
        }

        /// <summary>
        /// Send delete to all buddies and make sure all buddy lists (theirs and
        /// ours) get updated by waiting for and handling notifications.
        /// </summary>
        public void DeleteAllBuddies()
        {
            ArrayList dead = new ArrayList();
            ulong[] keys = new ulong[Buddies.Keys.Count];
            Buddies.Keys.CopyTo(keys,0);
            foreach( ulong buddyId in keys )
            {
                BuddyInfo bi    = GetBuddyInfo(buddyId);
                PNUser    buddy = PNUser.Find(buddyId);

                if( buddy == null )
                {
                    buddy = new PNUser( "DelAllBuds", buddyId );
                    DeleteBuddy( buddy );
                }
                else
                {
                    if( bi.Status == XonPresNoti.NOT_A_BUDDY )
                    {
                        // unlikely, normally removal happens when delete notification comes in.
                        dead.Add( buddyId );
                    }
                    else
                    {
                        DeleteBuddy( buddy );
                        WaitForBuddyStatusDeleted( buddy );
                        buddy.WaitForBuddyStatusDeleted( this );
                    }
                }
            }

            foreach( ulong buddyId in dead )
            {
                Buddies.Remove( buddyId );
            }
        }

        /// <summary>
        /// Lookup buddy information for any buddy state by the associated
        /// buddies user ID.
        /// </summary>
        public BuddyInfo GetBuddyInfo(ulong buddyId)
        {
            if(Buddies != null)
            {
                return Buddies[buddyId] as BuddyInfo;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Add a user to the list of peer subscribed users.
        /// </summary>
        public void AddPeerSubscription(PNUser peer)
        {
            AddPeerSubscription(new PNUser[]{peer});
        }

        /// <summary>
        /// Add an array of users to the list of peer subscribed users.
        /// </summary>
        public void AddPeerSubscription(PNUser []peers)
        {
            if(null == peers)
            {
                throw new ArgumentException("peers cannot be null");
            }

            // Create our new peer subscription array
            uint i = 0;
            PNUser []subscribe = new PNUser[PeerSubscriptions + peers.Length];

            // Add existing peers
            IDictionaryEnumerator e = PeerEnumerator;
            while(e.MoveNext())
            {
                PeerInfo info = (PeerInfo)e.Value;
                if(null != info)
                {
                    subscribe[i++] = info.User;
                }
            }

            // Add new peers
            foreach(PNUser peer in peers)
            {
                subscribe[i++] = peer;
            }

            // Update peer subscription
            PeerSubscribe(subscribe);
        }

        /// <summary>
        /// Remove one of the users that is subscribed and update subscriptions
        /// on server.
        /// </summary>
        public void RemovePeerSubscription(PNUser peer)
        {
            RemovePeerSubscription(new PNUser[]{peer});
        }

        /// <summary>
        /// Remove an array of users that are subscribed and update subscriptions
        /// on server.
        /// </summary>
        public void RemovePeerSubscription(PNUser []peers)
        {
            // Remove existing peers
            if(null != Peers && Peers.Count > 0)
            {
                foreach(PNUser peer in peers)
                {
                    if(Peers.Contains(peer.UserId))
                    {
                        Peers.Remove(peer.UserId);
                    }
                }
            }

            // Create new peer subscription
            PNUser []subscribe = new PNUser[PeerSubscriptions];
            uint i = 0;
            IDictionaryEnumerator e = PeerEnumerator;
            while(e.MoveNext())
            {
                PeerInfo info = (PeerInfo)e.Value;
                if(null != info)
                {
                    subscribe[i++] = info.User;
                }
            }

            // Update peer subscription
            PeerSubscribe(subscribe);
        }

        /// <summary>
        /// Peer subscribe to a single user. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribe(PNUser topeer)
        {
            PeerSubscribe(new PNUser[]{topeer});
        }

        /// <summary>
        /// Peer subscribe to a list of users. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribe(PNUser []topeerlist)
        {
            //Peer subscribe to connection server now?
            foreach (PNUser user in topeerlist)
            {
                //Basic subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetBasicPresenceDataObjectSpecifier(user.UserId) });
                //Rich subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetRichPresenceDataObjectSpecifier(user.UserId) });
            }

            // Allow the caller to pass in null for testing purposes, just clear
            // the peer hash if there is one and skip hash updates
            if(null == topeerlist)
            {
                if(null != Peers)
                {
                    Peers.Clear();
                }
                goto lbDone;
            }


            // Update the hash with new peer info structures keeping existing 
            // peer info unless we don't have any peer info yet in which case
            // we can do the cheaper straight import
            if (null != Peers && Peers.Count > 0)
            {
                Hashtable NewPeers = new Hashtable(topeerlist.Length);
                foreach (PNUser user in topeerlist)
                {
                    if (!Peers.Contains(user.UserId))
                    {
                        NewPeers[user.UserId] = new PeerInfo(user);
                    }
                    else
                    {
                        NewPeers[user.UserId] = Peers[user.UserId];
                    }
                }
                Peers = NewPeers;
            }
            else
            {
                if (null == Peers)
                {
                    Peers = new Hashtable(topeerlist.Length);
                }

                foreach(PNUser user in topeerlist)
                {
                    Peers[user.UserId] = new PeerInfo(user);
                }
            }

lbDone:
            return;
        }

        /// <summary>
        /// Peer subscribe to a single user. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribeEx(PNUser topeer)
        {
            PeerSubscribeEx(new PNUser[] { topeer });
        }


        /// <summary>
        /// Peer subscribe to a list of users. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribeEx(PNUser[] topeerlist)
        {

            // Allow the caller to pass in null for testing purposes, just clear
            // the peer hash if there is one and skip hash updates
            if (null == topeerlist)
            {
                if (null != Peers)
                {
                    Peers.Clear();
                }

                goto lbDone;
            }

            // Update the hash with new peer info structures keeping existing
            // peer info unless we don't have any peer info yet in which case
            // we can do the cheaper straight import
            if (null != Peers && Peers.Count > 0)
            {
                Hashtable NewPeers = new Hashtable(topeerlist.Length);
                foreach (PNUser user in topeerlist)
                {
                    if (!Peers.Contains(user.UserId))
                    {
                        NewPeers[user.UserId] = new PeerInfo(user);
                    }
                    else
                    {
                        NewPeers[user.UserId] = Peers[user.UserId];
                    }
                }
                Peers = NewPeers;
            }
            else
            {
                if (null == Peers)
                {
                    Peers = new Hashtable(topeerlist.Length);
                }

                foreach (PNUser user in topeerlist)
                {
                    Peers[user.UserId] = new PeerInfo(user);
                }
            }

        lbDone:
            //Peer subscribe to connection server now?
            foreach (PNUser user in topeerlist)
            {
                //Basic subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetBasicPresenceDataObjectSpecifier(user.UserId) });
                //Rich subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetRichPresenceDataObjectSpecifier(user.UserId) });
            }
            return;
        }


        /// <summary>
        /// Add Peer subscription to an add list of users. Remove any subscriptions from the delete list.
        /// </summary>
        public void PeerSubscribeEx(PNUser[] Add, PNUser[] Delete)
        {
            if (Add == null)
            {
                Add = new PNUser[0];
            }
            if (Delete == null)
            {
                Delete = new PNUser[0];
            }

            //Unsubscribe from connection server now?
            foreach (PNUser user in Delete)
            {
                //Basic subscription
                this.Xbox.SendUnsubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetBasicPresenceDataObjectSpecifier(user.UserId) });
                //Rich subscription
                this.Xbox.SendUnsubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetRichPresenceDataObjectSpecifier(user.UserId) });
            }
            //Peer subscribe to connection server now?
            foreach (PNUser user in Add)
            {
                //Basic subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetBasicPresenceDataObjectSpecifier(user.UserId) });
                //Rich subscription
                this.Xbox.SendSubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetRichPresenceDataObjectSpecifier(user.UserId) });
            }


            // Update the hash with new peer info structures keeping existing
            // peer info unless we don't have any peer info yet in which case
            // we can do the cheaper straight import
            if (null != Peers && Peers.Count > 0)
            {
                Hashtable NewPeers = new Hashtable(Add.Length + Peers.Count);
                Hashtable Removed = new Hashtable(Delete.Length);
                foreach (PNUser user in Delete)
                {
                    if (Peers.Contains(user.UserId))
                    {
                        Removed.Add(user.UserId, Peers[user.UserId]);
                        Peers.Remove(user.UserId);
                    }
                }
                foreach (PNUser user in Add)
                {
                    ulong userId = user.UserId;
                    if (!Peers.Contains(userId))
                    {
                        if (Removed.Contains(userId))
                        {
                            NewPeers[userId] = Removed[userId];
                        }
                        else
                        {
                            NewPeers[userId] = new PeerInfo(user);
                        }
                    }
                    else
                    {
                        NewPeers[userId] = Peers[userId];
                    }
                }
                foreach (PeerInfo peer in Peers.Values)
                {
                    if (!NewPeers.Contains(peer.User.UserId))
                    {
                        NewPeers[peer.User.UserId] = peer;
                    }
                }
                Peers = NewPeers;
            }
            else
            {
                if (null == Peers)
                {
                    Peers = new Hashtable(Add.Length);
                }

                foreach (PNUser user in Add)
                {
                    Peers[user.UserId] = new PeerInfo(user);
                }
            }

            return;
        }

        /// <summary>
        /// Tear down any existing peer subscriptions on server.
        /// </summary>
        public void PeerUnsubscribe()
        {
            foreach (PeerInfo pi in Peers.Values)
            {
                PNUser user = pi.User;
                //Basic subscription
                this.Xbox.SendUnsubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetBasicPresenceDataObjectSpecifier(user.UserId) });
                //Rich subscription
                this.Xbox.SendUnsubscribeForUser(UserId, new DATA_OBJECT_SPECIFIER[] { GetRichPresenceDataObjectSpecifier(user.UserId) });
            }

            // Clear the peer lookup table
            Peers = null;
        }

        /// <summary>
        /// Test peer subscription state.
        /// </summary>
        public bool IsPeerSubscribed(PNUser topeer)
        {
            return IsPeerSubscribed(topeer.UserId);
        }

        /// <summary>
        /// Test peer subscription state.
        /// </summary>
        public bool IsPeerSubscribed(ulong toPuid)
        {
            if(null == Peers)
            {
                return false;
            }
            return Peers.Contains(toPuid);
        }

        /// <summary>
        /// Lookup a peer info tracking struct.
        /// </summary>
        public PeerInfo GetPeerInfo(ulong userId)
        {
            if(Peers != null)
            {
                return Peers[userId] as PeerInfo;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Tell WaitForInviteBlip that you are waiting for an additional
        /// invite. (Stores current invite sequence number)
        /// </summary>
        public void ExpectInviteBlip()
        {
            LastInviteBlipCount = LastQValPacket.InviteSequenceNum;
        }

        /// <summary>
        /// Wait for the invite count to go above the last stored invite 
        /// blip count (see ExpectInviteBlip()).
        /// </summary>
        public void WaitForInviteBlip()
        {
            DateTime abortTime = DateTime.Now.AddSeconds( DefaultNotificationWait );

            while( true )
            {
                uint blipCount = LastQValPacket.InviteSequenceNum;
                if( blipCount > LastInviteBlipCount )
                {
                    return;
                }

                if( DateTime.Now > abortTime )
                {
                    throw new TimeOutException( (ushort)DefaultNotificationWait, "User[" + UserId.ToString("x") + "] Timed out waiting for Invite blip" );
                }

            }
        }

        /// <summary>
        /// Send game session invitation to one or more users
        /// </summary>
        /// <param name="invited">Users to invite</param>
        public void Invite( PNUser[] invited, ulong sessionId )
        {
            // EnterSession sets the session ID and calls SetTitleData, prompting an update on the fakeSG
            // Since sent invites are revoked when a user's state changes, if the invite was sent here before the user's
            // session ID is updated on the SG, the invite is revoked
            // To work around this, we pass in a user who will peer subscribe and wait for a notification, indicating
            // that the invitor's state has changed.
            EnterSessionWithObserver(sessionId, false, invited[0]);

            // Send the invite. Sending as PMSG_INVITE_2, since PMSG_INVITE has been deprecated
            MsgDetails msgDetails = MsgDetails.CreateBlank();
            msgDetails.AddProperty(MsgDefs.XONLINE_MSG_PROP_SESSION_ID, MatchSessionId);
            PMsgInvite2 inviteMsg = new PMsgInvite2( this, invited, 0, 0, msgDetails );
            inviteMsg.TransactFD();

            // Populate the outgoing invite
            if(null == Invites)
            {
                Invites = new Hashtable();
            }

            InvitationInfo invite = new InvitationInfo(this, sessionId);
            invite.Owns     = true;
            invite.Invited  = invited;
            Invites[UserId] = invite;
        }

        /// <summary>
        /// Send game session invitation to one or more users with extra
        /// messaging parameters and/or competition/team data.
        /// </summary>
        /// <param name="invited">Users to invite</param>
        public void Invite2( PNUser[] invited, ulong sessionId, ulong senderContext, uint msgFlags, MsgDetails msgDetails )
        {
            EnterSessionWithObserver(sessionId, false, invited[0]);

            // Send the invite
            PMsgInvite2 inviteMsg = new PMsgInvite2( this, invited, senderContext, msgFlags, msgDetails );
            inviteMsg.TransactFD();

            // Populate the outgoing invite
            if(null == Invites)
            {
                Invites = new Hashtable();
            }

            InvitationInfo invite = new InvitationInfo(this, sessionId);
            invite.Owns     = true;
            invite.Invited  = invited;
            invite.Context  = senderContext;
            Invites[UserId] = invite;
        }

        /// <summary>
        /// Send acceptance of invitation to game session
        /// </summary>
        /// <param name="host">User that sent the invitations</param>
        public void AcceptInvite( PNUser host )
        {
            QValPacket qval = null;
            InvitationInfo invite = GetInvitationInfo(host.UserId);

            if(null == invite)
            {
                // Try to dequeue invitation if the users are friends
                // or retrieve the message if they are not.
                if(null != GetBuddyInfo(host.UserId))
                {
                    // Try to get the invitation info if it doesn't exist. This will throw if
                    // an invite is not available in NotificationWait seconds.
                    qval = WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
                    HandleQValPacket(qval);

                    invite = GetInvitationInfo(host.UserId);
                    if(null == invite || null == invite.Invitation)
                    {
                        throw new UnexpectedTestResultException("Invite qflag notification came in but invitation data was not available");
                    }
                    if(host.UserId != invite.Invitation.HostID)
                    {
                        throw new UnexpectedTestResultException("Got an invite but it was from wrong user: " + invite.Invitation.HostID.ToString("x"));
                    }
                }

                // Users should always receive an invite message
                qval = WaitForNewMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE);
                HandleQValPacket(qval, HQV_ReadMessages);

                invite = GetInvitationInfo(host.UserId);
                ValueCheck.TestNotNull("Invitation info after processing game invite qvals", invite);
            }

            // Send the answer
            PMsgInviteAnswer answerMsg = new PMsgInviteAnswer( this, host, true );
            answerMsg.TransactFD();

            // Change our virtual match session ID, notify presence of the change
            EnterSession(invite.MatchSession, false);

            // Cleanup our internal state
            if(null != Invites)
            {
                Invites.Remove(host.UserId);
            }

            // Remove the host invite if he is a buddy
            BuddyInfo buddy = GetBuddyInfo(host.UserId);
            if(null != buddy)
            {
                buddy.Invitation = null;
            }

            // Remove the host invite if he is a peer
            PeerInfo peer = GetPeerInfo(host.UserId);
            if(null != peer)
            {
                peer.Invitation = null;
            }

            // Remove any invite messages
            RemoveMessageInfo(invite.MessageId);
        }

        /// <summary>
        /// Lookup an invite tracking struct by host user ID
        /// </summary>
        public InvitationInfo GetInvitationInfo(ulong userId)
        {
            if(Invites != null)
            {
                return Invites[userId] as InvitationInfo;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Lookup an invite tracking struct by that is being hosted
        /// by this user. There can be only one.
        /// </summary>
        public InvitationInfo GetPendingOwnedInvite()
        {
            IDictionaryEnumerator enumerator = InviteEnumerator;
            while(enumerator.MoveNext())
            {
                InvitationInfo info = enumerator.Value as InvitationInfo;
                if(info.Owns)
                {
                    return info;
                }
            }

            // Could not find owned outgoing invite
            return null;
        }

        /// <summary>
        /// Check to see if an invite is pending from a buddy.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvitedFromBuddy(PNUser host)
        {
            BuddyInfo buddy = GetBuddyInfo(host.UserId);
            return (buddy != null) && (buddy.Invitation != null);
        }

        /// <summary>
        /// Check to see if an invite is pending from a peer.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvitedFromPeer(PNUser host)
        {
            PeerInfo peer = GetPeerInfo(host.UserId);
            return (peer != null) && (peer.Invitation != null);
        }

        /// <summary>
        /// Check to see if an invite is pending from anyone at all.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvited(PNUser host)
        {
            return IsInvitedFromBuddy(host) || IsInvitedFromPeer(host);
        }

        /// <summary>
        /// Look for unanswereqd pending invite
        /// </summary>
        public bool HasUnAnsweredInvite()
        {
            IDictionaryEnumerator enumerator = InviteEnumerator;
            while(enumerator.MoveNext())
            {
                InvitationInfo info = enumerator.Value as InvitationInfo;
                if(info.Owns)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Send rejection of invitation to game session
        /// </summary>
        /// <param name="host">User that sent the invitations</param>
        public void RejectInvite( PNUser host )
        {
            RejectInvite( host, false );
        }

        /// <summary>
        /// Reject a pending invite.
        /// </summary>
        /// <param name="host">User that sent the invitations</param>
        /// <param name="never">Add host to user's never list</param>
        public void RejectInvite( PNUser host, bool never )
        {
            ushort reply = (never ? XonPresNoti.PINVITE_REPLY_NEVER : XonPresNoti.PINVITE_REPLY_NO);
            PMsgInviteAnswer answerlMsg = new PMsgInviteAnswer( this, host, reply );
            answerlMsg.TransactFD();

            BuddyInfo buddy = GetBuddyInfo(host.UserId);
            if(null != buddy)
            {
                buddy.Invitation = null;
            }

            PeerInfo peer = GetPeerInfo(host.UserId);
            if(null != peer)
            {
                peer.Invitation = null;
            }

            if(null != Invites)
            {
                Invites.Remove(host.UserId);
            }
        }

        /// <summary>
        /// Send revocation of game session invitation to one or more users
        /// </summary>
        /// <param name="invited">Users no longer invited</param>
        public void CancelInvite( PNUser[] invited )
        {
            PMsgCancelInvite cancelMsg = new PMsgCancelInvite( this, invited );
            cancelMsg.TransactFD();

            LeaveSession();

            if(null != Invites)
            {
                Invites.Remove(this.UserId);
            }
        }

        /// <summary>
        /// If we are not already in a session this will cause this user
        /// to appear to enter a session.
        /// </summary>
        public void EnterSession(ulong sessionId, bool joinable)
        {
            if(sessionId != MatchSessionId)
            {
                uint state = State;
                state |= XonPresNoti.P_STATE_MASK_PLAYING;

                if(joinable)
                {
                    state |= XonPresNoti.P_STATE_MASK_JOINABLE;
                }

                SetTitleData(state, sessionId, TitleStuff);
            }
        }

        /// <summary>
        /// Enter session and wait for the observer to receive a notification
        /// </summary>
        public void EnterSessionWithObserver(ulong sessionId, bool joinable, PNUser observer)
        {
            if (sessionId != MatchSessionId)
            {
                uint state = State;
                state |= XonPresNoti.P_STATE_MASK_PLAYING;

                if (joinable)
                {
                    state |= XonPresNoti.P_STATE_MASK_JOINABLE;
                }

                SetTitleDataWait(state, sessionId, observer);
            }
        }

        /// <summary>
        /// Make it appear to presence and reporting that we have left any session
        /// that we might have been a part of
        /// </summary>
        public void LeaveSession()
        {
            if(0 != MatchSessionId )
            {
                uint state = State;
                state &= ~(XonPresNoti.P_STATE_MASK_PLAYING|XonPresNoti.P_STATE_MASK_JOINABLE);
                SetTitleData(state, 0, TitleStuff);
            }
        }

        /// <summary>
        /// Lookup a stored message tracking struct by the message ID.
        /// </summary>
        public MessageInfo GetMessageInfo(uint msgId)
        {
            if(null != Messages)
            {
                return Messages[msgId] as MessageInfo;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Lookup all stored message tracking structs by the sending user ID.
        /// </summary>
        public MessageInfo[] GetMessageInfoFrom(PNUser sender)
        {
            return GetMessageInfoTypeFrom(sender, 0);
        }

        /// <summary>
        /// Lookup all stored message tracking structs by the sending user ID and message type.
        /// If the message type is 0 all messages from this user will be returned.
        /// </summary>
        public MessageInfo[] GetMessageInfoTypeFrom(PNUser sender, byte msgType)
        {
            ArrayList messages = new ArrayList();
            IDictionaryEnumerator enumerator = MessageEnumerator;

            while(enumerator.MoveNext())
            {
                MessageInfo info = enumerator.Value as MessageInfo;
                if(info.Message != null && info.Message.SenderID == sender.UserId)
                {
                    if(0 == msgType || msgType == info.Message.Type)
                    {
                        messages.Add(info);
                    }
                }
            }

            return (MessageInfo[])messages.ToArray(typeof(MessageInfo));
        }

        /// <summary>
        /// Delete a message by it's ID. Also removes any tracking structs.
        /// </summary>
        public uint DeleteMessage(uint msgId)
        {
            uint hr = HResult.S_OK;
            PNMsg replyMsg;
            QMsgDeleteMsg deleteMsg = new QMsgDeleteMsg( this, msgId, 0 );
            deleteMsg.TransactFD(out replyMsg);

            QDeleteMsgReplyMsgData deleteReplyData = (QDeleteMsgReplyMsgData)(replyMsg.Data);
            hr = deleteReplyData.HR;

            if(HResult.Failed(hr))
            {
                RO.Error("DeleteMessage[{0:x}]: failed for MsgId: {1:x}, HR: 0x{2:x8}",
                        UserId,
                        msgId,
                        hr);
            }
            else
            {
                RemoveMessageInfo(msgId);
            }

            return hr;
        }

        /// <summary>
        /// Remove messages that have been revoked or deleted on the server (we have received
        /// a deleted message qval for this message ID)
        /// </summary>
        public void RemoveDeletedMessages()
        {
            IDictionaryEnumerator enumerator = MessageEnumerator;
            ArrayList toRemove = new ArrayList();
            while(enumerator.MoveNext())
            {
                MessageInfo info = enumerator.Value as MessageInfo;
                if(info.Deleted)
                {
                    toRemove.Add(info);
                }
            }

            foreach(MessageInfo info in toRemove)
            {
                Messages.Remove(info.Id);
            }
        }

        /// <summary>
        /// For all tracking message structs delete the message on the server. Also
        /// removes tracking struct and returns the array of hresults returned from
        /// DeleteMessage().
        /// </summary>
        public uint[] DeleteAllMessages()
        {
            uint []hresults = null;
            if(null != Messages && Messages.Values.Count > 0)
            {
                hresults = new uint[Messages.Values.Count];
                uint i = 0;
                IDictionaryEnumerator enumerator = MessageEnumerator;

                while(enumerator.MoveNext())
                {
                    MessageInfo info = enumerator.Value as MessageInfo;
                    if(null != info)
                    {
                        hresults[i] = DeleteMessage(info.Id);
                    }

                    i++;
                }
            }

            return hresults;
        }

        /// <summary>
        /// Remove a message tracking struct.
        /// </summary>
        public void RemoveMessageInfo(uint msgId)
        {
            if(null != Messages && Messages.Contains(msgId))
            {
                Messages.Remove(msgId);
            }
        }

        /// <summary>
        /// Send addition to list of voice blocked users
        /// </summary>
        /// <param name="block">User to shut up</param>
        public void Mute( PNUser block )
        {
            PMsgBlockVoice blockMsg = new PMsgBlockVoice( this, block );
            blockMsg.TransactFD();

            Blocks.Add( block.UserId );
            if( Blocks.Count > 250 )
            {
                Blocks.RemoveRange( 0, 25 );
            }

            BlockListVer++;
        }

        /// <summary>
        /// Send deletion from list of voice blocked users
        /// </summary>
        /// <param name="unblock">User to listen to again</param>
        public void UnMute( PNUser unblock )
        {
            PMsgUnblockVoice unBlockMsg = new PMsgUnblockVoice( this, unblock );
            unBlockMsg.TransactFD();

            Blocks.Remove( unblock.UserId );

            BlockListVer++;
        }

        /// <summary>
        /// Send deletion from all voice blocked users
        /// </summary>
        public void UnMuteAll()
        {
            PMsgUnblockVoice unBlockMsg = new PMsgUnblockVoice(this);
            unBlockMsg.TransactFD();

            Blocks.Clear();

            BlockListVer++;
        }

        public void AddUsersToNeverList(ushort count, ulong[] usersToAdd)
        {
            //setup the request object
            AddUsersToNeverListMsg req = new AddUsersToNeverListMsg();
            req.qwUserID = this.UserId;
            req.rgqwNeverListUsers = usersToAdd;
            req.cNeverListUserCount = count;

            //get and send in the SG slot
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = UserId;
            slot.machinePuid = this.Xbox.XboxId;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = this.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = this.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = this.Xbox.XboxId;


            //setup the response object
            XRLObject2 resp = new XRLObject2();

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            if (hr != HResult.S_OK)
                throw new HResultException(hr, string.Format("AddUsersToNeverList failed. Recieved hr = {0}", hr.ToString("X8")));
        }

        public void RemoveUsersFromNeverList(ushort count, ulong[] usersToRemove)
        {
            //setup the request object
            RemoveUsersFromNeverListMsg req = new RemoveUsersFromNeverListMsg();
            req.qwUserID = this.UserId;
            req.rgqwNeverListUsers = usersToRemove;
            req.cNeverListUserCount = count;

            //get and send in the SG slot
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = UserId;
            slot.machinePuid = this.Xbox.XboxId;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = this.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = this.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = this.Xbox.XboxId;

            //setup the response object
            XRLObject2 resp = new XRLObject2();

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            if (hr != HResult.S_OK)
                throw new HResultException(hr, string.Format("RemoveUsersFromNeverList failed. Recieved hr = {0}", hr.ToString("X8")));
        }

        public uint[] CanSendMessageToUsers(ushort count, ulong[] usersToCheck)
        {
            //setup the request object
            CanSendMessageToUsersMsg req = new CanSendMessageToUsersMsg();

            req.qwUserID = this.UserId;
            req.rgqwUsers = usersToCheck;
            req.cUserListCount = count;

            //get and send in the SG slot
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = UserId;
            slot.machinePuid = this.Xbox.XboxId;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = this.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = this.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = this.Xbox.XboxId;

            //setup the response object
            CanSendMessageToUsersResponse replyData = new CanSendMessageToUsersResponse();
            XRLObject2 resp = replyData;

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            if (hr != HResult.S_OK)
                throw new HResultException(hr, string.Format("CanSendMessageToUsers failed. Recieved hr = {0}", hr.ToString("X8")));

            return replyData.rghrResponses;
        }

        /// <summary>
        /// Sets the Console Type Bits in the Local State
        /// </summary>
        private void AddConsoleStateInfo(ref uint state)
        {
            state &= ~XonPresNoti.P_STATE_MASK_CONSOLE_TYPE;
            switch(this.Xbox.ClientType)
            {
                case CSGInfo.ClientType.Xenon:
                    state |= XonPresNoti.P_STATE_ENUM_CONSOLE_XENON;
                    break;
                case CSGInfo.ClientType.PC:
                    state |= XonPresNoti.P_STATE_ENUM_CONSOLE_WINPC;
                    break;
//                case CSGInfo.ClientType.XenonBackCompat:
                default:
                    throw new ApplicationException("Invalid ClientType");
            }
        }

        /// <summary>
        /// Send current state flags, match session and Title data to server
        /// </summary>
        public void SetTitleData()
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
            if(null != _GIBlob)
            {
                SetTitleData( state, MatchSessionId, _GIBlob.GetBytes() );
            }
            else
            {
                SetTitleData( state, MatchSessionId, TitleStuff );
            }
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title
        /// data to server
        /// </summary>
        /// <param name="state">New state flags</param>
        public void SetTitleData( uint state )
        {
            uint internalstate = state;
            AddConsoleStateInfo(ref internalstate);

            if(null != _GIBlob)
            {
                SetTitleData(internalstate, MatchSessionId, _GIBlob.GetBytes());
            }
            else
            {
                SetTitleData(internalstate, MatchSessionId, TitleStuff);
            }
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title
        /// data to server
        /// </summary>
        /// <param name="matchId">New match session ID</param>
        public void SetTitleData( ulong matchId )
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
            if (null != _GIBlob)
            {
                SetTitleData( state, matchId, _GIBlob.GetBytes() );
            }
            else
            {
                SetTitleData( state, matchId, TitleStuff );
            }
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title
        /// data to server
        /// </summary>
        /// <param name="titleStuff">New title data</param>
        public void SetTitleData( byte[] titleStuff )
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
            SetTitleData(state, MatchSessionId, titleStuff);
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title
        /// data to server
        /// </summary>
        /// <param name="state">New state flags</param>
        /// <param name="matchId">New match session ID</param>
        /// <param name="titleStuff">New title data</param>
        public void SetTitleData( uint state, ulong matchSessionId, byte[] titleStuff )
        {
            State          = state;
            MatchSessionId = matchSessionId;
            TitleStuff     = titleStuff;

            if(Xbox.ConnectedToFakeSG && LoggedOn)
            {
                GlobalFakeSG.FakeSG.SetUserState(Xbox.XboxId, UserId, matchSessionId, state, titleStuff, (ushort)titleStuff.Length);
            }
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title
        /// data to server. The observer subscribes to the user and waits to receive a notification
        /// that state has changed.
        /// </summary>
        /// <param name="state">New state flags</param>
        /// <param name="matchId">New match session ID</param>
        private void SetTitleDataWait(uint state, ulong matchSessionId, PNUser observer)
        {
            if (State == state && MatchSessionId == matchSessionId)
            {
                return;
            }
            
            State = state;
            MatchSessionId = matchSessionId;
            
            if (observer.LoggedOn && LoggedOn)
            {
                observer.AddPeerSubscription(this);
            }

            if (Xbox.ConnectedToFakeSG && LoggedOn)
            {
                GlobalFakeSG.FakeSG.SetUserState(Xbox.XboxId, UserId, matchSessionId, state, TitleStuff, (ushort)TitleStuff.Length);
                if (observer.LoggedOn)
                {
                    try
                    {
                        UserNotification n = observer.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
                        HandleTCPNotification(n);
                    }
                    catch (TimeOutException)
                    {
                        RO.Warn("Timed out waiting for notification");
                    }
                }
                else
                {
                    // Wait for FakeSG to send sgnotifyupdate request
                    Thread.Sleep(5000);
                }
            }
        }

        /// <summary>
        /// Get web friends direct from FD (not webcache)
        /// </summary>
        public PWebFriendReplyMsgData GetWebFriends()
        {
            PNMsg replyMsg;
            PMsgWebFriends webFriendMsg = new PMsgWebFriends( this );
            webFriendMsg.TransactFD(out replyMsg);

            PWebFriendReplyMsgData replyData = (PWebFriendReplyMsgData) replyMsg.Data;

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Get Web Friends LimitedPresence HR = 0x"+replyData.HR.ToString( "X8" ) );

            ValueCheck.Test( "UserId", UserId, replyData.UserID );

            return replyData;
        }

        /// <summary>
        /// Get web friends direct from FD (not webcache)
        /// </summary>
        public PFriendsLimitedPresenceReplyMsgData GetFriendsLimitedPresence()
        {
            PNMsg replyMsg;
            PMMsgFriendsLimitedPresence friendsLimitedPresence = new PMMsgFriendsLimitedPresence(this);
            friendsLimitedPresence.TransactFD(out replyMsg);

            PFriendsLimitedPresenceReplyMsgData replyData = (PFriendsLimitedPresenceReplyMsgData)replyMsg.Data;

            if (replyData.HR!= HResult.S_OK)
                throw new HResultException(replyData.HR, "Get Web Friends HR = 0x" + replyData.HR.ToString("X8"));

            ValueCheck.Test("UserId", UserId, replyData.UserID);

            return replyData;
        }


        /// <summary>
        /// Get web friends direct from FD (not webcache)
        /// </summary>
        public PFriendsNoPresenceReplyMsgData GetFriendsNoPresence()
        {
            PNMsg replyMsg;
            PMMsgFriendsNoPresence friendsNoPresence = new PMMsgFriendsNoPresence(this);
            friendsNoPresence.TransactFD(out replyMsg);

            PFriendsNoPresenceReplyMsgData replyData = (PFriendsNoPresenceReplyMsgData)replyMsg.Data;

            if (replyData.HR != HResult.S_OK)
                throw new HResultException(replyData.HR, "Get Friends No Presence HR = 0x" + replyData.HR.ToString("X8"));

            ValueCheck.Test("UserId", UserId, replyData.UserID);

            return replyData;
        }

        /// <summary>
        /// Get web friends direct from FD (not webcache)
        /// </summary>
        public PGetFriendsListReplyMsgData GetFriendsList(PNUser target)
        {
            PMsgGetFriendsList pMsg = new PMsgGetFriendsList(this, target);
            PNMsg reply;
            pMsg.TransactFD(out reply);
            PGetFriendsListReplyMsgData replyData = (PGetFriendsListReplyMsgData)(reply.Data);

            if (replyData.HR != HResult.S_OK)
                throw new HResultException(replyData.HR, "Get Friends List HR = 0x" + replyData.HR.ToString("X8"));

            return replyData;
        }

        /// <summary>
        /// Get a user's friends list directly from social query FD and matches the passed in HR.
        /// </summary>
        public GetFriendsXrlResponse GetFriendsList(ulong requestingXuid,
            ulong ownerXuid,
            GetFriendSortType sortType,
            int pageSize,
            int pageStart,
            uint expectedResult)
        {
            return GetFriendsList(requestingXuid,
                ownerXuid,
                sortType,
                0,
                0,
                pageSize,
                pageStart,
                expectedResult);
        }
        public GetFriendsXrlResponse GetFriendsList(ulong requestingXuid, 
            ulong ownerXuid, 
            GetFriendSortType sortType, 
            uint titleId,
            ushort localeId,
            int pageSize, 
            int pageStart, 
            uint expectedResult)
        {
            //setup the request object
            GetFriendsXrlRequest req = new GetFriendsXrlRequest();
            req.RequestorXuid = requestingXuid;
            req.OwnerXuid = ownerXuid;
            req.SortType = sortType;
            req.TitleId = titleId;
            req.LocaleId = localeId;
            req.PagingInfo = new PagingInfo();
            req.PagingInfo.PageSize = pageSize;
            req.PagingInfo.PageStart = pageStart;

            //get and send in the SG slot
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = UserId;

            //setup the response object
            GetFriendsXrlResponse replyData = new GetFriendsXrlResponse();
            XRLObject2 resp = replyData;

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.SocialQuery, false, req.Xrl, req, ref resp);
            if (hr != expectedResult)
                throw new HResultException(hr, string.Format("Get User List returned an unexpected HR. Expected hr = {0}. Recieved = {1}", expectedResult.ToString("X8"), hr.ToString("X8")));

            return replyData;
        }

        /// <summary>
        /// Get a user's friends list directly from social query FD
        /// </summary>
        public GetFriendsXrlResponse GetFriendsList(GetFriendSortType sortType, int pageSize, int pageStart)
        {
            return GetFriendsList(this.UserId, this.UserId, sortType, pageSize, pageStart, HResult.S_OK);
        }

        /// <summary>
        /// Request another user's friends list directly from social query FD
        /// </summary>
        public GetFriendsXrlResponse GetFriendsList(ulong ownerXuid, int pageSize, int pageStart)
        {
            return GetFriendsList(this.UserId, ownerXuid, GetFriendSortType.OnlineStatus, pageSize, pageStart, HResult.S_OK);
        }

        /// <summary>
        /// Request another user's friends list sorted by parameter directly from social query FD
        /// </summary>
        public GetFriendsXrlResponse GetFriendsList(ulong ownerXuid, GetFriendSortType sortType, int pageSize, int pageStart)
        {
            return GetFriendsList(this.UserId, ownerXuid, sortType, pageSize, pageStart, HResult.S_OK);
        }

        /// <summary>
        /// Use datacenter port to query presence info for a target.
        /// </summary>
        public ServerTestFramework.LiveService.Presence.PresenceInfo GetPresenceInfo(PNUser target)
        {
            PMsgGetPresenceInfo req = new PMsgGetPresenceInfo(this, target);
            PNMsg rep;

            req.TransactFD(out rep);

            PPresenceInfoReplyMsgData repData = (PPresenceInfoReplyMsgData)rep.Data;
            if(null != repData && null != repData.rgUsers && repData.cdwUsers > 0)
            {
                return repData.rgUsers[0];
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Get host sesion data, including windosk endpoint
        /// </summary>
        /// <param name="host">User being asked about</param>
        /// <param name="sessInfo">Session data retrieved</param></param>
        public void GetPeerSession( PNUser host, out XSessionInfo sessInfo )
        {
            PNMsg replyMsg;
            PMsgPeerSession peerSessionMsg = new PMsgPeerSession( this, host );
            peerSessionMsg.TransactFD(out replyMsg);

            PPeerSessionReplyMsgData psReplyMsg = (PPeerSessionReplyMsgData) replyMsg.Data;

            if( psReplyMsg.HostUserID != host.UserId )
            {
                throw new Exception( "got peer session info reply for wrong host" );
            }

            sessInfo = new XSessionInfo();
            sessInfo.TitleId     = psReplyMsg.TitleID;
            sessInfo.TitleVer    = psReplyMsg.TitleVersion;
            sessInfo.TitleRegion = psReplyMsg.TitleRegion;
            sessInfo.XnAddr      = psReplyMsg.XnAddr;
            sessInfo.XnKId       = psReplyMsg.XnKId;
            sessInfo.XnKey       = psReplyMsg.XnKey;
        }

        /// <summary>
        /// Checks for outgoing buddy request
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>A request has been sent to buddy</returns>
        public bool BuddyStatusPending( PNUser buddy )
        {
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_PENDING );
        }

        /// <summary>
        /// Checks for incoming buddy request
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>A request has come from buddy</returns>
        public bool BuddyStatusRequested( PNUser buddy )
        {
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_REQUEST );
        }

        /// <summary>
        /// Checks for established buddy relationship
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>User is a fully accepted buddy</returns>
        public bool BuddyStatusOK( PNUser buddy )
        {
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_OK );
        }

        /// <summary>
        /// Checks for specified buddy stats
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <param name="status">Status being checked for</param>
        /// <returns>Is a user a buddy with the given status</returns>
        public bool BuddyStatus( PNUser buddy, byte status )
        {
            BuddyInfo info = GetBuddyInfo(buddy.UserId);
            return (info != null) && (info.Status == status);
        }

        /// <summary>
        /// Checks for existence of buddy list entry (regardless of Status)
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>User is in buddy list</returns>
        public bool IsBuddy( PNUser buddy )
        {
            BuddyInfo info = GetBuddyInfo(buddy.UserId);
            return (info != null) && (info.Status != XonPresNoti.NOT_A_BUDDY);
        }

        static public void MutualWaitForDelete(PNUser sender, PNUser receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.NOT_A_BUDDY );
        }

        static public void MutualWaitForSentRequest(PNUser sender, PNUser receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_PENDING );
        }

        static public void MutualWaitForRecvRequest(PNUser sender, PNUser receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_REQUEST );
        }

        static public void MutualWaitForFullFriend(PNUser sender, PNUser receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_OK );
        }

        /// <summary>
        /// Wait for a buddy request to a user to be confirmed
        /// </summary>
        /// <param name="buddy">User request was sent to</param>
        public void WaitForBuddyStatusPending( PNUser buddy )
        {
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_PENDING );
        }

        /// <summary>
        /// Wait for a buddy request from a user to come in
        /// </summary>
        /// <param name="buddy">User that made request</param>
        public void WaitForBuddyStatusRequested( PNUser buddy )
        {
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_REQUEST );
        }

        /// <summary>
        /// Wait for an accepted buddy request to be confirmed
        /// </summary>
        /// <param name="buddy">User that either made or accepted the request</param>
        public void WaitForBuddyStatusOK( PNUser buddy )
        {
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_OK );
        }

        /// <summary>
        /// Wait for a buddy deletion to be confirmed.
        /// </summary>
        /// <param name="buddy">User that is to be removed</param>
        public void WaitForBuddyStatusDeleted( PNUser buddy )
        {
            WaitForBuddyStatus( buddy, XonPresNoti.NOT_A_BUDDY );
        }

        /// <summary>
        /// Waits and watches Qflags and gets list change and buddy request notifications
        /// (if flags indicate the need to) in order to try for specified buddy stats.
        /// </summary>
        /// <param name="buddy">User waiting on</param>
        /// <param name="status">Satus being watied for</param>
        static public void MutualWaitForStatus( PNUser sender, PNUser receiver, byte status )
        {
            DateTime abortTime = DateTime.Now.AddSeconds(DefaultNotificationWait);

            while (true)
            {

                sender.ProcessQVals();
                receiver.ProcessQVals();

                BuddyInfo sendbi = sender.GetBuddyInfo(receiver.UserId);
                BuddyInfo recvbi = receiver.GetBuddyInfo(sender.UserId);

                if (status == XonPresNoti.NOT_A_BUDDY)
                {
                    // Check if buddy is absent or irelevant
                    if (((sendbi == null) || (sendbi.Status == XonPresNoti.NOT_A_BUDDY)) &&
                        ((recvbi == null) || (recvbi.Status == XonPresNoti.NOT_A_BUDDY)))
                    {
                        break;
                    }
                }
                else if (status == XonPresNoti.P_BUDDY_STATUS_OK)
                {
                    if ((sendbi != null && sendbi.Status == status &&
                          recvbi != null && recvbi.Status == status))
                    {
                        break;
                    }
                }
                else
                {
                    // Check if buddy is present and relevant
                    if ((sendbi != null && sendbi.Status == status &&
                         recvbi != null && recvbi.Status == 3 - status))
                    {
                        break;
                    }
                }

                if (DateTime.Now > abortTime)
                {
                    string message = String.Format("MutualWaitforBuddyStatus(): Sender: {0:x} and Receiver: {1:x} timed out {2} seconds waiting for buddy status: {3}",
                            sender.UserId,
                            receiver.UserId,
                            DefaultNotificationWait,
                            XonPresNoti.BuddyStatusToString(status));
                    throw new TimeOutException((ushort)DefaultNotificationWait, message);
                }


                Thread.Sleep(NotificationPollingInterval);
            }
        }

        /// <summary>
        /// Waits and watches Qflags and gets list change and buddy request notifications
        /// (if flags indicate the need to) in order to try for specified buddy stats.
        /// </summary>
        /// <param name="buddy">User waiting on</param>
        /// <param name="status">Satus being watied for</param>
        public void WaitForBuddyStatus( PNUser buddy, byte status )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( DefaultNotificationWait );

            while( true )
            {
                ProcessQVals();

                BuddyInfo bi = GetBuddyInfo(buddy.UserId);
                if( status == XonPresNoti.NOT_A_BUDDY )
                {
                    // Check if buddy is absent or irelevant
                    if( (bi == null) || (bi.Status == XonPresNoti.NOT_A_BUDDY) )
                    {
                        break;
                    }
                }
                else
                {
                    // Check if buddy is present and relevant
                    if( (bi != null) && (bi.Status == status) )
                    {
                        break;
                    }
                }

                if( DateTime.Now > abortTime )
                {
                    string message = String.Format("WaitForBuddyStatus(): User: {0:x} timed out {1} seconds waiting for buddy status: {2} on user {3:x}",
                            UserId,
                            DefaultNotificationWait,
                            XonPresNoti.BuddyStatusToString(status),
                            buddy.UserId);
                    throw new TimeOutException( (ushort)DefaultNotificationWait, message);
                }

                Thread.Sleep( NotificationPollingInterval );
            }
        }

        public enum PresenceFields
        {
            SessionID = 0x1,
            NickName = 0x2,
            State = 0x4,
            TitleID = 0x8,
            TitleData = 0x10,
            All = 0x1F
        }

        /// <summary>
        /// Gets and processes List Change notification queue items
        /// </summary>
        public void GetListChangeNotifications()
        {
            GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
        }

        /// <summary>
        /// Gets and processes Buddy Request notification queue items
        /// </summary>
        public void GetBuddyRequestNotifications()
        {
            GetNotifications(XonPresNoti.PQUEUE_BUDDY_REQ);
        }

        /// <summary>
        /// Gets and processes Invite notification queue items
        /// </summary>
        public void GetInviteNotifications()
        {
            GetNotifications( XonPresNoti.PQUEUE_INVITE );
        }

        /// <summary>
        /// Gets and processes Invite Answer notification queue items
        /// </summary>
        public void GetInviteAnswerNotifications()
        {
            GetNotifications( XonPresNoti.PQUEUE_INVITE_ANSWER );
        }

        public List<UserNotification> GetRawNotifications(DATA_TYPES notificationType)
        {
            List<UserNotification> result = new List<UserNotification>();
            Xbox.GetUserNotificationFromQueue(UserId, out result);
            return result;
        }

        public ListItem[] GetRawQVals(ushort qType)
        {
            QDequeueReplyMsgData reply = DequeueNotifications(qType);
            return reply.Items;
        }

        /// <summary>
        /// Provide granular control over the dequeue message
        /// </summary>
        /// <param name="qType">Queue to dequeue from</param>
        /// <returns>Dequeue reply data</returns>/
        public QDequeueReplyMsgData DequeueNotifications(ushort qType)
        {
            return DequeueNotifications(qType, 0, 100, UInt16.MaxValue);
        }

        /// <summary>
        /// Provide granular control over the dequeue message
        /// </summary>
        /// <param name="qType">Queue to dequeue from</param>
        /// <param name="startItemID">Item in queue to start with</param>
        /// <param name="maxItems">Max items to return</param>
        /// <param name="maxTotalItemsDataSize">Max total payload data size to return in bytes</param>
        /// <returns>Dequeue reply data</returns>/
        public QDequeueReplyMsgData DequeueNotifications(ushort qType, uint startItemID, ushort maxItems, uint maxTotalItemDataSize)
        {
            uint left = 100;
            QDequeueReplyMsgData reply = null;

            // Spool the dequeue requests
            while (0 != left)
            {
                ServerTestFramework.LiveService.Notification.ListItem[] replyLists = null;
                if (qType == XonPresNoti.PQUEUE_PRESENCE_2)
                {
                    throw new Exception("Only messaging is allowed to call this.");
                }
                else
                {
                    QMsgDequeue dequeueMsg = new QMsgDequeue(this, qType, startItemID, maxItems, maxTotalItemDataSize);
                    PNMsg replyMsg;
                    dequeueMsg.TransactFD(out replyMsg);

                    reply = (QDequeueReplyMsgData)replyMsg.Data;

                    if (HResult.Failed(reply.Hdr.HR))
                    {
                        RO.Error("DequeueNotifications[{0:x}]: failed with HR: 0x{1:x8} ({2})",
                                UserId,
                                reply.Hdr.HR,
                                Global.XErrToString(reply.Hdr.HR));

                        break;
                    }

                    ValueCheck.Test("Dequeue QType", qType, reply.Hdr.QType);
                    ValueCheck.Test("Dequeue UserId", UserId, reply.Hdr.UserID);
                    ValueCheck.Test("Dequeue QValCount", (uint)15, reply.Hdr.QValsLen);
                    replyLists = reply.Items;

                    // Figure out how many items we have left to dequeue
                    left = reply.Hdr.QLeft;

                }

                // TODO-jacobr: Copy the updated qval data into our local qval data, this requires some more
                // work in order to requeue these qvals.
                //
                //_LastQValPacket.Data = reply.Hdr.QVals;
                //_LastQValPacket.DeliveryTime = DateTime.Now;

                //RO.Debug("DequeueNotifications: QVals updated from dequeue: Sequence: {0}, Flags: 0x{1:x8} ({2})",
                //_LastQValPacket.QValSequenceNum,
                //_LastQValPacket.QFlags,
                //XonPresNoti.BuildQFlagsString(_LastQValPacket.QFlags));

                // Distill the raw notification items
                ProcessDequeue(qType, replyLists);
            }

            return reply;
        }

        /// <summary>
        /// Gets and processes notification queue items
        /// </summary>
        /// <param name="qType">ID of Queue to get items from</param>
        public void GetNotifications(ushort qType)
        {
            // Dequeue all of the notifications (this will send them
            // through an internal process that changes state based
            // on the ListIems
            DequeueNotifications(qType);
        }

        /// <summary>
        /// Wait for next message (any).
        /// </summary>
        public QValPacket WaitForNewMessage()
        {
            return WaitForNewMessage(0, 0);
        }

        /// <summary>
        /// Wait for a specific type of message to be delivered to the user.
        /// </summary>
        public QValPacket WaitForNewMessageType(byte messageType)
        {
            return WaitForNewMessage((uint)(messageType << 24), 0xff000000);
        }

        /// <summary>
        /// Wait for a message matching data flags to appear in the 0th slot of the
        /// messaging qvals. Passing zero will return the first non-zero qval.
        /// </summary>
        public QValPacket WaitForNewMessage(uint dataFlags, uint dataMask)
        {
            DateTime abortTime = DateTime.Now.AddSeconds( DefaultNotificationWait );
            QValPacket retPacket = null;

            if (Verbose)
            {
                RO.Debug("WaitForNewMessage[{0:x}]: Waiting on new data: 0x{1:x8} ({2})",
                    UserId,
                    dataFlags,
                    XonPresNoti.BuildMsgNotificationFlagsString(dataFlags));
            }

            while (true)
            {
                if (DateTime.Now > abortTime)
                {
                    throw new TimeOutException((ushort)DefaultNotificationWait, "User[" + UserId.ToString("x") + "] Timed out waiting for new message qval, dataFlags: " + dataFlags.ToString("x8"));
                }

                // Get all delivered qvals for this timeslice
                while (Xbox.ReadUserQValPacket(UserId, out retPacket))
                {
                    for (uint i = 0; i < 3; ++i)
                    {
                        if ((0 != retPacket.NewMessageId(i)) && (dataFlags == (retPacket.NewMessageData(i) & dataMask)))
                        {
                            // got match
                            goto lbFinished;
                        }
                    }

                    // Unmatched packets should still be processed, just warn when
                    // we have some actual flags that will be acted on but were not
                    // caught by the flags filter
                    if (retPacket.QFlags != 0)
                    {
                        RO.Warn("WaitForNewMessage[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3}) Ids({4}, {5}, {6}), Data({7:x8}, {8:x8}, {9:x8})",
                            UserId,
                            retPacket.QValSequenceNum,
                            retPacket.QFlags,
                            XonPresNoti.BuildQFlagsString(retPacket.QFlags),
                            retPacket.NewMessageId(0),
                            retPacket.NewMessageId(1),
                            retPacket.NewMessageId(2),
                            retPacket.NewMessageData(0),
                            retPacket.NewMessageData(1),
                            retPacket.NewMessageData(2));
                    }

                    HandleQValPacket(retPacket);
                }

                Thread.Sleep(NotificationPollingInterval);
            }
        lbFinished:

            return retPacket;
        }

        /// <summary>
        /// Wait for a non-zero message ID on the deleted message qval payload
        /// </summary>
        public QValPacket WaitForDeletedMessage()
        {
            return WaitForDeletedMessage(0xffffffff);
        }

        /// <summary>
        /// Wait for a specific message ID on the deleted message qval payload
        /// </summary>
        public QValPacket WaitForDeletedMessage(uint msgId)
        {
            DateTime abortTime = DateTime.Now.AddSeconds( DefaultNotificationWait );
            QValPacket retPacket = null;

            if (Verbose)
            {
                RO.Debug("WaitForDeletedMessage[{0:x}]: Waiting on deleted message", UserId);
            }

            while (true)
            {
                if (DateTime.Now > abortTime)
                {
                    throw new TimeOutException((ushort)DefaultNotificationWait, "User[" + UserId.ToString("x") + "] Timed out waiting for new message qval");
                }

                // Get all delivered qvals for this timeslice
                while (Xbox.ReadUserQValPacket(UserId, out retPacket))
                {
                    // Match any message first, specific message after
                    if (msgId == 0xffffffff && retPacket.DeletedMessageId(0) != 0)
                    {
                        goto lbFinished;
                    }
                    else if (retPacket.DeletedMessageId(0) == msgId)
                    {
                        goto lbFinished;
                    }
                    else
                    {
                        // Unmatched packets should still be processed, just warn when
                        // we have some actual flags that will be acted on but were not
                        // caught by the flags filter
                        if (retPacket.QFlags != 0)
                        {
                            RO.Warn("WaitForDeletedMessage[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3})",
                                UserId,
                                retPacket.QValSequenceNum,
                                retPacket.QFlags,
                                XonPresNoti.BuildQFlagsString(retPacket.QFlags));
                        }

                        HandleQValPacket(retPacket);
                    }
                }

                Thread.Sleep(NotificationPollingInterval);
            }
        lbFinished:

            return retPacket;
        }

        /// <summary>
        /// Wait for a single qval flag, note that this method can be bad for internal state since
        /// it doesn't ensure that the items are dequeued or that the qvals are updated correctly.
        /// Also any flags that come in before the one specified will not be correctly handled.
        /// </summary>
        public QValPacket WaitForQFlags(uint qFlagsMask)
        {
            DateTime abortTime = DateTime.Now.AddSeconds(DefaultNotificationWait);
            QValPacket retPacket = null;

            if (Verbose)
            {
                RO.Debug("WaitForQFlags[{0:x}]: Waiting on qflags {1:x} ({2})",
                    UserId,
                    qFlagsMask,
                    XonPresNoti.BuildQFlagsString(qFlagsMask));
            }

            while (true)
            {
                if (DateTime.Now > abortTime)
                {
                    throw new TimeOutException((ushort)DefaultNotificationWait, "User[" + UserId.ToString("x") + "] Timed out waiting for QFlags: " + qFlagsMask.ToString("X8"));
                }

                // Get all delivered qvals for this timeslice
                while (Xbox.ReadUserQValPacket(UserId, out retPacket))
                {
                    if ((retPacket.QFlags & qFlagsMask) == qFlagsMask)
                    {
                        // got match
                        goto lbFinished;
                    }
                    else
                    {
                        // Unmatched packets should still be processed, just warn when
                        // we have some actual flags that will be acted on but were not
                        // caught by the flags filter
                        if (retPacket.QFlags != 0)
                        {
                            RO.Warn("WaitForQFlags[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3})",
                                UserId,
                                retPacket.QValSequenceNum,
                                retPacket.QFlags,
                                XonPresNoti.BuildQFlagsString(retPacket.QFlags));
                        }

                        HandleQValPacket(retPacket);
                    }
                }

                Thread.Sleep(QValPollingInterval);
            }
        lbFinished:

            return retPacket;
        }

        public void ProcessQVals(uint seconds, uint hqvFlags)
        {
            if (Verbose)
            {
                RO.Debug("ProcessQVals[{0:x}]: processing qvals for: {1} seconds", UserId, seconds);
            }

            DateTime abortTime = DateTime.Now.AddSeconds(seconds);
            while (abortTime > DateTime.Now)
            {
                Thread.Sleep((int)((1000 * seconds) / 100));
                ProcessQVals(hqvFlags);
            }
        }

        /// <summary>
        /// Process qvals with default settings.
        /// </summary>
        public void ProcessQVals()
        {
            ProcessQVals(0);
        }

        /// <summary>
        /// Process qvals on the wire, dequeue and updating internal state with dequeues.
        /// Flags may be 0 or a combination of the HQV flags to control how the processed
        /// qvals should be processed.
        /// </summary>
        public void ProcessQVals(uint hqvFlags)
        {
            // While we have qval packets queued for this user
            // Dequeue the latest qval packet
            QValPacket packet;
            while (Xbox.ReadUserQValPacket(UserId, out packet))
            {
                TimeSpan Delta = DateTime.Now - packet.DeliveryTime;
                if (Verbose)
                {
                    RO.Debug("ProcessQVals[{0:x}]: Sequence: {1}, QFlags: {2:x8}, ProcessLag: {3}",
                        UserId,
                        packet.QValSequenceNum,
                        packet.QFlags,
                        Delta);
                }

                HandleQValPacket(packet, hqvFlags);
                _LastQValPacket.Copy(packet);
            }
        }

        public void HandleQValPacket(QValPacket packet)
        {
            HandleQValPacket(packet, 0);
        }

        public void HandleQValPacket(QValPacket packet, uint hqvFlags)
        {
            if (packet.QValSequenceNum > _LastQValPacket.QValSequenceNum)
            {
                uint QFlags = packet.QFlags;

                if (Verbose)
                {
                    RO.Debug("HandleQValPacket[{0:x}]: consuming QValSequence: {1}, QFlags: 0x{2:x8}",
                        UserId,
                        packet.QValSequenceNum,
                        packet.QFlags);
                }

                // Process the dequeues based on pending qflags markers
                if ((QFlags & XonPresNoti.QFLAG_MASK_BUDDY_REQ) != 0)
                {
                    GetNotifications(XonPresNoti.PQUEUE_BUDDY_REQ);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_LIST_CHANGE) != 0)
                {
                    GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_PRESENCE) != 0)
                {
                    throw new Exception("Only messaging is allowed to call this."); //GetNotifications(XonPresNoti.PQUEUE_PRESENCE);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_INVITE) != 0)
                {
                    GetNotifications(XonPresNoti.PQUEUE_INVITE);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_INVITE_ANSWER) != 0)
                {
                    GetNotifications(XonPresNoti.PQUEUE_INVITE_ANSWER);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS) != 0)
                {
                    throw new UnexpectedTestResultException("Got QFLAG_MASK_TRANSIENT_MSGS but Transient messages cannot be dequeued");
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_PEER_PRESENCE) != 0)
                {
                    throw new Exception("Only messaging is allowed to call this."); //GetNotifications(XonPresNoti.PQUEUE_PEER_PRESENCE);
                }
                if ((QFlags & XonPresNoti.QFLAG_MASK_PRESENCE_2) != 0)
                {
                    throw new Exception("Only messaging is allowed to call this."); //GetNotifications(XonPresNoti.PQUEUE_PRESENCE_2);
                }
            }

            if (packet.NewMessageSequenceNum > _LastQValPacket.NewMessageSequenceNum)
            {
                if (Verbose)
                {
                    RO.Debug("HandleQValPacket[{0:x}]: consuming message qval sequence: {1}, Ids: {2:x}, {3:x}, {4:x}",
                        UserId,
                        packet.NewMessageSequenceNum,
                        packet.NewMessageId(0),
                        packet.NewMessageId(1),
                        packet.NewMessageId(2));
                }

                ProcessNewMessages(packet, hqvFlags);
            }

            if (packet.DeletedMessageSequenceNum > _LastQValPacket.DeletedMessageSequenceNum)
            {
                if (Verbose)
                {
                    RO.Debug("HandleQValPacket[{0:x}]: consuming deleted qval sequence: {1}, Ids: {2:x}, {3:x}, {4:x}",
                        UserId,
                        packet.DeletedMessageSequenceNum,
                        packet.DeletedMessageId(0),
                        packet.DeletedMessageId(1),
                        packet.DeletedMessageId(2));
                }

                ProcessDeletedMessages(packet, hqvFlags);
            }
        }

        // Handle all items delivered in the dequeue
        private void ProcessDequeue(uint qType, ListItem[] items)
        {
            if (Verbose)
            {
                RO.Debug("ProcessDequeue[{0:x}]: QType: {1} ({2}), Items.Length: {3}",
                    UserId,
                    qType,
                    XonPresNoti.QTypeToString(qType),
                    items.Length);
            }

            for (int i = 0; i < items.Length; ++i)
            {
                switch (qType)
                {
                    case XonPresNoti.PQUEUE_LIST_CHANGE:
                    case XonPresNoti.PQUEUE_BUDDY_REQ:
                        {
                            ListChangeItem item = (ListChangeItem)items[i].Data;

                            if (HResult.Failed(item.HR))
                            {
                                RO.Error("ProcessDequeue[{0:x}]: failure item index: {1}, HR: {2:x8} ({3})",
                                        i,
                                        UserId,
                                        item.HR,
                                        Global.XErrToString(item.HR));

                                if (item.HR == HResult.XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS)
                                {
                                    // They're already friends
                                    continue;
                                }
                                else
                                {
                                    throw new HResultException(item.HR, "Negative HRESULT on listchange item: " + i);
                                }
                            }

                            if (item.ListVersion > BuddyListVer)
                            {
                                BuddyListVer = item.ListVersion;
                            }
                            else if (HResult.Succeeded(item.HR))
                            {
                                Global.RO.Warn("ProcessDequeue[{0:x}]: ListChangeItem received with list version <= current BuddyListVer: {1} <= {2}",
                                        UserId,
                                        item.ListVersion,
                                        BuddyListVer);
                            }

                            BuddyInfo buddy = GetBuddyInfo(item.TargetID);
                            if (buddy == null)
                            {
                                PNUser user = Find(item.TargetID);
                                if (user != null)
                                {
                                    buddy = new BuddyInfo(XonPresNoti.NOT_A_BUDDY, user);
                                }
                                else
                                {
                                    buddy = new BuddyInfo(XonPresNoti.NOT_A_BUDDY, item.TargetAcctName);
                                }
                                Buddies[item.TargetID] = buddy;
                            }

                            if (Verbose)
                            {
                                RO.Debug("ProcessDequeue[{0:x}]: BuddyListOperation: {1}, User: {2:x}, UserName: {3}",
                                    UserId,
                                    XonPresNoti.ListChangeOpToString(item.OperationID),
                                    item.TargetID,
                                    item.TargetAcctName);
                            }

                            ValidateListChangeItem(item);

                            switch (item.OperationID)
                            {
                                case XonPresNoti.PLIST_BUDDY_NOP:
                                    if (buddy.Status == XonPresNoti.NOT_A_BUDDY)
                                    {
                                        Buddies.Remove(item.TargetID);
                                    }
                                    break;

                                case XonPresNoti.PLIST_BUDDY_ADD:
                                    if (HResult.Succeeded(item.HR))
                                    {
                                        buddy.Status = XonPresNoti.P_BUDDY_STATUS_PENDING;
                                    }
                                    else
                                    {
                                        Global.RO.Error("Buddy add failed for buddy {0:x}, HR: {1:x}, removing temporary buddy record", item.TargetID, item.HR);
                                        Buddies.Remove(item.TargetID);
                                    }
                                    break;

                                case XonPresNoti.PLIST_BUDDY_ADDED:
                                    buddy.Status = XonPresNoti.P_BUDDY_STATUS_REQUEST;
                                    break;

                                case XonPresNoti.PLIST_BUDDY_ACCEPT:
                                    buddy.Status = XonPresNoti.P_BUDDY_STATUS_OK;
                                    break;

                                case XonPresNoti.PLIST_BUDDY_REJECT:
                                case XonPresNoti.PLIST_BUDDY_DELETE:
                                    Buddies.Remove(item.TargetID);
                                    break;
                                default:
                                    Global.RO.Error("ProcessDequeue[{0:x}]: Invalid ListChange OperationID: {1}",
                                            UserId, item.OperationID);
                                    break;
                            }
                            break;
                        }
                    case XonPresNoti.PQUEUE_INVITE:
                        {
                            InvitationItem item = (InvitationItem)items[i].Data;

                            PNUser invitor = Find(item.HostID);

                            if (Verbose)
                            {
                                RO.Debug("ProcessDequeue[{0:x}]: Invitation received from: {1}",
                                    UserId,
                                    invitor != null ? invitor.Name : item.HostID.ToString("x"));
                            }

                            ValidateInvitationItem(item);

                            BuddyInfo buddy = GetBuddyInfo(item.HostID);
                            if (null != buddy)
                            {
                                buddy.Invitation = item;
                            }

                            PeerInfo peer = GetPeerInfo(item.HostID);
                            if (null != peer)
                            {
                                peer.Invitation = item;
                            }

                            // Add the new invitation object
                            InvitationInfo invite = new InvitationInfo(invitor, item.MatchSessionID);
                            invite.Invitation = item;

                            if (null == Invites)
                            {
                                Invites = new Hashtable();
                            }
                            Invites[item.HostID] = invite;

                            break;
                        }
                    case XonPresNoti.PQUEUE_INVITE_ANSWER:
                        {
                            InvitationAnswerItem item = (InvitationAnswerItem)items[i].Data;

                            if (Verbose)
                            {
                                RO.Debug("ProcessDequeue[{0:x}]: InvitationAnswer received from: {1:x}",
                                    UserId,
                                    item.InviteeID);
                            }

                            ValidateInvitationAnswerItem(item);

                            if (null == Invites)
                            {
                                Invites = new Hashtable();
                            }

                            InvitationInfo invite = Invites[UserId] as InvitationInfo;

                            if (null == invite)
                            {
                                RO.Warn("InvitationAnswer arrived which does not have a corresponding invitation info object, creating one");
                                invite = new InvitationInfo(this, item.MatchSessionID);
                                invite.Owns = true;
                                Invites[UserId] = invite;
                            }
                            else if (invite.Owns == false)
                            {
                                RO.Warn("InvitationAnswer arrived on user who was tracking an invitation but does not own it, setting ownership flag");
                                invite.Owns = true;
                            }

                            invite.InvitationAnswers[item.InviteeID] = item;

                            break;
                        }
                    case XonPresNoti.PQUEUE_PRESENCE:
                        {
                            throw new Exception("Only messaging is allowed to call this.");
                        }
                    case XonPresNoti.PQUEUE_PEER_PRESENCE:
                        {
                            throw new Exception("Only messaging is allowed to call this.");
                        }
                    case XonPresNoti.PQUEUE_PRESENCE_2:
                        {
                            throw new Exception("Only messaging is allowed to call this.");
                        }

                    default:
                        {
                            throw new Exception("Get Notifications wierdness: Bad QType");
                        }
                }
            }
        }

        public UserNotification WaitForUserNotifications(DATA_TYPES notificationType)
        {
            DateTime abortTime = DateTime.Now.AddSeconds(DefaultNotificationWait);
            while (true)
            {
                if (DateTime.Now > abortTime)
                {
                    throw new TimeOutException((ushort)DefaultNotificationWait, "User[" + UserId.ToString("x") + "] Timed out waiting for QFlags: " + notificationType.ToString());
                }

                List<UserNotification> Notis = new List<UserNotification>();
                Xbox.GetUserNotificationFromQueue(UserId, out Notis);
                foreach (UserNotification n in Notis)
                {
                    if (n.NotificationDataType == notificationType)
                    {
                        //match
                        return n;
                    }
                    else
                    {
                        //no match. Handle anyway.
                        RO.Warn("Unmatched Notification found: Type: {0}, ForXuid: {1}, FromXuid: {2}, Recieved on: {3}",
                                n.NotificationDataType,
                                n.ForXuid,
                                n.FromXuid,
                                n.NotificationReceivedTime);
                        Xbox.ProcessTCPNotification(n);
                    }
                }
                Thread.Sleep(NotificationPollingInterval);
            }
        }

        public void ProcessNotifications(uint seconds, DATA_TYPES notificationType)
        {
            if (Verbose)
            {
                RO.Debug("ProcessNotification[{0:x}]: processing notif for: {1} seconds", UserId, seconds);
            }

            DateTime abortTime = DateTime.Now.AddSeconds(seconds);
            while (abortTime > DateTime.Now)
            {
                Thread.Sleep((int)((1000 * seconds) / 100));
                //Handle Notificatin
            }
        }

        public void ProcessNotifications()
        {
            //This is Evil. But there has been instances that external codes do call this immidiately after state change or logon/off. In order not to add sleeps at all those places
            //we put it at one place here. :( We dont like it, but as Jack Bauer says, 'we don't have choice'. Now dont tell me we always have choice. I dont buy it. oh well...
            Thread.Sleep(2000);
            List<UserNotification> notis = new List<UserNotification>();
            Xbox.GetUserNotificationFromQueue(UserId, out notis);
            foreach (UserNotification n in notis)
            {
                Global.RO.Debug("ProcessNotifications: Type:{0}, From:{1}", n.NotificationDataType.ToString(), n.FromXuid);
                HandleTCPNotification(n);
            }
        }

        public void ProcessNotifications(DATA_TYPES notificationType)
        {
            List<UserNotification> notis = new List<UserNotification>();
            Xbox.GetUserNotificationFromQueue(UserId, notificationType, out notis);
            foreach (UserNotification n in notis)
            {
                TimeSpan Delta = DateTime.Now - n.NotificationReceivedTime;
                if (Verbose)
                {
                    RO.Debug("ProcessNotifications for: [{0:x}], From: [{1:x}], Delta:{2}",
                        UserId,
                        n.FromXuid,
                        Delta);
                }
                //Handle Notification.
                HandleTCPNotification(n);
            }

        }

        public void HandleTCPNotification(UserNotification notif)
        {
            switch (notif.NotificationDataType)
            {
                case DATA_TYPES.eAvatar:
                    break;
                case DATA_TYPES.eBasicPresence:
                    {
                        Xbox.ProcessTCPNotification(notif);
                        break;
                    }
                case DATA_TYPES.eBasicProfile:
                    break;
                case DATA_TYPES.eConnSrvLocation:
                    break;
                case DATA_TYPES.eExtendedPresence:
                    break;
                case DATA_TYPES.eExtendedProfile:
                    break;
                case DATA_TYPES.eFriendsList:
                    {
                        Xbox.ProcessTCPNotification(notif);
                        break;
                    }
                case DATA_TYPES.ePartyInfo:
                    break;
                case DATA_TYPES.eRichPresenceString:
                    {
                        Xbox.ProcessTCPNotification(notif);
                        break;
                    }
                default:
                    break;
            }

        }

        private void ProcessNewMessages(QValPacket packet, uint hqvFlags)
        {
            for(uint i = 0; i < 3; ++i)
            {
                uint msgId = packet.NewMessageId(i);
                uint msgData = packet.NewMessageData(i);

                if(0 != msgId && 0 != msgData)
                {
                    if (Verbose)
                    {
                        RO.Debug("ProcessNewMessages[{0:x}]: processing MsgId: {1:x}, Data: {2:x8} ({3})",
                            UserId,
                            msgId,
                            msgData,
                            XonPresNoti.BuildMsgNotificationFlagsString(msgData));
                    }

                    if(null != GetMessageInfo(msgId))
                    {
                        // The message has already been indexed on a previous read, we can skip it
                        continue;
                    }

                    //
                    // Retreive the message data
                    //
                    UserMessage msg = UserMessage.CreateBlank();
                    uint setFlags = (0 != (hqvFlags & HQV_ReadMessages)) ? XonPresNoti.MSG_FLAG_READ : 0;

                    uint hr = msg.GetDetails(this, msgId, setFlags, 0);

                    if(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == hr)
                    {
                        // This log message is deprecated for now. Test cases in messaging should cover this explicity
                        // this is such a common occurrence when quickly making buddies that it has become a bit annoying
                        //RO.Warn("ProcessNewMessages[{0:x}]: MsgId: {1:x} did not exist may have been revoked or read by another action",
                        //        UserId,
                        //        msgId);
                        continue;
                    }
                    else if(!HResult.Succeeded(hr))
                    {
                        RO.Warn("ProcessNewMessages[{0:x}]: GetDetails() failed for MsgId: {1:x}, HR: 0x{2:x8}",
                                UserId,
                                msgId,
                                hr);
                        continue;
                    }

                    // Save the summary
                    MessageInfo info = new MessageInfo();
                    info.Id          = msgId;
                    info.Data        = msgData;
                    info.Message     = msg;

                    // Index message
                    if(null == Messages)
                    {
                        Messages = new Hashtable();
                    }

                    Messages[info.Id] = info;

                    //
                    // Do special by-type processing
                    //
                    if(XonPresNoti.MSG_TYPE_GAME_INVITE == info.MessageType)
                    {
                        InvitationInfo invite = GetInvitationInfo(info.Message.SenderID);

                        if(null == invite)
                        {
                            invite = new InvitationInfo();

                            invite.Owns         = false;
                            invite.Host         = Lookup[info.Message.SenderID] as PNUser;
                            invite.MatchSession = (ulong)msg.Details.GetQwordProperty( XonPresNoti.MSG_PROP_SESSION_ID );

                            if(null == Invites)
                            {
                                Invites = new Hashtable();
                            }

                            Invites[info.Message.SenderID] = invite;
                        }

                        invite.MessageId = msgId;
                    }

                    //
                    // Handle messaging HQV post process flags
                    //
                    if(0 != (HQV_DeleteMessages & hqvFlags))
                    {
                        DeleteMessage(msgId);
                    }
                }
            }
        }

        private void ProcessDeletedMessages(QValPacket packet, uint hqvFlags)
        {
            for(uint i = 0; i < 3; ++i)
            {
                uint msgId = packet.DeletedMessageId(i);

                if(0 != msgId)
                {
                    if (Verbose)
                    {
                        RO.Debug("ProcessDeletedMessages[{0:x}]: processing MsgId: {1:x}",
                            UserId,
                            msgId);
                    }

                    MessageInfo info = GetMessageInfo(msgId);
                    if(null == info)
                    {
                        info = new MessageInfo();
                        info.Id          = msgId;
                        info.Data        = 0;
                        info.Message     = null;
                    }

                    info.Deleted     = true;

                    // Index message
                    if(null == Messages)
                    {
                        Messages = new Hashtable();
                    }

                    Messages[info.Id] = info;
                }
            }
        }

        //------------------------------------------------------------------------------
        //
        // List Item Validators
        //
        //------------------------------------------------------------------------------
        private void ValidateListChangeItem(ListChangeItem item)
        {

            PNUser target = PNUser.Find(item.TargetID);
            if(target != null)
            {
                // Failures and deletions do not contain the buddy acct name
                if(HResult.Succeeded(item.HR) && item.OperationID != XonPresNoti.PLIST_BUDDY_DELETE && item.OperationID != XonPresNoti.PLIST_BUDDY_REJECT)
                {
                    ValueCheck.Test("ValidateListChangeItem(): TargetAcctName", target.Name.ToLower(), item.TargetAcctName.ToLower());

                    // If the names are different case we trust the server has sent us the canonical buddy name (there are functional
                    // tests that validate this)
                    if(target.Name != item.TargetAcctName)
                    {
                        target.Name = item.TargetAcctName;
                    }
                }
            }
            else
            {
                RO.Warn("ValidateListChangeItem(): TargetID not found in global lookup table");
            }

        }

        private void ValidateInvitationItem(InvitationItem item)
        {

            if(item.TimeSent <= DateTime.Now.AddMinutes(-10))
            {
                RO.Warn("ValidateInvitationItem(): Invitation was sent more than 10 minutes ago");
            }

            PNUser target = PNUser.Find(item.HostID);
            if(target != null)
            {
                ValueCheck.Test("ValidateInvitationItem(): MatchSessionID", target.MatchSessionId, item.MatchSessionID);
                ValueCheck.Test("ValidateInvitationItem(): TitleID", target.Xbox.TitleId, item.TitleID);
            }
            else
            {
                RO.Warn("ValidateInvitationItem(): HostID not found in global lookup table");
            }

        }

        private void ValidateInvitationAnswerItem(InvitationAnswerItem item)
        {
            if(item.TimeSent <= DateTime.Now.AddMinutes(-10))
            {
                RO.Warn("ValidateInvitationAnswerItem(): Invitation answer was sent more than 10 minutes ago");
            }

            if(item.Answer > 2)
            {
                RO.Warn("ValidateInvitationAnswerItem(): Invalid answer value: " + item.Answer);
            }

            PNUser target = PNUser.Find(item.InviteeID);
            if(null != target)
            {
                // If we do not have an outstanding invite don't expect the other user to be in a session
                // they may have rejected the invite
                InvitationInfo invite = target.GetInvitationInfo(UserId);
                if(null != invite)
                {
                    ValueCheck.Test("ValidateInvitationAnswerItem(): MatchSessionID", target.MatchSessionId, item.MatchSessionID);
                }
            }
            else
            {
                RO.Warn("ValidateInvitationAnswerItem(): InviteeID not found in global lookup table");
            }
        }

        private void ValidatePresenceItem(PresenceItem item)
        {
            if(0 == item.State)
            {
                if (Verbose)
                {
                    RO.Debug("Received offline presence record for: {0:x}", item.BuddyID);
                }
                return;
            }

            PNUser target = PNUser.Find(item.BuddyID);
            if(target != null)
            {
                if(0 == (item.State & XonPresNoti.P_STATE_MASK_CLOAKED))
                {
                    ValueCheck.Test("ValidatePresenceItem(): TitleID", target.Xbox.TitleId, item.TitleID);
                    ValueCheck.Test("ValidatePresenceItem(): State", target.State, item.State);
                    ValueCheck.Test("ValidatePresenceItem(): MatchSessionId", target.MatchSessionId, item.MatchSessionID);
                    //ValueCheck.Test("ValidatePresenceItem(): NicknameLengthConsistency", item.Nickname.Length, item.NicknameLen);
                    //ValueCheck.Test("ValidatePresenceItem(): Nickname", target.Name, new UTF8Encoding().GetString(item.Nickname));
                    //ValueCheck.Test("ValidatePresenceItem(): DataLenConsistency", item.TitleStuff.Length, item.TitleStuffLen);
                    //ValueCheck.Test("ValidatePresenceItem(): Data", target.TitleStuff, item.TitleStuff);
                }
            }
            else
            {
                RO.Warn("ValidatePresenceItem(): BuddyID not found in global lookup table");
            }
        }

        private void ValidatePeerPresenceItem(PeerPresenceItem item)
        {
            if(0 == item.State)
            {
                if (Verbose)
                {
                    RO.Debug("Received offline peer presence record for: {0:x}", item.UserID);
                }
                return;
            }

            PNUser target = PNUser.Find(item.UserID);
            if(target != null)
            {
                if(0 == (item.State & XonPresNoti.P_STATE_MASK_CLOAKED))
                {
                    ValueCheck.Test("ValidatePeerPresenceItem(): TitleID", target.Xbox.TitleId, item.TitleID);
                    ValueCheck.Test("ValidatePeerPresenceItem(): State", target.State, item.State);
                    ValueCheck.Test("ValidatePeerPresenceItem(): MatchSessionId", target.MatchSessionId, item.MatchSessionID);
                    ValueCheck.Test("ValidatePeerPresenceItem(): DataLenConsistency", item.TitleStuff.Length, item.TitleStuffLen);
                    ValueCheck.Test("ValidatePeerPresenceItem(): Data", target.TitleStuff, item.TitleStuff);
                }
            }
            else
            {
                RO.Warn("ValidatePeerPresenceItem(): UserID not found in global lookup table");
            }
        }

        private void ValidatePeerSubscribeExResult(PeerSubscribeExReplyData item)
        {
            if (0 == item.dwState)
            {
                if (Verbose)
                {
                    RO.Debug("Received offline peer presence data from PeerSubscribeEx for: {0:x}", item.qwUserID);
                }
                return;
            }

            PNUser target = PNUser.Find(item.qwUserID);
            if (target != null)
            {
                if (0 == (item.dwState & XonPresNoti.P_STATE_MASK_CLOAKED))
                {
                    ValueCheck.Test("ValidatePeerSubscribeExResult(): State", target.State, item.dwState);
                    ValueCheck.Test("ValidatePeerSubscribeExResult(): TitleID", target.Xbox.TitleId, item.dwTitleID);
                    ValueCheck.Test("ValidatePeerSubscribeExResult(): GamerTag", target.Name, item.szGamerTag);
                }
                else
                {
                    RO.Warn("Received cloaked bit set for peer presence data from PeerSubscribeEx for: {0:x}", item.qwUserID);
                }
            }
            else
            {
                RO.Warn("ValidatePeerSubscribeExResult(): UserID not found in global lookup table");
            }
        }

        private void ValidateBasicPresenceNotification(UserNotification item)
        {
            ValueCheck.Test("ValidateBasicPresenceNotification : NotificationType", DATA_TYPES.eBasicPresence, item.NotificationDataType);
            PNUser target = PNUser.Find(item.FromXuid);
            if (target != null)
            {
                if (0 == (target.State & XonPresNoti.P_STATE_MASK_CLOAKED))
                {
                    BasicPresence basic = new BasicPresence();
                    basic.ReadBytes((byte[])item.SubscriptionData);
                    ValueCheck.Test("ValidateBasicPresenceNotification(): TitleID", target.Xbox.TitleId, basic.dwTitleID);
                    ValueCheck.Test("ValidateBasicPresenceNotification(): State", target.State, basic.dwState);
                    ValueCheck.Test("ValidateBasicPresenceNotification(): MatchSessionId", target.MatchSessionId, basic.qwSessionID);
                }
            }
            else
            {
                RO.Warn("ValidateBasicPresenceNotification(): BuddyID {0:x} not found in global lookup table",
                        item.FromXuid);
            }

            // See if this user should even be sending us presence
            bool found = false;
            found = (null != GetBuddyInfo(item.FromXuid));

            if (!found)
            {
                found = (null != GetPeerInfo(item.FromXuid));
            }

            if (!found)
            {
                RO.Error("ValidateBasicPresenceNotification(): BuddyID {0:x} was not in buddies or peers lookup tables for user {1:x}",
                        item.FromXuid, UserId);
            }

        }

        private void ValidateRichPresenceNotification(UserNotification item)
        {
            ValueCheck.Test("ValidateRichPresenceNotification : NotificationType", DATA_TYPES.eRichPresenceString, item.NotificationDataType);
            PNUser target = PNUser.Find(item.FromXuid);
            if (target != null)
            {
                if (0 == (target.State & XonPresNoti.P_STATE_MASK_CLOAKED))
                {
                    RichPresenceData richPresence = new RichPresenceData();
                    richPresence.ReadBytes((byte[])item.SubscriptionData);
                    string rpstring = richPresence.sRichPresence;
                }
            }
            else
            {
                RO.Warn("ValidateRichPresenceNotification(): BuddyID {0:x} not found in global lookup table",
                        item.FromXuid);
            }

            // See if this user should even be sending us presence
            bool found = false;
            found = (null != GetBuddyInfo(item.FromXuid));

            if (!found)
            {
                found = (null != GetPeerInfo(item.FromXuid));
            }

            if (!found)
            {
                RO.Error("ValidateRichPresenceNotification(): BuddyID {0:x} was not in buddies or peers lookup tables for user {1:x}",
                        item.FromXuid, UserId);
            }

        }

        public UserTitle[] EnumerateTitles()
        {
            QMsgEnumTitles req = new QMsgEnumTitles(this);
            PNMsg rep;
            req.TransactFD(out rep);

            QEnumTitlesReplyMsgData repData = (QEnumTitlesReplyMsgData)rep.Data;

            if(HResult.Failed(repData.HR))
            {
                throw new HResultException(repData.HR, "EnumerateTitles() failed failed for user: " + UserId);
            }

            ValueCheck.Test("QEnumTitlesReplyMsgData.TitlesLen", repData.TitlesLen, repData.Titles.Length);

            return repData.Titles;
        }

        public void DeleteTitle(uint titleId)
        {
            QMsgDeleteTitle req = new QMsgDeleteTitle(this, titleId);
            PNMsg rep;
            req.TransactFD(out rep);

            QDeleteTitleReplyMsgData repData = (QDeleteTitleReplyMsgData)rep.Data;

            if(HResult.Failed(repData.HR))
            {
                throw new HResultException(repData.HR, "DeleteTitle() failed failed for user: " + UserId);
            }
        }

        public DATA_OBJECT_SPECIFIER GetBasicPresenceDataObjectSpecifier(ulong subscribeId)
        {
            unsafe
            {
                DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
                dos.qwOwnerXUID = subscribeId;
                dos.dwDataSubType = 0;
                dos.wDataType = (ushort)DATA_TYPES.eBasicPresence;
                BasicPresence pres = new BasicPresence();
                dos.wObjectSize = (ushort)pres.Size();
                return dos;
            }
        }

        public DATA_OBJECT_SPECIFIER GetRichPresenceDataObjectSpecifier(ulong subscribeId)
        {
            unsafe
            {
                DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
                dos.qwOwnerXUID = subscribeId;
                dos.dwDataSubType = 0;
                dos.wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                // maximum length of rich presence string is 128 bytes
                RichPresenceData rich = new RichPresenceData();
                rich.sRichPresence = new string(' ', 128);
                dos.wObjectSize = (ushort)rich.Size();
                return dos;
            }
        }

        public int UserControllerIndex
        {
            get
            {
                CSGInfo csg = GlobalFakeSG.FakeSG.GetSlot();
                GlobalFakeSG.FakeSG.LoadSlot(ref csg, this.Xbox.XboxId);

                ulong[] connectedusers = new ulong[4] { csg.userPuid0, csg.userPuid1, csg.userPuid2, csg.userPuid3 };

                //Find out where am I connected.
                for (int i = 0; i < connectedusers.Length; i++)
                {
                    if (connectedusers[i] == this.UserId)
                        return i;
                }

                return -1;

            }
        }

        public void SetMsgFlags(uint msgId, uint setFlags, uint unsetFlags)
        {
            SetMsgFlags(msgId, setFlags, unsetFlags, false);
        }

        public void SetMsgFlags(uint msgId, uint setFlags, uint unsetFlags, bool useDatacenterPort)
        {

            QMsgFlags msgFlags = new QMsgFlags(this, msgId, setFlags, unsetFlags);

            if (useDatacenterPort)
                msgFlags.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;

            PNMsg reply;
            msgFlags.TransactFD(out reply);
            ValueCheck.Test("Reply Data Type", typeof(QFlagsReplyMsgData).Name, reply.Data.GetType().Name);

            QFlagsReplyMsgData replyData = (QFlagsReplyMsgData)(reply.Data);
            if (replyData.hr != HResult.S_OK)
            {
                throw new HResultException(replyData.hr, "Set Flags Message HR = " + replyData.hr.ToString("X08"));
            }
        }

        public void SubscribeToPartnerMarketing()
        {
            UodbWS.SetUserProperty(this.UserId, "f_partner_opt_in", "1");
            FriendsCommon.WaitForXCache();
        }

        public void SubscribeToMSMarketing()
        {
            UodbWS.SetUserProperty(this.UserId, "f_ms_opt_in", "1");
            FriendsCommon.WaitForXCache(); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\QueryAndLsp\XRLLSPProxyGetSiteInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.QueryAndLsp {

	/// <summary>
	/// This class represents a GetSiteInfo request that originates in an SG 
	/// LSP server and makes its way to a LSP front-door server by way of the
	/// LSP proxy, Web SG, and the Live proxy.
	/// </summary>
	public class XRLLSPProxyGetSiteInfoRequest : XRLPayload {

		public XRLLSPProxyGetSiteInfoRequest (uint siteID) {
			// This ID is used for LSP SG requests
			ServiceId = XOService.InvalidService;

			this.siteID = siteID;
		}

		/// <summary>
		/// The Site ID for the GetSiteInfo request.
		/// </summary>
		public uint siteID;

		private string _serviceName = "/LiveProxy/GetSiteInfo.aspx";
		public string ServiceName {
			get { return _serviceName; }
			set { _serviceName = value; }
		}

		// Needs to be here for backwards compatibility
		protected override string GetServiceName () {
			return _serviceName;
		}

		/// <summary>
		/// Executes the request.
		/// </summary>
		/// <param name="proxyEndPoint">The IPEndPoint of the LSP proxy that 
		/// this request will be sent through.</param>
		/// <returns>true if successful.</returns>
		public override bool Execute (IPEndPoint proxyEndPoint) {
			return base.Execute(proxyEndPoint);
		}

		[XRLPayloadFld(Serialize=false)]
		public XRLSiteInfo response = null;

		/// <summary>
		/// Reads in the response from the LSP Front Door server. The read
		/// response is then stored in the 32-bit integer this.response.
		/// </summary>
		/// <param name="responseStream"></param>
		protected override void ReadResponse (MemoryStream responseStream) {
			response = new XRLSiteInfo();
			response.ReadStream(responseStream);
		}
	}


	/// <summary>
	/// This class represents the LSP Front Door server's response to a 
	/// GetSiteInfo request.
	/// </summary>
	public class XRLSiteInfo : XRLPayload {
		public UInt64 time;
		public UInt32 keyCount;

		[WireInfo(SizeParam="keyCount")]
		public XRLKeyInfo[] keys;
	}

	
	public class XRLKeyInfo : XRLPayload {
		public UInt32 version;
		public Byte key;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Ratings\XRLUserRatings.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;



namespace ServerTestFramework.LiveService.Ratings
{

    public class RateMediaRequestTest : XRLObject2
    {
        public Guid mediaId;
        
        public int ratingValue;

        [XRLPayloadFld(IsUPuid = true)]
        public ulong userXuid;

        [XRLPayloadFld(IsCountryId = true)]
        public byte userCountryId;
       
        public override string Xrl
        {
            get { return "/ratings/submitrating.ashx"; }
        }
    }

    public class GetRatingRequestTest : XRLObject2
    {
        public Guid mediaId;

        [XRLPayloadFld(IsUPuid = true)]
        public ulong userXuid;

        [XRLPayloadFld(IsCountryId = true)]
        public byte userCountryId;
        
        //TODO: url subjected to change
        public override string Xrl
        {
            get { return "/ratings/getrating.ashx"; }
        }
    }
    
    public class GetRatingResponseTest : XRLObject2
    {
        public int userValue;
        
        public double ratingsAverage;
        
        public int ratingsCount;
    }

    public class XRLMsnGetRating : XRLPayload<GetRatingRequestTest, GetRatingResponseTest>
    {
       
        public XRLMsnGetRating()
        {
            SetDefaults();
        }

        public XRLMsnGetRating(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            //This is for testing purpose only, actual test would pick the media from Catalog
            this.Request.mediaId = new Guid("ED43B32F-8C3D-4B7B-90B7-085B87D75804");
            this.Request.userXuid = ulong.MinValue;
            this.Request.userCountryId = 103;
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.ratings));
        }
    }

    public class XRLMsnSubmitRating : XRLPayload<RateMediaRequestTest>
    {
    
        public XRLMsnSubmitRating()
        {
            SetDefaults();
        }

        public XRLMsnSubmitRating(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            //This is for testing purpose only, actual test would pick the media from Catalog
            this.Request.mediaId = new Guid("ED43B32F-8C3D-4B7B-90B7-085B87D75804");
            this.Request.ratingValue = 1;
            this.Request.userXuid = ulong.MinValue;
            this.Request.userCountryId = 103;
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.ratings));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\RegDB\RegHistoryRetriever.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

using System.Data.SqlClient;


#pragma warning disable 420 //ref to volatile will not be treated as volatile.  C#'s Interlocked functions retartedly do not take volatile references.

namespace ServerTestFramework.Reporting
{
    /// <summary>
    /// Get information from RegDB.
    /// </summary>
    public class RegDBInfo
    {
        SqlConnection sqlCon;

        /// <summary>
        /// close the sql connection
        /// </summary>
        public void Close()
        {
            if (sqlCon!=null)
            {
                sqlCon.Close();
                sqlCon=null;
            }
        }

        /// <summary>
        /// Retrieves a list of all suites in RegDB
        /// </summary>
        public string[] GetAllSuites()
        {
            System.Collections.Generic.List<string> suites=new System.Collections.Generic.List<string>();

            if (sqlCon==null)
            {
                sqlCon=RegDB.OpenSQLConnection();
            }

            string query="SELECT SubComponent FROM [RegDB].[dbo].[SubComponent] order by SubComponent";
            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            while (reader.Read())
            {
                suites.Add((string)reader[0]);
            }
            reader.Close();

            return suites.ToArray();
        }

        /// <summary>
        /// Retrieves a list of all environments in RegDB, with an array that can be indexed by environmentID
        /// </summary>
        public string[] GetAllEnvironments()
        {
            System.Collections.Generic.List<string> envs=new System.Collections.Generic.List<string>();

            if (sqlCon==null)
            {
                sqlCon=RegDB.OpenSQLConnection();
            }

            string query="select EnvironmentID, Name from [RegDB].[dbo].[Environments] order by EnvironmentID";
            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            int lastID=-1;
            while (reader.Read())
            {
                int id=(int)(System.Byte)reader[0];

                while (lastID+1<id)
                {
                    envs.Add("?");
                    ++lastID;
                }

                envs.Add((string)reader[1]);

                lastID=id;
            }
            reader.Close();

            return envs.ToArray();
        }

        //
        public class BuildRun
        {
            public int EnvironmentID;
            public string Build; //in XX.XX.XXXX.XXXX form

            public int IterationID; //the ID in the iteration table that this entry came from
        }

        /// <summary>
        /// Retrieves a list of all build runs in RegDB
        /// </summary>
        /// <returns></returns>
        public BuildRun[] GetAllBuilds()
        {
            System.Collections.Generic.List<BuildRun> builds=new System.Collections.Generic.List<BuildRun>();

            if (sqlCon==null)
            {
                sqlCon=RegDB.OpenSQLConnection();
            }

            string query="select IterationID, BuildNo, IterationNO, EnvironmentID from [RegDB].[dbo].[Iteration] order by BuildNo desc, IterationNO desc";
            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            while (reader.Read())
            {
                BuildRun b=new BuildRun();
                b.EnvironmentID=(int)(System.Byte)reader[3];
                b.Build=(string)reader[1];
                b.Build+="."+((int)reader[2]).ToString().PadLeft(4,'0');
                b.IterationID=(int)reader[0];

                builds.Add(b);
            }
            reader.Close();

            return builds.ToArray();
        }

        /// <summary>
        /// Gets the pass and total count for a build for a suite
        /// </summary>
        public void GetSuitePassCountForBuild(string suite, int iterID, out int pass, out int total)
        {
            pass=0;
            total=0;

            if (sqlCon==null)
            {
                sqlCon=RegDB.OpenSQLConnection();
            }

            string query="declare @i int;\n"+
                         "SELECT @i=SubCompID FROM [RegDB].[dbo].[SubComponent] where SubComponent='"+suite+"';\n"+
                         "exec sp_SubComponentStatForBuild "+iterID+", @i";

            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            if (reader.Read())
            {
                pass=(int)reader[2];
                int fail=(int)reader[3];
                total=pass+fail;
            }
            reader.Close();
        }

        /// <summary>
        /// Gets RegDB's view of a suite's tree
        /// </summary>
        public static RegDBTreeReader.Node GetSuiteTree(string suite)
        {
            RegDBTreeReader.Node root=RegDBTreeReader.GetSuiteTree(suite);
            ConvertTreeFromOldFormat(root);
            return root;
        }

        //convert from the old 3-tier system into generic children
        private static void ConvertTreeFromOldFormat(RegDBTreeReader.Node node)
        {
            //expand my children
            foreach (RegDBTreeReader.Node child in node.Children)
            {
                ConvertTreeFromOldFormat(child);
            }

            //if I have a dot in my name, expand me
            if (node.Name.Contains("."))
            {
                int dotInd=node.Name.IndexOf('.');
                string newName=node.Name.Substring(0,dotInd);
                string childName=node.Name.Substring(dotInd+1, node.Name.Length-dotInd-1);

                node.Name=newName;
                RegDBTreeReader.Node newChild=new RegDBTreeReader.Node(childName, node);
                node.Children.AddLast(newChild);
            }

            //consolidate children that have the same name
omgtryagain:
            foreach (RegDBTreeReader.Node child1 in node.Children)
            {
                string firstName1=child1.Name.Split(new char[]{'.'})[0];

                foreach (RegDBTreeReader.Node child2 in node.Children)
                {
                    if (child1!=child2)
                    {
                        string firstName2=child2.Name.Split(new char[]{'.'})[0];

                        if (firstName1==firstName2)
                        {
                            //move 2's children into 1
                            foreach (RegDBTreeReader.Node c2Kid in child2.Children)
                            {
                                c2Kid.Parent=child1;
                                child1.Children.AddLast(c2Kid);
                            }
                            child2.Children.Clear();

                            //remove 2
                            node.Children.Remove(child2);

                            goto omgtryagain;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets whether a test leaf node passed or ran
        /// </summary>
        public void GetLeafPassFail(string fullName, int iterID, out int pass, out int total)
        {
            pass=0;
            total=0;

            //break the name down into the old suite/group/case system
            string []parts=fullName.Split(new char[]{'.'});
            if (parts.Length<3)
            {
                Global.RO.Warn("Old RegDB system can't handle less than 3 levels of tree structure.. returning nothing for "+fullName);
                return;
            }

            string suite=parts[0];
            string group=parts[1];
            string casee=parts[2];
            for (int i=3; i<parts.Length; ++i)
                casee+="."+parts[i];

            //do query
            if (sqlCon==null)
            {
                sqlCon=RegDB.OpenSQLConnection();
            }

            string query="select top 1 Result from [RegDB].[dbo].[TestRun] where IterationID="+iterID+" and TestCaseID="+
                         "(select top 1 TestCaseID from [RegDB].[dbo].[TestCase] where TestCaseName='"+casee+"' and TestGroupID="+
                         "  (select top 1 TestGroupID from [RegDB].[dbo].[TestGroup] where TestGroup='"+group+"' and SubCompID="+
                         "    (select top 1 SubCompID from [RegDB].[dbo].[SubComponent] where SubComponent='"+suite+"')"+
                         "  )"+
                         ")";

            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            if (reader.Read())
            {
                pass=((int)reader[0]!=0)?1:0;
                total=1;
            }
            reader.Close();
        }

        /// <summary>
        /// Retrieves output from RegDB and throws it at a report destination
        /// </summary>
        public static void GetNodeOutputToReportDestination(string fullName, int iterID, Report.Destination dest)
        {
            //break the name down into the old suite/group/case system
            string []parts=fullName.Split(new char[]{'.'});

            string suite=parts[0];
            string group=null;
            string casee=null;
            if (parts.Length>=2) group=parts[1];
            if (parts.Length>=3) casee=parts[2];
            for (int i=3; i<parts.Length; ++i)
                casee+="."+parts[i];

            //make the appropriate inquirer
            RegDBInquirer inq;
            if (casee!=null) //case
            {
                inq=new RegDBInquirer(suite, group, casee);
            }
            else if (group!=null) //group
            {
                inq=new RegDBInquirer(suite, group);
            }
            else //suite
            {
                inq=new RegDBInquirer(suite);
            }

            //get logs
            inq.GetLog((uint)iterID, dest);
        }

        //retrieves the history for a node
        public static RegDBInquirer.RegDBHistory[] GetNodeHistory(string fullName)
        {
            //break the name down into the old suite/group/case system
            string []parts=fullName.Split(new char[]{'.'});

            string suite=parts[0];
            string group=null;
            string casee=null;
            if (parts.Length>=2) group=parts[1];
            if (parts.Length>=3) casee=parts[2];
            for (int i=3; i<parts.Length; ++i)
                casee+="."+parts[i];

            //make the appropriate inquirer
            RegDBInquirer inq;
            if (casee!=null) //case
            {
                inq=new RegDBInquirer(suite, group, casee);
            }
            else if (group!=null) //group
            {
                inq=new RegDBInquirer(suite, group);
            }
            else //suite
            {
                inq=new RegDBInquirer(suite);
            }

            //get history
            return inq.GetHistory();
        }
    }



    // -- the interface to the code above uses the unified node system.
    // -- the old code below is all coded to the suite/group/test schema.



    /// <summary>
    /// Retrieves a node tree containing every test group and case that RegDB contains for a specific suite.
    /// </summary>
    public class RegDBTreeReader
    {
        //a node of the tree
        public class Node
        {
            public string Name;

            public string FullName
            {
                get
                {
                    if (Parent==null)
                        return Name;
                    else
                        return Parent+"."+Name;
                }
            }

            public System.Collections.Generic.LinkedList<Node> Children;
            public Node Parent;

            public Node(string myName, Node parent)
            {
                Name=myName;
                Parent=parent;
                Children=new System.Collections.Generic.LinkedList<Node>();
            }
        };

        //the retriever
        public static Node GetSuiteTree(string suiteName)
        {
            //find the suite's ID
            SqlConnection sqlCon=RegDB.OpenSQLConnection();
            string query="SELECT [SubCompID] FROM [RegDB].[dbo].[SubComponent] where SubComponent='" + suiteName + "'";
            SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();
            if (!reader.Read()) return null;

            uint suiteID=(uint)(int)reader[0];
            reader.Close();

            Node root=new Node(suiteName, null);

            //get a list of all groups within that suite
            query="SELECT [TestGroupID],[TestGroup] FROM [RegDB].[dbo].[TestGroup] where SubCompID=" + suiteID;
            reader=new SqlCommand(query, sqlCon).ExecuteReader();

            SqlConnection sqlConCase=RegDB.OpenSQLConnection();

            while (reader.Read())
            {
                //make group node
                uint groupID=(uint)(int)reader[0];
                string groupName=(string)reader[1];

                Node groupNode=new Node(groupName, root);

                //look up all cases within that group
                string queryCase="SELECT [TestCaseName] FROM [RegDB].[dbo].[TestCase] where TestGroupID=" + groupID;
                SqlDataReader readerCase=new SqlCommand(queryCase, sqlConCase).ExecuteReader();

                while (readerCase.Read())
                {
                    string caseName=(string)readerCase[0];

                    groupNode.Children.AddLast(new Node(caseName, groupNode));
                }

                //
                readerCase.Close();

                root.Children.AddLast(groupNode);
            }

            sqlConCase.Close();

            //
            reader.Close();
            sqlCon.Close();

            return root;
        }
    };

    /// <summary>
    /// Represents a specific component (suite, group or case) on which queries can be performed.
    /// </summary>
    public class RegDBInquirer
    {
        // -- Public Constructors

        /// <summary>
        /// This query is about a specific test suite.
        /// </summary>
        public RegDBInquirer(string suiteName)
        {
            this.suiteName=suiteName;
        }

        /// <summary>
        /// This query is about a specific test group.
        /// </summary>
        public RegDBInquirer(string suiteName, string groupName): this(suiteName)
        {
            this.groupName=groupName;

            if (suiteName==null || suiteName.Length==0)
            {
                throw new System.Exception("RegDB Query is invalid: Queries involving a group or case must have a valid suite name.");
            }
        }

        /// <summary>
        /// This query is about a specific test case.
        /// </summary>
        public RegDBInquirer(string suiteName, string groupName, string caseName): this(suiteName,groupName)
        {
            this.caseName=caseName;
            
            if (groupName==null || groupName.Length==0)
            {
                throw new System.Exception("RegDB Query is invalid: Queries involving a case must have a valid group name.");
            }
        }

        // -- Public Interface

        //retrieves the suite that this represents
        public string SuiteName { get {return suiteName;} }
        //retrieves the group that this represents (or null if none)
        public string GroupName { get {return groupName;} }
        //retrieves the case name that this represents (or null if none)
        public string CaseName { get {return caseName;} }

        /// <summary>
        /// represents a pass/fail entry for as specific build of a component.
        /// </summary>
        public class RegDBHistory: System.IComparable<RegDBHistory>
        {
            //Build number
            public string Build { get {return build;} }
            public uint Iteration { get {return iter;} }
            public uint IterationID { get {return iterID;} }
            public string Environment { get {return envName;} }

            //For group/suites, these are the number of subcomponents that passed and failed.  For test cases, either Passed will be 1 or Failed will be 1.
            public uint Passed;
            public uint Failed;

            //
            public RegDBHistory(string environment, uint iterationID, string buildNum, uint iterNum)
            {
                envName=environment;
                iterID=iterationID;
                build=buildNum;
                iter=iterNum;
            }
            private uint iterID, iter;
            private string build;
            private string envName;

            //
            public int CompareTo(RegDBHistory them)
            {
                int buildCmp=string.Compare(Build,them.Build);
                if (buildCmp!=0)
                    return -buildCmp;

                if (Iteration<them.Iteration)
                    return 1;
                else if (Iteration>them.Iteration)
                    return -1;
                else
                    return 0;
            }
        };

        /// <summary>
        /// Retrieves the history of the component that this object represents.
        /// </summary>
        public RegDBHistory[] GetHistory()
        {
            //return from cache if possible
            if (historyCache!=null)
            {
                return historyCache;
            }

            //
            SqlConnection sqlCon=RegDB.OpenSQLConnection();

            //Get a list of matching suites
            {
                string query="SELECT [SubCompID] FROM [RegDB].[dbo].[SubComponent] where SubComponent='" + suiteName + "'";
                SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();

                if (!reader.Read()) //no entry for suite in the db
                {
                    return historyCache=new RegDBHistory[0];
                }

                suiteID=(uint)(int)reader[0];

                if (reader.Read())
                {
                    Global.RO.Warn("Duplicates suite names found in RegDB... this should never happen.  Only the first ID will be used.");
                }

                reader.Close();
            }

            //If no group detail was requested, return info about the suite
            if (groupName==null)
            {
                string queryOfDoom=@"select [IterationID],[TotalPass],[TotalFail] from ( 
                    SELECT [IterationID],[TotalPass],[TotalFail] FROM [RegDB].[dbo].[BuildSummary] where SubCompID="+suiteID+@" 
                  union 
                    select [IterationID],0 as TotalPass,0 as TotalFail from [RegDB].[dbo].OutputLogs where SubComponentID="+suiteID+@" and IterationID not in
                      (SELECT [IterationID] FROM [RegDB].[dbo].[BuildSummary] where SubCompID="+suiteID+@" )
                ) as aoeu";

                SqlDataReader reader=new SqlCommand(queryOfDoom, sqlCon).ExecuteReader();

                System.Collections.ArrayList vec=new System.Collections.ArrayList();
                while (reader.Read())
                {
                    string env; string build; uint iter;
                    LookupBuildFromIterID((uint)(int)reader[0], out build, out iter, out env);

                    RegDBHistory e=new RegDBHistory(env, (uint)(int)reader[0], build, iter);
                    e.Passed=(uint)(int)reader[1];
                    e.Failed=(uint)(int)reader[2];
                    vec.Add(e);
                }

                RegDBHistory []histArr=new RegDBHistory[vec.Count];
                for (uint i=0; i<vec.Count; ++i)
                {
                    histArr[i]=(RegDBHistory)vec[(int)i];
                }

                reader.Close();

                //
                System.Array.Sort(histArr);
                return historyCache=histArr;
            }

            //Get a list of matching groups
            {
                string query="SELECT [TestGroupID] FROM [RegDB].[dbo].[TestGroup] where [SubCompID]=" + suiteID + " and [TestGroup]='" + groupName + "'";
                SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();

                if (!reader.Read()) //no entry for group in the db
                {
                    return historyCache=new RegDBHistory[0];
                }

                groupID=(uint)(int)reader[0];

                if (reader.Read())
                {
                    Global.RO.Warn("Duplicates group names found for a suite in RegDB... this should never happen.  Only the first ID will be used.");
                }

                reader.Close();
            }

            //If no case info was requested, return info about the group
            if (caseName==null)
            {
                string query="EXEC regdb..sp_GetIterationInfo_Group "+groupID;
                SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader(); //returns iterationID, build, iteration number, environment

                System.Collections.Generic.List<RegDBHistory> vec = new System.Collections.Generic.List<RegDBHistory>();
                while (reader.Read())
                {
                    RegDBHistory h=new RegDBHistory((string)reader[5],(uint)(int)reader[0], (string)reader[1], (uint)(int)reader[2]);
                    h.Passed=(uint)(int)reader[3];
                    h.Failed=(uint)(int)reader[4]-h.Passed;
                    vec.Add(h);
                }

                return historyCache=vec.ToArray();
            }

            //Get a list of matching cases
            {
                string query="SELECT [TestCaseID] FROM [RegDB].[dbo].[TestCase] where TestGroupID=" + groupID + " and TestCaseName='" + caseName + "'";
                SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();

                if (!reader.Read()) //no entry for suite in the db
                {
                    return historyCache=new RegDBHistory[0];
                }

                caseID=(uint)(int)reader[0];

                if (reader.Read())
                {
                    Global.RO.Warn("Duplicates case names found for a group in a suite in RegDB... this should never happen.  Only the first ID will be used.");
                }

                reader.Close();
            }

            //Return info about those cases
            {
                string queryOfDoom=@"SELECT [IterationID],[Result] FROM (
                  SELECT [IterationID],[Result] FROM [RegDB].[dbo].[TestRun] where TestCaseID="+caseID+@"
                union
                  select [IterationId],0 as Result from [RegDB].[dbo].OutputLogs where CaseID="+caseID+@" and IterationID not in
                    (SELECT [IterationID] FROM [RegDB].[dbo].[TestRun] where TestCaseID="+caseID+@")
                ) as aoeu";
                SqlDataReader reader=new SqlCommand(queryOfDoom, sqlCon).ExecuteReader();

                System.Collections.ArrayList vec=new System.Collections.ArrayList();
                while (reader.Read())
                {
                    string env; string build; uint iter;
                    LookupBuildFromIterID((uint)(int)reader[0], out build, out iter, out env);

                    RegDBHistory e=new RegDBHistory(env, (uint)(int)reader[0], build, iter);
                    e.Passed=(uint)(int)reader[1];
                    e.Failed=1-(uint)(int)reader[1];
                    vec.Add(e);
                }

                RegDBHistory []histArr=new RegDBHistory[vec.Count];
                for (uint i=0; i<vec.Count; ++i)
                {
                    histArr[i]=(RegDBHistory)vec[(int)i];
                }

                System.Array.Sort(histArr);
                return historyCache=histArr;
            }
        }

        /// <summary>
        /// Retrieves the output from a specific build of the component represented by this object.
        /// </summary>
        public string GetLog(RegDBHistory version)
        {
            return GetLog(version.IterationID);
        }
        /// <summary>
        /// Retrieves the output from a specific build of the component represented by this object.
        /// /// if outDst is non-null, then the log is pushed into a specific reporting destination rather than returned as a string
        /// </summary>
        public string GetLog(RegDBHistory version, Report.Destination outDst)
        {
            return GetLog(version.IterationID, outDst);
        }
        /// <summary>
        /// Retrieves the output from a specific build of the component represented by this object.
        /// </summary>
        public string GetLog(string environment, string build, uint iteration)
        {
            uint iterID=LookupIterIDFromBuild(build,iteration,environment);
            return GetLog(iterID);
        }
        /// <summary>
        /// Retrieves the output from a specific build of the component represented by this object.
        /// </summary>
        public string GetLog(uint iterationID)
        {
            return GetLog(iterationID,null);
        }
        /// <summary>
        /// Retrieves the output from a specific build of the component represented by this object.
        /// if outDst is non-null, then the log is pushed into a specific reporting destination rather than returned as a string
        /// </summary>
        public string GetLog(uint iterationID, Report.Destination outDst)
        {
            try
            {
                System.Threading.Interlocked.Increment(ref retrievingHistoryCount);

                if (cancelLog)
                {
                    return "";
                }

                //if we have no history populated yet, retrieve it
                if (historyCache==null)
                {
                    GetHistory();
                }

                //
                SqlConnection sqlCon=RegDB.OpenSQLConnection();

                //Grab all log entries that matches our iteration ID and suite ID, and optionally group and case IDs
                string query="SELECT [Date],[LogLevel],[Data] FROM [RegDB].[dbo].[OutputLogs] where SubComponentID="+suiteID+" and IterationID="+iterationID;
                if (groupName!=null)
                {
                    query+=" and GroupID="+groupID;
                }
                if (caseName!=null)
                {
                    query+=" and CaseID="+caseID;
                }

                query+=" order by Id";

                SqlDataReader reader=new SqlCommand(query, sqlCon).ExecuteReader();

                //pool the entries into a nice happy string
                string log="";
                if (outDst!=null)
                {
                    log=null;
                }

                while (reader.Read())
                {
                    System.DateTime dt=(System.DateTime)reader[0];
                    uint logLevel=(uint)(byte)reader[1];
                    string text=(string)reader[2];

                    string fullTestName=suiteName;
                    if (groupName!=null) fullTestName+="."+groupName;
                    if (caseName!=null) fullTestName+="."+caseName;

                    //check for cancel
                    if (cancelLog)
                    {
                        string cancelStr="\n-----GetLog() request cancelled-----\n";

                        if (outDst==null)
                        {
                            log+=cancelStr;
                        }
                        else
                        {
                            outDst.Log(Report.INFO, null, cancelStr, fullTestName, dt);
                        }

                        break;
                    }

                    //handle the logline
                    if (outDst==null)
                    {
                        log+=Report.FormatLogLine(dt, logLevel, "", text);
                        log+="\n";
                    }
                    else
                    {
                        outDst.Log(logLevel, null, text, fullTestName, dt);
                    }
                }

                return log;
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref retrievingHistoryCount);
                if (retrievingHistoryCount==0) cancelLog=false;
            }
        }

        /// <summary>
        /// Cancels a currently running GetLog() request.
        /// This blocks until log retrieval is actually halted.
        /// </summary>
        public void CancelGetLog()
        {
            while (retrievingHistoryCount!=0)
            {
                cancelLog=true;
                System.Threading.Thread.Sleep(50);
            }
        }

        // -- Internal stuff

        //Looks up the build and iteration number for a specific iteration ID
        private void LookupBuildFromIterID(uint iterID, out string build, out uint iter, out string env)
        {
            if (iterID==0)
            {
                throw new System.Exception("IterationID of 0 is invalid.");
            }

            lock (iterCache)
            {
                //hit cache first
                if (iterCache.Contains(iterID))
                {
                    IterCacheEntry entry=(IterCacheEntry)iterCache[iterID];
                    build=entry.build;
                    iter=entry.iterNum;
                    env=entry.env;
                    return;
                }

                //hit db
                if (sqlConLookup==null)
                {
                    sqlConLookup=RegDB.OpenSQLConnection();
                }

                string query="SELECT [BuildNo],[IterationNO],[EnvironmentID] FROM [RegDB].[dbo].[Iteration] where IterationID="+iterID;
                SqlDataReader reader=new SqlCommand(query, sqlConLookup).ExecuteReader();
                
                if (!reader.Read())
                {
                    reader.Close();
                    throw new System.Exception("IterationID "+iterID+" not found in Iteration table.");
                }

                build=(string)reader[0];
                iter=(uint)(int)reader[1];
                int envID=(int)(byte)reader[2];

                reader.Close();

                //get env name from ID
                query="SELECT Name FROM [RegDB].[dbo].[Environments] where EnvironmentId="+envID;
                reader=new SqlCommand(query, sqlConLookup).ExecuteReader();
                
                if (!reader.Read())
                {
                    reader.Close();
                    throw new System.Exception("EnvironmentID "+envID+" not found in Environments table.");
                }

                env=(string)reader[0];

                reader.Close();

                //add to cache
                { //evil C# scope-ness fix
                    IterCacheEntry entry=new IterCacheEntry();
                    entry.build=build;
                    entry.iterNum=iter;
                    entry.env=env;
                    iterCache.Add(iterID,entry);
                }
            }
        }

        //Looks up the build and iteration number for a specific iteration ID
        private uint LookupIterIDFromBuild(string build, uint iter, string env)
        {
            if (sqlConLookup==null)
            {
                sqlConLookup=RegDB.OpenSQLConnection();
            }

            string query="SELECT [IterationID] FROM [RegDB].[dbo].[Iteration] where BuildNo='" + build + "' and IterationNO=" + iter + " and Environment=" + env;
            uint id=(uint)(int)(new SqlCommand(query, sqlConLookup).ExecuteScalar());

            return id;
        }

        //name of the suite/group/case that we represent for an environment
        private string suiteName,groupName,caseName;

        //cached history
        RegDBHistory[] historyCache=null;
        object lockHistoryRetrieval=new object();

        //RegDB IDs populated by GetHistory()
        uint suiteID; //us
        uint groupID; //us, if we are a group
        uint caseID; //us, if we are a case

        //cached sql connections (so .NET doesn't freak out)
        SqlConnection sqlConLookup; //for lookups

        //interruption control
        volatile bool cancelLog=false;
        volatile int retrievingHistoryCount=0;

        //cache of different iteration IDs
        class IterCacheEntry
        {
            public string build;
            public uint iterNum;
            public string env;
        }
        System.Collections.Hashtable iterCache=new System.Collections.Hashtable();
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Cleanser.cs ===
using System;

namespace ServerTestFramework.STFLive.Reporting
{
    public class Cleanser : IReportingComponent
    {
        private string m_ComponentName;

        // TODO: Add cleanser connection TCP class (Should be located in a common library)

        public Cleanser(string serverName)
        {
            m_ComponentName = serverName;
        }

        /// <summary>
        /// What server you are dealing with
        /// </summary>
        public ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.Cleanser;
            }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public string ComponentName
        {
            get
            {
                return m_ComponentName;
            }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            // TODO: Check valid event types for this class
            //          Throw if not supported
            //       Grab the instance from the factory
            //       Generate that event type
            //       Make the associated calls to the cleanser
            //       Fill in the event data structure
            //       Return
            return "";
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            // TODO: Check valid next event types for this class
            //          Throw if not supported
            //       Make the associated calls to the cleanser
            //       Update the event data structure
            //       Return
            return "";
        }
        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public int GetIntPerformanceCounter(string Counter)
        {
            // TODO: Check that this server has this counter (use common code)
            //       Query the counter
            //       Return the value
            return 0;
        }
        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public float GetFloatPerformanceCounter(string Counter)
        {
            // TODO: Check that this server has this counter (use common code)
            //       Query the counter
            //       Return the value
            return 0.0f;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\RegDB\RegDBEventListener.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using System.Collections;

namespace ServerTestFramework.Reporting
{
    public class RegDBTestEventListener : TestEventListener
    {
        private RegDB regDB;

        public RegDBTestEventListener(string buildNo, int iterationNo)
        {
            regDB = new RegDB(buildNo, iterationNo);
        }

        public void OnTestEvent(TestEventArgs e)
        {
            if (e.Node==null)
            {
                return;
            }

            if (e.Node.ChildrenCount>0) //only send out leaf node events
            {
                return;
            }

            //hack up the testName into the old suite/group/case, since RegDB doesn't yet understand arbitrary trees.
            string []parts=e.Node.FullName.Split(new char[]{'.'});
            string suiteName="_";
            string groupName="_";
            string caseName="_";
            if (parts.Length>=1) suiteName=parts[0];
            if (parts.Length>=2) groupName=parts[1];
            if (parts.Length>=3) caseName=parts[2];
            for (int i=3; i<parts.Length; ++i)
                caseName+="."+parts[i];

            int bugId=e.BugID;

            //
            try
            {
                switch(e.Action)
                {
                    case TestAction.Start:
                        regDB.Start(suiteName, groupName, caseName, e.Details, bugId);
                        break;
                    case TestAction.Pass:
                        regDB.Pass(suiteName, groupName, caseName, e.Details, bugId);
                        break;
                    case TestAction.Fail: case TestAction.PreFail: case TestAction.PostFail:
                        regDB.Fail(suiteName, groupName, caseName, e.Details, bugId);
                        break;
                }
            }
            catch (Exception ex)
            {
                Global.RO.Warn(e.Node.FullName + ": Failed to log test event to regression DB: " + ex.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\RegDB\RegDB.cs ===
using System;
using System.Xml;
using System.Text.RegularExpressions;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;

namespace ServerTestFramework.Reporting
{
    public enum LogFlags {Fail = 0, Pass = 1}

    public class RegDBSettings
    {
        public string []IpAddresses;
        public string DefaultIpAddress;
        public string BuildNumber;
        public string Iteration;

        public bool IsValid()
        {
            return DefaultIpAddress != "" && BuildNumber != "" && Iteration != "";
        }

        public void SaveToConfig(StfXmlDoc config)
        {
            XmlElement regEl = config.SelectSingleNode("/stf/config/regressiondb") as XmlElement;

            if(regEl != null)
            {
                regEl.SetAttribute("defaultip", DefaultIpAddress);
                regEl.SetAttribute("buildno", BuildNumber);
                regEl.SetAttribute("iteration", Iteration);
            }
        }

        public void LoadFromConfig(StfXmlDoc config)
        {
            XmlElement regEl = config.SelectSingleNode("/stf/config/regressiondb") as XmlElement;

            // ensure that we have a regression config element
            if(regEl == null)
            {
                XmlNode configNode = config.SelectSingleNode("/stf/config");
                if(configNode == null)
                {
                    configNode = config.DocumentElement.AppendChild(config.CreateElement("config"));
                }
                regEl = configNode.AppendChild(config.CreateElement("regressiondb")) as XmlElement;
            }

            // Get the default settings (these may have been populated by a previus run)
            DefaultIpAddress = regEl.GetAttribute("defaultip");
            BuildNumber = regEl.GetAttribute("buildno");
            Iteration = regEl.GetAttribute("iteration");


            // Get the list of all IP addresses under the regression element
            // make sure the default IP address shows up first
            XmlNodeList nlist = regEl.SelectNodes("ip");
            if(nlist.Count == 0)
            {
                IpAddresses = new string[1];
                IpAddresses[0] = DefaultIpAddress;
            }
            else
            {
                IpAddresses = new string[nlist.Count];
                if(DefaultIpAddress != "")
                {
                    IpAddresses[0] = DefaultIpAddress;
                }
    
                for (int i = 0; i < nlist.Count; i++)
                {
                    // Only add the IP address if it is not the default
                    if(nlist[i].InnerText != DefaultIpAddress)
                    {
                        IpAddresses[i] = nlist[i].InnerText;
                    }
                }
            }
        }
    }

    public class RegDB: IDisposable
    {
        //
        protected SqlConnection connection;

        private static RegDBReportDestination regDBLogger=null;
        private static object regDBLogLock=new object();

        //RegDB server that connected successfully
        static volatile string goodRegDBIP=null;

        protected string BuildNo;
        protected int IterationNo;
        protected string Environment;

        //
        public RegDB(string buildNo, int iterationNo)
        {
            connection = OpenSQLConnection();
            BuildNo = buildNo;
            IterationNo = iterationNo;
            Environment=Global.XEnv.GetEnv();

            Global.RO.Debug("RegDB: env={2}, buildNo={0}, iteration={1}", buildNo, iterationNo, Global.XEnv.GetEnv());

            //setup logging connection
            lock (regDBLogLock)
            {
                if (regDBLogger!=null)
                {
                    Global.RO.Debug("RegDB Logger instance already exists... removing old instance.");
                    ServerTestFramework.Report.GetRoot().RemoveReportDestination(regDBLogger);
                    regDBLogger=null;
                }

                regDBLogger=new RegDBReportDestination(buildNo, iterationNo, Global.XEnv.GetEnv());
                ServerTestFramework.Report.GetRoot().AddReportDestination(regDBLogger);
            }
        }

        public void Dispose()
        {
            if (regDBLogger!=null)
            {
                ServerTestFramework.Report.GetRoot().RemoveReportDestination(regDBLogger);
                regDBLogger=null;
                Global.RO.Debug("Stopped RegDB logging.");
            }
        }

        static object regDBConnectLock=new object();

        /// <summary>
        /// Asynchronously attempts to connect to all RegDB server IPs and returns as soon as a successful connection is made.
        /// Once one is found, the server name is cached so subsequent attempts return much quicker.
        /// </summary>
        public static SqlConnection OpenSQLConnection()
        {
            lock (regDBConnectLock)
            {
                //if we have a cached name that worked, try that one first
                if(goodRegDBIP!=null)
                {
                    try
                    {
                        SqlConnection c=new SqlConnection("Data Source=" + goodRegDBIP + ";Initial Catalog=regdb;user id=regression;password=regression");
                        c.Open();
                        return c;
                    }
                    catch
                    {
                        Global.RO.Debug("Cached connection failed, will retry all servers.");
                        goodRegDBIP=null;
                    }
                }

                //try all servers asynchronously
                RegDBSettings rds=new RegDBSettings();
                rds.LoadFromConfig(Global.Config);
                if (rds.IpAddresses.Length==0)
                {
                    throw new System.Exception("No RegDB server(s) specified in your config.");
                }

                Global.RO.Debug("Trying to connect to RegDB servers...");
                ParallelRunner.Status runStatus=ParallelRunner.RunAsync(OpenSQLConnectionWorker, (uint)rds.IpAddresses.Length, 256, rds.IpAddresses, 0);
                while (runStatus.IsStillRunning)
                {
                    if (goodRegDBIP!=null) break;
                    System.Threading.Thread.Sleep(50);
                }

                if (goodRegDBIP==null)
                {
                    Global.RO.Warn("Failed to connect to RegDB.");
                    throw new System.Exception("Could not connect to any RegDB server in your config.");
                }

                //connect to chosen server
                {
                    Global.RO.Debug("Using RegDB server: " + goodRegDBIP);
                    SqlConnection c=new SqlConnection("Data Source=" + goodRegDBIP + ";Initial Catalog=regdb;user id=regression;password=regression");
                    c.Open();
                    return c;
                }
            }
        }

        static object regDBOpenLock=new object();

        //helper for OpenSQLConnection to try a single connection
        private static void OpenSQLConnectionWorker(uint num, object obj)
        {
            string ip=((string[])obj)[num];

            try
            {
                SqlConnection c=new SqlConnection("Data Source=" + ip + ";Initial Catalog=regdb;user id=regression;password=regression");
                c.Open();
                lock (regDBOpenLock)
                {
                    if (goodRegDBIP==null) goodRegDBIP=ip;
                }
                c.Close();
            }
            catch //this connection didn't work; oh well.
            {
            }
        }

        //
        protected void Log(TestAction action, string suiteName, string groupName, string testName, string resultDetails, int bugID)
        {
            bool pass;

            if (resultDetails == null)
                resultDetails = "";

            switch(action)
            {
                case TestAction.Pass:
                    pass = true;
                    break;
                case TestAction.Fail:
                    pass = false;
                    break;
                default:
                    return;
            }

            SqlNonQuery("EXEC regdb..sp_InsertTestResults '" + 
                BuildNo + "', " + 
                IterationNo + ", '" + 
                suiteName + "', '" + 
                groupName + "', '" + 
                testName.Replace("'", "''") + "', '" + 
                testName.Replace("'", "''") + "', " +  // TODO-jrepp: this used to be description of the test
                (pass ? "1" : "0") + ", '" + 
                resultDetails.Replace("'", "''") + "', " + 
                bugID + ", " +
                Environment);
        }

        public void Pass(string suiteName, string groupName, string testName, string resultDetails, int bugID)
        {
            Log(TestAction.Pass, suiteName, groupName, testName, resultDetails, bugID);
        }

        public void Fail(string suiteName, string groupName, string testName, string resultDetails, int bugID)
        {
            Log(TestAction.Fail, suiteName, groupName, testName, resultDetails, bugID);
        }

        public void Start(string suiteName, string groupName, string testName, string resultDetails, int bugID)
        {
            Log(TestAction.Start, suiteName, groupName, testName, resultDetails, bugID);
        }


        protected void SqlNonQuery(string s)
        {
            lock (sqlLock)
            {
                new SqlCommand(s, connection).ExecuteNonQuery();
            }
        }

        private object sqlLock=new object();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\RegDB\RegDBLog.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using System.Data.SqlClient;

namespace ServerTestFramework.Reporting
{
    //passes stf output to the RegDB
    public class RegDBReportDestination: Report.Destination
    {
        public RegDBReportDestination(string buildNo, int iterationNo, string targetEnvironment)
        {
            sqlCon=RegDB.OpenSQLConnection();

            buildNumber = buildNo;
            iteration = iterationNo;
            environment = targetEnvironment;

            Global.RO.Debug("RegDBLog: buildNo: {0}, iteration: {1}, env: {2}", buildNo, iterationNo, environment);
        }

        //Report Destination output
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            if (disableOutput || sqlCon==null || message.Length==0)
            {
                return;
            }

            //hack up the testName into the old suite/group/case, since RegDB doesn't yet understand arbitrary trees.
            string []parts=testName.Split(new char[]{'.'});
            string suiteName="_";
            string groupName="_";
            string caseName="_";
            if (parts.Length>=1) suiteName=parts[0];
            if (parts.Length>=2) groupName=parts[1];
            if (parts.Length>=3) caseName=parts[2];
            for (int i=3; i<parts.Length; ++i)
                caseName+="."+parts[i];

            //Do the log
            try
            {
                string query="EXEC regdb..[sp_RegDB_AddLog] '" + 
                    buildNumber + "', '" + 
                    iteration + "', '" + 
                    environment + "', '" + 
                    suiteName + "', '" + 
                    groupName + "', '" + 
                    caseName.Replace("'", "''") + "', '" + 
                    level + "', '" + 
                    message.Replace("'", "''") + "'";

                //execute the stored proc to log it
                lock (sqlLock)
                {
                    new SqlCommand(query, sqlCon).ExecuteNonQuery();
                }
            }
            catch (System.Exception e)
            {
                //temporarily disable logging to RegDB for this thread so that we can safely output to other destinations still
                try
                {
                    disableOutput=true;
                    Global.RO.Warn("Error logging output to RegDB.  The logline has been dropped.  Exception: " + e.Message);
                }
                finally
                {
                    disableOutput=false;
                }
            }
        }

        //records whether this thread's output is temporarily disabled
        [System.ThreadStatic]
        private static bool disableOutput=false;

        //sql stuff
        private SqlConnection sqlCon=null;
        private object sqlLock=new object();

        //version stuff
        private string environment;
        private string buildNumber;
        private int iteration;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\CleanserConnection.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Net.Sockets;



using ServerTestFramework;
using xonline.common.config;
using xonline.common.mgmt;



using ServerTestFramework.STFLive.Reporting;



namespace ServerTestFramework.STFLive.Reporting
{

    public enum CleanserConnectionType
    {
        VipConnection = 0,
        FirstCleanser
    }

    /// <summary>
    /// Encapsulates a connection to the cleanser using the cleanser protocol. Simulates the ReportConnection
    /// object used by the XomLog system during regular logging from service components. The exception is that
    /// this class does not simulate the async IO ReportConnection uses. This class is also not threadsafe.
    /// </summary>
    public class CleanserConnection
    {

        private Socket socket = null;
        private IPEndPoint remoteEP = null;
       
        public IPEndPoint RemoteEndPoint
        {
            get { return remoteEP; }
        }

        //default to first cleanser as most tests will want to operate on a single cleanser directly
        private CleanserConnectionType conType = CleanserConnectionType.FirstCleanser;

        public CleanserConnectionType ConnectionType
        {
            get
            {
                return conType;
            }
        }

        //default to 10,000 even tho max message size is 2048 currently. This allows us to test the truncation 
        //mechanism (core/mgmt/XomLogTarget.cs)
        private int messageBufferSize = 10000;
        
        private long currentTime = 0;

        private Report log = new Report("CleanserConnection"); 

        public CleanserConnection(CleanserConnectionType conType,ServiceComponentType ct)
        {
            Init(conType,ct);
        }

        
        public CleanserConnection(CleanserConnectionType conType,ServiceComponentType ct, int bufferSize)
        {
            messageBufferSize = bufferSize;
            Init(conType,ct);
        }
         


        private void Init(CleanserConnectionType inconType, ServiceComponentType ct)
        {
            currentTime = DateTime.UtcNow.ToFileTimeUtc();

            string[] szServers = null;

            IInterfaceInfo face = null;
            remoteEP = null;

            conType = inconType;

            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            if (conType == CleanserConnectionType.VipConnection)
            {
                remoteEP = GetVirutalInterface();
            }
            else if (conType == CleanserConnectionType.FirstCleanser)
            {
                remoteEP = GetFirstCleanser();
            }

            if (remoteEP == null)
            {
                log.Info("No virtual IP Endpoint could be found for this environment. Looking for first cleanser found...");


                szServers = Config.GetServerListByInterface(Interface.cleanser);

                if (null == szServers)
                {
                    log.Fatal("No cleansers found for current configuration! Aborting");
                    throw new ApplicationException("No cleanser found for current environment");
                }
                else
                {
                    face = Config.GetInterface(szServers[0], Interface.cleanser);
                    remoteEP = new IPEndPoint(face.IPAddress, face.Port);
                }
            }

            string hostName = System.Environment.MachineName;

            // Connect to the remote endpoint.
            socket.Connect(remoteEP);

            ReportMessageConnect connect = new ReportMessageConnect();
            connect.vcServer = hostName;  //connecting from this machine
            connect.iComponentID = (int)ct; //emulate the correct component for the message

            Send((byte[])connect);
            
        }


        ~CleanserConnection()
        {
            try
            {
                Close();
            }
            catch (Exception)
            {
                //eat this
            }
        }

        /// <summary>
        /// Helper function to get the remote endpoint of the first available cleanser
        /// </summary>
        /// <returns></returns>
        private IPEndPoint GetFirstCleanser()
        {
            IPEndPoint remoteEP = null;

            try
            {

                //vInterface = Global.XEnv.GetInterface("Cleanser");
                string[] szServers = null;
                szServers = Config.GetServerListByInterface(Interface.cleanser);
                IInterfaceInfo face = Config.GetInterface(szServers[0], Interface.cleanser);
                remoteEP = new IPEndPoint(face.IPAddress, face.Port);
                
            }
            catch (Exception)
            {
                //error loading, or was not found. Either way, VIP not available
                log.Info("Cleanser Not Found!!!!");
            }

            
            return remoteEP;
        }


        /// <summary>
        /// Helper function to find the cleanserinh vip endpoint
        /// </summary>
        /// <returns></returns>
        private IPEndPoint GetVirutalInterface()
        {
            IVirtualInterfaceInfo interfaceInfo = null;

            try
            {
                interfaceInfo = Config.GetVirtualInterface("cleanserinh");
                
            }
            catch (Exception)
            {
                //error loading, or was not found. Either way, VIP not available
                //we may still be able recover by finding the servers directly
                //but that is up to the caller
                log.Info("CleanserINH Not VIP FOUND");
                return null;
            }

            return new IPEndPoint(interfaceInfo.IPAddress, interfaceInfo.Port);
        }

   

        //Close the connection to the cleanser and cleanup the socket resources
        public void Close()
        {

            if (socket != null)
            {
                if (socket.Connected)
                {
                    //close the connection to the cleanser via the protocol
                    ReportMessageBase msgDisconnect = new ReportMessageBase();
                    msgDisconnect.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_DISCONNECT;
                    Send((byte[])msgDisconnect);

                    socket.Shutdown(SocketShutdown.Both);

                }
                socket.Close();
                socket = null;
            }

        }




        public void Send(string logLine)
        {
            if (string.IsNullOrEmpty(logLine))
            {
                throw new ArgumentNullException("Null or empty logline submitted to Send");
            }


            //Use the cleanser protocol to send the logline
            ReportMessageData data = new ReportMessageData();
            data.szMessage = logLine;
            data.llTime = currentTime;
            Send((byte[])data);
        }


        //Helper function for blitting a bitstream to the cleanser
        private void Send(byte[] buffer)
        {
            Debug.Assert(buffer.Length != 0);

            int sizeSent = -1;


            try
            {
                sizeSent = socket.Send(buffer, SocketFlags.None);
                
                
            }
            catch (Exception e)
            {
                log.Fatal(e.ToString());
                throw;
            }
            if (sizeSent != buffer.Length)
            {
                throw new Exception("Failed to send full message: original size = " + buffer.Length + " sent size  = " + sizeSent);
            }
        }



        public bool CheckConnection()
        {
            if( (socket != null) && (socket.Connected) )
            {
                //Try to send a keepalive, and see if the cleanser is still there
                ReportMessageBase msgKeepAlive = new ReportMessageBase();
                msgKeepAlive.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_KEEPALIVE;
                Send( (byte[])msgKeepAlive );
                return true;
            }
            return false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingCommon.cs ===
// Common Reporting Class and Interfaces
using System;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;

using ServerTestFramework.STFLive.Database;
using ServerTestFramework.STFLive;
using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// The current machines that are in some way involved in reporting
    /// </summary>
    public enum ReportingMachines
    {
        /// <summary>
        /// Uninitialized value
        /// </summary>
        Uninitialized,
        /// <summary>
        /// Client - Source for most server side events
        /// Hey, I can dream, can't I?
        /// </summary>
        Client,
        /// <summary>
        /// XBOS -
        /// Content Referral, Argo Licensing, etc.
        /// </summary>
        Xbos,
        /// <summary>
        /// XUACS -
        /// 
        /// </summary>
        Xuacs,
        /// <summary>
        /// XCBK -
        /// Account Provisioning/Deprovisioning
        /// </summary>
        Xcbk,
        /// <summary>
        /// Presence -
        /// TitleStart/TitleEnd, SessionStart/SessionEnd, GuestChanges, Messaging
        /// </summary>
        PresenceINH,
        /// <summary>
        /// StringServer -
        /// Fusion, Banner Click/View/Purchase
        /// </summary>
        StringSvr,
        /// <summary>
        /// WMIS -
        /// All argo related metadata
        /// </summary>
        WMIS,
        /// <summary>
        /// UODB -
        /// All user related data, achievements, etc.
        /// </summary>
        UODB,
        /// <summary>
        /// ProductDB -
        /// All product data, offers, etc.
        /// </summary>
        ProductDB,
        /// <summary>
        /// Cleanser -
        /// Server where all of the INH/Frontdoor data is collected
        /// </summary>
        Cleanser,
        /// <summary>
        /// SSIS -
        /// Server where all of the UODB and WMIS data is collected
        /// </summary>
        SSIS,
        /// <summary>
        /// FilterDB, distribution location for data passing through the cleansers
        /// </summary>
        Filter,
        /// <summary>
        /// Main reporting database
        /// </summary>
        Reporting,
        /// <summary>
        /// Main aggregation database
        /// </summary>
        OLAP,
        /// <summary>
        /// IIS Server that serves out reports
        /// </summary>
        Rosetta,
        /// <summary>
        /// Archive database for the reporting database
        /// </summary>
        Archive,
        /// <summary>
        /// Realtime reports database
        /// </summary>
        Realtime

    }

    /// <summary>
    /// Xbox Live Reports
    /// </summary>
    public enum XBLReports
    {
        AchievementSummary,
        ContractualPartners,
        FirstTitlePlayed,
        LastWebActivity,
        MarketplaceDownloadSummary,
        MarketplaceScorecard,
        MarketRedeemedContentTitleOffer,
        MarketRedeemedContentTypeTier,
        MusicRoyalty,
        PublisherTitleUsageDaily,
        PublisherTitleUsageMonthly,
        RealTimeAccounts,
        RealTimeTitleUsage,
        SubscriberLife,
        TitleUsageDetails,
        TitleUsageSummary,
        VideoRoyalty,
        VideoStudio,
        VisitorFrequency,
        Xbox1DownloadDetails,
        XboxAccountSummary
    }

    /// <summary>
    /// Interface for all servers or machines interacting with Reporting
    /// </summary>
    public interface IReportingComponent
    {
        /// <summary>
        /// What server you are dealing with
        /// </summary>
        ReportingMachines ComponentType
        {
            get;
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        string ComponentName
        {
            get;
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject);
        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject);
        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        int    GetIntPerformanceCounter(string Counter);
        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        float  GetFloatPerformanceCounter(string Counter);
    }

    /// <summary>
    /// A class defining database servers iwthin reporting
    /// </summary>
    public abstract class ReportingDatabase : IReportingComponent
    {
        // SQL Connection object for internal use only
        protected SqlConnection m_SqlConnection;

        // New items
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public abstract string DatabaseName
        {
            get;
            set;
        } 

        /// <summary>
        /// List of jobs to execute
        /// </summary>        
        protected List<ReportingJob> JobQueue;

        /// <summary>
        /// Hashtable to store Reporting Job threads
        /// </summary>
        protected Hashtable JobThreads;

        /// <summary>
        /// Close any internal items. This must be called somewhere inside the destructor of derived classes.
        /// </summary>
        protected virtual void CloseJobQueueThreads()
        {
           
            // Destroy Job queue
            if (JobQueue != null)
            {
                // Kill any threads
                if (JobThreads != null)
                {
                    foreach (ReportingJob j in JobQueue)
                    {
                        if (JobThreads.Contains(j.JobName))
                        {
                            ((Thread)JobThreads[j.JobName]).Abort();
                        }
                    }
                    JobThreads.Clear();
                }


                JobQueue.Clear();
            }
            JobQueue = null;
            JobThreads = null;
        }

        // Overridden members

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public abstract string RunDebugQuery();
        /// <summary>
        /// Runs a query against the tables for this database using the data available in the reference objects
        /// </summary>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public virtual string RunDebugQuery(ReportingReferenceObject reportingRefObject)
        {
            string retVal = "";
            // Command object
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = m_SqlConnection;

            // Get SQL query to inject data rom Loader
            cmd.CommandText = reportingRefObject.RunDebugQuery();
            cmd.CommandTimeout = 3000000;
            // Check if the data injection was successful by looking at affected rows
            int affectedRows = 0;
            try
            {
                affectedRows = cmd.ExecuteNonQuery();


                // If the query was NOT an Insert/Delete/Update, then affected rows will be -1. 
                // Execute the query again using correct method to obtain results.
                if (affectedRows < 0)
                {
                    object t = cmd.ExecuteScalar();
                    if (t != null)
                    {
                        retVal = t.ToString();
                    }
                }
                else
                {
                    retVal = affectedRows.ToString();
                }
            }
            catch (Exception exce)
            {
                Console.WriteLine("Error executing query: \n" + exce.Message + "\n" + exce.StackTrace);
                retVal = exce.Message;
            }

            return retVal;
        }
        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public abstract ReportingJob QueueJob(ReportingJobType jobType);
        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public abstract ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters);
        /// <summary>
        /// Runs the queued jobs
        /// </summary>
        /// <returns>An array list with the return values with the associated ReportingJob Objects which contain the results of each job</returns>
        public virtual List<ReportingJob> RunJobs()
        {
            ReportingJob temp;
            // Force synchronized access to job list
            lock (JobQueue)
            {
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    temp = JobQueue[i];

                    // Verify that there is no existing Thread executing for this job
                    if (!JobThreads.Contains(temp.JobName))
                    {
                        // Create new thread
                        Thread jobThread = new Thread(RunJob);
                        jobThread.Start((object)i);
                        JobThreads.Add(temp.JobName, jobThread);

                        // Sleep main thread so new threads can begin processing
                        Thread.Sleep(500);
                    }
                }
                // Give a little extra time for jobs to start on remote servers
                Thread.Sleep(500);
            }

            return JobQueue;
        }

        /// <summary>
        /// Sub-function to run each job in a separate Thread.
        /// </summary>
        /// <param name="JobIndex">Reporting Job to be run</param>
        /// <returns></returns>
        protected virtual void RunJob(object JobIndex)
        {
            // Run Through Jobs in sequence
            SqlCommand sqlCmd = new SqlCommand();
            sqlCmd.CommandTimeout = 5000;

            ReportingJob CurrentJob = JobQueue[(int)JobIndex];
            // Force synchronized access to job list
            lock (CurrentJob)
            {
                // Use database connection
                sqlCmd.Connection = m_SqlConnection;

                // Verify that the job is not running already
                if (CurrentJob.HResult != ReportingJobStatus.Running)
                {
                    // Run Job
                    sqlCmd.CommandText = CurrentJob.RunJob();

                    // Reset job status
                    if (CurrentJob.HResult == ReportingJobStatus.Idle)
                    {
                        CurrentJob.StartTime = DateTime.Now;
                        CurrentJob.Completed = false; CurrentJob.Results = "STARTING JOB";
                    }

                    // Each job knows how to execute itself. The database needs
                    // to verify if it's only executing a sproc (like p_daily_processing) to use the command object
                    if (sqlCmd.CommandText.Length > 4)
                    {
                        if (sqlCmd.CommandText.ToUpper().Contains("EXEC"))
                        {
                            // Execute job against database
                            CurrentJob.HResult = ReportingJobStatus.Running;
                            try
                            {
                                sqlCmd.ExecuteNonQuery();
                            }
                            catch (Exception Exce)
                            {
                                // Fail Job and log exception message
                                CurrentJob.HResult = ReportingJobStatus.Failed;
                                CurrentJob.Results = Exce.Message;
                                CurrentJob.RunningTime = TimeSpan.FromDays(0.0f);
                                CurrentJob.Completed = true;
                                sqlCmd = null;
                                return;
                            }
                        }
                    }

                    // Update job status while job is running
                    do
                    {
                        Thread.Sleep(1000);
                        CurrentJob.UpdateStatus();
                    }
                    while (CurrentJob.HResult == ReportingJobStatus.Running);
                    
                }
            }
            sqlCmd = null;
        }

        /// <summary>
        /// Updates the status of the queued jobs. *Note that only jobs that have already been started will be updated*
        /// </summary>
        /// <returns>An array list of the currently queued jobs with their updated status</returns>>        
        public virtual List<ReportingJob> GetCurrentJobStatus()
        {
            // Run through jobs and ping server about job status

            // Force synchronized access to job list
            lock (JobQueue)
            {
                foreach (ReportingJob currentJob in JobQueue)
                {
                    // Only return jobs that are NOT idling
                    if (currentJob.HResult != ReportingJobStatus.Idle)
                    {

                        // Close Threads that are finished
                        if (currentJob.HResult == ReportingJobStatus.Completed ||
                            currentJob.HResult == ReportingJobStatus.Failed)
                        {
                            if (JobThreads.Contains(currentJob.JobName))
                            {
                                // Try to join thread and give 90 second timeout
                                ((Thread)JobThreads[currentJob.JobName]).Join(TimeSpan.FromSeconds(90f));
                                JobThreads.Remove(currentJob.JobName);
                            }
                        }

                    }//If job started
                }//foreach job
            }
            return JobQueue;
        }

        /// <summary>
        /// Stops all jobs currently executing
        /// </summary>
        /// <returns>The database job queue</returns>
        public virtual List<ReportingJob> StopJobs()
        {
            lock (JobQueue)
            {
                foreach (ReportingJob currentJob in JobQueue)
                {
                    // Only return jobs that are NOT idling
                    if (currentJob.HResult != ReportingJobStatus.Idle)
                    {
                        currentJob.StopJob(); // Stop the job
                        if (JobThreads.Contains(currentJob.JobName))
                        {
                            // Try to join thread and give 90 second timeout
                            ((Thread)JobThreads[currentJob.JobName]).Join(TimeSpan.FromSeconds(90f));
                            JobThreads.Remove(currentJob.JobName);
                        }//If jobThread
                    }// If job running
                }//foreach job
            }

            return JobQueue;
        }


        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public abstract string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject);
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public abstract string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer);
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public abstract string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject);
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public abstract string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer container);
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public abstract string ListReplicationStreamsAndStatus();
        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public abstract string Verify(ReportingReferenceObject refObject);
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public abstract string Verify(ReportingReferenceObjectContainer refObjectContainer);

        /// <summary>
        /// What server you are dealing with
        /// </summary>
        public virtual ReportingMachines ComponentType
        {
            get { return ReportingMachines.Uninitialized; }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public virtual string ComponentName
        {
            get { return "Uninitialized"; }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public virtual string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject) 
        {
            reportingRefObject = null;
            return ""; 
        }
        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public virtual string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject) 
        {
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public virtual int GetIntPerformanceCounter(string Counter) { return -1; }
        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public virtual float GetFloatPerformanceCounter(string Counter) { return -0.0f; }
    }


    /// <summary>
    /// Main class for reporting test code
    /// </summary>
    public class ReportingCommon
    {

        private static ReportingCommon m_Instance = null;

        /// <summary>
        /// Returns the singleton for this class
        /// </summary>
        public static ReportingCommon Instance
        {
            get
            {
                if (m_Instance == null)
                    m_Instance = new ReportingCommon(false);
                return m_Instance;
            }
        }

        /// <summary>
        /// Clears the current singleton
        /// Should ONLY be done at the beginning of a test group
        /// </summary>
        public static void ClearInstance(bool useTestDatabases)
        {            
            m_Instance = new ReportingCommon(useTestDatabases);
        }

        private ReportingDatabase m_ReportingDB = null;
        /// <summary>
        /// A reference to the reportingDB
        /// </summary>
        public ReportingDatabase ReportingDB
        {
            get
            {
                return m_ReportingDB;
            }
        }

        private ReportingDatabase m_ReportingSSISDB = null;
        /// <summary>
        /// A reference to the SSISDB
        /// </summary>
        public ReportingDatabase ReportingSSISDB
        {
            get
            {
                return m_ReportingSSISDB;
            }
        }

        private ReportingDatabase m_ReportingArchiveDB = null;
        /// <summary>
        /// A reference to the Archive DB
        /// </summary>
        public ReportingDatabase ReportingArchiveDB
        {
            get
            {
                return m_ReportingArchiveDB;
            }
        }

        private ReportingDatabase m_ReportingOLAPDB = null;
        /// <summary>
        /// A reference to the OLAPDB
        /// </summary>
        public ReportingDatabase ReportingOLAPDB
        {
            get
            {
                return m_ReportingOLAPDB;
            }
        }

        private ReportingDatabase m_ReportingIIS = null;
        /// <summary>
        /// A reference to the ReportIIS - Report Service
        /// </summary>
        public ReportingDatabase ReportingIIS
        {
            get
            {
                return m_ReportingIIS;
            }
        }

        private ReportingDatabase m_RealtimeDB = null;
        /// <summary>
        /// A reference to the ReportingRealtime database
        /// </summary>
        public ReportingDatabase RealtimeDB
        {
            get
            {
                return m_RealtimeDB;
            }
        }



        private List<ReportingDatabase> m_FilterDBs = null;
        /// <summary>
        /// A reference to ALL of the filterdbs
        /// </summary>
        public List<ReportingDatabase> FilterDBs
        {
            get
            {
                return m_FilterDBs;
            }
        }

        private List<IReportingComponent> m_Cleansers = null;
        /// <summary>
        /// A reference to ALL of the cleansers
        /// </summary>
        public List<IReportingComponent> Cleansers
        {
            get
            {
                return m_Cleansers;
            }
        }

        /// <summary>
        /// Find the component object (Ex. ReportingDatabase) given an interface name.
        /// </summary>
        /// <param name="iFace">Interface name (Ex. reportingdb)</param>
        /// <returns>A list of all components related to that interface or an empty list if no components were found</returns>
        public List<IReportingComponent> FindObjectByInterface(string iFace)
        {
            List<IReportingComponent> retVal = new List<IReportingComponent>(); // Return list

            if (iFace != null && iFace != string.Empty)
            {
                switch (iFace)
                {
                    case Interface.reportingdb:     // ReportingDB
                        retVal.Add(ReportingDB);
                        break;
                    case Interface.reportssisdb:    // ReportSSISDB
                        retVal.Add(ReportingSSISDB);
                        break;
                    case Interface.rosetta:         // Rosetta
                        retVal.Add(ReportingIIS);
                        break;
                    case Interface.reportarchivedb: // ReportArchiveDB
                        retVal.Add(ReportingArchiveDB);
                        break;
                    case Interface.filterdb:        // FilterDBs
                        foreach (ReportingDatabase t in FilterDBs)
                        {
                            retVal.Add(t);
                        }
                        break;
                    case Interface.cleanser:        // Cleansers
                        retVal = Cleansers;
                        break;
                    default:
                        // No component found
                        break;

                }//switch(iFace)
            }//if(iFace != null)


            return retVal;            
        }// FindObjectbyInterface


        private ReportingCommon(bool useTestDatabases)
        {
            // Temporary object to get interfaces
            string[] szServers; 
            ReportingDatabase filter; // Temp object to initialize filterDbs
         
            // Use Normal Databases
            if (!useTestDatabases)
            {
                // Get ReportingDB Interface            
                szServers = Config.GetServerListByInterface(Interface.reportingdb);
                m_ReportingDB = new ReportingDB();
                ((ReportingDB)m_ReportingDB).ConnectToServer(szServers[0]);

                // Get Olap Interface            
                szServers = Config.GetServerListByInterface(Interface.olapGameUsage);
                m_ReportingOLAPDB = new OLAPDB();
                ((OLAPDB)m_ReportingOLAPDB).ConnectToServer(szServers[0]);

                // Get ReportingSSISDB Interface
                szServers = Config.GetServerListByInterface(Interface.reportssisdb);
                m_ReportingSSISDB = new ReportingSSIS();
                ((ReportingSSIS)m_ReportingSSISDB).ConnectToServer(szServers[0]);

                // Get ReportIIS Interface
                switch(Config.Environment.ToUpper())
                {
                    case "STRESSNET":
                        m_ReportingIIS = new ReportingIIS("https://reports.stress.xboxlive.com/ReportServer/ReportService.asmx");
                        break;
                    case "TESTNET":
                        m_ReportingIIS = new ReportingIIS("https://reports.test.xboxlive.com/ReportServer/ReportService.asmx");
                        break;
                    default:
                        szServers = Config.GetServerListByInterface(Interface.rosetta);
                        m_ReportingIIS = new ReportingIIS("http://" + szServers[0] + "/ReportServer/ReportService.asmx");
                        break;
                }              

                // Get ReportArchiveDB Interface
                szServers = Config.GetServerListByInterface(Interface.reportarchivedb);
                m_ReportingArchiveDB = new ReportingArchiveDatabase();
                ((ReportingArchiveDatabase)m_ReportingArchiveDB).ConnectToServer(szServers[0]);

                // Get RealtimeDB Interface
                try
                {
                    szServers = Config.GetServerListByInterface(Interface.reportrealtimedb);
                    m_RealtimeDB = new ReportRealtimeDB();
                    ((ReportRealtimeDB)m_RealtimeDB).ConnectToServer(szServers[0]);
                }
                catch (Exception)
                {
                    // pedrofv 04/10/2008
                    // REALTIME REPORTING HAS BEEN DEPRECATED FROM PRODUCTION
                }

                // Get FilterDB Interfaces
                szServers = Config.GetServerListByInterface(Interface.filterdb);
                if (szServers.Length > 0)
                {
                    // Initialize Filter list
                    m_FilterDBs = new List<ReportingDatabase>(szServers.Length);
                    for (int i = 0; i < szServers.Length; i++)
                    {
                        filter = new FilterDB();
                        ((FilterDB)filter).ConnectToServer(szServers[i]);
                        m_FilterDBs.Add(filter);
                    }
                }
                
                // Get Cleanser Interfaces
                szServers = Config.GetServerListByInterface(Interface.cleanser);
                if (szServers.Length > 0)
                {
                    // Initialize Cleanser list
                    //*************
                    // TO DO..
                    //*************
                }
            }// If !UseTestDB
            else
            {
                // Use Test Databases
                throw new Exception("Use of test databases is not implemented yet");
            }
        }//ReportingCommon(bool)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingData.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;



namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// A reference object class representing a data set
    /// </summary>
    public abstract class ReportingData : ReportingReferenceObject
    {
        /// <summary>
        /// Data source: UODB, SSIS, ReportingDB, etc
        /// </summary>
        public abstract ReportingDatabase Source
        {
            get;
            set;
        }

        /// <summary>
        ///  Get ReportingData object type
        /// </summary>
        public abstract ReportingDataType ObjectType
        {
            get;            
        }

        /// <summary>
        /// Get internal data type (Queries, Raw, Counts)
        /// </summary>
        public abstract InternalDataType DataType
        {
            get;
            set;
        }


        /// <summary>
        /// List of queries
        /// </summary>
        public virtual Hashtable Queries
        {
            set { }
            get { return null; }
        }

        /// <summary>
        /// Raw object data (Caller must know how to cast the data)
        /// </summary>
        public virtual object RawData
        {
            set { }
            get { return null; }   
        }

        /// <summary>
        /// ReportingData is a series of tables and respective row counts
        /// </summary>
        public virtual NameValueCollection TableCounts
        {
            set { }
            get { return null; }
        }


        /// <summary>
        /// This classifies the data that a ReportingData object contains
        /// </summary>
        public enum InternalDataType
        {
            /// <summary>
            ///  ReportingData object is a query or set of queries
            /// </summary>
            Query,

            /// <summary>
            /// ReportingData object contains raw data
            /// </summary>
            RawData,

            /// <summary>
            /// ReportingData object contains a set of tables and respective rowcounts
            /// </summary>
            TableCounts
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingDataLoader.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// A class containing the logic necessary to load data for a particular type of data
    /// </summary>
    public abstract class ReportingDataLoader
    {
        public abstract List<string> GetSupportedDatabases();
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public virtual string InjectSingleData()
        {
            return "";
        }

        public virtual string InjectSingleData(ReportingTable TargetTable)
        {
            return "";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingEvent.cs ===
using System;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// A reference object representing an individual event
    /// </summary>
    public abstract class ReportingEvent : ReportingReferenceObject
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingReferenceObject.cs ===
using System;

namespace ServerTestFramework.STFLive.Reporting
{

    public abstract class ReportingReferenceObject
    {
        protected string m_InitialServer;
        protected string m_InitialDB;

        public virtual string RunDebugQuery()
        {
            throw new Exception("Reporting Debug Query not defined");
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingHelper.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;

// Common Reporting Helper functions

namespace ServerTestFramework.STFLive.Reporting
{
    public class ReportingHelper
    {
        public static Report Log = new Report("ReportingHelper");

        //
        //  Classes
        //

        /// <summary>
        /// ColumnInfo 
        /// </summary>
        public class ColumnInfo
        {
            public string _szColumnName;
            public object _obj;
            public Type _tt;
            public bool _bKey;

            public ColumnInfo(string sCol, object obj, Type tt) 
            {
                _szColumnName=sCol; 
                _obj = obj; 
                _tt =tt;
            }
        }

        //
        //  Functions
        //

        /// <summary>
        /// fn_get_i_time 
        /// </summary>
        public static int fn_get_i_time(DateTime dt)
        {
            int iTime = dt.Hour*10000000+dt.Minute*100000+dt.Second*1000+dt.Millisecond;

            return iTime;
        }

        /// <summary>
        /// fn_get_dt_time 
        /// </summary>
        public static DateTime fn_get_dt_datetime(int iDate, int iTime)
        {
            DateTime dtDate = new DateTime(iDate / 10000, (iDate / 100) % 100, iDate % 100, iTime / 10000000, (iTime / 100000) % 100000, (iTime / 1000) % 1000, iTime % 1000);

            return dtDate;
        }

        /// <summary>
        /// fn_get_i_date 
        /// </summary>
        public static int fn_get_i_date(DateTime dt)
        {
            int iDate = dt.Year*10000+dt.Month*100+dt.Day;

            return iDate;
        }

        /// <summary>
        /// fn_get_dt_date 
        /// </summary>
        public static DateTime fn_get_dt_date(int iDate)
        {
            DateTime dtDate = new DateTime(iDate / 10000, (iDate / 100) % 100, iDate % 100);

            return dtDate;
        }

        /// <summary>
        /// API to get single row from a table
        /// </summary>
        /// <param name="sProvider"> SQLDataProvider </param>
        /// <param name="szTable"></param>
        /// <returns> SqlDataReader </returns>
        public static SqlDataReader GetTopContent(SqlConnection Connection, string szTable)  
        {
            SqlCommand cmd;

            cmd = new SqlCommand();
            cmd.Connection = Connection;
            cmd.CommandType = CommandType.Text;
            cmd.CommandText = string.Format("SELECT top 1 * FROM [{0}]", szTable);
            SqlDataReader reader = null;
            reader = cmd.ExecuteReader();

            return reader;
        }

           /// <summary>
        /// API to get single row from a table
        /// </summary>
        /// <param name="sProvider"> SQLDataProvider </param>
        /// <param name="szTable"></param>
        /// <returns> SqlDataReader </returns>
        public static NameValueCollection GetTopContent(ReportingDatabase Database, string szTable)
        {            
            NameValueCollection result = new NameValueCollection();
            // Iterate through reader
            SqlConnection Connection = new SqlConnection(string.Format("Integrated Security=SSPI;Initial Catalog={0};server={1}", Database.DatabaseName, Database.ComponentName));
            Connection.Open();
            SqlDataReader reader = GetTopContent(Connection, szTable);
            while (reader.Read())
            {              
                // Scroll through each column in reader
                for (int i = 0; i < reader.FieldCount; i++)
                {                    
                   
                   result.Add(reader.GetName(i), reader.GetValue(i).ToString());
                   
                }
            }
            if (reader != null)
            {
                reader.Close();
            }
            reader = null;
            Connection.Close();
            Connection = null;
            return result;
        }

        /// <summary>
        /// API to get single row from a table with conditions
        /// </summary>
        /// <param name="sProvider"> SQLDataProvider </param>
        /// <param name="szTable"></param>
        /// <param name="aList"> ArrayList of ColumnInfo </param>
        /// <returns> SqlDataReader </returns>
        public static SqlDataReader GetContent(SqlConnection Connection, string szTable, ArrayList aList)  
        {
            SqlCommand cmd;

            cmd = new SqlCommand();
            cmd.Connection = Connection;
            cmd.CommandType = CommandType.Text;

            string query = string.Format("SELECT top 1 * FROM [{0}]  ", szTable);
            
            for(int ii=0; ii<aList.Count; ii++)
            {
                ColumnInfo td = (ColumnInfo)aList[ii];
                
                if(ii == 0)
                    query += string.Format(" WHERE ");
                else
                    query += string.Format(" AND ");

                if(td._tt.ToString() == "System.String")
                {
                        query += string.Format(" {0} = '{1}'", td._szColumnName,  ((string)td._obj).Replace("'","''"));
                }
                else if(td._tt.ToString()  == "System.Boolean"|| td._tt.ToString()  == "System.Guid" )
                {
                        query += string.Format(" {0} = '{1}'", td._szColumnName,  td._obj);
                }
                else
                {
                        query += string.Format(" {0} = {1}", td._szColumnName,  td._obj);
                }
            }

            cmd.CommandText = query;
            SqlDataReader reader = null;
            try
            {
                reader = cmd.ExecuteReader();
            }
            catch(System.Data.SqlClient.SqlException e)
            {
                Log.Warn(e.Message);
                Log.Warn(query);
            }

            return reader;
        }

        /// <summary>
        /// CompareSingleRow 
        /// Compare a row in two tables column by column
        /// Currently it only cares about Byte, Int16, Int32, Int64, Boolean and String type
        /// </summary>
        public static bool CompareSingleRow(ArrayList sArrayList, ArrayList tArrayList)
        {
            bool bResult = true;
            
            for(int ii=0; ii<sArrayList.Count; ii++)
            {
                ColumnInfo std = (ColumnInfo)sArrayList[ii];
                ColumnInfo ttd = (ColumnInfo)tArrayList[ii];

                Log.Info("Comparing {0}...", std._szColumnName);
                
                if(std._szColumnName != ttd._szColumnName)
                {
                    Log.Warn("_szColumnNames are different : {0} : {1}", std._szColumnName, ttd._szColumnName);
                    bResult = false;
                    continue;
                }
                if(std._tt != ttd._tt)
                {
                    Log.Warn("Types are different : {0} : {1}", std._tt.ToString(), ttd._tt.ToString());
                    bResult = false;
                    continue;
                }

                bool bSame=true;
                
                if(std._tt.ToString() == "System.Byte")
                    bSame = ((System.Byte)std._obj == (System.Byte)ttd._obj);
                else if(std._tt.ToString() == "System.String")
                    bSame = ((System.String)std._obj == (System.String)ttd._obj);
                else if(std._tt.ToString() == "System.Int64")
                    bSame = ((System.Int64)std._obj == (System.Int64)ttd._obj);
                else if(std._tt.ToString() == "System.Int32")
                    bSame = ((System.Int32)std._obj == (System.Int32)ttd._obj);
                else if(std._tt.ToString() == "System.Int16")
                    bSame = ((System.Int16)std._obj == (System.Int16)ttd._obj);
                else if(std._tt.ToString() == "System.Boolean")
                    bSame = ((System.Boolean)std._obj == (System.Boolean)ttd._obj);
                else if(std._tt.ToString() == "System.Guid")
                    bSame = ((System.Guid)std._obj == (System.Guid)ttd._obj);
                else if(std._tt.ToString() == "System.Decimal")
                    bSame = ((System.Decimal)std._obj == (System.Decimal)ttd._obj);
                    
                if(bSame)
                {
                    Log.Info("Values are same : {0} : {1}", std._obj.ToString(), ttd._obj.ToString());
                }
                else
                {
                    Log.Warn("Values are different : {0} : {1}", std._obj.ToString(), ttd._obj.ToString());
                    bResult = false;
                }
            }

            return bResult;
        }


        /// <summary>
        /// FillColumnInfo 
        /// </summary>
        public static ArrayList FillColumnInfo(SqlDataReader sReader)
        {
            ArrayList   sArrayList = new ArrayList();

            for(int ii=0; ii<sReader.FieldCount; ii++)
            {
                string sCol = sReader.GetName(ii);
                object obj = sReader.GetValue(ii);
                Type tt = obj.GetType();

                // Removing columns hard to compare  from the list
                // Adding Hack to remove npdb:t_game_config:xml_config from comparing list since its type is ntext but tt returns string
                if(tt.ToString() == "System.DateTime" || tt.ToString() == "System.Byte[]" || tt.ToString() == "System.DBNull" || sCol == "xml_config")
                    continue;
                    
                ReportingHelper.ColumnInfo td = new ReportingHelper.ColumnInfo(sCol, obj, tt);
                sArrayList.Add(td);
            }

            return sArrayList;
        }
                
        /// <summary>
        /// GetArgumentString 
        /// </summary>
        public static string GetArgumentString(XmlDocument doc, string szTag)
        {
            XmlNodeList elemList = doc.GetElementsByTagName(szTag);
            if(elemList.Count != 1)
                throw new Exception("Num of " + szTag + " in xml is " + elemList.Count);

            return elemList[0].InnerXml;
        }

        /// <summary>
        /// GetArgumentInt 
        /// </summary>
        public static int GetArgumentInt(XmlDocument doc, string szTag)
        {
            XmlNodeList elemList = doc.GetElementsByTagName(szTag);
            if(elemList.Count != 1)
                throw new Exception("Num of " + szTag + " in xml is " + elemList.Count);

            return Int32.Parse(elemList[0].InnerXml);
        }

        /// <summary>
        /// GetArgumentBool 
        /// </summary>
        public static bool GetArgumentBool(XmlDocument doc, string szTag)
        {
            XmlNodeList elemList = doc.GetElementsByTagName(szTag);
            if(elemList.Count != 1)
                throw new Exception("Num of " + szTag + " in xml is " + elemList.Count);

            if(elemList[0].InnerXml.Equals("0"))
                return false;
            else
                return true;
        }




        /// <summary>
        /// Compare if two collections are equal. They are considered equal if they have the same number
        /// of objects and all objects from Data1 are present in Data2
        /// </summary>
        /// <param name="Data1">First Name/Value Collection</param>
        /// <param name="Data2">Second Name/Value Collection</param>
        /// <returns>True if the 2 sets of data are equal. False for everything else</returns>
        public static bool CollectionCompare_Equal(NameValueCollection Data1, NameValueCollection Data2)
        {
            // Parameter check
            if (Data1 == null || Data2 == null)
            {
                return false;
            }
            if (Data1.Count == 0 || Data2.Count == 0)
            {
                return false;
            }
            // Check that they have the same amount of records
            if (Data1.Count != Data2.Count)
            {
                return false;
            }
            // If the sets have the same length and all data from Data1 is present in Data2, then they are equal
            return CollectionCompare_DataPresent(Data1, Data2);
        }


        /// <summary>
        /// Compare if two collections are different. They are considered different if they have the different number
        /// of objects or objects from Data1 are not present in Data2
        /// </summary>
        /// <param name="Data1">First Name/Value Collection</param>
        /// <param name="Data2">Second Name/Value Collection</param>
        /// <returns>True if the 2 sets of data are different. False for everything else</returns>
        public static bool CollectionCompare_Different(NameValueCollection Data1, NameValueCollection Data2)
        {
            // Parameter check
            if (Data1 == null || Data2 == null)
            {
                return false;
            }
            if (Data1.Count == 0 || Data2.Count == 0)
            {
                return false;
            }
            // If the sets have different lenghts then they are different
            if (Data1.Count != Data2.Count)
            {
                return true;
            }
            // If the sets have the same length, and data from Data1 is NOT PRESENT in Data2, then they are different
            return !CollectionCompare_DataPresent(Data1, Data2);
        }

        /// <summary>
        /// Compare the values of a collection against each other to find if any are repeated
        /// </summary>
        /// <param name="Data1">Name/Value Collection</param>
        /// <returns>True if the set of data has repeated values. False for everything else</returns>
        public static bool CollectionNoRepeatedValues(NameValueCollection Data1)
        {
            // Parameter check
            if (Data1 == null)
            {
                return false;
            }
            if (Data1.Count == 0)
            {
                return false;
            }
            // Loop through all the values in the collection
            for (int currentValue = 0; currentValue < Data1.Count; currentValue++)
            {
                // Loop through all the keys in the collection
                for (int currentKey = 0; currentKey < Data1.AllKeys.Length; currentKey++)
                {
                    // Skip comparison if keys and values match
                    if (currentKey == currentValue)
                    {
                        continue;
                    }
                    // If the value is found for another key, then return true
                    if (Data1.Get(currentValue) == Data1.Get(Data1.GetKey(currentKey)))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Compare if all the elements from Data1 are present in Data2. Note that this DOES NOT mean they are equal
        /// </summary>
        /// <param name="Data1">First Name/Value Collection</param>
        /// <param name="Data2">Second Name/Value Collection</param>
        /// <returns>True if ALL elements from Data1 are present in Data2 (This does not mean that Data1 = Data2)</returns>
        public static bool CollectionCompare_DataPresent(NameValueCollection Data1, NameValueCollection Data2)
        {
            // Parameter check
            if (Data1 == null || Data2 == null)
            {
                return false;
            }
            if (Data1.Count == 0 || Data2.Count == 0)
            {
                return false;
            }

            // Loop through Data1
            for (int i = 0; i < Data1.Count; i++)
            {
                for (int j = 0; j < Data2.Count; j++)
                {
                    try
                    {
                        // If the element from Data1 is found in Data2 then continue to the next Data1 element
                        if (Convert.ToDouble(Data1.Get(i)) == Convert.ToDouble(Data2.Get(j)))
                        {
                            break;
                        }
                    }
                    catch (FormatException) // This means data is not numeric
                    {
                        // If any of the elements of Data1 are not in Data2, return false                    
                        if (Data1.Get(i) == Data2.Get(j))
                        {
                            break;
                        }
                    }
                    // If any of the elements of Data1 are not in Data2, return false
                    if (j == (Data2.Count - 1))
                    {
                        return false;
                    }
                }
            }

            return true;
        }



    }//class ReportingHelper

    // Table Definitions    
    public class DateRange
    {
        public string dateMin;
        public string dateMax;
        public int minDelta;
        public int maxDelta;

        /// <summary>
        /// Constructor for DateRange. Set dateMin and dateMax values.
        /// </summary>        
        /// <param name="minus">Delta to subtract from current time in seconds</param>
        /// <param name="plus">Delta to add to current time in seconds</param>
        public DateRange(int minus, int plus)
        {
            minDelta = minus;
            maxDelta = plus;
            Reset();
        }
                /// <summary>
        /// Constructor for DateRange. Set dateMin and dateMax values.
        /// </summary>
        /// <param name="Seed">Initial Time</param>
        /// <param name="minus">Delta to subtract from current time in seconds</param>
        /// <param name="plus">Delta to add to current time in seconds</param>
        public DateRange(DateTime Seed, int minus, int plus)
        {
            minDelta = minus;
            maxDelta = plus;
            Reset(Seed);
        }

        /// <summary>
        /// Recenters the date range around the current time.
        /// </summary>
        public void Reset()
        {
            DateTime dtNow = DateTime.Now;
            dateMin = dtNow.AddSeconds(minDelta * (-1)).ToString("MM/dd/yyyy HH:mm:ss.fff");
            dateMax = dtNow.AddSeconds(maxDelta).ToString("MM/dd/yyyy HH:mm:ss.fff");
        }
        /// <summary>
        /// Recenters the date range around the time in 'Seed'
        /// </summary>
        public void Reset(DateTime Seed)
        {
            DateTime dtNow = Seed;
            dateMin = dtNow.AddSeconds(minDelta * (-1)).ToString("MM/dd/yyyy HH:mm:ss.fff");
            dateMax = dtNow.AddSeconds(maxDelta).ToString("MM/dd/yyyy HH:mm:ss.fff");
        }
    }


    /// <summary>
    /// Basic Reporting Ref object test class
    /// </summary>
    public class TestRefObject : ReportingReferenceObject
    {
        private string m_Query = "";
        public string DebugQuery
        {
            set { m_Query = value; }
            get { return m_Query; }
        }

        /// <summary>
        /// Return RefObject Debug Query
        /// </summary>
        /// <returns></returns>
        public override string RunDebugQuery()
        {
            return m_Query;
        }
    }//class TestRefObject
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingJob.cs ===
using System;
using System.Data;
using System.Collections.Specialized;
using System.Threading;

using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;

using ServerTestFramework.Database;
using ServerTestFramework.STFLive.Database;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// Job Status
    /// </summary>
    public enum ReportingJobStatus
    {
        Idle,
        Running,
        Completed,
        Failed
    }


    /// <summary>
    /// 
    /// </summary>
    public abstract class ReportingJob
    {
        public static Report Log = new Report("ReportingJob");

        /// <summary>
        /// Using .NET built-in Job class internally
        /// </summary>
        protected Microsoft.SqlServer.Management.Smo.Agent.Job m_SQLJob;
        


        /// <summary>
        /// 
        /// </summary>
        protected bool m_Completed;

        /// <summary>
        /// 
        /// </summary>
        public bool Completed
        {
            get
            {
                return m_Completed;
            }
            set
            {
                lock (this)
                {
                    m_Completed = value;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected ReportingJobStatus m_HResult;

        /// <summary>
        /// 
        /// </summary>
        public ReportingJobStatus HResult
        {
            get
            {
                return m_HResult;
            }
            set
            {
                lock (this)
                {
                    m_HResult = value;
                }
            }
        }

        protected string m_Results;
        /// <summary>
        /// The results of this job
        /// </summary>
        public string Results
        {
            get
            {
                return m_Results;
            }
            set
            {
                m_Results = value;
            }
        }

        protected DateTime m_StartTime;

        /// <summary>
        /// When the job was started
        /// </summary>
        public DateTime StartTime
        {
            get
            {
                return m_StartTime;
            }
            set
            {
                m_StartTime = value;
            }
        }

        protected TimeSpan m_RunningTime;
        /// <summary>
        /// How long it took this job to run
        /// </summary>
        public TimeSpan RunningTime
        {
            get
            {
                return m_RunningTime;
            }
            set
            {
                m_RunningTime = value;
            }
        }

        protected String m_ServerName;

        /// <summary>
        /// Name of Server the job runs in
        /// </summary>
        public string ServerName
        {
            get
            {
                return m_ServerName;
            }            
        }

        protected String m_JobName;

        /// <summary>
        /// Name of the job
        /// </summary>
        public string JobName
        {
            get
            {
                return m_JobName;
            }            
        }

        /// <summary>
        /// Job Type
        /// </summary>
        protected ReportingJobType m_JobType;
        public ReportingJobType JobType
        {
            get
            {
                return m_JobType;
            }
        }



        protected NameValueCollection m_JobSteps;
        /// <summary>
        /// Job Steps
        /// </summary>
        public NameValueCollection JobSteps
        {
            get
            {
                return m_JobSteps;
            }
            set
            {
                m_JobSteps = JobSteps;
            }

        }

        /// <summary>
        /// Job parameters
        /// </summary>
        protected ReportingJobParameters m_Parameters;

        /// <summary>
        /// Job Parameters
        /// </summary>
        public ReportingJobParameters Parameters
        {
            get
            {
                return m_Parameters;
            }
        }


        /// <summary>
        /// Execute the job
        /// </summary>
        /// <returns>The constructed SQL script to execute the job</returns>
        public virtual string RunJob()                
        {            
            // Use SQL SMO object to run job
            // Get Server Object
            Microsoft.SqlServer.Management.Smo.Server sqlServer;

            // Get JobServer
            Microsoft.SqlServer.Management.Smo.Agent.JobServer jobServer;

            // Connect to that server
            sqlServer = new Microsoft.SqlServer.Management.Smo.Server(m_ServerName);
            jobServer = sqlServer.JobServer;

            // Get Job
            m_SQLJob = jobServer.Jobs[JobName];

            // Run Job if it exists
            if (m_SQLJob != null)
            {
                m_HResult = ReportingJobStatus.Running;
                m_StartTime = DateTime.Now;
                m_Completed = false;
                m_SQLJob.Start();
            }
            else
            {
                // Error if job not found
                throw new Exception("Error: Job '" + JobName + "' was not found in server '" + m_ServerName + "'");
            }

            return "";
        }

        /// <summary>
        /// Stop the job if it's currently executing
        /// </summary>
        public virtual void StopJob()
        {
            // Use SQL SMO object to run job
            // Get Server Object
            Microsoft.SqlServer.Management.Smo.Server sqlServer;

            // Get JobServer
            Microsoft.SqlServer.Management.Smo.Agent.JobServer jobServer;

            // Connect to that server
            sqlServer = new Microsoft.SqlServer.Management.Smo.Server(m_ServerName);
            jobServer = sqlServer.JobServer;

            // Get Job
            m_SQLJob = jobServer.Jobs[JobName];

            // Stop Job if it exists
            if (m_SQLJob != null)
            {
                m_HResult = ReportingJobStatus.Failed;
                m_RunningTime = DateTime.Now.Subtract(m_StartTime);
                m_Completed = false;
                try
                {
                    m_SQLJob.Stop();
                }
                catch (Exception)
                {
                    // Continue to stop despite Exceptions (Most likely a disconnect or the job was already stopped)
                    
                }
            }
            else
            {
                // Error if job not found
                throw new Exception("Error: Job '" + JobName + "' was not found in server '" + m_ServerName + "'");
            }
        }//StopJob()


        /// <summary>
        /// Update job status
        /// </summary>
        public virtual void UpdateStatus()
        {
            DataTable jobResults; DataTableReader reader;            

            // Use SQL SMO object to run job
            // Get Server Object
            Microsoft.SqlServer.Management.Smo.Server sqlServer;

            // Get JobServer
            Microsoft.SqlServer.Management.Smo.Agent.JobServer jobServer;

            // Connect to that server
            sqlServer = new Microsoft.SqlServer.Management.Smo.Server(m_ServerName);
            jobServer = sqlServer.JobServer;
            jobServer.Refresh();

            // Get Job
            m_SQLJob = jobServer.Jobs[JobName];

            // Run Job if it exists
            if (m_SQLJob != null)
            {
                // UPDATE JOB STATUS
                m_Completed = false;
                m_Results = m_SQLJob.CurrentRunStep;                
                // SQL RUN STATUS 1 = SUCCESS, 0 = FAILED, 3 = CANCELED, 4 = IN PROGRESS, 5 = UNKNOWN
                if (m_SQLJob.CurrentRunStatus == JobExecutionStatus.Executing)
                {
                     m_HResult = ReportingJobStatus.Running;
                     m_Results = "STARTING JOB";
                }
                else{
                    switch (m_SQLJob.LastRunOutcome)
                    {
                        case CompletionResult.Succeeded:
                            m_Completed = true;                            
                            m_HResult = ReportingJobStatus.Completed;                        
                            break;
                        case CompletionResult.InProgress:
                            m_HResult = ReportingJobStatus.Running;                            
                            break;
                        default:
                            m_HResult = ReportingJobStatus.Failed;                            
                            break;
                    }
                    // Get job history results
                    jobResults = m_SQLJob.EnumHistory();
                    reader = jobResults.CreateDataReader();
                    if (reader.Read())
                    {
                        m_Results = reader.GetString(reader.GetOrdinal("Message"));
                    }
                    else
                    {
                        m_Results = "Unable to find job execution details.";
                    }
                    reader = null;
                    jobResults = null;                    
                }
                m_RunningTime = DateTime.Now.Subtract(m_StartTime);
            }
            else
            {
                // Error if job not found
                throw new Exception("Error: Job '" + JobName + "' was not found in server '" + m_ServerName + "'");
            }
        }


       
        /// <summary>
        /// Execute the job
        /// </summary>
        /// <returns>JobExecutionStatus</returns>
        public virtual CompletionResult InvokeJob()                
        {
            StartTime = DateTime.Now;
            
            Server        myServer;
            //ServerConnection myServerConn;
            JobServer   myJobServer;
            Microsoft.SqlServer.Management.Smo.Agent.Job             myJob=null;

            myServer = new Server(ServerName);
            myJobServer = myServer.JobServer;

            myJob = myJobServer.Jobs[JobName];
            
            if(myJob != null)
            {
                myJob.Start();
                while(true)
                {
                    Thread.Sleep(1000);

                    myJob.Refresh();
                    if(myJob.CurrentRunStatus ==   JobExecutionStatus.Idle)
                        break;
                }
            }

            RunningTime  = DateTime.Now.Subtract(StartTime);
            Completed = true;

            switch(myJob.LastRunOutcome)
            {
                case CompletionResult.Cancelled:
                    Log.Warn("Job  Cancelled.");
                    break;

                case CompletionResult.Failed:
                    Log.Warn("Job  Failed.");
                    break;

                case CompletionResult.InProgress:
                    Log.Warn("Job  InProgress.");
                    break;

                case CompletionResult.Retry:
                    Log.Warn("Job  Retry.");
                    break;

                case CompletionResult.Succeeded:
                    Log.Info("Job  Succeeded.");
                    break;

                case CompletionResult.Unknown:
                    Log.Warn("Job  Unknown.");
                    break;
            }
            
            return myJob.LastRunOutcome;
        }       

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\MessageGenerator.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;
using System.Data.SqlClient;


//using xonline.common.mgmt;
//using xonline.common.config;
//using xonline.common.sql.sqlclient;
using xonline.common.config;


namespace ServerTestFramework.STFLive.Reporting
{


    public enum ServiceComponentType
    {
        Unknown = 3,     //placeholder for unknown component in generic messaging
        xcbk = 5,       //xonline.common.config.xbck
        xbos = 6,       //xonline.common.config.xbos
        xuacs = 7,      //xonline.common.config.xuacs
        stringsvr = 8,  // xonline.server.stringsvr
        xstatsfd = 9,   //xonline.server.xstatsfd
        presence = 17,  //xonline.common.config.xpserver
        sg = 23         //xonline.server.sgsvc

    }


    /// <summary>
    /// All currently known messages types fro npdb t_messages table as of 2/25/08
    /// </summary>
    public enum MessageType : int
    {
        CONTENTREF = 3,
        SND = 4,
        CREATEACCOUNT = 5,
        CREATELIVEACCOUNT = 6,
        CREATEXBOXCOMACCOUNT = 7,
        XeOfferPurchase = 8,
        XeContentReferral = 9,
        TITLESTART = 10,
        TITLEND = 11,
        SESSTART = 12,
        SESEND = 13,
        GUESTCHG = 14,
        MIGRATEXBOX1USER = 15,
        MigrateXboxComUser = 16,
        PROVISIONSERVICE = 17,
        DEPROVISIONSERVICE = 18,
        LS_BAN_VW = 19,
        LSA_BAN_VW = 20,
        LS_BAN_CL = 21,
        LSA_BAN_CL = 22,
        LS_MP_P = 23,
        LSA_MP_P = 24,
        LS_FU = 25,
        LSA_FU = 26,
        ARGOLICENSE = 27,
        GeoFenceOfferPurchase = 28,
        GeoFenceContentReferral = 29,
        GeoFenceVideoPurchase = 30,
        GeoFenceVideoAcquireURL = 31,
        GeoFenceVideoAcquireLicense = 32,
        LS_DHW = 33,
        LICTRANSFER = 34,
        GENERICMSG = 35,
        SGADDM = 36,
        SGUCHG = 37,
        SGTCHG = 38,
        SGDELM = 39,
        SGHASH = 40,
        PurchaseOffersReporting = 41,
        USAGE_STORE = 42,
        LICENSE_REQUEST = 43,
        SGAUTH = 44,
        SGDISK = 45,
        SGDMI = 46,
        SGGPR2 = 47,
        SGHRMOR = 48,
        SGFAIL = 49
    }


    /// <summary>
    /// Creates messages for all supported types in the current cleanser.
    /// These messages are generated from a combination of looking at service source code, 
    /// the old verification tests, and logs from various production servers.
    /// </summary>
    public class MessageGenerator
    {
        private delegate string ConstructMessage(ulong puid);

        private Dictionary<MessageType, ConstructMessage> m_messageMakers = new Dictionary<MessageType, ConstructMessage>();
        private Dictionary<MessageType, ServiceComponentType> m_message_component_map = new Dictionary<MessageType, ServiceComponentType>();

        #region Singleton Pattern Impl

        private static volatile MessageGenerator m_instance = null;
        private static object SyncRoot = new object();
        private static volatile bool m_initialized = false;

        public static MessageGenerator Instance
        {
            get
            {
                // only create a new instance if one doesn't already exist.
                if (m_instance == null)
                {
                    // use this lock to ensure that only one thread is access
                    // this block of code at once.
                    lock (SyncRoot)
                    {
                        if (m_instance == null)
                        {
                            m_instance = new MessageGenerator();
                            m_initialized = true;

                        }
                    }
                }
                // return instance where it was just created or already existed.
                return m_instance;
            }
        }

        #endregion


        private MessageGenerator()
        {
            if (m_initialized == true)
            {
                Debug.Assert(false, "Initialize somehow called twice!");
                return;
            }


            //stuff the MessageMakerMap. Basically stuff the right function pointer for each message type
            m_messageMakers.Add(MessageType.CONTENTREF, new ConstructMessage(BuildContentRefMessage));
            m_messageMakers.Add(MessageType.SND, new ConstructMessage(BuildSNDMessage));
            m_messageMakers.Add(MessageType.CREATEACCOUNT, new ConstructMessage(BuildCreateAccountMsg));
            m_messageMakers.Add(MessageType.CREATELIVEACCOUNT, new ConstructMessage(BuildCreateLiveAccountMsg));
            m_messageMakers.Add(MessageType.CREATEXBOXCOMACCOUNT, new ConstructMessage(BuildCreateXboxComAccountMsg));
            m_messageMakers.Add(MessageType.XeOfferPurchase, new ConstructMessage(BuildXeOfferPurchaseMsg));
            m_messageMakers.Add(MessageType.XeContentReferral, new ConstructMessage(BuildXeContentReferralMsg));
            m_messageMakers.Add(MessageType.TITLESTART, new ConstructMessage(BuildTitleStartMsg));
            m_messageMakers.Add(MessageType.TITLEND, new ConstructMessage(BuildTitleEndMsg));
            m_messageMakers.Add(MessageType.SESSTART, new ConstructMessage(BuildSessionStartMsg));
            m_messageMakers.Add(MessageType.SESEND, new ConstructMessage(BuildSessionEndMsg));
            m_messageMakers.Add(MessageType.GUESTCHG, new ConstructMessage(BuildGuestChgMsg));
            m_messageMakers.Add(MessageType.MIGRATEXBOX1USER, new ConstructMessage(BuildMigrateXbox1UserMsg));
            m_messageMakers.Add(MessageType.MigrateXboxComUser, new ConstructMessage(BuildMigrateXboxComUserMsg));
            m_messageMakers.Add(MessageType.PROVISIONSERVICE, new ConstructMessage(BuildProvisionServiceMsg));
            m_messageMakers.Add(MessageType.DEPROVISIONSERVICE, new ConstructMessage(BuildDeProvisionServiceMsg));
            m_messageMakers.Add(MessageType.LS_BAN_VW, new ConstructMessage(BuildLS_BAN_VWMsg));
            m_messageMakers.Add(MessageType.LSA_BAN_VW, new ConstructMessage(BuildLSA_BAN_VWMsg));
            m_messageMakers.Add(MessageType.LS_BAN_CL, new ConstructMessage(BuildLS_BAN_CLMsg));
            m_messageMakers.Add(MessageType.LSA_BAN_CL, new ConstructMessage(BuildLSA_BAN_CLMsg));
            m_messageMakers.Add(MessageType.LS_MP_P, new ConstructMessage(BuildLS_MP_PMsg));
            m_messageMakers.Add(MessageType.LSA_MP_P, new ConstructMessage(BuildLSA_MP_PMsg));
            m_messageMakers.Add(MessageType.LS_FU, new ConstructMessage(BuildLS_FUMsg));
            m_messageMakers.Add(MessageType.LSA_FU, new ConstructMessage(BuildLSA_FUMsg));
            m_messageMakers.Add(MessageType.ARGOLICENSE, new ConstructMessage(BuildArgoLicenseMsg));

            //geofencing messages
            m_messageMakers.Add(MessageType.GeoFenceOfferPurchase, new ConstructMessage(BuildGeoFenceOfferPurchaseMsg));
            m_messageMakers.Add(MessageType.GeoFenceContentReferral, new ConstructMessage(BuildGeoFenceContentReferralMsg));
            m_messageMakers.Add(MessageType.GeoFenceVideoPurchase, new ConstructMessage(BuildGeoFenceVideoPurchaseMsg));
            m_messageMakers.Add(MessageType.GeoFenceVideoAcquireURL, new ConstructMessage(BuildGeoFenceVideoAcquireURLMsg));
            m_messageMakers.Add(MessageType.GeoFenceVideoAcquireLicense, new ConstructMessage(BuildGeoFenceVideoAcquireLicenseMsg));

            m_messageMakers.Add(MessageType.GENERICMSG, new ConstructMessage(BuildGenericMsg));
            m_messageMakers.Add(MessageType.LS_DHW, new ConstructMessage(BuildLS_DHWMsg));
            m_messageMakers.Add(MessageType.LICTRANSFER, new ConstructMessage(BuildLicenseTransferMsg));
            m_messageMakers.Add(MessageType.PurchaseOffersReporting, new ConstructMessage(BuildPurchaseOffersReportingMsg));
            m_messageMakers.Add(MessageType.USAGE_STORE, new ConstructMessage(BuildUseageStoreLicenseMsg));
            m_messageMakers.Add(MessageType.LICENSE_REQUEST, new ConstructMessage(BuildLicenseRequestMsg));

            //SG
            m_messageMakers.Add(MessageType.SGADDM, new ConstructMessage(BuildSGADDMMsg));
            m_messageMakers.Add(MessageType.SGUCHG, new ConstructMessage(BuildSGUCHGMsg));
            m_messageMakers.Add(MessageType.SGTCHG, new ConstructMessage(BuildSGTCHGMsg));
            m_messageMakers.Add(MessageType.SGDELM, new ConstructMessage(BuildSGDELMMsg));
            m_messageMakers.Add(MessageType.SGHASH, new ConstructMessage(BuildSGHASHMsg));
            m_messageMakers.Add(MessageType.SGAUTH, new ConstructMessage(BuildSGAUTHMsg));
            m_messageMakers.Add(MessageType.SGDISK, new ConstructMessage(BuildSGDISKMsg));
            m_messageMakers.Add(MessageType.SGDMI, new ConstructMessage(BuildSGDMIMsg));
            m_messageMakers.Add(MessageType.SGGPR2, new ConstructMessage(BuildSGGPR2Msg));
            m_messageMakers.Add(MessageType.SGHRMOR, new ConstructMessage(BuildSGHRMORMsg));
            m_messageMakers.Add(MessageType.SGFAIL, new ConstructMessage(BuildSGFAILMsg));


            //load the dictionary of messages to service component
            LoadComponentToServiceMap();

        }

        /// <summary>
        /// Connects to NPDB and loads the componentID for each messageid. This is needed so that when 
        /// messages are sent to the cleanser we are sending them from the right component (spoofed). If this
        /// is not done, the cleanser is designed to reject the message.
        /// Note that this function is only ever called once per instance of the singleton (aka once per process)
        /// </summary>
        private void LoadComponentToServiceMap()
        {
            m_message_component_map.Clear();

            SqlConnection con = null;
            Report rpt = new Report("Component-Service Map:");

            try
            {

                string connect = Config.NpdbConnectionString;

                con = new SqlConnection(connect);
                con.Open();

                SqlCommand cmd = new SqlCommand("select si_message_id,si_component_id,vc_source_prefix from dbo.t_messages with (NOLOCK)", con);
                SqlDataReader rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    MessageType mid = (MessageType)rdr.GetInt16(0);
                    ServiceComponentType sct = (ServiceComponentType)rdr.GetInt16(1);
                    m_message_component_map.Add(mid, sct);
                }
                rdr.Close();

            }
            catch (Exception e)
            {
                rpt.Fatal("Failed to load message and component type maps from NPDB: " + e.ToString());
                throw;
            }

            finally
            {
                con.Close();
            }



        }


        public string BuildMessage(MessageType type, ulong puid)
        {

            return m_messageMakers[type](puid);
        }

        /// <summary>
        /// Allows a client to resolve the correct component that a message should come from
        /// </summary>
        /// <param name="mt"></param>
        /// <returns></returns>
        public ServiceComponentType MessageToServiceComponentType(MessageType mt)
        {
            return m_message_component_map[mt];
        }


        #region MESSAGE BUILDERS

        /// <summary>
        /// Build a CONTENTREF Message
        /////From private\server\billing\offering\fd\Contentreferral.cs -> ProcessRequest
        ///CONTENTREF|MachineID|UserID0|UserID1|UserID2|UserID3|TitleID|OfferingID|ReferralNonce|hr
        /// 
        ///Note: The code does not seem to match the above spec. According the code, the messages look like this:
        ///CONTENTREF|MachineID|UserID0|UserID1|UserID2|UserID3|TitleID|OfferingID|hr|ReferralNonce|sginfo.current.nonce
        ///
        /// generated at: server\billing\offering\fd\contentreferral.cs
        /// 
        /// </summary>
        /// <param name="puid"></param>
        /// <returns></returns>
        /// //tested
        private static string BuildContentRefMessage(ulong puid)
        {

            StringBuilder b = new StringBuilder();

            b.Append("CONTENTREF|");
            b.Append("4d53006400000001");
            b.Append("|");
            b.Append(puid.ToString("X")); // PUID 0
            b.Append("|");
            b.Append(0); // PUID 1
            b.Append("|");
            b.Append(0); // PUID 2
            b.Append("|");
            b.Append(0); // PUID 3
            b.Append("|");
            b.Append("53450031"); // Add Title ID
            b.Append("|");
            b.Append("FFFE07D18000000A"); // Add Offer ID
            b.Append("|");
            b.Append("0"); // Hresult
            b.Append("|");
            b.Append("123123"); // Add referralNonce
            b.Append("|");
            b.Append("123123123123123"); // Add Nonce

            return b.ToString();
        }

        /// <summary>
        /// Build an SND message from a prototype found in production logs
        /// </summary>
        /// <param name="puid"></param>
        /// <returns></returns>
        /// //Tested
        private static string BuildSNDMessage(ulong puid)
        {
            StringBuilder b = new StringBuilder();

            // TimeStamp|SND|IP:port|SenderPUID|SenderContext|SenderTitleId|messageFlags|ExpireMin|Details|MessageType|RecipientsList|hr
            b.Append("SND|A14CA34:9EE|");
            b.Append(puid.ToString("X"));
            b.Append("|67300000135|673|80|5|3A|5|9FFFFFFFFFDE0;9FFFFFFFFFDE2|0");

            return b.ToString();
        }


        //Tested
        private static string BuildCreateAccountMsg(ulong puid)
        {
            StringBuilder b = new StringBuilder();

            //TimeStamp|CREATEACCOUNT|UserPUID|hresult|gamertag|email|countryId|postalCode|languageId|machinePUID|titleID|OfferID|Voucher

            b.Append("CREATEACCOUNT|");

            b.Append(puid.ToString("X"));
            b.Append("|0|StfPN93i55au672|xboxstress@winisp.net|103|98014|1|9400000000000|0|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223");


            return b.ToString();
        }

        //Tested
        private static string BuildCreateLiveAccountMsg(ulong puid)
        {
            StringBuilder b = new StringBuilder();

            //CREATELIVEACCOUNT|machinePuid|userPassportPuid|ownerPassportPuid|userPuid|hresult|GamerTag|Email|PostalCode|countryId|languageId|cultureId|titleId|offerId|voucher
            b.Append("CREATELIVEACCOUNT|9400000000000|9000000001A07|9000000001A08|");
            b.Append(puid.ToString("X"));
            b.Append("|0|superawesomegamertag|test@test.com|98014|103|1|5|11111|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223|DEADBEEFFFFA");


            return b.ToString();
        }


        //Tested
        private static string BuildCreateXboxComAccountMsg(ulong puid)
        {
            StringBuilder b = new StringBuilder();

            //CREATEXBOXCOMACCOUNT|userPassportPuid|ownerPassportPuid|machinePuid|userPuid|hresult|gamerTag|Email|PostalCode|countryId|languageId|cultureId
            b.Append("CREATEXBOXCOMACCOUNT|37FFF8154041A|37FFF8154041A|9400000000000|");
            b.Append(puid.ToString("X"));
            b.Append("|0|XEN4uua3ua88a76|test@test.com|98052|103|1|1033");


            return b.ToString();
        }

        //tested
        private static string BuildXeOfferPurchaseMsg(ulong puid)
        {
            StringBuilder b = new StringBuilder();

            //XeOfferPurchase|machinePUID|userPUID|country|lang|tier| offerID|paymentType|priceW|priceF|payInstr|hr|Nonce
            b.Append("XeOfferPurchase|9400000000000|");
            b.Append(puid.ToString("X"));
            b.Append("|103|1|3|FFFE000080000008|1|4|99|123123|0|12123123123");

            return b.ToString();
        }

        //Tested
        private static string BuildXeContentReferralMsg(ulong puid)
        {
            //Timestamp|XeContentReferral|owner_machinePuid|userPuid|MachinePuid|contentId|packageSize|installSize|locations|hresult|Nonce

            StringBuilder b = new StringBuilder();

            b.Append("XeContentReferral|9E8D68D68F420|");
            b.Append(puid.ToString("X"));
            b.Append("|9E8D68D68F422|5345003120050111|12|34|1234|0|123123123");

            return b.ToString();
        }

        //Tested
        private static string BuildTitleStartMsg(ulong puid)
        {

            //TITLESTART|FA0000000083B3C9|4156880B|9000000996317|1001|A876C818|6FF8|48370715        
            StringBuilder b = new StringBuilder();

            b.Append("TITLESTART|FA0000000083B3C9|4156880B|");
            b.Append(puid.ToString("X"));
            b.Append("|1001|A876C818|6FF8|48370715");

            return b.ToString();

        }

        //Tested
        private static string BuildTitleEndMsg(ulong puid)
        {
            //TITLEND|FA00000000970000|FFFE0001|9000000080304|11001|C23EB000|20C|8600074D|240058|5|E
            //TITLEND|FA0000000083B3C9|FFFE07D1|123ABC|1001|A876C818|6FF8|48369DFB|691A|2|0
            StringBuilder b = new StringBuilder();

            b.Append("TITLEND|FA00000000970000|FFFE0001|");
            b.Append(puid.ToString("X"));
            b.Append("|11001|C23EB000|20C|8600074D|240058|5|E");

            return b.ToString();

        }

        //Tested
        private static string BuildSessionStartMsg(ulong puid)
        {

            //SESSTART|FA00000000B28DBF|4D5307E6|900000192DE5B|1003|6D271151270D0180
            StringBuilder b = new StringBuilder();

            b.Append("SESSTART|");
            b.Append(puid.ToString("X"));
            b.Append("|4D5307E6|900000192DE5B|1003|6D271151270D0180");

            return b.ToString();

        }

        //tested
        private static string BuildSessionEndMsg(ulong puid)
        {

            //SESEND|FA000000009BEB79|415607E6|9000001611623|1003|83EABA6CBC4C0181|635D
            StringBuilder b = new StringBuilder();

            b.Append("SESEND|");
            b.Append(puid.ToString("X"));
            b.Append("|415607E6|9000001611623|1003|83EABA6CBC4C0181|635D");

            return b.ToString();

        }

        //tested
        private static string BuildGuestChgMsg(ulong puid)
        {
            //TimeStamp|GUESTCHG|MachinePUID|TitleID|UserPUID|State|OldGuests|NewGuests

            Random rnd = new Random();

            StringBuilder b = new StringBuilder();

            b.Append("GUESTCHG|9F46B46B4A4F1|100E90A|");
            b.Append(puid.ToString("X"));
            b.Append("|123|");
            b.Append(rnd.Next(6));
            b.Append("|");
            b.Append(rnd.Next(6));

            return b.ToString();

        }

        //tested
        private static string BuildMigrateXbox1UserMsg(ulong puid)
        {
            //MIGRATEXBOX1USER|userPassportPuid|userPuid|hr
            /*"MIGRATEXBOX1USER|" +
                    (req == null ? "" : userPassportPuid.ToString("X")) + "|" +
                    (u == null ? "" : u.Puid.ToString("X")) + "|" +
                    (u == null ? "" : u.ParentalControlGroupId.ToString()) + "|" +
                    (u == null ? "" : u.CultureId.ToString()) + "|" +
                    hr.ToString("X");
            */

            StringBuilder b = new StringBuilder();

            b.Append("MIGRATEXBOX1USER|9E8D68D68F420|");
            b.Append(puid.ToString("X"));
            b.Append("|1|101|0");

            return b.ToString();

        }

        //tested
        private static string BuildMigrateXboxComUserMsg(ulong puid)
        {

            //MigrateXboxComUser|67FFE8BCE2815|900000059C02A|0
            StringBuilder b = new StringBuilder();

            b.Append("MigrateXboxComUser|67FFE8BCE2815|");
            b.Append(puid.ToString("X"));
            b.Append("|0");

            return b.ToString();

        }

        //tested
        private static string BuildProvisionServiceMsg(ulong puid)
        {

            //PROVISIONSERVICE|aPuid|userPuid|serviceInstanceId|oldXboxOfferId|oldTierId|newXboxOfferId|newTierId

            StringBuilder b = new StringBuilder();

            b.Append("PROVISIONSERVICE|9000000000409|");
            b.Append(puid.ToString("X"));
            b.Append("|irMAAAAAAAABAAEA|FFFE000080000008|6|FFFE000080000008|6|1");

            return b.ToString();

        }

        //tested
        private static string BuildDeProvisionServiceMsg(ulong puid)
        {


            //DEPROVISIONSERVICE|9000000000A1C|9000000000A1B|tsMCAAAAAAABAAEA|FFFE000080000008|6|FFFE000080000008|6|0

            StringBuilder b = new StringBuilder();

            b.Append("DEPROVISIONSERVICE|9000000000A1C|");
            b.Append(puid.ToString("X"));
            b.Append("|tsMCAAAAAAABAAEA|FFFE000080000008|6|FFFE000080000008|6|0");

            return b.ToString();

        }

        //tested
        private static string BuildLS_BAN_VWMsg(ulong puid)
        {
            RandomEx rnd = new RandomEx();
            UInt64 newInt;
            StringBuilder b = new StringBuilder();

            b.Append("LS-BAN_VW|F213421180449836|");
            b.Append(puid.ToString("X"));
            b.Append("|");

            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);

            b.Append(newInt.ToString("X"));
            b.Append("|0");

            return b.ToString();

        }

        //Tested
        private static string BuildLSA_BAN_VWMsg(ulong puid)
        {

            return "LSA-BAN_VW|537422EA0EC69934|2";

        }

        //tested
        private static string BuildLS_BAN_CLMsg(ulong puid)
        {
            return "LS-BAN_CL|537422EA0EC69934|" + puid.ToString("X") + "|2|1";
        }

        //tested
        private static string BuildLSA_BAN_CLMsg(ulong puid)
        {

            return "LSA-BAN_CL|537422EA0EC69934|2";
        }


        //tested
        private static string BuildLS_MP_PMsg(ulong puid)
        {
            //Banner purchase message

            RandomEx rnd = new RandomEx();
            UInt64 newInt;
            StringBuilder b = new StringBuilder();

            b.Append("LS-MP_P|001B921B594DF660|FFFE07D18000001B|");
            b.Append(puid.ToString("X"));
            b.Append("|");

            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);

            b.Append(newInt.ToString("X"));

            return b.ToString();
        }


        //tested
        private static string BuildLSA_MP_PMsg(ulong puid)
        {
            //LSA-MP_P|bannerID|offerID|count
            return "LSA-MP_P|537422EA0EC69934|10|2";
        }



        //tested
        private static string BuildLS_FUMsg(ulong puid)
        {
            //fusion message - Test code taken from stringsvr logtarget test (ReportingTargetTestBVT.cs)
            //FU|TITLEID|ERRORCODE~PUID|TIMESTAMP
            
            StringBuilder b = new StringBuilder();

            //Example - LS-FU|100|0|9000000000A1B|2

            b.Append("LS-FU|100|0");

            b.Append(puid.ToString("X"));
            b.Append("|2");

            return b.ToString();
        }

        //tested
        private static string BuildLSA_FUMsg(ulong puid)
        {
            //LSA-FU|TitleID|hr|count 
            return "LSA-FU|FFFF0004|0|42";

        }

        /// <summary>
        /// Builds an ARGOLICENSE MESSAGE
        /// Results in a call to p_add_video_license on FilterDB that inserts into t_video_license_fact
        /// </summary>
        /// <param name="puid"></param>
        /// <returns></returns>
        /// //Tested
        private static string BuildArgoLicenseMsg(ulong puid)
        {
            //ARGOLICENSE|clientTimestamp|wmid|ownerMachinePUID|currentMachinePUID|userPUID

            RandomEx rnd = new RandomEx();

            StringBuilder b = new StringBuilder();

            UInt64 newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);

            b.Append("ARGOLICENSE|0|6286EA85-62E9-48D7-963B-F7BEAE00846E|");
            b.Append(newInt.ToString("X"));
            b.Append("|");
            b.Append(newInt.ToString("X"));
            b.Append("|");
            b.Append(puid.ToString("X"));
            b.Append("|1");

            return b.ToString();
        }



        /// <summary>
        /// Builds an SGADDM Message
        /// </summary>
        /// <param name="puid"></param>
        /// <returns></returns>
        private static string BuildSGADDMMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);
            
            //SGADDM|XB2|<Machine PUID>|ADDM|<Title ID>|<Title Version>|<Title Region>|<IP Address>|<IP Port>|<OS Major>|<OS Minor>|<OS Build>|<OS Qfe>
            sb.Append("SGADDM");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid.ToString("X"));
                    sb.Append("|");
                    sb.Append("ADDM"); // 
                    sb.Append("|");
                    sb.Append("12345"); // Title ID
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); // 
                    sb.Append("|");
                    sb.Append("125.124.123.121"); //
                    sb.Append("|");
                    sb.Append("334"); // 
                    sb.Append("|");
                    sb.Append("12"); // 
                    sb.Append("|");
                    sb.Append("20"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("2"); 

            return sb.ToString();

        }

        private static string BuildSGAUTHMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGAUTH|XB2|<Machine PUID>|AUTH|<Title ID>|<Title Version>|<Title Region>|<Auth Speed>
            sb.Append("SGAUTH");
            sb.Append("|");
            sb.Append("XB2"); //
            sb.Append("|");
            sb.Append(machid.ToString("X"));
            sb.Append("|");
            sb.Append("AUTH"); // 
            sb.Append("|");
            sb.Append("12345"); //
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("4"); // 
            sb.Append("|");
            sb.Append("1200"); // 

            return sb.ToString();

        }

        private static string BuildSGDELMMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGDELM|XB2|<Machine PUID>|DELM|<Reason>|<Challenge ID>|<Challenge Hash>
            sb.Append("SGDELM");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); //
            sb.Append("|");
            sb.Append("DELM"); // 
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("4"); // 
            sb.Append("|");
            sb.Append("1234"); //

            return sb.ToString();

        }


        private static string BuildSGDISKMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGDISK|XB2|<Machine PUID>|DISK|<Title ID>|<Title Version>|<Title Region>|<DVD Size>|<Game Size>|<Flags>
            sb.Append("SGDISK");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); // 
            sb.Append("|");
            sb.Append("DISK"); // 
            sb.Append("|");
            sb.Append("12345"); // 
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("4"); // 
            sb.Append("|");
            sb.Append("4096"); // 
            sb.Append("|");
            sb.Append("1024"); // 
            sb.Append("|");
            sb.Append("1101"); // 

            return sb.ToString();
        }


        private static string BuildSGDMIMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGDMI|XB2|<Machine PUID>|DMI|<Title ID>|<Title Version>|<Title Region>|<Disk DMI>|<Game DMI>|<Disk Num>|<Disk Timestamp>|<XMID>|<Flags>
            sb.Append("SGDMI");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); //
            sb.Append("|");
            sb.Append("DMI"); // 
            sb.Append("|");
            sb.Append("12345"); // 
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("4"); //
            sb.Append("|");
            sb.Append("123123"); // 
            sb.Append("|");
            sb.Append("123123"); //
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("12345"); // 
            sb.Append("|");
            sb.Append("12345"); // 
            sb.Append("|");
            sb.Append("1101"); // 

            return sb.ToString();
        }

        private static string BuildSGFAILMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGFAIL|XB2|<Machine PUID>|FAIL|<Chal Id>|<Hash Id>|<Result>
            sb.Append("SGFAIL");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); //
            sb.Append("|");
            sb.Append("FAIL"); // 
            sb.Append("|");
            sb.Append("1"); // 
            sb.Append("|");
            sb.Append("1"); //
            sb.Append("|");
            sb.Append("0"); //

            return sb.ToString();
        }


        private static string BuildSGGPR2Msg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGGPR2|XB2|<Machine PUID>|GPR2|<GPR2 Value>
            sb.Append("SGGPR2");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); // 
            sb.Append("|");
            sb.Append("GPR2"); // 
            sb.Append("|");
            sb.Append("12345"); // 

            return sb.ToString();
        }

        private static string BuildSGHASHMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGHASH|XB2|<Machine PUID>|HASH|<Kernel Type>|<Hash Type>|<Hash Id>|<OS Major>|<OS Minor>|<OS Build>|<OS Qfe>|<Hash>
            sb.Append("SGHASH");
            sb.Append("|");
            sb.Append("XB2"); //
            sb.Append("|");
            sb.Append(machid.ToString("X")); //
            sb.Append("|");
            sb.Append("HASH"); //
            sb.Append("|");
            sb.Append("1"); //
            sb.Append("|");
            sb.Append("1"); //
            sb.Append("|");
            sb.Append("1234"); //
            sb.Append("|");
            sb.Append("1234"); // 
            sb.Append("|");
            sb.Append("3"); // 
            sb.Append("|");
            sb.Append("333"); //
            sb.Append("|");
            sb.Append("2"); // 
            sb.Append("|");
            sb.Append("1234"); //  

            return sb.ToString();
        }


        private static string BuildSGHRMORMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGHRMOR|XB2|<Machine PUID>|HRMOR|<HRMOR Value>
            sb.Append("SGHRMOR");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); //
            sb.Append("|");
            sb.Append("HRMOR"); //
            sb.Append("|");
            sb.Append("1101"); // 

            return sb.ToString();
        }

        private static string BuildSGTCHGMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGTCHG|XB2|<Machine PUID>|TCHG|<Title Id>|<Title Version>|<Title Region>
            sb.Append("SGTCHG");
            sb.Append("|");
            sb.Append("XB2"); // 
            sb.Append("|");
            sb.Append(machid.ToString("X")); // 
            sb.Append("|");
            sb.Append("TCHG"); // 
            sb.Append("|");
            sb.Append("4444"); // 
            sb.Append("|");
            sb.Append("2"); // 
            sb.Append("|");
            sb.Append("2"); // 

            return sb.ToString();
        }

        private static string BuildSGUCHGMsg(ulong puid)
        {
            StringBuilder sb = new StringBuilder();
            RandomEx rnd = new RandomEx();
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.XenonBackCompat);

            //SGUCHG|XB2|<Machine PUID>|UCHG|<User #1 PUID>|<User #2 PUID>|<User #3 PUID>|<User #4 PUID> 
            sb.Append("SGUCHG");
            sb.Append("|");
            sb.Append("XB2"); //
            sb.Append("|");
            sb.Append(machid.ToString("X")); // 
            sb.Append("|");
            sb.Append("UCHG"); // 
            sb.Append("|");
            sb.Append(puid.ToString("X")); // 
            sb.Append("|");
            sb.Append(puid.ToString("X")); // 
            sb.Append("|");
            sb.Append(puid.ToString("X")); // 
            sb.Append("|");
            sb.Append(puid.ToString("X")); // 

            return sb.ToString();
        }

#region deprecated
        /*
        //deprecated function
        /// <summary>
        /// Taken from the old stress code to handle SG related messages. 
        /// </summary>
        /// <returns></returns>
        private static string BuildSecurityMsg(ulong puid)
        {
            RandomEx rnd = new RandomEx();
            const int NumSecurityLoglines = 11;

            StringBuilder sb = new StringBuilder();

            int rndInt = rnd.Next(Int32.MaxValue);
            UInt64 machid = rnd.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xbox);

            // Grab Randome ex and switch
            // 

            int msg = rndInt % NumSecurityLoglines;

            switch (msg)
            {
                
                case 0:
                    // GOOD
                    //SGADDM|XB2|<Machine PUID>|ADDM|<Title ID>|<Title Version>|<Title Region>|<IP Address>|<IP Port>|<OS Major>|<OS Minor>|<OS Build>|<OS Qfe>
                    sb.Append("SGADDM");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid);
                    sb.Append("|");
                    sb.Append("ADDM"); // 
                    sb.Append("|");
                    sb.Append("12345"); // Title ID
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); // 
                    sb.Append("|");
                    sb.Append("125.124.123.121"); //
                    sb.Append("|");
                    sb.Append("334"); // 
                    sb.Append("|");
                    sb.Append("12"); // 
                    sb.Append("|");
                    sb.Append("20"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("2"); // 
                    break;
                case 1:
                    // GOOD
                    //SGAUTH|XB2|<Machine PUID>|AUTH|<Title ID>|<Title Version>|<Title Region>|<Auth Speed>
                    sb.Append("SGAUTH");
                    sb.Append("|");
                    sb.Append("XB2"); //
                    sb.Append("|");
                    sb.Append(machid);
                    sb.Append("|");
                    sb.Append("AUTH"); // 
                    sb.Append("|");
                    sb.Append("12345"); //
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); // 
                    sb.Append("|");
                    sb.Append("1200"); // 
                    break;
                case 2:
                    // GOOD
                    //SGDELM|XB2|<Machine PUID>|DELM|<Reason>|<Challenge ID>|<Challenge Hash>
                    sb.Append("SGDELM");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); //
                    sb.Append("|");
                    sb.Append("DELM"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); // 
                    sb.Append("|");
                    sb.Append("1234"); //
                    break;
                case 3:
                    // GOOD
                    //SGDISK|XB2|<Machine PUID>|DISK|<Title ID>|<Title Version>|<Title Region>|<DVD Size>|<Game Size>|<Flags>
                    sb.Append("SGDISK");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); // 
                    sb.Append("|");
                    sb.Append("DISK"); // 
                    sb.Append("|");
                    sb.Append("12345"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); // 
                    sb.Append("|");
                    sb.Append("4096"); // 
                    sb.Append("|");
                    sb.Append("1024"); // 
                    sb.Append("|");
                    sb.Append("1101"); // 
                    break;
                case 4:
                    // GOOD
                    //SGDMI|XB2|<Machine PUID>|DMI|<Title ID>|<Title Version>|<Title Region>|<Disk DMI>|<Game DMI>|<Disk Num>|<Disk Timestamp>|<XMID>|<Flags>
                    sb.Append("SGDMI");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); //
                    sb.Append("|");
                    sb.Append("DMI"); // 
                    sb.Append("|");
                    sb.Append("12345"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("4"); //
                    sb.Append("|");
                    sb.Append("123123"); // 
                    sb.Append("|");
                    sb.Append("123123"); //
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("12345"); // 
                    sb.Append("|");
                    sb.Append("12345"); // 
                    sb.Append("|");
                    sb.Append("1101"); // 
                    break;
                case 5:
                    // GOOD
                    //SGFAIL|XB2|<Machine PUID>|FAIL|<Chal Id>|<Hash Id>|<Result>
                    sb.Append("SGFAIL");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); //
                    sb.Append("|");
                    sb.Append("FAIL"); // 
                    sb.Append("|");
                    sb.Append("1"); // 
                    sb.Append("|");
                    sb.Append("1"); //
                    sb.Append("|");
                    sb.Append("0"); //
                    break;
                case 6:
                    // GOOD
                    //SGGPR2|XB2|<Machine PUID>|GPR2|<GPR2 Value>
                    sb.Append("SGGPR2");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); // 
                    sb.Append("|");
                    sb.Append("GPR2"); // 
                    sb.Append("|");
                    sb.Append("12345"); // 
                    break;
                case 7: // BROKEN
                    //SGHASH|XB2|<Machine PUID>|HASH|<Kernel Type>|<Hash Type>|<Hash Id>|<OS Major>|<OS Minor>|<OS Build>|<OS Qfe>|<Hash>
                    sb.Append("SGHASH");
                    sb.Append("|");
                    sb.Append("XB2"); //
                    sb.Append("|");
                    sb.Append(machid); //
                    sb.Append("|");
                    sb.Append("HASH"); //
                    sb.Append("|");
                    sb.Append("1"); //
                    sb.Append("|");
                    sb.Append("1"); //
                    sb.Append("|");
                    sb.Append("1234"); //
                    sb.Append("|");
                    sb.Append("1234"); // 
                    sb.Append("|");
                    sb.Append("3"); // 
                    sb.Append("|");
                    sb.Append("333"); //
                    sb.Append("|");
                    sb.Append("2"); // 
                    sb.Append("|");
                    sb.Append("1234"); // 
                    break;
                case 8:
                    // GOOD
                    //SGHRMOR|XB2|<Machine PUID>|HRMOR|<HRMOR Value>
                    sb.Append("SGHRMOR");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); //
                    sb.Append("|");
                    sb.Append("HRMOR"); //
                    sb.Append("|");
                    sb.Append("1101"); // 
                    break;
                case 9:
                    // GOOD
                    //SGTCHG|XB2|<Machine PUID>|TCHG|<Title Id>|<Title Version>|<Title Region>
                    sb.Append("SGTCHG");
                    sb.Append("|");
                    sb.Append("XB2"); // 
                    sb.Append("|");
                    sb.Append(machid); // 
                    sb.Append("|");
                    sb.Append("TCHG"); // 
                    sb.Append("|");
                    sb.Append("4444"); // 
                    sb.Append("|");
                    sb.Append("2"); // 
                    sb.Append("|");
                    sb.Append("2"); // 
                    break;
                case 10:
                default:
                    // GOOD
                    //SGUCHG|XB2|<Machine PUID>|UCHG|<User #1 PUID>|<User #2 PUID>|<User #3 PUID>|<User #4 PUID> 
                    sb.Append("SGUCHG");
                    sb.Append("|");
                    sb.Append("XB2"); //
                    sb.Append("|");
                    sb.Append(machid); // 
                    sb.Append("|");
                    sb.Append("UCHG"); // 
                    sb.Append("|");
                    sb.Append(puid.ToString("X")); // 
                    sb.Append("|");
                    sb.Append(puid.ToString("X")); // 
                    sb.Append("|");
                    sb.Append(puid.ToString("X")); // 
                    sb.Append("|");
                    sb.Append(puid.ToString("X")); // 
                    break;
            }

            return sb.ToString();
        }
*/
#endregion

        //Tested
        private static string BuildGeoFenceOfferPurchaseMsg(ulong puid)
        {
            return string.Format("GeoFenceOfferPurchase|Filter|{0}|9E8D68D68F420|127.0.0.1|USA|12341234", puid.ToString("X"));
        }

        //Tested
        private static string BuildGeoFenceContentReferralMsg(ulong puid)
        {
            return string.Format("GeoFenceContentReferral|Filter|{0}|9F46B46B4A4A4|127.0.0.2|CAN|12341235", puid.ToString("X"));
        }

        //Tested
        private static string BuildGeoFenceVideoPurchaseMsg(ulong puid)
        {
            return string.Format("GeoFenceVideoPurchase|Filter|{0}|9F46B46B4A4A3|127.0.0.4|USA|1286EA85-62E9-48D7-963B-F7BEAE00846C|1", puid.ToString("X"));
        }

        //Tested
        private static string BuildGeoFenceVideoAcquireURLMsg(ulong puid)
        {
            return string.Format("GeoFenceVideoAcquireURL|Filter|{0}|9F46B46B4A4A6|127.0.0.5|CAN|1286EA85-62E9-48D7-963B-F7BEAE00846D|2", puid.ToString("X"));
        }

        //Tested
        private static string BuildGeoFenceVideoAcquireLicenseMsg(ulong puid)
        {
            return string.Format("GeoFenceVideoAcquireLicense|Filter|{0}|9F46B46B4A4A5|127.0.0.6|CAN|1286EA85-62E9-48D7-963B-F7BEAE00846E|3", puid.ToString("X"));
        }


        //Tested
        private static string BuildLS_DHWMsg(ulong puid)
        {

            //though the argon_fact table is supposed to want a machine puid, we will use the puid generated as a 
            //fake to satisfy the referential integrity constraints on the fact table in filterDB

            //also, for stress, we are sending the max data - 250 chars
            //LS-DHW|<machine_puid>|<MSGDATA_ASCIITEXT>
            return string.Format("LS-DHW|{0}|AAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEE", puid.ToString("X"));

        }


        //Tesed
        private static string BuildLicenseTransferMsg(ulong puid)
        {
            //LICTRANSFER|SGNonce|UserPUID|OldMachineID|NewMachineID|UserLicenses|MachineLicenses|hr
            return string.Format("LICTRANSFER|111168D68F420|{0}|9E8D68D68F433|9E8D68D68F444|1|2|BAADBEEF", puid.ToString("X"));
        }


        //Tested
        private static string BuildGenericMsg(ulong unused)
        {
            RandomEx rnd = new RandomEx();

            int iNumColumn = rnd.Next(Int32.MaxValue) % 20;

            if (iNumColumn == 0)
            {
                iNumColumn = 1; //at least one column of data
            }

            int iNumChar;
            string sz250 = "0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij0123456789abcdefghij";

            //  Random
            string logLine = string.Format("GenericHeader");
            for (int ii = 0; ii < iNumColumn; ii++)
            {
                iNumChar = rnd.Next(Int32.MaxValue) % 25;
                logLine += string.Format("|{0}", sz250.Substring(0, iNumChar));
            }

            return logLine;
        }


        //Tested
        private static string BuildPurchaseOffersReportingMsg(ulong puid)
        {

            //PurchaseOffersReporting|USERPUID|MACHINEPUID|IP|PAYMENTTYPE|OFFERINSTANCEID|MEDIATYPEID|RETAILPRICEPOINTS|RETAILPRICE|RETAILCURRENCY|WHOLESALEPRICE|WHOLESALECURRENCY|PROMOTIONID|PRINCINGRULEID|STOREID
            return string.Format("PurchaseOffersReporting|{0}|211168D68F422|127.0.0.1|1|1286EA85-62E9-48D7-963B-F7BEAE00846C|1|2|3.14|USD|10.20|ESD|1286EA85-62E9-48D7-963B-F7BEAE00846D|1|1", puid.ToString("X"));

        }

        //tested
        private static string BuildUseageStoreLicenseMsg(ulong puid)
        {
            //There are 3 cases here. ad percentage viewed, ad supported, and non ad supported. Pick a random case here
            //with the percentage viewed, data is only inserted if the data is within the last week too. This is not a functional test
            //but we do want to simlate all types of inserts, so we will generate 1 of the 3 valid cases each pass

            RandomEx rnd = new RandomEx();

            int k = rnd.Next(3);

            string logLine = null;

            switch (k)
            {
                case 0:
                    {
                        //Tested
                        //percentage viewed
                        //the A(10) means ad percentage viewed. Also, we have to use the current date so that the data will not be discarded
                        logLine = string.Format("USAGE_STORE|{0}|01234567-0123-0123-0123-0123456789ab|01234567-0123-0123-0123-0123456789aC|1|A|5|{1}", puid.ToString("X"), DateTime.Now.AddDays(-1.0).ToString());
                        break;
                    }
                case 1:
                    {
                        //Tested
                        //ad supported
                        //note: The 9 in this logline indicates ad supported video
                        logLine = string.Format("USAGE_STORE|{0}|01234567-0123-0123-0123-0123456789ab|01234567-0123-0123-0123-0123456789aC|1|9|5|6/20/2007 2:10:08 PM", puid.ToString("X"));
                        break;
                    }
                case 2:
                    {
                        //Tested
                        //non ad supported
                        logLine = string.Format("USAGE_STORE|{0}|01234567-0123-0123-0123-0123456789ab|||1|5|6/20/2007 2:10:08 PM|1", puid.ToString("X"));
                        break;
                    }
                default:
                    {
                        Debug.Assert(false, "Invalid case found in BuildUseageStoreLicenseMsg");
                        throw new ApplicationException("Invalid case in useagestore message generation");

                    }

            }

            return logLine;
        }

        //Tested
        private static string BuildLicenseRequestMsg(ulong puid)
        {
            //example of FD log. Code from server\signature\fd\LicenseImpl.cs
            return string.Format("LICENSE_REQUEST|8000009a-f02d-4dfc-82a7-fb446d09da05|64e98845-44e8-4b5c-8276-2875cfd00009|fa00000000000b27|fa0000000000ab27|{0}|0|1|2000097|B3Ft9f6+0000hSdvi8ReVQ==|", puid.ToString("X"));
        }
        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingReferenceObjectContainer.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace ServerTestFramework.STFLive.Reporting
{
    public abstract class ReportingReferenceObjectContainer
    {


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingReferenceObjectFactory.cs ===
using System;

namespace ServerTestFramework.STFLive.Reporting
{
    public enum ReportingEventType
    {
        PresenceTitleStart,
        PresenceTitleEnd,
        PresenceSessionStart,
        PresenceSessionEnd,
        PresenceGuestChange,
        XboxContentReferral,
        Xbox360ContentReferral
     
    }

    public enum ReportingDataType
    {
        OlapReportData,
        OlapGenericData,
        RealtimeDBStressData
    }

    public class ReportingReferenceObjectFactory
    {
        private ReportingReferenceObjectFactory()
        {

        }

        private static ReportingReferenceObjectFactory m_Instance = null;

        public static ReportingReferenceObjectFactory Instance
        {
            get
            {
                if (m_Instance == null)
                    m_Instance = new ReportingReferenceObjectFactory();
                return m_Instance;
            }
        }

        public ReportingReferenceObject CreateRefObject(ReportingEventType eventType)
        {
            return null;
        }

        // Create a Data Reference Object
        public ReportingReferenceObject CreateDataObject(ReportingDataType dataType)
        {
            ReportingReferenceObject tempObj = null;
            // Identify data object and throw an exception if not found
            switch (dataType)
            {
                case ReportingDataType.OlapReportData:  // Data objects for olap reports
                    tempObj = new OlapReportData();
                    break;
                case ReportingDataType.OlapGenericData: // Generic object for Olap queries
                    tempObj = new OlapGenericData();
                    break;
                default:
                    throw new Exception("Reference Object Factory: Invalid DataObject type");
            }
            return tempObj;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingJobFactory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

namespace ServerTestFramework.STFLive.Reporting
{
    public enum ReportingJobType
    {
        ReportingDB_GameUsageDaily,
        ReportingDB_ArgoUsageDaily,
        ReportingDB_PurgeFact,
        SSIS_Secondary,
        SSIS_Daily,
        FilterDB_Purge,
        OlapDB_SSASAchievementsDaily,
        OlapDB_SSASGameUsageDaily,
        OlapDB_SSASCruxUsageDaily,
        OlapDB_SSASCDBCruxUsageDaily,
        OlapDB_SSASVideoCubeDaily,
        OlapCubeGeneration,
        ReportingDB_DropArchivedFact,
        WMIS_Download,
        SSIS_Realtime,
        SSIS_Purchase,
        SSIS_Music,
        SSIS_Video,
        SSIS_Accounts,
        SSIS_Offers,
        ReportArchiveDB_TransferFactData,
        ReportArchiveDB_UpdateFilegroups,
        RealtimeDB_RealtimeProcessing,
        RealtimeDB_PurgeFact,
        SCGImportFeed_SSIS,
        SCGExport_SSIS,
        CIQ_Datafeed,
        SSIS_CdbVideoProcessing


        //TODO: Add more job types
    }

    /// <summary>
    /// Placeholder class, you cast from this class to your expected job parameters.
    /// </summary>
    public abstract class ReportingJobParameters
    {
        protected bool m_UseDefaultJob = true;  // True to run the default job from SQL Server Agent
        public virtual bool UseDefaultJob
        {
            get { return m_UseDefaultJob; }
            set { m_UseDefaultJob = value; }
        }   

        // Base function to compare if parameters are equal
        public virtual bool Equals(ReportingJobParameters param)
        {
            if (param.GetType() == this.GetType())
            {
                return true;
            }
            return false;
        }
    }

    public class ReportingJobFactory
    {
        /// <summary>
        /// Create a singleton class
        /// </summary>
        private static ReportingJobFactory m_Instance = null;

        /// <summary>
        /// Contains all reporting jobs in this test run
        /// </summary>
        private List<ReportingJob> m_ReportingJobs;


        /// <summary>
        /// Constructor
        /// The class is a singleton because it serves as a central datastore for all jobs in a test run
        /// </summary>
        private ReportingJobFactory()
        {
            
        }

        /// <summary>
        /// Returns the singleton for this class
        /// </summary>
        public static ReportingJobFactory Instance
        {
            get
            {
                if (m_Instance == null)
                {
                    m_Instance = new ReportingJobFactory();
                }
                return m_Instance;
            }
        }

        /// <summary>
        /// Clears the current singleton        
        /// </summary>
        public static void ClearInstance()
        {
            m_Instance = null;
            m_Instance = new ReportingJobFactory();
        }


        /// <summary>
        /// Factory method
        /// </summary>
        /// <param name="reportingJobType"></param>
        /// <param name="reportingJobParams"></param>
        /// <returns></returns>
        public ReportingJob CreateReportingJob(ReportingJobType reportingJobType, ReportingJobParameters reportingJobParams)
        {
            ReportingJob retVal = null;
            lock (m_Instance)   // Restrict access to Job Factory instance
            {
                if (m_ReportingJobs == null)
                {
                    // Initialize list if needed
                    m_ReportingJobs = new List<ReportingJob>();
                }

                switch (reportingJobType)
                {
                    case ReportingJobType.ReportingDB_GameUsageDaily:       // Game Usage Daily Processing
                        retVal = new DailyProcessing_GameUsage(reportingJobParams);
                        break;

                    case ReportingJobType.ReportingDB_ArgoUsageDaily:       // Crux Daily Processing
                        retVal = new DailyProcessing_Crux(reportingJobParams);
                        break;

                    case ReportingJobType.OlapDB_SSASAchievementsDaily:     // DAILY OLAP ACHIEVEMENTS CUBE PROCESSING            
                        retVal = new DailySSAS_AchievementsProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.OlapDB_SSASGameUsageDaily:        // DAILY OLAP GAMEUSAGE CUBE PROCESSING
                        retVal = new DailySSAS_GameUsageProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.OlapDB_SSASCDBCruxUsageDaily:        // DAILY OLAP CDB CRUX USAGE CUBE PROCESSING
                        retVal = new DailySSAS_CDBCruxUsageProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.OlapDB_SSASCruxUsageDaily:        // DAILY OLAP CRUXUSAGE CUBE PROCESSING
                        retVal = new DailySSAS_CruxUsageProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.OlapDB_SSASVideoCubeDaily:        // DAILY OLAP VIDEO CUBE USAGE CUBE PROCESSING
                        retVal = new DailySSAS_VideoCubeProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.ReportingDB_PurgeFact:            // Purge ReportingDB Fact tables
                        retVal = new ReportingDB_PurgeFactTables(reportingJobParams);
                        break;

                    case ReportingJobType.ReportingDB_DropArchivedFact:     // Drop ReportingDB Archived tables
                        retVal = new ReportingDB_DropArchivedFacts(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Secondary:                   // Secondary UODB SSIS 
                        retVal = new UODB_Secondary_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Daily:                       // Daily UODB SSIS
                        retVal = new UODB_Primary_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.FilterDB_Purge:                   // Purge FilterDB Tables
                        retVal = new FilterDB_PurgeFactTables(reportingJobParams);
                        break;

                    case ReportingJobType.WMIS_Download:                    // WMIS Download job
                        retVal = new WMIS_Download(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Realtime:                    // Realtime UODB SSIS
                        retVal = new UODB_Realtime_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Purchase:                       // Purchase UODB SSIS
                        retVal = new UODB_Purchase_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Music:                       // Music UODB SSIS
                        retVal = new UODB_Music_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Video:                       // Video UODB SSIS
                        retVal = new UODB_Video_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Accounts:                     // UODB Accounts SSIS
                        retVal = new UODB_Accounts_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.SSIS_Offers:                       // UODB Offers SSIS
                        retVal = new UODB_Offers_SSIS(reportingJobParams);
                        break;

                    case ReportingJobType.ReportArchiveDB_TransferFactData: // ArchiveDB Transfer Fact Data
                        retVal = new ReportArchiveDB_TransferFactData(reportingJobParams);
                        break;

                    case ReportingJobType.ReportArchiveDB_UpdateFilegroups: // ArchiveDB Update Filegroups
                        retVal = new ReportArchiveDB_UpdateFilegroups(reportingJobParams);
                        break;

                    case ReportingJobType.RealtimeDB_PurgeFact:             // ReportRealtimeDB - Purge Fact Tables
                        retVal = new RealtimeDB_PurgeFactTables(reportingJobParams);
                        break;

                    case ReportingJobType.RealtimeDB_RealtimeProcessing:    // ReportRealtimeDB - Realtime Processing
                        retVal = new RealtimeDB_RealtimeProcessing(reportingJobParams);
                        break;

                    case ReportingJobType.OlapCubeGeneration:               // Olap cubes Partitions creation tool job
                        retVal = new OlapCubeGeneration(reportingJobParams);
                        break;

                    case ReportingJobType.CIQ_Datafeed:                     // CIQ Job
                        retVal = new CIQDatafeed(reportingJobParams);
                        break;

                    case ReportingJobType.SCGImportFeed_SSIS:               // SCG Import job into SSISDB
                        retVal = new SCGImportFeed_SSIS(reportingJobParams);
                        break;
                    
                    case ReportingJobType.SCGExport_SSIS:                   // ReportingDB SCG Data Export SSIS Job
                        retVal = new SCGExport_SSIS(reportingJobParams);
                        break;
                    case  ReportingJobType.SSIS_CdbVideoProcessing:
                        retVal = new CdbVideoProcessing_SSIS(reportingJobParams); // SSIS Cdb_VideoProcessing job
                        break;

                    default:
                        throw new Exception("Reporting job type not supported");
                }// switch
                m_ReportingJobs.Add(retVal);
            }
            return retVal;
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingSQLQueryBuilder.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace ServerTestFramework.STFLive.Reporting
{

    /// <summary>
    /// Type of query to do against a particular table
    /// </summary>
    public enum ReportingQueryType
    {
        Strict, // All known values passed in will be verified
        Loose,  // Only values marked with attribute [LooseQuery] will be processed
        Individual // Only the first value in the list will be verified
    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class ReportingPair
    {
        // TODO: Column Name/Value pair
    }

    /// <summary>
    /// Runs a query against a Reporting server
    /// 
    /// First deconstructs the query, running a count query first
    /// </summary>
    public class ReportingSQLQueryRunner
    {
        // Functions
        /// <summary>
        /// Order expected (count query then select query
        /// </summary>
        /// <param name="queries">Queries to run against the server</param>
        /// <param name="ReportingServer">Server to hit</param>
        /// <param name="ReportingDB">Database to hit</param>
        /// <param name="count"></param>
        /// <param name="Results">Results and counts from queries</param>
        /// <returns>If there were any errors</returns>
        public static bool RunQuery(List<string> queries, string ReportingServer, string ReportingDB, out int count, out ArrayList Results) // First should query count and should only return results if under a certain amount
        {
            count = 0;
            Results = null;
            //TODO: Open a connection
            foreach (string s in queries)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(s);
                // TODO: Make sure the query is not a count query to begin with
                sb.Replace("select ", "select count ");
                //TODO: Run String builder query
                //      If too many results are returned
                //         continue; // Don't run the query
            }
            return false;
        }

        public static ArrayList RunDebugQuerySet()
        {
            // TODO: Run strict queries, then loose queries, then individual queries, compile resutls, and spit back an arraylist of strings
            return null;
        }

    }

    /// <summary>
    /// Contains helpful utility functions for building SQL queries
    /// </summary>
    public class ReportingSQLQueryBuilder
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="ReportingTableType"></param>
        /// <param name="KnownValues"></param>
        /// <param name="TypeOfQuery"></param>
        /// <returns></returns>
        public static string BuildQuery(Type ReportingTableType, Queue<ReportingPair> KnownValues, ReportingQueryType TypeOfQuery)
        {
            //TODO: Walk through table type looking for table types
            //      Parse items
            //      "select * from " + table + " where "
            //      if individual
            //           Grab first known value
            //            + column name + " = " + Known Value
            //      if loose
            //         foreach (LooseItem in Parsed Items)
            //             if (LooseItem exists in known values)
            //                + column name + " = " + Known Value + " and "
            //         remove last " and "
            //      if strict
            //         foreach (Item in Parsed Items)
            //             if (Item exists in known values)
            //                + column name + " = " + Known Value + " and "
            return "";
        }

        public static string QueryIndividualValue(Type reportingTable, ReportingPair KnownValue)
        {
            // Call build query with correct parameters
            return "";
        }
        // TODO: Add more helpful functions

    }

    // TODO: Add OLAP Query builder
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Data\OlapDailyProcessingData.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using ServerTestFramework.STFLive.Reporting.Tables;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// GameUsageFactData
    /// </summary>
    public class OlapDailyProcessingData : ReportingData
    {
        public static Report Log = new Report("OlapDailyProcessingData");

        protected ReportingDatabase _source;
        protected ReportingDataType _objectType;
        protected InternalDataType _dataType;

        /// <summary>
        /// Constructor
        /// </summary>
        public OlapDailyProcessingData()
        {
            _objectType = ReportingDataType.OlapReportData;
        }
        
        /// <summary>
        /// Data source: UODB, SSIS, ReportingDB, etc
        /// </summary>
        public override ReportingDatabase Source
        {
            get { return _source; }
            set { _source = value; }
        }

        /// <summary>
        ///  Get ReportingData object type
        /// </summary>
        public override ReportingDataType ObjectType
        {
            get { return _objectType; }
        }

        /// <summary>
        /// Get internal data type (Queries, Raw, Counts)
        /// </summary>
        public override InternalDataType DataType
        {
            get { return _dataType; }
            set { _dataType = value; }
        }
    }
    
    /// <summary>
    /// GameUsageFactData
    /// </summary>
    public class OlapDailyProcessingBVTData : OlapDailyProcessingData
    {
        public bool PopulateSingleFactTablesForOneday(ReportingDB rdb, int iDate, int iTime)
        {
            bool bReturn = true;
            Source = rdb;

            Log.Info("PopulateSingleFactTablesForOneday started.");
        
            //
            // Populate Data - user/title/offer
            //

            //
            T_titles t_titles = new T_titles();
            int iTitleId_xbox1, iTitleId_xbox360;

            iTitleId_xbox1 = t_titles.AddOneRow(rdb.Connection, 0);
            iTitleId_xbox360 = t_titles.AddOneRow(rdb.Connection, 2);

            //
            T_offers t_offers = new T_offers();
            long biOfferId1 = t_offers.AddOneRow(rdb.Connection, 0); //Xbox1 Offer
            long biOfferId2 = t_offers.AddOneRow(rdb.Connection, 2); //Xbox360 Offer

            //
            T_title_offers t_title_offers = new T_title_offers();
            try{
                t_title_offers.AddOneRow(rdb.Connection, iTitleId_xbox1, biOfferId1);
                t_title_offers.AddOneRow(rdb.Connection, iTitleId_xbox360, biOfferId2);
            }
            catch(Exception e){
                Log.Warn("t_title_offers: "+e.Message);
                bReturn = false;
            }


            T_content_package t_content_package =  new T_content_package();
            try{
                t_content_package.AddOneRow(rdb.Connection, biOfferId2);
            }
            catch(Exception e){
                Log.Warn("t_content_package: "+e.Message);
                bReturn = false;
            }

            //
            T_users t_users1 = new T_users();
            T_users t_users2 = new T_users();
            long biUserPuid1 = t_users1.AddOneRow(rdb.Connection);   //Xbox1 User
            long biUserPuid2 = t_users2.AddOneRow(rdb.Connection);   //Xbox360 User
            
            //
            T_base_offers t_base_offers = new T_base_offers();
            long biBaseOfferId1 = t_base_offers.AddOneRow(rdb.Connection);
            long biBaseOfferId2 = t_base_offers.AddOneRow(rdb.Connection);
            t_offers.AddOneRow(rdb.Connection, 0, biBaseOfferId1); //Xbox1 Offer
            t_offers.AddOneRow(rdb.Connection, 2, biBaseOfferId2); //Xbox360 Offer
            

            //
                T_subscriptions t_subscriptions = new T_subscriptions();
            try{
                t_subscriptions.AddOneRow(rdb.Connection, biUserPuid1, biBaseOfferId1);
                t_subscriptions.AddOneRow(rdb.Connection, biUserPuid2, biBaseOfferId1);
            }
            catch(Exception e){
                Log.Warn("t_subscriptions: "+e.Message);
                bReturn = false;
            }
            
            //
            // Populate Data - fact tables
            //

            //
            T_rdb_new_account_fact t_rdb_new_account_fact = new T_rdb_new_account_fact();
            try{
                t_rdb_new_account_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, biBaseOfferId1);
            }
            catch(Exception e){
                Log.Warn("t_new_account_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_migrate_account_fact t_rdb_migrate_account_fact = new T_rdb_migrate_account_fact();
            try{
                t_rdb_migrate_account_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1);
            }
            catch(Exception e){
                Log.Warn("t_rdb_migrate_account_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_provision_fact t_rdb_provision_fact = new T_rdb_provision_fact();
            try{
                t_rdb_provision_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, biBaseOfferId1);
            }
            catch(Exception e){
                Log.Warn("t_rdb_provision_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_session_fact t_rdb_session_fact = new T_rdb_session_fact();
            try{
                t_rdb_session_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid2, iTitleId_xbox360);
                //t_rdb_session_fact.AddOneRow(rdb.Connection, iDate, iTime.AddMinutes(1), biUserPuid2, iTitleId_xbox360);
            }
            catch(Exception e){
                Log.Warn("t_rdb_session_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_presence_fact t_rdb_presence_fact = new T_rdb_presence_fact();
            try{
                t_rdb_presence_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, iTitleId_xbox1);
            }
            catch(Exception e){
                Log.Warn("t_rdb_presence_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_msg_snd_fact t_rdb_msg_snd_fact = new T_rdb_msg_snd_fact();
            try{
                t_rdb_msg_snd_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, iTitleId_xbox360);
            }
            catch(Exception e){
                Log.Warn("t_rdb_msg_snd_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_guest_fact t_rdb_guest_fact = new T_rdb_guest_fact();
            try{
                t_rdb_guest_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, iTitleId_xbox360);
            }
            catch(Exception e){
                Log.Warn("t_rdb_guest_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_purchase_fact t_rdb_purchase_fact = new T_rdb_purchase_fact();
            try{
                t_rdb_purchase_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid2, iTitleId_xbox360, biOfferId2);
            }
            catch(Exception e){
                Log.Warn("t_rdb_purchase_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_content_fact t_rdb_content_fact = new T_rdb_content_fact();
            try{
                t_rdb_content_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid1, iTitleId_xbox1, biOfferId1);  //Xbox1 Content
                }
            catch(Exception e){
                Log.Warn("t_rdb_content_fact: "+e.Message);
                bReturn = false;
            }

            //
            T_rdb_content_xbox360_fact t_rdb_content_xbox360_fact = new T_rdb_content_xbox360_fact();
            try{
                t_rdb_content_xbox360_fact.AddOneRow(rdb.Connection, iDate, iTime, biUserPuid2,  biOfferId2);  //Xbox360 Content
                }
            catch(Exception e){
                Log.Warn("T_rdb_content_xbox360_fact: "+e.Message);
                bReturn = false;
            }

            Log.Info("PopulateSingleFactTablesForOneday ended.");

            return bReturn;
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingXBLReport.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.STFLive.Database;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// Abstract class for Xbox Live Report objects. Each object will map to a specific report
    /// </summary>
    public abstract class XBLReport
    {
        /// <summary>
        /// What server you are dealing with
        /// </summary>
        public virtual ReportingMachines ComponentType
        {
            get { return ReportingMachines.Uninitialized; }
        }
        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public virtual string ComponentName
        {
            get { return "Uninitialized"; }
        }

        /// <summary>
        /// Path to report in ReportingService
        /// </summary>
        public abstract string ReportPath
        {
            get;
        }

        /// <summary>
        /// Queries the ReportingService to get the parameters for this Report.
        /// </summary>
        /// <returns>A list of Report Parameter Names</returns>
        public virtual List<string> GetReportParameters()
        {
            // Get common instance
            ReportingCommon rcommon = ReportingCommon.Instance;
            return ((ReportingIIS)rcommon.ReportingIIS).GetReportParameters(ReportPath);            
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this Report
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public abstract string Verify(ReportingReferenceObject refObject);
        
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this Report
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public abstract string Verify(ReportingReferenceObjectContainer refObjectContainer);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingVerification.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.Database;
using ServerTestFramework.STFLive.Database;


namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// 
    /// </summary>
    public abstract class ReportingVerification : ReportingReferenceObject
    {
        /// <summary>
        /// 
        /// </summary>
        protected bool m_Completed;

        /// <summary>
        /// 
        /// </summary>
        public bool Completed
        {
            get
            {
                return m_Completed;
            }
            set
            {
                lock (this)
                {
                    m_Completed = value;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected int m_HResult;

        /// <summary>
        /// 
        /// </summary>
        public int HResult
        {
            get
            {
                return m_HResult;
            }
            set
            {
                lock (this)
                {
                    m_HResult = value;
                }
            }
        }

        protected string m_Results;
        /// <summary>
        /// The results of this job
        /// </summary>
        public string Results
        {
            get
            {
                return m_Results;
            }
            set
            {
                m_Results = value;
            }
        }

        protected DateTime m_StartTime;

        /// <summary>
        /// When the job was started
        /// </summary>
        public DateTime StartTime
        {
            get
            {
                return m_StartTime;
            }
            set
            {
                m_StartTime = value;
            }
        }

        protected TimeSpan m_RunningTime;
        /// <summary>
        /// How long it took this job to run
        /// </summary>
        public TimeSpan RunningTime
        {
            get
            {
                return m_RunningTime;
            }
            set
            {
                m_RunningTime = value;
            }
        }

        protected String m_JobName;

        /// <summary>
        /// Name of the job
        /// </summary>
        public string JobName
        {
            get
            {
                return m_JobName;
            }            
        }

        protected NameValueCollection m_JobSteps;
        /// <summary>
        /// Job Steps
        /// </summary>
        public NameValueCollection JobSteps
        {
            get
            {
                return m_JobSteps;
            }
            set
            {
                m_JobSteps = JobSteps;
            }

        }

        /// <summary>
        /// Job parameters
        /// </summary>
        protected ReportingJobParameters m_Parameters;

        /// <summary>
        /// Job Parameters
        /// </summary>
        public ReportingJobParameters Parameters
        {
            get
            {
                return m_Parameters;
            }
        }


        /// <summary>
        /// Execute the job
        /// </summary>
        /// <returns>The constructed SQL script to execute the job</returns>
        public virtual string RunJob()                
        {
            // SQL COMMAND:
            //  use msdb
            //  exec sp_start_job '<JOBNAME>'
            return @"exec sp_start_job '" + m_JobName + "'";
        }
       

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Data\OlapGenericData.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Reporting;



namespace ServerTestFramework.STFLive.Reporting
{


    /// <summary>
    /// Generic Olap Data class
    /// </summary>
    public class OlapGenericData : ReportingData
    {
        protected ReportingDatabase _source;
        protected ReportingDataType _objectType;
        protected InternalDataType _dataType;

        protected object _rawData;

        protected NameValueCollection _dataCollection;

        /// <summary>
        /// Constructor
        /// </summary>
        public OlapGenericData()
        {
            _objectType = ReportingDataType.OlapGenericData;
            _rawData = null;
        }

        /// <summary>
        /// Data source: UODB, SSIS, ReportingDB, etc
        /// </summary>
        public override ReportingDatabase Source
        {
            get { return _source; }
            set { _source = value; }
        }

        /// <summary>
        ///  Get ReportingData object type
        /// </summary>
        public override ReportingDataType ObjectType
        {
            get { return _objectType; }
        }

        /// <summary>
        /// Get internal data type (Queries, Raw, Counts)
        /// </summary>
        public override InternalDataType DataType
        {
            get { return _dataType; }
            set { _dataType = value; }
        }


        /// <summary>
        /// ReportingData is a series of tables and respective row counts
        /// </summary>
        public override NameValueCollection TableCounts
        {
            set { _dataCollection = TableCounts; }
            get { return _dataCollection; }
        }

        /// <summary>
        /// Raw object data (Caller must know how to cast the data)
        /// </summary>
        public override object RawData
        {
            set { _rawData = value; }
            get { return _rawData; }
        }


    }//Generic Olap data class










}//Namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingTable.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// A class representing individual database tables
    /// </summary>
    public class ReportingTable
    //public abstract class ReportingTable
    {
        protected string _szTableName;
        protected Hashtable _keyTable;

        public ReportingTable()
        {
            _keyTable = new Hashtable();

            
        }

        public string TableName
        {
            get { return _szTableName; }
        }

        public Hashtable KeyTable
        {
            get
            {
                return _keyTable;
            }
        }

        /// <summary>
        /// GetMaxUserID
        /// </summary>
        public virtual long GetMaxUserPUID(SqlConnection conn)
        {
            long bi_user_puid;
            
            // Get current max title id in the table
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = conn;
            Cmd.CommandType = CommandType.Text;
            if(_szTableName == "t_subscriptions")
                Cmd.CommandText = string.Format("select max(bi_primary_puid) from {0} where bi_primary_puid < 0x0009FFFFFFFFFC00", _szTableName);	
            else if(_szTableName == "t_achievements")
                Cmd.CommandText = string.Format("select max(bi_puid) from {0} where bi_puid < 0x0009FFFFFFFFFC00", _szTableName);	
            else
                Cmd.CommandText = string.Format("select max(bi_user_puid) from {0} where bi_user_puid < 0x0009FFFFFFFFFC00", _szTableName);	

	     Cmd.CommandTimeout = 300;
            Object obj = Cmd.ExecuteScalar ();

            if(Object.ReferenceEquals(obj.GetType(),DBNull.Value.GetType()) )
                throw new Exception(string.Format("No data at {0}", _szTableName));
            else
                bi_user_puid = (long) obj ;
            
            return bi_user_puid;
        }

        /// <summary>
        /// GetMaxUserID - Using Reporting Database
        /// </summary>
        public virtual long GetMaxUserPUID(ReportingDatabase Database)
        {
            long result = 0;
            // Iterate through reader
            SqlConnection Connection = new SqlConnection(string.Format("Integrated Security=SSPI;Initial Catalog={0};server={1}", Database.DatabaseName, Database.ComponentName));
            Connection.Open();

            result = GetMaxUserPUID(Connection);

            if (Connection != null)
            {
                Connection.Close();
            }
            Connection = null;
            return result;
        }


        /// <summary>
        /// GetMinUserID
        /// </summary>
        public virtual long GetMinUserPUID(SqlConnection conn)
        {
            long bi_user_puid;
            
            // Get current max title id in the table
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = conn;
            Cmd.CommandType = CommandType.Text;
            if (_szTableName == "t_subscriptions")
                Cmd.CommandText = string.Format("select min(bi_primary_puid) from {0} where bi_primary_puid < 0x0009FFFFFFFFFC00", _szTableName);
            else if (_szTableName == "t_achievements")
                Cmd.CommandText = string.Format("select min(bi_puid) from {0} where bi_puid < 0x0009FFFFFFFFFC00", _szTableName);
            else
                Cmd.CommandText = string.Format("select min(bi_user_puid) from {0}", _szTableName); // where bi_user_puid < 0x0009FFFFFFFFFC00", _szTableName);	

	     Cmd.CommandTimeout = 300;
            Object obj = Cmd.ExecuteScalar ();

            if(Object.ReferenceEquals(obj.GetType(),DBNull.Value.GetType()) )
                throw new Exception(string.Format("No data at {0}", _szTableName));
            else
                bi_user_puid = (long) obj;
            
            return bi_user_puid;
        }

        /// <summary>
        /// GetMinUserID - Using Reporting Database
        /// </summary>
        public virtual long GetMinUserPUID(ReportingDatabase Database)
        {
            long result = 0;
            // Iterate through reader
            SqlConnection Connection = new SqlConnection(string.Format("Integrated Security=SSPI;Initial Catalog={0};server={1}", Database.DatabaseName, Database.ComponentName));
            Connection.Open();

            result = GetMinUserPUID(Connection);

            if (Connection != null)
            {
                Connection.Close();
            }
            Connection = null;
            return result;
        }


        /// <summary>
        /// FindNextUserID
        /// </summary>
        public virtual long FindNextUserID(SqlConnection conn, long bi_user_puid)
        {
            long bi_user_puid_return;
            
            // Get current max title id in the table
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = conn;

            bi_user_puid_return=FindNextUserID( Cmd,  bi_user_puid);
            
            return (long) bi_user_puid_return;
        }

        /// <summary>
        /// Find Next User ID - Using Reporting Database
        /// </summary>
        public virtual long FindNextUserID(ReportingDatabase Database, long bi_user_puid)
        {
            long result = 0;
            // Iterate through reader
            SqlConnection Connection = new SqlConnection(string.Format("Integrated Security=SSPI;Initial Catalog={0};server={1}", Database.DatabaseName, Database.ComponentName));
            Connection.Open();

            result = FindNextUserID(Connection,bi_user_puid);

            if (Connection != null)
            {
                Connection.Close();
            }
            Connection = null;
            return result;
        }


        /// <summary>
        /// FindNextUserID
        /// </summary>
        public virtual long FindNextUserID(SqlCommand Cmd, long bi_user_puid)
        {
            long bi_user_puid_return;
            
            // Get current max title id in the table
            Cmd.CommandType = CommandType.Text;
            if(_szTableName == "t_subscriptions")
                Cmd.CommandText = string.Format("select min(bi_primary_puid) from {0} where bi_primary_puid > {1}", _szTableName, bi_user_puid);	
            else if(_szTableName == "t_achievements")
                Cmd.CommandText = string.Format("select min(bi_puid) from {0} where bi_puid > {1}", _szTableName, bi_user_puid);	
            else
                Cmd.CommandText = string.Format("select min(bi_user_puid) from {0} where bi_user_puid > {1}", _szTableName, bi_user_puid);	

	     Cmd.CommandTimeout = 300;
            Object obj = Cmd.ExecuteScalar ();

            if(Object.ReferenceEquals(obj.GetType(),DBNull.Value.GetType()) )
                throw new Exception(string.Format("No data at {0}", _szTableName));
            else
                bi_user_puid_return = (long) obj;
            
            return (long) bi_user_puid_return;
        }

    
        /// <summary>
        /// Get Table Record Count
        /// </summary>
        public virtual long GetRecordCount(ReportingDatabase Database)
        {
            TestRefObject tro = new TestRefObject();
            long result = 0;
            tro.DebugQuery = string.Format("SELECT count(*) FROM {0} (nolock)", _szTableName);
            
            // Iterate through reader
            result = long.Parse(Database.RunDebugQuery(tro));      

            return result;
        }

        
    }//ReportingTable
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Data\RealtimeDBStressData.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework.STFLive.Reporting;


public class RealtimeDBStressData : ReportingData
{
    
    /// <summary>
    /// Data source: UODB, SSIS, ReportingDB, etc
    /// </summary>
    private ReportingDatabase m_Source;
    public override ReportingDatabase Source
    {
        get { return m_Source; }
        set { m_Source = value; }
    }

    /// <summary>
    ///  Get ReportingData object type
    /// </summary>
    private ReportingDataType m_ObjectType;
    public override ReportingDataType ObjectType
    {
        get { return m_ObjectType; }
    }

    /// <summary>
    /// Get internal data type (Queries, Raw, Counts)
    /// </summary>
    private InternalDataType m_DataType;
    public override InternalDataType DataType
    {
        set { throw new Exception("ERROR: RealtimeDBStressData class only supports Query InternalDataType"); }
        get { return m_DataType; }        
    }


    /// <summary>
    /// List of queries
    /// </summary>
    private Hashtable m_Queries;
    public override Hashtable Queries
    {
        set { m_Queries = value; }
        get { return m_Queries; }
    }


    /// <summary>
    /// Constructor
    /// </summary>
    public RealtimeDBStressData()
    {
        // Store all of the Queries in the HashTable
        m_Queries = null;
        m_ObjectType = ReportingDataType.RealtimeDBStressData;
        m_DataType = InternalDataType.Query;
    }
    



}//RealtimeDBStressData class
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Data\RealtimeDBStressDataLoader.cs ===
using System;
using System.Collections.Generic;

using System.Data.SqlClient;
using ServerTestFramework.STFLive.Database;

using ServerTestFramework.STFLive.Reporting.Tables;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This class contains the logic necessary to load Data objects into the Reporting Realtime Database
    /// or FilterDB databases that feed the Realtime system.
    /// </summary>
    public class RealtimeDBStressDataLoader : ReportingDataLoader
    {
        /// <summary>
        /// UserPuid index - Puid to use in the next data generation
        /// </summary>
        private static string m_MinUserIndex ="";
        private static string m_MaxUserIndex ="";
        private static string m_UserIndex = "";
       
        /// <summary>
        /// Initialize the data index
        /// </summary>
        /// <param name="SeedIndex">Seed value to use</param>
        public string MinUserIndex
        {
            set
            {               
                m_MinUserIndex = value;
                m_UserIndex = value;
            }
            get
            {
                return m_MinUserIndex;
            }
        }
        // Max User index
        public string MaxUserIndex
        {
            set { m_MaxUserIndex = value; }
            get { return m_MaxUserIndex; }
        }


        /// <summary>
        /// Array of titles to use
        /// </summary>
        private static List<string> m_Titles;
        public List<string> Titles
        {
            get { return m_Titles; }
            set { m_Titles = value; }
        }

        /// <summary>
        /// Array of offers to use
        /// </summary>
        private static List<string> m_Offers;
        public List<string> Offers
        {
            get { return m_Offers; }
            set { m_Offers = value; }
        }

       

        /// <summary>
        /// Target table to insert data into
        /// </summary>
        private ReportingTable m_TargetTable;
        public ReportingTable TargetTable
        {
            get { return m_TargetTable; }
            set { m_TargetTable = value; }            
        }

        // Random object for data generation
        private static Random m_Random = new Random();

        /// <summary>
        /// Get the database names supported by this loader object
        /// </summary>
        /// <returns>List of database names</returns>
        public override System.Collections.Generic.List<string> GetSupportedDatabases()
        {
            List<string> retVal = new List<string>(ReportingCommon.Instance.FilterDBs.Count + 1);
            // Return filterDB & RealtimeDB names
            foreach (ReportingDatabase d in ReportingCommon.Instance.FilterDBs)
            {
                retVal.Add(d.DatabaseName);
            }
            retVal.Add(ReportingCommon.Instance.RealtimeDB.DatabaseName);
            return retVal;
        }


        /// <summary>
        /// This method creates a SQL query to add a single row of data into specific tables of a database.
        /// </summary>        
        /// <returns>SQL string to add data</returns>
        public override string InjectSingleData()
        {
            string retVal = "";

            //Initialize random values 
            int nextRandom = m_Random.Next(500000);
            string randomTitle = m_Titles[nextRandom % m_Titles.Count];
            string randomOffer = m_Offers[nextRandom % m_Offers.Count];

            // Create a SQL command based on table type
            switch (m_TargetTable.TableName.ToUpper())
            {
                case "T_SESSION_FACT":  // SESSIONS
                    T_session_fact tempSession = (T_session_fact)m_TargetTable;
                    tempSession.dt_start = new DateRange(1000, 1000);
                    if ((nextRandom % 2) > 0)
                    {
                        retVal = "insert t_session_fact values('" + tempSession.dt_start.dateMax + "', " + nextRandom +
                            ", " + m_UserIndex + ", " + randomTitle + ", " + (1000 + nextRandom)  +  ", " + m_UserIndex + ")";
                    }
                    else
                    {
                        retVal = "insert t_session_fact values('" + tempSession.dt_start.dateMin + "', " + nextRandom +
                         ", " + m_UserIndex + ", " + randomTitle + ", " + (1000 + nextRandom) + ", " + m_UserIndex + ")";
                    }
                    break;
                case "T_PRESENCE_FACT": // PRESENCE
                    T_presence_fact tempPresence = (T_presence_fact)m_TargetTable;
                    tempPresence.dt_start = new DateRange(1000, 1000);
                    if ((nextRandom % 2) > 0)
                    {
                        retVal = "insert t_presence_fact values('" + tempPresence.dt_start.dateMax + "', " + nextRandom + 
                            ", " + m_UserIndex + ", " + m_UserIndex + ", " + randomTitle + ", 192168001001, " + (1000 + nextRandom)  +  ", 1)";
                    }
                    else
                    {
                        retVal = "insert t_presence_fact values('" + tempPresence.dt_start.dateMin + "', " + nextRandom + 
                            ", " + m_UserIndex + ", " + m_UserIndex + ", " + randomTitle + ", 192168001001 , " + (1000 + nextRandom)  +  ", 0)";
                    }
                    
                    break;
                case "T_PURCHASE_FACT": // PURCHASES
                    T_purchase_fact tempPurchase = (T_purchase_fact)m_TargetTable;
                    tempPurchase.dt_when = new DateRange(1000, 1000);
                    if ((nextRandom % 2) > 0)
                    {
                        retVal = "insert t_purchase_fact values('" + tempPurchase.dt_when.dateMax + "', " + m_UserIndex + ", " + m_UserIndex +
                            ", " + ((nextRandom % 3) * 3) + ", " + (nextRandom % 104) + ", 1, " + (nextRandom % 3) + ", " + randomOffer + ", 100, 50)";
                    }
                    else
                    {
                        retVal = "insert t_purchase_fact values('" + tempPurchase.dt_when.dateMin + "', " + m_UserIndex + ", " + m_UserIndex +
                            ", " + ((nextRandom % 3) * 3) + ", " + (nextRandom % 104) + ", 1, " + (nextRandom % 3) + ", " + randomOffer + ", 100, 50)";
                    }
                    
                    break;
                case "T_CONTENT_FACT": // CONTENT
                    T_content_fact tempContent = (T_content_fact)m_TargetTable;
                    tempContent.dt_when = new DateRange(1000, 1000);                    
                    if ((nextRandom % 2) > 0)
                    {
                        retVal = "insert t_content_fact values ('" + tempContent.dt_when.dateMin + "', " + m_UserIndex + ", " + m_UserIndex +
                            ", " + m_UserIndex + ", " + randomTitle + ", " + randomOffer + ", 0x123)";
                    }
                    else
                    {
                        retVal = "insert t_content_fact values ('" + tempContent.dt_when.dateMax + "', " + m_UserIndex + ", " + m_UserIndex +
                            ", " + m_UserIndex + ", " + randomTitle + ", " + randomOffer + ", 0x123)";
                    }

                    break;
                case "T_NEW_ACCOUNT_FACT": // NEW ACCOUNTS
                    T_new_account_fact tempAccount = (T_new_account_fact)m_TargetTable;
                    tempAccount.dt_when = new DateRange(1000, 1000);
                    retVal = "insert t_new_account_fact values('" + tempAccount.dt_when.dateMin + "', " + (nextRandom % 3) + ", " +
                        m_UserIndex + ", " + m_UserIndex + ", 1111, 1111, " + (nextRandom % 104) + ", 1, 1033, -554353576378358, " + nextRandom % 2 + ")";

                    break;
                default:
                    throw new Exception("ERROR: TABLE " + m_TargetTable.TableName + " IS NOT SUPPORTED");                    
            }
            // Increase index
            IncreaseUserDataIndex();

            return retVal;
        }

        /// <summary>
        /// Internal function to increase data index
        /// </summary>
        private void IncreaseUserDataIndex()
        {            
            long temp = 0;
            if (m_UserIndex != "")
            {                
                temp = (long.Parse(m_UserIndex));                
                temp++;
                m_UserIndex = temp.ToString();
                if (m_UserIndex == m_MaxUserIndex)
                {
                    m_UserIndex = m_MinUserIndex;
                }
            }
        }

    } // RealTimeDBDataLoader class
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\CIQDatafeed.cs ===
using System;
using System.Collections.Specialized;

using ServerTestFramework.Utilities;
using ServerTestFramework.STFLive;

using xonline.common.config;

using ServerTestFramework.STFLive.Database;
namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the CIQ Datafeed export job
    /// </summary>
    public class CIQDatafeed : ReportingJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public CIQDatafeed()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public CIQDatafeed(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }
        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingDB.ComponentName;

            m_JobName = @"CIQ Datafeed";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.CIQ_Datafeed;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";       

            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class CIQDatafeed_Params : ReportingJobParameters
        {
            // Enter any parameters here..
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Events\CleanserTCPEvent.cs ===
using System;
using System.Net;
using System.Net.Sockets;

using System.IO;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;


using xonline.common.mgmt;
//using xonline.server.cleanser.svr;

using xonline.common.config;


namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// CleanserTCPEvent
    /// </summary>
    public class CleanserTCPEvent : ReportingEvent
    {
        protected int _componentID; 
        protected Socket[] _rptSock;
        protected int _iNumCleanser;
        protected DateTime _dtEvent;


        /// <summary>
        /// CleanserTCPEvent constructor
        /// </summary>
        public CleanserTCPEvent( )
        {
            string[] szServers;

            szServers = Config.GetServerListByInterface(Interface.cleanser);
            _iNumCleanser = szServers.Length;

            _dtEvent = DateTime.UtcNow;
        }
        
        /// <summary>
        /// ConnectToCleanser
        /// </summary>
        public void ConnectToCleanser( int serverID, int componentID)
        {
            string[] szServers;

            szServers = Config.GetServerListByInterface(Interface.cleanser);
            serverID %= _iNumCleanser;
            
            if (_rptSock==null)
            {
                _rptSock = new Socket[_iNumCleanser];
            }

            // Create a TCP/IP socket.
            if(_rptSock[serverID] == null)
                _rptSock[serverID] = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            
            //
            if(_rptSock[serverID].Connected)
            {
                return;
            }
            
            //            
            IInterfaceInfo iface = Config.GetInterface(szServers[serverID], Interface.cleanser);
            IPEndPoint remoteEP = new IPEndPoint(iface.IPAddress, iface.Port);

            // Connect to the remote endpoint.
            _rptSock[serverID].Connect( remoteEP);   

            ReportMessageConnect connect = new  ReportMessageConnect();
            //connect.iServerID = serverID; // ServerID is deprecated in NPDB
            connect.iComponentID = componentID;
            connect.vcServer = szServers[serverID];
            SocketSend(serverID, (byte[])connect);
        }

        /// <summary>
        /// DisconnectFromCleanser
        /// </summary>
        public void DisconnectFromCleanser(int serverID)
        {
            serverID %= _iNumCleanser;
            
            if (_rptSock[serverID] !=null && _rptSock[serverID].Connected)
            {
                ReportMessageBase disconnect = new ReportMessageBase();
                disconnect.bMsgType = ( byte ) RPT_MSG_TYPE.RPT_MSG_DISCONNECT;
                SocketSend(serverID, (byte[])disconnect);
                try
                {
                    _rptSock[serverID].Shutdown(SocketShutdown.Both);
                    _rptSock[serverID].Close();  
                    _rptSock[serverID] = null;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Exception caught: " + e.Message);
                }
           }
        }

        /// <summary>
        /// SocketSend
        /// </summary>
        protected void SocketSend(int serverID, byte[] buffer)
        {      
            serverID %= _iNumCleanser;

            int sizeSent = _rptSock[serverID].Send(buffer, SocketFlags.None);
            
            if ( sizeSent != buffer.Length)
            {
                throw new Exception("Failed to send full message: original size = " + buffer.Length + " sent size  = "+sizeSent);
            }
        }

        /// <summary>
        /// SendMessage
        /// </summary>
        protected void SendMessage(int serverID, int componentID, string logLine)
        {
            serverID %= _iNumCleanser;
            
            ReportMessageData data = new ReportMessageData();                           
            data.szMessage =logLine;
            data.usSize += ( ushort ) ( Encoding.UTF8.GetByteCount( logLine ) );    
            data.llTime = _dtEvent.ToFileTimeUtc( );
            SocketSend(serverID, (byte[])data);
        }

    }

    /// <summary>
    /// MigrateAccountTCPEvent
    /// </summary>
    public class MigrateAccountTCPEvent : CleanserTCPEvent
    {
        private long _userPassportPuid,_userPuid; 
        private int _hr;
    
        public MigrateAccountTCPEvent()
        {
            _componentID = 7; // Component.xuacs;
        }
        
        public void SendLogLine(int serverID, long userPassportPuid, long userPuid, int hr)
        {
            //		MIGRATEXBOX1USER|userPassportPuid|userPuid|hr

            _userPassportPuid = userPassportPuid;
            _userPuid = userPuid;
            _hr = hr;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);
    
            //		MIGRATEXBOX1USER|userPassportPuid|userPuid|hr
            string logLine = string.Format("MIGRATEXBOX1USER|{0}|{1}|{2}",
                                                           _userPassportPuid,_userPuid,_hr );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// ProvisionTCPEvent 
    /// </summary>
    public class ProvisionTCPEvent : CleanserTCPEvent
    {
        private long _aPuid, _userPuid,  _oldXboxOfferId,  _newXboxOfferId;
        private string  _serviceInstanceId;
        private int  _oldTierId, _newTierId;
    
        public ProvisionTCPEvent()
        {
            _componentID = 5; // Component.xcbk;
        }
        
        public void SendLogLine(int serverID, long aPuid, long userPuid, string serviceInstanceId, long oldXboxOfferId, int oldTierId, long newXboxOfferId, int newTierId)
        {
            _aPuid = aPuid;
            _userPuid = userPuid;
            _serviceInstanceId = serviceInstanceId;
            _oldXboxOfferId = oldXboxOfferId;
            _oldTierId = oldTierId;
            _newXboxOfferId = newXboxOfferId;
            _newTierId = newTierId;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);
    
            //	PROVISIONSERVICE|aPuid|userPuid|serviceInstanceId|oldXboxOfferId|oldTierId|newXboxOfferId|newTierId
            string logLine = string.Format("PROVISIONSERVICE|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                            _aPuid, _userPuid, _serviceInstanceId, _oldXboxOfferId, _oldTierId, _newXboxOfferId, _newTierId );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// DeprovisionTCPEvent 
    /// </summary>
    public class DeprovisionTCPEvent : CleanserTCPEvent
    {
        private long _aPuid, _userPuid,  _oldXboxOfferId,  _newXboxOfferId;
        private string  _serviceInstanceId;
        private int  _oldTierId, _newTierId;
    
        public DeprovisionTCPEvent()
        {
            _componentID = 5; // Component.xcbk;
        }
        
        public void SendLogLine(int serverID, long aPuid, long userPuid, string serviceInstanceId, long oldXboxOfferId, int oldTierId, long newXboxOfferId, int newTierId)
        {
            _aPuid = aPuid;
            _userPuid = userPuid;
            _serviceInstanceId = serviceInstanceId;
            _oldXboxOfferId = oldXboxOfferId;
            _oldTierId = oldTierId;
            _newXboxOfferId = newXboxOfferId;
            _newTierId = newTierId;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);
    
            //	DEPROVISIONSERVICE|aPuid|userPuid|serviceInstanceId|oldXboxOfferId|oldTierId|newXboxOfferId|newTierId
            string logLine = string.Format("DEPROVISIONSERVICE|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                            _aPuid, _userPuid, _serviceInstanceId, _oldXboxOfferId, _oldTierId, _newXboxOfferId, _newTierId );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }



    /// <summary>
    /// ContentTCPEvent
    /// </summary>
    public class ContentTCPEvent : CleanserTCPEvent
    {
        private long _biMachineID, _biUserPUID0, _biUserPUID1, _biUserPUID2, _biUserPUID3; 
        private int _ititleID;
        private long _biOfferID; 
        private int _hresult;
    
        public ContentTCPEvent()
        {
            _componentID = 6; // Component.xbos;
        }

        public void SendLogLine(int serverID, long biMachineID, long biUserPUID0, long biUserPUID1, long biUserPUID2, long biUserPUID3, int ititleID, long biOfferID, int hresult)
        {
            //   CONTENTREF|MachineID|userPUID0|userPUID1|userPUID2|userPUID3|titleID|offerID|hresult|referralNonce|Nonce

            _biMachineID = biMachineID;
            _biUserPUID0 = biUserPUID0;
            _biUserPUID1 = biUserPUID1;
            _biUserPUID2 = biUserPUID2;
            _biUserPUID3 = biUserPUID3; 
            _ititleID = ititleID;
            _biOfferID = biOfferID; 
            _hresult = hresult;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //   CONTENTREF|MachineID|userPUID0|userPUID1|userPUID2|userPUID3|titleID|offerID|hresult|referralNonce|Nonce
            string logLine = string.Format("CONTENTREF|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|fffffff|123123123123123",
                                                           _biMachineID,  _biUserPUID0,  _biUserPUID1,  _biUserPUID2,  _biUserPUID3,  _ititleID,  _biOfferID,  _hresult );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }


    /// <summary>
    /// ContentXeTCPEvent - Not Done
    /// </summary>
    public class ContentXeTCPEvent : CleanserTCPEvent
    {
        private long _owner_machinePuid, _userPuid, _MachinePuid; 
        private string _contentId;
        private int _packageSize, _installSize, _locations,_hresult;
    
        public ContentXeTCPEvent()
        {
            _componentID = 6; // Component.xbos;
        }

        public void SendLogLine(int serverID, long owner_machinePuid, long userPuid, long MachinePuid, string contentId, int packageSize, int installSize, int locations, int hresult)
        {
            _owner_machinePuid = owner_machinePuid;
            _userPuid = userPuid;
            _MachinePuid = MachinePuid;
            _contentId = contentId;
            _packageSize = packageSize; 
            _installSize = installSize;
            _locations = locations; 
            _hresult = hresult;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //        XeContentReferral|owner_machinePuid|userPuid|MachinePuid|contentId|packageSize|installSize|locations|hresult|Nonce
            string logLine = string.Format("XeContentReferral|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|123123123123123",
                                                           _owner_machinePuid, _userPuid, _MachinePuid, _contentId, _packageSize, _installSize, _locations, _hresult );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// PresenceTitleStartTCPEvent
    /// </summary>
    public class PresenceTitleStartTCPEvent : CleanserTCPEvent
    {
        private long _MachinePUID, _UserPUID, _XboxIP, _SessKey; 
        private int _TitleID, _State;
        private short _Xboxport;
    
        public PresenceTitleStartTCPEvent()
        {
            _componentID = 17; // Component.xpserver;
        }

        public void SendLogLine(int serverID, long MachinePUID, int TitleID, long UserPUID, int State, long XboxIP, short Xboxport, long SessKey)
        {
            _MachinePUID = MachinePUID;
            _UserPUID = UserPUID;
            _XboxIP = XboxIP;
            _SessKey = SessKey;
            _TitleID = TitleID; 
            _State = State;
            _Xboxport = Xboxport; 

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            // TITLESTART|      MachinePUID|     TitleID|    UserPUID|              State|Xbox IP|    Xbox port|SessKey
            string logLine = string.Format("TITLESTART|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _MachinePUID, _TitleID, _UserPUID, _State, _XboxIP, _Xboxport, _SessKey );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// PresenceTitleEndTCPEvent 
    /// </summary>
    public class PresenceTitleEndTCPEvent : CleanserTCPEvent
    {
        private long _MachinePUID, _UserPUID, _XboxIP, _SessKey; 
        private int _TitleID, _State, _Duration;
        private short _Xboxport;
    
        public PresenceTitleEndTCPEvent()
        {
            _componentID = 17; // Component.xpserver;
        }

        public void SendLogLine(int serverID, long MachinePUID, int TitleID, long UserPUID, int State, long XboxIP, short Xboxport, long SessKey, int Duration)
        {
            _MachinePUID = MachinePUID;
            _UserPUID = UserPUID;
            _XboxIP = XboxIP;
            _SessKey = SessKey;
            _TitleID = TitleID; 
            _State = State;
            _Xboxport = Xboxport; 
            _Duration = Duration; 

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //   TITLEND|MachinePUID|     TitleID|    UserPUID|        State|Xbox IP|Xbox port|SessKey|Duration(ms)
            string logLine = string.Format("TITLEND|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}",
                                                           _MachinePUID, _TitleID, _UserPUID, _State, _XboxIP, _Xboxport, _SessKey, _Duration );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// SessionStartTCPEvent
    /// </summary>
    public class SessionStartTCPEvent : CleanserTCPEvent
    {
        private long _MachinePUID, _UserPUID, _SessionID; 
        private int _TitleID, _State;
    
        public SessionStartTCPEvent()
        {
            _componentID = 17; // Component.xpserver;
        }

        public void SendLogLine(int serverID, long MachinePUID,  long UserPUID, int TitleID, int State, long SessionID)
        {
            _MachinePUID = MachinePUID;
            _UserPUID = UserPUID;
            _TitleID = TitleID; 
            _State = State;
            _SessionID = SessionID; 

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //SESSTART|MachinePUID|TitleID|UserPUID|State|SessionID 
            string logLine = string.Format("SESSTART|{0}|{1}|{2}|{3}|{4}",
                                                           _MachinePUID, _TitleID, _UserPUID, _State, _SessionID );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// SessionEndTCPEvent
    /// </summary>
    public class SessionEndTCPEvent : CleanserTCPEvent
    {
        private long _MachinePUID, _UserPUID, _SessionID; 
        private int _TitleID, _State, _Duration;
    
        public SessionEndTCPEvent()
        {
            _componentID = 17; // Component.xpserver;
        }

        public void SendLogLine(int serverID, long MachinePUID,  long UserPUID, int TitleID, int State, long SessionID, int Duration)
        {
            _MachinePUID = MachinePUID;
            _UserPUID = UserPUID;
            _TitleID = TitleID; 
            _State = State;
            _SessionID = SessionID; 
            _Duration = Duration; 

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //SESEND|MachinePUID|TitleID|UserPUID|State|SessionID |Duration(ms)
            string logLine = string.Format("SESEND|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _MachinePUID, _TitleID, _UserPUID, _State, _SessionID, _Duration );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// PresenceGuestTCPEvent
    /// </summary>
    public class PresenceGuestTCPEvent : CleanserTCPEvent
    {
        private long _MachinePUID, _UserPUID; 
        private int _TitleID, _State, _OldGuests, _NewGuests;
    
        public PresenceGuestTCPEvent()
        {
            _componentID = 17; // Component.xpserver;
        }

        public void SendLogLine(int serverID, long MachinePUID, int TitleID, long UserPUID, int State, int OldGuests, int NewGuests)
        {
            _MachinePUID = MachinePUID;
            _UserPUID = UserPUID;
            _TitleID = TitleID; 
            _State = State;
            _OldGuests = OldGuests; 
            _NewGuests = NewGuests;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            // GUESTCHG|MachinePUID|TitleID|UserPUID|State|OldGuests|NewGuests
            string logLine = string.Format("GUESTCHG|{0}|{1}|{2}|{3}|{4}|{5}",
                                                           _MachinePUID, _TitleID, _UserPUID, _State, _OldGuests, _NewGuests );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// XePurchaseTCPEvent
    /// </summary>
    public class XePurchaseTCPEvent : CleanserTCPEvent
    {
        private long _machinePUID , _userPUID, _offerID; 
        private int _lang, _tier , _paymentType, _priceW, _priceF, _payInstr, _hr;
        private byte _country;
    
        public XePurchaseTCPEvent()
        {
            _componentID = 6; // Component.xbos;
        }

        public void SendLogLine(int serverID, long  machinePUID , long userPUID    , byte country, int lang, int tier, long offerID   , int paymentType, int priceW, int priceF, int payInstr, int hr)
        {
            _machinePUID = machinePUID;
            _userPUID = userPUID;
            _offerID = offerID; 
            _lang = lang;
            _tier = tier; 
            _paymentType = paymentType;
            _priceW = priceW;
            _priceF = priceF;
            _payInstr = payInstr; 
            _hr = hr;
            _country = country;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            // XeOfferPurchase|machinePUID |userPUID    |country|lang|tier| offerID   |paymentType|priceW|priceF|payInstr|hr|Nonce
            string logLine = string.Format("XeOfferPurchase|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}",
                                                            _machinePUID , _userPUID    , _country, _lang, _tier, _offerID   , _paymentType, _priceW, _priceF, _payInstr, _hr);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }


    /// <summary>
    /// EliteMigrationTCPEvent
    /// </summary>
    public class EliteMigrationTCPEvent : CleanserTCPEvent
    {
        private long _biSgNonce, _biUserPUID, _biOldMachinePUID, _biNewMachinePUID; 
        private int _iUserLicenses, _iMachineLicenses, _iHr;
    
        public EliteMigrationTCPEvent()
        {
            _componentID = 6; // xonline.server.xbos;
        }
        
        public void SendLogLine(int serverID, long biSgNonce, long biUserPUID, long biOldMachinePUID, long biNewMachinePUID,  int iUserLicenses, int iMachineLicenses, int iHr)
        {
            //LICTRANSFER|SGNonce|UserPUID|OldMachineID|NewMachineID|UserLicenses|MachineLicenses|hr

            _biSgNonce = biSgNonce;
            _biUserPUID = biUserPUID;
            _biOldMachinePUID = biOldMachinePUID;
            _biNewMachinePUID = biNewMachinePUID;
            _iUserLicenses = iUserLicenses; 
            _iMachineLicenses = iMachineLicenses;
            _iHr = iHr; 

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LICTRANSFER|SGNonce|UserPUID|OldMachineID|NewMachineID|UserLicenses|MachineLicenses|hr
            string logLine = string.Format("LICTRANSFER|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _biSgNonce, _biUserPUID, _biOldMachinePUID, _biNewMachinePUID,  _iUserLicenses, _iMachineLicenses, _iHr );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// ContentTCPEvent
    /// </summary>
    public class GenericTCPEvent : CleanserTCPEvent
    {
        public GenericTCPEvent()
        {
            _componentID = 3; //random component
        }

        public void SendLogLine(int serverID, string szHeader, int iNumColumn)
        {
            ConnectToCleanser(serverID, _componentID);

            //  Random
            string logLine = string.Format("{0}", szHeader);
            for(int ii=0; ii<iNumColumn; ii++)
            {
                logLine += string.Format("|{0}", ii*12345);
            }

            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

        public void SendLogLine(int serverID, string szHeader, int iNumColumn, int iSizeOfColumn)
        {
            ConnectToCleanser(serverID, _componentID);

            string szColumn = new string('y', iSizeOfColumn);

            //  Random
            string logLine = string.Format("{0}", szHeader);
            for(int ii=0; ii<iNumColumn; ii++)
            {
                logLine += string.Format("|{0}", szColumn);
            }

            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }
        
        
        public void SendLogLine(int serverID, string szHeader, string szLogLine)
        {
            ConnectToCleanser(serverID, _componentID);

            string logLine = string.Format("{0}|{1}", szHeader,szLogLine);
            
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }
    }
    
    /// <summary>
    /// ArgonTCPEvent
    /// </summary>
    public class ArgonTCPEvent : CleanserTCPEvent
    {
        private long _bi_machine_puid; 
        private string _vc_argon_data;
    
        public ArgonTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID, long bi_machine_puid, string vc_argon_data)
        {

            _bi_machine_puid = bi_machine_puid;
            _vc_argon_data = vc_argon_data;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LS-DHW|<machine_puid>|<MSGDATA_ASCIITEXT>
            string logLine = string.Format("LS-DHW|{0}|{1}",
                                                           _bi_machine_puid, _vc_argon_data );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// GeoFenceOfferPurchaseTCPEvent
    /// </summary>
    public class GeoFenceOfferPurchaseTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid, _bi_machine_puid, _bi_offer_id; 
        private string _vc_reasoncode, _vc_ip_address, _vc_countrycode ;
    
        public GeoFenceOfferPurchaseTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, string vc_reasoncode, long bi_machine_puid, long bi_user_puid, string vc_ip_address, string vc_countrycode, long bi_offer_id)
        {

            _bi_machine_puid = bi_machine_puid;
            _bi_user_puid = bi_user_puid;
            _bi_offer_id = bi_offer_id;
            _vc_reasoncode = vc_reasoncode;
            _vc_ip_address = vc_ip_address;
            _vc_countrycode = vc_countrycode;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            // GeoFenceOfferPurchase|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|offerID
            string logLine = string.Format("GeoFenceOfferPurchase|{0}|{1}|{2}|{3}|{4}|{5}",
                                                           _vc_reasoncode, _bi_user_puid, _bi_machine_puid, _vc_ip_address, _vc_countrycode, _bi_offer_id );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// GeoFenceContentReferralTCPEvent
    /// </summary>
    public class GeoFenceContentReferralTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid, _bi_machine_puid, _bi_offer_id; 
        private string _vc_reasoncode, _vc_ip_address, _vc_countrycode ;
    
        public GeoFenceContentReferralTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, string vc_reasoncode, long bi_machine_puid, long bi_user_puid, string vc_ip_address, string vc_countrycode, long bi_offer_id)
        {

            _bi_machine_puid = bi_machine_puid;
            _bi_user_puid = bi_user_puid;
            _bi_offer_id = bi_offer_id;
            _vc_reasoncode = vc_reasoncode;
            _vc_ip_address = vc_ip_address;
            _vc_countrycode = vc_countrycode;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            // GeoFenceContentReferral|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|offerID
            string logLine = string.Format("GeoFenceContentReferral|{0}|{1}|{2}|{3}|{4}|{5}",
                                                           _vc_reasoncode, _bi_user_puid, _bi_machine_puid, _vc_ip_address, _vc_countrycode, _bi_offer_id );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// GeoFenceVideoPurchaseTCPEvent
    /// </summary>
    public class GeoFenceVideoPurchaseTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid, _bi_machine_puid; 
        private string _vc_reasoncode, _vc_ip_address, _vc_countrycode ;
        private Guid _ui_wmid;
        private int _i_videotype;
        
    
        public GeoFenceVideoPurchaseTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, string vc_reasoncode, long bi_machine_puid, long bi_user_puid, string vc_ip_address, string vc_countrycode, Guid ui_wmid, int i_videotype)
        {

            _bi_machine_puid = bi_machine_puid;
            _bi_user_puid = bi_user_puid;
            _vc_reasoncode = vc_reasoncode;
            _vc_ip_address = vc_ip_address;
            _vc_countrycode = vc_countrycode;
            _ui_wmid = ui_wmid;
            _i_videotype = i_videotype;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //GeoFenceVideoPurchase|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|wmid|videoType
            string logLine = string.Format("GeoFenceVideoPurchase|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _vc_reasoncode, _bi_user_puid, _bi_machine_puid, _vc_ip_address, _vc_countrycode, _ui_wmid,  _i_videotype);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// GeoFenceVideoAcquireURLTCPEvent
    /// </summary>
    public class GeoFenceVideoAcquireURLTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid, _bi_machine_puid; 
        private string _vc_reasoncode, _vc_ip_address, _vc_countrycode ;
        private Guid _ui_wmid;
        private int _i_videotype;
        
    
        public GeoFenceVideoAcquireURLTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, string vc_reasoncode, long bi_machine_puid, long bi_user_puid, string vc_ip_address, string vc_countrycode, Guid ui_wmid, int i_videotype)
        {

            _bi_machine_puid = bi_machine_puid;
            _bi_user_puid = bi_user_puid;
            _vc_reasoncode = vc_reasoncode;
            _vc_ip_address = vc_ip_address;
            _vc_countrycode = vc_countrycode;
            _ui_wmid = ui_wmid;
            _i_videotype = i_videotype;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //GeoFenceVideoAcquireURL|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|wmid|videoType
            string logLine = string.Format("GeoFenceVideoAcquireURL|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _vc_reasoncode, _bi_user_puid, _bi_machine_puid, _vc_ip_address, _vc_countrycode, _ui_wmid,  _i_videotype);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// GeoFenceVideoAcquireLicenseTCPEvent
    /// </summary>
    public class GeoFenceVideoAcquireLicenseTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid, _bi_machine_puid; 
        private string _vc_reasoncode, _vc_ip_address, _vc_countrycode ;
        private Guid _ui_wmid;
        private int _i_videotype;
        
    
        public GeoFenceVideoAcquireLicenseTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, string vc_reasoncode, long bi_machine_puid, long bi_user_puid, string vc_ip_address, string vc_countrycode, Guid ui_wmid, int i_videotype)
        {

            _bi_machine_puid = bi_machine_puid;
            _bi_user_puid = bi_user_puid;
            _vc_reasoncode = vc_reasoncode;
            _vc_ip_address = vc_ip_address;
            _vc_countrycode = vc_countrycode;
            _ui_wmid = ui_wmid;
            _i_videotype = i_videotype;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //GeoFenceVideoAcquireLicense|<reasonCode>|user_puid|machine_puid|user_ip|geoinfo_country|wmid|videoType
            string logLine = string.Format("GeoFenceVideoAcquireLicense|{0}|{1}|{2}|{3}|{4}|{5}|{6}",
                                                           _vc_reasoncode, _bi_user_puid, _bi_machine_puid, _vc_ip_address, _vc_countrycode, _ui_wmid,  _i_videotype);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// BannerViewAggTCPEvent
    /// </summary>
    public class BannerViewAggTCPEvent : CleanserTCPEvent
    {
        private long _bi_banner_counter; 
        private byte _ti_banner_type_id;
    
        public BannerViewAggTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID, long bi_banner_counter, byte ti_banner_type_id)
        {

            _bi_banner_counter = bi_banner_counter;
            _ti_banner_type_id = ti_banner_type_id;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LSA-BAN_VW|bannerID|count
            string logLine = string.Format("LSA-BAN_VW|{0}|{1}",
                                                           _ti_banner_type_id, _bi_banner_counter );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }


    /// <summary>
    /// BannerViewTCPEvent
    /// </summary>
    public class BannerViewTCPEvent : CleanserTCPEvent
    {
        private byte _ti_banner_type_id;
        private long _bi_user_puid; 
        private int _i_clienttimestamp; 
        private int _i_seqnum; 
    
        public BannerViewTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  byte ti_banner_type_id, long bi_user_puid, int i_clienttimestamp, int i_seqnum)
        {

            _ti_banner_type_id = ti_banner_type_id;
            _bi_user_puid = bi_user_puid;
            _i_clienttimestamp = i_clienttimestamp;
            _i_seqnum = i_seqnum;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LS-BAN_VW|bannerID|userPUID|clientTimestamp|sequenceNumber
            string logLine = string.Format("LS-BAN_VW|{0}|{1}|{2}|{3}",
                                                           _ti_banner_type_id, _bi_user_puid,  _i_clienttimestamp, _i_seqnum);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// BannerClickAggTCPEvent
    /// </summary>
    public class BannerClickAggTCPEvent : CleanserTCPEvent
    {
        private long _bi_banner_counter; 
        private byte _ti_banner_type_id;
    
        public BannerClickAggTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID, long bi_banner_counter, byte ti_banner_type_id)
        {

            _bi_banner_counter = bi_banner_counter;
            _ti_banner_type_id = ti_banner_type_id;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LSA-BAN_CL|bannerID|count
            string logLine = string.Format("LSA-BAN_CL|{0}|{1}",
                                                            _ti_banner_type_id, _bi_banner_counter );
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }


    /// <summary>
    /// BannerClickTCPEvent
    /// </summary>
    public class BannerClickTCPEvent : CleanserTCPEvent
    {
        private byte _ti_banner_type_id;
        private long _bi_user_puid; 
        private int _i_clienttimestamp; 
        private int _i_seqnum; 
    
        public BannerClickTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  byte ti_banner_type_id, long bi_user_puid, int i_clienttimestamp, int i_seqnum)
        {

            _ti_banner_type_id = ti_banner_type_id;
            _bi_user_puid = bi_user_puid;
            _i_clienttimestamp = i_clienttimestamp;
            _i_seqnum = i_seqnum;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LS-BAN_CL|bannerID|userPUID|clientTimestamp|sequenceNumber
            string logLine = string.Format("LS-BAN_CL|{0}|{1}|{2}|{3}",
                                                           _ti_banner_type_id, _bi_user_puid,  _i_clienttimestamp, _i_seqnum);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// BannerPurchaseTCPEvent
    /// </summary>
    public class BannerPurchaseTCPEvent : CleanserTCPEvent
    {
        private byte _ti_banner_type_id;
        private long _bi_offer_id; 
        private long _bi_user_puid; 
        private int _i_clienttimestamp; 
   
        public BannerPurchaseTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  byte ti_banner_type_id, long bi_offer_id, long bi_user_puid, int i_clienttimestamp)
        {

            _ti_banner_type_id = ti_banner_type_id;
            _bi_user_puid = bi_user_puid;
            _i_clienttimestamp = i_clienttimestamp;
            _bi_offer_id = bi_offer_id;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LS-MP_P|bannerID|offerID|userPUID|clientTimestamp
            string logLine = string.Format("LS-MP_P|{0}|{1}|{2}|{3}",
                                                           _ti_banner_type_id, _bi_offer_id, _bi_user_puid,  _i_clienttimestamp);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// BannerPurchaseAggTCPEvent
    /// </summary>
    public class BannerPurchaseAggTCPEvent : CleanserTCPEvent
    {
        private byte _ti_banner_type_id;
        private long _bi_offer_id; 
        private int _i_count; 
   
        public BannerPurchaseAggTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  byte ti_banner_type_id, long bi_offer_id,  int i_count)
        {

            _ti_banner_type_id = ti_banner_type_id;
            _i_count = i_count;
            _bi_offer_id = bi_offer_id;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LSA-MP_P|bannerID|offerID|count
            string logLine = string.Format("LSA-MP_P|{0}|{1}|{2}",
                                                           _ti_banner_type_id, _bi_offer_id, _i_count);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }


    /// <summary>
    /// FusionTCPEvent
    /// </summary>
    public class FusionTCPEvent : CleanserTCPEvent
    {
        private int _i_title_id;
        private int _i_hr; 
        private long _bi_user_puid; 
        private int _i_clienttimestamp; 
   
        public FusionTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  int i_title_id, int i_hr, long bi_user_puid, int i_clienttimestamp)
        {

            _i_title_id = i_title_id;
            _bi_user_puid = bi_user_puid;
            _i_clienttimestamp = i_clienttimestamp;
            _i_hr = i_hr;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LS-FU|TitleID|hr|userPuid|clientTimestamp
            string logLine = string.Format("LS-FU|{0}|{1}|{2}|{3}",
                                                           _i_title_id, _i_hr, _bi_user_puid,  _i_clienttimestamp);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// FusionAggTCPEvent
    /// </summary>
    public class FusionAggTCPEvent : CleanserTCPEvent
    {
        private int _i_title_id;
        private int _i_hr; 
        private long _bi_count; 
   
        public FusionAggTCPEvent()
        {
            _componentID = 8; // xonline.server.stringsvr;
        }
        
        public void SendLogLine(int serverID,  int i_title_id, int i_hr, long bi_count)
        {

            _i_title_id = i_title_id;
            _bi_count = bi_count;
            _i_hr = i_hr;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //LSA-FU|TitleID|hr|count
            string logLine = string.Format("LS-FU|{0}|{1}|{2}",
                                                           _i_title_id, _i_hr, _bi_count);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }
        
    /// <summary>
    /// LicenseTCPEvent
    /// </summary>
    public class LicenseTCPEvent : CleanserTCPEvent
    {
        private int _i_clienttimestamp; 
        private Guid _ui_wmid;
        private long  _bi_owner_machine_puid; 
        private long  _bi_current_machine_puid; 
        private long _bi_user_puid; 
        
    
        public LicenseTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID, int i_clienttimestamp, Guid ui_wmid, long bi_owner_machine_puid, long bi_current_machine_puid, long bi_user_puid)
        {

            _i_clienttimestamp = i_clienttimestamp;
            _ui_wmid = ui_wmid;
            _bi_owner_machine_puid = bi_owner_machine_puid;
            _bi_current_machine_puid = bi_current_machine_puid;
            _bi_user_puid = bi_user_puid;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //ARGOLICENSE|clientTimestamp|wmid|ownerMachinePUID|currentMachinePUID|userPUID
            string logLine = string.Format("ARGOLICENSE|{0}|{1}|{2}|{3}|{4}",
                                                           _i_clienttimestamp, _ui_wmid, _bi_owner_machine_puid, _bi_current_machine_puid, _bi_user_puid);
            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
    /// PurchaseOfferTCPEvent
    /// </summary>
    public class PurchaseOfferTCPEvent : CleanserTCPEvent
    {
        private long _bi_user_puid; 
        private long _bi_machine_puid; 
        private string _vc_ip_address; 
        private int _i_pmt_type; 
        private Guid _ui_offerinstance_id;
        private int  _i_mediatype_id; 
        private int  _i_retail_price_points; 
        private int  _i_retail_price_usd; 
        private Guid _ui_promotion_id;
        private int _i_pricing_rule_id; 
        
    
        public PurchaseOfferTCPEvent()
        {
            _componentID = 6; // Component.xpserver;
        }
        
        public void SendLogLine(int serverID,
                                                long	biuserpuid	,
                                                long	bimachinepuid	,
                                                string	vcipaddress	,
                                                int	ipmttype	,
                                                Guid	uiofferinstanceid	,
                                                int	imediatypeid	,
                                                int	iretailpricepoints	,
                                                int	iretailpriceusd	,
                                                Guid	uipromotionid	,
                                                int	ipricingruleid
        )
        {
            _bi_user_puid	=	biuserpuid	;
            _bi_machine_puid	=	bimachinepuid	;
            _vc_ip_address	=	vcipaddress	;
            _i_pmt_type	=	ipmttype	;
            _ui_offerinstance_id	=	uiofferinstanceid	;
            _i_mediatype_id	=	imediatypeid	;
            _i_retail_price_points	=	iretailpricepoints	;
            _i_retail_price_usd	=	iretailpriceusd	;
            _ui_promotion_id	=	uipromotionid	;
            _i_pricing_rule_id	=	ipricingruleid	;

            SendLogLineInternal(serverID);
        }

        protected void SendLogLineInternal(int serverID)
        {
            ConnectToCleanser(serverID, _componentID);

            //PurchaseOffers|biuserpuid|bimachinepuid|vcipaddress|ipmttype|uiofferinstanceid|imediatypeid|iretailpricepoints|iretailpriceusd|uipromotionid|ipricingruleid
            string logLine = string.Format("PurchaseOffers|{0}|{1}|'{2}'|{3}|{4}||{5}|{6}|{7}|{8}|{9}"
                                                           , _bi_user_puid, _bi_machine_puid, _vc_ip_address, _i_pmt_type, _ui_offerinstance_id, _i_mediatype_id, _i_retail_price_points
                                                           , _i_retail_price_usd,_ui_promotion_id, _i_pricing_rule_id);

            SendMessage(serverID, _componentID, logLine);

            DisconnectFromCleanser(serverID);
        }

    }

    /// <summary>
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\CdbVideoProcessing_SSIS.cs ===
using System;
using System.Collections.Specialized;

using ServerTestFramework.Utilities;
using ServerTestFramework.STFLive;

using xonline.common.config;
using ServerTestFramework.STFLive.Database;
namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the SSIS Cdb Video Processing job
    /// </summary>
    public class CdbVideoProcessing_SSIS : SSISJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public CdbVideoProcessing_SSIS()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public CdbVideoProcessing_SSIS(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }
        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingSSISDB.ComponentName;

            m_JobName = @"ReportSSISDB:Cdb_VideoProcessing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.SSIS_CdbVideoProcessing;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";       

            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class CdbVideoProcessing_SSIS_Params : ReportingJobParameters
        {
            // Enter any parameters here..
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailyProcessing_GameUsage.cs ===
using System;
using System.Collections.Specialized;
using System.Data.SqlClient;

using ServerTestFramework.STFLive.Database;
namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the Game Usage Daily Processing job
    /// </summary>
    public class DailyProcessing_GameUsage : ReportingJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailyProcessing_GameUsage()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailyProcessing_GameUsage(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }

        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_JobName = @"Daily Processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.ReportingDB_GameUsageDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_ServerName = ReportingCommon.Instance.ReportingDB.ComponentName;
            
            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

        /// <summary>
        /// Execute the job. If the job contains a valid parameter object then it will create
        /// the SQL to run the stored procedure for Game Usage Daily Processing
        /// </summary>
        /// <returns></returns>
        public override string RunJob()
        {            
            string retVal = "";

            // Check for parameters
            if (m_Parameters != null)
            {
                // Verify parameter is valid for this job
                if (m_Parameters is DailyProcessing_GameUsage_Params)
                {
                    DailyProcessing_GameUsage_Params temp = (DailyProcessing_GameUsage_Params)m_Parameters;
                    // Check for the Flag for default job execution
                    if (!temp.UseDefaultJob)
                    {
                        // Construct the query
                        return retVal = "exec p_Daily_Processing '" + temp.StartDate.ToShortDateString() + "', '" +
                            temp.EndDate.ToShortDateString() + "', " + temp.Wait_FDB + ", " + temp.Wait_UODB + ", " +
                            temp.Add_Missing_Dim_Data + ", " + temp.Force_Run + ", " + temp.Remove_Invalid_Facts;
                    }
                }
            }                                  

            return base.RunJob();
        }

        /// <summary>
        /// Update Job status
        /// </summary>
        public override void UpdateStatus()
        {
            // Use base object update method if flagged
            if (Parameters.UseDefaultJob)
            {
                base.UpdateStatus();
            }
            else
            {
                
                SqlDataReader reader = null; DateTime tempDt; 
                SqlCommand sqlCmd = new SqlCommand();
                
                ReportingCommon rcommon = ReportingCommon.Instance;

                // Update job status through SQL Queries
                string vc_Area = "GameUsage"; int tempIDate = 0;
                tempDt = ((DailyProcessing_GameUsage_Params)m_Parameters).StartDate;

                tempIDate = tempDt.Year * 10000 + tempDt.Month * 100 + tempDt.Day;
                // Construct the sql string to verify job execution status
                
                sqlCmd.Connection = new SqlConnection("server=" + rcommon.ReportingDB.ComponentName + ";database=" + rcommon.ReportingDB.DatabaseName +  ";Integrated Security=SSPI");
                sqlCmd.Connection.Open();
                sqlCmd.CommandText = "Select * from t_daily_processing_component_status where i_Date = " +
                   tempIDate.ToString() + " AND vc_area = '" + vc_Area + "' AND vc_component = 'ALL'";

                try
                {
                    // Execute sql against Reporting database
                    reader = sqlCmd.ExecuteReader();
                    while (reader.Read() && reader.HasRows)
                    {
                        // Verify if the job completed successfully
                        // RUN STATUS 2 = SUCCESS, 0 = FAILED
                        if (reader.GetBoolean(reader.GetOrdinal("b_executed")) == true)
                        {
                            m_Completed = true;
                            if (reader.GetBoolean(reader.GetOrdinal("b_success")) == true)
                            {
                                m_HResult = ReportingJobStatus.Completed;
                                m_Results = "JOB COMPLETED SUCCESSFULLY";
                            }
                            else
                            {
                                m_HResult = ReportingJobStatus.Failed;
                                m_Results = "DAILY PROCESSING FAILED";
                            }
                            m_StartTime = (DateTime)reader.GetValue(reader.GetOrdinal("dt_start"));
                            m_RunningTime = (TimeSpan)((DateTime)reader.GetValue(reader.GetOrdinal("dt_end")) - m_StartTime);
                        }
                        else
                        {
                            m_RunningTime = DateTime.Now.Subtract(m_StartTime);
                        }

                    }// while reader.Read
                }
                catch (Exception Exce)
                {
                    // Fail Job and log exception message
                    m_HResult = ReportingJobStatus.Failed;
                    m_Results = Exce.Message;
                    m_RunningTime = TimeSpan.FromDays(0.0f);
                    Completed = true;
                }
                reader.Close();
                sqlCmd.Connection.Close();         
            }// If not default job         
        }//UpdateStatus()




       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailyProcessing_GameUsage_Params : ReportingJobParameters
        {            
            private DateTime m_StartDate;   // Daily Processing Start Date
            public DateTime StartDate
            {
                get
                {
                    return m_StartDate;
                }
                set
                {                    
                    // Assign the Start Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_StartDate = value;
                }
            }
            
            // Set flag to use default job
            public override bool UseDefaultJob
            {
                get
                {
                    return m_UseDefaultJob;
                }
                set
                {
                    m_UseDefaultJob = value;
                }
            }

            private DateTime m_EndDate;     // Daily Processing End Date
            public DateTime EndDate
            {
                get
                {
                    return m_EndDate;
                }
                set
                {
                    // Assign the End Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_EndDate = value;
                }
            }

            public int Wait_FDB = 1;                    // Wait for FilterDB replication in minutes
            public int Wait_UODB = 1;                   // Wait for UODB replication in minutes
            public short Add_Missing_Dim_Data=0;        // True to add any missing Dim Data during Prescan
            public short Force_Run=0;                   // True to bypass any date checks. NOTE: There must be an entry in v_fdb_time in order for Transfer data to work
            public short Remove_Invalid_Facts = 0;      // True to remove invalid facts during Prescan

            public DailyProcessing_GameUsage_Params()
            {
                m_StartDate = new DateTime();
                m_StartDate = DateTime.Now;
                m_EndDate = new DateTime();
                m_EndDate = DateTime.Now.AddDays(1);                
            }

            // Specify a function to determine equal job parameters
            public override bool Equals(ReportingJobParameters obj)
            {
                bool equal = false;
                DailyProcessing_GameUsage_Params temp;
                // Check if is the same param type
                if (obj is DailyProcessing_GameUsage_Params)
                {
                    temp = (DailyProcessing_GameUsage_Params)obj;
                    // Check if main parameter values match
                    if ((m_StartDate.ToShortDateString() == temp.StartDate.ToShortDateString()) &&
                        (m_EndDate.ToShortDateString() == temp.EndDate.ToShortDateString()))
                    {
                        equal = true;
                    }
                }
                return equal;
            }
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailySSAS_AchievementsProcessing.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the OLAP ACHIEVEMENT CUBE daily processing job
    /// </summary>
    public class DailySSAS_AchievementsProcessing : OlapJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailySSAS_AchievementsProcessing()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailySSAS_AchievementsProcessing(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);           
        }
        
        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingOLAPDB.ComponentName;

            m_JobName = @"Daily SSAS Achievements processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.OlapDB_SSASAchievementsDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_OlapDatabaseName = "OlapAchievements";
            m_ProcessXMLFile = "ProcessOlapAchievements.xml";
            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailySSAS_AchievementProcessing_Params : OlapJobParameters
        {
            // Enter any parameters here..
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailySSAS_CDBCruxUsageProcessing.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the OLAP CDB CRUXUSAGE CUBE daily processing job
    /// </summary>
    public class DailySSAS_CDBCruxUsageProcessing : OlapJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailySSAS_CDBCruxUsageProcessing()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailySSAS_CDBCruxUsageProcessing(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);

        }

        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingOLAPDB.ComponentName;

            m_JobName = @"Daily SSAS CdbCruxUsage processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.OlapDB_SSASCDBCruxUsageDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_OlapDatabaseName = "OlapCdbCruxUsage";
            m_ProcessXMLFile = "ProcessOlapCdbCruxUsage.xml";
            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailySSAS_CDBCruxUsageProcessing_Params : OlapJobParameters
        {
            // Enter any parameters here..
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailyProcessing_Crux.cs ===
using System;
using System.Collections.Specialized;
using System.Data.SqlClient;

using ServerTestFramework.STFLive.Database;
namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the ReportingDB Daily Processing Crux job
    /// </summary>
    public class DailyProcessing_Crux : ReportingJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailyProcessing_Crux()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailyProcessing_Crux(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }

        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_JobName = @"Daily Processing Crux";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.ReportingDB_ArgoUsageDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_ServerName = ReportingCommon.Instance.ReportingDB.ComponentName;

            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

        /// <summary>
        /// Execute the job. If the job contains a valid parameter object then it will create
        /// the SQL to run the stored procedure for Daily Processing Crux.
        /// </summary>
        /// <returns></returns>
        public override string RunJob()
        {          
            string retVal = "";
            
            // Check for parameters
            if (m_Parameters != null)
            {
                // Verify parameter is valid for this job
                if (m_Parameters is DailyProcessing_Crux_Params)
                {
                    DailyProcessing_Crux_Params temp = (DailyProcessing_Crux_Params)m_Parameters;
                    // Check for the special code for default parameters                    
                    if (!temp.UseDefaultJob)
                    {
                        // Construct the query
                        return retVal = "exec p_Daily_Processing_Crux '" + temp.StartDate.ToShortDateString() + "', '" +
                        temp.EndDate.ToShortDateString() + "', " + temp.Wait_FDB + ", " + temp.Wait_UODB + ", " +
                        temp.Wait_Pending + ", " + temp.Fix_Prescan + ", " + temp.Force_Run;
                    }
                }
            }
            
            return base.RunJob();
        }


        /// <summary>
        /// Update Job status
        /// </summary>
        public override void UpdateStatus()
        {
            // Use base object update method if flagged
            if (Parameters.UseDefaultJob)
            {
                base.UpdateStatus();
            }
            else
            {
                SqlDataReader reader = null; DateTime tempDt;
                SqlCommand sqlCmd = new SqlCommand();

                ReportingCommon rcommon = ReportingCommon.Instance;

                // Update job status through SQL Queries
                string vc_Area = "Crux"; int tempIDate = 0;
                tempDt = ((DailyProcessing_Crux_Params)m_Parameters).StartDate;

                tempIDate = tempDt.Year * 10000 + tempDt.Month * 100 + tempDt.Day;
                // Construct the sql string to verify job execution status

                sqlCmd.Connection = new SqlConnection("server=" + rcommon.ReportingDB.ComponentName + ";database=" + rcommon.ReportingDB.DatabaseName + ";Integrated Security=SSPI");
                sqlCmd.Connection.Open();
                sqlCmd.CommandText = "Select * from t_daily_processing_component_status where i_Date = " +
                   tempIDate.ToString() + " AND vc_area = '" + vc_Area + "' AND vc_component = 'ALL'";

                try
                {
                    // Execute sql against Reporting database
                    reader = sqlCmd.ExecuteReader();
                    while (reader.Read() && reader.HasRows)
                    {
                        // Verify if the job completed successfully
                        // RUN STATUS 2 = SUCCESS, 0 = FAILED
                        if (reader.GetBoolean(reader.GetOrdinal("b_executed")) == true)
                        {
                            m_Completed = true;
                            if (reader.GetBoolean(reader.GetOrdinal("b_success")) == true)
                            {
                                m_HResult = ReportingJobStatus.Completed;
                                m_Results = "JOB COMPLETED SUCCESSFULLY";
                            }
                            else
                            {
                                m_HResult = ReportingJobStatus.Failed;
                                m_Results = "DAILY PROCESSING FAILED";
                            }
                            m_StartTime = (DateTime)reader.GetValue(reader.GetOrdinal("dt_start"));
                            m_RunningTime = (TimeSpan)((DateTime)reader.GetValue(reader.GetOrdinal("dt_end")) - m_StartTime);
                        }
                        else
                        {
                            m_RunningTime = DateTime.Now.Subtract(m_StartTime);
                        }

                    }// while Reader.Read()
                }
                catch (Exception Exce)
                {
                    // Fail Job and log exception message
                    m_HResult = ReportingJobStatus.Failed;
                    m_Results = Exce.Message;
                    m_RunningTime = TimeSpan.FromDays(0.0f);
                    Completed = true;
                }
                reader.Close();
                sqlCmd.Connection.Close();
            }// If not default job         
        }//UpdateStatus()





        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailyProcessing_Crux_Params : ReportingJobParameters
        {
            private DateTime m_StartDate;   // Daily Processing Start Date
            public DateTime StartDate
            {
                get
                {
                    return m_StartDate;
                }
                set
                {
                    // Assign the Start Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_StartDate = value;
                }
            }

            // Set flag to use default job
            public override bool UseDefaultJob
            {
                get
                {
                    return m_UseDefaultJob;
                }
                set
                {
                    m_UseDefaultJob = value;
                }
            }


            private DateTime m_EndDate;     // Daily Processing End Date
            public DateTime EndDate
            {
                get
                {
                    return m_EndDate;
                }
                set
                {
                    // Assign the End Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_EndDate = value;
                }
            }

            public int Wait_FDB = 1;               // Wait for FilterDB replication in minutes
            public int Wait_UODB = 1;              // Wait for UODB replication in minutes
            public int Wait_Pending = 1;           // Wait for any pending transactions
            public short Fix_Prescan = 0;       // True to fix invalid facts during Prescan
            public short Force_Run = 0;         // True to bypass any date checks. NOTE: There must be an entry in v_fdb_time in order for Transfer data to work            

            public DailyProcessing_Crux_Params()
            {
                m_StartDate = new DateTime();
                m_StartDate = DateTime.Now;
                m_EndDate = new DateTime();
                m_EndDate = DateTime.Now.AddDays(1);                                
            }

            // Specify a function to determine equal job parameters
            public override bool Equals(ReportingJobParameters obj)
            {
                bool equal = false;
                DailyProcessing_Crux_Params temp;
                // Check if is the same param type
                if (obj is DailyProcessing_Crux_Params)
                {
                    temp = (DailyProcessing_Crux_Params) obj;
                    // Check if main parameter values match
                    if((m_StartDate.ToShortDateString() == temp.StartDate.ToShortDateString()) &&
                        (m_EndDate.ToShortDateString() == temp.EndDate.ToShortDateString()))
                    {
                        equal = true;
                    }

                }
                return equal;
            }
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailySSAS_CruxUsageProcessing.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the OLAP CRUXUSAGE CUBE daily processing job
    /// </summary>
    public class DailySSAS_CruxUsageProcessing : OlapJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailySSAS_CruxUsageProcessing()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailySSAS_CruxUsageProcessing(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);

        }

        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingOLAPDB.ComponentName;

            m_JobName = @"Daily SSAS CruxUsage processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.OlapDB_SSASCruxUsageDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_OlapDatabaseName = "OlapCruxUsage";
            m_ProcessXMLFile = "ProcessOlapCruxUsage.xml";
            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailySSAS_CruxUsageProcessing_Params : OlapJobParameters
        {
            // Enter any parameters here..
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailySSAS_VideoCubeProcessing.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the OLAP CDB CRUXUSAGE CUBE daily processing job
    /// </summary>
    public class DailySSAS_VideoCubeProcessing : OlapJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailySSAS_VideoCubeProcessing()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailySSAS_VideoCubeProcessing(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);

        }

        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingOLAPDB.ComponentName;

            m_JobName = @"Daily SSAS VideoCube processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.OlapDB_SSASVideoCubeDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";
            m_OlapDatabaseName = "VideoCube";
            m_ProcessXMLFile = "ProcessOlapVideoCube.xml";
            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailySSAS_VideoCubeProcessing_Params : OlapJobParameters
        {
            // Enter any parameters here..
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\FilterDB_PurgeFactTables.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;
namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the FilterDB:Purge Fact Tables job
    /// </summary>
    public class FilterDB_PurgeFactTables : ReportingJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public FilterDB_PurgeFactTables()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public FilterDB_PurgeFactTables(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }
        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_JobName = @"Fitlerdb: Purge fact tables";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.FilterDB_Purge;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";

            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class FilterDB_PurgeFactTables_Params : ReportingJobParameters
        {
            // Enter any parameters here..
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\DailySSAS_GameUsageProcessing.cs ===
using System;
using System.Collections.Specialized;
using ServerTestFramework.STFLive.Database;

using xonline.common.config;

namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// This is the OLAP GAMEUSAGE CUBE daily processing job
    /// </summary>
    public class DailySSAS_GameUsageProcessing : OlapJob
    {        

        /// <summary>
        /// Default Constructor
        /// </summary>
        public DailySSAS_GameUsageProcessing()
        {
            Initialize(null);
        }
        
        /// <summary>
        /// Reporting Constructor with Job Parameters
        /// </summary>
        public DailySSAS_GameUsageProcessing(ReportingJobParameters reportingJobParams)
        {
            Initialize(reportingJobParams);
        }
        /// <summary>
        /// Initialize Job with parameters if provided
        /// </summary>
        /// <param name="reportingJobParams">Job Parameters</param>
        private void Initialize(ReportingJobParameters reportingJobParams)
        {
            m_ServerName = ReportingCommon.Instance.ReportingOLAPDB.ComponentName;

            m_JobName = @"Daily SSAS GameUsage processing";
            m_JobSteps = new NameValueCollection(1);
            m_JobType = ReportingJobType.OlapDB_SSASGameUsageDaily;
            // Set Default Values
            m_Completed = false;
            m_HResult = ReportingJobStatus.Idle;
            m_Results = @"Job not executed yet";                        
            m_OlapDatabaseName = "OlapRdb";
            m_ProcessXMLFile = "ProcessOlapGameUsage.xml";

            if (reportingJobParams != null)
            {
                m_Parameters = reportingJobParams;
            }
        }

       

        /// <summary>
        /// Job parameters specific to this job
        /// </summary>
        public class DailySSAS_GameUsageProcessing_Params : OlapJobParameters
        {
            // Enter any parameters here..
        }
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\Jobs\OlapJob.cs ===
using System;
using System.IO;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;

using Microsoft.AnalysisServices;
using Microsoft.SqlServer.Management.Smo;

using ServerTestFramework.STFLive.Database;
using xonline.common.mgmt;
using xonline.common.config;


namespace ServerTestFramework.STFLive.Reporting
{
    /// <summary>
    /// OlapJob. From here the SSAS processing jobs will be derived.
    /// </summary>
    public class OlapJob : ReportingJob
    {
        new public static Report Log = new Report("OlapJob");
        
        protected string m_OlapDatabaseName = "UNKNOWN";    // Cube Database Name
        protected string m_ProcessXMLFile = "UNKNOWN";      // Cube XML processing file for OlapAutoBuild

        // Constructor
        public OlapJob()
        {
            // Initialize parameters to default
            m_Parameters = new OlapJobParameters();            
        }
        
        /// <summary>
        /// Run job. If no parameters are set then default job will be executed.
        /// </summary>
        /// <returns></returns>
        public override string RunJob()
        {
            string retVal = "", tempName = "";
            ReportingCommon rcommon = ReportingCommon.Instance;            

            OlapJobParameters temp;
            if((Parameters.UseDefaultJob) || !(Parameters is OlapJobParameters))
            {
                return base.RunJob();
            }
            else
            {
                // Cast parameters
                temp = (OlapJobParameters)m_Parameters;
                
                // Process SSAS database fully
                if (temp.ProcessFull)
                {
                    // Mark as starting
                    m_StartTime = DateTime.Now;
                    m_HResult = ReportingJobStatus.Running;
                    m_Results = "STARTING JOB";
                    m_Completed = false;

                    // Process
                    ((OLAPDB)rcommon.ReportingOLAPDB).SSASServer.Databases.FindByName(m_OlapDatabaseName).Process(ProcessType.ProcessFull);                 
                }
                else // Create a new temporary job to process the cube partially
                {
                    // Get Server Object
                    Microsoft.SqlServer.Management.Smo.Server sqlServer;
                    // Get JobServer
                    Microsoft.SqlServer.Management.Smo.Agent.JobServer jobServer;
                    // Job Object
                    Microsoft.SqlServer.Management.Smo.Agent.Job tempJob;

                    // Connect to that server
                    sqlServer = new Microsoft.SqlServer.Management.Smo.Server(rcommon.ReportingOLAPDB.ComponentName);
                    jobServer = sqlServer.JobServer;
                    
                    // Delete any previous temp jobs
                    tempName = "TestOlapProcessing_" + m_JobName;
                    if(jobServer.Jobs.Contains(tempName))
                    {
                        tempJob = jobServer.Jobs[tempName];
                        tempJob.Drop(); tempJob = null;
                    }

                    // Create Job
                    tempJob = new Microsoft.SqlServer.Management.Smo.Agent.Job(jobServer, tempName);
                    tempJob.Create();
                    
                    // Add Job Step
                    Microsoft.SqlServer.Management.Smo.Agent.JobStep tempStep = new Microsoft.SqlServer.Management.Smo.Agent.JobStep(tempJob, "Run OlapAutoBuild with Test Parameters");
                    // Create Olap processing command
                    tempStep.Command = Config.GetSetting("setup_approot") + "\\Olap\\OlapAutoBuild.exe /verbose:yes /xml:" + 
                            m_ProcessXMLFile + " /from:" + temp.StartDate.ToShortDateString() + 
                            " /to:" + temp.EndDate.ToShortDateString();
                    tempStep.OnSuccessAction = Microsoft.SqlServer.Management.Smo.Agent.StepCompletionAction.QuitWithSuccess;
                    tempStep.OnFailAction = Microsoft.SqlServer.Management.Smo.Agent.StepCompletionAction.QuitWithFailure;
                    tempStep.SubSystem = Microsoft.SqlServer.Management.Smo.Agent.AgentSubSystem.CmdExec;
                                        
                    // Create Step
                    tempStep.Create();
                    tempJob.ApplyToTargetServer(rcommon.ReportingOLAPDB.ComponentName);                                        
                    tempJob.Initialize();
                    jobServer.Refresh();
                                        
                    // Execute the new job
                    tempJob.Start();                  

                    m_HResult = ReportingJobStatus.Running;
                    m_Results = "STARTING JOB";
                    m_StartTime = DateTime.Now;
                    m_Completed = false;                                        
                }

            }//If not default job
            return retVal;
        }//RunJob()

        /// <summary>
        /// Update Olap Job Status
        /// </summary>
        public override void UpdateStatus()
        {
            ReportingCommon rcommon = ReportingCommon.Instance;            

            OlapJobParameters temp;
            if ((Parameters.UseDefaultJob) || !(Parameters is OlapJobParameters))
            {
                base.UpdateStatus();
            }
            else
            {
                // Cast parameters
                temp = (OlapJobParameters)m_Parameters;

                // if Process SSAS database fully
                if (temp.ProcessFull)
                {
                    m_HResult = ReportingJobStatus.Failed;
                    m_Completed = false;
                    // Connect to olap server/db and check state
                    switch (((OLAPDB)rcommon.ReportingOLAPDB).SSASServer.Databases.FindByName(m_OlapDatabaseName).State)
                    {
                        case AnalysisState.Processed:                            
                            m_Results = "Success: Olap Cube has been processed.";
                            m_HResult = ReportingJobStatus.Completed;
                            m_Completed = true;
                            break;

                        case AnalysisState.PartiallyProcessed:                            
                            m_Results ="Olap has been only partially processed.";
                            m_HResult = ReportingJobStatus.Running;
                            break;

                        case AnalysisState.Unprocessed:                            
                            m_Results = "ERROR: Olap has NOT been processed.";
                            m_Completed = true;
                            break;

                        default:                            
                            m_Results = "ERROR: Olap is in unknown state.";                            
                            m_Completed = true;
                            break;
                    }                                                            
                    m_RunningTime = DateTime.Now.Subtract(m_StartTime);
                    
                }
                else// if Process SSAS database partially
                {
                    // Change job name to temporary jobName
                    string tempName = m_JobName;
                    m_JobName = "TestOlapProcessing_" + tempName;
                    base.UpdateStatus();
                    m_JobName = tempName;
                }
            }
        }//UpdateStatus()



        /// <summary>
        /// Parameters for Olap Cube processing jobs
        /// Default settings are for regular job to run
        /// </summary>
        public class OlapJobParameters : ReportingJobParameters
        {                        
            private DateTime m_StartDate;   // SSAS Processing Start Date
            public DateTime StartDate
            {
                get
                {
                    return m_StartDate;
                }
                set
                {
                    // Assign the Start Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_StartDate = value;
                }
            }            

            private DateTime m_EndDate;     // SSAS Processing End Date
            public DateTime EndDate
            {
                get
                {
                    return m_EndDate;
                }
                set
                {
                    // Assign the End Date ** Note that we don't check for valid date to allow
                    // invalid dates for negative test cases
                    m_EndDate = value;
                }
            }

            // Set flag to use default job
            public override bool UseDefaultJob
            {
                get
                {
                    return m_UseDefaultJob;
                }
                set
                {
                    m_UseDefaultJob = value;
                }
            }
            // Process SSAS Cube fully
            public bool ProcessFull;

            // Constructor
            public OlapJobParameters()
            {                
                ProcessFull = false;
                m_UseDefaultJob = true;
            }



        }//class OlapJobParameters




    }//class OlapJob

    /// <summary>
    /// OlapFullProcessGameUsageJob
    /// </summary>
    public class OlapFullProcessGameUsageJob : OlapJob
    {
        private Microsoft.AnalysisServices.Server _olapServer;
        private Microsoft.AnalysisServices.Database _olapDb;
    
        public OlapFullProcessGameUsageJob()
        {
            _olapServer = new Microsoft.AnalysisServices.Server();
            _olapDb = new Microsoft.AnalysisServices.Database();
        }


        public override string RunJob()
        {
            return base.RunJob();
        }        

        public bool Run()
        {
            bool bReturn = false;
            string[] szOlapServers;
            IInterfaceInfo iiInfo;

            // Connect to olap server/db
            szOlapServers = Global.XEnv.GetServerListByInterface(Interface.olapGameUsage);
            iiInfo = Config.GetInterface( szOlapServers[0], Interface.olapGameUsage );

            _olapServer.Connect(szOlapServers[0]);
            _olapDb = _olapServer.Databases.FindByName(iiInfo.DBName);
            if (_olapDb == null)
            {
                throw new Exception("Unable to connect to OLAP database " + iiInfo.DBName + " on " + szOlapServers[0]);
            }

            // Run full process
            Log.Info("Olap full processing started.");
            _olapDb.Process(ProcessType.ProcessFull);
            Log.Info("Olap full processing ended.");

            switch(_olapDb.State)
            {
                case AnalysisState.Processed:
                    bReturn = true;
                    Log.Info("Olap has been processed.");
                    break;

                case AnalysisState.PartiallyProcessed:
                    bReturn = false;
                    Log.Warn("Olap has been olny partially processed.");
                    break;

                case AnalysisState.Unprocessed:
                    bReturn = false;
                    Log.Warn("Olap has NOT been processed.");
                    break;
                    
                default:
                    bReturn = false;
                    Log.Warn("Olap is in unknown state.");
                    break;
                    
            }

            return bReturn;
        }

    }

        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Reporting\ReportingService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
using ServerTestFramework.STFLive.Reporting;
namespace ServerTestFramework.STFLive.Reporting.Service
{
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ReportingServiceSoap", Namespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DataSourceDefinitionOrReference))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ExpirationDefinition))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RecurrencePattern))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ScheduleDefinitionOrReference))]
    public partial class ReportingService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private ServerInfoHeader serverInfoHeaderValueField;
        
        private System.Threading.SendOrPostCallback ListSecureMethodsOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateBatchOperationCompleted;
        
        private BatchHeader batchHeaderValueField;
        
        private System.Threading.SendOrPostCallback CancelBatchOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExecuteBatchOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSystemPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetSystemPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteItemOperationCompleted;
        
        private System.Threading.SendOrPostCallback MoveItemOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListChildrenOperationCompleted;
        
        private ItemNamespaceHeader itemNamespaceHeaderValueField;
        
        private System.Threading.SendOrPostCallback GetPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetItemTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateFolderOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateReportOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportDefinitionOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportDefinitionOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateResourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetResourceContentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetResourceContentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportParametersOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportParametersOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateLinkedReportOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportLinkOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportLinkOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListLinkedReportsOperationCompleted;
        
        private SessionHeader sessionHeaderValueField;
        
        private System.Threading.SendOrPostCallback RenderOperationCompleted;
        
        private System.Threading.SendOrPostCallback RenderStreamOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRenderResourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetExecutionOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExecutionOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetCacheOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCacheOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateReportExecutionSnapshotOperationCompleted;
        
        private System.Threading.SendOrPostCallback FlushCacheOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListJobsOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateDataSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDataSourceContentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetDataSourceContentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnableDataSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback DisableDataSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListReportsUsingDataSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportDataSourcesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportDataSourcesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportDataSourcePromptsOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateReportHistorySnapshotOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportHistoryOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportHistoryOptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetReportHistoryLimitOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReportHistoryLimitOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListReportHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteReportHistorySnapshotOperationCompleted;
        
        private System.Threading.SendOrPostCallback FindItemsOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateScheduleOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteScheduleOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetSchedulePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSchedulePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListScheduledReportsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListSchedulesOperationCompleted;
        
        private System.Threading.SendOrPostCallback PauseScheduleOperationCompleted;
        
        private System.Threading.SendOrPostCallback ResumeScheduleOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateSubscriptionOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateDataDrivenSubscriptionOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetSubscriptionPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetDataDrivenSubscriptionPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSubscriptionPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDataDrivenSubscriptionPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteSubscriptionOperationCompleted;
        
        private System.Threading.SendOrPostCallback PrepareQueryOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExtensionSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateExtensionSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListSubscriptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListSubscriptionsUsingDataSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListExtensionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListEventsOperationCompleted;
        
        private System.Threading.SendOrPostCallback FireEventOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListSystemTasksOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListTasksOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListSystemRolesOperationCompleted;
        
        private System.Threading.SendOrPostCallback ListRolesOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateRoleOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteRoleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRolePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetRolePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSystemPoliciesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetSystemPoliciesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPoliciesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetPoliciesOperationCompleted;
        
        private System.Threading.SendOrPostCallback InheritParentSecurityOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSystemPermissionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPermissionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LogonUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback LogoffOperationCompleted;
        
        /// <remarks/>

        /// Reporting Service constructor
        public ReportingService(string ReportUrl) {
            this.Url = "http://reports.test.xboxlive.com/ReportServer/ReportService.asmx";
            if(ReportUrl != null){
                this.Url = ReportUrl;
            }
            
        }
        
        public ServerInfoHeader ServerInfoHeaderValue {
            get {
                return this.serverInfoHeaderValueField;
            }
            set {
                this.serverInfoHeaderValueField = value;
            }
        }
        
        public BatchHeader BatchHeaderValue {
            get {
                return this.batchHeaderValueField;
            }
            set {
                this.batchHeaderValueField = value;
            }
        }
        
        public ItemNamespaceHeader ItemNamespaceHeaderValue {
            get {
                return this.itemNamespaceHeaderValueField;
            }
            set {
                this.itemNamespaceHeaderValueField = value;
            }
        }
        
        public SessionHeader SessionHeaderValue {
            get {
                return this.sessionHeaderValueField;
            }
            set {
                this.sessionHeaderValueField = value;
            }
        }
        
        /// <remarks/>
        public event ListSecureMethodsCompletedEventHandler ListSecureMethodsCompleted;
        
        /// <remarks/>
        public event CreateBatchCompletedEventHandler CreateBatchCompleted;
        
        /// <remarks/>
        public event CancelBatchCompletedEventHandler CancelBatchCompleted;
        
        /// <remarks/>
        public event ExecuteBatchCompletedEventHandler ExecuteBatchCompleted;
        
        /// <remarks/>
        public event GetSystemPropertiesCompletedEventHandler GetSystemPropertiesCompleted;
        
        /// <remarks/>
        public event SetSystemPropertiesCompletedEventHandler SetSystemPropertiesCompleted;
        
        /// <remarks/>
        public event DeleteItemCompletedEventHandler DeleteItemCompleted;
        
        /// <remarks/>
        public event MoveItemCompletedEventHandler MoveItemCompleted;
        
        /// <remarks/>
        public event ListChildrenCompletedEventHandler ListChildrenCompleted;
        
        /// <remarks/>
        public event GetPropertiesCompletedEventHandler GetPropertiesCompleted;
        
        /// <remarks/>
        public event SetPropertiesCompletedEventHandler SetPropertiesCompleted;
        
        /// <remarks/>
        public event GetItemTypeCompletedEventHandler GetItemTypeCompleted;
        
        /// <remarks/>
        public event CreateFolderCompletedEventHandler CreateFolderCompleted;
        
        /// <remarks/>
        public event CreateReportCompletedEventHandler CreateReportCompleted;
        
        /// <remarks/>
        public event GetReportDefinitionCompletedEventHandler GetReportDefinitionCompleted;
        
        /// <remarks/>
        public event SetReportDefinitionCompletedEventHandler SetReportDefinitionCompleted;
        
        /// <remarks/>
        public event CreateResourceCompletedEventHandler CreateResourceCompleted;
        
        /// <remarks/>
        public event SetResourceContentsCompletedEventHandler SetResourceContentsCompleted;
        
        /// <remarks/>
        public event GetResourceContentsCompletedEventHandler GetResourceContentsCompleted;
        
        /// <remarks/>
        public event GetReportParametersCompletedEventHandler GetReportParametersCompleted;
        
        /// <remarks/>
        public event SetReportParametersCompletedEventHandler SetReportParametersCompleted;
        
        /// <remarks/>
        public event CreateLinkedReportCompletedEventHandler CreateLinkedReportCompleted;
        
        /// <remarks/>
        public event GetReportLinkCompletedEventHandler GetReportLinkCompleted;
        
        /// <remarks/>
        public event SetReportLinkCompletedEventHandler SetReportLinkCompleted;
        
        /// <remarks/>
        public event ListLinkedReportsCompletedEventHandler ListLinkedReportsCompleted;
        
        /// <remarks/>
        public event RenderCompletedEventHandler RenderCompleted;
        
        /// <remarks/>
        public event RenderStreamCompletedEventHandler RenderStreamCompleted;
        
        /// <remarks/>
        public event GetRenderResourceCompletedEventHandler GetRenderResourceCompleted;
        
        /// <remarks/>
        public event SetExecutionOptionsCompletedEventHandler SetExecutionOptionsCompleted;
        
        /// <remarks/>
        public event GetExecutionOptionsCompletedEventHandler GetExecutionOptionsCompleted;
        
        /// <remarks/>
        public event SetCacheOptionsCompletedEventHandler SetCacheOptionsCompleted;
        
        /// <remarks/>
        public event GetCacheOptionsCompletedEventHandler GetCacheOptionsCompleted;
        
        /// <remarks/>
        public event UpdateReportExecutionSnapshotCompletedEventHandler UpdateReportExecutionSnapshotCompleted;
        
        /// <remarks/>
        public event FlushCacheCompletedEventHandler FlushCacheCompleted;
        
        /// <remarks/>
        public event ListJobsCompletedEventHandler ListJobsCompleted;
        
        /// <remarks/>
        public event CancelJobCompletedEventHandler CancelJobCompleted;
        
        /// <remarks/>
        public event CreateDataSourceCompletedEventHandler CreateDataSourceCompleted;
        
        /// <remarks/>
        public event GetDataSourceContentsCompletedEventHandler GetDataSourceContentsCompleted;
        
        /// <remarks/>
        public event SetDataSourceContentsCompletedEventHandler SetDataSourceContentsCompleted;
        
        /// <remarks/>
        public event EnableDataSourceCompletedEventHandler EnableDataSourceCompleted;
        
        /// <remarks/>
        public event DisableDataSourceCompletedEventHandler DisableDataSourceCompleted;
        
        /// <remarks/>
        public event ListReportsUsingDataSourceCompletedEventHandler ListReportsUsingDataSourceCompleted;
        
        /// <remarks/>
        public event SetReportDataSourcesCompletedEventHandler SetReportDataSourcesCompleted;
        
        /// <remarks/>
        public event GetReportDataSourcesCompletedEventHandler GetReportDataSourcesCompleted;
        
        /// <remarks/>
        public event GetReportDataSourcePromptsCompletedEventHandler GetReportDataSourcePromptsCompleted;
        
        /// <remarks/>
        public event CreateReportHistorySnapshotCompletedEventHandler CreateReportHistorySnapshotCompleted;
        
        /// <remarks/>
        public event SetReportHistoryOptionsCompletedEventHandler SetReportHistoryOptionsCompleted;
        
        /// <remarks/>
        public event GetReportHistoryOptionsCompletedEventHandler GetReportHistoryOptionsCompleted;
        
        /// <remarks/>
        public event SetReportHistoryLimitCompletedEventHandler SetReportHistoryLimitCompleted;
        
        /// <remarks/>
        public event GetReportHistoryLimitCompletedEventHandler GetReportHistoryLimitCompleted;
        
        /// <remarks/>
        public event ListReportHistoryCompletedEventHandler ListReportHistoryCompleted;
        
        /// <remarks/>
        public event DeleteReportHistorySnapshotCompletedEventHandler DeleteReportHistorySnapshotCompleted;
        
        /// <remarks/>
        public event FindItemsCompletedEventHandler FindItemsCompleted;
        
        /// <remarks/>
        public event CreateScheduleCompletedEventHandler CreateScheduleCompleted;
        
        /// <remarks/>
        public event DeleteScheduleCompletedEventHandler DeleteScheduleCompleted;
        
        /// <remarks/>
        public event SetSchedulePropertiesCompletedEventHandler SetSchedulePropertiesCompleted;
        
        /// <remarks/>
        public event GetSchedulePropertiesCompletedEventHandler GetSchedulePropertiesCompleted;
        
        /// <remarks/>
        public event ListScheduledReportsCompletedEventHandler ListScheduledReportsCompleted;
        
        /// <remarks/>
        public event ListSchedulesCompletedEventHandler ListSchedulesCompleted;
        
        /// <remarks/>
        public event PauseScheduleCompletedEventHandler PauseScheduleCompleted;
        
        /// <remarks/>
        public event ResumeScheduleCompletedEventHandler ResumeScheduleCompleted;
        
        /// <remarks/>
        public event CreateSubscriptionCompletedEventHandler CreateSubscriptionCompleted;
        
        /// <remarks/>
        public event CreateDataDrivenSubscriptionCompletedEventHandler CreateDataDrivenSubscriptionCompleted;
        
        /// <remarks/>
        public event SetSubscriptionPropertiesCompletedEventHandler SetSubscriptionPropertiesCompleted;
        
        /// <remarks/>
        public event SetDataDrivenSubscriptionPropertiesCompletedEventHandler SetDataDrivenSubscriptionPropertiesCompleted;
        
        /// <remarks/>
        public event GetSubscriptionPropertiesCompletedEventHandler GetSubscriptionPropertiesCompleted;
        
        /// <remarks/>
        public event GetDataDrivenSubscriptionPropertiesCompletedEventHandler GetDataDrivenSubscriptionPropertiesCompleted;
        
        /// <remarks/>
        public event DeleteSubscriptionCompletedEventHandler DeleteSubscriptionCompleted;
        
        /// <remarks/>
        public event PrepareQueryCompletedEventHandler PrepareQueryCompleted;
        
        /// <remarks/>
        public event GetExtensionSettingsCompletedEventHandler GetExtensionSettingsCompleted;
        
        /// <remarks/>
        public event ValidateExtensionSettingsCompletedEventHandler ValidateExtensionSettingsCompleted;
        
        /// <remarks/>
        public event ListSubscriptionsCompletedEventHandler ListSubscriptionsCompleted;
        
        /// <remarks/>
        public event ListSubscriptionsUsingDataSourceCompletedEventHandler ListSubscriptionsUsingDataSourceCompleted;
        
        /// <remarks/>
        public event ListExtensionsCompletedEventHandler ListExtensionsCompleted;
        
        /// <remarks/>
        public event ListEventsCompletedEventHandler ListEventsCompleted;
        
        /// <remarks/>
        public event FireEventCompletedEventHandler FireEventCompleted;
        
        /// <remarks/>
        public event ListSystemTasksCompletedEventHandler ListSystemTasksCompleted;
        
        /// <remarks/>
        public event ListTasksCompletedEventHandler ListTasksCompleted;
        
        /// <remarks/>
        public event ListSystemRolesCompletedEventHandler ListSystemRolesCompleted;
        
        /// <remarks/>
        public event ListRolesCompletedEventHandler ListRolesCompleted;
        
        /// <remarks/>
        public event CreateRoleCompletedEventHandler CreateRoleCompleted;
        
        /// <remarks/>
        public event DeleteRoleCompletedEventHandler DeleteRoleCompleted;
        
        /// <remarks/>
        public event GetRolePropertiesCompletedEventHandler GetRolePropertiesCompleted;
        
        /// <remarks/>
        public event SetRolePropertiesCompletedEventHandler SetRolePropertiesCompleted;
        
        /// <remarks/>
        public event GetSystemPoliciesCompletedEventHandler GetSystemPoliciesCompleted;
        
        /// <remarks/>
        public event SetSystemPoliciesCompletedEventHandler SetSystemPoliciesCompleted;
        
        /// <remarks/>
        public event GetPoliciesCompletedEventHandler GetPoliciesCompleted;
        
        /// <remarks/>
        public event SetPoliciesCompletedEventHandler SetPoliciesCompleted;
        
        /// <remarks/>
        public event InheritParentSecurityCompletedEventHandler InheritParentSecurityCompleted;
        
        /// <remarks/>
        public event GetSystemPermissionsCompletedEventHandler GetSystemPermissionsCompleted;
        
        /// <remarks/>
        public event GetPermissionsCompletedEventHandler GetPermissionsCompleted;
        
        /// <remarks/>
        public event LogonUserCompletedEventHandler LogonUserCompleted;
        
        /// <remarks/>
        public event LogoffCompletedEventHandler LogoffCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/ListSe" +
            "cureMethods", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] ListSecureMethods() {
            object[] results = this.Invoke("ListSecureMethods", new object[0]);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginListSecureMethods(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ListSecureMethods", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndListSecureMethods(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public void ListSecureMethodsAsync() {
            this.ListSecureMethodsAsync(null);
        }
        
        /// <remarks/>
        public void ListSecureMethodsAsync(object userState) {
            if ((this.ListSecureMethodsOperationCompleted == null)) {
                this.ListSecureMethodsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnListSecureMethodsOperationCompleted);
            }
            this.InvokeAsync("ListSecureMethods", new object[0], this.ListSecureMethodsOperationCompleted, userState);
        }
        
        private void OnListSecureMethodsOperationCompleted(object arg) {
            if ((this.ListSecureMethodsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ListSecureMethodsCompleted(this, new ListSecureMethodsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Create" +
            "Batch", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("BatchID")]
        public string CreateBatch() {
            object[] results = this.Invoke("CreateBatch", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateBatch(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateBatch", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCreateBatch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CreateBatchAsync() {
            this.CreateBatchAsync(null);
        }
        
        /// <remarks/>
        public void CreateBatchAsync(object userState) {
            if ((this.CreateBatchOperationCompleted == null)) {
                this.CreateBatchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateBatchOperationCompleted);
            }
            this.InvokeAsync("CreateBatch", new object[0], this.CreateBatchOperationCompleted, userState);
        }
        
        private void OnCreateBatchOperationCompleted(object arg) {
            if ((this.CreateBatchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateBatchCompleted(this, new CreateBatchCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Cancel" +
            "Batch", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CancelBatch() {
            this.Invoke("CancelBatch", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelBatch(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelBatch", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelBatch(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CancelBatchAsync() {
            this.CancelBatchAsync(null);
        }
        
        /// <remarks/>
        public void CancelBatchAsync(object userState) {
            if ((this.CancelBatchOperationCompleted == null)) {
                this.CancelBatchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelBatchOperationCompleted);
            }
            this.InvokeAsync("CancelBatch", new object[0], this.CancelBatchOperationCompleted, userState);
        }
        
        private void OnCancelBatchOperationCompleted(object arg) {
            if ((this.CancelBatchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelBatchCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Execut" +
            "eBatch", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ExecuteBatch() {
            this.Invoke("ExecuteBatch", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExecuteBatch(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExecuteBatch", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndExecuteBatch(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ExecuteBatchAsync() {
            this.ExecuteBatchAsync(null);
        }
        
        /// <remarks/>
        public void ExecuteBatchAsync(object userState) {
            if ((this.ExecuteBatchOperationCompleted == null)) {
                this.ExecuteBatchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExecuteBatchOperationCompleted);
            }
            this.InvokeAsync("ExecuteBatch", new object[0], this.ExecuteBatchOperationCompleted, userState);
        }
        
        private void OnExecuteBatchOperationCompleted(object arg) {
            if ((this.ExecuteBatchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExecuteBatchCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetSys" +
            "temProperties", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Values")]
        public Property[] GetSystemProperties(Property[] Properties) {
            object[] results = this.Invoke("GetSystemProperties", new object[] {
                        Properties});
            return ((Property[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSystemProperties(Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSystemProperties", new object[] {
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public Property[] EndGetSystemProperties(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Property[])(results[0]));
        }
        
        /// <remarks/>
        public void GetSystemPropertiesAsync(Property[] Properties) {
            this.GetSystemPropertiesAsync(Properties, null);
        }
        
        /// <remarks/>
        public void GetSystemPropertiesAsync(Property[] Properties, object userState) {
            if ((this.GetSystemPropertiesOperationCompleted == null)) {
                this.GetSystemPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSystemPropertiesOperationCompleted);
            }
            this.InvokeAsync("GetSystemProperties", new object[] {
                        Properties}, this.GetSystemPropertiesOperationCompleted, userState);
        }
        
        private void OnGetSystemPropertiesOperationCompleted(object arg) {
            if ((this.GetSystemPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSystemPropertiesCompleted(this, new GetSystemPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetSys" +
            "temProperties", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetSystemProperties(Property[] Properties) {
            this.Invoke("SetSystemProperties", new object[] {
                        Properties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetSystemProperties(Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetSystemProperties", new object[] {
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetSystemProperties(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetSystemPropertiesAsync(Property[] Properties) {
            this.SetSystemPropertiesAsync(Properties, null);
        }
        
        /// <remarks/>
        public void SetSystemPropertiesAsync(Property[] Properties, object userState) {
            if ((this.SetSystemPropertiesOperationCompleted == null)) {
                this.SetSystemPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetSystemPropertiesOperationCompleted);
            }
            this.InvokeAsync("SetSystemProperties", new object[] {
                        Properties}, this.SetSystemPropertiesOperationCompleted, userState);
        }
        
        private void OnSetSystemPropertiesOperationCompleted(object arg) {
            if ((this.SetSystemPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetSystemPropertiesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Delete" +
            "Item", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteItem(string Item) {
            this.Invoke("DeleteItem", new object[] {
                        Item});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteItem(string Item, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteItem", new object[] {
                        Item}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteItem(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteItemAsync(string Item) {
            this.DeleteItemAsync(Item, null);
        }
        
        /// <remarks/>
        public void DeleteItemAsync(string Item, object userState) {
            if ((this.DeleteItemOperationCompleted == null)) {
                this.DeleteItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteItemOperationCompleted);
            }
            this.InvokeAsync("DeleteItem", new object[] {
                        Item}, this.DeleteItemOperationCompleted, userState);
        }
        
        private void OnDeleteItemOperationCompleted(object arg) {
            if ((this.DeleteItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteItemCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/MoveIt" +
            "em", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void MoveItem(string Item, string Target) {
            this.Invoke("MoveItem", new object[] {
                        Item,
                        Target});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMoveItem(string Item, string Target, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MoveItem", new object[] {
                        Item,
                        Target}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndMoveItem(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void MoveItemAsync(string Item, string Target) {
            this.MoveItemAsync(Item, Target, null);
        }
        
        /// <remarks/>
        public void MoveItemAsync(string Item, string Target, object userState) {
            if ((this.MoveItemOperationCompleted == null)) {
                this.MoveItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMoveItemOperationCompleted);
            }
            this.InvokeAsync("MoveItem", new object[] {
                        Item,
                        Target}, this.MoveItemOperationCompleted, userState);
        }
        
        private void OnMoveItemOperationCompleted(object arg) {
            if ((this.MoveItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MoveItemCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/ListCh" +
            "ildren", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("CatalogItems")]
        public CatalogItem[] ListChildren(string Item, bool Recursive) {
            object[] results = this.Invoke("ListChildren", new object[] {
                        Item,
                        Recursive});
            return ((CatalogItem[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginListChildren(string Item, bool Recursive, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ListChildren", new object[] {
                        Item,
                        Recursive}, callback, asyncState);
        }
        
        /// <remarks/>
        public CatalogItem[] EndListChildren(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CatalogItem[])(results[0]));
        }
        
        /// <remarks/>
        public void ListChildrenAsync(string Item, bool Recursive) {
            this.ListChildrenAsync(Item, Recursive, null);
        }
        
        /// <remarks/>
        public void ListChildrenAsync(string Item, bool Recursive, object userState) {
            if ((this.ListChildrenOperationCompleted == null)) {
                this.ListChildrenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnListChildrenOperationCompleted);
            }
            this.InvokeAsync("ListChildren", new object[] {
                        Item,
                        Recursive}, this.ListChildrenOperationCompleted, userState);
        }
        
        private void OnListChildrenOperationCompleted(object arg) {
            if ((this.ListChildrenCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ListChildrenCompleted(this, new ListChildrenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ItemNamespaceHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetPro" +
            "perties", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Values")]
        public Property[] GetProperties(string Item, Property[] Properties) {
            object[] results = this.Invoke("GetProperties", new object[] {
                        Item,
                        Properties});
            return ((Property[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetProperties(string Item, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetProperties", new object[] {
                        Item,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public Property[] EndGetProperties(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Property[])(results[0]));
        }
        
        /// <remarks/>
        public void GetPropertiesAsync(string Item, Property[] Properties) {
            this.GetPropertiesAsync(Item, Properties, null);
        }
        
        /// <remarks/>
        public void GetPropertiesAsync(string Item, Property[] Properties, object userState) {
            if ((this.GetPropertiesOperationCompleted == null)) {
                this.GetPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPropertiesOperationCompleted);
            }
            this.InvokeAsync("GetProperties", new object[] {
                        Item,
                        Properties}, this.GetPropertiesOperationCompleted, userState);
        }
        
        private void OnGetPropertiesOperationCompleted(object arg) {
            if ((this.GetPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPropertiesCompleted(this, new GetPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetPro" +
            "perties", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetProperties(string Item, Property[] Properties) {
            this.Invoke("SetProperties", new object[] {
                        Item,
                        Properties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetProperties(string Item, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetProperties", new object[] {
                        Item,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetProperties(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetPropertiesAsync(string Item, Property[] Properties) {
            this.SetPropertiesAsync(Item, Properties, null);
        }
        
        /// <remarks/>
        public void SetPropertiesAsync(string Item, Property[] Properties, object userState) {
            if ((this.SetPropertiesOperationCompleted == null)) {
                this.SetPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetPropertiesOperationCompleted);
            }
            this.InvokeAsync("SetProperties", new object[] {
                        Item,
                        Properties}, this.SetPropertiesOperationCompleted, userState);
        }
        
        private void OnSetPropertiesOperationCompleted(object arg) {
            if ((this.SetPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetPropertiesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetIte" +
            "mType", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Type")]
        public ItemTypeEnum GetItemType(string Item) {
            object[] results = this.Invoke("GetItemType", new object[] {
                        Item});
            return ((ItemTypeEnum)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetItemType(string Item, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetItemType", new object[] {
                        Item}, callback, asyncState);
        }
        
        /// <remarks/>
        public ItemTypeEnum EndGetItemType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ItemTypeEnum)(results[0]));
        }
        
        /// <remarks/>
        public void GetItemTypeAsync(string Item) {
            this.GetItemTypeAsync(Item, null);
        }
        
        /// <remarks/>
        public void GetItemTypeAsync(string Item, object userState) {
            if ((this.GetItemTypeOperationCompleted == null)) {
                this.GetItemTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetItemTypeOperationCompleted);
            }
            this.InvokeAsync("GetItemType", new object[] {
                        Item}, this.GetItemTypeOperationCompleted, userState);
        }
        
        private void OnGetItemTypeOperationCompleted(object arg) {
            if ((this.GetItemTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetItemTypeCompleted(this, new GetItemTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Create" +
            "Folder", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateFolder(string Folder, string Parent, Property[] Properties) {
            this.Invoke("CreateFolder", new object[] {
                        Folder,
                        Parent,
                        Properties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateFolder(string Folder, string Parent, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateFolder", new object[] {
                        Folder,
                        Parent,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateFolder(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateFolderAsync(string Folder, string Parent, Property[] Properties) {
            this.CreateFolderAsync(Folder, Parent, Properties, null);
        }
        
        /// <remarks/>
        public void CreateFolderAsync(string Folder, string Parent, Property[] Properties, object userState) {
            if ((this.CreateFolderOperationCompleted == null)) {
                this.CreateFolderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateFolderOperationCompleted);
            }
            this.InvokeAsync("CreateFolder", new object[] {
                        Folder,
                        Parent,
                        Properties}, this.CreateFolderOperationCompleted, userState);
        }
        
        private void OnCreateFolderOperationCompleted(object arg) {
            if ((this.CreateFolderCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateFolderCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Create" +
            "Report", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Warnings")]
        public Warning[] CreateReport(string Report, string Parent, bool Overwrite, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] Definition, Property[] Properties) {
            object[] results = this.Invoke("CreateReport", new object[] {
                        Report,
                        Parent,
                        Overwrite,
                        Definition,
                        Properties});
            return ((Warning[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateReport(string Report, string Parent, bool Overwrite, byte[] Definition, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateReport", new object[] {
                        Report,
                        Parent,
                        Overwrite,
                        Definition,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public Warning[] EndCreateReport(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Warning[])(results[0]));
        }
        
        /// <remarks/>
        public void CreateReportAsync(string Report, string Parent, bool Overwrite, byte[] Definition, Property[] Properties) {
            this.CreateReportAsync(Report, Parent, Overwrite, Definition, Properties, null);
        }
        
        /// <remarks/>
        public void CreateReportAsync(string Report, string Parent, bool Overwrite, byte[] Definition, Property[] Properties, object userState) {
            if ((this.CreateReportOperationCompleted == null)) {
                this.CreateReportOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateReportOperationCompleted);
            }
            this.InvokeAsync("CreateReport", new object[] {
                        Report,
                        Parent,
                        Overwrite,
                        Definition,
                        Properties}, this.CreateReportOperationCompleted, userState);
        }
        
        private void OnCreateReportOperationCompleted(object arg) {
            if ((this.CreateReportCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateReportCompleted(this, new CreateReportCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetRep" +
            "ortDefinition", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Definition", DataType="base64Binary")]
        public byte[] GetReportDefinition(string Report) {
            object[] results = this.Invoke("GetReportDefinition", new object[] {
                        Report});
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReportDefinition(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReportDefinition", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public byte[] EndGetReportDefinition(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public void GetReportDefinitionAsync(string Report) {
            this.GetReportDefinitionAsync(Report, null);
        }
        
        /// <remarks/>
        public void GetReportDefinitionAsync(string Report, object userState) {
            if ((this.GetReportDefinitionOperationCompleted == null)) {
                this.GetReportDefinitionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReportDefinitionOperationCompleted);
            }
            this.InvokeAsync("GetReportDefinition", new object[] {
                        Report}, this.GetReportDefinitionOperationCompleted, userState);
        }
        
        private void OnGetReportDefinitionOperationCompleted(object arg) {
            if ((this.GetReportDefinitionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReportDefinitionCompleted(this, new GetReportDefinitionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetRep" +
            "ortDefinition", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Warnings")]
        public Warning[] SetReportDefinition(string Report, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] Definition) {
            object[] results = this.Invoke("SetReportDefinition", new object[] {
                        Report,
                        Definition});
            return ((Warning[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetReportDefinition(string Report, byte[] Definition, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetReportDefinition", new object[] {
                        Report,
                        Definition}, callback, asyncState);
        }
        
        /// <remarks/>
        public Warning[] EndSetReportDefinition(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Warning[])(results[0]));
        }
        
        /// <remarks/>
        public void SetReportDefinitionAsync(string Report, byte[] Definition) {
            this.SetReportDefinitionAsync(Report, Definition, null);
        }
        
        /// <remarks/>
        public void SetReportDefinitionAsync(string Report, byte[] Definition, object userState) {
            if ((this.SetReportDefinitionOperationCompleted == null)) {
                this.SetReportDefinitionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetReportDefinitionOperationCompleted);
            }
            this.InvokeAsync("SetReportDefinition", new object[] {
                        Report,
                        Definition}, this.SetReportDefinitionOperationCompleted, userState);
        }
        
        private void OnSetReportDefinitionOperationCompleted(object arg) {
            if ((this.SetReportDefinitionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetReportDefinitionCompleted(this, new SetReportDefinitionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Create" +
            "Resource", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateResource(string Resource, string Parent, bool Overwrite, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] Contents, string MimeType, Property[] Properties) {
            this.Invoke("CreateResource", new object[] {
                        Resource,
                        Parent,
                        Overwrite,
                        Contents,
                        MimeType,
                        Properties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateResource(string Resource, string Parent, bool Overwrite, byte[] Contents, string MimeType, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateResource", new object[] {
                        Resource,
                        Parent,
                        Overwrite,
                        Contents,
                        MimeType,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateResource(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateResourceAsync(string Resource, string Parent, bool Overwrite, byte[] Contents, string MimeType, Property[] Properties) {
            this.CreateResourceAsync(Resource, Parent, Overwrite, Contents, MimeType, Properties, null);
        }
        
        /// <remarks/>
        public void CreateResourceAsync(string Resource, string Parent, bool Overwrite, byte[] Contents, string MimeType, Property[] Properties, object userState) {
            if ((this.CreateResourceOperationCompleted == null)) {
                this.CreateResourceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateResourceOperationCompleted);
            }
            this.InvokeAsync("CreateResource", new object[] {
                        Resource,
                        Parent,
                        Overwrite,
                        Contents,
                        MimeType,
                        Properties}, this.CreateResourceOperationCompleted, userState);
        }
        
        private void OnCreateResourceOperationCompleted(object arg) {
            if ((this.CreateResourceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateResourceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetRes" +
            "ourceContents", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetResourceContents(string Resource, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] Contents, string MimeType) {
            this.Invoke("SetResourceContents", new object[] {
                        Resource,
                        Contents,
                        MimeType});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetResourceContents(string Resource, byte[] Contents, string MimeType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetResourceContents", new object[] {
                        Resource,
                        Contents,
                        MimeType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetResourceContents(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetResourceContentsAsync(string Resource, byte[] Contents, string MimeType) {
            this.SetResourceContentsAsync(Resource, Contents, MimeType, null);
        }
        
        /// <remarks/>
        public void SetResourceContentsAsync(string Resource, byte[] Contents, string MimeType, object userState) {
            if ((this.SetResourceContentsOperationCompleted == null)) {
                this.SetResourceContentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetResourceContentsOperationCompleted);
            }
            this.InvokeAsync("SetResourceContents", new object[] {
                        Resource,
                        Contents,
                        MimeType}, this.SetResourceContentsOperationCompleted, userState);
        }
        
        private void OnSetResourceContentsOperationCompleted(object arg) {
            if ((this.SetResourceContentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetResourceContentsCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetRes" +
            "ourceContents", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Contents", DataType="base64Binary")]
        public byte[] GetResourceContents(string Resource, out string MimeType) {
            object[] results = this.Invoke("GetResourceContents", new object[] {
                        Resource});
            MimeType = ((string)(results[1]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourceContents(string Resource, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourceContents", new object[] {
                        Resource}, callback, asyncState);
        }
        
        /// <remarks/>
        public byte[] EndGetResourceContents(System.IAsyncResult asyncResult, out string MimeType) {
            object[] results = this.EndInvoke(asyncResult);
            MimeType = ((string)(results[1]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public void GetResourceContentsAsync(string Resource) {
            this.GetResourceContentsAsync(Resource, null);
        }
        
        /// <remarks/>
        public void GetResourceContentsAsync(string Resource, object userState) {
            if ((this.GetResourceContentsOperationCompleted == null)) {
                this.GetResourceContentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetResourceContentsOperationCompleted);
            }
            this.InvokeAsync("GetResourceContents", new object[] {
                        Resource}, this.GetResourceContentsOperationCompleted, userState);
        }
        
        private void OnGetResourceContentsOperationCompleted(object arg) {
            if ((this.GetResourceContentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetResourceContentsCompleted(this, new GetResourceContentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetRep" +
            "ortParameters", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Parameters")]
        public ReportParameter[] GetReportParameters(string Report, string HistoryID, bool ForRendering, ParameterValue[] Values, DataSourceCredentials[] Credentials) {
            object[] results = this.Invoke("GetReportParameters", new object[] {
                        Report,
                        HistoryID,
                        ForRendering,
                        Values,
                        Credentials});
            return ((ReportParameter[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReportParameters(string Report, string HistoryID, bool ForRendering, ParameterValue[] Values, DataSourceCredentials[] Credentials, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReportParameters", new object[] {
                        Report,
                        HistoryID,
                        ForRendering,
                        Values,
                        Credentials}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReportParameter[] EndGetReportParameters(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReportParameter[])(results[0]));
        }
        
        /// <remarks/>
        public void GetReportParametersAsync(string Report, string HistoryID, bool ForRendering, ParameterValue[] Values, DataSourceCredentials[] Credentials) {
            this.GetReportParametersAsync(Report, HistoryID, ForRendering, Values, Credentials, null);
        }
        
        /// <remarks/>
        public void GetReportParametersAsync(string Report, string HistoryID, bool ForRendering, ParameterValue[] Values, DataSourceCredentials[] Credentials, object userState) {
            if ((this.GetReportParametersOperationCompleted == null)) {
                this.GetReportParametersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReportParametersOperationCompleted);
            }
            this.InvokeAsync("GetReportParameters", new object[] {
                        Report,
                        HistoryID,
                        ForRendering,
                        Values,
                        Credentials}, this.GetReportParametersOperationCompleted, userState);
        }
        
        private void OnGetReportParametersOperationCompleted(object arg) {
            if ((this.GetReportParametersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReportParametersCompleted(this, new GetReportParametersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetRep" +
            "ortParameters", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetReportParameters(string Report, ReportParameter[] Parameters) {
            this.Invoke("SetReportParameters", new object[] {
                        Report,
                        Parameters});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetReportParameters(string Report, ReportParameter[] Parameters, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetReportParameters", new object[] {
                        Report,
                        Parameters}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetReportParameters(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetReportParametersAsync(string Report, ReportParameter[] Parameters) {
            this.SetReportParametersAsync(Report, Parameters, null);
        }
        
        /// <remarks/>
        public void SetReportParametersAsync(string Report, ReportParameter[] Parameters, object userState) {
            if ((this.SetReportParametersOperationCompleted == null)) {
                this.SetReportParametersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetReportParametersOperationCompleted);
            }
            this.InvokeAsync("SetReportParameters", new object[] {
                        Report,
                        Parameters}, this.SetReportParametersOperationCompleted, userState);
        }
        
        private void OnSetReportParametersOperationCompleted(object arg) {
            if ((this.SetReportParametersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetReportParametersCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Create" +
            "LinkedReport", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateLinkedReport(string Report, string Parent, string Link, Property[] Properties) {
            this.Invoke("CreateLinkedReport", new object[] {
                        Report,
                        Parent,
                        Link,
                        Properties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateLinkedReport(string Report, string Parent, string Link, Property[] Properties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateLinkedReport", new object[] {
                        Report,
                        Parent,
                        Link,
                        Properties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateLinkedReport(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateLinkedReportAsync(string Report, string Parent, string Link, Property[] Properties) {
            this.CreateLinkedReportAsync(Report, Parent, Link, Properties, null);
        }
        
        /// <remarks/>
        public void CreateLinkedReportAsync(string Report, string Parent, string Link, Property[] Properties, object userState) {
            if ((this.CreateLinkedReportOperationCompleted == null)) {
                this.CreateLinkedReportOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateLinkedReportOperationCompleted);
            }
            this.InvokeAsync("CreateLinkedReport", new object[] {
                        Report,
                        Parent,
                        Link,
                        Properties}, this.CreateLinkedReportOperationCompleted, userState);
        }
        
        private void OnCreateLinkedReportOperationCompleted(object arg) {
            if ((this.CreateLinkedReportCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateLinkedReportCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetRep" +
            "ortLink", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Link")]
        public string GetReportLink(string Report) {
            object[] results = this.Invoke("GetReportLink", new object[] {
                        Report});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReportLink(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReportLink", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetReportLink(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetReportLinkAsync(string Report) {
            this.GetReportLinkAsync(Report, null);
        }
        
        /// <remarks/>
        public void GetReportLinkAsync(string Report, object userState) {
            if ((this.GetReportLinkOperationCompleted == null)) {
                this.GetReportLinkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReportLinkOperationCompleted);
            }
            this.InvokeAsync("GetReportLink", new object[] {
                        Report}, this.GetReportLinkOperationCompleted, userState);
        }
        
        private void OnGetReportLinkOperationCompleted(object arg) {
            if ((this.GetReportLinkCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReportLinkCompleted(this, new GetReportLinkCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetRep" +
            "ortLink", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetReportLink(string Report, string Link) {
            this.Invoke("SetReportLink", new object[] {
                        Report,
                        Link});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetReportLink(string Report, string Link, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetReportLink", new object[] {
                        Report,
                        Link}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetReportLink(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetReportLinkAsync(string Report, string Link) {
            this.SetReportLinkAsync(Report, Link, null);
        }
        
        /// <remarks/>
        public void SetReportLinkAsync(string Report, string Link, object userState) {
            if ((this.SetReportLinkOperationCompleted == null)) {
                this.SetReportLinkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetReportLinkOperationCompleted);
            }
            this.InvokeAsync("SetReportLink", new object[] {
                        Report,
                        Link}, this.SetReportLinkOperationCompleted, userState);
        }
        
        private void OnSetReportLinkOperationCompleted(object arg) {
            if ((this.SetReportLinkCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetReportLinkCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/ListLi" +
            "nkedReports", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Reports")]
        public CatalogItem[] ListLinkedReports(string Report) {
            object[] results = this.Invoke("ListLinkedReports", new object[] {
                        Report});
            return ((CatalogItem[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginListLinkedReports(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ListLinkedReports", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public CatalogItem[] EndListLinkedReports(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CatalogItem[])(results[0]));
        }
        
        /// <remarks/>
        public void ListLinkedReportsAsync(string Report) {
            this.ListLinkedReportsAsync(Report, null);
        }
        
        /// <remarks/>
        public void ListLinkedReportsAsync(string Report, object userState) {
            if ((this.ListLinkedReportsOperationCompleted == null)) {
                this.ListLinkedReportsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnListLinkedReportsOperationCompleted);
            }
            this.InvokeAsync("ListLinkedReports", new object[] {
                        Report}, this.ListLinkedReportsOperationCompleted, userState);
        }
        
        private void OnListLinkedReportsOperationCompleted(object arg) {
            if ((this.ListLinkedReportsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ListLinkedReportsCompleted(this, new ListLinkedReportsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SessionHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.InOut)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Render" +
            "", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result", DataType="base64Binary")]
        public byte[] Render(string Report, string Format, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, DataSourceCredentials[] Credentials, string ShowHideToggle, out string Encoding, out string MimeType, out ParameterValue[] ParametersUsed, out Warning[] Warnings, out string[] StreamIds) {
            object[] results = this.Invoke("Render", new object[] {
                        Report,
                        Format,
                        HistoryID,
                        DeviceInfo,
                        Parameters,
                        Credentials,
                        ShowHideToggle});
            Encoding = ((string)(results[1]));
            MimeType = ((string)(results[2]));
            ParametersUsed = ((ParameterValue[])(results[3]));
            Warnings = ((Warning[])(results[4]));
            StreamIds = ((string[])(results[5]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRender(string Report, string Format, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, DataSourceCredentials[] Credentials, string ShowHideToggle, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Render", new object[] {
                        Report,
                        Format,
                        HistoryID,
                        DeviceInfo,
                        Parameters,
                        Credentials,
                        ShowHideToggle}, callback, asyncState);
        }
        
        /// <remarks/>
        public byte[] EndRender(System.IAsyncResult asyncResult, out string Encoding, out string MimeType, out ParameterValue[] ParametersUsed, out Warning[] Warnings, out string[] StreamIds) {
            object[] results = this.EndInvoke(asyncResult);
            Encoding = ((string)(results[1]));
            MimeType = ((string)(results[2]));
            ParametersUsed = ((ParameterValue[])(results[3]));
            Warnings = ((Warning[])(results[4]));
            StreamIds = ((string[])(results[5]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public void RenderAsync(string Report, string Format, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, DataSourceCredentials[] Credentials, string ShowHideToggle) {
            this.RenderAsync(Report, Format, HistoryID, DeviceInfo, Parameters, Credentials, ShowHideToggle, null);
        }
        
        /// <remarks/>
        public void RenderAsync(string Report, string Format, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, DataSourceCredentials[] Credentials, string ShowHideToggle, object userState) {
            if ((this.RenderOperationCompleted == null)) {
                this.RenderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRenderOperationCompleted);
            }
            this.InvokeAsync("Render", new object[] {
                        Report,
                        Format,
                        HistoryID,
                        DeviceInfo,
                        Parameters,
                        Credentials,
                        ShowHideToggle}, this.RenderOperationCompleted, userState);
        }
        
        private void OnRenderOperationCompleted(object arg) {
            if ((this.RenderCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RenderCompleted(this, new RenderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SessionHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.InOut)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Render" +
            "Stream", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result", DataType="base64Binary")]
        public byte[] RenderStream(string Report, string Format, string StreamID, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, out string Encoding, out string MimeType) {
            object[] results = this.Invoke("RenderStream", new object[] {
                        Report,
                        Format,
                        StreamID,
                        HistoryID,
                        DeviceInfo,
                        Parameters});
            Encoding = ((string)(results[1]));
            MimeType = ((string)(results[2]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRenderStream(string Report, string Format, string StreamID, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RenderStream", new object[] {
                        Report,
                        Format,
                        StreamID,
                        HistoryID,
                        DeviceInfo,
                        Parameters}, callback, asyncState);
        }
        
        /// <remarks/>
        public byte[] EndRenderStream(System.IAsyncResult asyncResult, out string Encoding, out string MimeType) {
            object[] results = this.EndInvoke(asyncResult);
            Encoding = ((string)(results[1]));
            MimeType = ((string)(results[2]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public void RenderStreamAsync(string Report, string Format, string StreamID, string HistoryID, string DeviceInfo, ParameterValue[] Parameters) {
            this.RenderStreamAsync(Report, Format, StreamID, HistoryID, DeviceInfo, Parameters, null);
        }
        
        /// <remarks/>
        public void RenderStreamAsync(string Report, string Format, string StreamID, string HistoryID, string DeviceInfo, ParameterValue[] Parameters, object userState) {
            if ((this.RenderStreamOperationCompleted == null)) {
                this.RenderStreamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRenderStreamOperationCompleted);
            }
            this.InvokeAsync("RenderStream", new object[] {
                        Report,
                        Format,
                        StreamID,
                        HistoryID,
                        DeviceInfo,
                        Parameters}, this.RenderStreamOperationCompleted, userState);
        }
        
        private void OnRenderStreamOperationCompleted(object arg) {
            if ((this.RenderStreamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RenderStreamCompleted(this, new RenderStreamCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetRen" +
            "derResource", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result", DataType="base64Binary")]
        public byte[] GetRenderResource(string Format, string DeviceInfo, out string MimeType) {
            object[] results = this.Invoke("GetRenderResource", new object[] {
                        Format,
                        DeviceInfo});
            MimeType = ((string)(results[1]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRenderResource(string Format, string DeviceInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRenderResource", new object[] {
                        Format,
                        DeviceInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public byte[] EndGetRenderResource(System.IAsyncResult asyncResult, out string MimeType) {
            object[] results = this.EndInvoke(asyncResult);
            MimeType = ((string)(results[1]));
            return ((byte[])(results[0]));
        }
        
        /// <remarks/>
        public void GetRenderResourceAsync(string Format, string DeviceInfo) {
            this.GetRenderResourceAsync(Format, DeviceInfo, null);
        }
        
        /// <remarks/>
        public void GetRenderResourceAsync(string Format, string DeviceInfo, object userState) {
            if ((this.GetRenderResourceOperationCompleted == null)) {
                this.GetRenderResourceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRenderResourceOperationCompleted);
            }
            this.InvokeAsync("GetRenderResource", new object[] {
                        Format,
                        DeviceInfo}, this.GetRenderResourceOperationCompleted, userState);
        }
        
        private void OnGetRenderResourceOperationCompleted(object arg) {
            if ((this.GetRenderResourceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRenderResourceCompleted(this, new GetRenderResourceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetExe" +
            "cutionOptions", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetExecutionOptions(string Report, ExecutionSettingEnum ExecutionSetting, [System.Xml.Serialization.XmlElementAttribute("NoSchedule", typeof(NoSchedule))] [System.Xml.Serialization.XmlElementAttribute("ScheduleDefinition", typeof(ScheduleDefinition))] [System.Xml.Serialization.XmlElementAttribute("ScheduleReference", typeof(ScheduleReference))] ScheduleDefinitionOrReference Item) {
            this.Invoke("SetExecutionOptions", new object[] {
                        Report,
                        ExecutionSetting,
                        Item});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetExecutionOptions(string Report, ExecutionSettingEnum ExecutionSetting, ScheduleDefinitionOrReference Item, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetExecutionOptions", new object[] {
                        Report,
                        ExecutionSetting,
                        Item}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetExecutionOptions(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetExecutionOptionsAsync(string Report, ExecutionSettingEnum ExecutionSetting, ScheduleDefinitionOrReference Item) {
            this.SetExecutionOptionsAsync(Report, ExecutionSetting, Item, null);
        }
        
        /// <remarks/>
        public void SetExecutionOptionsAsync(string Report, ExecutionSettingEnum ExecutionSetting, ScheduleDefinitionOrReference Item, object userState) {
            if ((this.SetExecutionOptionsOperationCompleted == null)) {
                this.SetExecutionOptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetExecutionOptionsOperationCompleted);
            }
            this.InvokeAsync("SetExecutionOptions", new object[] {
                        Report,
                        ExecutionSetting,
                        Item}, this.SetExecutionOptionsOperationCompleted, userState);
        }
        
        private void OnSetExecutionOptionsOperationCompleted(object arg) {
            if ((this.SetExecutionOptionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetExecutionOptionsCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetExe" +
            "cutionOptions", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ExecutionSetting")]
        public ExecutionSettingEnum GetExecutionOptions(string Report, [System.Xml.Serialization.XmlElementAttribute("NoSchedule", typeof(NoSchedule))] [System.Xml.Serialization.XmlElementAttribute("ScheduleDefinition", typeof(ScheduleDefinition))] [System.Xml.Serialization.XmlElementAttribute("ScheduleReference", typeof(ScheduleReference))] out ScheduleDefinitionOrReference Item) {
            object[] results = this.Invoke("GetExecutionOptions", new object[] {
                        Report});
            Item = ((ScheduleDefinitionOrReference)(results[1]));
            return ((ExecutionSettingEnum)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExecutionOptions(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExecutionOptions", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExecutionSettingEnum EndGetExecutionOptions(System.IAsyncResult asyncResult, out ScheduleDefinitionOrReference Item) {
            object[] results = this.EndInvoke(asyncResult);
            Item = ((ScheduleDefinitionOrReference)(results[1]));
            return ((ExecutionSettingEnum)(results[0]));
        }
        
        /// <remarks/>
        public void GetExecutionOptionsAsync(string Report) {
            this.GetExecutionOptionsAsync(Report, null);
        }
        
        /// <remarks/>
        public void GetExecutionOptionsAsync(string Report, object userState) {
            if ((this.GetExecutionOptionsOperationCompleted == null)) {
                this.GetExecutionOptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExecutionOptionsOperationCompleted);
            }
            this.InvokeAsync("GetExecutionOptions", new object[] {
                        Report}, this.GetExecutionOptionsOperationCompleted, userState);
        }
        
        private void OnGetExecutionOptionsOperationCompleted(object arg) {
            if ((this.GetExecutionOptionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExecutionOptionsCompleted(this, new GetExecutionOptionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/SetCac" +
            "heOptions", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetCacheOptions(string Report, bool CacheReport, [System.Xml.Serialization.XmlElementAttribute("ScheduleExpiration", typeof(ScheduleExpiration))] [System.Xml.Serialization.XmlElementAttribute("TimeExpiration", typeof(TimeExpiration))] ExpirationDefinition Item) {
            this.Invoke("SetCacheOptions", new object[] {
                        Report,
                        CacheReport,
                        Item});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetCacheOptions(string Report, bool CacheReport, ExpirationDefinition Item, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetCacheOptions", new object[] {
                        Report,
                        CacheReport,
                        Item}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetCacheOptions(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetCacheOptionsAsync(string Report, bool CacheReport, ExpirationDefinition Item) {
            this.SetCacheOptionsAsync(Report, CacheReport, Item, null);
        }
        
        /// <remarks/>
        public void SetCacheOptionsAsync(string Report, bool CacheReport, ExpirationDefinition Item, object userState) {
            if ((this.SetCacheOptionsOperationCompleted == null)) {
                this.SetCacheOptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetCacheOptionsOperationCompleted);
            }
            this.InvokeAsync("SetCacheOptions", new object[] {
                        Report,
                        CacheReport,
                        Item}, this.SetCacheOptionsOperationCompleted, userState);
        }
        
        private void OnSetCacheOptionsOperationCompleted(object arg) {
            if ((this.SetCacheOptionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetCacheOptionsCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/GetCac" +
            "heOptions", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("CacheReport")]
        public bool GetCacheOptions(string Report, [System.Xml.Serialization.XmlElementAttribute("ScheduleExpiration", typeof(ScheduleExpiration))] [System.Xml.Serialization.XmlElementAttribute("TimeExpiration", typeof(TimeExpiration))] out ExpirationDefinition Item) {
            object[] results = this.Invoke("GetCacheOptions", new object[] {
                        Report});
            Item = ((ExpirationDefinition)(results[1]));
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCacheOptions(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCacheOptions", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndGetCacheOptions(System.IAsyncResult asyncResult, out ExpirationDefinition Item) {
            object[] results = this.EndInvoke(asyncResult);
            Item = ((ExpirationDefinition)(results[1]));
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void GetCacheOptionsAsync(string Report) {
            this.GetCacheOptionsAsync(Report, null);
        }
        
        /// <remarks/>
        public void GetCacheOptionsAsync(string Report, object userState) {
            if ((this.GetCacheOptionsOperationCompleted == null)) {
                this.GetCacheOptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCacheOptionsOperationCompleted);
            }
            this.InvokeAsync("GetCacheOptions", new object[] {
                        Report}, this.GetCacheOptionsOperationCompleted, userState);
        }
        
        private void OnGetCacheOptionsOperationCompleted(object arg) {
            if ((this.GetCacheOptionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCacheOptionsCompleted(this, new GetCacheOptionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/Update" +
            "ReportExecutionSnapshot", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateReportExecutionSnapshot(string Report) {
            this.Invoke("UpdateReportExecutionSnapshot", new object[] {
                        Report});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateReportExecutionSnapshot(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateReportExecutionSnapshot", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateReportExecutionSnapshot(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateReportExecutionSnapshotAsync(string Report) {
            this.UpdateReportExecutionSnapshotAsync(Report, null);
        }
        
        /// <remarks/>
        public void UpdateReportExecutionSnapshotAsync(string Report, object userState) {
            if ((this.UpdateReportExecutionSnapshotOperationCompleted == null)) {
                this.UpdateReportExecutionSnapshotOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateReportExecutionSnapshotOperationCompleted);
            }
            this.InvokeAsync("UpdateReportExecutionSnapshot", new object[] {
                        Report}, this.UpdateReportExecutionSnapshotOperationCompleted, userState);
        }
        
        private void OnUpdateReportExecutionSnapshotOperationCompleted(object arg) {
            if ((this.UpdateReportExecutionSnapshotCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateReportExecutionSnapshotCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BatchHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/FlushC" +
            "ache", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void FlushCache(string Report) {
            this.Invoke("FlushCache", new object[] {
                        Report});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginFlushCache(string Report, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("FlushCache", new object[] {
                        Report}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndFlushCache(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void FlushCacheAsync(string Report) {
            this.FlushCacheAsync(Report, null);
        }
        
        /// <remarks/>
        public void FlushCacheAsync(string Report, object userState) {
            if ((this.FlushCacheOperationCompleted == null)) {
                this.FlushCacheOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFlushCacheOperationCompleted);
            }
            this.InvokeAsync("FlushCache", new object[] {
                        Report}, this.FlushCacheOperationCompleted, userState);
        }
        
        private void OnFlushCacheOperationCompleted(object arg) {
            if ((this.FlushCacheCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FlushCacheCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServerInfoHeaderValue", Direction=System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices/ListJo" +
            "bs", RequestNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", ResponseNamespace="http://schemas.microsoft.com/sqlserver/2003/12/reporting/reportingservices", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("Jobs")]
        public Job[] ListJobs() {
            object[] results = this.Invoke("ListJobs", new object[0]);
            return ((Job[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginListJobs(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ListJobs", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Job[] EndListJobs(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Job[])(results[0]));
        }
        
        /// <remarks/>
        public void ListJobsAsync() {
            this.ListJobsAsync(null);
        }
        
        /// <remarks/>
        public void ListJobsAsync(object userState) {
            if ((this.ListJobsOperationCompleted == null)) {
                this.ListJobsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnListJobsOperationCompleted);
            }
            this.InvokeAsync("ListJobs", new object[0], this.ListJobsOperationCompleted, userState);
        }
        
        private void OnListJobsOperationCompleted(object arg) {
            if ((this.ListJobsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.