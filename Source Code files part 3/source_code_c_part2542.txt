nerItem *	GetHead() {return (CContainerItem *)AList::GetHead();};
    CContainerItem *	RemoveHead() {return (CContainerItem *)AList::RemoveHead();};
    void                AddTail(CContainerItem * pItem) { AList::AddTail((AListItem *)pItem);};
};

class CContainer : 
    public IDirectMusicContainer,
    public IDirectMusicObject,
    public IPersistStream,
    public IDirectMusicObjectP
{
public:
    CContainer::CContainer();
    CContainer::~CContainer();
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicContainer
    STDMETHODIMP EnumObject(REFGUID rguidClass,
        DWORD dwIndex,
        LPDMUS_OBJECTDESC pDesc,
        WCHAR *pwszAlias);

    // IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

private:
    void    Clear();    // Remove all object references.
    HRESULT Load(CRiffParser *pParser, IDirectMusicLoader *pLoader);
    HRESULT LoadObject(CRiffParser *pParser,
                      IDirectMusicLoader *pLoader);

    IStream *           m_pStream;  // Pointer to stream this was loaded from.
                                    // This also provides access to the loader, indirectly.
    CContainerItemList  m_ItemList; // List of objects that were loaded by container. 
    long                m_cRef;     // COM reference counter.
    DWORD               m_dwFlags;  // Flags loaded from file.
    DWORD               m_dwPartialLoad; // Used to keep track of partial load.
    // IDirectMusicObject variables
    CInfo               m_Info;
    CMemTrack           m_MemTrack; // Used to debug memory leaks.
    bool                m_fZombie;
};

#endif //__CONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\tempotrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include "pchime.h"
// TempoTrk.cpp : Implementation of CTempoTrack
#include "dmime.h"
#include "TempoTrk.h"
#include "dmusicip.h"
#include "dmusicf.h"
#include "debug.h"
#include "dmperf.h"
#include "..\shared\Validate.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// CTempoTrack

void CTempoTrack::Construct()
{
    IncrementDLLCount();

	m_cRef = 0;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CTempoTrack::CTempoTrack() : m_MemTrack(DMTRACK_TEMPO_TRACK)
{
	Construct();
	m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTempoTrack::CTempoTrack(
		const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : m_MemTrack(DMTRACK_TEMPO_TRACK)
{
	Construct();
	m_fActive = rTrack.m_fActive;
    m_fStateSetBySetParam = rTrack.m_fStateSetBySetParam;
	TListItem<DMUS_IO_TEMPO_ITEM>* pScan = rTrack.m_TempoEventList.GetHead();
	//1////////////////////////////////////////
	TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
	//1////////////////////////////////////////
	for(; pScan; pScan = pScan->GetNext())
	{
		DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
		//2////////////////////////////////////////
		if (rScan.lTime < mtStart)
		{
			pPrevious = pScan;
		}
		//2////////////////////////////////////////
		else if (rScan.lTime < mtEnd)
		{
			//3////////////////////////////////////////
			if (rScan.lTime == mtStart)
			{
				pPrevious = NULL;
			}
			//3////////////////////////////////////////
			TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
			if (pNew)
			{
				DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
				memcpy( &rNew, &rScan, sizeof(DMUS_IO_TEMPO_ITEM) );
				rNew.lTime = rScan.lTime - mtStart;
				m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_TempoEventList.Reverse(); // for above AddHead.
	//4////////////////////////////////////////
	if (pPrevious)
	{
		DMUS_IO_TEMPO_ITEM& rPrevious = pPrevious->GetItemValue();
		TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
		if (pNew)
		{
			DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
			memcpy( &rNew, &rPrevious, sizeof(DMUS_IO_TEMPO_ITEM) );
			rNew.lTime = 0;
			m_TempoEventList.AddHead(pNew);
		}
	}
	//4////////////////////////////////////////
}

CTempoTrack::~CTempoTrack()
{
    if (m_fCSInitialized)
    {
	    DELETE_CRITICAL_SECTION(&m_CrSec);
    }
    DecrementDLLCount();
}

// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTempoTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTempoTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CTempoTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Tempo Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | Release | Standard Release implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTempoTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CTempoTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicTempoTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTempoTrack::IsDirty()
{
	return S_FALSE;
}

/*

  @method HRESULT | ITempoTrack | Load |
  Call this with an IStream filled with DMUS_IO_TEMPO_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TEMPO_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain Tempo events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TempoTrack is released.
*/
HRESULT CTempoTrack::Load( IStream* pIStream )
{
	V_INAME(CTempoTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	ENTER_CRITICAL_SECTION(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
	if( m_TempoEventList.GetHead() )
	{
		TListItem<DMUS_IO_TEMPO_ITEM>* pItem;
		while( pItem = m_TempoEventList.RemoveHead() )
		{
			delete pItem;
		}
	}

	// copy contents of the stream into the list.
	LARGE_INTEGER li;
	DMUS_IO_TEMPO_ITEM tempoEvent;
	// read in the chunk id
	DWORD dwChunk, dwSubSize;
	long lSize;
	pIStream->Read( &dwChunk, sizeof(DWORD), NULL );
	if( dwChunk != DMUS_FOURCC_TEMPO_TRACK )
	{
        Trace(1,"Error: Invalid data in tempo track.\n");
		LEAVE_CRITICAL_SECTION(&m_CrSec);
	    return DMUS_E_CHUNKNOTFOUND;
	}
	// read in the overall size
	pIStream->Read( &lSize, sizeof(long), NULL );
	// read in the size of the data structures
	if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
	{
        // Check to make sure our reads are succeeding (we can safely
        // assume the previous reads worked if we got this far.)
        Trace(1,"Error: Unable to read tempo track.\n");
		LEAVE_CRITICAL_SECTION(&m_CrSec);
	    return DMUS_E_CANNOTREAD;
	}
	lSize -= sizeof(DWORD);

	DWORD dwRead, dwSeek;
	if( dwSubSize > sizeof(DMUS_IO_TEMPO_ITEM) )
	{
		dwRead = sizeof(DMUS_IO_TEMPO_ITEM);
		dwSeek = dwSubSize - dwRead;
		li.HighPart = 0;
		li.LowPart = dwSeek;
	}
	else
	{
		dwRead = dwSubSize;
		dwSeek = 0;
	}
	if( dwRead )
	{
	    while( lSize > 0 )
	    {
		    if( FAILED( pIStream->Read( &tempoEvent, dwRead, NULL )))
		    {
                Trace(1,"Error: Failure reading tempo track.\n");
			    hr = DMUS_E_CANNOTREAD;
			    break;
		    }
		    lSize -= dwRead;
		    if( dwSeek )
		    {
			    if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
			    {
                    Trace(1,"Error: Failure reading tempo track.\n");
				    hr = DMUS_E_CANNOTSEEK;
				    break;
			    }                                             
			    lSize -= dwSeek;
		    }
		    TListItem<DMUS_IO_TEMPO_ITEM>* pNew = 
			    new TListItem<DMUS_IO_TEMPO_ITEM>(tempoEvent);
		    if (pNew)
		    {
			    m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
		    }
        }
	    m_TempoEventList.Reverse();
    }
    else
    {
        Trace(1,"Error: Failure reading tempo track.\n");
        hr = DMUS_E_CANNOTREAD;
    }
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CTempoTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CTempoTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack
HRESULT STDMETHODCALLTYPE CTempoTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(IDirectMusicTrack::IsParamSupported);
	V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
	    if( m_fActive )
	    {
		    if( rguid == GUID_TempoParam ) return S_OK;
            if( rguid == GUID_PrivateTempoParam ) return S_OK;
#ifdef DXAPI
		    if( rguid == GUID_DisableTempo ) return S_OK;
		    if( rguid == GUID_EnableTempo ) return DMUS_E_TYPE_DISABLED;
#endif
	    }
	    else
	    {
		    if( rguid == GUID_TempoParam ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_PrivateTempoParam ) return DMUS_E_TYPE_DISABLED;
#ifdef DXAPI
		    if( rguid == GUID_EnableTempo ) return S_OK;
		    if( rguid == GUID_DisableTempo ) return DMUS_E_TYPE_DISABLED;
#endif
	    }
    }
    else
    {
		if ( rguid == GUID_TempoParam ) return S_OK;
        if ( rguid == GUID_PrivateTempoParam ) return S_OK;
#ifdef DXAPI
        if ( rguid == GUID_DisableTempo ) return S_OK;
        if ( rguid == GUID_EnableTempo ) return S_OK;
#endif
    }

	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTempoTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CTempoTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	TempoStateData* pStateData;
	pStateData = new TempoStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->fActive = m_fActive;
    }
    else
    {
        pStateData->fActive = ((dwFlags & DMUS_SEGF_CONTROL) ||
            !(dwFlags & DMUS_SEGF_SECONDARY));
    }
	pStateData->dwVirtualTrackID = dwTrackID;
	pStateData->pPerformance = pPerformance; // weak reference, no addref.
	pStateData->pSegState = pSegmentState; // weak reference, no addref.
	pStateData->pCurrentTempo = m_TempoEventList.GetHead();
	pStateData->dwValidate = m_dwValidate;
	return S_OK;
}

HRESULT CTempoTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(TempoStateData));
		TempoStateData* pSD = (TempoStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

STDMETHODIMP CTempoTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}

STDMETHODIMP CTempoTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
	DWORD dwFlags,	
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,	
	DWORD dwVirtualID)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	ENTER_CRITICAL_SECTION(&m_CrSec);
    HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CTempoTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	HRESULT	hr = DMUS_S_END;
	IDirectMusicGraph* pGraph = NULL;
	TempoStateData* pSD = (TempoStateData*)pStateData;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	// if pSD->pCurrentTempo is NULL, and we're in a normal Play call (dwFlags is 0)
	// this means that we either have no events, or we got to the end of the event
	// list previously. So, it's safe to just return.
	if( (pSD->pCurrentTempo == NULL) && (dwFlags == 0) )
	{
        return S_FALSE;
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		pSD->dwValidate = m_dwValidate;
		pSD->pCurrentTempo = NULL;
	}
	if (!pSD->pCurrentTempo)
	{
		pSD->pCurrentTempo = m_TempoEventList.GetHead();
	}
	if (!pSD->pCurrentTempo)
	{
        return DMUS_S_END;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->mtPrevEnd != mtStart ))
	{
		TempoStateData tempData;
		BOOL fFlag = TRUE;
		tempData = *pSD; // put this in so we can use Seek in other functions such as GetParam
		if( !fSeek && (dwFlags & DMUS_TRACKF_DIRTY ))
		{
			fFlag = FALSE;
		}
		Seek( &tempData, mtStart, fFlag );
		*pSD = tempData;
	}
	pSD->mtPrevEnd = mtEnd;

	if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for (; pSD->pCurrentTempo; pSD->pCurrentTempo = pSD->pCurrentTempo->GetNext())
	{
		DMUS_IO_TEMPO_ITEM& rTempoEvent = pSD->pCurrentTempo->GetItemValue();
		if( rTempoEvent.lTime >= mtEnd )
		{
			// this time is in the future. Return now to retain the same
			// seek pointers for next time.
			hr = S_OK;
			break;
		}
		if( rTempoEvent.lTime < mtStart )
		{
			if( dwFlags & DMUS_TRACKF_FLUSH )
			{
				// this time is in the past, and this call to Play is in response to an
				// invalidate. We don't want to replay stuff before the start time.
				continue;
			}
			else if( !( dwFlags & DMUS_TRACKF_START) && !(dwFlags & DMUS_TRACKF_SEEK) )
			{
				// we really only want to play events earlier than mtStart on account
				// of a START or SEEK (that isn't a FLUSH.)
				continue;
			}
		}
		if( pSD->fActive )
		{
			DMUS_TEMPO_PMSG* pTempo;
			if( SUCCEEDED( pSD->pPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
				(DMUS_PMSG**)&pTempo )))
			{
				if( rTempoEvent.lTime < mtStart )
				{
					// this only happens in the case where we've puposefully seeked
					// and need to time stamp this event with the start time
                    if (fClockTime)
                    {
                        pTempo->rtTime = (mtStart * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
					    pTempo->mtTime = mtStart + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
				}
				else
				{
                    if (fClockTime)
                    {
                        pTempo->rtTime = (rTempoEvent.lTime  * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
					    pTempo->mtTime = rTempoEvent.lTime + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
				}
				pTempo->dblTempo = rTempoEvent.dblTempo;
				pTempo->dwVirtualTrackID = pSD->dwVirtualTrackID;
				pTempo->dwType = DMUS_PMSGT_TEMPO;
				pTempo->dwGroupID = 0xffffffff;
				if( pGraph )
				{
					pGraph->StampPMsg( (DMUS_PMSG*)pTempo );
				}
				if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pTempo )))
				{
					pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pTempo );
				}
			}
		}
	}
	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

// if fGetPrevious is TRUE, seek to the event prior to mtTime. Otherwise, seek to
// the event on or after mtTime
HRESULT CTempoTrack::Seek( 
    /* [in] */ TempoStateData *pSD,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
	TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pSD->pCurrentTempo;
	if (!pScan)
	{
		pScan = m_TempoEventList.GetHead();
	}
	if (!pScan)
	{
		return S_FALSE;
	}
	// if the event's time is on or past mtTime, we need to go to the beginning
	if (pScan->GetItemValue().lTime >= mtTime)
	{
		pScan = m_TempoEventList.GetHead();
	}
	pSD->pCurrentTempo = pScan;
	for (; pScan; pScan = pScan->GetNext())
	{
		if (pScan->GetItemValue().lTime >= mtTime)
		{
			if (!fGetPrevious)
			{
				pSD->pCurrentTempo = pScan;
			}
			break;
		}
		pSD->pCurrentTempo = pScan;
	}
	return S_OK;
}

STDMETHODIMP CTempoTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CTempoTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{    
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
	return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}


HRESULT CTempoTrack::GetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(IDirectMusicTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rguid);

    HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    if( NULL == pData )
    {
        return E_POINTER;
    }
    if( rguid == GUID_PrivateTempoParam )
    {
        DMUS_TEMPO_PARAM TempoData;
        PrivateTempo* pPrivateTempoData = (PrivateTempo*)pData;
        hr = GetParam(GUID_TempoParam, mtTime, pmtNext, (void*)&TempoData);
        if (hr == S_OK)
        {
            pPrivateTempoData->dblTempo = TempoData.dblTempo;
            pPrivateTempoData->mtTime = 0; // must be set by the caller
            pPrivateTempoData->mtDelta = TempoData.mtTime;
            pPrivateTempoData->fLast = (pmtNext && !*pmtNext);
        }
        else if (hr == DMUS_E_NOT_FOUND) // the tempo track was empty
        {
            pPrivateTempoData->fLast = true;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if( !m_fActive )
        {
            return DMUS_E_TYPE_DISABLED;
        }
        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
        TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
        TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = pScan;
        if (!pScan)
        {
            return DMUS_E_NOT_FOUND;
        }
        for (; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().lTime > mtTime)
            {
                break;
            }
            pPrevious = pScan;
        }
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pPrevious->GetItemValue();
        pTempoData->dblTempo = rTempoEvent.dblTempo;
        pTempoData->mtTime = rTempoEvent.lTime - mtTime;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        if (pScan)
        {
            DMUS_IO_TEMPO_ITEM& rNextTempoEvent = pScan->GetItemValue();
            if (pmtNext)
            {
                *pmtNext = rNextTempoEvent.lTime - mtTime;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Q: if all tracks are time-stamped, why do we need mtTime?
HRESULT CTempoTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
    V_INAME(IDirectMusicTrack::SetParam);
    V_REFGUID(rguid);

    ENTER_CRITICAL_SECTION(&m_CrSec);

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;
#ifdef DXAPI
    if( rguid == GUID_DisableTempo )
    {
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_EnableTempo )
    {
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else
#endif
    if( rguid == GUID_TempoParam )
    {
        if (!m_fActive)
        {   // Oops, app intentionally disabled tempo.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( NULL == pData )
            {
                LeaveCriticalSection(&m_CrSec);
                return E_POINTER;
            }
            DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
            TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
            TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().lTime >= mtTime)
                {
                    break;
                }
                pPrevious = pScan;
            }
            // Make a new DMUS_IO_TEMPO_ITEM and insert it after pPrevious
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (!pNew)
            {
                LEAVE_CRITICAL_SECTION(&m_CrSec);
                return E_OUTOFMEMORY;
            }
            DMUS_IO_TEMPO_ITEM& rTempoEvent = pNew->GetItemValue();
            rTempoEvent.dblTempo = pTempoData->dblTempo;
            /*
            // I believe the fix for 204160 was supposed to change this line to what 
            // follows the comment.  RSW
            rTempoEvent.lTime = pTempoData->mtTime;
            */
            rTempoEvent.lTime = mtTime;
            if (pPrevious)
            {
                pNew->SetNext(pScan);
                pPrevious->SetNext(pNew);
            }
            else
            {
                m_TempoEventList.AddHead(pNew);
            }
            if (pScan && pScan->GetItemValue().lTime == mtTime)
            {
                // remove it
                pNew->SetNext(pScan->GetNext());
                pScan->SetNext(NULL);
                delete pScan;
            }
            m_dwValidate++;
            hr = S_OK;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	if(mtStart < 0 )
	{
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION(&m_CrSec);

    CTempoTrack *pDM;
    NEWCATCH(pDM,CTempoTrack(*this, mtStart, mtEnd))
	LEAVE_CRITICAL_SECTION(&m_CrSec);
    if (pDM == NULL) 
    {
        return E_OUTOFMEMORY;
    }
	return pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
}

STDMETHODIMP CTempoTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CTempoTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	V_INAME(IDirectMusicTrack::Join);
	V_INTERFACE(pNewTrack);
	V_INTERFACE_OPT(pContext);
	V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CrSec);

	if (ppResultTrack)
	{
		hr = Clone(0, mtJoin, ppResultTrack);
		if (SUCCEEDED(hr))
		{
			hr = ((CTempoTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
		}
	}
	else
	{
		hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
	}

	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CTempoTrack::JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
	CTempoTrack* pOtherTrack = (CTempoTrack*)pNewTrack;
	TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pOtherTrack->m_TempoEventList.GetHead();
	for (; pScan; pScan = pScan->GetNext())
	{
		DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
		TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
		if (pNew)
		{
			DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
			rNew.lTime = rScan.lTime + mtJoin;
			rNew.dblTempo = rScan.dblTempo;
			m_TempoEventList.AddTail(pNew);
		}
		else
		{
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\tsigtrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// TimeSigTrk.cpp : Implementation of CTimeSigTrack
#include "pchime.h"
/*
#include "dmime.h"
#include "TSigTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert
*/
CTimeSigItem::CTimeSigItem()

{ 
    m_TimeSig.lTime = 0;
    m_TimeSig.bBeatsPerMeasure = 0; 
    m_TimeSig.bBeat = 0;
    m_TimeSig.wGridsPerBeat = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack

void CTimeSigTrack::Construct()
{
    IncrementDLLCount();

	m_cRef = 0;
    m_fCSInitialized = FALSE;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
	m_fNotificationMeasureBeat = FALSE;
}

CTimeSigTrack::CTimeSigTrack() : m_MemTrack(DMTRACK_TIMESIG_TRACK)
{
	Construct();
	m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTimeSigTrack::CTimeSigTrack(
		CTimeSigTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : m_MemTrack(DMTRACK_TIMESIG_TRACK)
{
	Construct();
	m_fActive = pSourceTrack->m_fActive;
    m_fStateSetBySetParam = pSourceTrack->m_fStateSetBySetParam;
    // Clone the time signature list.
	CTimeSigItem* pScan = pSourceTrack->m_TSigEventList.GetHead();
	CTimeSigItem* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		if (pScan->m_TimeSig.lTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (pScan->m_TimeSig.lTime < mtEnd)
		{
			if (pScan->m_TimeSig.lTime == mtStart)
			{
				pPrevious = NULL;
			}
			CTimeSigItem* pNew = new CTimeSigItem;
			if (pNew)
			{
				pNew->m_TimeSig = pScan->m_TimeSig;
				pNew->m_TimeSig.lTime = pScan->m_TimeSig.lTime - mtStart;
				m_TSigEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_TSigEventList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPrevious)
	{
		CTimeSigItem* pNew = new CTimeSigItem;
		if (pNew)
		{
			pNew->m_TimeSig = pPrevious->m_TimeSig;
			pNew->m_TimeSig.lTime = 0;
			m_TSigEventList.AddHead(pNew);
		}
	}
}

void CTimeSigTrack::Clear()

{
    CTimeSigItem* pItem;
	while( pItem = m_TSigEventList.RemoveHead() )
	{
		delete pItem;
	}
}

CTimeSigTrack::~CTimeSigTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DELETE_CRITICAL_SECTION(&m_CrSec);
    }
    DecrementDLLCount();
}

// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTimeSigTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTimeSigTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CTimeSigTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Time Signature Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | Release | Standard Release implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTimeSigTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CTimeSigTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicTimeSigTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTimeSigTrack::IsDirty()
{
	return S_FALSE;
}

/*

  @method HRESULT | ITimeSigTrack | Load |
  Call this with an IStream filled with DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain TimeSig events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TimeSigTrack is released.
*/

HRESULT CTimeSigTrack::Load( IStream* pIStream )
{
	V_INAME(CTimeSigTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	ENTER_CRITICAL_SECTION(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    { 
 		if (ckMain.ckid == DMUS_FOURCC_TIMESIG_CHUNK)
        {
            hr = LoadTimeSigList(&Parser,ckMain.cksize);
        }
        else if ((ckMain.ckid == FOURCC_LIST) && 
            (ckMain.fccType == DMUS_FOURCC_TIMESIGTRACK_LIST))
        {
            Clear();
	        RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
		        switch(ckNext.ckid)
		        {
                case DMUS_FOURCC_TIMESIG_CHUNK :
                    hr = LoadTimeSigList(&Parser,ckNext.cksize);
                    break;
                }    
            }
            Parser.LeaveList();
        }
        else
        {
            Trace(1,"Error: Failure reading bad data in time signature track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
        }
    }

	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}


HRESULT CTimeSigTrack::LoadTimeSigList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;

	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
	    {
		    dwRead = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Failure reading time signature track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CTimeSigItem *pNew = new CTimeSigItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_TimeSig, dwRead )))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
				    // make sure this time sig is OK
				    if (!pNew->m_TimeSig.bBeatsPerMeasure)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeatsPerMeasure\n");
					    pNew->m_TimeSig.bBeatsPerMeasure = 4;
				    }
				    if (!pNew->m_TimeSig.bBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeat\n");
					    pNew->m_TimeSig.bBeat = 4;
				    }
				    if (!pNew->m_TimeSig.wGridsPerBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.wGridsPerBeat\n");
					    pNew->m_TimeSig.wGridsPerBeat = 4;
				    }
                    m_TSigEventList.AddHead(pNew); 
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_TSigEventList.Reverse();
            // If there is no time signature at the start, make a copy of the 
            // first time signature and stick it there. This resolves a bug in 6.1 
            // where notification messages and GetParam() were inconsistent
            // in their behavior under this circumstance. This ensures they behave
            // the same.
            CTimeSigItem *pTop = m_TSigEventList.GetHead();
            if (pTop && (pTop->m_TimeSig.lTime > 0))
            {
                CTimeSigItem *pCopy = new CTimeSigItem;
                if (pCopy)
                {
                    *pCopy = *pTop;
                    pCopy->m_TimeSig.lTime = 0;
                    m_TSigEventList.AddHead(pCopy);
                }                
            }
        }
    }
	return hr;
}

HRESULT CTimeSigTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CTimeSigTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CTimeSigTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CTimeSigTrack::IsParamSupported);
	V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
	    if( m_fActive )
	    {
		    if( rguid == GUID_TimeSignature ) return S_OK;
#ifdef DXAPI
		    if( rguid == GUID_DisableTimeSig ) return S_OK;
		    if( rguid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
#endif
	    }
	    else
	    {
		    if( rguid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
#ifdef DXAPI
		    if( rguid == GUID_EnableTimeSig ) return S_OK;
		    if( rguid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
#endif
	    }
    }
    else
    {
		if (rguid == GUID_TimeSignature ) return S_OK;
#ifdef DXAPI
		if (rguid == GUID_DisableTimeSig ) return S_OK;
		if (rguid == GUID_EnableTimeSig ) return S_OK;
#endif
    }
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTimeSigTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CTimeSigTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

    ENTER_CRITICAL_SECTION(&m_CrSec);
	CTimeSigStateData* pStateData;
	pStateData = new CTimeSigStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fActive = m_fActive;
    }
    else
    {
        pStateData->m_fActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pCurrentTSig = m_TSigEventList.GetHead();
	pStateData->m_dwValidate = m_dwValidate;
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return S_OK;
}

HRESULT CTimeSigTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(CTimeSigTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(CTimeSigStateData));
		CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

HRESULT CTimeSigTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(CTimeSigStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	ENTER_CRITICAL_SECTION(&m_CrSec);
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	DMUS_TIMESIG_PMSG* pTimeSig;
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
	MUSIC_TIME mtNotification = mtStart;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	if( pSD->m_dwValidate != m_dwValidate )
	{
		pSD->m_dwValidate = m_dwValidate;
		pSD->m_pCurrentTSig = NULL;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->m_mtPrevEnd != mtStart ))
	{
		if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
		{
			Seek( pStateData, mtStart, TRUE );
		}
		else
		{
			Seek( pStateData, mtStart, FALSE );
		}
	}
	pSD->m_mtPrevEnd = mtEnd;

	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}

	if( FAILED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->m_pCurrentTSig; pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext() )
	{
		DMUS_IO_TIMESIGNATURE_ITEM *pItem = &pSD->m_pCurrentTSig->m_TimeSig;
		if( pItem->lTime >= mtEnd )
		{
			break;
		}
		if( (pItem->lTime < mtStart) && !fSeek )
		{
			break;
		}
		if( pSD->m_fActive && !(dwFlags & DMUS_TRACKF_PLAY_OFF) && SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
			(DMUS_PMSG**)&pTimeSig )))
		{
			if( pItem->lTime < mtStart )
			{
				// this only happens in the case where we've puposefully seeked
				// and need to time stamp this event with the start time
				pTimeSig->mtTime = mtStart + mtOffset;
			}
			else
			{
				pTimeSig->mtTime = pItem->lTime + mtOffset;
			}
			pTimeSig->bBeatsPerMeasure = pItem->bBeatsPerMeasure;
			pTimeSig->bBeat = pItem->bBeat;
			pTimeSig->wGridsPerBeat = pItem->wGridsPerBeat;
			pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
			pTimeSig->dwVirtualTrackID = pSD->m_dwVirtualTrackID;
			pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
			pTimeSig->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
			}
			TraceI(3, "TimeSigtrk: TimeSig event\n");
			if(FAILED(pSD->m_pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
			}
		}
		if( pSD->m_fActive && m_fNotificationMeasureBeat && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
		{
			// create beat and measure notifications for up to this time
            if (mtNotification < pItem->lTime)
            {
			    mtNotification = NotificationMeasureBeat( mtNotification, pItem->lTime, pSD, mtOffset );
            }
        }
		// set the state data to the new beat and beats per measure, and time
		pSD->m_bBeat = pItem->bBeat;
		pSD->m_bBeatsPerMeasure = pItem->bBeatsPerMeasure;
		pSD->m_mtTimeSig = pItem->lTime;
	}
	if( pSD->m_fActive && m_fNotificationMeasureBeat && ( mtNotification < mtEnd ) 
        && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
	{
		NotificationMeasureBeat( mtNotification, mtEnd, pSD, mtOffset );
	}
	if( pGraph )
	{
		pGraph->Release();
	}

	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

// seeks to the time sig. just before mtTime.
HRESULT CTimeSigTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;

	if( m_TSigEventList.IsEmpty() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	if( pSD->m_pCurrentTSig->m_TimeSig.lTime >= mtTime )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	CTimeSigItem*	pTSig;
	for( pTSig = pSD->m_pCurrentTSig; pTSig ; pTSig = pTSig->GetNext() )
	{
		if( pTSig->m_TimeSig.lTime >= mtTime )
		{
			break;
		}
		pSD->m_pCurrentTSig = pTSig;
	}
	if( !fGetPrevious && pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext();
	}
	return S_OK;
}

HRESULT CTimeSigTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CTimeSigTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    ENTER_CRITICAL_SECTION(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_TimeSignature == rguid )
	{
		if( !m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
        else
        {
            DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
		    CTimeSigItem* pScan = m_TSigEventList.GetHead();
		    CTimeSigItem* pPrevious = pScan;
		    if (pScan)
		    {
		        for (; pScan; pScan = pScan->GetNext())
		        {
			        if (pScan->m_TimeSig.lTime > mtTime)
			        {
				        break;
			        }
			        pPrevious = pScan;
		        }
		        pTSigData->mtTime = pPrevious->m_TimeSig.lTime - mtTime;
		        pTSigData->bBeatsPerMeasure = pPrevious->m_TimeSig.bBeatsPerMeasure;
		        pTSigData->bBeat = pPrevious->m_TimeSig.bBeat;
		        pTSigData->wGridsPerBeat = pPrevious->m_TimeSig.wGridsPerBeat;
		        if (pmtNext)
		        {
			        *pmtNext = 0;
		        }
		        if (pScan)
		        {
			        if (pmtNext)
			        {
				        *pmtNext = pScan->m_TimeSig.lTime - mtTime;
			        }
		        }
		        hr = S_OK;
            }
            else
            {
                hr = DMUS_E_NOT_FOUND;
		    }
        }
	}
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CTimeSigTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	V_INAME(CTimeSigTrack::SetParam);
	V_REFGUID(rguid);
#ifdef DXAPI
	HRESULT hr = DMUS_E_SET_UNSUPPORTED;

	if( rguid == GUID_EnableTimeSig )
	{
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
		    hr = S_OK;
        }
	}
	else if( rguid == GUID_DisableTimeSig )
	{
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
		    hr = S_OK;
        }
	}
	return hr;
#else
    return DMUS_E_SET_UNSUPPORTED;
#endif
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::AddNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = TRUE;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::RemoveNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = FALSE;
		hr = S_OK;
	}
	return hr;
}

// send measure and beat notifications
MUSIC_TIME CTimeSigTrack::NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
	CTimeSigStateData* pSD, MUSIC_TIME mtOffset )
{
	DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	MUSIC_TIME mtTime;
	DWORD dwMeasure;
	BYTE bCurrentBeat;

	if( pSD->m_mtTimeSig >= mtEnd )
		return mtStart;

	if( pSD->m_mtTimeSig > mtStart )
	{
		mtStart = pSD->m_mtTimeSig;
	}

	// now actually generate the beat events.
	// Generate events that are on beat boundaries, from mtStart to mtEnd
	long lQuantize = ( DMUS_PPQ * 4 ) / pSD->m_bBeat;

	mtTime = mtStart - pSD->m_mtTimeSig;
	if( mtTime ) // 0 stays 0
	{
		// quantize to next boundary
		mtTime = ((( mtTime - 1 ) / lQuantize ) + 1 ) * lQuantize;
	}
	mtStart += mtTime - ( mtStart - pSD->m_mtTimeSig );
	
	bCurrentBeat = (BYTE)(( ( mtStart - pSD->m_mtTimeSig ) / lQuantize ) % pSD->m_bBeatsPerMeasure);
	dwMeasure = mtStart / (pSD->m_bBeatsPerMeasure * lQuantize );
	while( mtStart < mtEnd )
	{
		if( SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
			(DMUS_PMSG**)&pEvent )))
		{
			pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
			pEvent->mtTime = mtStart + mtOffset;
			pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
			pSD->m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

			pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
			pEvent->dwField1 = bCurrentBeat;
			pEvent->dwField2 = dwMeasure;
			pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
			pEvent->dwGroupID = 0xffffffff;
            pEvent->dwVirtualTrackID = pSD->m_dwVirtualTrackID;

			IDirectMusicGraph* pGraph;
			if( SUCCEEDED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
				(void**)&pGraph )))
			{
				pGraph->StampPMsg((DMUS_PMSG*) pEvent );
				pGraph->Release();
			}
			if(FAILED(pSD->m_pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
			}
		}
		bCurrentBeat++;
		if( bCurrentBeat >= pSD->m_bBeatsPerMeasure )
		{
			bCurrentBeat = 0;
			dwMeasure += 1;
		}
		mtStart += lQuantize;
	}
	return mtEnd;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	if((mtStart < 0 ) ||(mtStart > mtEnd))
	{
        Trace(1,"Error: Clone failed on time signature track because of invalid start or end time.\n");
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION(&m_CrSec);
    CTimeSigTrack *pDM;
    NEWCATCH(pDM,CTimeSigTrack(this, mtStart, mtEnd))
	LEAVE_CRITICAL_SECTION(&m_CrSec);
    if (pDM)
    {
        return pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\wavtrack.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include "pchime.h"
/*
// WavTrack.cpp : Implementation of CWavTrack
#include "dmime.h"
#include "dmperf.h"
#include "WavTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "..\dswave\dswave.h"
#include "dmsegobj.h"
#define ASSERT  assert
#include <math.h>
*/
// @doc EXTERNAL
#ifdef DXAPI
TList<TaggedWave> WaveItem::st_WaveList;
CRITICAL_SECTION WaveItem::st_WaveListCritSect;
long CWavTrack::st_RefCount = 0;
#endif

BOOL PhysicalLess(WaveItem& WI1, WaveItem& WI2)
{ 
    return WI1.m_rtTimePhysical < WI2.m_rtTimePhysical; 
}

BOOL LogicalLess(WaveItem& WI1, WaveItem& WI2)
{ 
    return WI1.m_mtTimeLogical < WI2.m_mtTimeLogical; 
}

/////////////////////////////////////////////////////////////////////////////
// CWavTrack
#ifdef DXAPI

void CWavTrack::FlushWaves()
{
    UnloadAllWaves(NULL);
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    while (!WaveItem::st_WaveList.IsEmpty())
    {
        TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.RemoveHead();
        delete pScan;
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
}

void CWavTrack::StaticInit(){
    InitializeCriticalSection(&WaveItem::st_WaveListCritSect);
}
void CWavTrack::StaticFinalize(){
    DeleteCriticalSection(&WaveItem::st_WaveListCritSect);
}

#endif

#ifdef DXAPI
HRESULT CWavTrack::UnloadAllWaves(IDirectMusicPerformance* pPerformance)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.GetHead();
    TListItem<TaggedWave>* pNext = NULL;
    for (; pScan; pScan = pNext)
    {
        pNext = pScan->GetNext();
        TaggedWave& rScan = pScan->GetItemValue();
        if (!pPerformance || rScan.m_pPerformance == pPerformance)
        {
            if (rScan.m_pPort)
            {
                if (rScan.m_pDownloadedWave)
                {
                    Trace(1, "Error: Wave was downloaded but never unloaded.\n");
                    rScan.m_pPort->UnloadWave(rScan.m_pDownloadedWave);
                    rScan.m_pDownloadedWave = NULL;
                }
                rScan.m_pPort->Release();
                rScan.m_pPort = NULL;
            }
            if (rScan.m_pPerformance)
            {
                rScan.m_pPerformance->Release();
                rScan.m_pPerformance = NULL;
            }
            if (rScan.m_pWave)
            {
                rScan.m_pWave->Release();
                rScan.m_pWave = NULL;
            }
            WaveItem::st_WaveList.Remove(pScan);
            delete pScan;
        }
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
    return hr;
}

#endif

// This SHOULD NOT be called except from a constructor.
void CWavTrack::Construct()
{
    IncrementDLLCount();

    m_fCSInitialized = FALSE;
    INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;

    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwTrackFlags = 0;
    m_dwValidate = 0;
    m_cRef = 1;
#ifdef DXAPI
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    m_fAutoDownload = FALSE;
    m_fLockAutoDownload = FALSE;
    st_RefCount++;
#endif
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    m_dwWaveItems = 0;
}

void CWavTrack::CleanUp()
{
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    if (m_pdwVariations) delete [] m_pdwVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
    m_aPChannels = NULL;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WavePartList.CleanUp();
#ifdef DXAPI
    RemoveDownloads(NULL);
#endif
}

void CWavTrack::CleanUpTempParts()
{
    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_TempWavePartList.CleanUp();
}

void CWavTrack::MovePartsToTemp()
{
    CleanUpTempParts();
    TListItem<WavePart>* pScan = m_WavePartList.RemoveHead();
    for (; pScan; pScan = m_WavePartList.RemoveHead() )
    {
        m_TempWavePartList.AddHead(pScan);
    }
}

#ifdef DXAPI
// NULL for non-streaming waves.
// For streaming waves, return the DownLoadedWave that's associated with the same wave
// with the same start offset (and remove it from the Item list so it's not returned again).
IDirectSoundDownloadedWaveP* CWavTrack::FindDownload(TListItem<WaveItem>* pItem)
{
    if (!pItem || !pItem->GetItemValue().m_pWave || !pItem->GetItemValue().m_fIsStreaming)
    {
        return NULL;
    }

    WaveItem& rWaveItem = pItem->GetItemValue();

    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan ; pScan = pScan->GetNext())
    {
        TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
        TListItem<WaveItem>* pNext = NULL;
        for (; pItemScan; pItemScan = pNext)
        {
            pNext = pItemScan->GetNext();
            WaveItem& rTempItem = pItemScan->GetItemValue();
            if (rTempItem.m_fIsStreaming &&
                rWaveItem.m_pWave == rTempItem.m_pWave &&
                rWaveItem.m_rtStartOffset == rTempItem.m_rtStartOffset)
            {
                IDirectSoundDownloadedWaveP* pReturn = rTempItem.m_pDownloadedWave; 
                if (rTempItem.m_pWave)
                {
                    rTempItem.m_pWave->Release();
                    rTempItem.m_pWave = NULL;
                }
                rTempItem.m_pDownloadedWave = NULL;
                pScan->GetItemValue().m_WaveItemList.Remove(pItemScan);
                delete pItemScan;
                return pReturn;
            }
        }
    }
    return NULL;
}


HRESULT CWavTrack::GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice)
{
    HRESULT hr = S_OK;
    TListItem<WaveDLOnPlay>* pNew = NULL;
    if (!pWaveDL || !pStateData) return E_POINTER;

    IDirectSoundDownloadedWaveP* pNewWaveDL = NULL;
    if (rItem.m_fIsStreaming)
    {
        bool fPair = false;
        TListItem<WavePair>* pPair = m_WaveList.GetHead();
        for (; pPair; pPair = pPair->GetNext())
        {
            if (pWaveDL == pPair->GetItemValue().m_pWaveDL)
            {
                if (!pNewWaveDL)
                {
                    // download a new one (to be returned), and put it in the state data's list.
                    if (FAILED(hr = pPortP->DownloadWave( pWave, &pNewWaveDL, rtStartOffset )))
                    {
                        return hr;
                    }
                    pNew = new TListItem<WaveDLOnPlay>;
                    if (!pNew)
                    {
                        pPortP->UnloadWave(pNewWaveDL);
                        return E_OUTOFMEMORY;
                    }
                    pNew->GetItemValue().m_pWaveDL = pNewWaveDL;
                    pNew->GetItemValue().m_pPort = pPortP;
                    pPortP->AddRef();
                    pStateData->m_WaveDLList.AddHead(pNew);
                }
                if (pStateData == pPair->GetItemValue().m_pStateData)
                {
                    fPair = true;
                    break;
                }
            }
        }
        if (!fPair)
        {
            // create one and add it to m_WaveList
            pPair = new TListItem<WavePair>;
            if (!pPair)
            {
                return E_OUTOFMEMORY;
            }
            pPair->GetItemValue().m_pStateData = pStateData;
            pPair->GetItemValue().m_pWaveDL = pWaveDL;
            pWaveDL->AddRef();
            m_WaveList.AddHead(pPair);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!pNewWaveDL) pNewWaveDL = pWaveDL;
        hr = pPortP->AllocVoice(pNewWaveDL, 
            dwMChannel, dwGroup, rtStartOffset, 
            rItem.m_dwLoopStart, rItem.m_dwLoopEnd,
            ppVoice);
        if (SUCCEEDED(hr))
        {
            if (pNew)
            {
                pNew->GetItemValue().m_pVoice = *ppVoice;
            }
            else
            {
                if (pStateData->m_apVoice[rItem.m_dwVoiceIndex])
                {
                    pStateData->m_apVoice[rItem.m_dwVoiceIndex]->Release();
                }
                pStateData->m_apVoice[rItem.m_dwVoiceIndex] = *ppVoice;
            }
        }
    }
    return hr;
}

void CWavTrack::RemoveDownloads(WaveStateData* pStateData)
{
    TListItem<WavePair>* pPair = m_WaveList.GetHead();
    TListItem<WavePair>* pNextPair = NULL;
    for (; pPair; pPair = pNextPair)
    {
        pNextPair = pPair->GetNext();
        if (!pStateData || pPair->GetItemValue().m_pStateData == pStateData)
        {
            m_WaveList.Remove(pPair);
            delete pPair;
        }
    }

    if (pStateData)
    {
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!pStateData->m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = pStateData->m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }
}
#endif

CWavTrack::CWavTrack() : CMemTrack(DMTRACK_WAVE_TRACK)
{
    Construct();
}

CWavTrack::CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : CMemTrack(DMTRACK_WAVE_TRACK)
{
    Construct();
    CopyParts(rTrack.m_WavePartList, mtStart, mtEnd);
    m_lVolume = rTrack.m_lVolume;
    m_dwTrackFlags = rTrack.m_dwTrackFlags;
}

HRESULT CWavTrack::InitTrack(DWORD dwPChannels)
{
    HRESULT hr = S_OK;

    m_dwPChannelsUsed = dwPChannels;
    m_dwWaveItems = 0;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (!m_aPChannels) hr = E_OUTOFMEMORY;
        else if (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL)
        {
            m_pdwVariations = new DWORD[m_dwPChannelsUsed];
            m_pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
            if (!m_pdwVariations || !m_pdwRemoveVariations) hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pScan = m_WavePartList.GetHead();
            for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
            {
                m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
                if (m_pdwVariations) m_pdwVariations[dw] = 0;
                if (m_pdwRemoveVariations) m_pdwRemoveVariations[dw] = 0;
#ifdef DXAPI
                TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
                for (; pItemScan; pItemScan = pItemScan->GetNext())
                {
                    pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                    m_dwWaveItems++;
                }
#endif
            }
        }
        else CleanUp();
    }
    return hr;
}

CWavTrack::~CWavTrack()
{
    if (m_fCSInitialized)
    {
        CleanUpTempParts();
        CleanUp();
#ifdef DXAPI
        st_RefCount--;
        if (st_RefCount <= 0)
        {
            // if there's still something in the wave list, it means there are waves that 
            // haven't been unloaded; but at this point we've gotten rid of all wave tracks,
            // so unload and release everything now.
            UnloadAllWaves(NULL);
            WaveItem::st_WaveList.CleanUp();
        }
#endif
        DELETE_CRITICAL_SECTION(&m_CrSec);
    }

    DecrementDLLCount();
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CWavTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CWavTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } 
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } 
    else if (iid == IID_IPrivateWaveTrack)
    {
        *ppv = static_cast<IPrivateWaveTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CWavTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicWaveTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CWavTrack::IsDirty()
{
    return S_FALSE;
}

HRESULT CWavTrack::Load( IStream* pIStream )
{
    V_INAME(CWavTrack::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    ENTER_CRITICAL_SECTION(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_WAVETRACK_LIST))
    {
        MovePartsToTemp();
        CleanUp();
        RIFFIO ckList;
        Parser.EnterList(&ckList);
        while (Parser.NextChunk(&hr))
        {
            if ( ckList.ckid  == DMUS_FOURCC_WAVETRACK_CHUNK )
            {
                DMUS_IO_WAVE_TRACK_HEADER iTrackHeader;

                // Read in the item's header structure
                hr = Parser.Read( &iTrackHeader, sizeof( DMUS_IO_WAVE_TRACK_HEADER ) );

                if( SUCCEEDED( hr ) )
                {
                    m_lVolume = iTrackHeader.lVolume;
                    m_dwTrackFlags = iTrackHeader.dwFlags;
                }
            }
            else if (( ckList.ckid == FOURCC_LIST) && 
                (ckList.fccType == DMUS_FOURCC_WAVEPART_LIST))
            {
                TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
                if( !pNewPart )
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = pNewPart->GetItemValue().Load( &Parser );
                    if( FAILED ( hr ) )
                    {
                        delete pNewPart;
                    }
                    else
                    {
                        InsertByAscendingPChannel( pNewPart );
                    }
                }
            }
        }
        Parser.LeaveList();
    }
    Parser.LeaveList();
    if (SUCCEEDED(hr))
    {
        hr = InitTrack(m_WavePartList.GetCount());
    }
    if (SUCCEEDED(hr))
    {
#ifdef DXAPI
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (; pScan ; pScan = pScan->GetNext())
        {
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_pDownloadedWave = FindDownload(pItemScan);
            }
        }
#endif
    }
    else CleanUp();

    CleanUpTempParts();
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}
    
HRESULT CWavTrack::CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WavePart>* pScan = rParts.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        TListItem<WavePart>* pNew = new TListItem<WavePart>;
        if (pNew)
        {
            WavePart& rNew = pNew->GetItemValue();
            rNew.m_dwLockToPart = rScan.m_dwLockToPart;
            rNew.m_dwPChannel = rScan.m_dwPChannel;
            rNew.m_dwIndex = rScan.m_dwIndex;
            rNew.m_dwPChannelFlags = rScan.m_dwPChannelFlags;
            rNew.m_lVolume = rScan.m_lVolume;
            rNew.m_dwVariations = rScan.m_dwVariations;
            if (SUCCEEDED(hr = rNew.CopyItems(rScan.m_WaveItemList, mtStart, mtEnd)))
            {
                m_WavePartList.AddHead(pNew);
            }
            else
            {
                delete pNew;
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WavePartList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

void CWavTrack::InsertByAscendingPChannel( TListItem<WavePart>* pPart )
{
    if (pPart)
    {
        DWORD dwPChannel = pPart->GetItemValue().m_dwPChannel;
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        TListItem<WavePart>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext())
        {
            if (dwPChannel < pScan->GetItemValue().m_dwPChannel)
            {
                break;
            }
            pPrevious = pScan;
        }
        if (pPrevious)
        {
            pPart->SetNext(pScan);
            pPrevious->SetNext(pPart);
        }
        else
        {
            m_WavePartList.AddHead(pPart);
        }
    }
}

HRESULT CWavTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::IsParamSupported( 
    REFGUID rguidType)  // @parm The guid identifying the type of data to check.
{
#ifdef DXAPI
    if(rguidType == GUID_Download ||
       rguidType == GUID_DownloadToAudioPath ||
       rguidType == GUID_UnloadFromAudioPath ||
       rguidType == GUID_WavePlayParams ||
       rguidType == GUID_Enable_Auto_Download ||
       rguidType == GUID_Disable_Auto_Download ||
       rguidType == GUID_Unload )
#else
    if (rguidType == GUID_WavePlayParams)
#endif
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CWavTrack::Init( 
    IDirectMusicSegment *pSegment)  // @parm Pointer to the Segment to which this Track belongs.
{
    ENTER_CRITICAL_SECTION(&m_CrSec);
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    CSegment* pCSegment = NULL;
    bool fSortLogical = false;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment, (void**)&pCSegment)))
    {
        DWORD dwGroupBits = 0;
        if (FAILED(pSegment->GetTrackGroup( this, &dwGroupBits )))
        {
            dwGroupBits = 0xffffffff;
        }
        DWORD dwConfig = 0;
        if (SUCCEEDED(pCSegment->GetTrackConfig(CLSID_DirectMusicWaveTrack, dwGroupBits, 0, &dwConfig)))
        {
            if ( !(dwConfig & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) )
            {
                fSortLogical = true;
            }
        }
        pCSegment->Release();
    }
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (fSortLogical)
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(LogicalLess);
        }
        else
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(PhysicalLess);
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CWavTrack::InitPlay( 
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf, // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,     // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicSegmentState8 *pSegSt8 = NULL;

    ENTER_CRITICAL_SECTION(&m_CrSec);
    WaveStateData* pStateData = new WaveStateData;
    if( NULL == pStateData ) 
    {
        goto ON_END;
    }
#ifdef DXAPI
    // Get the audiopath being used by our segment state and save it in our state data.
    hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
    if (SUCCEEDED(hr))
    {
        hr = pSegSt8->GetObjectInPath(
                        0,                          // pchannel doesn't apply
                        DMUS_PATH_AUDIOPATH,        // get the audiopath
                        0,                          // buffer index doesn't apply
                        CLSID_NULL,                 // clsid doesn't apply
                        0,                          // there should be only one audiopath
                        IID_IDirectMusicAudioPath,
                        reinterpret_cast<void**>(&pStateData->m_pAudioPath));

        // If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
        // pAudioPath stays NULL and we'll play our triggered segments on the general performance.
        if (hr == DMUS_E_NOT_FOUND)
            hr = S_OK;
        pSegSt8->Release();
    }
    pStateData->m_pPerformance = pPerf;
#endif
    {
        *ppStateData = pStateData;
#ifdef DXAPI
        StatePair SP(pSegmentState, pStateData);
        TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
        if (!pPair)
        {
            goto ON_END;
        }
        m_StateList.AddHead(pPair);
#endif
    }
    SetUpStateCurrentPointers(pStateData);

    // Set up arrays for variations
    if (m_dwPChannelsUsed)
    {
        pStateData->pdwVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwVariations)
        {
            goto ON_END;
        }
        pStateData->pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwRemoveVariations)
        {
            goto ON_END;
        }
        for (DWORD dw = 0; dw < m_dwPChannelsUsed; dw++)
        {
            if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
                 m_pdwVariations && 
                 m_pdwRemoveVariations )
            {
                pStateData->pdwVariations[dw] = m_pdwVariations[dw];
                pStateData->pdwRemoveVariations[dw] = m_pdwRemoveVariations[dw];
            }
            else
            {
                pStateData->pdwVariations[dw] = 0;
                pStateData->pdwRemoveVariations[dw] = 0;
            }
        }
    }

    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }
    hr = S_OK;
#ifdef DXAPI
    // for auditioning variations...
    pStateData->InitVariationInfo(m_dwVariation, m_dwPart, m_dwIndex, m_dwLockID, m_fAudition);
    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerf->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_fAutoDownload = fGlobal, 
            // but that's bitten markburt before, so I'm being paranoid today.
            if( fGlobal )
            {
                m_fAutoDownload = TRUE;
            }
            else
            {
                m_fAutoDownload = FALSE;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_fAutoDownload = FALSE;
    }
    // Call SetParam to download all waves used by the track
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_fAutoDownload)
    {
        hr = SetParam(GUID_Download, 0, (void *)pPerf);
        if (FAILED(hr)) goto ON_END;
    }

    ///////////////// pre-allocate voices for all waves in the track ////////////////
    pStateData->m_dwVoices = m_dwWaveItems;
    pStateData->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
    if (!pStateData->m_apVoice)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
        {
            pStateData->m_apVoice[dw] = NULL;
        }
        Seek( pSegmentState, pPerf, dwTrackID, pStateData, 0, TRUE, 0, FALSE );
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        DWORD dwPChannel = 0;
        for( DWORD dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            long lPartVolume = 0;
            if( pPart )
            {
                WavePart& rPart = pPart->GetItemValue();
                dwPChannel = rPart.m_dwPChannel;
                lPartVolume = rPart.m_lVolume;
            }
            if( pStateData->apCurrentWave )
            {
                for( ; pStateData->apCurrentWave[dwIndex]; 
                    pStateData->apCurrentWave[dwIndex] = pStateData->apCurrentWave[dwIndex]->GetNext() )
                {
                    WaveItem& rItem = pStateData->apCurrentWave[dwIndex]->GetItemValue();
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    HRESULT hr = rItem.PChannelInfo(pPerf, pStateData->m_pAudioPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave && 
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                if (rItem.m_dwVoiceIndex == 0xffffffff)
                                {
                                    hr = DMUS_E_NOT_INIT;
                                    TraceI(0, "Voice index not initialized!\n");
                                }
                                else if(!rItem.m_fIsStreaming || (rItem.m_fIsStreaming && rItem.m_fUseNoPreRoll == FALSE))
                                {
                                    IDirectMusicVoiceP *pVoice = NULL;
                                    hr = GetDownload(
                                        rDLWave.m_pDownloadedWave,
                                        pStateData,
                                        pPortP,
                                        rDLWave.m_pWave,
                                        rtStartOffset,
                                        rItem,
                                        dwMChannel, dwGroup,
                                        &pVoice);
                                }
                            }
                            else
                            {
                                hr = DMUS_E_NOT_INIT;
                                Trace(1, "Error: Attempt to play wave that has not been downloaded.\n");
                                
                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
                            // Release the private interface
                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
            if( pPart )
            {
                pPart = pPart->GetNext();
            }
        }
    }
#endif
ON_END:
    if (FAILED(hr) && pStateData)
    {
        delete pStateData;
        pStateData = NULL;
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success. 
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CWavTrack::EndPlay( 
    void *pStateData)   // @parm The state data returned from <om .InitPlay>.
{
    ENTER_CRITICAL_SECTION(&m_CrSec);

    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(WaveStateData));
        WaveStateData* pSD = (WaveStateData*)pStateData;
#ifdef DXAPI
        RemoveDownloads(pSD);
        if(m_fAutoDownload)
        {
            SetParam(GUID_Unload, 0, (void *)pSD->m_pPerformance);
        }
        for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
        {
            StatePair& rPair = pScan->GetItemValue();
            if (pSD == rPair.m_pStateData)
            {
                rPair.m_pSegState = NULL;
                rPair.m_pStateData = NULL;
                m_StateList.Remove(pScan);
                delete pScan;
                break;
            }
        }
#endif
        delete pSD;
    }

    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return S_OK;
}

void CWavTrack::SetUpStateCurrentPointers(WaveStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentWave )
        {
            delete [] pStateData->apCurrentWave;
            pStateData->apCurrentWave = NULL;
        }
        pStateData->apCurrentWave = new TListItem<WaveItem>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentWave )
        {
            memset( pStateData->apCurrentWave, 0, sizeof(TListItem<WavePart>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

REFERENCE_TIME ConvertOffset(REFERENCE_TIME rtOffset, long lPitch)
{
    if (lPitch)
    {
        double dblPitch = (double) lPitch;
        double dblStart = (double) rtOffset;
        dblStart *= pow(2, (dblPitch / 1200.0));
        rtOffset = (REFERENCE_TIME) dblStart;
    }
    return rtOffset;
}

STDMETHODIMP CWavTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CrSec);
    BOOL fClock = (dwFlags & DMUS_TRACKF_CLOCK) ? TRUE : FALSE;
/*    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else*/
    {
        hr = Play(pStateData, rtStart, rtEnd, rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, fClock);
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CWavTrack::Play( 
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    ENTER_CRITICAL_SECTION(&m_CrSec);
    HRESULT hr = Play(pStateData, mtStart, mtEnd, mtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, FALSE);
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

// BUGBUG go through all the times and make sure music time/reference time stuff
// all makes sense

HRESULT CWavTrack::Play( 
    void *pStateData,   
    REFERENCE_TIME rtStart, 
    REFERENCE_TIME rtEnd,
    //MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,      
    IDirectMusicPerformance* pPerf, 
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    WaveStateData* pSD = (WaveStateData*)pStateData;
    if ( dwFlags & DMUS_TRACKF_LOOP )
    {
        REFERENCE_TIME rtPerfStart = rtStart + rtOffset;
        MUSIC_TIME mtPerfStart = 0;
        if (fClockTime)
        {
            pPerf->ReferenceToMusicTime(rtPerfStart, &mtPerfStart);
        }
        else
        {
            mtPerfStart = (MUSIC_TIME)rtPerfStart;
        }
        CPerformance* pCPerf = NULL;
        if (SUCCEEDED(pPerf->QueryInterface(IID_CPerformance, (void**)&pCPerf)))
        {
            pCPerf->FlushVirtualTrack(dwVirtualID, mtPerfStart, FLUSH_ON_REPEAT);
            pCPerf->Release();
        }
        pSD->m_fLoop = true;
    }
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    if ( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
    {
        pSD->rtNextVariation = 0;
    }

    // if we're sync'ing variations to the pattern track, get the current variations
    if ( (m_dwTrackFlags & DMUS_WAVETRACKF_SYNC_VAR) && 
         (!pSD->rtNextVariation || (rtStart <= pSD->rtNextVariation && rtEnd > pSD->rtNextVariation)) )
    {
        hr = SyncVariations(pPerf, pSD, rtStart, rtOffset, fClockTime);
    }
    else if (dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP))
    {
        hr = ComputeVariations(pSD);
    }

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }
    if( pSD->dwValidate != m_dwValidate )
    {
#ifdef DXAPI
        if (pSD->m_apVoice)
        {
            for (DWORD dw = 0; dw < pSD->m_dwVoices; dw++)
			{
				if (pSD->m_apVoice[dw])
				{
					pSD->m_apVoice[dw]->Release();
				}
            }
            delete [] pSD->m_apVoice;
        }
        pSD->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
        if (!pSD->m_apVoice)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
            {
                pSD->m_apVoice[dw] = NULL;
            }
        }
        pSD->m_dwVoices = m_dwWaveItems;
#endif
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, TRUE, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, FALSE, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;

    TListItem<WavePart>* pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        long lPartVolume = 0;
        if( pPart )
        {
            WavePart& rPart = pPart->GetItemValue();
            dwPChannel = rPart.m_dwPChannel;
            lPartVolume = rPart.m_lVolume;
        }
        if( pSD->apCurrentWave )
        {
            for( ; pSD->apCurrentWave[dwIndex]; 
                pSD->apCurrentWave[dwIndex] = pSD->apCurrentWave[dwIndex]->GetNext() )
            {
                DWORD dwItemVariations = 0;
                WaveItem& rItem = pSD->apCurrentWave[dwIndex]->GetItemValue();
                REFERENCE_TIME rtTime = fClockTime ? rItem.m_rtTimePhysical : rItem.m_mtTimeLogical;
                if( rtTime >= rtEnd )
                {
                    break;
                }
                if (pPart)
                {
                    dwItemVariations = pSD->Variations(pPart->GetItemValue(), dwIndex) & rItem.m_dwVariations;
                }
                MUSIC_TIME mtTime = 0;
                MUSIC_TIME mtOffset = 0;
                if (fClockTime)
                {
                    MUSIC_TIME mtPerfTime = 0;
                    pPerf->ReferenceToMusicTime(rtOffset, &mtOffset);
                    pPerf->ReferenceToMusicTime(rItem.m_rtTimePhysical + rtOffset, &mtPerfTime);
                    mtTime = mtPerfTime - mtOffset;
                }
                else
                {
                    mtTime = rItem.m_mtTimeLogical;
                    mtOffset = (MUSIC_TIME)rtOffset;
                }
                m_PChMap.GetInfo( dwPChannel, mtTime, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, FALSE );
#ifdef DXAPI
                if( !fMute && dwItemVariations )
                {
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    HRESULT hr = rItem.PChannelInfo(pPerf, pSD->m_pAudioPath, dwMutePChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave && 
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                REFERENCE_TIME rtDurationMs = 0;
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                REFERENCE_TIME rtDuration = rItem.m_rtDuration;
                                DMUS_WAVE_PMSG* pWave;
                                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_WAVE_PMSG),
                                    (DMUS_PMSG**)&pWave )))
                                {
                                    pWave->dwType = DMUS_PMSGT_WAVE;
                                    pWave->dwPChannel = dwMutePChannel;
                                    pWave->dwVirtualTrackID = dwVirtualID;
                                    pWave->dwGroupID = pSD->dwGroupBits;
                                    if (fClockTime)
                                    {
                                        REFERENCE_TIME rtPlay = rItem.m_rtTimePhysical;
                                        rtDuration -= ConvertOffset(rtStartOffset, -rItem.m_lPitch);
                                        if (rtPlay < rtStart)
                                        {
                                            REFERENCE_TIME rtPlayOffset = ConvertOffset(rtStart - rtPlay, rItem.m_lPitch);
                                            rtStartOffset += rtPlayOffset;
                                            rtDuration -= (rtStart - rtPlay);
                                            rtPlay = rtStart;
                                        }
                                        pWave->rtTime = rtPlay + rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                        pWave->lOffset = 0;
                                        rtDurationMs = rtDuration / REF_PER_MIL;
                                    }
                                    else
                                    {
                                        REFERENCE_TIME rtPlay = 0;
                                        MUSIC_TIME mtPlay = (MUSIC_TIME)rItem.m_rtTimePhysical;
                                        pPerf->MusicToReferenceTime(mtPlay + (MUSIC_TIME)rtOffset, &rtPlay);
                                        MUSIC_TIME mtRealPlay = 0;
                                        pPerf->ReferenceToMusicTime(rtPlay + rtStartOffset, &mtRealPlay);
                                        if (mtRealPlay > rtOffset + mtPlay)
                                        {
                                            rtDuration -= ConvertOffset(mtRealPlay - (rtOffset + mtPlay), -rItem.m_lPitch);

                                        }
                                        if (mtPlay < (MUSIC_TIME) rtStart)
                                        {
                                            // Calculate distance from wave start to segment start, but begin
                                            // the calculation at segment start to avoid strangeness
                                            // when attempting to do conversions at times earlier than
                                            // segment start.
                                            REFERENCE_TIME rtRefStartPlus = 0;
                                            REFERENCE_TIME rtRefPlayPlus = 0;
                                            MUSIC_TIME mtNewDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rtStart + (MUSIC_TIME)rtOffset, &rtRefStartPlus);
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + mtPlay + (MUSIC_TIME)rtOffset, &rtRefPlayPlus);
                                            rtStartOffset += ConvertOffset((rtRefStartPlus - rtRefPlayPlus), rItem.m_lPitch);
                                            mtPlay = (MUSIC_TIME) rtStart;
                                            REFERENCE_TIME rtRealDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rItem.m_rtDuration + (MUSIC_TIME)rtOffset, &rtRealDuration);
                                            pPerf->ReferenceToMusicTime(rtRealDuration - (ConvertOffset(rItem.m_rtStartOffset, -rItem.m_lPitch) + (rtRefStartPlus - rtRefPlayPlus)), &mtNewDuration);
                                            rtDuration = (REFERENCE_TIME)mtNewDuration - (rtStart + rtOffset);
                                        }
                                        pWave->mtTime = mtPlay + (MUSIC_TIME)rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_MUSICTIME;
                                        pWave->lOffset = (MUSIC_TIME)rItem.m_rtTimePhysical - rItem.m_mtTimeLogical;
                                        REFERENCE_TIME rtZero = 0;
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)rtOffset + mtPlay, &rtZero);
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)(rtDuration + rtOffset) + mtPlay, &rtDurationMs);
                                        rtDurationMs -= rtZero;
                                        rtDurationMs /= REF_PER_MIL;
                                    }
                                    // If we're either past the end of the wave, or we're within
                                    // 150 ms of the end of a looping wave (and we've just started
                                    // playback), or if this is a loop start and the wave should not 
                                    // play on loop, don't play the wave.
                                    if ( rtDurationMs <= 0 ||
                                         (rItem.m_dwLoopEnd && (dwFlags & DMUS_TRACKF_START) && rtDurationMs < 150) ||
                                         (rItem.m_dwFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlags & DMUS_TRACKF_LOOP))
                                    {
                                        pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                    }
                                    else
                                    {
                                        pWave->rtStartOffset = rtStartOffset;
                                        pWave->rtDuration = rtDuration; 
                                        pWave->lVolume = rItem.m_lVolume + lPartVolume + m_lVolume;
                                        pWave->lPitch = rItem.m_lPitch;
                                        pWave->bFlags = (BYTE)(rItem.m_dwFlags & 0xff);
                                        IDirectMusicVoiceP *pVoice = NULL;
                                        if (rItem.m_dwVoiceIndex == 0xffffffff)
                                        {
                                            hr = DMUS_E_NOT_INIT;
                                            TraceI(0, "Voice index not initialized!\n");
                                        }
                                        else
                                        {
                                            if ( pSD->m_fLoop ||
                                                 !pSD->m_apVoice[rItem.m_dwVoiceIndex] || 
                                                 rtStartOffset != rItem.m_rtStartOffset ||
                                                 dwMutePChannel != dwPChannel)
                                            {
                                                hr = GetDownload(
                                                    pDLWave->GetItemValue().m_pDownloadedWave,
                                                    pSD,
                                                    pPortP,
                                                    pDLWave->GetItemValue().m_pWave,
                                                    pWave->rtStartOffset,
                                                    rItem,
                                                    dwMChannel, dwGroup,
                                                    &pVoice);
                                            }
                                            else
                                            {
                                                pVoice = pSD->m_apVoice[rItem.m_dwVoiceIndex];
                                            }
                                        }
                                        if (SUCCEEDED(hr))
                                        {
                                            pWave->punkUser = (IUnknown*)pVoice;
                                            pVoice->AddRef();
                                            if( pGraph )
                                            {
                                                pGraph->StampPMsg( (DMUS_PMSG*)pWave );
                                            }
                                            hr = pPerf->SendPMsg( (DMUS_PMSG*)pWave );
                                        }
                                        if(FAILED(hr))
                                        {
                                            pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                        }
                                    }
                                }
                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
#else
                if( !fMute && dwItemVariations )
                {
                    REFERENCE_TIME rtDurationMs = 0;
                    REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                    REFERENCE_TIME rtDuration = rItem.m_rtDuration;
                    DMUS_WAVE_PMSG* pWave;
                    if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_WAVE_PMSG),
                        (DMUS_PMSG**)&pWave )))
                    {
                        pWave->dwType = DMUS_PMSGT_WAVE;
                        pWave->dwPChannel = dwMutePChannel;
                        pWave->dwVirtualTrackID = dwVirtualID;
                        pWave->dwGroupID = pSD->dwGroupBits;
                        if (fClockTime)
                        {
                            REFERENCE_TIME rtPlay = rItem.m_rtTimePhysical;
                            rtDuration -= ConvertOffset(rtStartOffset, -rItem.m_lPitch);
                            if (rtPlay < rtStart)
                            {
                                REFERENCE_TIME rtPlayOffset = ConvertOffset(rtStart - rtPlay, rItem.m_lPitch);
                                rtStartOffset += rtPlayOffset;
                                rtDuration -= (rtStart - rtPlay);
                                rtPlay = rtStart;
                            }
                            pWave->rtTime = rtPlay + rtOffset;
                            pWave->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                            pWave->lOffset = 0;
                            rtDurationMs = rtDuration / REF_PER_MIL;
                        }
                        else
                        {
                            REFERENCE_TIME rtPlay = 0;
                            MUSIC_TIME mtPlay = (MUSIC_TIME)rItem.m_rtTimePhysical;
                            pPerf->MusicToReferenceTime(mtPlay + (MUSIC_TIME)rtOffset, &rtPlay);
                            MUSIC_TIME mtRealPlay = 0;
                            pPerf->ReferenceToMusicTime(rtPlay + rtStartOffset, &mtRealPlay);
                            if (mtRealPlay > rtOffset + mtPlay)
                            {
                                rtDuration -= ConvertOffset(mtRealPlay - (rtOffset + mtPlay), -rItem.m_lPitch);

                            }
                            if (mtPlay < (MUSIC_TIME) rtStart)
                            {
                                // Calculate distance from wave start to segment start, but begin
                                // the calculation at segment start to avoid strangeness
                                // when attempting to do conversions at times earlier than
                                // segment start.
                                REFERENCE_TIME rtRefStartPlus = 0;
                                REFERENCE_TIME rtRefPlayPlus = 0;
                                MUSIC_TIME mtNewDuration = 0;
                                pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rtStart + (MUSIC_TIME)rtOffset, &rtRefStartPlus);
                                pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + mtPlay + (MUSIC_TIME)rtOffset, &rtRefPlayPlus);
                                rtStartOffset += ConvertOffset((rtRefStartPlus - rtRefPlayPlus), rItem.m_lPitch);
                                mtPlay = (MUSIC_TIME) rtStart;
                                REFERENCE_TIME rtRealDuration = 0;
                                pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rItem.m_rtDuration + (MUSIC_TIME)rtOffset, &rtRealDuration);
                                pPerf->ReferenceToMusicTime(rtRealDuration - (ConvertOffset(rItem.m_rtStartOffset, -rItem.m_lPitch) + (rtRefStartPlus - rtRefPlayPlus)), &mtNewDuration);
                                rtDuration = (REFERENCE_TIME)mtNewDuration - (rtStart + rtOffset);
                            }
                            pWave->mtTime = mtPlay + (MUSIC_TIME)rtOffset;
                            pWave->dwFlags = DMUS_PMSGF_MUSICTIME;
                            pWave->lOffset = (MUSIC_TIME)rItem.m_rtTimePhysical - rItem.m_mtTimeLogical;
                            REFERENCE_TIME rtZero = 0;
                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtOffset + mtPlay, &rtZero);
                            pPerf->MusicToReferenceTime((MUSIC_TIME)(rtDuration + rtOffset) + mtPlay, &rtDurationMs);
                            rtDurationMs -= rtZero;
                            rtDurationMs /= REF_PER_MIL;
                        }
                        // If we're either past the end of the wave, or we're within
                        // 150 ms of the end of a looping wave (and we've just started
                        // playback), or if this is a loop start and the wave should not 
                        // play on loop, don't play the wave.
                        if ( rtDurationMs <= 0 ||
                             (rItem.m_dwLoopEnd && (dwFlags & DMUS_TRACKF_START) && rtDurationMs < 150) ||
                             (rItem.m_dwFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlags & DMUS_TRACKF_LOOP))
                        {
                            pPerf->FreePMsg((DMUS_PMSG*)pWave);
                        }
                        else
                        {
                            pWave->rtStartOffset = rtStartOffset;
                            pWave->rtDuration = rtDuration; 
                            pWave->lVolume = rItem.m_lVolume + lPartVolume + m_lVolume;
                            pWave->lPitch = rItem.m_lPitch;
                            pWave->bFlags = (BYTE)(rItem.m_dwFlags & 0xff);
                            pWave->punkUser = (IUnknown*)rItem.m_pWave;
                            rItem.m_pWave->AddRef();
                            if( pGraph )
                            {
                                pGraph->StampPMsg( (DMUS_PMSG*)pWave );
                            }
                            hr = pPerf->SendPMsg( (DMUS_PMSG*)pWave );
                            if(FAILED(hr))
                            {
                                pPerf->FreePMsg((DMUS_PMSG*)pWave);
                            }
                        }
                    }
                }
#endif
            }
        }
        if( pPart )
        {
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// it's legal to start in the middle of a wave.
HRESULT CWavTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    WaveStateData* pSD, REFERENCE_TIME rtTime, BOOL fGetPrevious, 
    REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<WavePart>* pPart;
    TListItem<WaveItem>* pWaveItem;

    // in the case of fGetPrevious (which means DMUS_SEGF_START/LOOP was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious )//&& ( rtTime == 0 ) )
    {
        pPart = m_WavePartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead();
                if( pWaveItem && pSD->apCurrentWave )
                {
                    pSD->apCurrentWave[dwIndex] = pWaveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

    pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            // scan the wave event list in this part.
            for( pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead(); pWaveItem; pWaveItem = pWaveItem->GetNext() )
            {
                WaveItem& rWaveItem = pWaveItem->GetItemValue();
                REFERENCE_TIME rtWaveTime = fClockTime ? rWaveItem.m_rtTimePhysical : rWaveItem.m_mtTimeLogical;
                if( rtWaveTime >= rtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
            }
            if( pSD->apCurrentWave )
            {
                pSD->apCurrentWave[dwIndex] = pWaveItem;
            }
            pPart = pPart->GetNext();
        }
    }

    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::GetParam( 
    REFGUID rguidType,  // @parm The type of data to obtain.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::SetParam( 
    REFGUID rguidType,  // @parm The type of data to set.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return SetParamEx(rguidType, mtTime, pData, NULL, 0);
}

STDMETHODIMP CWavTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    V_INAME(CBandTrk::SetParamEx);
    V_REFGUID(rguidType);

    HRESULT hr = S_OK;

#ifdef DXAPI
    if((pParam == NULL) &&
       (rguidType != GUID_Enable_Auto_Download) &&
       (rguidType != GUID_Disable_Auto_Download))
#else
     if(pParam == NULL) 
#endif
    {
        return E_POINTER;   
    }
    
    ENTER_CRITICAL_SECTION(&m_CrSec);
    if (rguidType == GUID_WavePlayParams)
    {
        DMUS_IO_WAVE_HEADER *pWaveHeader = (DMUS_IO_WAVE_HEADER *)pParam;
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            pPart->GetItemValue().SetWaveParams(pWaveHeader);
        }    
    }
#ifdef DXAPI
    else if(rguidType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, NULL, NULL, GUID_NULL)) )
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
    }
    else if(rguidType == GUID_DownloadToAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, pPath, NULL, GUID_NULL)) )
                {
                    hrFail = hr;
                }
                else
                {
                    dwSuccess++;
                }
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            pPart->GetItemValue().Unload(pPerf, NULL, NULL);
        }
    }
    else if(rguidType == GUID_UnloadFromAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                pPart->GetItemValue().Unload(pPerf, pPath, NULL);
            }
        }
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Enable_Auto_Download)
    {
        m_fAutoDownload = TRUE;
        m_fLockAutoDownload = TRUE;
    }
    else if(rguidType == GUID_Disable_Auto_Download)
    {
        m_fAutoDownload = FALSE;
        m_fLockAutoDownload = TRUE;
    }
#endif
    else
    {
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LEAVE_CRITICAL_SECTION(&m_CrSec);

    return hr;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CWavTrack::Clone(
    MUSIC_TIME mtStart, // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,   // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if((mtStart < 0 )||(mtStart > mtEnd))
    {
        Trace(1,"Error: Wave track clone failed because of invalid start or end time.\n");
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION(&m_CrSec);
    CWavTrack *pDM;
    NEWCATCH(pDM,CWavTrack(*this, mtStart, mtEnd))

    if (pDM == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pDM->InitTrack(m_dwPChannelsUsed);
        if (SUCCEEDED(hr))
        {
            hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
        }
        pDM->Release();
    }

    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}


STDMETHODIMP CWavTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::ComputeVariations(WaveStateData* pSD)
{
    if (!pSD) 
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
    {
        pSD->adwVariationGroups[i] = 0;
    }
    // Now, compute the variations for each part.
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (i = 0; pScan && i < (int)m_dwPChannelsUsed; pScan = pScan->GetNext(), i++)
    {
        hr = ComputeVariation(i, pScan->GetItemValue(), pSD);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CWavTrack::SyncVariations(IDirectMusicPerformance* pPerf, 
                                  WaveStateData* pSD, 
                                  REFERENCE_TIME rtStart,
                                  REFERENCE_TIME rtOffset,
                                  BOOL fClockTime)
{
    if (!pSD) 
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // Get the current variations
    DMUS_VARIATIONS_PARAM Variations;
    memset(&Variations, 0, sizeof(Variations));
    // Call GetParam for variations to sync to
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    REFERENCE_TIME rtNext = 0;
    if (fClockTime)
    {
        pPerf->ReferenceToMusicTime(pSD->rtNextVariation + rtOffset, &mtNow);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr) &&
            SUCCEEDED(pPerf->MusicToReferenceTime(mtNext + mtNow, &rtNext)) )
        {
            pSD->rtNextVariation += rtNext;
        }
    }
    else
    {
        mtNow = (MUSIC_TIME) (pSD->rtNextVariation + rtOffset);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr))
        {
            pSD->rtNextVariation += mtNext;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Initialize the array of variation groups.
        for (int nGroup = 0; nGroup < MAX_WAVE_VARIATION_LOCKS; nGroup++)
        {
            pSD->adwVariationGroups[nGroup] = 0;
        }
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dwPart = 0; pScan && dwPart < m_dwPChannelsUsed; pScan = pScan->GetNext(), dwPart++)
        {
            WavePart& rPart = pScan->GetItemValue();
            for (DWORD dwSyncPart = 0; dwSyncPart < Variations.dwPChannelsUsed; dwSyncPart++)
            {
                if (rPart.m_dwPChannel == Variations.padwPChannels[dwSyncPart])
                {
                    pSD->pdwVariations[dwPart] = Variations.padwVariations[dwSyncPart];
                    break;
                }
            }
            if (dwSyncPart == Variations.dwPChannelsUsed) // no part to sync to
            {
                hr = ComputeVariation((int)dwPart, rPart, pSD);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
    }
    else
    {
        return ComputeVariations(pSD);
    }
    return hr;
}

HRESULT CWavTrack::ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD)
{
    BYTE bLockID = (BYTE)rWavePart.m_dwLockToPart;
    if (bLockID && pSD->adwVariationGroups[bLockID - 1] != 0)
    {
        pSD->pdwVariations[nPart] = pSD->adwVariationGroups[bLockID - 1];
    }
    else
    {
        // First, collect all matches.
        DWORD dwMatches = rWavePart.m_dwVariations;
        int nMatchCount = 0;
        for (int n = 0; n < 32; n++)
        {
            if (dwMatches & (1 << n)) nMatchCount++;
        }
        // Now, select a variation based on the part's variation mode.
        BYTE bMode = (BYTE)(rWavePart.m_dwPChannelFlags & 0xf); 
        DWORD dwTemp = dwMatches;
        if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
        {
            dwTemp &= ~pSD->pdwRemoveVariations[nPart];
            if (!dwTemp)
            {
                // start counting all over, but don't repeat this one
                pSD->pdwRemoveVariations[nPart] = 0;
                dwTemp = dwMatches;
                bMode = DMUS_VARIATIONT_NO_REPEAT;
            }
        }
        if ( bMode == DMUS_VARIATIONT_NO_REPEAT && pSD->pdwVariations[nPart] != 0 )
        {
            dwTemp &= ~pSD->pdwVariations[nPart];
        }
        if (dwTemp != dwMatches)
        {
            if (dwTemp) // otherwise, keep what we had
            {
                for (int i = 0; i < 32; i++)
                {
                    if ( ((1 << i) & dwMatches) && !((1 << i) & dwTemp) )
                    {
                        nMatchCount--;
                    }
                }
                dwMatches = dwTemp;
            }
        }
        int nV = 0;
        switch (bMode)
        {
        case DMUS_VARIATIONT_RANDOM_ROW:
        case DMUS_VARIATIONT_NO_REPEAT:
        case DMUS_VARIATIONT_RANDOM:
            {
                short nChoice = (short) (dm_rand() % nMatchCount);
                short nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nChoice == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
                if (bMode == DMUS_VARIATIONT_RANDOM_ROW)
                {
                    pSD->pdwRemoveVariations[nPart] |= pSD->pdwVariations[nPart];
                }
                TraceI(3, "New variation: %d\n", nV);
                break;
            }
        case DMUS_VARIATIONT_RANDOM_START:
            // Choose an initial value
            if (pSD->pdwVariations[nPart] == 0)
            {
                int nStart = 0;
                nStart = (BYTE) (dm_rand() % nMatchCount);
                int nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nStart == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
            }
            // Now, go directly to the sequential case (no break)
        case DMUS_VARIATIONT_SEQUENTIAL:
            {
                if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                else
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                while (!(pSD->pdwVariations[nPart] & dwMatches))
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                } 
                TraceI(3, "New variation: %d\n", pSD->pdwVariations[nPart]);
                break;
            }
        }
        // If this is a locked variation, it's the first in its group, so record it.
        if (bLockID)
        {
            pSD->adwVariationGroups[bLockID - 1] = pSD->pdwVariations[nPart];
        }
        if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
             m_pdwVariations && 
             m_pdwRemoveVariations )
        {
            m_pdwVariations[nPart] = pSD->pdwVariations[nPart];
            m_pdwRemoveVariations[nPart] = pSD->pdwRemoveVariations[nPart];
        }
    }
    return S_OK;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
#ifdef DXAPI
HRESULT CWavTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart, DWORD dwIndex)
{
    WaveStateData* pState = NULL;
    ENTER_CRITICAL_SECTION( &m_CrSec );
    m_dwVariation = dwVariationFlags;
    m_dwPart = dwPart;
    m_dwIndex = dwIndex;
    m_fAudition = TRUE;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        if (rScan.m_dwPChannel == dwPart && rScan.m_dwIndex == dwIndex)
        {
            m_dwLockID = rScan.m_dwLockToPart;
        }
    }
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(dwVariationFlags, dwPart, dwIndex, m_dwLockID, m_fAudition);
    }
    LEAVE_CRITICAL_SECTION( &m_CrSec );

    return S_OK;
}

// Clears the variations to be played for a part, so that all parts use the MOAW.
HRESULT CWavTrack::ClearVariations(IDirectMusicSegmentState* pSegState)
{
    WaveStateData* pState = NULL;
    ENTER_CRITICAL_SECTION( &m_CrSec );
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(0, 0, 0, 0, m_fAudition);
    }
    LEAVE_CRITICAL_SECTION( &m_CrSec );

    return S_OK;
}

WaveStateData* CWavTrack::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}
#endif

// Adds a wave at mtTime to part dwIndex on PChannel dwPChannel
// If there was already a wave there, the two will co-exist
HRESULT CWavTrack::AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    ENTER_CRITICAL_SECTION(&m_CrSec);
    HRESULT hr = S_OK;
    m_lVolume = 0;
    m_dwTrackFlags = 0;
    TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
    if( !pNewPart )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewPart->GetItemValue().Add(pWave, rtTime, dwPChannel, dwIndex, prtLength);
    if( FAILED ( hr ) )
    {
        delete pNewPart;
        goto ON_ERROR;
    }
    InsertByAscendingPChannel( pNewPart );
    m_dwWaveItems = 0;
    m_dwPChannelsUsed = m_WavePartList.GetCount();
    if (m_aPChannels)
    {
        delete [] m_aPChannels;
        m_aPChannels = NULL;
    }
    m_aPChannels = new DWORD[m_dwPChannelsUsed];
    if (m_aPChannels)
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
        {
            m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
#ifdef DXAPI
                pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
#endif
                m_dwWaveItems++;
            }
        }
    }
    else
    {
        CleanUp();
        hr = E_OUTOFMEMORY;
    }
ON_ERROR:
    LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}
#ifdef DXAPI
HRESULT CWavTrack::DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::DownloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);
    V_REFGUID(rguidVersion);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        ENTER_CRITICAL_SECTION(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, download is only partial.
            if (pPart->GetItemValue().Download(pPerf, pPath, pWave, rguidVersion) != S_OK) 
            {
                Trace(1,"Error: Wave download was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk)
{
    V_INAME(CWavTrack::UnloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        ENTER_CRITICAL_SECTION(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, unload is only partial.
            if (pPart->GetItemValue().Unload(pPerf, pPath, pWave) != S_OK) 
            {
                Trace(1,"Error: Wavetrack unload was only partially successful.\n");
                hr = S_FALSE;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::RefreshWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        ENTER_CRITICAL_SECTION(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, refresh is only partial.
            if (pPart->GetItemValue().Refresh(pPerf, pPath, pWave, dwPChannel, rguidVersion) != S_OK) 
            {
                Trace(1,"Error: Wavetrack refresh was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::FlushAllWaves()
{
    FlushWaves();
    return S_OK;
}


HRESULT CWavTrack::OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)
{
    HRESULT hr = S_OK;
    if( pStateData && pVoice )
    {
        ENTER_CRITICAL_SECTION(&m_CrSec);

        WaveStateData* pSD = (WaveStateData*)pStateData;
        TListItem<WaveDLOnPlay>* pWDLOnPlay = pSD->m_WaveDLList.GetHead();
        TListItem<WaveDLOnPlay>* pWDLNext = NULL;
        for (; pWDLOnPlay; pWDLOnPlay = pWDLNext)
        {
            pWDLNext = pWDLOnPlay->GetNext();
            if (pWDLOnPlay->GetItemValue().m_pVoice == pVoice)
            {
                pSD->m_WaveDLList.Remove(pWDLOnPlay);
                delete pWDLOnPlay;
                break;
            }
        }

        LEAVE_CRITICAL_SECTION(&m_CrSec);
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}

#endif

////////////////////////////////////////////////////////////////////
// WavePart

HRESULT WavePart::Load( CRiffParser *pParser )
{
    HRESULT hr = S_OK; 
    RIFFIO          ck;
    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
        if ( ck.ckid == DMUS_FOURCC_WAVEPART_CHUNK )
        {
            DMUS_IO_WAVE_PART_HEADER iPartHeader;
            memset(&iPartHeader, 0, sizeof(iPartHeader));

            // Read in the item's header structure
            hr = pParser->Read( &iPartHeader, sizeof( DMUS_IO_WAVE_PART_HEADER ) );

            // Handle any I/O error by returning a failure code
            if( SUCCEEDED( hr ) )
            {
                m_dwPChannel = iPartHeader.dwPChannel;
                m_dwIndex = iPartHeader.dwIndex;

                m_lVolume = iPartHeader.lVolume;
                m_dwLockToPart = iPartHeader.dwLockToPart;
                m_dwPChannelFlags = iPartHeader.dwFlags;
                m_dwVariations = iPartHeader.dwVariations;
            }
            else
            {
                Trace(1,"Error: Unable to read wave track - bad wave part header.\n");
            }
        }
        else if ((ck.ckid == FOURCC_LIST ) && ( ck.fccType == DMUS_FOURCC_WAVEITEM_LIST))
        {
            RIFFIO ckList;
            pParser->EnterList(&ckList);
            while (pParser->NextChunk(&hr))
            {
                if (( ckList.ckid == FOURCC_LIST) && ( ckList.fccType == DMUS_FOURCC_WAVE_LIST))
                {
                    TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
                    if( !pNewItem )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = pNewItem->GetItemValue().Load( pParser );
                        if( FAILED ( hr ) )
                        {
                            delete pNewItem;
                            Trace(1,"Warning: Empty wave item in wave track. Content should be cleaned up.\n");
                            hr = S_OK;
                        }
                        else
                        {
                            m_WaveItemList.AddHead( pNewItem );
                        }
                    }
                }
            }
            pParser->LeaveList();
        }
    }
    pParser->LeaveList();

    return hr;
}

void WavePart::CleanUp()
{
    TListItem<WaveItem>* pScan = m_WaveItemList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WaveItemList.CleanUp();
}

HRESULT WavePart::CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WaveItem>* pScan = rItems.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WaveItem& rScan = pScan->GetItemValue();
        if (mtStart <= (MUSIC_TIME) rScan.m_rtTimePhysical && 
            (!mtEnd || (MUSIC_TIME) rScan.m_rtTimePhysical < mtEnd) )
        {
            TListItem<WaveItem>* pNew = new TListItem<WaveItem>;
            if (pNew)
            {
                WaveItem& rNew = pNew->GetItemValue();
                rNew.m_rtTimePhysical = rScan.m_rtTimePhysical - mtStart;
                rNew.m_lVolume = rScan.m_lVolume;
                rNew.m_lPitch = rScan.m_lPitch;
                rNew.m_dwVariations = rScan.m_dwVariations;
                rNew.m_rtStartOffset = rScan.m_rtStartOffset;
                rNew.m_rtDuration = rScan.m_rtDuration;
                rNew.m_mtTimeLogical = rScan.m_mtTimeLogical;
                rNew.m_dwFlags = rScan.m_dwFlags;
                rNew.m_pWave = rScan.m_pWave;
                rNew.m_dwLoopStart = rScan.m_dwLoopStart;
                rNew.m_dwLoopEnd = rScan.m_dwLoopEnd;
                rNew.m_fIsStreaming = rScan.m_fIsStreaming;
                if (rNew.m_pWave)
                {
                    rNew.m_pWave->AddRef();
                }
                if (SUCCEEDED(hr))
                {
                    m_WaveItemList.AddHead(pNew);
                }
                else
                {
                    delete pNew;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WaveItemList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

void WavePart::SetWaveParams(DMUS_IO_WAVE_HEADER *pWaveHeader)

{
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        pItem->GetItemValue().SetWaveParams(pWaveHeader);
    }
}

#ifdef DXAPI
HRESULT WavePart::Download(IDirectMusicPerformance* pPerformance, 
                           IDirectMusicAudioPath* pPath, 
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Download(pPerformance, pPath, m_dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep downloading)
        }
    }
    return hr;
}

HRESULT WavePart::Unload(IDirectMusicPerformance* pPerformance, IDirectMusicAudioPath* pPath, IDirectSoundWave* pWave)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Unload(pPerformance, pPath, m_dwPChannel, pWave);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep unloading)
        }
    }
    return hr;
}

HRESULT WavePart::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          IDirectSoundWave* pWave,
                          DWORD dwPChannel,
                          REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Refresh(pPerformance, pPath, m_dwPChannel, dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep refreshing)
        }
    }
    return hr;
}
#endif
HRESULT WavePart::Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    m_dwPChannel = dwPChannel;
    m_dwIndex = dwIndex;

    m_lVolume = 0;
    m_dwLockToPart = 0;
    m_dwPChannelFlags = 0;
    m_dwVariations = 0xffffffff;

    TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
    if( pNewItem == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewItem->GetItemValue().Add( pWave, rtTime, prtLength );
    if( FAILED ( hr ) )
    {
        delete pNewItem;
        goto ON_ERROR;
    }
    m_WaveItemList.AddHead( pNewItem );
ON_ERROR:
    return hr;
}

////////////////////////////////////////////////////////////////////
// WaveItem

HRESULT WaveItem::Load( CRiffParser *pParser )
{
    RIFFIO          ck;
    HRESULT         hr = S_OK;
    BOOL            bLoadedHeader = FALSE;
    BOOL            bLoadedWave   = FALSE;

    // LoadListItem does not expect to be called twice on the same object
    // Code assumes item consists of initial values
    ASSERT( m_rtTimePhysical == 0 );
    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
        if ( ck.ckid == DMUS_FOURCC_WAVEITEM_CHUNK)
        {
            DMUS_IO_WAVE_ITEM_HEADER iItemHeader;
            // Read in the item's header structure
            hr = pParser->Read( &iItemHeader, sizeof( DMUS_IO_WAVE_ITEM_HEADER ) );

            // Handle any I/O error by returning a failure code
            if( SUCCEEDED( hr ) )
            {
                m_lVolume = iItemHeader.lVolume;
                m_lPitch = iItemHeader.lPitch;
                m_dwVariations = iItemHeader.dwVariations;
                m_rtTimePhysical = iItemHeader.rtTime;
                m_rtStartOffset = iItemHeader.rtStartOffset;  
                m_rtDuration = iItemHeader.rtDuration;
                m_mtTimeLogical = iItemHeader.mtLogicalTime;
                m_dwFlags = iItemHeader.dwFlags;
                m_dwLoopStart = iItemHeader.dwLoopStart;
                m_dwLoopEnd = iItemHeader.dwLoopEnd;
                if (m_dwLoopEnd)
                    m_dwLoopEnd++; // fix for bug 38505
                bLoadedHeader = TRUE;
            }
        }
        else if ((ck.ckid == FOURCC_LIST) && ( ck.fccType == DMUS_FOURCC_REF_LIST ))
        {
            hr = LoadReference( pParser );
#ifdef DBG
            if (FAILED(hr))
            {
                Trace(1,"Wave track unable to load referenced wave.\n");
            }
#endif
            bLoadedWave = TRUE;
        }
    }
    pParser->LeaveList();
    
    //If all the calls succeeded but we did not load the necessary data, fail.
    if (SUCCEEDED(hr))
    {
        if (!bLoadedHeader)
        {
            Trace(1, "Content Error: Unable to load WAVE_ITEM_HEADER.\n");
            hr = DMUS_E_BADWAVE;
        }
        else if (!bLoadedWave)
        {
            Trace(1, "Content Error: Wave item in wave track is missing reference to wave data.\n");
            hr = DMUS_E_BADWAVE;
        }
    }

    return hr;
}

HRESULT WaveItem::LoadReference(CRiffParser *pParser)
{
    CLinkParser LinkParser;
    IDirectSoundWave* pWave;
    HRESULT hr = LinkParser.LoadReferencedObject(pParser,(void **)&pWave,IID_IDirectSoundWave,FALSE);
    if (SUCCEEDED(hr))
    {
        if (m_pWave) m_pWave->Release();
        m_pWave = pWave; // no need to AddRef; GetObject did that
        REFERENCE_TIME rtReadAhead = 0;
        DWORD dwFlags = 0;
        m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
        m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
        m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
    }
    return hr;
}
#ifdef DXAPI
HRESULT WaveItem::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           DWORD dwPChannel,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if ( rDLWave.m_pWave == m_pWave && 
                         rDLWave.m_pPerformance == pPerformance &&
                         rDLWave.m_pPort == pPortP &&
                         ( !m_fIsStreaming ||
                           rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        break;
                    }
                }
                // only download the wave if:
                // 1) it hasn't already been downloaded to the port, or
                // 2) its version doesn't match the currently downloaded version.
                if (!pDLWave)
                {
                    pDLWave = new TListItem<TaggedWave>;
                    if (!pDLWave)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        TaggedWave& rDLWave = pDLWave->GetItemValue();
                        hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                        if (SUCCEEDED(hr))
                        {
                            rDLWave.m_pPort = pPortP;
                            rDLWave.m_pPort->AddRef();
                            rDLWave.m_pPerformance = pPerformance;
                            rDLWave.m_pPerformance->AddRef();
                            rDLWave.m_pWave = m_pWave;
                            rDLWave.m_pWave->AddRef();
                            rDLWave.m_lRefCount = 1;
                            rDLWave.m_guidVersion = rguidVersion;
                            st_WaveList.AddHead(pDLWave);
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                            }
                            if(m_fIsStreaming)
                            {
                                m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                                m_pDownloadedWave->AddRef();
                            }
                        }
                        else
                        {
                            delete pDLWave;
                        }
                    }
                }
                else if (rguidVersion != pDLWave->GetItemValue().m_guidVersion)
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pDownloadedWave)
                    {
                        pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                        rDLWave.m_pDownloadedWave = NULL;
                    }
                    if (rDLWave.m_pPort)
                    {
                        rDLWave.m_pPort->Release();
                        rDLWave.m_pPort = NULL;
                    }
                    if (rDLWave.m_pPerformance)
                    {
                        rDLWave.m_pPerformance->Release();
                        rDLWave.m_pPerformance = NULL;
                    }
                    hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                    if (SUCCEEDED(hr))
                    {
                        rDLWave.m_pPort = pPortP;
                        rDLWave.m_pPort->AddRef();
                        rDLWave.m_pPerformance = pPerformance;
                        rDLWave.m_pPerformance->AddRef();
                        rDLWave.m_lRefCount = 1;
                        rDLWave.m_guidVersion = rguidVersion;
                        if (m_pDownloadedWave)
                        {
                            m_pDownloadedWave->Release();
                        }
                        
                        if(m_fIsStreaming)
                        {
                            m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                            m_pDownloadedWave->AddRef();
                        }
                    }
                    else
                    {
                        if (rDLWave.m_pWave)
                        {   
                            rDLWave.m_pWave->Release();
                            rDLWave.m_pWave = NULL;
                        }
                        st_WaveList.Remove(pDLWave);
                        delete pDLWave;
                    }
                }
                else // keep track of this, but return S_FALSE (indicates wave wasn't downloaded)
                {
                    pDLWave->GetItemValue().m_lRefCount++;
                    hr = S_FALSE;
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for download.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1,"Error: Wavetrack download failed, initialization error.\n");
        hr = DMUS_E_NOT_INIT;
    }

    return hr;
}

HRESULT WaveItem::Unload(IDirectMusicPerformance* pPerformance,
                         IDirectMusicAudioPath* pPath,
                         DWORD dwPChannel,
                         IDirectSoundWave* pWave)
{
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pWave == m_pWave && 
                        rDLWave.m_pPerformance == pPerformance &&
                        rDLWave.m_pPort == pPortP &&
                        ( !m_fIsStreaming ||
                          rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        rDLWave.m_lRefCount--;
                        if (rDLWave.m_lRefCount <= 0)
                        {
                            if (rDLWave.m_pWave)
                            {
                                rDLWave.m_pWave->Release();
                                rDLWave.m_pWave = NULL;
                            }
                            if (rDLWave.m_pPort)
                            {
                                rDLWave.m_pPort->Release();
                                rDLWave.m_pPort = NULL;
                            }
                            if (rDLWave.m_pPerformance)
                            {
                                rDLWave.m_pPerformance->Release();
                                rDLWave.m_pPerformance = NULL;
                            }
                            if (rDLWave.m_pDownloadedWave)
                            {
                                pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                                rDLWave.m_pDownloadedWave = NULL;
                            }
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                                m_pDownloadedWave = NULL;
                            }
                            st_WaveList.Remove(pDLWave);
                            delete pDLWave;
                        }
                        else
                        {
                            hr = S_FALSE; // indicates wave wasn't actually unloaded
                        }
                        break;
                    }
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for unload.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }

    return hr;
}

HRESULT WaveItem::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          DWORD dwOldPChannel,
                          DWORD dwNewPChannel,
                          IDirectSoundWave* pWave,
                          REFGUID rguidVersion)
{
    IDirectMusicPort* pOldPort = NULL;
    IDirectMusicPort* pNewPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    hr = PChannelInfo(pPerformance, pPath, dwOldPChannel, &pOldPort, &dwGroup, &dwMChannel);
    if (SUCCEEDED(hr))
    {
        hr = PChannelInfo(pPerformance, pPath, dwNewPChannel, &pNewPort, &dwGroup, &dwMChannel);
    }
    if (SUCCEEDED(hr))
    {
        // if the old port and new port are different, unload the wave from the old port
        // and download to the new one.
        if (pOldPort != pNewPort)
        {
            Unload(pPerformance, pPath, dwOldPChannel, pWave);
            hr = Download(pPerformance, pPath, dwNewPChannel, pWave, rguidVersion);
        }
    }
    if (pOldPort) pOldPort->Release();
    if (pNewPort) pNewPort->Release();
    return hr;
}

HRESULT WaveItem::PChannelInfo(
    IDirectMusicPerformance* pPerformance,
    IDirectMusicAudioPath* pAudioPath,
    DWORD dwPChannel,
    IDirectMusicPort** ppPort,
    DWORD* pdwGroup,
    DWORD* pdwMChannel)
{
    HRESULT hr = S_OK;
    DWORD dwConvertedPChannel = dwPChannel;
    if (pAudioPath)
    {
        hr = pAudioPath->ConvertPChannel(dwPChannel, &dwConvertedPChannel);
    }
    if (SUCCEEDED(hr))
    {
#ifdef DXAPI
        hr = pPerformance->PChannelInfo(dwConvertedPChannel, ppPort, pdwGroup, pdwMChannel);
#else
        CPerformance *pCPerf = (CPerformance *) pPerformance;
        pCPerf->PChannelInfo(dwConvertedPChannel, ppPort, pdwGroup, pdwMChannel);
#endif
    }
    return hr;
}
#endif
void WaveItem::CleanUp()
{
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
#ifdef DXAPI
    if (m_pDownloadedWave)
    {
        m_pDownloadedWave->Release();
        m_pDownloadedWave = NULL;
    }
#endif
}

void WaveItem::SetWaveParams(DMUS_IO_WAVE_HEADER *pWaveHeader)

{
    IPrivateWave* pPrivWave = NULL;
    if (SUCCEEDED(m_pWave->QueryInterface(IID_IPrivateWave, (void**)&pPrivWave)))
    {
        pPrivWave->SetWaveParams(pWaveHeader->rtReadAhead,pWaveHeader->dwFlags);
        m_dwFlags &= ~(DMUS_WAVEF_IGNORELOOPS | DMUS_WAVEF_NOINVALIDATE);
        m_dwFlags |= pWaveHeader->dwFlags & (DMUS_WAVEF_IGNORELOOPS | DMUS_WAVEF_NOINVALIDATE);
        m_pWave->GetStreamingParms(&pWaveHeader->dwFlags, &pWaveHeader->rtReadAhead);
        m_fIsStreaming = pWaveHeader->dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
        m_fUseNoPreRoll = pWaveHeader->dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        pPrivWave->Release();
    }
}


HRESULT WaveItem::Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    IPrivateWave* pPrivWave = NULL;
    *prtLength = 0; // in case GetLength fails...
    REFERENCE_TIME rtLength = 0;
    m_rtDuration = 0;
    if (SUCCEEDED(hr = pWave->QueryInterface(IID_IPrivateWave, (void**)&pPrivWave)))
    {
        if (SUCCEEDED(hr = pPrivWave->GetLength(&rtLength,&m_dwLoopStart,&m_dwLoopEnd)))
        {
            // Assumes the track is clock time
            m_rtDuration = rtLength * REF_PER_MIL;
            *prtLength = rtLength; // NOTE: length in milliseconds; duration in Ref time
        }
        pPrivWave->Release();
    }
    if (SUCCEEDED(hr))
    {
        m_lVolume = 0;
        m_lPitch = 0;
        m_dwVariations = 0xffffffff;
        m_rtTimePhysical = rtTime;
        m_rtStartOffset = 0;  
        m_mtTimeLogical = 0;
        m_dwFlags = 0;
        if (m_pWave)
        {
            m_pWave->Release();
            m_pWave = NULL;
        }
        m_pWave = pWave;
        if (m_pWave)
        {
            m_pWave->AddRef();
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
#ifdef DXAPI
        if (m_pDownloadedWave)
        {
            m_pDownloadedWave->Release();
        }
        m_pDownloadedWave = NULL;
#endif
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmime$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

# XMIX is (DSound-based) hardware mixing for Xbox
!if !defined(SILVER) && !defined(NOXMIX)
C_DEFINES = $(C_DEFINES) -DXMIX
!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2 -D_MT -DXBOX -DUNICODE

MSC_WARNING_LEVEL=/W3 /WX
MSC_OPTIMIZATION =  $(MSC_OPTIMIZATION) /Od

INCLUDES=$(INCLUDES);   \
    ..\..\shared;			\
    ..\..\xprivate; \
    ..

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchime.h
PRECOMPILED_PCH=pchime.pch
PRECOMPILED_OBJ=pchime.obj

SOURCES=\
alist.cpp			\
dmgraph.cpp         \
debug.cpp			\
dmperf.cpp          \
dmprfdll.cpp        \
dmsegobj.cpp        \
dmsstobj.cpp        \
medparam_i.c		\
queue.cpp           \
seqtrack.cpp        \
sysextrk.cpp        \
tempotrk.cpp        \
tsigtrk.cpp         \
dmstrm.cpp		   \
audpath.cpp         \
lyrictrk.cpp        \
marktrk.cpp         \
paramtrk.cpp        \
segtrtrk.cpp        \
smartref.cpp        \
song.cpp            \
trackhelp.cpp       \
wavtrack.cpp        \
phoneyds.cpp		\
dowork.cpp			\
dmcreate.cpp 		\
cmixbins.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\wavtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// WavTrack.h : Declaration of the CWavTrack

#ifndef __WAVTRACK_H_
#define __WAVTRACK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "dmstrm.h"
#include "tlist.h"
#include "PChMap.h"
#include "..\shared\dmusiccp.h"
#include "dsoundp.h"  // For IDirectSoundWave

interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)=0;
#ifdef DXAPI
    virtual HRESULT STDMETHODCALLTYPE OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)=0;
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
        IDirectSoundWave* pWave,   // wave to download
        IUnknown* pUnk,            // performance or audio path
        REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
        IDirectSoundWave* pWave,   // wave to unload
        IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
        IDirectSoundWave* pWave,   // wave to refresh
        IUnknown* pUnk,            // performance or audio path
        DWORD dwPChannel,          // new PChannel for the wave
        REFGUID rguidVersion)=0;  // version of refreshed wave
    virtual HRESULT STDMETHODCALLTYPE FlushAllWaves()=0;
#endif
};

DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);

const int MAX_WAVE_VARIATION_LOCKS = 255;  // max number of variation lock ids
#ifdef DXAPI
struct TaggedWave
{
    IDirectSoundWave*               m_pWave;
    GUID                            m_guidVersion;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    long                            m_lRefCount;
    IDirectMusicPortP*              m_pPort;
    IDirectMusicPerformance*        m_pPerformance;

    TaggedWave() : m_pWave(NULL), m_pDownloadedWave(NULL), m_lRefCount(0),
        m_pPort(NULL), m_pPerformance(NULL), m_guidVersion(GUID_NULL)
    {
    }

    ~TaggedWave()
    {
        if (m_pWave) m_pWave->Release();
        if (m_pPort) m_pPort->Release();
        if (m_pPerformance) m_pPerformance->Release();
        if (m_pDownloadedWave) m_pDownloadedWave->Release();
    }
};
#endif
struct WaveItem
{
    WaveItem() : m_rtTimePhysical(0), m_lVolume(0), m_lPitch(0), m_dwVariations(0),
        m_rtStartOffset(0), m_rtDuration(0), m_mtTimeLogical(0), m_dwFlags(0),
        m_pWave(NULL), m_dwLoopStart(0), m_dwLoopEnd(0), 
#ifdef DXAPI
        m_dwVoiceIndex(0xffffffff),m_pDownloadedWave(NULL), 
#endif
        m_fIsStreaming(FALSE), m_fUseNoPreRoll(FALSE)
    {
    }

    ~WaveItem()
    {
        CleanUp();
    }

    HRESULT Load( CRiffParser *pParser );
    HRESULT LoadReference(CRiffParser *pParser);
#ifdef DXAPI
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave, 
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwOldPChannel, 
        DWORD dwNewPChannel,
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    static HRESULT PChannelInfo(
        IDirectMusicPerformance* pPerformance,
        IDirectMusicAudioPath* pAudioPath,
        DWORD dwPChannel,
        IDirectMusicPort** ppPort,
        DWORD* pdwGroup,
        DWORD* pdwMChannel);
#endif
    void SetWaveParams(DMUS_IO_WAVE_HEADER *pWaveHeader);

    void CleanUp();
    HRESULT Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime, REFERENCE_TIME* prtLength);

    REFERENCE_TIME                  m_rtTimePhysical;
    long                            m_lVolume;
    long                            m_lPitch;
    DWORD                           m_dwVariations; // variations this wave item responds to
    REFERENCE_TIME                  m_rtStartOffset;
    REFERENCE_TIME                  m_rtDuration;
    MUSIC_TIME                      m_mtTimeLogical;
    DWORD                           m_dwFlags;
    IDirectSoundWave*               m_pWave;
#ifdef DXAPI
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    static TList<TaggedWave>        st_WaveList;
    DWORD                           m_dwVoiceIndex; // unique (to the track) index for state data's vaoice array
    static CRITICAL_SECTION         st_WaveListCritSect;
#endif
    BOOL                            m_fIsStreaming;
    BOOL                            m_fUseNoPreRoll;
    DWORD                           m_dwLoopStart;
    DWORD                           m_dwLoopEnd;

};

struct WavePart
{
    WavePart() : m_dwPChannel(0), m_lVolume(0), m_dwLockToPart(0), 
        m_dwPChannelFlags(0), m_dwVariations(0), m_dwIndex(0)
    {
    }

    ~WavePart()
    {
        CleanUp();
    }

    HRESULT Load( CRiffParser *pParser );
    HRESULT CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
#ifdef DXAPI
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        DWORD dwPChannel,
        REFGUID rguidVersion);
#endif
    HRESULT Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);
    void SetWaveParams(DMUS_IO_WAVE_HEADER *pWaveHeader);

    DWORD               m_dwPChannel;
    DWORD               m_dwIndex; // Index to distinguish different parts on the same PChannel
    DWORD               m_lVolume;
    DWORD               m_dwVariations;    // variations enabled for this part
    DWORD               m_dwLockToPart;    // all parts with this ID are locked (0 means no locking)
    DWORD               m_dwPChannelFlags; // lowest-order nibble holds DMUS_VARIATIONT_TYPES value
    TList<WaveItem>     m_WaveItemList;
};

struct WaveDLOnPlay
{
    WaveDLOnPlay() : m_pWaveDL(NULL), m_pPort(NULL), m_pVoice(NULL) {}
    ~WaveDLOnPlay()
    {
        if (m_pPort)
        {
            if (m_pWaveDL)
            {
                m_pPort->UnloadWave(m_pWaveDL);
            }
            m_pWaveDL = NULL;
            m_pPort->Release();
            m_pPort = NULL;
        }
        if (m_pVoice)
        {
            m_pVoice->Release();
            m_pVoice = NULL;
        }
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    IDirectMusicPortP*             m_pPort;
    IDirectMusicVoiceP*            m_pVoice;
};

struct WaveStateData
{
    DWORD                       dwPChannelsUsed; // number of PChannels
    // the following array is allocated to the size of dwNumPChannels, which
    // must match the Wave Track's m_dwPChannelsUsed. The array matches one-for-one with
    // the parts inside the Wave Track.
    TListItem<WaveItem>**       apCurrentWave; // array of size dwNumPChannels
    DWORD                       dwValidate;
    DWORD                       dwGroupBits; // the group bits of this track
    DWORD*                      pdwVariations;      // array of variations (1 per part)
    DWORD*                      pdwRemoveVariations;    // array of variations already played (1 per part)
    DWORD                       adwVariationGroups[MAX_WAVE_VARIATION_LOCKS];
    REFERENCE_TIME              rtNextVariation; // time of next variation
    DWORD                       m_dwVariation;   // selected variations to audition
    DWORD                       m_dwPart;        // PChannel of part for auditioning variations
    DWORD                       m_dwIndex;       // Index of part for auditioning variations
    DWORD                       m_dwLockID;      // For locking to the part being auditioned
    BOOL                        m_fAudition;     // Am I auditioning variations?
#ifdef DXAPI
    IDirectMusicPerformance*    m_pPerformance;
    IDirectMusicVoiceP**        m_apVoice;      // array of voices (one per wave item in track)
    DWORD                       m_dwVoices;     // number of voices in m_apVoice
    TList<WaveDLOnPlay>         m_WaveDLList;   // waves downloaded while the track was playing
    IDirectMusicAudioPath*      m_pAudioPath;   // audio path in effect for this track state
#endif
    bool                        m_fLoop;        // set after the wave loops

    WaveStateData() : dwPChannelsUsed(0), 
        apCurrentWave(NULL), 
        dwGroupBits(0),
        pdwVariations(NULL), pdwRemoveVariations(NULL), rtNextVariation(0),
        m_dwVariation(0), m_dwPart(0), m_dwIndex(0), m_dwLockID(0), m_fAudition(FALSE),
#ifdef DXAPI
        m_pPerformance(NULL), m_apVoice(NULL), m_dwVoices(0), m_pAudioPath(NULL),
#endif
        m_fLoop(false)
    {
        for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
        {
            adwVariationGroups[i] = 0;
        }
    }

    ~WaveStateData()
    {
        if( apCurrentWave )
        {
            delete [] apCurrentWave;
        }
        if( pdwVariations )
        {
            delete [] pdwVariations;
        }
        if( pdwRemoveVariations )
        {
            delete [] pdwRemoveVariations;
        }
#ifdef DXAPI
        if (m_apVoice)
        {
            for (DWORD dw = 0; dw < m_dwVoices; dw++)
            {
                if (m_apVoice[dw])
                {
                    m_apVoice[dw]->Release();
                }
            }
            delete [] m_apVoice;
        }
        if( m_pAudioPath )
        {
            m_pAudioPath->Release();
        }
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
#endif
    }

    HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, DWORD dwIndex, DWORD dwLockID, BOOL fAudition)
    {
        HRESULT hr = S_OK;
        m_dwVariation = dwVariations;
        m_dwPart = dwPart;
        m_dwIndex = dwIndex;
        m_dwLockID = dwLockID;
        m_fAudition = fAudition;
        return hr;
    }

    DWORD Variations(WavePart& rPart, int nPartIndex)
    {
        if (m_dwLockID && rPart.m_dwLockToPart == m_dwLockID)
        {
            TraceI(4, "Variations for locked part\n");
            return m_dwVariation;
        }
        else if ( m_fAudition &&
                  (rPart.m_dwPChannel == m_dwPart) &&
                  (rPart.m_dwIndex == m_dwIndex) )
        {
            TraceI(4, "Variations for current part\n");
            return m_dwVariation;
        }
        else
        {
            TraceI(4, "Variations for a different part\n");
            return pdwVariations[nPartIndex];
        }
    }

};

#ifdef DXAPI
struct StatePair
{
    StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
    StatePair(const StatePair& rPair)
    {
        m_pSegState = rPair.m_pSegState;
        m_pStateData = rPair.m_pStateData;
    }
    StatePair(IDirectMusicSegmentState* pSegState, WaveStateData* pStateData)
    {
        m_pSegState = pSegState;
        m_pStateData = pStateData;
    }
    StatePair& operator= (const StatePair& rPair)
    {
        if (this != &rPair)
        {
            m_pSegState = rPair.m_pSegState;
            m_pStateData = rPair.m_pStateData;
        }
        return *this;
    }
    ~StatePair()
    {
    }
    IDirectMusicSegmentState*   m_pSegState;
    WaveStateData*          m_pStateData;
};

struct WavePair
{
    WavePair() : m_pWaveDL(NULL), m_pStateData(NULL) {}
    ~WavePair()
    {
        if (m_pWaveDL) m_pWaveDL->Release();
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    WaveStateData*                 m_pStateData;
};
#endif
/////////////////////////////////////////////////////////////////////////////
// CWavTrack
class CWavTrack : public CMemTrack,
    public IPersistStream,
    public IPrivateWaveTrack,
    public IDirectMusicTrack8
{
public:
    CWavTrack();
    CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    ~CWavTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
// IPersist methods
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
//  IPrivateWaveTrack methods
    STDMETHODIMP AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);
#ifdef DXAPI
    STDMETHODIMP OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData);
    STDMETHODIMP SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex);
    STDMETHODIMP ClearVariations(IDirectMusicSegmentState* pSegState);
    STDMETHODIMP DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion);
    STDMETHODIMP UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk);
    STDMETHODIMP RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    STDMETHODIMP FlushAllWaves();
#endif
    // misc
#ifdef DXAPI
#else
    static void StaticInit();
    static void StaticFinalize();
#endif
    static HRESULT UnloadAllWaves(IDirectMusicPerformance* pPerformance);

protected:
    void Construct(void);
    HRESULT Play(
        void *pStateData,   
        REFERENCE_TIME rtStart, 
        REFERENCE_TIME rtEnd,
      //  MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,      
        IDirectMusicPerformance* pPerf, 
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        BOOL fClockTime);
    void InsertByAscendingPChannel( TListItem<WavePart>* pPart );
    HRESULT CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    void CleanUpTempParts();
    void MovePartsToTemp();
    IDirectSoundDownloadedWaveP* FindDownload(TListItem<WaveItem>* pItem);
    void SetUpStateCurrentPointers(WaveStateData* pStateData);
    HRESULT STDMETHODCALLTYPE Seek( 
        IDirectMusicSegmentState*,
        IDirectMusicPerformance*,
        DWORD dwVirtualID,
        WaveStateData*,
        REFERENCE_TIME rtTime,
        BOOL fGetPrevious,
//      MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
    HRESULT SyncVariations(IDirectMusicPerformance* pPerf, 
        WaveStateData* pSD, 
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtOffset,  
        BOOL fClockTime);
    HRESULT ComputeVariations(WaveStateData* pSD);
    HRESULT ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD);
    WaveStateData* FindState(IDirectMusicSegmentState* pSegState);
    HRESULT InitTrack(DWORD dwPChannels);
    HRESULT GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice);
    void RemoveDownloads(WaveStateData* pStateData);

    static void FlushWaves();

// member variables
private:
    long                m_cRef;
    CRITICAL_SECTION    m_CrSec;
    BOOL                m_fCSInitialized;

    long                m_lVolume;
    DWORD               m_dwTrackFlags; // Only current flag is DMUS_WAVETRACKF_SYNC_VAR
    DWORD               m_dwPChannelsUsed;
    DWORD*              m_aPChannels;
    TList<WavePart>     m_WavePartList;
    TList<WavePart>     m_TempWavePartList; // keep this around when reloading the track
    DWORD               m_dwValidate; // used to validate state data
    CPChMap             m_PChMap;
#ifdef DXAPI
    DWORD               m_dwVariation;   // selected variations to audition
    DWORD               m_dwPart;        // PChannel of part for auditioning variations
    DWORD               m_dwIndex;       // Index of part for auditioning variations
    DWORD               m_dwLockID;      // For locking to the part being auditioned
    BOOL                m_fAudition;     // Am I auditioning variations?
    BOOL                m_fAutoDownload;
    BOOL                m_fLockAutoDownload; // if true, this flag indicates that we've specifically
                                // commanded the band to autodownload. Otherwise,
                                // it gets its preference from the performance via
                                // GetGlobalParam.
#endif
    DWORD*              m_pdwVariations;        // Track's array of variations (1 per part)
    DWORD*              m_pdwRemoveVariations;  // Track's array of variations already played (1 per part)
    DWORD               m_dwWaveItems;          // Total number of wave items in the track

#ifdef DXAPI
    TList<StatePair>    m_StateList;            // The track's state information
    TList<WavePair>     m_WaveList;             // Information about waves downloaded to the track
#endif
    static long         st_RefCount;            // global count of # of instantiated wave tracks
};

#endif //__WAVTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\guids.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
//#include "initguid.h"
//#include "pchloader.h"
/*#include "dmusicc.h" 
#include "dmusicip.h"
#include "loader.h"
#include "dmscriptautguids.h"*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\sysextrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include "pchime.h"
/*
// SysExTrk.cpp : Implementation of CSysExTrk
#include "dmime.h"
#include "SysExTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert*/

/////////////////////////////////////////////////////////////////////////////
// CSysExTrack
void CSysExTrack::Construct()
{
    IncrementDLLCount();

	m_cRef = 1;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CSysExTrack::CSysExTrack() : m_MemTrack(DMTRACK_SYSEX_TRACK)
{
	Construct();
}

CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd): m_MemTrack(DMTRACK_SYSEX_TRACK)
{
	Construct();
	SysExListItem* pScan = rTrack.m_SysExEventList.GetHead();

	for(; pScan; pScan = pScan->GetNext())
	{
		FullSysexEvent* pItem = pScan->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		else if( pItem->mtTime < mtStart )
		{
			continue;
		}
		else if (pItem->mtTime < mtEnd)
		{
			SysExListItem* pNew = new SysExListItem;
			if (pNew)
			{
				FullSysexEvent item;
				item.mtTime = pItem->mtTime - mtStart;
				item.dwSysExLength = pItem->dwSysExLength;
				if (item.dwSysExLength && (item.pbSysExData = new BYTE[item.dwSysExLength]))
                {
					memcpy( item.pbSysExData, pItem->pbSysExData, item.dwSysExLength );
					pNew->SetItem(item);
					m_SysExEventList.AddTail(pNew);
				}
                else
                {
                    delete pNew;
                }
			}
		}
		else break;
	}
}

CSysExTrack::~CSysExTrack()
{
    if (m_fCSInitialized)
    {
	    DELETE_CRITICAL_SECTION(&m_CrSec);
    }

    DecrementDLLCount();
}

// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSysExTrack>
//
// parm const IID & | iid | Interface to query for
// parm void ** | ppv | The requested interface will be returned here
//
// rdesc Returns one of the following:
//
// flag S_OK | If the interface is supported and was returned
// flag E_NOINTERFACE | If the object does not support the given interface.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP CSysExTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSysExTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sysex Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | Release | Standard Release implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSysExTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CSysExTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSysExTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSysExTrack::IsDirty()
{
	return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | Load |
  Call this with an IStream filled with SysExEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SysExEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SysExEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SysExTrack is released.
*/
HRESULT CSysExTrack::Load( IStream* pIStream )
{
	V_INAME(CSysExTrack::Load);
	V_INTERFACE(pIStream);

	ENTER_CRITICAL_SECTION(&m_CrSec);
	HRESULT hr = S_OK;

	m_dwValidate++;
	if( m_SysExEventList.GetHead() )
	{
		m_SysExEventList.DeleteAll();
	}

	// copy contents of the stream into the list.
	//DMUS_IO_SYSEX_ITEM sysexEvent;
	FullSysexEvent sysexEvent;
	// read in the chunk id
	DWORD dwChunk;
	long lSize;
	pIStream->Read( &dwChunk, sizeof(DWORD), NULL);
	if( dwChunk != DMUS_FOURCC_SYSEX_TRACK )
	{
        Trace(1,"Error: Invalid data in sysex track.\n");
        LEAVE_CRITICAL_SECTION(&m_CrSec);
		return DMUS_E_CHUNKNOTFOUND;
	}
	// read in the overall size
	pIStream->Read( &lSize, sizeof(long), NULL );
	DMUS_IO_SYSEX_ITEM SysexItem;
	BYTE* pbSysExData;
	while( lSize > 0 )
	{
		pIStream->Read( &SysexItem, sizeof(DMUS_IO_SYSEX_ITEM), NULL );
		lSize -= sizeof(DMUS_IO_SYSEX_ITEM);
		pbSysExData = new BYTE[SysexItem.dwSysExLength];
		if( !pbSysExData )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		if( FAILED( pIStream->Read( pbSysExData, SysexItem.dwSysExLength, NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			delete [] pbSysExData;
			break;
		}
		lSize -= SysexItem.dwSysExLength;
		sysexEvent.mtTime = SysexItem.mtTime;
		sysexEvent.dwPChannel = SysexItem.dwPChannel;
		sysexEvent.dwSysExLength = SysexItem.dwSysExLength;
		sysexEvent.pbSysExData = pbSysExData;
		SysExListItem* pNew = new SysExListItem;
		if (pNew)
		{
			if( FAILED( pNew->SetItem(sysexEvent)))
			{
				delete [] pbSysExData;
				hr = E_OUTOFMEMORY;
				break;
			}
			m_SysExEventList.AddTail(pNew);
		}
		else
		{
			delete [] pbSysExData;
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CSysExTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSysExTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CSysExTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a Segment, it's Init() routine is called
by that Segment.

parm IDirectMusicSegment* | pSegment |
[in] Pointer to the Segment to which this Track belongs.

rvalue S_OK
*/
HRESULT CSysExTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CSysExTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SysExStateData* pStateData;
	pStateData = new SysExStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
	pStateData->dwVirtualTrackID = dwTrackID;
	pStateData->pPerformance = pPerformance; // weak reference, no addref.
	pStateData->pSegState = pSegmentState; // weak reference, no addref.
	pStateData->pCurrentSysEx = m_SysExEventList.GetHead();
	pStateData->dwValidate = m_dwValidate;
	return S_OK;
}

HRESULT CSysExTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(SysExStateData));
		SysExStateData* pSD = (SysExStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

/*

  method HRESULT | CSysExTrack | Play |
  Play method.
  rvalue S_FALSE | If there has been no stream loaded into the Track.
  rvalue S_OK
*/
HRESULT CSysExTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	ENTER_CRITICAL_SECTION(&m_CrSec);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

HRESULT CSysExTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	IDirectMusicGraph* pGraph = NULL;
	DMUS_SYSEX_PMSG* pSysEx;
	SysExStateData* pSD = (SysExStateData*)pStateData;
	HRESULT	hr = S_OK;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	// if pSD->pCurrentSysEx is NULL, and we're in a normal Play call (dwFlags is 0)
	// this means that we either have no events, or we got to the end of the event
	// list previously. So, it's safe to just return.
	if( (pSD->pCurrentSysEx == NULL) && (dwFlags == 0) )
	{
		return S_FALSE;
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		pSD->dwValidate = m_dwValidate;
		pSD->pCurrentSysEx = NULL;
	}
	if( NULL == m_SysExEventList.GetHead() )
	{
		return DMUS_S_END;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->mtPrevEnd != mtStart ))
	{
		Seek( pStateData, mtStart );
	}
	else if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	pSD->mtPrevEnd = mtEnd;

	if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		if( pItem->mtTime >= mtEnd )
		{
			// this time is in the future. Return now to retain the same
			// seek pointers for next time.
			hr = S_OK;
			break;
		}
		if( (pItem->mtTime < mtStart) && !fSeek )
		{
			break;
		}
		// allocate a DMUS_SYSEX_PMSG of the approriate size and read 
		// the sysex data into it
		if( SUCCEEDED( hr = pSD->pPerformance->AllocPMsg( 
			sizeof(DMUS_SYSEX_PMSG) + pItem->dwSysExLength, (DMUS_PMSG**)&pSysEx ) ) )
		{
			memcpy( pSysEx->abData, pItem->pbSysExData, pItem->dwSysExLength );
            if (fClockTime)
            {
                pSysEx->rtTime = (pItem->mtTime  * REF_PER_MIL) + rtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

            }
            else
            {
			    pSysEx->mtTime = pItem->mtTime + mtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_MUSICTIME;
            }
			pSysEx->dwLen = pItem->dwSysExLength;
			pSysEx->dwPChannel = 0;
			pSysEx->dwVirtualTrackID = pSD->dwVirtualTrackID;
			pSysEx->dwType = DMUS_PMSGT_SYSEX;
			pSysEx->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pSysEx );
			}
			if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pSysEx )))
			{
				pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pSysEx );
			}
		}
        else
        {
            hr = DMUS_S_END;
            break;
        }
	}
	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

HRESULT CSysExTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime)
{
	SysExStateData* pSD = (SysExStateData*)pStateData;

	if( NULL == m_SysExEventList.GetHead() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
	if( pItem->mtTime >= mtTime )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		pItem = pSD->pCurrentSysEx->m_pItem;
		if( pItem->mtTime >= mtTime )
		{
			break;
		}
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) || (mtStart > mtEnd))
	{
        Trace(1,"Error: Unable to clone sysex track, invalid start parameter.\n",mtStart);
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION(&m_CrSec);

    CSysExTrack *pDM;
    NEWCATCH(pDM,CSysExTrack(*this, mtStart, mtEnd))
/*    try
    {
        pDM = new CSysExTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }*/

	LEAVE_CRITICAL_SECTION(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}


STDMETHODIMP CSysExTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\ima.h ===
// Copyright (c) 1998 Microsoft Corporation
// IMA.h : Declaration of private interface for IMA legacy mode.
//
//

#ifndef __IMA_H_
#define __IMA_H_


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX


#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif


#undef  INTERFACE
#define INTERFACE  IDirectMusicIMA
DECLARE_INTERFACE_(IDirectMusicIMA, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicIMA */
	STDMETHOD(LegacyCaching)		(THIS_ BOOL fEnable) PURE;
};

DEFINE_GUID(IID_IDirectMusicIMA,0xd2ac28b3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef __IMA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]   		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\container.cpp ===
// Container.cpp : Implementation of CContainer
//
// Copyright (c) 1999-1999 Microsoft Corporation
//
//

/*#include "dmusicc.h" 
#include "dmusicip.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "container.h"
#include "loader.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "smartref.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#endif*/

#include "pchloader.h"

extern long g_cComponent;

CContainerItem::CContainerItem(bool fEmbedded)

{
    m_Desc.dwSize = sizeof(m_Desc);
    m_Desc.dwValidData = 0;
    m_dwFlags = 0;
    m_pObject = NULL;
    m_fEmbedded = fEmbedded;
    m_pwszAlias = NULL;
}

CContainerItem::~CContainerItem()

{
    if (m_pObject)
    {
        m_pObject->Release();
    }
    if (m_Desc.dwValidData & DMUS_OBJ_STREAM)
    {
        SafeRelease(m_Desc.pStream);
    }
    delete m_pwszAlias;
}

CContainer::CContainer() : m_MemTrack(DMTRACK_CONTAINER)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwPartialLoad = 0;
    m_pStream = NULL;
    m_fZombie = false;
}

CContainer::~CContainer()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
    }
}

void CContainer::Clear()
{
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (m_pStream)
    {
        m_pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    CContainerItem *pItem = m_ItemList.GetHead();
    CContainerItem *pNext;
    for (;pItem;pItem = pNext)
    {
        pNext = pItem->GetNext();
        if (pItem->m_pObject)
        {
            if (pLoader && !(pItem->m_dwFlags & DMUS_CONTAINED_OBJF_KEEP))
            {
#ifdef DXAPI
                pLoader->ReleaseObject(pItem->m_pObject);
#else
                pLoader->ReleaseObjectByUnknown(pItem->m_pObject);
#endif
            }
            pItem->m_pObject->Release();
            pItem->m_pObject = NULL;
        }
        delete pItem;
    }
    if (pLoader)
    {
        pLoader->Release();
    }
}

STDMETHODIMP_(void) CContainer::Zombie()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }
    m_fZombie = true;
}

STDMETHODIMP_(ULONG) CContainer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CContainer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CContainer::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IDirectMusicContainer) {
        *ppvObj = static_cast<IDirectMusicContainer*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObject)
    {
        *ppvObj = static_cast<IDirectMusicObject*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObjectP)
    {
        *ppvObj = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (riid == IID_IPersistStream) 
    {
        *ppvObj = static_cast<IPersistStream*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

HRESULT CContainer::EnumObject(REFGUID rguidClass,
                               DWORD dwIndex,
                               LPDMUS_OBJECTDESC pDesc,
                               WCHAR *pwszAlias)
{
    V_INAME(CContainer::EnumObject);
    V_PTR_WRITE_OPT(pDesc, LPDMUS_OBJECTDESC);
    V_BUFPTR_WRITE_OPT(pwszAlias, MAX_PATH);
    V_REFGUID(rguidClass);

    CHECK_ZOMBIE(m_fZombie)
    
    CContainerItem *pItem = m_ItemList.GetHead();
    DWORD dwCounter = 0;
    HRESULT hr = S_FALSE;
    for (;pItem;pItem = pItem->GetNext())
    {
        if ((rguidClass == GUID_DirectMusicAllTypes) || 
            (rguidClass == pItem->m_Desc.guidClass))
        {
            if (dwCounter == dwIndex)
            {
                hr = S_OK;
                if (pDesc)
                {
                    DWORD dwCopySize = min(pDesc->dwSize,pItem->m_Desc.dwSize);
                    memcpy(pDesc,&pItem->m_Desc,dwCopySize);
                    if (pDesc->dwValidData & DMUS_OBJ_STREAM && pDesc->pStream)
                        pDesc->pStream->AddRef();
                }
                if (pwszAlias)
                {
                    hr = wcsTruncatedCopy(pwszAlias, pItem->m_pwszAlias ? pItem->m_pwszAlias : L"", MAX_PATH);
                }
                break;
            }
            dwCounter++;
        }
    }
    return hr;
}

HRESULT CContainer::Load(CRiffParser *pParser, IDirectMusicLoader *pLoader)

{
    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    DMUS_IO_CONTAINER_HEADER ioHeader;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_CONTAINER_CHUNK :
            hr = pParser->Read(&ioHeader, sizeof(DMUS_IO_CONTAINER_HEADER));
            m_dwFlags = ioHeader.dwFlags;
            break;
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
            case DMUS_FOURCC_UNFO_LIST:
                hr = m_Info.ReadChunk(pParser,ckNext.fccType);
				break;
            case DMUS_FOURCC_CONTAINED_OBJECTS_LIST :
                pParser->EnterList(&ckChild);
                while(pParser->NextChunk(&hr))
                {
                    switch(ckChild.ckid)
                    {
                    case FOURCC_RIFF:
                    case FOURCC_LIST:
                        switch(ckChild.fccType)
                        {
                        case DMUS_FOURCC_CONTAINED_OBJECT_LIST :
                            hr = LoadObject(pParser, pLoader);
                            break;
                        }
                        break;
                    }
                }
                pParser->LeaveList();
            }
        }
    }
    pParser->LeaveList();
    if (SUCCEEDED(hr))
    {
        pParser->LeaveList(); // This is to ascend the caller completely outside the container.
        if (!(m_dwFlags & DMUS_CONTAINER_NOLOADS))
        {
            for (CContainerItem *pItem = m_ItemList.GetHead();pItem && SUCCEEDED(hr);pItem = pItem->GetNext())
            {
#ifdef DXAPI
                if (FAILED(pLoader->GetObject(&pItem->m_Desc,
                    IID_IDirectMusicObject,
                    (void **)&pItem->m_pObject)))
                {
                    hr = DMUS_S_PARTIALLOAD;
                }
#else
                hr = pLoader->GetObject(&pItem->m_Desc,IID_IDirectMusicObject,
                    (void **)&pItem->m_pObject);
#endif
            }
        }

        if (m_pStream)
        {
            m_pStream->Release();
        }
        m_pStream = pParser->GetStream();
        m_pStream->AddRef();
    }
    return hr;
}


HRESULT CContainer::LoadObject(CRiffParser *pParser,
                              IDirectMusicLoader *pLoader)
{
    RIFFIO ckNext;
    DMUS_IO_CONTAINED_OBJECT_HEADER ioHeader;
    HRESULT hr = S_OK;
    DWORD dwStep = 0;
    SmartRef::Buffer<WCHAR> wbufAlias;
    pParser->EnterList(&ckNext);  
    while (pParser->NextChunk(&hr))
    {
        switch (ckNext.ckid)
        {
        case DMUS_FOURCC_CONTAINED_ALIAS_CHUNK:
            if (dwStep > 1) hr = DMUS_E_INVALID_CONTAINER_OBJECT;
            else
            {
                wbufAlias.Alloc(ckNext.cksize / 2);
                if (wbufAlias) 
                {
                    hr = pParser->Read(wbufAlias,ckNext.cksize);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            break;
        case DMUS_FOURCC_CONTAINED_OBJECT_CHUNK:
            if (dwStep > 1) hr = DMUS_E_INVALID_CONTAINER_OBJECT;
            else
            {
                hr = pParser->Read(&ioHeader, sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER));
                if(ioHeader.ckid == 0 && ioHeader.fccType == NULL)
                {
                    Trace(1,"Invalid object header in Container.\n");
                    hr = DMUS_E_INVALID_CONTAINER_OBJECT;
                }
            }
            dwStep = 1;
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            if (dwStep < 1) hr = DMUS_E_INVALID_CONTAINER_OBJECT;
            else
            {
                dwStep = 2;
                if ((ckNext.fccType == ioHeader.fccType) || (ckNext.ckid == ioHeader.ckid))
                {
                    // Okay, this is the chunk we are looking for.
                    // Seek back to start of chunk.
                    bool fEmbedded = !(ckNext.ckid == FOURCC_LIST && ckNext.fccType == DMUS_FOURCC_REF_LIST);
                    CContainerItem *pItem = new CContainerItem(fEmbedded);
                    if (!pItem)
                        hr = E_OUTOFMEMORY;
                    else
                    {
                        if (fEmbedded)
                        {
                            // This is an embedded object.  Return to the position where from which it will be loaded.
                            pParser->SeekBack();
                            pItem->m_Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                            pItem->m_Desc.guidClass = ioHeader.guidClassID;
                            pItem->m_Desc.pStream = pParser->GetStream();
                            pItem->m_Desc.pStream->AddRef();
                        }
                        else
                        {
                            // This is a reference chunk.  Read the object descriptor.
                            CLinkParser LinkParser;
                            hr = LinkParser.ReadReference(pParser, &pItem->m_Desc);
                        }

                        if (SUCCEEDED(hr))
                        {
                            // We will call SetObject on items in the container here.  The items are loaded later.
                            // This ensures that out-of-order references between objects can be retrieved as the objects
                            // load themselves.
#ifdef DXAPI
                            pLoader->SetObject(&pItem->m_Desc);
#else
                            hr = pLoader->SetObject(&pItem->m_Desc);
#endif
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (pItem->m_Desc.dwValidData & DMUS_OBJ_STREAM)
                            {
                                // The loader has the stream now so we don't need it any more.
                                pItem->m_Desc.dwValidData &= ~DMUS_OBJ_STREAM;
                                SafeRelease(pItem->m_Desc.pStream);
                                pParser->SeekForward();
                            }
                            pItem->m_pwszAlias = wbufAlias.disown();
                            m_ItemList.AddTail(pItem);
                        }
                        else
                        {
                            delete pItem;
                        }
                    }
                }
            }
        }
    }
    pParser->LeaveList();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CContainer::GetClassID( CLSID* pClassID )
{
    if (pClassID)
    {
        *pClassID = CLSID_DirectMusicContainer;
        return S_OK;
    }
    return E_POINTER;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CContainer::IsDirty()
{
    return S_FALSE;
}

HRESULT CContainer::Load( IStream* pStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pStream);

    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (pStream)
    {
        pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    if (pLoader)
    {
        HRESULT hr = S_OK;
        CRiffParser Parser(pStream);
        RIFFIO ckMain;
        Parser.EnterList(&ckMain);  
        if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_CONTAINER_FORM))
        {
            hr = Load(&Parser, pLoader);
        }
        else
        {
            Trace(1,"Error: Failed parsing - file is not in Container format.\n");
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
        pLoader->Release();
        return hr;
    }
    Trace(1, "Error: unable to load container from a stream because it doesn't support the IDirectMusicGetLoader interface.\n");
    return DMUS_E_UNSUPPORTED_STREAM;
}


HRESULT CContainer::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CContainer::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    CHECK_ZOMBIE(m_fZombie)
    
    return (m_Info.GetDescriptor(pDesc,CLSID_DirectMusicContainer));
}

STDMETHODIMP CContainer::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC); 
    
    CHECK_ZOMBIE(m_fZombie)

    return (m_Info.SetDescriptor(pDesc));
}

STDMETHODIMP CContainer::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CContainer::ParseDescriptor);
    V_INTERFACE(pStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    return (m_Info.ParseDescriptor(pStream,pDesc,DMUS_FOURCC_CONTAINER_FORM,CLSID_DirectMusicContainer));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\riff.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD(Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT /*wFlags*/);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\pchloader.h ===
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#include <mmsystem.h>
#undef timeGetTime 
#define timeGetTime GetTickCount
#include "..\shared\dmusiccp.h"
#include "..\shared\xsoundp.h" // For GUID_All_Objects
extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);
#else // XBOX
#include <windows.h>
#include <objbase.h> // Need IClassFactory
#include <mmsystem.h>
#endif // XBOX
#include "..\shared\critsec.h"
#include "dmusicc.h" 
#include "dmusicip.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "loader.h"
#include "container.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "smartref.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif
#ifdef DXAPI
#include <regstr.h>
#include <share.h>
extern long g_cComponent;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CLoaderFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#ifdef DXAPI
#pragma warning(disable:4530)
#endif

/*#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include "debug.h"

#ifndef XBOX
#include "oledll.h"
#endif // XBOX
#include "debug.h" 
#include "dmusicc.h"
#include "dmusicip.h" 
#include "loader.h"
#include "container.h"

#ifdef DXAPI
#include <regstr.h>
#endif // XBOX
*/

#include "pchloader.h"

// Globals
//

// Version information for our class
//
#ifdef DXAPI
TCHAR g_szFriendlyName[]        = TEXT("DirectMusicLoader");
TCHAR g_szVerIndProgID[]        = TEXT("Microsoft.DirectMusicLoader");
TCHAR g_szProgID[]              = TEXT("Microsoft.DirectMusicLoader.1");
TCHAR g_szContFriendlyName[]    = TEXT("DirectMusicContainer");
TCHAR g_szContVerIndProgID[]    = TEXT("Microsoft.DirectMusicContainer");
TCHAR g_szContProgID[]          = TEXT("Microsoft.DirectMusicContainer.1");
#endif // DXAPI

// Dll's hModule
//
#ifndef XBOX
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;
#endif // XBOX




#ifndef XBOX
// CLoaderFactory::QueryInterface
//
HRESULT __stdcall
CLoaderFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CLoaderFactory::CLoaderFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CLoaderFactory::~CLoaderFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CLoaderFactory::AddRef
//
ULONG __stdcall
CLoaderFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CLoaderFactory::Release
//
ULONG __stdcall
CLoaderFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CLoaderFactory::CreateInstance
//
//
HRESULT __stdcall
CLoaderFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CLoader *pLoader;
    
    try
    {
        pLoader = new CLoader;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pLoader == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pLoader->Init();
    if (!SUCCEEDED(hr)) {
        delete pLoader;
        return hr;
    }

    hr = pLoader->QueryInterface(iid, ppv);
    pLoader->Release();
    
    return hr;
}

// CLoaderFactory::LockServer
//
HRESULT __stdcall
CLoaderFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// CContainerFactory::QueryInterface
//
HRESULT __stdcall
CContainerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CContainerFactory::CContainerFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CContainerFactory::~CContainerFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CContainerFactory::AddRef
//
ULONG __stdcall
CContainerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CContainerFactory::Release
//
ULONG __stdcall
CContainerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CContainerFactory::CreateInstance
//
//
HRESULT __stdcall
CContainerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CContainer *pContainer;
    
    try
    {
        pContainer = new CContainer;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pContainer == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pContainer->QueryInterface(iid, ppv);
    pContainer->Release();
    
    return hr;
}

// CContainerFactory::LockServer
//
HRESULT __stdcall
CContainerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;

        if(clsid == CLSID_DirectMusicLoader)
        {
            pIUnknown = static_cast<IUnknown*> (new CLoaderFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }
        else if(clsid == CLSID_DirectMusicContainer)
        {
            pIUnknown = static_cast<IUnknown*> (new CContainerFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }

        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicLoader,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);
    UnregisterServer(CLSID_DirectMusicContainer,
                     g_szContFriendlyName,
                     g_szContVerIndProgID,
                     g_szContProgID);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicLoader,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicContainer,
                   g_szContFriendlyName,
                   g_szContVerIndProgID,
                   g_szContProgID);
    return S_OK; 
}
#endif // XBOX

#ifndef XBOX

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
#ifdef DBG
    else if(dwReason == DLL_PROCESS_DETACH) {
        if (--nReferenceCount == 0)
        {
            TraceI(-1, "Unloading DMLoader : g_cLock = %d, g_cComponent = %d", g_cLock, g_cComponent);

            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
        }
    }
#endif
    return TRUE;
}

#endif // XBOX

#ifdef XBOX

STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader )

{
    HRESULT hr;

    CLoader *pLoader;
    
    pLoader = new CLoader;

    if (pLoader == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pLoader->Init();
    if (!SUCCEEDED(hr)) {
        delete pLoader;
        return hr;
    }

    hr = pLoader->QueryInterface(iid, ppLoader);
    pLoader->Release();
    
    return hr;
}

STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer )
{
    HRESULT hr;

    CContainer *pContainer;
    
    pContainer = new CContainer;

    if (pContainer == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pContainer->QueryInterface(iid, ppContainer);
    pContainer->Release();
    
    return hr;
}

STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream )
{
    HRESULT hr;

    CMemStream *pStream  = new CMemStream;

    if (pStream == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pStream->QueryInterface(iid, ppStream);
    return hr;
}

STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream )
{
    HRESULT hr;

    CFileStream *pStream  = new CFileStream;

    if (pStream == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pStream->QueryInterface(iid, ppStream);
    return hr;
}

STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream )
{
    HRESULT hr;

    CStream *pStream  = new CStream;

    if (pStream == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pStream->QueryInterface(iid, ppStream);
    return hr;
}


/*#if 0

void * __cdecl 
operator new
(
    size_t                  size
)
{
    return LocalAlloc(LPTR, size);
}

void __cdecl
operator delete
(
    void *                  pv
)
{
    LocalFree(pv);
}

#endif*/

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\sources.inc ===
!include ..\..\sources.inc

TARGETNAME = dmloader$(LIBEXT)
TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj

USE_MAPSYM = 1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!endif

C_DEFINES = $(C_DEFINES) -DXBOX -DUNICODE

INCLUDES = $(INCLUDES);\
           ..\..\shared;\
           ..\..\xprivate; \
           ..

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchloader.h
PRECOMPILED_PCH=pchloader.pch
PRECOMPILED_OBJ=pchloader.obj

SOURCES = container.cpp\
          dll.cpp\
          loader.cpp\
          object.cpp\
          stream.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autaudiopath.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicAudioPath.
//

/*#include "stdinc.h"
#include "autaudiopath.h"*/
#include "pchscript.h"

const WCHAR CAutDirectMusicAudioPath::ms_wszClassName[] = L"AudioPath";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_SetVolume = 1;
const DISPID DMPDISP_GetVolume = 2;

const AutDispatchMethod CAutDirectMusicAudioPath::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_SetVolume,				L"SetVolume",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// volume
						ADT_Long,		true,	&IID_NULL,						// duration
						ADT_None },
		{ DMPDISP_GetVolume,				L"GetVolume",
						ADT_Long,		true,	&IID_NULL,						// returned volume
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicAudioPath> CAutDirectMusicAudioPath::ms_Handlers[] =
	{
		{ DMPDISP_SetVolume, SetVolume },
		{ DMPDISP_GetVolume, GetVolume },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicAudioPath::CAutDirectMusicAudioPath(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpAudioPath(pUnknownOuter, iid, ppv, phr),
	m_lVolume(0)
{
}

HRESULT
CAutDirectMusicAudioPath::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicAudioPath *pInst = new CAutDirectMusicAudioPath(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicAudioPath::SetVolume(AutDispatchDecodedParams *paddp)
{
	LONG lVol = paddp->params[0].lVal;
	LONG lDuration = paddp->params[1].lVal;

	m_lVolume = ClipLongRange(lVol, -9600, 0);
	return m_pITarget->SetVolume(m_lVolume, lDuration);
}

HRESULT
CAutDirectMusicAudioPath::GetVolume(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_lVolume;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autaudiopath.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicAudioPath.
// IDispatch interface for IDirectMusicAudioPath.
// Unly usable via aggregation within an IDirectMusicAudioPath object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicAudioPath;
typedef CAutBaseImp<CAutDirectMusicAudioPath, IDirectMusicAudioPath, &IID_IDirectMusicAudioPath> BaseImpAudioPath;

class CAutDirectMusicAudioPath
  : public BaseImpAudioPath
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicAudioPath(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT SetVolume(AutDispatchDecodedParams *paddp);
	HRESULT GetVolume(AutDispatchDecodedParams *paddp);

	LONG m_lVolume;

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicAudioPath> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autaudiopathconfig.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicAudioPathConfig.
//

/*#include "stdinc.h"
#include "autaudiopathconfig.h"
#include "activescript.h"*/

#include "pchscript.h"

const WCHAR CAutDirectMusicAudioPathConfig::ms_wszClassName[] = L"AudioPathConfig";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Create = 2;

const AutDispatchMethod CAutDirectMusicAudioPathConfig::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_Load, 						L"Load",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Create,						L"Create",
						ADT_Interface,	true,	&IID_IUnknown,					// returned audiopath
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicAudioPathConfig> CAutDirectMusicAudioPathConfig::ms_Handlers[] =
	{
		{ DMPDISP_Load, Load },
		{ DMPDISP_Create, Create },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicAudioPathConfig::CAutDirectMusicAudioPathConfig(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpAPConfig(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicAudioPathConfig::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicAudioPathConfig *pInst = new CAutDirectMusicAudioPathConfig(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicAudioPathConfig::Load(AutDispatchDecodedParams *paddp)
{
	// Loading is actually implemented generically by container items.
	// If we're here, we're already loaded and don't need to do anything.
	return S_OK;
}

HRESULT
CAutDirectMusicAudioPathConfig::Create(AutDispatchDecodedParams *paddp)
{
	IDirectMusicAudioPath **ppAudioPath = reinterpret_cast<IDirectMusicAudioPath **>(paddp->pvReturn);
	if (!ppAudioPath)
		return S_OK;

	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	hr = pPerformance->CreateAudioPath(m_pITarget, TRUE, ppAudioPath);
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autaudiopathconfig.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicAudioPathConfig.
// IDispatch interface for IUnknown.
// Unly usable via aggregation within an IUnknown object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicAudioPathConfig;
typedef CAutBaseImp<CAutDirectMusicAudioPathConfig, IDirectMusicObject, &IID_IPersistStream> BaseImpAPConfig;

class CAutDirectMusicAudioPathConfig
  : public BaseImpAPConfig
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicAudioPathConfig(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Create(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicAudioPathConfig> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autbaseimp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Templated base class CAutBaseImp for constructing automation interfaces.
// Implements aggregation and IDispatched based on a table of method information.
//

#pragma once
#include "authelper.h"

// Inherit your class from CAutBaseImp with the following template types:
//	* T_derived is the type of your class itself.
//	* T_ITarget is the DirectMusic interface you are implemention automation for.
//	* T_piid is the address of the IID of T_ITarget.

// Your class must have the following public static members:
//	* static const AutDispatchMethod ms_Methods[];
//		This table describes your methods and their parameters.
//	* static const DispatchHandlerEntry<T_derived> ms_Handlers[];
//		This table designates member functions on your class that will be called when
//		your methods are invoked.
// 	* static const WCHAR ms_wszClassName[];
//		This is the name of your class that will be output in the debug log
//		as your functions are called.


// See autperformance.h and autperformance.cpp for an example of using this base class.

template <class T_derived>
struct DispatchHandlerEntry
	{
		typedef HRESULT (T_derived::* pmfnDispatchHandler)(AutDispatchDecodedParams *paddp);

		DISPID dispid;
		pmfnDispatchHandler pmfn;
	};

template <class T_derived, class T_ITarget, const IID *T_piid>
class CAutBaseImp
  : public CAutUnknown::CAutUnknownParent,
	public IDispatch
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

protected:
	CAutBaseImp(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr);
	virtual ~CAutBaseImp() {}

	T_ITarget *m_pITarget;

private:
	CAutUnknown m_UnkControl;
	virtual void Destroy();
};

#include "autbaseimp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autconstants.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Functions that implement the automation interfaces for the DirectMusic constants.
// This is a table of names and integer values that are implemented as read-only properties.
//

#pragma once

namespace ScriptConstants
{
	const LONG IsSecondary		= (1 << 0);
	const LONG IsControl		= (1 << 1);
	const LONG AtFinish			= (1 << 2);
	const LONG AtGrid			= (1 << 3);
	const LONG AtBeat			= (1 << 4);
	const LONG AtMeasure		= (1 << 5);
	const LONG AtMarker			= (1 << 6);
	const LONG AtImmediate		= (1 << 7);
	const LONG AlignToBar		= (1 << 8);
	const LONG AlignToBeat		= (1 << 9);
	const LONG AlignToSegment	= (1 << 10);
	const LONG PlayFill			= (1 << 11);
	const LONG PlayIntro		= (1 << 12);
	const LONG PlayBreak		= (1 << 13);
	const LONG PlayEnd			= (1 << 14);
	const LONG PlayEndAndIntro	= (1 << 15);
	const LONG PlayModulate		= (1 << 16);
	const LONG NoCutoff			= (1 << 17);
};

HRESULT AutConstantsGetIDsOfNames(
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId);

HRESULT AutConstantsInvoke(
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			EXCEPINFO __RPC_FAR *pExcepInfo,
			UINT __RPC_FAR *puArgErr);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\loader.cpp ===
// Loader.cpp : Implementation of CLoader
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

/*#ifdef XBOX
#include <xtl.h>
#endif // XBOX
#include "dmusicc.h" 
#include "dmusicip.h" 
#include "validate.h"
#include "loader.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "miscutil.h"
#ifndef XBOX
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif
#endif // XBOX

#ifndef XBOX
extern long g_cComponent;
#endif // XBOX

*/
#include "pchloader.h"

/////////////////////////////////////////////////////////////////////////////
// CLoader


#ifndef XBOX
static HRESULT GetRegStringW( HKEY hKey, WCHAR* lpSubKey, WCHAR* lpValueName, WCHAR* lpwzString )
{
	HKEY  hKeyOpen;
	DWORD dwType;
	DWORD dwCbData;
	LONG  lResult;

	lpwzString[0] = L'\0';
	lResult = RegOpenKeyExW( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = MAX_PATH * sizeof(WCHAR);
		lResult = RegQueryValueExW( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpwzString, &dwCbData );
		if( lResult != ERROR_SUCCESS )
		{
			lpwzString[0] = L'\0';
		}
		else
		{
#ifndef UNDER_CE		
			if( dwType == REG_EXPAND_SZ )
			{
				WCHAR wzTemp[MAX_PATH];
				if( ExpandEnvironmentStringsW( lpwzString, wzTemp, MAX_PATH ) )
				{
					wcscpy(lpwzString, wzTemp);
				}
				else
				{
					lpwzString[0] = L'\0';
				}
			}
			else
#endif
			if( dwType != REG_SZ )
			{
				lpwzString[0] = L'\0';
			}
		}
		RegCloseKey( hKeyOpen );
	}
    return lResult;
}
#endif // XBOX

#ifndef UNDER_CE
#ifndef XBOX
static HRESULT GetRegStringA( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValueName, LPSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwType;
	DWORD dwCbData;
	LONG  lResult;

	lpszString[0] = '\0';
	lResult = RegOpenKeyEx( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = MAX_PATH;
		lResult = RegQueryValueExA( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpszString, &dwCbData );
		if( lResult != ERROR_SUCCESS )
		{
			lpszString[0] = '\0';
		}
		else
		{
			if( dwType == REG_EXPAND_SZ )
			{
				char szTemp[MAX_PATH];
				if( ExpandEnvironmentStringsA( lpszString, szTemp, MAX_PATH ) )
				{
					strcpy(lpszString, szTemp);
				}
				else
				{
					lpszString[0] = '\0';
				}
			}
			else if( dwType != REG_SZ )
			{
				lpszString[0] = '\0';
			}
		}
		RegCloseKey( hKeyOpen );
	}
    return lResult;
}
#endif // XBOX
#endif

HRESULT CLoader::Init()

{
	HRESULT hr;
#ifndef XBOX
#ifndef UNDER_CE
	char szPath[MAX_PATH];
	char szGMFile[MAX_PATH];
#endif	
	WCHAR wzPath[MAX_PATH];
	WCHAR wzGMFile[MAX_PATH];
	// First, get the GM path from the registry, if it exists.
	HRESULT hr;
#ifndef UNDER_CE	
	if( g_fIsUnicode )
#endif
	{
		hr = GetRegStringW( HKEY_LOCAL_MACHINE,
			  L"Software\\Microsoft\\DirectMusic",
			  L"GMFilePath",
			  wzGMFile );
	}
#ifndef UNDER_CE
	else
	{
		hr = GetRegStringA( HKEY_LOCAL_MACHINE,
			  "Software\\Microsoft\\DirectMusic",
			  "GMFilePath",
			  szGMFile );
		mbstowcs(wzGMFile,szGMFile,MAX_PATH);
	}
#endif	
	if (hr == S_OK)
	{
		DMUS_OBJECTDESC DESC;					// Descriptor to use to find it.
		memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
		DESC.dwSize = sizeof (DMUS_OBJECTDESC);
		DESC.guidClass = CLSID_DirectMusicCollection;  
		wcscpy(DESC.wszFileName,wzGMFile);
		DESC.guidObject = GUID_DefaultGMCollection;
		DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | 
			DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
		SetObject(&DESC);
	}
    m_fPathValid = (hr == S_OK);
	if (m_fPathValid)
	{
		if( wzPath[lstrlenW( wzPath ) - 1] != L'\\' )
		{
			lstrcatW( wzPath, L"\\" );
		}
		wcscpy(m_wzPath,wzPath);
	}
#endif // XBOX

	// prepare root node for garbage collection
	assert(!m_pApplicationObject); // this would fail if Init were called twice, which it shouldn't be
	m_pApplicationObject = new CObject(NULL);
	if (!m_pApplicationObject)
		return E_OUTOFMEMORY;
	hr = m_pApplicationObject->GC_Collectable();
	if (FAILED(hr))
	{
		delete m_pApplicationObject;
		m_pApplicationObject = NULL;
		return hr;
	}
	m_pLoadedObjectContext = m_pApplicationObject;

	return S_OK;
}


CLoader::CLoader()
  : m_pLoadedObjectContext(NULL),
	m_pApplicationObject(NULL),
    CMemTrack(DMTRACK_LOADER)
{
    m_fCSInitialized = FALSE;
    m_fFirstLoadTry = FALSE;

	IncrementDLLCount();
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_fCSInitialized = TRUE;

	m_fPathValid = FALSE;
	m_fKeepObjects = TRUE;
	m_cRef = 1;
	m_cPRef = 0;
	m_fIMA = FALSE;
}

CLoader::~CLoader()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to put anything in this list
        //
    	while (!m_ClassList.IsEmpty())
    	{
            CClass *pClass = m_ClassList.RemoveHead();
            delete pClass;
    	}

		while (!m_ReleasedObjectList.IsEmpty())
		{
			CObject *pObject = m_ReleasedObjectList.RemoveHead();
	        delete pObject;
		}

        DELETE_CRITICAL_SECTION(&m_CriticalSection);
    }

    delete m_pApplicationObject;

    DecrementDLLCount();
}

// CLoader::QueryInterface
//
STDMETHODIMP
CLoader::QueryInterface(const IID &iid,
                                   void **ppv)
{
	*ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicLoader || iid == IID_IDirectMusicLoader8) {
        *ppv = static_cast<IDirectMusicLoader8*>(this);
    }
	else if(iid == IID_IDirectMusicLoader8P)
	{
		*ppv = static_cast<IDirectMusicLoader8P*>(this);
	}
#ifdef DXAPI
	else if(iid == IID_IDirectMusicIMA)
	{
		*ppv = static_cast<IDirectMusicIMA*>(this);
	}
#endif
	if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CLoader::AddRef
//
STDMETHODIMP_(ULONG)
CLoader::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CLoader::AddRefP()
{
    return InterlockedIncrement(&m_cPRef);
}

// CLoader::Release
//
STDMETHODIMP_(ULONG)
CLoader::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
	{
		// Ref count of zero indicates that no objects are currently using the loader except for streams.
		// Streams support the GetLoader method and hence we can't delete the loader yet.  These streams
		//    hold private references (AddRefP/ReleaseP).
		// Since no objects other than those streams are currently being used, we'll clear our cache.
		//    This will release any of the Loader's refs on the streams and (assuming nobody else is
		//    holding the streams) bring the private ref count down to zero so we can delete ourself.

		InterlockedIncrement(&m_cRef);		// Keep streams from deleting loader.
		ClearCacheInternal(GUID_DirectMusicAllTypes, true);
		CollectGarbage();
		if (!InterlockedDecrement(&m_cRef))
		{
			if (!m_cPRef)
			{
				delete this;
				return 0;
			}
		}
    }
    return m_cRef;
}

ULONG CLoader::ReleaseP()
{
    if (!InterlockedDecrement(&m_cPRef)) 
	{
		if (!m_cRef)
		{
			delete this;
			return 0;
		}
    }
    return m_cPRef;
}

HRESULT CLoader::GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate)

/*	Scan the class list and find the matching class. 
	If the class can not be found AND fCreate is TRUE,
	create a new class.
*/

{
	*ppClass = NULL;
	if ((pDesc->m_dwValidData & DMUS_OBJ_CLASS) == 0) // We must have a valid class id.
	{
		Trace(1, "The class id field is required and missing in the DMUS_OBJECTDESC.\n");
		return DMUS_E_LOADER_NOCLASSID;
	}
	CClass *pClass = m_ClassList.GetHead();
	for (;pClass != NULL;pClass = pClass->GetNext())
	{
		if (pClass->m_ClassDesc.m_guidClass == pDesc->m_guidClass)
		{
			*ppClass = pClass;
			break;
		}
	}
	if (*ppClass == NULL)
	{
		if (fCreate)
		{
			pClass = new CClass(this, pDesc);
			if (pClass)
			{
				m_ClassList.AddHead(pClass);
				*ppClass = pClass;
			}
			else
			{
				return E_OUTOFMEMORY;
			}
		}
		else
		{
#ifndef XBOX
#ifdef DBG
			WCHAR *polestrClsid = NULL;
			if (S_OK != ProgIDFromCLSID(pDesc->m_guidClass, &polestrClsid))
			{
				StringFromCLSID(pDesc->m_guidClass, &polestrClsid);
			}
			if (polestrClsid)
				Trace(1, "There are no objects of type %S in the loader.\n", polestrClsid);
			CoTaskMemFree(polestrClsid);
#endif
#endif // XBOX
			return DMUS_E_LOADER_OBJECTNOTFOUND;
		}
	}
	return S_OK;
}

#ifdef DBG
const int GC_Report_DebugLevel = 4;

void GC_Report(CLoader *pThis)
{
	struct LocalFunc
	{
		static void ReportObject(CObject *pObject, bool fReportGC, CObject *pApplicationObject)
		{
			if (!(pObject->m_dwScanBits & SCAN_GC) == !fReportGC)
			{
				DMUS_OBJECTDESC desc;
				ZeroMemory(&desc, sizeof(desc));
				pObject->m_ObjectDesc.Get(&desc);
				DebugTrace(GC_Report_DebugLevel, "   *%08X %S [%S]\n", pObject, desc.wszName, desc.wszFileName);
				if (!(desc.dwValidData & DMUS_OBJ_LOADED))
				{
					DebugTrace(GC_Report_DebugLevel, "     Not loaded.\n");
				}

				if (fReportGC)
				{
					// check if object is referenced by the app
					for (UINT i = 0; i < pApplicationObject->m_pvecReferences->size(); ++i)
					{
						if (pObject == (*pApplicationObject->m_pvecReferences)[i])
						{
							DebugTrace(GC_Report_DebugLevel, "     In use by application.\n");
						}
					}

					// output the object's references
					assert(pObject->m_pvecReferences);
					for (i = 0; i < pObject->m_pvecReferences->size(); ++i)
					{
						CObject *pObjectRef = (*pObject->m_pvecReferences)[i];
						DMUS_OBJECTDESC descRef;
						ZeroMemory(&descRef, sizeof(descRef));
						pObjectRef->m_ObjectDesc.Get(&descRef);
						DebugTrace(GC_Report_DebugLevel, "     -%08X %S (%S)\n", pObjectRef, descRef.wszName, descRef.wszFileName);
					}
				}
			}
		}
	};

//	SmartRef::CritSec CS(&pThis->m_CriticalSection);
    ENTER_CRITICAL_SECTION(&pThis->m_CriticalSection);

	DebugTrace(GC_Report_DebugLevel, "Cached non-GC contents of DirectMusic Loader:\n");

	// Do two passes.  One to report non-GC items, one to report GC items.
	for (int fReportGC = 0; fReportGC < 2; ++fReportGC)
	{
		for (CClass *pClass = pThis->m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
		{
			for (CObject *pObject = pClass->m_ObjectList.GetHead(); pObject; pObject = pObject->GetNext())
			{
				LocalFunc::ReportObject(pObject, !!fReportGC, pThis->m_pApplicationObject);
			}
		}

		DebugTrace(GC_Report_DebugLevel, !fReportGC ? "Cached garbage-collected contents:\n" : "Contents released from the cache that aren't yet garbage or haven't been collected:\n");
	}

	for (CObject *pObject = pThis->m_ReleasedObjectList.GetHead(); pObject; pObject = pObject->GetNext())
	{
		assert(pObject->m_dwScanBits & SCAN_GC);
		LocalFunc::ReportObject(pObject, true, pThis->m_pApplicationObject);
	}

	DebugTrace(GC_Report_DebugLevel, "End of cache report.\n\n");
    LEAVE_CRITICAL_SECTION(&pThis->m_CriticalSection);
}
#endif

STDMETHODIMP CLoader::LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
#ifdef XBOX
                                            const char *pszFilePath,
#else
                                            WCHAR *pwzFilePath, 
#endif
                                            void ** ppObject)

{
	V_INAME(IDirectMusicLoader8::LoadObjectFromFile);
#ifdef XBOX
    V_BUFPTR_READ(pszFilePath,1);
    WCHAR pwzFilePath[MAX_PATH];
    mbstowcs( pwzFilePath, pszFilePath, MAX_PATH );
#define FIRSTPASS (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME)
#define SECONDPASS (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH)
#else
    V_BUFPTR_READ(pwzFilePath,2);
#define SECONDPASS (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME)
#define FIRSTPASS (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH)
#endif
    HRESULT hr;
    DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
	assert(pDESC);
    pDESC->dwSize = sizeof (DMUS_OBJECTDESC);
    pDESC->dwValidData = FIRSTPASS;
    wcscpy(pDESC->wszFileName,pwzFilePath);
	pDESC->guidClass = rguidClassID;  
    m_fFirstLoadTry = TRUE; // Don't print an error message if this fails.
	hr = GetObject(pDESC, iidInterfaceID, ppObject);
    m_fFirstLoadTry = FALSE;
    if (FAILED(hr))
    {
        pDESC->dwValidData = SECONDPASS;
        hr = GetObject(pDESC, iidInterfaceID, ppObject);
    }
	delete pDESC;
    return hr;
}


STDMETHODIMP CLoader::GetObject(
	LPDMUS_OBJECTDESC pDESC,	// @parm Description of the requested object in <t DMUS_OBJECTDESC> structure.
    REFIID riid, //@parm The interface to return in <p ppv>
	LPVOID FAR *ppv)	// @parm Receives the interface on success.

{
	HRESULT hr = S_OK;
	HRESULT hrLoad = S_OK;
	CDescriptor Desc;

	V_INAME(IDirectMusicLoader::GetObject);
//	V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC); 
    V_PTRPTR_WRITE(ppv);

    IStream *pStream = pDESC->dwValidData & DMUS_OBJ_STREAM ? pDESC->pStream : NULL;
    if (pStream)
    {
        V_INTERFACE(pStream);
    }

    // if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
    if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
    {
        pDESC->dwValidData |= DMUS_OBJ_FILENAME;
    }
    IDirectMusicObject* pDMObj;
    CClass *pClass;
    CObject *pObject = NULL;

    if (pStream)
    {
        // The loader will save a cloned stream so that it doesn't interfere with
        // the application reading from the stream.
        // Don't worry -- then we'll restore the original stream pointer.
        hr = pStream->Clone(&pDESC->pStream);
        if(FAILED(hr))
        {
            return E_OUTOFMEMORY;
        }
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    Desc.Set(pDESC);
    if (pStream)
    {
        // Restore the stream in the descriptor we were passed.
        pDESC->pStream->Release(); // release matching call to Clone (ref is now held in descriptor)
        pDESC->pStream = pStream;
    }

    hr = GetClass(&Desc,&pClass, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pClass->GetObject(&Desc,&pObject);
        if (SUCCEEDED(hr))
        {
            bool fKeep = !!pClass->m_fKeepObjects;
            bool fGC = fKeep && m_pLoadedObjectContext && m_pLoadedObjectContext->m_dwScanBits & SCAN_GC;

            if (pObject->m_pIDMObject) // Already loaded!
            {
                pObject->m_pIDMObject->AddRef();
                pDMObj = pObject->m_pIDMObject;
                hr = S_OK;
            }
            else
            {
                CObject *pPrevContext;
                if (fGC)
                {
                    // Save a pointer to the current object that will be used to track that it is
                    // the source object if nested calls to GetObject occur while it is loaded.
                    pPrevContext = m_pLoadedObjectContext;
                    m_pLoadedObjectContext = pObject;

                    // Set this object as garbage-collectable.
#ifndef XBOX
                    if (pObject->m_ObjectDesc.m_guidObject != GUID_DefaultGMCollection) // don't cache GM DLS set
#endif // XBOX
                        hr = pObject->GC_Collectable();
                }
                if (SUCCEEDED(hr))
                    hrLoad = hr = pObject->Load();
                if (fGC)
                {
                    // Restore the context that was used to load this object.
                    m_pLoadedObjectContext = pPrevContext;
                }

#ifndef XBOX
#ifdef DBG
                if (FAILED(hrLoad) || m_pLoadedObjectContext == m_pApplicationObject)
                {
                    DebugTraceLoadFailure(pObject, hrLoad);
                }
#endif
#endif // XBOX

                if (SUCCEEDED(hr))
                {
                    pDMObj = pObject->m_pIDMObject;
                    if (fKeep)
                    {
                        pObject->m_pIDMObject->AddRef();
                    }
                    else
                    {
                        pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
                        pObject->m_pIDMObject = NULL;
                    }
                }
            }

            if (SUCCEEDED(hr) && fGC)
            {
                assert(m_pLoadedObjectContext);
                hr = m_pLoadedObjectContext->GC_AddReference(pObject);
            }

            if (FAILED(hr))
            {
                // This happens if either GC_AddReference or Load fails.
                pClass->RemoveObject(pObject);
                pObject = NULL;
                if (Desc.m_dwValidData & DMUS_OBJ_URL)
                {
                    Trace(1, "Error: Attempt to load an object via DMUS_OBJ_URL failed because the DirectMusic Loader doesn't currently support loading objects by URL.");
                    hr = DMUS_E_LOADER_FORMATNOTSUPPORTED;
                }
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        hr = pDMObj->QueryInterface( riid, ppv );
        pDMObj->Release();
    }
    if( E_FAIL == hr )
    {
        hr = DMUS_E_LOADER_FAILEDCREATE;
    }

#ifdef DBG
    // After each top-level call to GetObject, report to debug output the contents of the cache.
    if (m_pLoadedObjectContext == m_pApplicationObject)
        GC_Report(this);
#endif
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;

    if( SUCCEEDED(hr) )
    {
        return hrLoad;
    }
    else
    {
#ifdef DBG
        if (!m_fFirstLoadTry)
        {
            char *GetClassName(REFGUID clsid);
            char *pszClassName = GetClassName(pDESC->guidClass);
            Trace(1,"Error: Unable to load %s, ",pszClassName);
            if (pDESC->dwValidData & DMUS_OBJ_NAME)
            {
                Trace(1,"Name %ls, ",pDESC->wszName);
            }
            if (pDESC->dwValidData & DMUS_OBJ_FILENAME)
            {
                WCHAR wzFullPath[DMUS_MAX_FILENAME];
                if (pDESC->dwValidData & DMUS_OBJ_FULLPATH)
                {
                    wcscpy(wzFullPath,pDESC->wszFileName);
                }
                else if (pClass)
                {
                    pClass->GetPath(wzFullPath);
                    wcscat(wzFullPath,pDESC->wszFileName);
                }
                Trace(1,"File Path %ls ",wzFullPath);
            }
            if (pDESC->dwValidData & DMUS_OBJ_STREAM)
            {
                Trace(1,"Stream Pointer %lx",pDESC->pStream);
            }
            if (pDESC->dwValidData & DMUS_OBJ_MEMORY)
            {
                Trace(1,"Memory Pointer %lx, Size %ld",(long) pDESC->pbMemData,(long)pDESC->llMemLength);
            }
            if (pDESC->dwValidData & DMUS_OBJ_OBJECT)
            {
                Trace(1,"GUID: (0x%08lX,0x%04X,0x%04X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X)",
                    pDESC->guidObject.Data1,
                    pDESC->guidObject.Data2, pDESC->guidObject.Data3, pDESC->guidObject.Data4[0], pDESC->guidObject.Data4[1], pDESC->guidObject.Data4[2],
                    pDESC->guidObject.Data4[3], pDESC->guidObject.Data4[4], pDESC->guidObject.Data4[5], pDESC->guidObject.Data4[6], pDESC->guidObject.Data4[7]); 
            }
            Trace(1,"\n");
        }
#endif
        return hr;
    }
}

STDMETHODIMP CLoader::SetObject(
	LPDMUS_OBJECTDESC pDESC)

{
	HRESULT hr = S_OK;
	CDescriptor Desc;

	V_INAME(IDirectMusicLoader::SetObject);
	V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC);

	IStream *pStream = NULL;
	if (pDESC->dwValidData & DMUS_OBJ_STREAM)
	{
		// Save the stream we were passed and verify it is a valid interface.
		pStream = pDESC->pStream;
		V_INTERFACE(pStream);

		// The loader will save a cloned stream so that the caller can contine
		// using the passed stream without intefering with the loader.
		// Don't worry -- we'll restore the original stream pointer before returning.
		hr = pStream->Clone(&pDESC->pStream);
		if (FAILED(hr))
			return hr;
	}

	// if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
	if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
	{
		pDESC->dwValidData |= DMUS_OBJ_FILENAME;
	}
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
	CClass *pClass;
	Desc.Set(pDESC);
	hr = GetClass(&Desc,&pClass, TRUE);
	if (SUCCEEDED(hr))
	{
		CObject *pObject;
		hr = pClass->GetObject(&Desc,&pObject);
		if (SUCCEEDED(hr))
		{
			if (Desc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
			{
                // Clear DMUS_OBJ_FULLPATH whenever clearing DMUS_OBJ_FILENAME.

				pObject->m_ObjectDesc.m_dwValidData &= 
					~(DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM);
			}
			// Merge in any new things we've added
			pObject->m_ObjectDesc.Merge(&Desc);
			if (pObject->m_ObjectDesc.m_dwValidData & 
				(DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
			{
				// If we can actually load this, have it give us its internal data.
				hr = pObject->Parse();
			}
			// Return the data.
			pObject->m_ObjectDesc.Get(pDESC);
		}
	}

	if (pStream)
	{
		// Restore the stream information in the descriptor we were passed.

		// Get will have cleared the stream bit (ordinarily we don't want to be returning these streams out of the loader).
		pDESC->dwValidData |= DMUS_OBJ_STREAM;
		// The stream pointer was changed to the cloned stream.
		pDESC->pStream->Release(); // release matching call to Clone (ref is now held in merged descriptor)
		pDESC->pStream = pStream;
	}
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
	return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | SetSearchDirectory | 
Sets a search path for finding object files. The search path can be set for
one object file type, or, alternatively, all files.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | The search directory was already set to the requested path.
@flag E_POINTER | Bad pointer passed in <p pszPath>.
@flag DMUS_E_LOADER_BADPATH | Path is invalid.
@flag E_OUTOFMEMORY | Running low on memory, unable to complete task.

@comm Once a search path is set, the loader does not need a full path
every time it is given an object to load by file name. 
However, the loader does not automatically becomes
aware of all files of the requested type within the search 
directory. After calling <om IDirectMusicLoader::SetSearchDirectory>,
call <om IDirectMusicLoader::ScanDirectory> to scan the
directory for all 
files of the requested class and compile a list of them. 
Once this is done, you can easily find
files within the directory by object name, or GUID, as well as 
file name.

@ex The following example sets the search path for style files, then
loads a style by file name. Although this seems a little redundant 
(it's simpler to just use the full path name), 
objects that indirectly reference other objects can
find them by file name without knowing the full path: |

	// The first function calls SetSearchDirectory to set the path.
	// All subsequant calls to load objects in the application
	// no longer need to know the full path.

	HRESULT mySetLoaderPath (
		IDirectMusicLoader *pILoader)	// Loader interface, previously created.
	{
		return pILoader->SetSearchDirectory(CLSID_DirectMusicStyle,
			L"c:\\mymusic\\funky",FALSE);
	}

	//	Later, the application wants to load a style by 
	//	local file name.


	HRESULT myLoadStyleFromPath (
		IDirectMusicStyle **ppIStyle,	// Style to load.
		IDirectMusicLoader *pILoader)	// Loader.
	{
		HRESULT hr;

		DMUS_OBJECTDESC Desc;           // Descriptor.

		// Start by initializing Desc with the local file name for the object.

		wcscpy(Desc.wszName,L"Polka");	// Name is wide char format.
		wcscpy(Desc.wszFileName,L"polka.sty");	// Use file name without full path.
		Desc.guidClass = CLSID_DirectMusicStyle;   // Style class.
		Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
		Desc.dwSize = sizeof (DMUS_OBJECTDESC);

        hr = pILoader->GetObject(&Desc, IID_IDirectMusicStyle, (void**) ppIStyle);
		return hr;
	}

@xref <i IDirectMusicLoader>, <i IDirectMusicObject>,
<om IDirectMusicLoader::GetObject>,
<om IDirectMusicLoader::ScanDirectory>,
<om IDirectMusicLoader::EnumObject>
*/
STDMETHODIMP CLoader::SetSearchDirectory(
	REFCLSID rguidClass,
#ifdef XBOX
    const char *pszPath,
#else
    WCHAR *pwzPath,
#endif
    BOOL fClear)
										
{
	V_INAME(IDirectMusicLoader::SetSearchDirectory);
#ifdef XBOX
    WCHAR pwzPath[MAX_PATH];
    mbstowcs( pwzPath, pszPath, MAX_PATH );
#else
	if (pwzPath)
	{
		V_BUFPTR_READ(pwzPath,2);
	}
#endif
	HRESULT hr = DMUS_E_LOADER_BADPATH;
	WCHAR wzMaxPath[MAX_PATH];

	if (pwzPath == NULL)
	{
		return E_POINTER;
	}
	wcscpy( wzMaxPath, pwzPath );
	if( wzMaxPath[wcslen( wzMaxPath ) - 1] != '\\' )
	{
		wcscat( wzMaxPath, L"\\" );
	}
	DWORD dwAttrib;
#ifndef XBOX
	if (g_fIsUnicode)
	{
		dwAttrib= GetFileAttributesW(wzMaxPath); 
	}
	else
#else
	{
		char szPath[MAX_PATH];
		wcstombs( szPath, wzMaxPath, MAX_PATH );
		dwAttrib= GetFileAttributesA(szPath); 
	}
#endif // XBOX
	if ((dwAttrib != 0xFFFFFFFF) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
	{
		ENTER_CRITICAL_SECTION(&m_CriticalSection);
        ENTER_API_CRITICAL_SECTION;
        if (rguidClass == GUID_DirectMusicAllTypes)
		{
			CClass *pClass = m_ClassList.GetHead();
			hr = S_OK;
			for (;pClass != NULL;pClass = pClass->GetNext())
			{
				if( S_FALSE == pClass->SetSearchDirectory(wzMaxPath,fClear))
                {
                    hr = S_FALSE;
                }
			}
			wcsncpy(m_wzPath,wzMaxPath,DMUS_MAX_FILENAME);
			m_fPathValid = TRUE;
		}
		else
		{
			CClass *pClass;
			CDescriptor Desc;
			Desc.m_guidClass = rguidClass;
			Desc.m_dwValidData = DMUS_OBJ_CLASS;
			hr = GetClass(&Desc,&pClass,TRUE);
			if (SUCCEEDED(hr))
			{
				hr = pClass->SetSearchDirectory(wzMaxPath,fClear);
			}
		}
		LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        LEAVE_API_CRITICAL_SECTION;
	}

#ifdef DBG
	if (hr == DMUS_E_LOADER_BADPATH)
	{
		Trace(1, "Error: SetSearchDirectory failed because '%S' is not a valid directory.\n", pwzPath);
	}
#endif

	return hr;
}

#ifndef XBOX

STDMETHODIMP CLoader::ScanDirectory(
	REFCLSID rguidClass,	// @parm Class id identifies which class of objects this pertains to.
	WCHAR *pszFileExtension,// @parm File extension for type of file to look for. 
							// For example, L"sty" for style files. L"*" will look in all
							// files. L"" or NULL will look for files without an
							// extension.
	WCHAR *pszCacheFileName	// @parm Optional storage file to store and retrieve
							// cached file information. This file is created by 
							// the first call to <om IDirectMusicLoader::ScanDirectory>
							// and used by subsequant calls. NULL if cache file
							// not desired.
)

{

	V_INAME(IDirectMusicLoader::ScanDirectory);
	if (pszFileExtension)
	{
		V_BUFPTR_READ(pszFileExtension,2);
	}
	if (pszCacheFileName)
	{
		V_BUFPTR_READ(pszCacheFileName,2);
	}

	HRESULT hr = S_OK;
	//	First, mark all currently stored objects prior to scanning.
	CClass *pClass = m_ClassList.GetHead();
	for (;pClass != NULL;pClass = pClass->GetNext())
	{	
		pClass->PreScan();
	}
	if (pszCacheFileName != NULL)
	{
		LoadCacheFile(pszCacheFileName);
	}
	if (rguidClass == GUID_DirectMusicAllTypes)
	{
		Trace(1, "Error: ScanDirectory requires the clsid of a specific type of object to scan for. GUID_DirectMusicAllTypes is not valid.\n");
		return REGDB_E_CLASSNOTREG;
	}
	else
	{
		CDescriptor Desc;
		Desc.m_guidClass = rguidClass;
		Desc.m_dwValidData = DMUS_OBJ_CLASS;
		ENTER_CRITICAL_SECTION(&m_CriticalSection);
		GetClass(&Desc,&pClass,TRUE);
		if (pClass)
		{
			if( pszFileExtension )
			{
				hr = pClass->SearchDirectory(pszFileExtension);
			}
			else
			{
				hr = pClass->SearchDirectory(L"");
			}
//			if( hr == E_FAIL ) hr = DMUS_E_NOT_FOUND;
		}
		LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	}
	if (pszCacheFileName != NULL)
	{
		SaveCacheFile(pszCacheFileName);
	}	
	return hr;
}
#endif
HRESULT CLoader::FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject, IDirectMusicObject *pIDMObject)

//	Scan through the classes and objects to find the object. 

{
	assert(pDesc);
	HRESULT hr = GetClass(pDesc,ppClass,FALSE);
    if (SUCCEEDED(hr))
	{
		HRESULT hr = (*ppClass)->FindObject(pDesc,ppObject,NULL,pIDMObject);
#ifndef XBOX
#ifdef DBG
		if (hr == DMUS_E_LOADER_OBJECTNOTFOUND)
		{
			DMUS_OBJECTDESC desc;
			ZeroAndSize(&desc);
			pDesc->Get(&desc);
			Trace(1, "Error: The following object could not be found in the loader: ");
			DebugTraceObject(&desc);
		}
#endif
#endif // XBOX
		return hr;
	}
	return hr;
}

// Find the object in the cache.  S_FALSE if not loaded.  Error if not found.
HRESULT CLoader::FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject)

{
	// Potential optimization:
	//    The linear search to find the object could be eliminated by using
	// an efficient lookup structure such as a hash table.

	assert(pIDMObject && ppObject);

	HRESULT hr = S_OK;

	DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
    if (pDESC)
    {
	    ZeroMemory( pDESC, sizeof(DMUS_OBJECTDESC) );
	    pDESC->dwValidData = 0;
	    pDESC->dwSize = sizeof (DMUS_OBJECTDESC);

	    hr = pIDMObject->GetDescriptor(pDESC);
	    if (SUCCEEDED(hr))
        {
	        CDescriptor Desc;
	        Desc.Set(pDESC);
	        delete pDESC;
	        SmartRef::CritSec CS(&m_CriticalSection);
            ENTER_CRITICAL_SECTION(&m_CriticalSection);
	        CClass *pClass;
	        CObject *pCObject;
        	hr = FindObject(&Desc,&pClass,&pCObject,pIDMObject);
	        if (SUCCEEDED(hr))
            {
	            assert(pCObject);
	            if (pCObject->m_pIDMObject == pIDMObject)
	            {
		            *ppObject = pCObject;
		            hr = S_OK;
	            }
	            else
	            {
		            hr = S_FALSE;
	            }
            }
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | CacheObject | 
Tells the loader to keep a reference to the object. This guarantees
that the object will not be loaded twice.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | Object already cached.
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found.

@comm If you have an object that will be accessed in multiple places
throughout the life of your program, letting the loader cache the object
can significantly speed performance. 

Alternatively, tell the loader to automatically cache all objects of
a particular type with a call to 
<om IDirectMusicLoader::EnableCache>.

Remove the reference later with a call to 
<om IDirectMusicLoader::ReleaseObject> or 
<om IDirectMusicLoader::ClearCache>.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::ReleaseObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::CacheObject(
	IDirectMusicObject * pObject)	// @parm Object to cache.

{
	HRESULT hr;
	DMUS_OBJECTDESC DESC;
	ZeroMemory( &DESC, sizeof(DMUS_OBJECTDESC) );
	DESC.dwSize = sizeof (DMUS_OBJECTDESC);

	V_INAME(IDirectMusicLoader::CacheObject);
	V_INTERFACE(pObject);

	if (pObject == NULL)
	{
		return E_POINTER;
	}
	DESC.dwValidData = 0;
	hr = pObject->GetDescriptor(&DESC);
	if (SUCCEEDED(hr))
	{
		CDescriptor Desc;
		Desc.Set(&DESC);
		CClass *pClass;
		CObject *pCObject;
	    ENTER_CRITICAL_SECTION(&m_CriticalSection);
        ENTER_API_CRITICAL_SECTION;
		hr = FindObject(&Desc,&pClass,&pCObject,NULL);
		if (SUCCEEDED(hr))
		{
			if (pCObject->m_pIDMObject && (pCObject->m_pIDMObject != pObject))
			{
				pCObject->m_pIDMObject->Release();
				pCObject->m_pIDMObject = NULL;
			}
			if (pCObject->m_pIDMObject != pObject)
			{
				pCObject->m_pIDMObject = pObject;
				pCObject->m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
				pObject->AddRef();
			}
			else
			{
				hr = S_FALSE;
			}
		}
		LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        LEAVE_API_CRITICAL_SECTION;
	}
/*    if( E_FAIL == hr ) // Should never happen...
    {
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    }*/
	return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ReleaseObject | 
Tells the loader to release its reference to the object. 

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found or was already released.

@comm <om IDirectMusicLoader::ReleaseObject> is the reciprocal
of <om IDirectMusicLoader::CacheObject>.

Objects can be cached explicitly via 
<om IDirectMusicLoader::CacheObject>,
or automatically via <om IDirectMusicLoader::EnableCache>.

To tell the loader to flush all objects of
a particular type, call
<om IDirectMusicLoader::ClearCache>.
 
@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::ReleaseObject(
	IDirectMusicObject * pObject)	// @parm Object to release.

{

	V_INAME(IDirectMusicLoader::ReleaseObject);
	V_INTERFACE(pObject);

	HRESULT hr = S_OK;
	CObject *pCObject = NULL;
//	SmartRef::CritSec CS(&m_CriticalSection);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;

	hr = FindObject(pObject, &pCObject);
    // Removed the following because it causes a regression from DX7, even though it is the better return.
//	if (hr == S_FALSE)
//		hr = DMUS_E_LOADER_OBJECTNOTFOUND;
	if (hr == S_OK)
	{
        // Don't keep the IStream around because it could keep a file or other resource open.
        pCObject->m_ObjectDesc.ClearIStream();
		if (pCObject->m_dwScanBits & SCAN_GC)
		{
			// Other objects may have references to this one so we need to keep this object around
			// and track its references.  We'll hold onto the DMObject pointer too because we may
			// later need to Zombie the object in order to break a cyclic reference.

			// We'll place an unloaded object with a duplicate descriptor in the cache to match the
			// non-GC behavior and then move the original object into a list of released objects that
			// will eventually be reclaimed by CollectGarbage.

			// Potential optimization:
			//   Here we re-iterate to remove from the list when we just iterated during FindObject.
			// Returning more info from FindObject, expanding it into this function, or using some
			// other technique would make this operation twice as fast.

			hr = pCObject->GC_RemoveAndDuplicateInParentList();
            if (SUCCEEDED(hr))
            {
        		GC_UpdateForReleasedObject(pCObject);
            }
		}
		else
		{
			pCObject->m_pIDMObject->Release();
			pCObject->m_pIDMObject = NULL;
			pCObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
		}
        // If the object no longer has any information in it that can be used to 
        // load later, get rid of it. 
        if (pCObject->m_ObjectDesc.IsEmpty())
        {
            pCObject->m_pClass->RemoveObject(NULL);
        }
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
	return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ClearCache | 
Tells the loader to release all references to a particular type
of object.  

@rdesc Returns just

@flag S_OK | Always succeeds

@comm <om IDirectMusicLoader::ClearCache> clears all objects
that are currently being held. However, if caching is enabled
via <om IDirectMusicLoader::EnableCache>, this does not
turn off caching so future file loads will continue to be cached.

Use <om IDirectMusicLoader::ReleaseObject> to release a specific
object.

Call <om IDirectMusicLoader::EnableCache> to turn off automatic
caching.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::ClearCache(
	REFCLSID rguidClass)	// @parm Class id identifies which class of objects to clear.
					// Optionally, GUID_DirectMusicAllTypes specifies all types. 

{
	return ClearCacheInternal(rguidClass, false);
}

HRESULT CLoader::ClearCacheInternal(
	REFCLSID rguidClass,
	bool fClearStreams)

{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

	HRESULT hr = S_OK;
	CClass *pClass;
	if (rguidClass == GUID_DirectMusicAllTypes)
	{
		pClass = m_ClassList.GetHead();
		for (;pClass != NULL;pClass = pClass->GetNext())
		{
			hr = pClass->ClearCache(fClearStreams);
			if (FAILED(hr))
				break;
		}		
	}
	else
	{
		CDescriptor Desc;
		Desc.m_guidClass = rguidClass;
		Desc.m_dwValidData = DMUS_OBJ_CLASS;
		GetClass(&Desc,&pClass,FALSE);
		if (pClass)
		{
			hr = pClass->ClearCache(fClearStreams);
		}
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnableCache | 
Tells the loader to enable or disable automatic caching of
objects it loads. By default, caching is enabled for all
object classes. 

Once caching is enabled with a call to 
<om IDirectMusicLoader::EnableCache>, the loader keeps a reference to
all objects it loads subsequently,
either directly or indirectly (via a referenced load, for example, a
Section Segment that references a Style).

<om IDirectMusicLoader::EnableCache> can also be used to disable
caching by setting <p fEnable> to FALSE. Before disabling caching, think
twice. Caching is used extensively in the file loading process to 
resolve links to objects. If an object is not found in the cache, it
has to be reloaded, even if it already exists. For example, two segments
could reference the same style. When the first segment loads, it calls the
loader to get the style, which in turn creates a style, loads it from disk,
stores a pointer to the style in the cache, and returns it to the segment.
When the second segment loader, it asks for the style and the loader immediately
returns it, so both segments point to the same style. If caching is disabled, 
the second segment's request for the style results in a duplicate style
loaded from the file. This is very inefficient.

Another example: <i IDirectMusicBand> counts on the loader to keep the 
GM DLS collection cached. Every time it comes across a general MIDI instrument,
it gets the GM DLS collection from the loader by requesting it with 
GUID_DefaultGMCollection. If caching for CLSID_DirectMusicCollection is
disabled, every patch change in a general MIDI file will result in a
seperate copy of the entire GM collection being created! Not good!

However, with judicious use of <om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>, and <om IDirectMusicLoader::EnableCache>,
you can have the objects you don't need released, while others stick around 
in the cache.
 
To clear the cache without disabling caching, call 
<om IDirectMusicLoader::ClearCache>.

@ex The following example disables caching for just segment objects, so they
don't stay in memory after the application releases them. Yet, other objects
that should be shared, like styles, personalities and DLS collections, continue
to be cached. |

	void myPrepareLoader(IDirectMusicLoader *pILoader)
	
	{
		pILoader->EnableCache(GUID_DirectMusicAllTypes, TRUE);
		pILoader->EnableCache(CLSID_DirectMusicSegment, FALSE);
	}
		
@rdesc Returns just

@flag S_OK | Success.
@flag S_FALSE | The cache was already in the requested state.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::ClearCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::EnableCache(
	REFCLSID rguidClass,	// @parm Class id identifies which class of objects to cache.
					// Optionally, GUID_DirectMusicAllTypes specifies all types. 
	BOOL fEnable)	// @parm TRUE to enable caching, FALSE to clear and disable.

{
	CClass *pClass;
    HRESULT hr = S_OK;
	if (rguidClass == GUID_DirectMusicAllTypes)
	{
		pClass = m_ClassList.GetHead();
		for (;pClass != NULL;pClass = pClass->GetNext())
		{
			if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
		}
		m_fKeepObjects = fEnable;
	}
	else
	{
		CDescriptor Desc;
		Desc.m_guidClass = rguidClass;
		Desc.m_dwValidData = DMUS_OBJ_CLASS;
		GetClass(&Desc,&pClass,TRUE);
		if (pClass)
		{
			if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
		}
	}
	return hr;
}
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnumObject | 
Enumerate through all available objects of the requested type. 

@rdesc Returns one of the following

@flag S_OK | Found object at request index.
@flag S_FALSE | Reached end of list.

@ex Use <om IDirectMusicLoader::EnumObject> to walk through all styles
that are already referenced by the loader. These might have been prepared
with a call to <om IDirectMusicLoader::ScanDirectory> or loaded
individually. |

	void myDisplayStyles(
		IDirectMusicLoader *pILoader)

	{
		DWORD dwIndex;
		DMUS_OBJECTDESC Desc;
		Desc.dwSize = sizeof(DMUS_OBJECTDESC);
		for (dwIndex = 0; ;dwIndex++)
		{
			if (S_OK ==(pILoader->EnumObject(CLSID_DirectMusicStyle,
									   dwIndex,&Desc)))
			{
				TRACE("Name: %S, Category: %S, Path: %S\n",
					Desc.wszName,Desc.wszCategory,Desc.wszFileName);
			}
			else break;
		}
	}

@xref <i IDirectMusicLoader>, <t DMUS_OBJECTDESC>

*/
STDMETHODIMP CLoader::EnumObject(
	REFCLSID rguidClass,			// @parm Class ID for class of objects to view. 
	DWORD dwIndex,			// @parm Index into list. Typically, starts with 0 and increments.
	LPDMUS_OBJECTDESC pDESC)	// @parm <t DMUS_OBJECTDESC> structure to be filled with data about object.
									   
{
	HRESULT hr;
	CClass *pClass;
	CDescriptor Desc;

	V_INAME(IDirectMusicLoader::EnumObject);
	V_STRUCTPTR_WRITE(pDESC,DMUS_OLDOBJECTDESC);

	Desc.m_guidClass = rguidClass;
	Desc.m_dwValidData = DMUS_OBJ_CLASS;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	hr = GetClass(&Desc,&pClass,TRUE);
	if (SUCCEEDED(hr))
	{
		hr = pClass->EnumerateObjects(dwIndex, &Desc);
		Desc.Get(pDESC);
	}
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

void
CLoader::GC_Mark(CObject *pObject)
{
	// mark pObject and everything it references
	GC_TraverseHelper(pObject, NULL, true);
}

bool
CLoader::GC_HasCycle(CObject *pObject)
{
	// see if pObject has a cyclical reference
	bool fFound = GC_TraverseHelper(pObject, pObject, true);
	// the search left marks while traversing, so clear them
	GC_TraverseHelper(pObject, pObject, false);
	return fFound;
}

// Function used to recursively traverse references.
// pObject:			Root to start the search from.
// pObjectToFind:	Stop marking and return true if a reference to this object is encountered.
//					(Can be the same as pObject without being considered a match unless pObject has a reference to itself.)
// fMark:			If true, objects are marked as they are visited.  If false, the opposite occurs, clearing marks.
bool
CLoader::GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark)
{
	// Potential optimization:
	//    This could be written using an explicit stack instead of recursion and
	// it might be significantly faster.  If this were done then this algorithm should
	// also be changed to use a fixed-size stack.  If the stack is exhausted, the
	// object would be marked as unexamined and these unexamined objects would be
	// marked in later passes.  However, since that's getting unnecessarily complex
	// we'll stick with recursion unless it proves to be a problem.

	assert(pObject && pObject->m_dwScanBits & SCAN_GC && pObject->m_pvecReferences);
	if (!!(pObject->m_dwScanBits & SCAN_GC_MARK) == fMark)
		return false; // already done

	if (fMark)
		pObject->m_dwScanBits |= SCAN_GC_MARK;
	else
		pObject->m_dwScanBits &= ~SCAN_GC_MARK;

	SmartRef::Vector<CObject*> &vecRefs = *pObject->m_pvecReferences;
	const UINT iEnd = vecRefs.size();

	// While we iterate over the references, we're going to write them back into the
	// vector, compacting away any NULL slots created by GC_RemoveReference.
	UINT iWrite = 0;

	for (UINT i = 0; i < iEnd; ++i)
	{
		CObject *pObjectRef = vecRefs[i];

		if (pObjectRef)
		{
			if (pObjectRef == pObjectToFind)
				return true;

			if (GC_TraverseHelper(pObjectRef, pObjectToFind, fMark))
				return true;

			if (!pObjectToFind)
			{
				// Compact empty slots only when just marking.  (Doing so while searching for an object could
				// return before the compacting loop is complete, leaving the vector in an inconsistent state.)
				vecRefs[iWrite++] = pObjectRef;
			}
		}
	}
	if (!pObjectToFind)
		vecRefs.Shrink(iWrite);
	return false;
}

STDMETHODIMP_(void)
CLoader::CollectGarbage()
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;

	if (m_pApplicationObject)
	{
#ifdef DBG
		DebugTrace(GC_Report_DebugLevel, "DirectMusic loader CollectGarbage...\n");
#endif

		GC_Mark(m_pApplicationObject);

		// sweep through everything looking for unmarked GC objects
        m_ReleasedObjectList.GC_Sweep(TRUE);
		for (CClass *pClass = m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
			pClass->GC_Sweep();
		m_ReleasedObjectList.GC_Sweep();

		// clear the application's mark for next time (the other marks are all cleared by sweep)
		m_pApplicationObject->m_dwScanBits &= ~SCAN_GC_MARK;

#ifdef DBG
		DebugTrace(GC_Report_DebugLevel, "End of garbage collection.\n\n");
#endif
	}

#ifdef DBG
	GC_Report(this);
#endif
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
}

STDMETHODIMP
CLoader::ReleaseObjectByUnknown(IUnknown *pObject)
{
	V_INAME(CLoader::ReleaseObjectByUnknown);
	V_INTERFACE(pObject);

    IDirectMusicObject *pIDMObject = NULL;
	HRESULT hr = pObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pIDMObject));
	if (FAILED(hr))
		return hr;

	hr = ReleaseObject(pIDMObject);
    pIDMObject->Release();
	return hr;
}

STDMETHODIMP
CLoader::GetDynamicallyReferencedObject(
	IDirectMusicObject *pSourceObject,
	LPDMUS_OBJECTDESC pDesc,
	REFIID riid,
	LPVOID FAR *ppv)
{
	V_INAME(CLoader::GetDynamicallyReferencedObject);
	V_INTERFACE(pSourceObject);

	CObject *pCSourceObject = NULL;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
    if (SUCCEEDED(hr))
    {
	    if (!pCSourceObject)
	    {
		    assert(false);
		    hr = DMUS_E_LOADER_OBJECTNOTFOUND;
	    }
        else
        {
	        CObject *pPrevContext = m_pLoadedObjectContext;
	        m_pLoadedObjectContext = pCSourceObject;
	        hr = this->GetObject(pDesc, riid, ppv);
	        m_pLoadedObjectContext = pPrevContext;
#ifdef DBG
	        GC_Report(this);
#endif
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP
CLoader::ReportDynamicallyReferencedObject(
	IDirectMusicObject *pSourceObject,
	IUnknown *pReferencedObject)
{
	V_INAME(CLoader::GetDynamicallyReferencedObject);
	V_INTERFACE(pSourceObject);
	V_INTERFACE(pReferencedObject);

	CObject *pCSourceObject = NULL;

//	SmartRef::CritSec CS(&m_CriticalSection);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
	if (hr == S_FALSE)
		hr = DMUS_E_LOADER_OBJECTNOTFOUND;
	if (SUCCEEDED(hr))
    {
//		return hr; // Why was this put here?
	    assert(pCSourceObject);

	    IDirectMusicObject *pReferencedIDMObject = NULL;
	    hr = pReferencedObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pReferencedIDMObject));
	    if (FAILED(hr))
	    {
		    if (hr == E_NOINTERFACE)
			    hr = S_OK; // If the referenced object isn't a DirectMusic object then that's OK and we don't need to track it.
	    }
        else
        {
	        CObject *pCDestObject = NULL;
	        hr = FindObject(pReferencedIDMObject, &pCDestObject);
	        if (hr == S_FALSE)
		        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
	        if (SUCCEEDED(hr))
            {
	            assert(pCDestObject);

	            hr = pCSourceObject->GC_AddReference(pCDestObject);

#ifdef DBG
	            GC_Report(this);
#endif
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

HRESULT CLoader::GetPath(WCHAR *pwzPath)

{
	if (m_fPathValid)
	{
		wcsncpy(pwzPath,m_wzPath,DMUS_MAX_FILENAME);
		return S_OK;
	}
	wcsncpy(pwzPath,L"",DMUS_MAX_FILENAME);
	return E_FAIL;
}

// Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
// The object must have already been removed from its list in the main cache.
// This method adds it to the released object list and removes it from the list of
// objects in use by the application.
void CLoader::GC_UpdateForReleasedObject(CObject *pObject)
{
	assert(!pObject->GetNext());

	m_ReleasedObjectList.AddHead(pObject);
	assert(m_pApplicationObject);
	m_pApplicationObject->GC_RemoveReference(pObject);

	if (!(pObject->m_ObjectDesc.m_guidClass == CLSID_DirectMusicScript) && !GC_HasCycle(pObject))
	{
		// Although we need to keep the record around (CObject), we know that this object
		// can't be involved in any cycles and therefore we can release it.
		// (If a cycle is possible we'd need to hold a ref on the object so we could break the
		//  reference by calling Zombie during CollectGarbage.)

		// bugbug: The hard-coded check for CLSID_IDirectMusicScript will need to be extended
		// if we publicly expose methods like IDirectMusicLoader8P::GetDynamicallyReferencedObject
		// so that objects other than scripts could dynamically load objects.
		//    Alternatively, we could assume all objects could be cyclical and always hold onto
		// them.  We would have done it this way, except that legacy applications won't ever call
		// CollectGarbage and that would cause them to leak everything they loaded even after calling
		// ReleaseObject.  That could be a better way (if we could detect legacy apps that don't
		// call CollectGarbage) because it would avoid calling GC_HasCycle every time
		// through ReleaseObject, which is (worst case) order N where N is the number of objects
		// in the loader.  In practice, this worst case only happens if all the objects are
		// arranged in one big cycle.

		pObject->m_pIDMObject->Release();
		pObject->m_pIDMObject = NULL;
	}
}
#ifndef XBOX
HRESULT CLoader::LoadCacheFile(WCHAR *pwzCacheFileName)

{
	HRESULT hr = S_OK;
	return hr;
}
#define FOURCC_LIST_CLASSLIST	mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER		mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST		mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER		mmioFOURCC('o','b','j','h')

HRESULT CLoader::SaveCacheFile(WCHAR *pwzCacheFileName)

{
	HRESULT hr = E_OUTOFMEMORY;
	MMCKINFO ckMain;

	ZeroMemory(&ckMain, sizeof(MMCKINFO));

	CFileStream *pStream = new CFileStream;
	if (pStream)
	{
        pStream->Init(this);
		hr = pStream->Open(pwzCacheFileName,GENERIC_WRITE);
		if (SUCCEEDED(hr))
		{
			IRIFFStream *pRiff;
			hr = AllocRIFFStream(pStream, &pRiff );
			if (SUCCEEDED(hr))
			{
				ckMain.fccType = FOURCC_RIFF_CACHE;
				if( pRiff->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0)
				{
					MMCKINFO ckList;
					
					ZeroMemory(&ckList, sizeof(MMCKINFO));

					ckList.fccType = FOURCC_LIST_CLASSLIST;
					if( pRiff->CreateChunk(&ckList, MMIO_CREATELIST) == 0 )
					{
						CClass *pClass = m_ClassList.GetHead();
						for (;pClass != NULL;pClass = pClass->GetNext())
						{
							hr = pClass->SaveToCache(pRiff);
							if (FAILED(hr))
							{
								Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
								pRiff->Release();
								pStream->Release();
								return hr;
							}
						}
						if( pRiff->Ascend( &ckList, 0 ) != 0 )
						{
							Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
							hr = DMUS_E_CANNOTSEEK;
						}
					}
					if( pRiff->Ascend( &ckMain, 0 ) != 0 )
					{
						Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
						hr = DMUS_E_CANNOTSEEK;
					}
				}
				pRiff->Release();
			}
		}
		pStream->Release();
	}

	return hr;
}


	// IDirectMusicIMA
STDMETHODIMP CLoader::LegacyCaching( BOOL fEnable)

{
	m_fIMA = fEnable;
	if (fEnable)
	{
		ScanDirectory(CLSID_DirectMusicStyle,L"sty",L"imafiles");
		ScanDirectory(CLSID_DirectMusicChordMap,L"per",L"imafiles");
	}
	else
	{
		CClass *pClass;
		CDescriptor Desc;
		Desc.m_guidClass = CLSID_DirectMusicStyle;
		Desc.m_dwValidData = DMUS_OBJ_CLASS;
		ENTER_CRITICAL_SECTION(&m_CriticalSection);
		GetClass(&Desc,&pClass,FALSE);
		if (pClass)	
		{
			pClass->ClearObjects(TRUE,L"sty");
		}
		LEAVE_CRITICAL_SECTION(&m_CriticalSection);
		Desc.m_guidClass = CLSID_DirectMusicChordMap;
		Desc.m_dwValidData = DMUS_OBJ_CLASS;
		ENTER_CRITICAL_SECTION(&m_CriticalSection);
		GetClass(&Desc,&pClass,FALSE);
		if (pClass)	
		{
			pClass->ClearObjects(TRUE,L"per");
		}
		LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	}
	return S_OK;
}


#ifdef DBG
void CLoader::DebugTraceObject(DMUS_OBJECTDESC *pDesc)
{
	WCHAR *polestrType = NULL;
	if (pDesc->dwValidData & DMUS_OBJ_CLASS)
	{
		if (S_OK != ProgIDFromCLSID(pDesc->guidClass, &polestrType))
		{
			StringFromCLSID(pDesc->guidClass, &polestrType);
		}
	}
	WCHAR *polestrGUID = NULL;
	if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
	{
		StringFromCLSID(pDesc->guidObject, &polestrGUID);
	}
	Trace(1,
			"   [file %S, name %S, type %S, guid %S]\n",
			(pDesc->dwValidData & DMUS_OBJ_FILENAME) ? pDesc->wszFileName : L"??",
			(pDesc->dwValidData & DMUS_OBJ_NAME) ? pDesc->wszName : L"??",
			polestrType ? polestrType : L"??",
			polestrGUID ? polestrGUID : L"??");
	CoTaskMemFree(polestrType);
	CoTaskMemFree(polestrGUID);
}

void CLoader::DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad)
{
	if (!pObject)
	{
		assert(false);
		return;
	}

	if (m_pLoadedObjectContext == m_pApplicationObject)
	{
		// This is the object loaded by the application.  Print the warning if anything failed to load.

		UINT iSize = m_vecdescDebugTraceLoadFailure.size();
		if (iSize > 0)
		{
			DMUS_OBJECTDESC desc;
			Zero(&desc);
			pObject->m_ObjectDesc.Get(&desc);

			Trace(1, "Load failure. While attempting to load the object\n");
			DebugTraceObject(&desc);
			Trace(1, "the following referenced objects could not be loaded:\n");
			for (UINT i = 0; i < iSize; ++i)
			{
				DebugTraceObject(&m_vecdescDebugTraceLoadFailure[i]);
			}

			m_vecdescDebugTraceLoadFailure.Shrink(0);
		}
	}
	else
	{
		// This is a referenced sub-object.  Save the desciptor of the failed object in the next slot.

		UINT uiNewPos = m_vecdescDebugTraceLoadFailure.size();
		if (m_vecdescDebugTraceLoadFailure.AccessTo(uiNewPos))
		{
			DMUS_OBJECTDESC *pdesc = &m_vecdescDebugTraceLoadFailure[uiNewPos];
			Zero(pdesc);
			pObject->m_ObjectDesc.Get(pdesc);
		}
	}
}
#endif
#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\activescript.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CActiveScriptManager.
//

/*#include "stdinc.h"
#include "activescript.h"
#include "dll.h"
#include "oleaut.h"
#include "dmscript.h"
#include "authelper.h"
#include "packexception.h"
#include "engine.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Global constants

// For some reason, the following was added in DX8, but it causes a compile error because
// we use precompiled headers (it's in enginc.h", so I commented it out. 
//const LCID lcidUSEnglish = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
const WCHAR g_wszGlobalDispatch[] = L"DirectMusic";

//////////////////////////////////////////////////////////////////////
// Static variables

SmartRef::Vector<CActiveScriptManager::ThreadContextPair> CActiveScriptManager::ms_svecContext;

//////////////////////////////////////////////////////////////////////
// ScriptNames

HRESULT
ScriptNames::Init(bool fUseOleAut, DWORD cNames)
{
	m_prgbstr = new BSTR[cNames];
	if (!m_prgbstr)
		return E_OUTOFMEMORY;
	ZeroMemory(m_prgbstr, sizeof(BSTR) * cNames);
	m_fUseOleAut = fUseOleAut;
	m_dwSize = cNames;
	return S_OK;
}

void
ScriptNames::Clear()
{
	if (m_prgbstr)
	{
		for (DWORD i = 0; i < m_dwSize; ++i)
		{
			DMS_SysFreeString(m_fUseOleAut, m_prgbstr[i]);
		}
	}
	delete[] m_prgbstr;
}

//////////////////////////////////////////////////////////////////////
// Public functions

CActiveScriptManager::CActiveScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
  : m_cRef(1),
	m_pParentScript(pParentScript),
	m_fUseOleAut(fUseOleAut),
	m_pActiveScript(NULL),
	m_pDispatchScript(NULL),
	m_bstrErrorSourceComponent(NULL),
	m_bstrErrorDescription(NULL),
	m_bstrErrorSourceLineText(NULL),
	m_bstrHelpFile(NULL),
	m_i64IntendedStartTime(0),
	m_dwIntendedStartTimeFlags(0)
{
	LockModule(true);
	this->ClearErrorInfo();

	IActiveScriptParse *pActiveScriptParse = NULL;

	if (!m_pParentScript)
	{
		assert(false);
		*phr = E_POINTER;
		goto Fail;
	}

	// Create the scripting engine
#ifdef XBOX
	//
	// Only AudioVBScript is supported - bypass DirectMusicCreateInstance
	//
	
	if ((NULL != pwszLanguage) && (0 == _wcsicmp(L"AudioVBScript", pwszLanguage)))
	{
		*phr = CAudioVBScriptEngine::CreateInstance(NULL,
													IID_IActiveScript,
													reinterpret_cast<void **>(&m_pActiveScript));
	}
	else
	{
		*phr = E_FAIL;
	}
	if (FAILED(*phr))
		goto Fail;
#else  // XBOX

	CLSID clsid;
	*phr = CLSIDFromProgID(pwszLanguage, &clsid);
	if (FAILED(*phr))
		goto Fail;

	*phr = DirectMusicCreateInstance(clsid, NULL, IID_IActiveScript, reinterpret_cast<void **>(&m_pActiveScript));
	if (FAILED(*phr))
		goto Fail;
		
#endif // XBOX

	// Initialize the scripting engine

	*phr = m_pActiveScript->SetScriptSite(this);
	if (FAILED(*phr))
		goto Fail;

	// Add the default objects

	*phr = m_pActiveScript->AddNamedItem(g_wszGlobalDispatch, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_NOCODE | SCRIPTITEM_GLOBALMEMBERS);
	if (FAILED(*phr))
		goto Fail;

	// Parse the script

	*phr = m_pActiveScript->QueryInterface(IID_IActiveScriptParse, reinterpret_cast<void **>(&pActiveScriptParse));
	if (FAILED(*phr))
	{
		if (*phr == E_NOINTERFACE)
		{
			Trace(1, "Error: Scripting engine '%S' does not support the IActiveScriptParse interface required for use with DirectMusic.\n", pwszLanguage);
			*phr = DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
		}
		goto Fail;
	}

	*phr = pActiveScriptParse->InitNew();
	if (FAILED(*phr))
		goto Fail;

	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	*phr = pActiveScriptParse->ParseScriptText(
						pwszSource,
						NULL,
						NULL,
						NULL,
						NULL,
						0,
						0,
						NULL,
						&exinfo);
	if (*phr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"parsing script", L"", exinfo);
	if (FAILED(*phr))
		goto Fail;

	SafeRelease(pActiveScriptParse); // No longer needed
	return;

Fail:
	if (m_pActiveScript)
		m_pActiveScript->Close();
	SafeRelease(pActiveScriptParse);
	SafeRelease(m_pActiveScript);
	*phr = this->ReturnErrorInfo(*phr, pErrorInfo);
}

HRESULT
CActiveScriptManager::Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pActiveScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// Start the script running

	// Set context to this script (VBScript runs global code and could play something when it starts)
	CActiveScriptManager *pASM = NULL;
	HRESULT hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_STARTED); // We don't need to sink any events

	CActiveScriptManager::SetCurrentContext(pASM, NULL);

	if (FAILED(hr))
		goto Fail;
	assert(hr != S_FALSE);
	if (hr != S_OK)
	{
		assert(false);
		hr = DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
		goto Fail;
	}

	hr = m_pActiveScript->GetScriptDispatch(NULL, &m_pDispatchScript);
	if (FAILED(hr))
		goto Fail;

	return S_OK;

Fail:
	if (m_pActiveScript)
		m_pActiveScript->Close();
	SafeRelease(m_pActiveScript);
	SafeRelease(m_pDispatchScript);
	hr = this->ReturnErrorInfo(hr, pErrorInfo);
	return hr;
}

HRESULT
CActiveScriptManager::CallRoutine(
		const WCHAR *pwszRoutineName,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error calling script routine: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszRoutineName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
	{
		Trace(1, "Error: Attempt to call routine '%S' that is not defined in the script.\n", pwszRoutineName);
		return DMUS_E_SCRIPT_ROUTINE_NOT_FOUND;
	}
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));

	// Set context to this script
	CActiveScriptManager *pASM = NULL;
	hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			DISPATCH_METHOD,
			&dispparamsNoArgs,
			NULL,
			&exinfo,
			NULL);

	// Restore previous context (the routine could have been called from another script,
	// whose context needs to be restored).
	CActiveScriptManager::SetCurrentContext(pASM, NULL);

	if (hr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"calling routine ", pwszRoutineName, exinfo);

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

#ifdef ASYNCH_SCRIPTTRACK

#include "dowork.h"

class CScriptTrackCall : public AListItem
{
public:
    CScriptTrackCall(){
        m_pwszRoutineName = NULL;
        m_pSegSt = NULL;
    }

    ~CScriptTrackCall(){
        delete [] m_pwszRoutineName;
        if(m_pSegSt){
            m_pSegSt->Release();
        }
    }

    CScriptTrackCall *   GetNext() { return (CScriptTrackCall*)AListItem::GetNext();};

    void Call()
    {
	    m_pScriptManager->ScriptTrackCallRoutineImp(
				    m_pwszRoutineName,
				    m_pSegSt,
				    m_dwVirtualTrackID,
				    m_fErrorPMsgsEnabled,
				    m_i64IntendedStartTime,
				    m_dwIntendedStartTimeFlags);
        if(m_pSegSt) {
            m_pSegSt->Release(); // release the interface acquired in CopyParams
        }
        m_pSegSt = NULL;
        delete [] m_pwszRoutineName;
        m_pwszRoutineName = NULL;
    }

    HRESULT CopyParams(
        CActiveScriptManager *pmgr,
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
        DWORD dwIntendedStartTimeFlags)
    {
        delete [] m_pwszRoutineName;
        m_pwszRoutineName = new WCHAR[wcslen(pwszRoutineName)+1];
        if(!m_pwszRoutineName){
            return E_OUTOFMEMORY;
        }
	    wcscpy(m_pwszRoutineName, pwszRoutineName);

        m_pScriptManager = pmgr;
        if(m_pSegSt){
            m_pSegSt->Release();
        }
	    m_pSegSt = pSegSt;
        if(m_pSegSt){
            m_pSegSt->AddRef(); // hold a ref because the call is asynchronous and the interface we were passed may be released
        }
	    m_dwVirtualTrackID = dwVirtualTrackID;
	    m_fErrorPMsgsEnabled = fErrorPMsgsEnabled;
	    m_i64IntendedStartTime = i64IntendedStartTime;
	    m_dwIntendedStartTimeFlags = dwIntendedStartTimeFlags;

	    return S_OK;
    }


private:
    CScriptTrackCall(const CScriptTrackCall&);
    CScriptTrackCall& operator=(const CScriptTrackCall&);

    CActiveScriptManager*       m_pScriptManager;

	IDirectMusicSegmentState*   m_pSegSt;
	DWORD                       m_dwVirtualTrackID;
	bool                        m_fErrorPMsgsEnabled;
	__int64                     m_i64IntendedStartTime;
	DWORD                       m_dwIntendedStartTimeFlags;
	WCHAR*                      m_pwszRoutineName; // dynamically allocate extra space to hold the actual string within this structure
};

extern CBossMan g_BossMan;
static void WINAPI _ScriptTrackCallListWorker(LPVOID lpParam,REFERENCE_TIME *prtWakeUp);

class CScriptTrackCallList : private AList {
public:
    CScriptTrackCallList();
    ~CScriptTrackCallList();

    HRESULT DeferredCall(
        CActiveScriptManager *pmgr,
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
        DWORD dwIntendedStartTimeFlags)
    {
        CScriptTrackCall* pCall = new CScriptTrackCall();
        if(!pCall){
            return E_OUTOFMEMORY;
        }
        HRESULT hr = pCall->CopyParams(pmgr, pwszRoutineName, pSegSt, dwVirtualTrackID,
            fErrorPMsgsEnabled, i64IntendedStartTime, dwIntendedStartTimeFlags);
        if(FAILED(hr)){
            delete pCall;
            return hr;
        }
        Add(pCall);
        return S_OK;
    }

    void DoWork(REFERENCE_TIME *prtWakeUp){
        CScriptTrackCall* pS;
        for(;;){
            EnterCriticalSection(&m_cs);
            pS = RemoveHead();
            LeaveCriticalSection(&m_cs);
            if(!pS){
                break;
            }
            pS->Call();
            delete pS;
        }
    }

private:
    void Add(CScriptTrackCall *pItem){
        EnterCriticalSection(&m_cs);
        AddTail(pItem);
        if(!m_pWorker){
            // Register with DoWork for time
            m_pWorker = g_BossMan.InstallWorker(_ScriptTrackCallListWorker,this,40,"DM Worker: Script (MilsPerSecond)");
        }
        LeaveCriticalSection(&m_cs);
    }

    CRITICAL_SECTION m_cs;
    CScriptTrackCall*    RemoveHead(){return (CScriptTrackCall*)AList::RemoveHead();};
    void AddTail(CScriptTrackCall *pItem) { AList::AddTail(pItem); }
    CWorker* m_pWorker;
};

static void WINAPI _ScriptTrackCallListWorker(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    ((CScriptTrackCallList *)lpParam)->DoWork(prtWakeUp);
}

CScriptTrackCallList::CScriptTrackCallList(){
    InitializeCriticalSection(&m_cs);
    m_pWorker = NULL;
}

CScriptTrackCallList::~CScriptTrackCallList()
{
    if(m_pWorker){
        m_pWorker->PinkSlip();
    }
    DeleteCriticalSection(&m_cs);
}

CScriptTrackCallList* g_pScriptTrackCallList;

void CScriptTrackCallListInitialize(void){
    g_pScriptTrackCallList = new CScriptTrackCallList();
}

#endif // ASYNCH_SCRIPTTRACK

HRESULT
CActiveScriptManager::ScriptTrackCallRoutineImp(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	DMUS_SCRIPT_ERRORINFO ErrorInfo;
	if (fErrorPMsgsEnabled)
		ZeroAndSize(&ErrorInfo);

	// record current timing context
	__int64 i64IntendedStartTime_PreCall = m_i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags_PreCall = m_dwIntendedStartTimeFlags;
	// set designated timing context (used by play/stop methods if called within the routine)
	m_i64IntendedStartTime = i64IntendedStartTime;
	m_dwIntendedStartTimeFlags = dwIntendedStartTimeFlags;

	HRESULT hr = CallRoutine(pwszRoutineName, &ErrorInfo);

	// Restore the previous timing context.
	// This is important because when R finishes it will resore both fields to the values set in the
	//    constructor, which are music time 0.  This setting means that routines called via IDirectMusicScript
	//    will play segments at the current time.
	// It is also important because such calls can be nested.  Assume that track T calls a script routine R
	//    that plays a segment containing track T', which calls another script routine R'.  Statements
	//    in R should be associated with the time of R in T, but statements in R' get the time of R' in T'.
	m_i64IntendedStartTime = i64IntendedStartTime_PreCall;
	m_dwIntendedStartTimeFlags = dwIntendedStartTimeFlags_PreCall;

	if (fErrorPMsgsEnabled && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
	{
		IDirectMusicPerformance *pPerf = m_pParentScript->GetPerformance();
		FireScriptTrackErrorPMsg(pPerf, pSegSt, dwVirtualTrackID, &ErrorInfo);
	}

	return hr;

}

#ifndef ASYNCH_SCRIPTTRACK

HRESULT
CActiveScriptManager::ScriptTrackCallRoutine(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
    return ScriptTrackCallRoutineImp(pwszRoutineName,
				    pSegSt,
				    dwVirtualTrackID,
				    fErrorPMsgsEnabled,
				    i64IntendedStartTime,
				    dwIntendedStartTimeFlags);
}

#else // ASYNCH_SCRIPTTRACK

HRESULT
CActiveScriptManager::ScriptTrackCallRoutine(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	// Call asynchronously.  Needed to avoid deadlocks between the user thread and DirectMusicDoWork
    // thread. or to avoid blocking the performance if the ActionScript routine takes a long time to complete.

    return g_pScriptTrackCallList->DeferredCall(this, pwszRoutineName, pSegSt, dwVirtualTrackID,
            fErrorPMsgsEnabled, i64IntendedStartTime, dwIntendedStartTimeFlags);
}

#endif // ASYNCH_SCRIPTTRACK


HRESULT
CActiveScriptManager::SetVariable(
		const WCHAR *pwszVariableName,
		VARIANT varValue,
		bool fSetRef,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error setting script variable: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszVariableName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
	{
		Trace(1, "Error: Attempt to set variable '%S' that is not defined in the script.\n", pwszVariableName);
		return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
	}
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPID dispidPropPut = DISPID_PROPERTYPUT;
	DISPPARAMS dispparams;
	dispparams.rgvarg = &varValue;
	dispparams.rgdispidNamedArgs = &dispidPropPut;
	dispparams.cArgs = 1;
	dispparams.cNamedArgs = 1;
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			fSetRef ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT,
			&dispparams,
			NULL,
			&exinfo,
			NULL);
	if (hr == DISP_E_EXCEPTION)
	{
		this->ContributeErrorInfo(L"setting variable ", pwszVariableName, exinfo);

		// Check if it was more likely a malformed call to SetVariable rather than an error in the script, in which
		// case return a descriptive HRESULT rather than the textual error.
		bool fObject = varValue.vt == VT_DISPATCH || varValue.vt == VT_UNKNOWN;
		if (fObject)
		{
			if (!fSetRef)
			{
				// Theoretically an object could support the value property, which would allow it to be assigned by value.
				//    (Not that any of our built-in objects currently do this.)
				// But in this case we know that the set failed, so probably this is the fault of the caller, who forgot to use
				//    fSetRef when setting an object.
				this->ClearErrorInfo();
				return DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED;
			}
		}
		else
		{
			if (fSetRef)
			{
				// Setting by reference without using an object.
				this->ClearErrorInfo();
				return DMUS_E_SCRIPT_NOT_A_REFERENCE;
			}
		}
	}

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

HRESULT
CActiveScriptManager::GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error getting script variable: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	assert(pvarValue->vt == VT_EMPTY);

	DISPID dispid;
	HRESULT hr = this->GetIDOfName(pwszVariableName, &dispid);
	if (hr == DISP_E_UNKNOWNNAME)
		return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
	if (FAILED(hr))
		return hr;

	this->ClearErrorInfo();
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = m_pDispatchScript->Invoke(
			dispid,
			m_fUseOleAut ? IID_NULL : g_guidInvokeWithoutOleaut,
			lcidUSEnglish,
			DISPATCH_PROPERTYGET,
			&dispparamsNoArgs,
			pvarValue,
			&exinfo,
			NULL);
	if (hr == DISP_E_EXCEPTION)
		this->ContributeErrorInfo(L"getting variable ", pwszVariableName, exinfo);

	return this->ReturnErrorInfo(hr, pErrorInfo);
}

HRESULT
CActiveScriptManager::EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems)
{
	HRESULT hr = this->EnsureEnumItemsCached(fRoutine);
	if (FAILED(hr))
		return hr;

	ScriptNames &snames = fRoutine ? m_snamesRoutines : m_snamesVariables;

	DWORD cNames = snames.size();
	// snames was allocated for the size of the most items there could be as reported by the script's type info.
	// However, the global "DirectMusic" variable may have been skipped, leaving a NULL entry at the end of snames.
	if (cNames > 0 && !snames[cNames - 1])
		--cNames;
	if (pcItems)
		*pcItems = cNames;
	if (dwIndex >= cNames)
		return S_FALSE;
	
	const BSTR bstrName = snames[dwIndex];
	if (!bstrName)
	{
		assert(false);
		return S_FALSE;
	}

	return wcsTruncatedCopy(pwszName, bstrName, MAX_PATH);
}

HRESULT CActiveScriptManager::DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// handle the dummy load method
	HRESULT hr = AutLoadDispatchGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (SUCCEEDED(hr))
		return hr;

	// otherwise defer to the scripting engine
	return m_pDispatchScript->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

HRESULT CActiveScriptManager::DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	// handle the dummy load method
	HRESULT hr = AutLoadDispatchInvoke(NULL, dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (SUCCEEDED(hr))
		return hr;

	// otherwise defer to the scripting engine...

	CActiveScriptManager *pASM = NULL;
	hr = CActiveScriptManager::SetCurrentContext(this, &pASM);
	if (FAILED(hr))
		return hr;

	// If this is a property set of an object then we need to report it to garbage collecting loader if present.
	// Note that we do this before actually setting the property with Invoke.  We do this because if the garbage collector
	//    fails to track the reference then it won't necessarily keep the target object alive and we don't want to create
	//    a dangling reference in the script.
	if (wFlags & DISPATCH_PROPERTYPUTREF && pDispParams && pDispParams->cArgs == 1)
	{
		IDirectMusicLoader8P *pLoader8P = m_pParentScript->GetLoader8P();
		VARIANT &var = pDispParams->rgvarg[0];
		if (pLoader8P && (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH))
		{
			hr = pLoader8P->ReportDynamicallyReferencedObject(m_pParentScript, var.vt == VT_UNKNOWN ? var.punkVal : var.pdispVal);
			if (FAILED(hr))
				return hr;
		}
	}

	hr = m_pDispatchScript->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);

	bool fExceptionUsingOleAut = !!(riid != g_guidInvokeWithoutOleaut);

	if (hr == 0x80020101 && pExcepInfo) // supposedly this is SCRIPT_E_REPORTED
	{
		// See KB article ID: Q247784, INFO: '80020101' Returned From Some ActiveX Scripting Methods.
		// Sometimes VBScript just returns this undocumented HRESULT, which means the error has already been
		//   reported via OnScriptError.  Since it then doesn't give us the exception info via pExcepInfo, we have
		//   to take the info we saves from OnScriptError and put it back in.

		assert(fExceptionUsingOleAut && m_fUseOleAut); // We don't expect this to happen with a custom scripting engine.
		assert(!pExcepInfo->bstrSource && !pExcepInfo->bstrDescription && !pExcepInfo->bstrHelpFile); // We don't expect this will happen when the exception info has been filled in.

		pExcepInfo->scode = m_hrError;

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrSource);
		pExcepInfo->bstrSource = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrErrorSourceComponent);

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrDescription);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrErrorDescription);

		DMS_SysFreeString(fExceptionUsingOleAut, pExcepInfo->bstrHelpFile);
		pExcepInfo->bstrHelpFile = DMS_SysAllocString(fExceptionUsingOleAut, m_bstrHelpFile);

		hr = DISP_E_EXCEPTION;
	}

	if (hr == DISP_E_EXCEPTION)
	{
		// Hack: See packexception.h for more info
		PackExceptionFileAndLine(fExceptionUsingOleAut, pExcepInfo, m_pParentScript->GetFilename(), m_fError ? &m_ulErrorLineNumber : NULL);
	}

	CActiveScriptManager::SetCurrentContext(pASM, NULL);
	return hr;
}

void
CActiveScriptManager::Close()
{
	if (!m_pActiveScript)
	{
		assert(false); // Close being called if initialization failed.  Or Close was called twice.  Or else m_pActiveScript is getting cleared prematurely somehow.
		return;
	}

	HRESULT hr = m_pActiveScript->Close();
	assert(SUCCEEDED(hr) && hr != S_FALSE);
	SafeRelease(m_pDispatchScript);
	SafeRelease(m_pActiveScript);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CActiveScriptManager::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CActiveScriptManager::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IActiveScriptSite)
	{
		*ppv = static_cast<IActiveScriptSite*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CActiveScriptManager::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CActiveScriptManager::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		SafeRelease(m_pDispatchScript);
		SafeRelease(m_pActiveScript);
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IActiveScriptSite

STDMETHODIMP
CActiveScriptManager::GetLCID(/* [out] */ LCID __RPC_FAR *plcid)
{
	V_INAME(CActiveScriptManager::GetLCID);
	V_PTR_WRITE(plcid, LCID);

	*plcid = lcidUSEnglish;

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::GetItemInfo(
	/* [in] */ LPCOLESTR pstrName,
	/* [in] */ DWORD dwReturnMask,
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
	/* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti)
{
	V_INAME(CActiveScriptManager::GetLCID);
	V_PTR_WRITE_OPT(ppti, ITypeInfo*);

	bool fGetUnknown = !!(dwReturnMask | SCRIPTINFO_IUNKNOWN);
	if (fGetUnknown || ppiunkItem)
	{
		V_PTR_WRITE(ppiunkItem, IUnknown*);
	}

	if (ppiunkItem)
		*ppiunkItem = NULL;
	if (ppti)
		*ppti = NULL;

	if (0 != wcscmp(g_wszGlobalDispatch, pstrName))
	{
		assert(false); // we should only be asked about the global object
		return TYPE_E_ELEMENTNOTFOUND;
	}

	if (fGetUnknown)
	{
		IDispatch *pDispGlobal = m_pParentScript->GetGlobalDispatch();
		pDispGlobal->AddRef();
		*ppiunkItem = pDispGlobal;
	}

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::GetDocVersionString(/* [out] */ BSTR __RPC_FAR *pbstrVersion)
{
	return E_NOTIMPL; // Not an issue for our scripts that don't persist their state and aren't edited at runtime.
}

STDMETHODIMP
CActiveScriptManager::OnScriptTerminate(
	/* [in] */ const VARIANT __RPC_FAR *pvarResult,
	/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo)
{
	if (pexcepinfo)
		this->ContributeErrorInfo(L"terminating script", L"", *pexcepinfo);

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnStateChange(/* [in] */ SCRIPTSTATE ssScriptState)
{
	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnScriptError(/* [in] */ IActiveScriptError __RPC_FAR *pscripterror)
{
	V_INAME(CActiveScriptManager::OnScriptError);
	V_INTERFACE(pscripterror);

	BSTR bstrSource = NULL;
	pscripterror->GetSourceLineText(&bstrSource); // this may fail, in which case the source text will remain blank

	ULONG ulLine = 0;
	LONG lChar = 0;
	HRESULT hr = pscripterror->GetSourcePosition(NULL, &ulLine, &lChar);
	assert(SUCCEEDED(hr));

	EXCEPINFO exinfo;
	ZeroMemory(&exinfo, sizeof(EXCEPINFO));
	hr = pscripterror->GetExceptionInfo(&exinfo);
	assert(SUCCEEDED(hr));

	this->SetErrorInfo(ulLine, lChar, bstrSource, exinfo);

	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnEnterScript()
{
	return S_OK;
}

STDMETHODIMP
CActiveScriptManager::OnLeaveScript()
{
	return S_OK;
}

IDirectMusicPerformance8 *
CActiveScriptManager::GetCurrentPerformanceNoAssertWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
		return NULL;

	return pASM->m_pParentScript->GetPerformance();
}

IDirectMusicObject *
CActiveScriptManager::GetCurrentScriptObjectWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		return NULL;
	}

	assert(pASM->m_pParentScript);
	return pASM->m_pParentScript;
}

IDirectMusicComposer8 *CActiveScriptManager::GetComposerWEAK()
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		return NULL;
	}

	assert(pASM->m_pParentScript);
	return pASM->m_pParentScript->GetComposer();
}

void CActiveScriptManager::GetCurrentTimingContext(__int64 *pi64IntendedStartTime, DWORD *pdwIntendedStartTimeFlags)
{
	CActiveScriptManager *pASM = CActiveScriptManager::GetCurrentContext();
	if (!pASM)
	{
		assert(false);
		*pi64IntendedStartTime = 0;
		*pdwIntendedStartTimeFlags = 0;
	}
	else
	{
		*pi64IntendedStartTime = pASM->m_i64IntendedStartTime;
		*pdwIntendedStartTimeFlags = pASM->m_dwIntendedStartTimeFlags;
	}
}

//////////////////////////////////////////////////////////////////////
// Private functions

HRESULT
CActiveScriptManager::GetIDOfName(const WCHAR *pwszName, DISPID *pdispid)
{
	V_INAME(CDirectMusicScript::GetIDOfName);
	V_BUFPTR_READ(pwszName, 2);
	V_PTR_WRITE(pdispid, DISPID);

	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = m_pDispatchScript->GetIDsOfNames(
					IID_NULL,
					const_cast<WCHAR **>(&pwszName),
					1,
					lcidUSEnglish,
					pdispid);
	return hr;
}

// Clears the error info and frees all cached BSTRs.
void
CActiveScriptManager::ClearErrorInfo()
{
	m_fError = false;
	if (m_bstrErrorSourceComponent)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorSourceComponent);
		m_bstrErrorSourceComponent = NULL;
	}
	if (m_bstrErrorDescription)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorDescription);
		m_bstrErrorDescription = NULL;
	}
	if (m_bstrErrorSourceLineText)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrErrorSourceLineText);
		m_bstrErrorSourceLineText = NULL;
	}
	if (m_bstrHelpFile)
	{
		DMS_SysFreeString(m_fUseOleAut, m_bstrHelpFile);
		m_bstrHelpFile = NULL;
	}
}

// Saves the passed error values.
// Assumes ownership of the BSTRs so don't use them after this call since they may be freed!
void
CActiveScriptManager::SetErrorInfo(
		ULONG ulLineNumber,
		LONG ichCharPosition,
		BSTR bstrSourceLine,
		const EXCEPINFO &excepinfo)
{
	this->ClearErrorInfo();
	m_fError = true;
	m_hrError = excepinfo.scode;
	m_ulErrorLineNumber = ulLineNumber;
	m_ichErrorCharPosition = ichCharPosition;

	m_bstrErrorSourceComponent = excepinfo.bstrSource;
	m_bstrErrorDescription = excepinfo.bstrDescription;
	m_bstrErrorSourceLineText = bstrSourceLine;
	m_bstrHelpFile = excepinfo.bstrHelpFile;
}

// Sometimes a EXCEPINFO is returned when calling Invoke or on script termination.  Although
// there is no source code information, we still want to do our best to set info about
// the error.  If OnScriptError has already been called, then calling this function has
// no effect, since we prefer that information.
// Assumes ownership of the BSTRs so don't use them after this call since they may be freed!
void
CActiveScriptManager::ContributeErrorInfo(
		const WCHAR *pwszActivity,
		const WCHAR *pwszSubject,
		const EXCEPINFO &excepinfo)
{
	if (m_fError)
	{
		// Error info already set.  Just clear the BSTRs and bail.
		if (excepinfo.bstrSource)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrSource);
		if (excepinfo.bstrDescription)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrDescription);
		if (excepinfo.bstrHelpFile)
			DMS_SysFreeString(m_fUseOleAut, excepinfo.bstrHelpFile);
		return;
	}

	this->SetErrorInfo(0, 0, NULL, excepinfo);
}

// If no error occurred, hr is returned unchanged and pErrorInfo is unaffected.
// If an error did occur, DMUS_E_SCRIPT_ERROR_IN_SCRIPT is returned, the error
//    information is saved into pErrorInfo (if nonnull), and the error info is
//    cleared for next time.
HRESULT
CActiveScriptManager::ReturnErrorInfo(HRESULT hr, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	if (!m_fError)
		return hr;

	assert(FAILED(hr));
	if (pErrorInfo)
	{
		pErrorInfo->hr = m_hrError;
		pErrorInfo->ulLineNumber = m_ulErrorLineNumber;
		pErrorInfo->ichCharPosition = m_ichErrorCharPosition;

		if (m_bstrErrorDescription)
		{
			// Hack: See packexception.h for more info
			UnpackExceptionFileAndLine(m_bstrErrorDescription, pErrorInfo);
		}

		// The IActiveScript interfaces return zero-based line and column numbers, but we want
		// to return them from IDirectMusicScript using a one-based line and column that is
		// natural for users.
		++pErrorInfo->ulLineNumber;
		++pErrorInfo->ichCharPosition;
#ifdef DXAPI
		if (pErrorInfo->wszSourceFile[0] == L'\0')
		{
			// if there was no filename packaged in the description, use this script's filename
			const WCHAR *pwszFilename = m_pParentScript->GetFilename();
			if (pwszFilename)
				wcsTruncatedCopy(pErrorInfo->wszSourceFile, pwszFilename, DMUS_MAX_FILENAME);
		}

		if (m_bstrErrorSourceComponent)
			wcsTruncatedCopy(pErrorInfo->wszSourceComponent, m_bstrErrorSourceComponent, DMUS_MAX_FILENAME);
		if (m_bstrErrorSourceLineText)
			wcsTruncatedCopy(pErrorInfo->wszSourceLineText, m_bstrErrorSourceLineText, DMUS_MAX_FILENAME);
#else
		if (pErrorInfo->wszSourceFile[0] == '\0')
		{
			// if there was no filename packaged in the description, use this script's filename
			const WCHAR *pwszFilename = m_pParentScript->GetFilename();
			if (pwszFilename)
				wcstombs(pErrorInfo->wszSourceFile, pwszFilename, DMUS_MAX_FILENAME);
		}

		if (m_bstrErrorSourceComponent)
			wcstombs(pErrorInfo->wszSourceComponent, m_bstrErrorSourceComponent, DMUS_MAX_FILENAME);
		if (m_bstrErrorSourceLineText)
			wcstombs(pErrorInfo->wszSourceLineText, m_bstrErrorSourceLineText, DMUS_MAX_FILENAME);
#endif
    }
	this->ClearErrorInfo();

#ifdef DBG
    if (pErrorInfo)
    {
#ifdef XBOX
		// XBox uses ASCII for wszSourceFile and friends.
	    Trace(1, "Error: Script error in \"%s\", line %u, column %i, near \"%s\".\n  %s: %s.\n  Error code 0x%08X.\n",
		    pErrorInfo->wszSourceFile,
		    pErrorInfo->ulLineNumber,
		    pErrorInfo->ichCharPosition,
		    pErrorInfo->wszSourceLineText,
		    pErrorInfo->wszSourceComponent,
		    pErrorInfo->wszDescription,
		    pErrorInfo->hr);
#else
	    Trace(1, "Error: Script error in %S, line %u, column %i, near %S. %S: %S. Error code 0x%08X.\n",
		    pErrorInfo->wszSourceFile,
		    pErrorInfo->ulLineNumber,
		    pErrorInfo->ichCharPosition,
		    pErrorInfo->wszSourceLineText,
		    pErrorInfo->wszSourceComponent,
		    pErrorInfo->wszDescription,
		    pErrorInfo->hr);
#endif
    }
    else
    {
	    Trace(1, "Error: Unknown Script error.\n");
    }
#endif

	return DMUS_E_SCRIPT_ERROR_IN_SCRIPT;
}

CActiveScriptManager *CActiveScriptManager::GetCurrentContext()
{
	DWORD dwThreadId = GetCurrentThreadId();
	UINT uiSize = ms_svecContext.size();

	for (UINT i = 0; i < uiSize; ++i)
	{
		if (ms_svecContext[i].dwThreadId == dwThreadId)
			break;
	}

	if (i == uiSize)
		return NULL;

	return ms_svecContext[i].pActiveScriptManager;
}

HRESULT
CActiveScriptManager::SetCurrentContext(CActiveScriptManager *pActiveScriptManager, CActiveScriptManager **ppActiveScriptManagerPrevious)
{
	if (ppActiveScriptManagerPrevious)
		*ppActiveScriptManagerPrevious = NULL;

	DWORD dwThreadId = GetCurrentThreadId();
	UINT uiSize = ms_svecContext.size();

	for (UINT i = 0; i < uiSize; ++i)
	{
		if (ms_svecContext[i].dwThreadId == dwThreadId)
			break;
	}

	if (i == uiSize)
	{
		// add an entry
		if (!ms_svecContext.AccessTo(i))
			return E_OUTOFMEMORY;
	}

	ThreadContextPair &tcp = ms_svecContext[i];

	if (i == uiSize)
	{
		// initialize the new entry
		tcp.dwThreadId = dwThreadId;
		tcp.pActiveScriptManager = NULL;
	}

	if (ppActiveScriptManagerPrevious)
		*ppActiveScriptManagerPrevious = tcp.pActiveScriptManager;
	tcp.pActiveScriptManager = pActiveScriptManager;

	return S_OK;
}

HRESULT
CActiveScriptManager::EnsureEnumItemsCached(bool fRoutine)
{
	if (!m_pDispatchScript)
	{
		Trace(1, "Error: Script element not initialized.\n");
		return DMUS_E_NOT_INIT;
	}

	ScriptNames &snames = fRoutine ? m_snamesRoutines : m_snamesVariables;
	if (snames)
		return S_OK;

	UINT uiTypeInfoCount = 0;
	HRESULT hr = m_pDispatchScript->GetTypeInfoCount(&uiTypeInfoCount);
	if (SUCCEEDED(hr) && !uiTypeInfoCount)
		hr = E_NOTIMPL;
	if (FAILED(hr))
		return hr;

	SmartRef::ComPtr<ITypeInfo> scomITypeInfo;
	hr = m_pDispatchScript->GetTypeInfo(0, lcidUSEnglish, &scomITypeInfo);
	if (FAILED(hr))
		return hr;

	TYPEATTR *pattr = NULL;
	hr = scomITypeInfo->GetTypeAttr(&pattr);
	if (FAILED(hr))
		return hr;

	UINT cMaxItems = fRoutine ? pattr->cFuncs : pattr->cVars;
	hr = snames.Init(m_fUseOleAut, cMaxItems);
	if (FAILED(hr))
		return hr;

	// Iterate over the items
	DWORD dwCurIndex = 0; // Index position of next name to be saved in our cache
	for (UINT i = 0; i < cMaxItems; ++i)
	{
		FUNCDESC *pfunc = NULL;
		VARDESC *pvar = NULL;
		MEMBERID memid = DISPID_UNKNOWN;

		if (fRoutine)
		{
			hr = scomITypeInfo->GetFuncDesc(i, &pfunc);
			if (FAILED(hr))
				break;
			if (pfunc->funckind == FUNC_DISPATCH && pfunc->invkind == INVOKE_FUNC && pfunc->cParams == 0)
				memid = pfunc->memid;
		}
		else
		{
			hr = scomITypeInfo->GetVarDesc(i, &pvar);
			if (SUCCEEDED(hr) && pvar->varkind == VAR_DISPATCH)
				memid = pvar->memid;
		}

		if (memid != DISPID_UNKNOWN)
		{
			UINT cNames = 0;
			BSTR bstrName = NULL;
			hr = scomITypeInfo->GetNames(memid, &bstrName, 1, &cNames);
			if (SUCCEEDED(hr) && cNames == 1 && (fRoutine || 0 != wcscmp(bstrName, g_wszGlobalDispatch)))
				snames[dwCurIndex++] = bstrName;
			else
				DMS_SysFreeString(m_fUseOleAut, bstrName);
		}

		if (fRoutine)
			scomITypeInfo->ReleaseFuncDesc(pfunc);
		else
			scomITypeInfo->ReleaseVarDesc(pvar);
	}

	scomITypeInfo->ReleaseTypeAttr(pattr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\object.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// Object.cpp : Implementations of CObject and CClass

/*#ifdef XBOX
#include <xtl.h>
#endif // XBOX
#include "dmusicip.h"
#include "loader.h"
#include "debug.h"
#include "miscutil.h"
#ifndef XBOX
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif
#endif // !XBOX

#ifdef XBOX
//#include "..\shared\nocom.h"
//#include "..\shared\xsoundp.h" // For IDirectSoundWave
//#include "dmusics.h" // for IID_IDirectMusicSynth8
//#include "..\shared\dmscriptautguids.h"
#endif // XBOX

#ifndef XBOX
const GUID GUID_NULL = { 0 };
#endif
*/
#include "pchloader.h"

#ifdef XBOX
#define USE_ANSI 
#define ONLY_ANSI
#else // !XBOX
#ifdef UNDER_CE
#define USE_UNICODE
#define ONLY_UNICODE
#else // !CE
#define USE_ANSI
#define USE_UNICODE
#define USE_BOTH
#endif // !CE
#endif // !XBOX

CDescriptor::CDescriptor()

{
    m_fCSInitialized = FALSE;

    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_llMemLength = 0;
    m_pbMemData = NULL;         // Null pointer to memory.
    m_dwValidData = 0;          // Flags indicating which of above is valid.
    m_guidObject = GUID_NULL;           // Unique ID for this object.
    m_guidClass = GUID_NULL;            // GUID for the class of object.
    ZeroMemory( &m_ftDate, sizeof(FILETIME) );              // File date of object.
    ZeroMemory( &m_vVersion, sizeof(DMUS_VERSION) );                // Version, as set by authoring tool.
    m_pwzName = NULL;               // Name of object.  
    m_pwzCategory = NULL;           // Category for object (optional).
    m_pwzFileName = NULL;           // File path.
    m_dwFileSize = 0;           // Size of file.
    m_pIStream = NULL;
    m_liStartPosition.QuadPart = 0;
}

CDescriptor::~CDescriptor()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to do any other initializations
        //
        if (m_pwzFileName) delete[] m_pwzFileName;
        if (m_pwzCategory) delete[] m_pwzCategory;
        if (m_pwzName) delete[] m_pwzName;
        if (m_pIStream) m_pIStream->Release();
        DELETE_CRITICAL_SECTION(&m_CriticalSection);
    }
}

void CDescriptor::ClearName()

{
    if (m_pwzName) delete[] m_pwzName;
    m_pwzName = NULL;
    m_dwValidData &= ~DMUS_OBJ_NAME;
}

void CDescriptor::SetName(WCHAR *pwzName)

{
    ClearName();
    m_pwzName = new WCHAR[wcslen(pwzName)+1];
    if (m_pwzName)
    {
        wcscpy( m_pwzName,pwzName ); 
        m_dwValidData |= DMUS_OBJ_NAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_NAME;
    }
}

void CDescriptor::ClearCategory()

{
    if (m_pwzCategory) delete[] m_pwzCategory;
    m_pwzCategory = NULL;
    m_dwValidData &= ~DMUS_OBJ_CATEGORY;
}

void CDescriptor::SetCategory(WCHAR *pwzCategory)

{
    ClearCategory();
    m_pwzCategory = new WCHAR[wcslen(pwzCategory)+1];
    if (m_pwzCategory)
    {
        wcscpy( m_pwzCategory,pwzCategory ); 
        m_dwValidData |= DMUS_OBJ_CATEGORY;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_CATEGORY;
    }
}

void CDescriptor::ClearFileName()

{
    if (m_pwzFileName) delete[] m_pwzFileName;
    m_pwzFileName = NULL;
    m_dwValidData &= ~DMUS_OBJ_FILENAME;
}

// return S_FALSE if the filename is already set to this
HRESULT CDescriptor::SetFileName(WCHAR *pwzFileName)

{
    if( m_pwzFileName )
    {
        if( !_wcsicmp( m_pwzFileName, pwzFileName ))
        {
            return S_FALSE;
        }
    }
    ClearFileName();
    m_pwzFileName = new WCHAR[wcslen(pwzFileName)+1];
    if (m_pwzFileName)
    {
        wcscpy( m_pwzFileName,pwzFileName ); 
        m_dwValidData |= DMUS_OBJ_FILENAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_FILENAME;
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

BOOL CDescriptor::IsEmpty()

{
    return !(m_dwValidData & (DMUS_OBJ_STREAM | DMUS_OBJ_FILENAME | DMUS_OBJ_NAME | DMUS_OBJ_MEMORY));
}

void CDescriptor::ClearIStream()

{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_pIStream)
    {
        m_pIStream->Release();
    }
    m_pIStream      = NULL;
    m_liStartPosition.QuadPart = 0;
    m_dwValidData  &= ~DMUS_OBJ_STREAM;
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
}

void CDescriptor::SetIStream(IStream *pIStream)

{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ClearIStream();

    m_pIStream = pIStream;

    if (m_pIStream)
    {
        ULARGE_INTEGER  libNewPosition;
        m_liStartPosition.QuadPart = 0;
        m_pIStream->Seek( m_liStartPosition, STREAM_SEEK_CUR, &libNewPosition );
        m_liStartPosition.QuadPart = libNewPosition.QuadPart;
        m_pIStream->AddRef();
        m_dwValidData |= DMUS_OBJ_STREAM;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
}

BOOL CDescriptor::IsExtension(WCHAR *pwzExtension)

{
    if (pwzExtension && m_pwzFileName)
    {
        DWORD dwX;
        DWORD dwLen = wcslen(m_pwzFileName);
        for (dwX = 0; dwX < dwLen; dwX++)
        {
            if (m_pwzFileName[dwX] == '.') break;
        }
        dwX++;
        if (dwX < dwLen)
        {
            return !_wcsicmp(pwzExtension,&m_pwzFileName[dwX]);
        }
    }
    return FALSE;
}

void CDescriptor::Get(LPDMUS_OBJECTDESC pDesc)

{
    // Don't return the IStream insterface. Once set, this becomes private to the loader.
    pDesc->dwValidData = m_dwValidData & ~DMUS_OBJ_STREAM;

    pDesc->guidObject = m_guidObject;
    pDesc->guidClass = m_guidClass;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    pDesc->llMemLength = m_llMemLength;
    pDesc->pbMemData = m_pbMemData;
    if (m_pwzName) 
    {
        wcsncpy( pDesc->wszName,m_pwzName, DMUS_MAX_NAME ); 
    }
    if (m_pwzCategory)
    {
        wcsncpy( pDesc->wszCategory,m_pwzCategory, DMUS_MAX_CATEGORY ); 
    }
    if (m_pwzFileName)
    {
        wcsncpy( pDesc->wszFileName, m_pwzFileName, DMUS_MAX_FILENAME);
    }
}

void CDescriptor::Set(LPDMUS_OBJECTDESC pDesc)

{
    m_dwValidData = pDesc->dwValidData;
    m_guidObject = pDesc->guidObject;
    m_guidClass = pDesc->guidClass;
    m_ftDate = pDesc->ftDate;
    m_vVersion = pDesc->vVersion;
    m_llMemLength = pDesc->llMemLength;
    m_pbMemData = pDesc->pbMemData;
    ClearName();
    if (pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;  // Force string length, in case of error.
        SetName(pDesc->wszName);
    }
    ClearCategory();
    if (pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;  // Force string length, in case of error.
        SetCategory(pDesc->wszCategory);
    }
    ClearFileName();
    if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        pDesc->wszFileName[DMUS_MAX_FILENAME - 1] = 0;  // Force string length, in case of error.
        SetFileName(pDesc->wszFileName);
    }
    ClearIStream();
    if (pDesc->dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->pStream);
    }
}

void CDescriptor::Copy(CDescriptor *pDesc)

{
    m_dwValidData = pDesc->m_dwValidData;
    m_guidObject = pDesc->m_guidObject;
    m_guidClass = pDesc->m_guidClass;
    m_ftDate = pDesc->m_ftDate;
    m_vVersion = pDesc->m_vVersion;
    m_llMemLength = pDesc->m_llMemLength;
    m_pbMemData = pDesc->m_pbMemData;
    ClearName();
    if (pDesc->m_dwValidData & DMUS_OBJ_NAME)
    {
        SetName(pDesc->m_pwzName);
    }
    ClearCategory();
    if (pDesc->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        SetCategory(pDesc->m_pwzCategory);
    }
    ClearFileName();
    if (pDesc->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        SetFileName(pDesc->m_pwzFileName);
    }
    ClearIStream();
    if (pDesc->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->m_pIStream);
    }
}

void CDescriptor::Merge(CDescriptor *pSource)

{
    if (pSource->m_dwValidData & DMUS_OBJ_OBJECT)
    {
        m_dwValidData |= DMUS_OBJ_OBJECT;
        m_guidObject = pSource->m_guidObject;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CLASS)
    {
        m_dwValidData |= DMUS_OBJ_CLASS;
        m_guidClass = pSource->m_guidClass;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_NAME)
    {
        m_dwValidData |= DMUS_OBJ_NAME;
        SetName(pSource->m_pwzName);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        m_dwValidData |= DMUS_OBJ_CATEGORY;
        SetCategory(pSource->m_pwzCategory);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_VERSION)
    {
        m_dwValidData |= DMUS_OBJ_VERSION;
        m_vVersion = pSource->m_vVersion;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_DATE)
    {
        m_dwValidData |= DMUS_OBJ_DATE;
        m_ftDate = pSource->m_ftDate; 
    }
    if (pSource->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        if (!(m_dwValidData & DMUS_OBJ_FILENAME))
        {
            if (SUCCEEDED(SetFileName(pSource->m_pwzFileName)))
            {
                m_dwValidData |= (pSource->m_dwValidData & 
                    (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH | DMUS_OBJ_URL));
            }
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_MEMORY)
    {
        m_pbMemData = pSource->m_pbMemData;
        m_llMemLength = pSource->m_llMemLength;
        if (m_llMemLength && m_pbMemData)
        {
            m_dwValidData |= DMUS_OBJ_MEMORY;
        }
        else
        {
            m_dwValidData &= ~DMUS_OBJ_MEMORY;
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pSource->m_pIStream);
    }
}

CObject::CObject(CClass *pClass)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_pvecReferences = NULL;
}

CObject::CObject(CClass *pClass, CDescriptor *pDesc)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_ObjectDesc.Copy(pDesc);
    m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
    if (!(m_ObjectDesc.m_dwValidData & DMUS_OBJ_CLASS))
    {
        m_ObjectDesc.m_guidClass = pClass->m_ClassDesc.m_guidClass;
        m_ObjectDesc.m_dwValidData |= 
            (pClass->m_ClassDesc.m_dwValidData & DMUS_OBJ_CLASS);
    }
    m_pvecReferences = NULL;
}


CObject::~CObject()

{
    if (m_pIDMObject)
    {
        m_pIDMObject->Release();
        m_pIDMObject = NULL;
    }
    delete m_pvecReferences;
}

HRESULT CObject::Parse()

{
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        return ParseFromFile();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        return ParseFromMemory();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        return ParseFromStream();
    }
    assert(false);
    return E_FAIL;
}

HRESULT CObject::ParseFromFile()

{
    HRESULT hr;
    IDirectMusicObject *pIObject = NULL;
    hr = DirectMusicCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicFileStream,
            NULL, IID_CFileStream, (void **) &pStream );
        if (pStream)
        {
            pStream->Init(m_pClass->m_pLoader);
            if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
            {
                wcscpy(wzFullPath,m_ObjectDesc.m_pwzFileName);
            }
            else
            {
                m_pClass->GetPath(wzFullPath);
                wcscat(wzFullPath,m_ObjectDesc.m_pwzFileName);
            }
            hr = pStream->Open(wzFullPath,GENERIC_READ);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
				assert(pDESC);
                memset((void *)pDESC,0,sizeof(DMUS_OBJECTDESC));
                pDESC->dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,pDESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(pDESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
				delete pDESC;
            }
#ifdef XBOX
#ifdef DEBUG
            else {
                Trace(-1,"CObject::ParseFromFile: Could not open file: \"%S\"\n", wzFullPath);
            }
#endif
#endif
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromMemory()

{
    HRESULT hr;
    IDirectMusicObject *pIObject = NULL;
    hr = DirectMusicCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CMemStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicMemStream,
            NULL, IID_CMemStream, (void **) &pStream );
        if (pStream)
        {
            pStream->Init(m_pClass->m_pLoader);
            hr = pStream->Open(m_ObjectDesc.m_pbMemData,m_ObjectDesc.m_llMemLength);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
				assert(pDESC);
                memset((void *)pDESC,0,sizeof(DMUS_OBJECTDESC));
                pDESC->dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,pDESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(pDESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
				delete pDESC;
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromStream()

{
    HRESULT hr;
    IDirectMusicObject *pIObject = NULL;
    hr = DirectMusicCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicStreamStream,
            NULL, IID_CStream, (void **) &pStream );
        if (pStream)
        {
            pStream->Init(m_pClass->m_pLoader);
            hr = pStream->Open(m_ObjectDesc.m_pIStream,
                m_ObjectDesc.m_liStartPosition);
            if (SUCCEEDED(hr))
            {
				// Allocate dynamically to avoid using stack space on XBox!
                DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
				assert(pDESC);
                memset((void *)pDESC,0,sizeof(DMUS_OBJECTDESC));
                pDESC->dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,pDESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(pDESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
				delete pDESC;
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


// Record that this object can be garbage collected and prepare to store its references.
// Must be called before any of CObject's other routines.
HRESULT CObject::GC_Collectable()

{
    m_dwScanBits |= SCAN_GC;
    assert(!m_pvecReferences);

    m_pvecReferences = new SmartRef::Vector<CObject*>;
    if (!m_pvecReferences)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CObject::GC_AddReference(CObject *pObject)

{
    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    // don't track references to objects that aren't garbage collected
    if (!(pObject->m_dwScanBits & SCAN_GC))
        return S_OK;

    UINT uiPosNext = m_pvecReferences->size();
    for (UINT i = 0; i < uiPosNext; ++i)
    {
        if ((*m_pvecReferences)[i] == pObject)
            return S_OK;
    }

    if (!m_pvecReferences->AccessTo(uiPosNext))
        return E_OUTOFMEMORY;
    (*m_pvecReferences)[uiPosNext] = pObject;
    return S_OK;
}

HRESULT CObject::GC_RemoveReference(CObject *pObject)

{
    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    SmartRef::Vector<CObject*> &vecRefs = *m_pvecReferences;
    UINT iEnd = vecRefs.size();
    for (UINT i = 0; i < iEnd; ++i)
    {
        if (vecRefs[i] == pObject)
        {
            // Remove by clearing the pointer.
            // The open slot will be compacted during garbage collection (GC_Mark).
            vecRefs[i] = NULL;
            return S_OK;
        }
    }
    return S_FALSE;
}

// Helper method used to implement ReleaseObject.
HRESULT CObject::GC_RemoveAndDuplicateInParentList()
{
    CObject* pObjectToFind = NULL;
    HRESULT hr = m_pClass->FindObject(&m_ObjectDesc, &pObjectToFind, this, m_pIDMObject);
    if (SUCCEEDED(hr) && pObjectToFind)
    {
        m_pClass->GC_Replace(this, NULL);
    }
    else
    {
        CObject *pObjectUnloaded = new CObject(m_pClass, &m_ObjectDesc);
        if (!pObjectUnloaded)
        {
            return E_OUTOFMEMORY;
        }

        m_pClass->GC_Replace(this, pObjectUnloaded);
    }
    return S_OK;
}

HRESULT CObject::Load()

{
    // See if we have one of the fields we need to load
    if (!(m_ObjectDesc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM)))
    {
        Trace(1, "Error: GetObject failed because the requested object was not already cached and the supplied desciptor did not specify a source to load the object from (DMUS_OBJ_FILENAME, DMUS_OBJ_MEMORY, or DMUS_OBJ_STREAM).\n");
        return DMUS_E_LOADER_NOFILENAME;
    }

    // Create the object
    SmartRef::ComPtr<IDirectMusicObject> scomIObject = NULL;
    HRESULT hr = DirectMusicCreateInstance(m_ObjectDesc.m_guidClass, NULL, IID_IDirectMusicObject, reinterpret_cast<void**>(&scomIObject));
    if (FAILED(hr))
        return hr;

    // Create the stream the object will load from
    SmartRef::ComPtr<IStream> scomIStream;
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicFileStream,
            NULL, IID_CFileStream, (void **) &pStream );
        if (!pStream)
            return E_OUTOFMEMORY;
        pStream->Init( m_pClass->m_pLoader );
        scomIStream = pStream;

        if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
        {
            wcscpy(wzFullPath,m_ObjectDesc.m_pwzFileName);
        }
        else
        {
            m_pClass->GetPath(wzFullPath);
            wcscat(wzFullPath,m_ObjectDesc.m_pwzFileName);
        }
        hr = pStream->Open(wzFullPath,GENERIC_READ);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        CMemStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicMemStream,
            NULL, IID_CMemStream, (void **) &pStream );
        if (!pStream)
            return E_OUTOFMEMORY;
        pStream->Init(m_pClass->m_pLoader);
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pbMemData, m_ObjectDesc.m_llMemLength);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        CStream *pStream = NULL; 
        DirectMusicCreateInstance(CLSID_DirectMusicStreamStream,
            NULL, IID_CStream, (void **) &pStream );
        if (!pStream)
            return E_OUTOFMEMORY;
        pStream->Init(m_pClass->m_pLoader);
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pIStream, m_ObjectDesc.m_liStartPosition);
        if (FAILED(hr))
            return hr;
    }

    // Load the object
    IPersistStream* pIPS = NULL;
    hr = scomIObject->QueryInterface( IID_IPersistStream, (void**)&pIPS );
    if (FAILED(hr))
        return hr;
    // Save the new object.  Needs to be done before loading because of circular references.  While this object
    // loads it could get other objects and those other objects could need to get this object.
    SafeRelease(m_pIDMObject);
    m_pIDMObject = scomIObject.disown();
    hr = pIPS->Load( scomIStream );
    pIPS->Release();
    if (FAILED(hr))
    {
        // Clear the object we set above.
        SafeRelease(m_pIDMObject);
        return hr;
    }

    // Merge in descriptor information from the object
    CDescriptor Desc;
    DMUS_OBJECTDESC *pDESC = new DMUS_OBJECTDESC;
	assert(pDESC);
    memset((void *)pDESC,0,sizeof(DMUS_OBJECTDESC));
    pDESC->dwSize = sizeof (DMUS_OBJECTDESC);
    m_pIDMObject->GetDescriptor(pDESC);
    Desc.Set(pDESC);
    m_ObjectDesc.Merge(&Desc);
    m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
    m_ObjectDesc.Get(pDESC);
    m_pIDMObject->SetDescriptor(pDESC);
	delete pDESC;
    return hr;
}

// Collect everything that is unmarked.
void CObjectList::GC_Sweep(BOOL bOnlyScripts)

{
    // sweep through looking for unmarked GC objects
    CObject *pObjectPrev = NULL;
    CObject *pObjectNext = NULL;
    for (CObject *pObject = this->GetHead(); pObject; pObject = pObjectNext)
    {
        // get the next item now since we could be messing with the list
        pObjectNext = pObject->GetNext();

        bool fRemoved = false;
        if(bOnlyScripts && pObject->m_ObjectDesc.m_guidClass != CLSID_DirectMusicScript)
        {
            pObjectPrev = pObject;
            continue;
        }


        if (pObject->m_dwScanBits & SCAN_GC)
        {
            if (!(pObject->m_dwScanBits & SCAN_GC_MARK))
            {
                // the object is unused

                // Zombie it to break any cyclic references
                IDirectMusicObject *pIDMO = pObject->m_pIDMObject;
                if (pIDMO)
                {
                    IDirectMusicObjectP *pIDMO8 = NULL;
                    HRESULT hr = pIDMO->QueryInterface(IID_IDirectMusicObjectP, reinterpret_cast<void**>(&pIDMO8));
                    if (SUCCEEDED(hr))
                    {
                        pIDMO8->Zombie();
                        pIDMO8->Release();
                    }

#ifdef DBG
                    DebugTrace(4, SUCCEEDED(hr) ? "   *%08X Zombied\n" : "   *%08X no IDirectMusicObjectP interface\n", pObject);
#endif
                }

                // remove it from the list
                if (pObjectPrev)
                    pObjectPrev->Remove(pObject);
                else
                    this->RemoveHead();
                delete pObject;
                fRemoved = true;
            }
            else
            {
                // clear mark for next time
                pObject->m_dwScanBits &= ~SCAN_GC_MARK;
            }
        }

        if (!fRemoved)
            pObjectPrev = pObject;
    }
}

CClass::CClass(CLoader *pLoader)

{
    assert(pLoader);
    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;
}

CClass::CClass(CLoader *pLoader, CDescriptor *pDesc)

{
    assert(pLoader);
    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;

    // Set up this class's descritor with just the class id.
    m_ClassDesc.m_guidClass = pDesc->m_guidClass;
    m_ClassDesc.m_dwValidData = DMUS_OBJ_CLASS;
}


CClass::~CClass()

{
    ClearObjects(FALSE,NULL);
}

void CClass::ClearObjects(BOOL fKeepCache, WCHAR *pwzExtension)

//  Clear objects from the class list, optionally keep 
//  cached objects or objects that are not of the requested extension.

{
    m_fDirSearched = FALSE;
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        DMUS_OBJECTDESC DESC;
        pObject->m_ObjectDesc.Get(&DESC);
        // If the keepCache flag is set, we want to hang on to the object
        // if it is GM.dls, an object that's currently cached, or
        // an object with a different extension from what we are looking for.
#ifdef XBOX

        if (fKeepCache && (pObject->m_pIDMObject || !pObject->m_ObjectDesc.IsExtension(pwzExtension)))

#else // XBOX

        if (fKeepCache && 
            ((DESC.guidObject == GUID_DefaultGMCollection)
#ifdef DRAGON
            || (DESC.guidObject == GUID_DefaultGMDrums)
#endif
            || pObject->m_pIDMObject 
            || !pObject->m_ObjectDesc.IsExtension(pwzExtension)))

#endif // XBOX

        {
            KeepList.AddHead(pObject);
        }
        else
        {
            delete pObject;
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}


HRESULT CClass::FindObject(CDescriptor *pDesc,CObject ** ppObject, CObject *pNotThis, IDirectMusicObject *pIDMObject)

{
    DWORD dwSearchBy = pDesc->m_dwValidData;
    CObject *pObject = NULL;

    if (dwSearchBy & DMUS_OBJ_OBJECT)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_OBJECT)
            {
                if (pObject->m_ObjectDesc.m_guidObject == pDesc->m_guidObject)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_MEMORY)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
            {
                if (pObject->m_ObjectDesc.m_pbMemData == pDesc->m_pbMemData)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_STREAM)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
            {
                if (pObject->m_ObjectDesc.m_pIStream == pDesc->m_pIStream)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_FILENAME) && (dwSearchBy & DMUS_OBJ_FULLPATH))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName,pDesc->m_pwzFileName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_NAME) && (dwSearchBy & DMUS_OBJ_CATEGORY))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_CATEGORY))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzCategory,pDesc->m_pwzCategory))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName,pDesc->m_pwzName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_NAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME)
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName,pDesc->m_pwzName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_FILENAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
            {
                if ((dwSearchBy & DMUS_OBJ_FULLPATH) == (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName,pDesc->m_pwzFileName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
                else
                {
                    WCHAR *pC1 = pObject->m_ObjectDesc.m_pwzFileName;
                    WCHAR *pC2 = pDesc->m_pwzFileName;
                    if (dwSearchBy & DMUS_OBJ_FULLPATH)
                    {
                        pC1 = wcsrchr(pObject->m_ObjectDesc.m_pwzFileName, L'\\');
                    }
                    else
                    {
                        pC2 = wcsrchr(pDesc->m_pwzFileName, '\\');
                    }
                    if (pC1 && pC2)
                    {
                        if (!_wcsicmp(pC1,pC2))
                        {
                            *ppObject = pObject;
                            return S_OK;
                        }
                    }
                }
            }
        }
    }
    if (pIDMObject)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_pIDMObject == pIDMObject)
            {
                *ppObject = pObject;
                return S_OK;
            }
        }
    }

    *ppObject = NULL;
    return DMUS_E_LOADER_OBJECTNOTFOUND;
}

HRESULT CClass::EnumerateObjects(DWORD dwIndex,CDescriptor *pDesc)

{
    if (m_fDirSearched == FALSE)
    {
//      SearchDirectory();
    }
    if ((dwIndex < m_dwLastIndex) || (m_pLastObject == NULL))
    {
        m_dwLastIndex = 0;
        m_pLastObject = m_ObjectList.GetHead();
    }
    while (m_dwLastIndex < dwIndex)
    {
        if (!m_pLastObject) break;
        m_dwLastIndex++;
        m_pLastObject = m_pLastObject->GetNext();
    }
    if (m_pLastObject)
    {
        pDesc->Copy(&m_pLastObject->m_ObjectDesc);
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CClass::GetPath(WCHAR * pwzPath)

{
    if (m_ClassDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        wcsncpy(pwzPath, m_ClassDesc.m_pwzFileName, DMUS_MAX_FILENAME);
        return S_OK;
    }
    else 
    {
        return m_pLoader->GetPath(pwzPath);
    }
}

// returns S_FALSE if the search directory is already set to this.
HRESULT CClass::SetSearchDirectory(WCHAR * pwzPath,BOOL fClear)

{
    HRESULT hr;

    hr = m_ClassDesc.SetFileName(pwzPath);
    if (SUCCEEDED(hr))
    {
        m_ClassDesc.m_dwValidData |= DMUS_OBJ_FULLPATH;
    }
    if (fClear)
    {
        CObjectList KeepList;   // Use to store objects to keep.
        while (!m_ObjectList.IsEmpty())
        {
            CObject *pObject = m_ObjectList.RemoveHead();
            if (pObject->m_pIDMObject)
            {
                KeepList.AddHead(pObject);
            }
#ifndef XBOX
            else
            {
                // check for the special case of the default gm collection.
                // don't clear that one out.
                DMUS_OBJECTDESC DESC;
                pObject->m_ObjectDesc.Get(&DESC);
                if( DESC.guidObject == GUID_DefaultGMCollection )
                {
                    KeepList.AddHead(pObject);
                }
                else
                {
                    delete pObject;
                }
            }
#endif
        }
        //  Now put cached objects back in list.
        while (!KeepList.IsEmpty())
        {
            CObject *pObject = KeepList.RemoveHead();
            m_ObjectList.AddHead(pObject);
        }
        m_pLastObject = NULL;
    }
    return hr;
}

HRESULT CClass::GetObject(CDescriptor *pDesc, CObject ** ppObject)

{
    
    HRESULT hr = FindObject(pDesc,ppObject);
    if (SUCCEEDED(hr)) // Okay, found object in list.
    {
        return hr;
    }
    *ppObject = new CObject (this, pDesc);
    if (*ppObject)
    {
        m_ObjectList.AddHead(*ppObject);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CClass::RemoveObject(CObject* pRemoveObject)
//  Remove an object from the class list
{
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        if(( pObject == pRemoveObject ) || (!pRemoveObject && pObject->m_ObjectDesc.IsEmpty()))
        {
            delete pObject;
            // we can assume no duplicates, and we should avoid comparing the deleted
            // object to the remainder of the list
            if (pRemoveObject)
                break;
        }
        else
        {
            KeepList.AddHead(pObject);
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}

HRESULT CClass::ClearCache(bool fClearStreams)

{
    CObject *pObject = m_ObjectList.GetHead();
    CObject *pObjectPrev = NULL; // remember the previous object -- needed to quickly remove the current object from the list
    CObject *pObjectNext = NULL; // remember the next object -- needed because the current object may be removed from the list
    for (;pObject;pObject = pObjectNext)
    {
        // Should always clear the IStreams.
//        if (fClearStreams)
        pObject->m_ObjectDesc.ClearIStream();
        pObjectNext = pObject->GetNext();
        if (pObject->m_pIDMObject)
        {
            if (pObject->m_dwScanBits & SCAN_GC)
            {
                // Other objects may have references to this one so we need to keep this object around
                // and track its references.  We'll hold onto the DMObject pointer too because we may
                // later need to Zombie the object in order to break a cyclic reference.

                // We'll place an unloaded object with a duplicate descriptor in the cache to match the
                // non-GC behavior and then move the original object into a list of released objects that
                // will eventually be reclaimed by CollectGarbage.

                CObject *pObjectUnloaded = new CObject(this, &pObject->m_ObjectDesc);
                if (!pObjectUnloaded)
                {
                    return E_OUTOFMEMORY;
                }

                if (!pObjectPrev)
                    m_ObjectList.Remove(pObject);
                else
                    pObjectPrev->Remove(pObject);
                m_ObjectList.AddHead(pObjectUnloaded);
                m_pLoader->GC_UpdateForReleasedObject(pObject);
            }
            else
            {
                pObject->m_pIDMObject->Release();
                pObject->m_pIDMObject = NULL;
                pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;

                pObjectPrev = pObject;
            }
        }
    }

    return S_OK;
}

// return S_FALSE if the cache is already enabled according to fEnable,
// indicating it's already been done.
HRESULT CClass::EnableCache(BOOL fEnable)

{
    HRESULT hr = S_FALSE;
    if (!fEnable)
    {
        ClearCache(false);
    }
    if( m_fKeepObjects != fEnable )
    {
        hr = S_OK;
        m_fKeepObjects = fEnable;
    }
    return hr;
}

typedef struct ioClass
{
    GUID    guidClass;
} ioClass;


HRESULT CClass::SaveToCache(IRIFFStream *pRiff)

{
    HRESULT hr = S_OK;
    IStream* pIStream;
    MMCKINFO ck;
    WORD wStructSize;
    DWORD dwBytesWritten;
//  DWORD dwBufferSize;
    ioClass oClass;

    ZeroMemory(&ck, sizeof(MMCKINFO));

    pIStream = pRiff->GetStream();
    if( pIStream == NULL )
    {
        // I don't think anybody should actually be calling this function
        // if they don't have a stream.  Currently, this is only called by
        // SaveToCache file.  It definitely has a stream when it calls
        // AllocRIFFStream and the stream should still be there when
        // we arrive here.
        assert(false);

        return DMUS_E_LOADER_NOFILENAME;
    }

    // Write class chunk header
    ck.ckid = FOURCC_CLASSHEADER;
    if( pRiff->CreateChunk( &ck, 0 ) == 0 )
    {
        wStructSize = sizeof(ioClass);
        hr = pIStream->Write( &wStructSize, sizeof(wStructSize), &dwBytesWritten );
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(wStructSize) )
        {
            pIStream->Release();
            return DMUS_E_CANNOTWRITE;
        }
        // Prepare ioClass structure
    //  memset( &oClass, 0, sizeof(ioClass) );
        memcpy( &oClass.guidClass, &m_ClassDesc.m_guidClass, sizeof(GUID) );

        // Write Class header data
        hr = pIStream->Write( &oClass, sizeof(oClass), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(oClass) )
        {
            hr = DMUS_E_CANNOTWRITE;
        }
        else
        {
            if( pRiff->Ascend( &ck, 0 ) != 0 )
            {
                hr = DMUS_E_CANNOTSEEK;
            }
        }

    }
    else
    {
        hr = DMUS_E_CANNOTSEEK;
    }
    pIStream->Release();
    return hr;
}

void CClass::PreScan()

/*  Prior to scanning a directory, mark all currently loaded objects
    so they won't be confused with objects loaded in the scan or
    referenced by the cache file.
*/

{
    CObject *pObject = m_ObjectList.GetHead();
    for (;pObject != NULL; pObject = pObject->GetNext())
    {
        // clear the lower fields and set SCAN_PRIOR
        pObject->m_dwScanBits &= ~(SCAN_CACHE | SCAN_PARSED | SCAN_SEARCH);
        pObject->m_dwScanBits |= SCAN_PRIOR;
    }
}

// Helper method used to implement RemoveAndDuplicateInParentList.
void CClass::GC_Replace(CObject *pObject, CObject *pObjectReplacement)

{
    m_ObjectList.Remove(pObject);
    if (pObjectReplacement)
    {
        m_ObjectList.AddHead(pObjectReplacement);
    }
}

HRESULT CClass::SearchDirectory(WCHAR *pwzExtension)

{
    HRESULT hr;
    IDirectMusicObject *pIObject = NULL;
    hr = DirectMusicCreateInstance(m_ClassDesc.m_guidClass,
        NULL,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CFileStream *pStream = new CFileStream;
        if (pStream)
        {
            pStream->Init(m_pLoader);
            WCHAR wzPath[MAX_PATH];
            hr = GetPath(wzPath);
            if (SUCCEEDED(hr))
            {
                hr = S_FALSE;
                CObjectList TempList;
#ifdef USE_ANSI
                char szPath[MAX_PATH];
                WIN32_FIND_DATAA fileinfoA;
#endif      
#ifdef USE_UNICODE
                WIN32_FIND_DATAW fileinfoW;
#endif
                HANDLE  hFindFile;
                CObject * pObject;
                wcscat(wzPath, L"*." );
                wcscat(wzPath, pwzExtension);
#ifdef USE_BOTH
                if (g_fIsUnicode)
                {
                    hFindFile = FindFirstFileW( wzPath, &fileinfoW );
                }
                else
                {
                    wcstombs( szPath, wzPath, MAX_PATH );
                    hFindFile = FindFirstFileA( szPath, &fileinfoA );
                }
#endif
#ifdef ONLY_UNICODE
				hFindFile = FindFirstFileW( wzPath, &fileinfoW );
#endif
#ifdef ONLY_ANSI
				wcstombs( szPath, wzPath, MAX_PATH );
                hFindFile = FindFirstFileA( szPath, &fileinfoA );
#endif // ONLY_ANSI

                if( hFindFile == INVALID_HANDLE_VALUE )
                {
                    pStream->Release();
                    pIObject->Release();
                    return S_FALSE;
                }
                ClearObjects(TRUE, pwzExtension); // Clear everything but the objects currently loaded.
                for (;;)
                {
                    BOOL fGoParse = FALSE;
                    CDescriptor Desc;
                    GetPath(wzPath);
#ifdef USE_BOTH
                    if (g_fIsUnicode)
                    {
                        Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                        wcsncat(wzPath,fileinfoW.cFileName,DMUS_MAX_FILENAME);
                    }
                    else
                    {
                        Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                        WCHAR wzFileName[MAX_PATH];
                        mbstowcs( wzFileName, fileinfoA.cFileName, MAX_PATH );
                        wcsncat(wzPath,wzFileName,DMUS_MAX_FILENAME);
                    }
#endif
#ifdef ONLY_UNICODE
					Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                    wcsncat(wzPath,fileinfoW.cFileName,DMUS_MAX_FILENAME);
#endif
#ifdef ONLY_ANSI
					Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                    WCHAR wzFileName[MAX_PATH];
                    mbstowcs( wzFileName, fileinfoA.cFileName, MAX_PATH );
                    wcsncat(wzPath,wzFileName,DMUS_MAX_FILENAME);
#endif
                    if (SUCCEEDED(Desc.SetFileName(wzPath)))
                    {
                        Desc.m_dwValidData = (DMUS_OBJ_DATE | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
                    }
                    if (SUCCEEDED(FindObject(&Desc,&pObject))) // Make sure we don't already have it.
                    {
#ifdef USE_BOTH
                        if (g_fIsUnicode)
                        {
                            fGoParse = (fileinfoW.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                            if (!fGoParse)
                            {
                                fGoParse = !memcmp(&fileinfoW.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                            }
                        }
                        else
                        {
                            fGoParse = (fileinfoA.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                            if (!fGoParse)
                            {
                                fGoParse = !memcmp(&fileinfoA.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                            }
                        }
#endif
#ifdef ONLY_UNICODE
                        fGoParse = (fileinfoW.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                        if (!fGoParse)
                        {
                            fGoParse = !memcmp(&fileinfoW.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                        }
#endif
#ifdef ONLY_ANSI
                        fGoParse = (fileinfoA.nFileSizeLow != pObject->m_ObjectDesc.m_dwFileSize);
                        if (!fGoParse)
                        {
                            fGoParse = !memcmp(&fileinfoA.ftLastWriteTime,&pObject->m_ObjectDesc.m_ftDate,sizeof(FILETIME));
                        }
#endif
							// Yet, disregard if it is already loaded.
                        if (pObject->m_pIDMObject) fGoParse = FALSE;
                    }
                    else fGoParse = TRUE;
                    if (fGoParse)
                    {
                        HRESULT hrTemp = pStream->Open(Desc.m_pwzFileName,GENERIC_READ);
                        if (SUCCEEDED(hrTemp))
                        {
                            DMUS_OBJECTDESC DESC;
                            memset((void *)&DESC,0,sizeof(DESC));
                            DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                            hrTemp = pIObject->ParseDescriptor(pStream,&DESC);
                            if (SUCCEEDED(hrTemp))
                            {
                                hr = S_OK;
                                CDescriptor ParseDesc;
                                ParseDesc.Set(&DESC);
                                Desc.Merge(&ParseDesc);
#ifdef USE_BOTH
                                if (g_fIsUnicode)
                                {
                                    Desc.m_dwFileSize = fileinfoW.nFileSizeLow;
                                    Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                                }
                                else
                                {
                                    Desc.m_dwFileSize = fileinfoA.nFileSizeLow;
                                    Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                                }
#endif                          
#ifdef ONLY_UNICODE
                                Desc.m_dwFileSize = fileinfoW.nFileSizeLow;
                                Desc.m_ftDate = fileinfoW.ftLastWriteTime;
#endif
#ifdef ONLY_ANSI
                                Desc.m_dwFileSize = fileinfoA.nFileSizeLow;
                                Desc.m_ftDate = fileinfoA.ftLastWriteTime;
#endif
                                if (pObject)
                                {
                                    pObject->m_ObjectDesc.Copy(&Desc);
                                    pObject->m_dwScanBits |= SCAN_PARSED | SCAN_SEARCH;
                                }
                                else
                                {
                                    pObject = new CObject(this, &Desc);
                                    if (pObject)
                                    {
                                        TempList.AddHead(pObject);
                                        pObject->m_dwScanBits |= SCAN_PARSED | SCAN_SEARCH;
                                    }
                                }
                            }
                            pStream->Close();
                        }
                    }
#ifdef USE_BOTH
                    if (g_fIsUnicode)
                    {
                        if ( !FindNextFileW( hFindFile, &fileinfoW ) ) break;
                    }
                    else
                    {
                        if ( !FindNextFileA( hFindFile, &fileinfoA ) ) break;
                    }
#endif
#ifdef ONLY_UNICODE
					if ( !FindNextFileW( hFindFile, &fileinfoW ) ) break;
#endif
#ifdef ONLY_ANSI
					if ( !FindNextFileA( hFindFile, &fileinfoA ) ) break;
#endif
                }
                FindClose(hFindFile );
                while (!TempList.IsEmpty())
                {
                    pObject = TempList.RemoveHead();
                    m_ObjectList.AddHead(pObject);
                }
                m_fDirSearched = TRUE;
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\loader.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// Loader.h : Declaration of CLoader
//
// @doc EXTERNAL
//

#ifndef __CDMLOADER_H_
#define __CDMLOADER_H_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include "dmusicip.h"
#include "Alist.h"
#include "riff.h"
#include "ima.h"
#include <mmreg.h>
#include <stdio.h>
#include "smartref.h"
#include "..\shared\dmusicp.h"

class CLoader;
class CClass;

#define FOURCC_RIFF_CACHE		mmioFOURCC('D','M','L','C')
#define FOURCC_LIST_CLASSLIST	mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER		mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST		mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER		mmioFOURCC('o','b','j','h')

// We need an older sized object descriptor for parameter validation. 

typedef struct _DMUS_OLDOBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
} DMUS_OLDOBJECTDESC;


class CDescriptor
{
public:
					CDescriptor();
					~CDescriptor();

	void			Get(LPDMUS_OBJECTDESC pDesc);
	void			Set(LPDMUS_OBJECTDESC pDesc);
	void			Merge(CDescriptor * pDesc);
	void			ClearName();
	void			SetName(WCHAR *pwzName);
	void			ClearCategory();
	void			SetCategory(WCHAR *pwzCategory);
	void			ClearFileName();
	HRESULT			SetFileName(WCHAR *pwzFileName);
	void     		SetIStream(IStream *pIStream);
    void            ClearIStream();
	void			Copy(CDescriptor *pDesc);
	BOOL			IsExtension(WCHAR *pwzExtension);
    BOOL            IsEmpty();
public:
	LONGLONG		m_llMemLength;			// Memory size.
	DWORD			m_dwValidData;			// Flags indicating which of above is valid.
	GUID			m_guidObject;			// Unique ID for this object.
	GUID			m_guidClass;			// GUID for the class of object.
	FILETIME		m_ftDate;				// File date of object.
	DMUS_VERSION	m_vVersion;				// Version, as set by authoring tool.
	WCHAR *			m_pwzName;				// Name of object.	
	WCHAR *			m_pwzCategory;			// Category for object (optional).
	WCHAR *			m_pwzFileName;			// File path.
	DWORD			m_dwFileSize;			// Size of file.
	BYTE *			m_pbMemData;			// Pointer to memory.
    IStream *       m_pIStream;             // Pointer to IStream object.
    LARGE_INTEGER   m_liStartPosition;      // Position in stream to start at.   
    CRITICAL_SECTION	m_CriticalSection;	// Critical section for the descriptor's stream.
    BOOL                m_fCSInitialized;
};

#define     SCAN_CACHE		1			// Was found in cache file.
#define     SCAN_PRIOR		2			// Was in list prior to scanning.
#define     SCAN_PARSED		4			// Was parsed in the directory.
#define     SCAN_SEARCH		8			// Type of object we are searching for.
const DWORD SCAN_GC =		1 << 12;	// Object was cached while garbage collection was enabled.
const DWORD SCAN_GC_MARK =	1 << 13;	// Bit set during marking phase of CollectGarbage.  Objects that remain unmarked are garbage.
										// Also used to detect cycles.


class CObject : public AListItem
{
public:
									CObject(CClass *pClass);
									CObject(CClass *pClass, CDescriptor *pDesc);
									~CObject();
    CObject *						GetNext() {return(CObject *)AListItem::GetNext();};
	HRESULT							Load();
	HRESULT							Parse();
	HRESULT							ParseFromFile();
	HRESULT							ParseFromMemory();
	HRESULT							ParseFromStream();
	HRESULT							GC_Collectable();
	HRESULT							GC_AddReference(CObject *pObject);
	HRESULT							GC_RemoveReference(CObject *pObject);
	HRESULT							GC_RemoveAndDuplicateInParentList();

	CDescriptor						m_ObjectDesc;
	IDirectMusicObject *			m_pIDMObject;
	DWORD							m_dwScanBits;
	SmartRef::Vector<CObject*> *	m_pvecReferences;
	CClass *				m_pClass;
};

class CObjectList : public AList
{
public:
    CObject *	GetHead() {return (CObject *)AList::GetHead();};
    CObject *	RemoveHead() {return (CObject *)AList::RemoveHead();};
	void		GC_Sweep(BOOL bOnlyScripts = FALSE);
};


class CClass : public AListItem
{
public:
						CClass( CLoader *pLoader );
						CClass( CLoader *pLoader, CDescriptor *pDesc );
						~CClass();
	void				ClearObjects(BOOL fKeepCache,WCHAR *pwzExtension);
	void				RemoveObject(CObject* pRemoveObject);
    CClass *			GetNext() {return(CClass *)AListItem::GetNext();};
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	HRESULT             FindObject(CDescriptor *pDesc,CObject **ppObject, CObject *NotThis = NULL, IDirectMusicObject *pIDMObject = NULL);
	HRESULT				EnumerateObjects(
							DWORD dwIndex, 
							CDescriptor *pDesc) ;
	HRESULT				SetSearchDirectory(WCHAR *pwzPath,BOOL fClear);
	HRESULT				SearchDirectory(WCHAR *pwzFileExtension);
	HRESULT				EnableCache(BOOL fEnable);
	HRESULT				ClearCache(bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT				SaveToCache(IRIFFStream *pRiff);
	HRESULT				GetObject(CDescriptor *pDesc, CObject ** ppObject);
	void				PreScan();
	void				GC_Replace(CObject *pObject, CObject *pObjectReplacement);
	void				GC_Sweep() { m_ObjectList.GC_Sweep(); }

	CDescriptor			m_ClassDesc;
	CLoader *			m_pLoader;
	BOOL				m_fKeepObjects;		// Hang onto objects after loading them.

	friend void GC_Report(CLoader *);
private:
	CObjectList			m_ObjectList;
	DWORD				m_dwLastIndex;		// For tracking enumeration.
	CObject *			m_pLastObject;		// Last object enumerated.
	BOOL				m_fDirSearched;		// Directory has been searched for files.
};

class CClassList : public AList
{
public:
    CClass *	GetHead() {return (CClass *)AList::GetHead();};
    CClass *	RemoveHead() {return (CClass *)AList::RemoveHead();};
};


class CLoader : public IDirectMusicLoader8, public CMemTrack,
#ifdef DXAPI
    public IDirectMusicIMA,
#endif
    public IDirectMusicLoader8P
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicLoader
	STDMETHODIMP GetObject(LPDMUS_OBJECTDESC pDesc, REFIID, LPVOID FAR *) ;
	STDMETHODIMP SetObject(LPDMUS_OBJECTDESC pDesc) ;
#ifdef XBOX
    STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, const char *pszPath, BOOL fClear) ;
#else
    STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) ;
#endif
	STDMETHODIMP ScanDirectory(REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) ;
	STDMETHODIMP CacheObject(IDirectMusicObject * pObject) ;
	STDMETHODIMP ReleaseObject(IDirectMusicObject * pObject) ;
	STDMETHODIMP ClearCache(REFGUID rguidClass) ;
	STDMETHODIMP EnableCache(REFGUID rguidClass, BOOL fEnable) ;
	STDMETHODIMP EnumObject(REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) ;

	// IDirectMusicLoader8
	STDMETHODIMP_(void) CollectGarbage() ;
	STDMETHODIMP ReleaseObjectByUnknown(IUnknown *pObject) ;
	STDMETHODIMP GetDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														LPDMUS_OBJECTDESC pDesc,
														REFIID riid,
														LPVOID FAR *ppv) ;
	STDMETHODIMP ReportDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														   IUnknown *pReferencedObject);
#ifdef XBOX
    STDMETHODIMP LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            const char *pszFilePath, 
                                            void ** ppObject) ;
#else
    STDMETHODIMP LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            WCHAR *pwzFilePath, 
                                            void ** ppObject) ;
#endif
    virtual ULONG STDMETHODCALLTYPE AddRefP();			// Private AddRef, for streams and scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP();			// Private Release, for streams and scripts.

	// IDirectMusicIMA
	STDMETHODIMP LegacyCaching( BOOL fEnable) ;

	CLoader();
	~CLoader();
	HRESULT				Init();
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	void				GC_UpdateForReleasedObject(CObject *pObject); // Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
	BOOL				m_fIMA;				// Support IMA parsing of ini files, etc.
	BOOL				m_fKeepObjects;		// Hang on to objects after loading them.

	friend void GC_Report(CLoader *);

private:
	HRESULT				LoadCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				SaveCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate);
	HRESULT 			ClearCacheInternal(REFGUID rguidClass, bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT             FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject,IDirectMusicObject *pIDMObject);
	HRESULT				FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject);

	void				GC_Mark(CObject *pObject);
	bool				GC_HasCycle(CObject *pObject);
	// Recursive function used to implement GC_Mark and GC_HasCycle
	bool				GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark);

	CClassList			m_ClassList;		// Each type has its own list.
	WCHAR				m_wzPath[DMUS_MAX_FILENAME];	// Search directory.
	BOOL				m_fPathValid;		// Search dir is valid.
	long				m_cRef;
	long				m_cPRef;			// Private reference count.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage lists.
    BOOL                m_fCSInitialized;

	CObject *			m_pApplicationObject; // Object used to track references to objects in use by the application.
	CObject *			m_pLoadedObjectContext; // Used to determine which object called GetObject.  Initially m_pApplicationContext, but set and restored as a cascade of GetObject calls occurs between components.
	CObjectList			m_ReleasedObjectList; // Holds objects that are released, but may still be referenced by other objects.

	// Debug-only functions used by GetObject to report load failures.
	// Frequently some file will fail to load because it depends on some other file
	// that is missing and this will print out trace statements helping the user
	// understand what's missing.
#ifndef XBOX
#ifdef DBG
	void DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad);
	static void DebugTraceObject(DMUS_OBJECTDESC *pDesc);
	SmartRef::Vector<DMUS_OBJECTDESC> m_vecdescDebugTraceLoadFailure; // accumulates the failed sub-items
#endif
#endif // XBOX
    BOOL                m_fFirstLoadTry;    // For LoadObjectFromFile(). Disables warning on first try.
};

class CFileStream : public IStream, public IDirectMusicGetLoader, public CMemTrack
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CFileStream();
						~CFileStream();
	HRESULT Open( WCHAR *lpFileName, DWORD dwDesiredAccess );
    void    Init( CLoader *pLoader );
	HRESULT	Close();

private:
    LONG            m_cRef;         // object reference count
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME]; // Save name for cloning.
#if defined(UNDER_CE) || defined(XBOX)
    HANDLE          m_hFile;
#else
	FILE*			m_pFile;		// file pointer
#endif
	CLoader *		m_pLoader;
};

class CMemStream : public IStream, public IDirectMusicGetLoader, public CMemTrack
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CMemStream( );
						~CMemStream();
    void                Init( CLoader *pLoader) ;
	HRESULT				Open( BYTE *pbData, LONGLONG llLength );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
	BYTE*			m_pbData;		// memory pointer
	LONGLONG		m_llLength;
	LONGLONG		m_llPosition;	// Current file position.
	CLoader *		m_pLoader;
};


class CStream : public IStream, public IDirectMusicGetLoader, public CMemTrack
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CStream();
						~CStream();
    void                Init( CLoader *pLoader );
	HRESULT				Open(IStream *pIStream,LARGE_INTEGER liStartPosition);
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    IStream *       m_pIStream;
	CLoader *		m_pLoader;
};

// Class factory
// 
class CLoaderFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CLoaderFactory();

	// Destructor
	~CLoaderFactory(); 

private:
	long m_cRef;
};

class CContainerFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CContainerFactory();

	// Destructor
	~CContainerFactory(); 

private:
	long m_cRef;
};

#endif //__CDMLOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\activescript.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CActiveScriptManager.
//

// CActiveScriptManager handles interfacing with VBScript or any activeX scripting
// language.  It intializes an IActiveScript object, sends it code, and sets and gets
// the values of variables.  Used by CDirectMusicScript.

#pragma once
#include "debug.h"
#include "ole2.h"
#include "activscp.h"
#include "scriptthread.h"
#include "..\shared\dmusicp.h"

// forward declaration
class CDirectMusicScript;

// little helper class to cache routine and variable names for EnumItem
class ScriptNames
{
public:
	ScriptNames() : m_prgbstr(NULL) {}
	~ScriptNames() { Clear(); }
	HRESULT Init(bool fUseOleAut, DWORD cNames);
	operator bool() { return !!m_prgbstr; }
	DWORD size() { return m_dwSize; }
	void Clear();
	BSTR &operator[](DWORD dwIndex) { assert(m_prgbstr && dwIndex < m_dwSize); return m_prgbstr[dwIndex]; }

private:
	bool m_fUseOleAut;
	DWORD m_dwSize;
	BSTR *m_prgbstr;
};

#ifdef XBOX
#define ASYNCH_SCRIPTTRACK
#endif

class CActiveScriptManager
  : public IActiveScriptSite,
	public ScriptManager
{
public:
	CActiveScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT ScriptTrackCallRoutine(
				const WCHAR *pwszRoutineName,
				IDirectMusicSegmentState *pSegSt,
				DWORD dwVirtualTrackID,
				bool fErrorPMsgsEnabled,
				__int64 i64IntendedStartTime,
				DWORD dwIntendedStartTimeFlags);
	HRESULT ScriptTrackCallRoutineImp(
				const WCHAR *pwszRoutineName,
				IDirectMusicSegmentState *pSegSt,
				DWORD dwVirtualTrackID,
				bool fErrorPMsgsEnabled,
				__int64 i64IntendedStartTime,
				DWORD dwIntendedStartTimeFlags);
	HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems);
	HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId);
	HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);
	void Close(); // Releases all references in preparation for shutdown

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IActiveScriptSite
	STDMETHOD(GetLCID)(/* [out] */ LCID __RPC_FAR *plcid);
	STDMETHOD(GetItemInfo)(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwReturnMask,
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
		/* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);
	STDMETHOD(GetDocVersionString)(/* [out] */ BSTR __RPC_FAR *pbstrVersion);
	STDMETHOD(OnScriptTerminate)(
		/* [in] */ const VARIANT __RPC_FAR *pvarResult,
		/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);
	STDMETHOD(OnStateChange)(/* [in] */ SCRIPTSTATE ssScriptState);
	STDMETHOD(OnScriptError)(/* [in] */ IActiveScriptError __RPC_FAR *pscripterror);
	STDMETHOD(OnEnterScript)();
	STDMETHOD(OnLeaveScript)();

	// Retrieve context for the currently running script.
	// Some automation model functions need access to the context from which the
	//    currently running routine was called.  For example, they may need to operate
	//    on the implied global performance.
	// Be sure to addref the returned pointer if holding onto it.
	static IDirectMusicPerformance8 *GetCurrentPerformanceNoAssertWEAK();
	static IDirectMusicPerformance8 *GetCurrentPerformanceWEAK() { IDirectMusicPerformance8 *pPerf = CActiveScriptManager::GetCurrentPerformanceNoAssertWEAK(); if (!pPerf) {assert(false);} return pPerf; }
	static IDirectMusicObject *GetCurrentScriptObjectWEAK();
	static IDirectMusicComposer8 *GetComposerWEAK();
	static void GetCurrentTimingContext(__int64 *pi64IntendedStartTime, DWORD *pdwIntendedStartTimeFlags);

private:
	// Functions
	HRESULT GetIDOfName(const WCHAR *pwszName, DISPID *pdispid); // returns S_FALSE for unknown name
	void ClearErrorInfo();
	void SetErrorInfo(ULONG ulLineNumber, LONG ichCharPosition, BSTR bstrSourceLine, const EXCEPINFO &excepinfo);
	void ContributeErrorInfo(const WCHAR *pwszActivity, const WCHAR *pwszSubject, const EXCEPINFO &excepinfo);
	HRESULT ReturnErrorInfo(HRESULT hr, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	static CActiveScriptManager *GetCurrentContext();
	static HRESULT SetCurrentContext(CActiveScriptManager *pActiveScriptManager, CActiveScriptManager **ppActiveScriptManagerPrevious); // remember to restore the previous pointer after the call
	HRESULT EnsureEnumItemsCached(bool fRoutine);

	// Data
	long m_cRef;

	// Pointer back to the containing script object
	CDirectMusicScript *m_pParentScript;

	// Active Scripting
	bool m_fUseOleAut;
	IActiveScript *m_pActiveScript;
	IDispatch *m_pDispatchScript;

	// Errors (managed via ClearErrorInfo, SetErrorInfo, and ContributeErrorInfo)
	bool m_fError;
	HRESULT m_hrError;
	ULONG m_ulErrorLineNumber;
	LONG m_ichErrorCharPosition;
	BSTR m_bstrErrorSourceComponent;
	BSTR m_bstrErrorDescription;
	BSTR m_bstrErrorSourceLineText;
	BSTR m_bstrHelpFile;

	// Context
	struct ThreadContextPair
	{
		DWORD dwThreadId;
		CActiveScriptManager *pActiveScriptManager;
	};
	static SmartRef::Vector<ThreadContextPair> ms_svecContext;

	// Timing context for a routine call from a script track.  (Sets the play/stop time of segments, songs, and playingsegments
	// to the time of the routine in the script track.)
	__int64 m_i64IntendedStartTime;
	DWORD m_dwIntendedStartTimeFlags;

	// cached names from enum methods
	ScriptNames m_snamesRoutines;
	ScriptNames m_snamesVariables;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\authelper.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper utilities for implementing automation interfaces.
// Note that autbaseimp.h makes use of these utilities.  If you inherit from
//    CAutBaseImp then this is all implementated for you and you probably won't
//    need to use this file directly.
//

#pragma once

#include <limits>

//////////////////////////////////////////////////////////////////////
// Aggregation controlling unknown

// Class that implements the controlling unknown for aggregation.
// The interface should be returned only from CoCreate.
// This object will keep the reference count and call Destroy on its parent when 0.
//    The parent should then delete the CAutUnknown and itself.
// QI only returns IUnknown and IDispatch from the parent object.
class CAutUnknown : public IUnknown
{
public:
	// Virtual base class.  Inherit from CAutUnknown::CAutUnknownParent if you want to use an object with CAutUnknown.
	class CAutUnknownParent
	{
	public:
		virtual void Destroy() = 0;
	};

	CAutUnknown();
	// Call Init immediately.  The parent passes pointers to itself for both params.
	// I didn't put this on the constructor because VC warns about using 'this' in
	//    a member initializer list.
	void Init(CAutUnknownParent *pParent, IDispatch *pDispatch);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

private:
	// Data
	long m_cRef;
	CAutUnknownParent *m_pParent;
	IDispatch *m_pDispatch;
};

//////////////////////////////////////////////////////////////////////
// IDispatch implemented from type table

// Max params to any method -- increase this as needed
const int g_cDispatchMaxParams = 5;

// Parameters

enum AutDispatchType { ADT_None, ADT_Long, ADT_Interface, ADT_Bstr };

struct AutDispatchParam
{
	AutDispatchType adt;
	bool fOptional; // not relevant for return parameters
	const IID *piid; // only relevant if ADT_INTERFACE: specifies the IID of the desired interface (ignored for return parameters)
};

#define ADPARAM_NORETURN ADT_None, false, &IID_NULL

// Methods

struct AutDispatchMethod
{
	DISPID dispid;
	const WCHAR *pwszName;
	AutDispatchParam adpReturn;
	AutDispatchParam rgadpParams[g_cDispatchMaxParams]; // terminate with ADT_NONE for last param
};
// terminate an array of methods with dispid DISPID_UNKNOWN

// Decoded parameters -- read (write for return) void * as pointer to type specified in methods

union AutDispatchDecodedParam
{
	LONG lVal;		// ADT_Long
	void *iVal;		// ADT_Interface (cast to the interface specified by piid)
	BSTR bstrVal;	// ADT_Bstr
};

struct AutDispatchDecodedParams
{
	void *pvReturn; // set to NULL by AutDispatchInvokeDecode if no return specified or no return requested by caller, otherwise set to location to write return
	AutDispatchDecodedParam params[g_cDispatchMaxParams];
};

// Helper functions

HRESULT AutDispatchGetIDsOfNames(
			const AutDispatchMethod *pMethods,
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId);

HRESULT AutDispatchInvokeDecode(
			const AutDispatchMethod *pMethods,
			AutDispatchDecodedParams *pDecodedParams,
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			UINT __RPC_FAR *puArgErr,
			const WCHAR *pwszTraceTargetType,
			IUnknown *punkTraceTargetObject);

void AutDispatchInvokeFree(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid);

HRESULT AutDispatchHrToException(
		const AutDispatchMethod *pMethods,
		DISPID dispIdMember,
		REFIID riid,
		HRESULT hr,
		EXCEPINFO __RPC_FAR *pExcepInfo);

// Implementation of IDispatch for the standard Load method on objects.
// Dummy implementation--does nothing.

// Assign Load a dispid that probably won't conflict with the wrapped object's methods.
// Probably it doesn't matter if two methods have the same dispid, but theoretically some scripting engine could
// be weirded out by that and hide a method with the same dispid that is exposed after the real object is loaded.
const DISPID g_dispidLoad = 10000000;

// Return S_OK and the dispid if this is a call to load.
HRESULT AutLoadDispatchGetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);

// Returns S_OK if this is a call to load.
HRESULT AutLoadDispatchInvoke(
		bool *pfUseOleAut,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

//////////////////////////////////////////////////////////////////////
// Miscellaneous little things

inline LONG ClipLongRange(LONG lVal, LONG lMin, LONG lMax) { return lVal < lMin
																? lMin
																: (lVal > lMax ? lMax : lVal); }

const UINT g_uiRefTimePerMillisecond = 10000;

// Conversion between tempo normally represented in floating point and integers used by
// scripts that may not handle floating point numbers.

// 100 corresponds to 1 (no change), 1 corresponds to .01 (1/100th as fast), 10000 corresponds to 100 (100X as fast)
const float g_fltTempoScale = 100.0;

inline float
ConvertToTempo(LONG lTempo)
{
	return lTempo / g_fltTempoScale;
}

inline LONG
ConvertFromTempo(double dblTempo)
{
	LONG lTempo = static_cast<LONG>(dblTempo * g_fltTempoScale + .5);
	return lTempo ? lTempo : 1;
}

// Returns a proper VB boolean value (0 for false, -1 for true)
inline LONG
BoolForVB(bool f) { return f ? VARIANT_TRUE : VARIANT_FALSE; }

// Convert from one set of flags into another
struct FlagMapEntry
{
	LONG lSrc;
	DWORD dwDest;
};
DWORD MapFlags(LONG lFlags, const FlagMapEntry *pfm);

HRESULT SendVolumePMsg(LONG lVolume, LONG lDuration, DWORD dwPChannel, IDirectMusicGraph *pGraph, IDirectMusicPerformance *pPerf, short *pnNewVolume);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsegment.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSegment.
// IDispatch interface for IDirectMusicSegment.
// Unly usable via aggregation within an IDirectMusicSegment object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSegment;
typedef CAutBaseImp<CAutDirectMusicSegment, IDirectMusicSegment8, &IID_IDirectMusicSegment8> BaseImpSegment;

class CAutDirectMusicSegment
  : public BaseImpSegment
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSegment(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	//  Methods that rely on an implied performance need testing in multithreaded situations
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Play(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);
	HRESULT DownloadSoundData(AutDispatchDecodedParams *paddp) { return DownloadOrUnload(true, paddp); }
	HRESULT UnloadSoundData(AutDispatchDecodedParams *paddp) { return DownloadOrUnload(false, paddp); }
	HRESULT Recompose(AutDispatchDecodedParams *paddp);

	// Helpers
	HRESULT DownloadOrUnload(bool fDownload, AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSegment> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autperformance.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicPerformance.
// IDispatch interface for IDirectMusicPerformance.
// Unly usable via aggregation within an IDirectMusicPerformance object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicPerformance;
typedef CAutBaseImp<CAutDirectMusicPerformance, IDirectMusicPerformance, &IID_IDirectMusicPerformance> BaseImpPerf;

class CAutDirectMusicPerformance
  : public BaseImpPerf
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicPerformance(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT SetMasterTempo(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterTempo(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterVolume(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterVolume(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterGrooveLevel(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterGrooveLevel(AutDispatchDecodedParams *paddp);
	HRESULT SetMasterTranspose(AutDispatchDecodedParams *paddp);
	HRESULT GetMasterTranspose(AutDispatchDecodedParams *paddp);
	HRESULT _Trace(AutDispatchDecodedParams *paddp);
	HRESULT Rand(AutDispatchDecodedParams *paddp);

	// Helpers
	HRESULT GetMasterParam(const GUID &guid, void *pParam, DWORD dwSize); // Calls GetGlobalParam, but returns S_OK if the param hasn't been set previously.

	// data
	SmartRef::ComPtr<IDirectMusicGraph> m_scomGraph;
	short m_nTranspose;
	short m_nVolume;
	long m_lRand;

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicPerformance> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsegmentstate.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSegmentState.
//

/*#include "stdinc.h"
#include "autsegmentstate.h"
#include "activescript.h"
#include "autconstants.h"
#include <limits>*/

#include "pchscript.h"

const WCHAR CAutDirectMusicSegmentState::ms_wszClassName[] = L"SegmentState";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_IsPlaying = 1;
const DISPID DMPDISP_Stop = 2;

const AutDispatchMethod CAutDirectMusicSegmentState::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_IsPlaying,					L"IsPlaying",
						ADT_Long,		true,	&IID_NULL,						// returns true if playing
						ADT_None },
		{ DMPDISP_Stop,							L"Stop",
						ADPARAM_NORETURN,
						ADT_Long,		true,	&IID_NULL,						// flags
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicSegmentState> CAutDirectMusicSegmentState::ms_Handlers[] =
	{
		{ DMPDISP_IsPlaying, IsPlaying },
		{ DMPDISP_Stop, Stop },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSegmentState::CAutDirectMusicSegmentState(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpSegSt(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicSegmentState::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicSegmentState *pInst = new CAutDirectMusicSegmentState(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation

HRESULT
CAutDirectMusicSegmentState::IsPlaying(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	IDirectMusicPerformance *pPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();
	HRESULT hr = pPerf->IsPlaying(NULL, m_pITarget);
	*plRet = ::BoolForVB(hr == S_OK);
	return hr;
}

const FlagMapEntry gc_flagmapStop[] =
	{
		{ ScriptConstants::AtGrid,			DMUS_SEGF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_SEGF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_SEGF_MEASURE },
		{ ScriptConstants::AtImmediate,		DMUS_SEGF_DEFAULT }, // this flag gets flipped later
		{ 0 }
	};

HRESULT
CAutDirectMusicSegmentState::Stop(AutDispatchDecodedParams *paddp)
{
	LONG lFlags = paddp->params[0].lVal;
	DWORD dwFlags = MapFlags(lFlags, gc_flagmapStop);
		// Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
		//dwFlags ^= DMUS_SEGF_DEFAULT;

        //If we're "borrowing" the default flag to signify "immediate" then we'll assume other SEGF transition flags aren't specified and simply
        //  turn off this bug.
        //  If other transition flags ARE specified then they'll override "immediate".
        if (dwFlags & DMUS_SEGF_DEFAULT)
        {
    		dwFlags ^= DMUS_SEGF_DEFAULT;
        }

        //If we're NOT borrowing the default flag to signify "immediate", it may or may not be necessary to add.  It will only be necessary if
        //  no other transition flags were specified.
        else
        {
            if (!(dwFlags & (DMUS_SEGF_SEGMENTEND | DMUS_SEGF_GRID | DMUS_SEGF_BEAT | DMUS_SEGF_MEASURE | DMUS_SEGF_MARKER | DMUS_SEGF_ALIGN)))
            {
	            dwFlags |= DMUS_SEGF_DEFAULT;
            }
        }


	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);
#ifdef DXAPI
	HRESULT hr = pPerformance->Stop(NULL, m_pITarget, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
#else
    HRESULT hr = pPerformance->StopEx( m_pITarget, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\stream.cpp ===
//	stream.cpp
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL

/*#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" // Using specific path for now, since the headers are changing.
#include "dmusicip.h" // Using specific path for now, since the headers are changing.
#include "loader.h"
#include <initguid.h>
#include "riff.h"

#if !defined(XBOX) && !defined(UNDER_CE)

#include <regstr.h>
#include <share.h>

extern BOOL g_fIsUnicode;*/

#include "pchloader.h"

#if !defined(XBOX) && !defined(UNDER_CE)

CFileStream::CFileStream( ) : CMemTrack(DMTRACK_FILE_STREAM)

{
	m_cRef = 0;
	m_pFile = NULL;
	m_pLoader = NULL;
}

HRESULT CFileStream::Open(WCHAR * lpFileName,DWORD dwDesiredAccess)

{
	Close();
    wcscpy(m_wszFileName,lpFileName);
	assert(dwDesiredAccess == GENERIC_READ || dwDesiredAccess == GENERIC_WRITE);
    if( dwDesiredAccess == GENERIC_READ )
    {
		if (g_fIsUnicode)
		{
			m_pFile = _wfsopen( lpFileName, L"rb", _SH_DENYWR );
		}
		else
		{
			char path[MAX_PATH];
			wcstombs( path, lpFileName, MAX_PATH );
			m_pFile = _fsopen( path, "rb", _SH_DENYWR );
		}
	}
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
		if (g_fIsUnicode)
		{
			m_pFile = _wfsopen( lpFileName, L"wb", _SH_DENYNO );
		}
		else
		{
			char path[MAX_PATH];
			wcstombs( path, lpFileName, MAX_PATH );
			m_pFile = _fsopen( path, "wb", _SH_DENYNO );
		}   
	}
	if (m_pFile == NULL)
	{
		Trace(1, "Warning: The file %S couldn't be opened: %s. Try another path.\n", lpFileName, _strerror(NULL));
		return DMUS_E_LOADER_FAILEDOPEN;
	}
	return S_OK;
}

HRESULT CFileStream::Close()

{
	if (m_pFile)
	{
		fclose(m_pFile);
	}
	m_pFile = NULL;
	return S_OK;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
	size_t dw;
	dw = fread( pv, sizeof(char), cb, m_pFile );
	if( cb == dw )
	{
		if( pcbRead != NULL )
		{
			*pcbRead = cb;
		}
		return S_OK;
	}
	return E_FAIL ;
}

STDMETHODIMP CFileStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
	if( cb == fwrite( pv, sizeof(char), cb, m_pFile ))
	{
		if( pcbWritten != NULL )
		{
			*pcbWritten = cb;
		}
		return S_OK;
	}
	Trace(1, "Error: An error occurred writing to %S.", m_wszFileName);
    return STG_E_MEDIUMFULL;
}

STDMETHODIMP CFileStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
	// fseek can't handle a LARGE_INTEGER seek...
	long lOffset;

	lOffset = dlibMove.LowPart;

	int i = fseek( m_pFile, lOffset, dwOrigin );
	if( i ) 
	{
		Trace(1, "Error: An error occurred while seeking in the file %S.\n", m_wszFileName);
		return E_FAIL;
	}

	if( plibNewPosition != NULL )
	{
		plibNewPosition->QuadPart = ftell( m_pFile );
	}
    return S_OK;
}

#else

CFileStream::CFileStream( ): CMemTrack(DMTRACK_FILE_STREAM)

{
	m_cRef = 0;
	m_hFile = NULL;
	m_pLoader = NULL;
}

HRESULT CFileStream::Open(WCHAR * lpFileName, DWORD dwDesiredAccess)
{
	Close();
    wcscpy(m_wszFileName,lpFileName);
#ifdef XBOX
	char path[MAX_PATH];
	wcstombs( path, lpFileName, MAX_PATH );
	m_hFile = CreateFile(path, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#else
	m_hFile = CreateFile(lpFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif
	if(m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE)
	{
#ifndef XBOX
#ifdef DBG
		LPVOID lpMsgBuf;
		if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
							NULL,
							GetLastError(),
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPTSTR) &lpMsgBuf,
							0,
							NULL))
		{
			Trace(1, "Error: The file %S couldn't be opened: %S\n", lpFileName, lpMsgBuf);
			LocalFree( lpMsgBuf );
		}
#endif
#endif // XBOX
		return DMUS_E_LOADER_FAILEDOPEN;
	}
	return S_OK;
}

HRESULT CFileStream::Close()
{
	if(m_hFile)
	{
		CloseHandle(m_hFile);
	}
	m_hFile = NULL;
	return S_OK;
}

/* IStream methods */
STDMETHODIMP CFileStream::Read(void* pv, ULONG cb, ULONG* pcbRead)
{
	ULONG cbTempRead = 0;
	if (!pcbRead)
	{
		pcbRead = &cbTempRead;
	}
    if(ReadFile(m_hFile, pv, cb, pcbRead, NULL))
    {
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CFileStream::Write(const void* pv, ULONG cb, ULONG* pcbWritten)
{
    if(WriteFile(m_hFile, pv, cb, pcbWritten, NULL))
    {
        return S_OK;
    }
    Trace(1, "Error: An error occurred writing to %S.", m_wszFileName);
    return STG_E_MEDIUMFULL;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)
{
    DWORD dw;

    dw = SetFilePointer(m_hFile,dlibMove.LowPart, &dlibMove.HighPart, dwOrigin);
    if(dw == 0xffffffff && GetLastError() != NO_ERROR)
    {
        Trace(1, "Error: An error occurred while seeking in the file %S.\n", m_wszFileName);
        return E_FAIL;
    }
    if(plibNewPosition != NULL)
    {
        plibNewPosition->LowPart = dw;
        plibNewPosition->HighPart = dlibMove.HighPart;
    }
    return S_OK;
}

#endif

// The following routines are identical for both file system models.

void CFileStream::Init( CLoader *pLoader)

{
	m_pLoader = pLoader;
	if (pLoader)
	{
		pLoader->AddRefP();
	}
}

CFileStream::~CFileStream() 

{ 
	if (m_pLoader)
	{
		m_pLoader->ReleaseP();
	}
	Close();
}

STDMETHODIMP CFileStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
    }
	else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
    }
    else if (riid == IID_CFileStream)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP CFileStream::GetLoader(
	IDirectMusicLoader ** ppLoader)	// @parm Returns an AddRef'd pointer to the loader.
{
	if (m_pLoader)
	{
		return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
	}
	assert(false);
	*ppLoader = NULL;
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }
    return m_cRef;
}


STDMETHODIMP CFileStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Revert()
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CFileStream::Clone(IStream** pStream)
{ 
    HRESULT hr = E_OUTOFMEMORY;
    CFileStream *pNewStream = new CFileStream;
    if (pNewStream)
    {
        pNewStream->Init(m_pLoader);
        hr = pNewStream->Open(m_wszFileName,GENERIC_READ);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER   dlibMove;
            dlibMove.QuadPart = 0;
            ULARGE_INTEGER  libNewPosition;
            Seek( dlibMove, STREAM_SEEK_CUR, &libNewPosition );
            dlibMove.QuadPart = libNewPosition.QuadPart;
            pNewStream->Seek(dlibMove,STREAM_SEEK_SET,NULL);
            hr = pNewStream->QueryInterface(IID_IStream,(void **) pStream);
        }
        else
        {
            delete pNewStream;
        }
    }
	return hr;  
}

/*CMemStream::CMemStream( CLoader *pLoader)

{
	m_cRef = 1;
	m_pbData = NULL;
	m_llLength = 0;
	m_llPosition = 0;
	m_pLoader = pLoader;
	if (pLoader)
	{
		pLoader->AddRefP();
	}
}

CMemStream::CMemStream( CLoader *pLoader,
                       LONGLONG llLength,
                       LONGLONG llPosition,
                       BYTE *pbData)

{
	m_cRef = 1;
	m_pbData = pbData;
	m_llLength = llLength;
	m_llPosition = llPosition;
	m_pLoader = pLoader;
	if (pLoader)
	{
		pLoader->AddRefP();
	}
}*/

CMemStream::CMemStream( ): CMemTrack(DMTRACK_MEM_STREAM)

{
	m_cRef = 0;
	m_pbData = NULL;
	m_llLength = 0;
	m_llPosition = 0;
	m_pLoader = NULL;
}

void CMemStream::Init( CLoader *pLoader)

{
	m_pLoader = pLoader;
	pLoader->AddRefP();
}

CMemStream::~CMemStream() 

{ 
	if (m_pLoader)
	{
		m_pLoader->ReleaseP();
	}
	Close();
}

HRESULT CMemStream::Open(BYTE *pbData, LONGLONG llLength)

{
	Close();
	m_pbData = pbData;
	m_llLength = llLength;
	m_llPosition = 0;
	if ((pbData == NULL) || (llLength == 0))
	{
#ifdef DBG
		if (pbData)
		{
			Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY set but pbMemData is NULL.");
		}
		else
		{
			Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY set but llMemLength is 0.");
		}
#endif
		return DMUS_E_LOADER_FAILEDOPEN;
	}
	if (IsBadReadPtr(pbData, (DWORD) llLength))
	{
		m_pbData = NULL;
		m_llLength = 0;
#ifdef DBG
		DWORD dwLength = (DWORD) llLength;
		Trace(1, "Error: Attempt to load an object from an invalid block of memory. A DMUS_OBJECTDESC has DMUS_OBJ_MEMORY, pbMemData=0x%08x, llMemLength=%lu, which isn't a block that can be read.", pbData, dwLength);
#endif
		return DMUS_E_LOADER_FAILEDOPEN;
	}
	return S_OK;
}

HRESULT CMemStream::Close()

{
	m_pbData = NULL;
	m_llLength = 0;
	return S_OK;
}

STDMETHODIMP CMemStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
    }
	else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
    }
    else if (riid == IID_CMemStream)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP CMemStream::GetLoader(
	IDirectMusicLoader ** ppLoader)	

{
	if (m_pLoader)
	{
		return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
	}
	assert(false);
	*ppLoader = NULL;
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMemStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMemStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CMemStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
	if ((cb + m_llPosition) <= m_llLength)
	{
		memcpy(pv,&m_pbData[m_llPosition],cb);
		m_llPosition += cb;
		if( pcbRead != NULL )
		{
			*pcbRead = cb;
		}
		return S_OK;
	}
#ifdef DBG
	Trace(1, "Error: Unexpected end of data reading object from memory. Memory length is %ld, attempting to read to %ld\n", 
        (long) m_llLength, (long) (cb + m_llPosition));
#endif
	return E_FAIL ;
}

STDMETHODIMP CMemStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMemStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
	// Since we only parse RIFF data, we can't have a file over 
	// DWORD in length, so disregard high part of LARGE_INTEGER.

	LONGLONG llOffset;

	llOffset = dlibMove.QuadPart;
	if (dwOrigin == STREAM_SEEK_CUR)
	{
		llOffset += m_llPosition;
	} 
	else if (dwOrigin == STREAM_SEEK_END)
	{
		llOffset += m_llLength;
	}
	if ((llOffset >= 0) && (llOffset <= m_llLength))
	{
		m_llPosition = llOffset;
	}
	else
	{
#ifdef DBG
		Trace(1, "Error: Seek request %ld past end of memory file, size %ld.\n", 
            (long) llOffset, (long) m_llLength);
#endif
		return E_FAIL;
	}

	if( plibNewPosition != NULL )
	{
		plibNewPosition->QuadPart = m_llPosition;
	}
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize( ULARGE_INTEGER /*libNewSize*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                     ULARGE_INTEGER* /*pcbRead*/,
                     ULARGE_INTEGER* /*pcbWritten*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Commit( DWORD /*grfCommitFlags*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Revert()
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                         DWORD /*dwLockType*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                           DWORD /*dwLockType*/)
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
{ 
	return E_NOTIMPL; 
}

STDMETHODIMP CMemStream::Clone( IStream** ppStream )
{ 
    CMemStream *pClone = new CMemStream;
    if (pClone)
    {
        pClone->m_llLength = m_llLength;
        pClone->m_llPosition = m_llPosition;
        pClone->m_pbData = m_pbData;
        pClone->Init(m_pLoader);
        return pClone->QueryInterface(IID_IStream,(void **) ppStream);
    }
	return E_OUTOFMEMORY; 
}

STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff )
{
    if( ( *ppRiff = (IRIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
			Trace(1, "Error: Read error - unable to seek in a stream.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			ULONG cbRead;

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CRIFFStream::Ascend

STDMETHODIMP CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
			Trace(1, "Error: Read error - unable to seek in a stream.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
			Trace(1, "Error: Unable to write to a stream.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
				Trace(1, "Error: Unable to write to a stream.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
			Trace(1, "Error: Read error - unable to seek in a stream.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
			Trace(1, "Error: Unable to write to a stream.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
		Trace(1, "Error: Read error - unable to seek in a stream.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CRIFFStream::CreateChunk

STDMETHODIMP CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
		Trace(1, "Error: Read error - unable to seek in a stream.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
		Trace(1, "Error: Unable to write to a stream.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}


void CStream::Init( CLoader *pLoader )

{
	m_pLoader = pLoader;
	if (pLoader)
	{
		pLoader->AddRefP();
	}
}

CStream::CStream() : CMemTrack(DMTRACK_STREAM_STREAM)

{
    m_pIStream = NULL;
	m_cRef = 0;
}

CStream::~CStream() 

{ 
	if (m_pLoader)
	{
		m_pLoader->ReleaseP();
	}
	Close();
}

HRESULT CStream::Open(IStream *pIStream,LARGE_INTEGER liStartPosition)

{
    Close();
           
    m_pIStream = pIStream;

    if (m_pIStream)
    {
        // Need to seek to point that was where we were in the stream
        // when the stream was first provided via GetObject or SetObject.
        pIStream->Seek(liStartPosition,STREAM_SEEK_SET,NULL);
        pIStream->AddRef();
    }

	return S_OK;
}

HRESULT CStream::Close()

{
    if (m_pIStream)
    {
        m_pIStream->Release();
    }
    m_pIStream = NULL;

	return S_OK;
}

STDMETHODIMP CStream::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IStream) 
    {
        *ppvObj = static_cast<IStream*>(this);
    }
	else if (riid == IID_IDirectMusicGetLoader) 
    {
        *ppvObj = static_cast<IDirectMusicGetLoader*>(this);
    }
    else if (riid == IID_CStream)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP CStream::GetLoader(
	IDirectMusicLoader ** ppLoader)	

{
	if (m_pLoader)
	{
		return m_pLoader->QueryInterface( IID_IDirectMusicLoader,(void **) ppLoader );
	}
	assert(false);
	*ppLoader = NULL;
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CStream::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
	{
        Close();
		delete this;
		return 0;
    }
    return m_cRef;
}

/* IStream methods */
STDMETHODIMP CStream::Read( void* pv, ULONG cb, ULONG* pcbRead )
{
    if (m_pIStream)
    {
        return m_pIStream->Read(pv, cb, pcbRead);
    }
    Trace(1, "Error: Attempt to read from a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::Write( const void* pv, ULONG cb, ULONG* pcbWritten )
{
    if (m_pIStream)
    {
        return m_pIStream->Write(pv, cb, pcbWritten);
    }
    Trace(1, "Error: Attempt to write to a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    if (m_pIStream)
    {
        return m_pIStream->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    Trace(1, "Error: Read error - attempt to seek in a NULL stream.\n");
    return E_FAIL;
}

STDMETHODIMP CStream::SetSize( ULARGE_INTEGER libNewSize)
{ 
    if (m_pIStream)
    {
        return m_pIStream->SetSize(libNewSize);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::CopyTo( IStream* pstm, ULARGE_INTEGER cb,
                     ULARGE_INTEGER* pcbRead,
                     ULARGE_INTEGER* pcbWritten)
{ 
    if (m_pIStream)
    {
        return m_pIStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::Commit( DWORD grfCommitFlags)
{ 
    if (m_pIStream)
    {
        return m_pIStream->Commit(grfCommitFlags);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::Revert()
{ 
    if (m_pIStream)
    {
        return m_pIStream->Revert();
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                         DWORD dwLockType)
{ 
    if (m_pIStream)
    {
        return m_pIStream->LockRegion(libOffset, cb, dwLockType);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::UnlockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                           DWORD dwLockType)
{ 
    if (m_pIStream)
    {
        return m_pIStream->UnlockRegion(libOffset, cb, dwLockType);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::Stat( STATSTG* pstatstg, DWORD grfStatFlag)
{ 
    if (m_pIStream)
    {
        return m_pIStream->Stat(pstatstg, grfStatFlag);
    }
	return E_FAIL; 
}

STDMETHODIMP CStream::Clone( IStream** ppStream)
{ 
    HRESULT hr = E_FAIL;
    if (m_pIStream)
    {
        IStream *pNewIStream = NULL;
        hr = m_pIStream->Clone(&pNewIStream);
        if (SUCCEEDED(hr))
        {
            CStream *pNewCStream = new CStream;
            if (pNewCStream)
            {
                pNewCStream->Init( m_pLoader );
                pNewCStream->m_pIStream = pNewIStream;
                return pNewCStream->QueryInterface(IID_IStream,(void **) ppStream);
            }
            hr = E_OUTOFMEMORY;
            pNewIStream->Release();
        }
    }
	else
	{
		Trace(1, "Error: Attempt to clone a NULL stream.\n");
	}
	return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsegmentstate.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSegmentState.
// IDispatch interface for IDirectMusicSegmentState.
// Unly usable via aggregation within an IDirectMusicSegmentState object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSegmentState;
typedef CAutBaseImp<CAutDirectMusicSegmentState, IDirectMusicSegmentState, &IID_IDirectMusicSegmentState> BaseImpSegSt;

class CAutDirectMusicSegmentState
  : public BaseImpSegSt
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSegmentState(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT IsPlaying(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSegmentState> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsong.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSong.
//

/*#include "stdinc.h"
#include "autsong.h"
#include "activescript.h"*/

#include "pchscript.h"

const WCHAR CAutDirectMusicSong::ms_wszClassName[] = L"Song";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Recompose = 2;
const DISPID DMPDISP_Play = 3;
const DISPID DMPDISP_GetSegment = 4;
const DISPID DMPDISP_Stop = 5;
const DISPID DMPDISP_DownloadSoundData = 6;
const DISPID DMPDISP_UnloadSoundData = 7;

const AutDispatchMethod CAutDirectMusicSong::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_Load,							L"Load",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Recompose,					L"Recompose",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Play,							L"Play",
						ADT_Interface,	true,	&IID_IUnknown,					// returned segment state
						ADT_Bstr,		true,	&IID_NULL,						// name of segment to play
						ADT_None },
		{ DMPDISP_GetSegment,					L"GetSegment",
						ADT_Interface,	true,	&IID_IUnknown,					// returned segment
						ADT_Bstr,		true,	&IID_NULL,						// name of segment to retrieve
						ADT_None },
		{ DMPDISP_Stop,							L"Stop",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_DownloadSoundData,			L"DownloadSoundData",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_UnloadSoundData,				L"UnloadSoundData",
						ADPARAM_NORETURN,
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicSong> CAutDirectMusicSong::ms_Handlers[] =
	{
		{ DMPDISP_Load, Load },
		{ DMPDISP_Recompose, Recompose },
		{ DMPDISP_Play, Play },
		{ DMPDISP_GetSegment, GetSegment },
		{ DMPDISP_Stop, Stop },
		{ DMPDISP_DownloadSoundData, DownloadSoundData },
		{ DMPDISP_UnloadSoundData, UnloadSoundData },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSong::CAutDirectMusicSong(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpSong(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT
CAutDirectMusicSong::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicSong *pInst = new CAutDirectMusicSong(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicSong::Load(AutDispatchDecodedParams *paddp)
{
	// Loading is actually implemented generically by container items.
	// If we're here, we're already loaded and don't need to do anything.
	return S_OK;
}

HRESULT
CAutDirectMusicSong::Recompose(AutDispatchDecodedParams *paddp)
{
	return m_pITarget->Compose();
}

HRESULT
CAutDirectMusicSong::Play(AutDispatchDecodedParams *paddp)
{
	IDirectMusicSegmentState **ppSegSt = reinterpret_cast<IDirectMusicSegmentState **>(paddp->pvReturn);
#ifndef XBOX
	BSTR bstrSegName = paddp->params[0].bstrVal;
#endif
	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

	hr = pPerformance->PlaySegmentEx(
							m_pITarget,
#ifdef XBOX
                            NULL,
#else
							bstrSegName,
#endif
							NULL,
							DMUS_SEGF_DEFAULT | DMUS_SEGF_AUTOTRANSITION | dwIntendedStartTimeFlags,
							i64IntendedStartTime,
							ppSegSt,
							NULL,
							NULL);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CAutDirectMusicSong::GetSegment(AutDispatchDecodedParams *paddp)
{
	IDirectMusicSegment **ppSeg = reinterpret_cast<IDirectMusicSegment **>(paddp->pvReturn);
	BSTR bstrSegName = paddp->params[0].bstrVal;

	HRESULT hr = S_OK;
	hr = m_pITarget->GetSegment(bstrSegName, ppSeg);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CAutDirectMusicSong::Stop(AutDispatchDecodedParams *paddp)
{
	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();

	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

	hr = pPerformance->StopEx(m_pITarget, i64IntendedStartTime, DMUS_SEGF_DEFAULT | dwIntendedStartTimeFlags);
	return hr;
}

HRESULT
CAutDirectMusicSong::DownloadSoundData(AutDispatchDecodedParams *paddp)
{
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	return m_pITarget->Download(pPerformance);
}

HRESULT
CAutDirectMusicSong::UnloadSoundData(AutDispatchDecodedParams *paddp)
{
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	return m_pITarget->Unload(pPerformance);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsong.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAutDirectMusicSong.
// IDispatch interface for IDirectMusicSong.
// Unly usable via aggregation within an IDirectMusicSong object.
//

#pragma once
#include "autbaseimp.h"

class CAutDirectMusicSong;
typedef CAutBaseImp<CAutDirectMusicSong, IDirectMusicSong, &IID_IDirectMusicSong> BaseImpSong;

class CAutDirectMusicSong
  : public BaseImpSong
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

private:
	// Methods
	CAutDirectMusicSong(
			IUnknown* pUnknownOuter,
			const IID& iid,
			void** ppv,
			HRESULT *phr);

	// Automation
	HRESULT Load(AutDispatchDecodedParams *paddp);
	HRESULT Recompose(AutDispatchDecodedParams *paddp);
	HRESULT Play(AutDispatchDecodedParams *paddp);
	HRESULT GetSegment(AutDispatchDecodedParams *paddp);
	HRESULT Stop(AutDispatchDecodedParams *paddp);
	HRESULT DownloadSoundData(AutDispatchDecodedParams *paddp);
	HRESULT UnloadSoundData(AutDispatchDecodedParams *paddp);

public:
	// Dispatch info for CAutBaseImp
	static const AutDispatchMethod ms_Methods[];
	static const DispatchHandlerEntry<CAutDirectMusicSong> ms_Handlers[];

	// Name for CAutBaseImp
	static const WCHAR ms_wszClassName[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\containerdisp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CContainerDispatch.
//

#pragma once

#include "smartref.h"
#include "unkhelp.h"
#include "dmusicp.h"

class CContainerItemDispatch
  : public IDispatch,
	public ComSingleInterface
{
public:
	CContainerItemDispatch(IDirectMusicLoader *pLoader, const WCHAR *wszAlias, const DMUS_OBJECTDESC &desc, bool fPreload, bool fAutodownload, HRESULT *phr);
	~CContainerItemDispatch();
	const WCHAR *Alias() { return m_wstrAlias; }
	IDispatch *Item() { if (m_pDispLoadedItem) return m_pDispLoadedItem; return this; } // returns the contained item when loaded, otherwise itself so Load can be called

	// IUnknown
	ComSingleInterfaceUnknownMethods(IDispatch)

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { return E_NOTIMPL; }
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo) { return E_NOTIMPL; }
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// If it is a segment or song, download it if needed.
	// If it is a script, init it.
	// If it is a song, compose it.
	enum InitWithPerfomanceFailureType { IWP_Success, IWP_DownloadFailed, IWP_ScriptInitFailed };
	HRESULT InitWithPerformance(IDirectMusicPerformance *pPerf, InitWithPerfomanceFailureType *peFailureType);

private:
	void ReleaseLoader();
	HRESULT Load(bool fDynamicLoad);
	HRESULT DownloadOrUnload(bool fDownload, IDirectMusicPerformance *pPerf);

	SmartRef::WString m_wstrAlias;
	IDirectMusicLoader *m_pLoader;		// note: use AddRefP/ReleaseP
	IDirectMusicLoader8P *m_pLoader8P;	// note: use AddRefP/ReleaseP
	DMUS_OBJECTDESC m_desc;

	bool m_fLoaded;
	IDispatch *m_pDispLoadedItem;

	bool m_fAutodownload;
	IDirectMusicPerformance *m_pPerfForUnload;
};

class CContainerDispatch
{
public:
	CContainerDispatch(IDirectMusicContainer *pContainer, IDirectMusicLoader *pLoader, DWORD dwScriptFlags, HRESULT *phr);
	~CContainerDispatch();
	HRESULT OnScriptInit(IDirectMusicPerformance *pPerf); // gives the container a chance to do auto downloading/composing during script initialization

	HRESULT GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	HRESULT Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// For use by the script object
	HRESULT EnumItem(DWORD dwIndex, WCHAR *pwszName);
	HRESULT GetVariableObject(WCHAR *pwszVariableName, IUnknown **ppunkValue);

private:
	SmartRef::Vector<CContainerItemDispatch *> m_vecItems;
	bool m_fDownloadOnInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\dll.h ===
// Copyright (c) 1999 Microsoft Corporation
// dll.h
//
// Class factory
//

#pragma once

void LockModule(bool fLock);
long *GetModuleLockCounter();

typedef HRESULT (PFN_CreateInstance)(IUnknown *pUnkOuter, const IID &iid, void **ppv);

class CDMScriptingFactory : public IClassFactory
{
public:
    // Constructor
    CDMScriptingFactory(PFN_CreateInstance *pfnCreate) : m_cRef(0), m_pfnCreate(pfnCreate) { assert(m_pfnCreate); }

    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock);

private:
    long m_cRef;
	PFN_CreateInstance *m_pfnCreate;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\dll_dmscript.cpp ===
// Allows us to compile the source code in dll.cpp to product an object file dll_dmscript.obj
// (Which avoids an error when linking dmusic.lib.)

#include "pchscript.h"
#include "dll.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\authelper.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper utilities for implementing automation interfaces.
//

/*#include "stdinc.h"
#include "authelper.h"
#include "oleaut.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// CAutUnknown

CAutUnknown::CAutUnknown()
  : m_cRef(0),
	m_pParent(NULL),
	m_pDispatch(NULL)
{
}

void
CAutUnknown::Init(CAutUnknownParent *pParent, IDispatch *pDispatch)
{
	m_pParent = pParent;
	m_pDispatch = pDispatch;

	struct LocalFn
	{
		static HRESULT CheckParams(CAutUnknownParent *pParent, IDispatch *pDispatch)
		{
			V_INAME(CAutUnknown::CAutUnknown);
			V_PTR_READ(pParent, CAutUnknown::CAutUnknownParent);
			V_INTERFACE(pDispatch);
			return S_OK;
		}
	};
	assert(S_OK == LocalFn::CheckParams(m_pParent, m_pDispatch));
}

STDMETHODIMP 
CAutUnknown::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CAutUnknown::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	*ppv = NULL;
	if (iid == IID_IUnknown)
	{
		*ppv = this;
	}
	else if (iid == IID_IDispatch)
	{
		if (!m_pDispatch)
			return E_UNEXPECTED;
		*ppv = m_pDispatch;
	}

	if (*ppv == NULL)
		return E_NOINTERFACE;
	
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CAutUnknown::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAutUnknown::Release()
{
	if (!InterlockedDecrement(&m_cRef) && m_pParent) 
	{
		m_pParent->Destroy();
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDispatch implemented from type table

HRESULT
AutDispatchGetIDsOfNames(
		const AutDispatchMethod *pMethods,
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutDispatchGetIDsOfNames);
	V_PTR_READ(pMethods, AutDispatchMethod); // only 1 -- assume the rest are OK
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	for (c = 0; pMethods[c].dispid != DISPID_UNKNOWN; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], pMethods[c].pwszName))
		{
			rgDispId[0] = pMethods[c].dispid;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

inline HRESULT
ConvertParameter(
		bool fUseOleAut,
		VARIANTARG *pvarActualParam, // pass null if param omitted
		const AutDispatchParam *pExpectedParam,
		AutDispatchDecodedParam *pparam)
{
	HRESULT hr = S_OK;

	if (!pvarActualParam)
	{
		// parameter omitted

		if (!pExpectedParam->fOptional)
			return DISP_E_PARAMNOTOPTIONAL;

		// set to default value
		switch (pExpectedParam->adt)
		{
		case ADT_Long:
			pparam->lVal = 0;
			break;
		case ADT_Interface:
			pparam->iVal = NULL;
			break;
		case ADT_Bstr:
			pparam->bstrVal = NULL;
			break;
		default:
			assert(false);
			return E_FAIL;
		}
	}
	else
	{
		// convert to expected type

		VARIANT varConvert;
		DMS_VariantInit(fUseOleAut, &varConvert);

		VARTYPE vtExpected;
		switch (pExpectedParam->adt)
		{
		case ADT_Long:
			vtExpected = VT_I4;
			break;
		case ADT_Interface:
			vtExpected = VT_UNKNOWN;
			break;
		case ADT_Bstr:
			vtExpected = VT_BSTR;
			break;
		default:
			assert(false);
			return E_FAIL;
		}

		hr = DMS_VariantChangeType(
				fUseOleAut,
				&varConvert,
				pvarActualParam,
				0,
				vtExpected);
		if (FAILED(hr) && !(hr == DISP_E_OVERFLOW || hr == DISP_E_TYPEMISMATCH))
		{
			assert(false); // something weird happened -- according to the OLE specs these are the only two conversion results we should get if we called VariantChangeType properly
			hr = DISP_E_TYPEMISMATCH; // the problem happened during type conversion problem, so call it a type mismatch
		}
		if (SUCCEEDED(hr))
		{
			// set the decoded pointer
			switch (vtExpected)
			{
			case VT_I4:
				pparam->lVal = varConvert.lVal;
				break;
			case VT_UNKNOWN:
				if (varConvert.punkVal)
					hr = varConvert.punkVal->QueryInterface(*pExpectedParam->piid, &pparam->iVal);
				else
					pparam->iVal = 0;
				if (FAILED(hr))
					hr = DISP_E_TYPEMISMATCH;
				break;
			case VT_BSTR:
				pparam->bstrVal = DMS_SysAllocString(fUseOleAut, varConvert.bstrVal);
				break;
			default:
				assert(false);
				return E_FAIL;
			}
		}
		DMS_VariantClear(fUseOleAut, &varConvert); // free possible resources allocated in conversion
	}

	return hr;
}

inline void
FreeParameters(
		bool fUseOleAut,
		const AutDispatchMethod *pMethod,
		AutDispatchDecodedParams *pDecodedParams,
		const AutDispatchParam *pParamStopBefore = NULL)
{
	for (const AutDispatchParam *pParam = pMethod->rgadpParams;
			pParam != pParamStopBefore;
			++pParam)
	{
		switch (pParam->adt)
		{
		case ADT_None:
			return;
		case ADT_Long:
			break;
		case ADT_Interface:
			{
				IUnknown *pUnknown = reinterpret_cast<IUnknown *>(pDecodedParams->params[pParam - pMethod->rgadpParams].iVal);
				SafeRelease(pUnknown);
				pDecodedParams->params[pParam - pMethod->rgadpParams].iVal = NULL;
				break;
			}
		case ADT_Bstr:
			{
				DMS_SysFreeString(fUseOleAut, pDecodedParams->params[pParam - pMethod->rgadpParams].bstrVal);
				pDecodedParams->params[pParam - pMethod->rgadpParams].bstrVal = NULL;
				break;
			}
		default:
			assert(false);
			return;
		}
	}
}

HRESULT
AutDispatchInvokeDecode(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		UINT __RPC_FAR *puArgErr,
		const WCHAR *pwszTraceTargetType,
		IUnknown *punkTraceTargetObject)
{
	V_INAME(AutDispatchInvokeDecode);
	V_PTR_READ(pMethods, AutDispatchMethod); // only 1 -- assume the rest are OK
	V_PTR_WRITE(pDecodedParams, AutDispatchDecodedParams);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_METHOD))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	ZeroMemory(pDecodedParams, sizeof(AutDispatchDecodedParams));

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the method

	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid == DISPID_UNKNOWN)
		return DISP_E_MEMBERNOTFOUND;

#ifdef DBG
	// Build a trace string for the method call
	struct LocalTraceFunc
	{
		static void CatTill(WCHAR *&rpwszWrite, const WCHAR *pwszCopy, const WCHAR *pwszUntil)
		{
			while (*pwszCopy != L'\0' && rpwszWrite < pwszUntil)
			{
				*rpwszWrite++ = *pwszCopy++;
			}
		}
	};

	WCHAR wszBuf[512];
	WCHAR *pwszWrite = wszBuf;
	const WCHAR *pwszUntil = wszBuf + ARRAY_SIZE(wszBuf) - 2; // leave space for CR and \0

	LocalTraceFunc::CatTill(pwszWrite, L"Call to ", pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, pwszTraceTargetType, pwszUntil);

	IDirectMusicObject *pIDMO = NULL;
	HRESULT hrTrace = punkTraceTargetObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pIDMO));
	if (SUCCEEDED(hrTrace))
	{
		DMUS_OBJECTDESC objdesc;
		ZeroMemory(&objdesc, sizeof(objdesc));
        objdesc.dwSize = sizeof(DMUS_OBJECTDESC);
		hrTrace = pIDMO->GetDescriptor(&objdesc);
		pIDMO->Release();
		if (SUCCEEDED(hrTrace) && (objdesc.dwValidData & DMUS_OBJ_NAME))
		{
			LocalTraceFunc::CatTill(pwszWrite, L" \"", pwszUntil);
			LocalTraceFunc::CatTill(pwszWrite, objdesc.wszName, pwszUntil);
			LocalTraceFunc::CatTill(pwszWrite, L"\"", pwszUntil);
		}
	}

	LocalTraceFunc::CatTill(pwszWrite, L" ", pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, pMethodCalled->pwszName, pwszUntil);
	LocalTraceFunc::CatTill(pwszWrite, L"(", pwszUntil);
#endif

	// Count the expected parameters
	UINT cParamMin = 0;
	for (UINT cParamMax = 0;
			pMethodCalled->rgadpParams[cParamMax].adt != ADT_None;
			++cParamMax)
	{
		if (!pMethodCalled->rgadpParams[cParamMax].fOptional)
		{
			cParamMin = cParamMax + 1; // add one because max is currently zero-based
		}
	}

	if (pDispParams->cArgs < cParamMin || pDispParams->cArgs > cParamMax)
		return DISP_E_BADPARAMCOUNT;

	// Verify and prepare each parameter

	HRESULT hr = S_OK;
	for (UINT iParam = 0; iParam < cParamMax; ++iParam)
	{
		const int iParamActual = pDispParams->cArgs - iParam - 1; // dispparams are passed last to first
		const AutDispatchParam *pExpectedParam = &pMethodCalled->rgadpParams[iParam];
		VARIANTARG *pvarActualParam = (iParamActual >= 0)
										? &pDispParams->rgvarg[iParamActual]
										: NULL;
		// VT_ERROR with DISP_E_PARAMNOTFOUND is passed as placeholder for optional params
		if (pvarActualParam && pvarActualParam->vt == VT_ERROR && pvarActualParam->scode == DISP_E_PARAMNOTFOUND)
			pvarActualParam = NULL;

		hr = ConvertParameter(fUseOleAut, pvarActualParam, pExpectedParam, &pDecodedParams->params[iParam]);

		if (FAILED(hr))
		{
			if (puArgErr)
				*puArgErr = iParamActual;
			FreeParameters(fUseOleAut, pMethodCalled, pDecodedParams, pExpectedParam);
			return hr;
		}
	}

	// Prepare the return value

	if (pVarResult)
	{
		switch (pMethodCalled->adpReturn.adt)
		{
		case ADT_None:
			break;

		case ADT_Long:
			pVarResult->vt = VT_I4;
			pVarResult->lVal = 0;
			pDecodedParams->pvReturn = &pVarResult->lVal;
			break;

		case ADT_Interface:
			pVarResult->vt = VT_UNKNOWN;
			pVarResult->punkVal = NULL;
			pDecodedParams->pvReturn = &pVarResult->punkVal;
			break;

		case ADT_Bstr:
			pVarResult->vt = VT_BSTR;
			pVarResult->bstrVal = NULL;
			pDecodedParams->pvReturn = &pVarResult->bstrVal;

		default:
			assert(false);
			return E_FAIL;
		}
	}

#ifdef DBG
	LocalTraceFunc::CatTill(pwszWrite, L")", pwszUntil);
	pwszWrite[0] = L'\n';
	pwszWrite[1] = L'\0';
	DebugTrace(g_ScriptCallTraceLevel, "%S", wszBuf);
#endif

	return S_OK;
}

void
AutDispatchInvokeFree(
		const AutDispatchMethod *pMethods,
		AutDispatchDecodedParams *pDecodedParams,
		DISPID dispIdMember,
		REFIID riid)
{
	bool fUseOleAut = !!(riid == IID_NULL);
	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
	{
		assert(false);
		return;
	}

	// Find the method
	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid != DISPID_UNKNOWN)
	{
		FreeParameters(fUseOleAut, pMethodCalled, pDecodedParams); 
	}
}

HRESULT AutDispatchHrToException(
		const AutDispatchMethod *pMethods,
		DISPID dispIdMember,
		REFIID riid,
		HRESULT hr,
		EXCEPINFO __RPC_FAR *pExcepInfo)
{
	V_INAME(AutDispatchHrToException);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (SUCCEEDED(hr))
		return hr;

	if (!pExcepInfo)
		return DISP_E_EXCEPTION;

	// Find the method
	for (const AutDispatchMethod *pMethodCalled = pMethods;
			pMethodCalled->dispid != DISPID_UNKNOWN && pMethodCalled->dispid != dispIdMember;
			++pMethodCalled)
	{
	}

	if (pMethodCalled->dispid == DISPID_UNKNOWN)
	{
		assert(false);
		return hr;
	}

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(fUseOleAut, L"Microsoft DirectMusic Runtime Error");
	static const WCHAR wszError[] = L"An error occurred in a call to ";
	static const UINT cchError = wcslen(wszError);
	WCHAR *pwszDescription = new WCHAR[cchError + wcslen(pMethodCalled->pwszName) + 1];
	if (!pwszDescription)
	{
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, wszError);
		wcscat(pwszDescription, pMethodCalled->pwszName);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = hr;

	return DISP_E_EXCEPTION;
}

//////////////////////////////////////////////////////////////////////
// Implementation of IDispatch for the standard Load method on objects.

HRESULT AutLoadDispatchGetIDsOfNames(
			REFIID riid,
			LPOLESTR __RPC_FAR *rgszNames,
			UINT cNames,
			LCID lcid,
			DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutLoadDispatchGetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	if (0 == _wcsicmp(rgszNames[0], L"Load"))
		rgDispId[0] = g_dispidLoad;

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT AutLoadDispatchInvoke(
		bool *pfUseOleAut,
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	V_INAME(AutLoadDispatchInvoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);
	if (pfUseOleAut)
		*pfUseOleAut = fUseOleAut;

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_METHOD))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the method

	if (dispIdMember != g_dispidLoad)
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Miscellaneous silly little things

DWORD MapFlags(LONG lFlags, const FlagMapEntry *pfm)
{
	assert(pfm);
	DWORD dw = 0;
	for ( ; pfm->lSrc; ++pfm)
	{
		if (lFlags & pfm->lSrc)
			dw |= pfm->dwDest;
	}
	return dw;
}

BYTE VolumeToMidi(LONG lVolume)
{
	assert(lVolume >= -9600 && lVolume <= 0);
	static LONG s_lDBToMIDI[97] = { 0 };
	if (s_lDBToMIDI[0] == 0)
	{
		s_lDBToMIDI[0] = 127;
		for (int nIndex = 1; nIndex < 97; nIndex++)
		{
			double flTemp = 0.0 - nIndex;
			flTemp /= 10.0;
			flTemp = pow(10,flTemp);
			flTemp = sqrt(flTemp);
			flTemp = sqrt(flTemp);
			flTemp *= 127.0;
			s_lDBToMIDI[nIndex] = (long) flTemp;
		}
	}

	lVolume = -lVolume;
	long lFraction = lVolume % 100;
	lVolume = lVolume / 100;
	long lResult = s_lDBToMIDI[lVolume];
	lResult += ((s_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    if (lResult < 0) lResult = 0;
    if (lResult > 0x7F) lResult = 0x7F;
	return (BYTE) lResult;
}

HRESULT SendVolumePMsg(LONG lVolume, LONG lDuration, DWORD dwPChannel, IDirectMusicGraph *pGraph, IDirectMusicPerformance *pPerf, short *pnNewVolume)
{
	assert(pGraph && pPerf && pnNewVolume);
	lVolume = ClipLongRange(lVolume, -9600, 0);
	BYTE bMIDIVol = VolumeToMidi(lVolume);

	SmartRef::PMsg<DMUS_CURVE_PMSG> pmsgCurve(pPerf);
	HRESULT hr = pmsgCurve.hr();
	if (FAILED(hr))
		return hr;

	// generic PMsg fields

	REFERENCE_TIME rtTimeNow = 0;
#ifndef XBOX
	hr = pPerf->GetLatencyTime(&rtTimeNow);
#else
    hr = pPerf->GetTime(&rtTimeNow,NULL);
#endif
	if (FAILED(hr))
		return hr;
	pmsgCurve.p->rtTime = rtTimeNow;
	pmsgCurve.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	pmsgCurve.p->dwPChannel = dwPChannel;
	// dwVirtualTrackID: this isn't a track so leave as 0
	pmsgCurve.p->dwType = DMUS_PMSGT_CURVE;
	pmsgCurve.p->dwGroupID = -1; // this isn't a track so just say all groups

	// curve PMsg fields
	pmsgCurve.p->mtDuration = lDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
	// mtResetDuration: no reset so leave as 0
	// nStartValue: will be ignored
	pmsgCurve.p->nEndValue = bMIDIVol;
	// nResetValue: no reset so leave as 0
	pmsgCurve.p->bType = DMUS_CURVET_CCCURVE;
	pmsgCurve.p->bCurveShape = lDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
	pmsgCurve.p->bCCData = 7; // MIDI volume controller number
	pmsgCurve.p->bFlags = DMUS_CURVE_START_FROM_CURRENT;
	// wParamType: leave as zero since this isn't a NRPN/RPN curve
	pmsgCurve.p->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

	// send it
	pmsgCurve.StampAndSend(pGraph);
	hr = pmsgCurve.hr();
	if (FAILED(hr))
		return hr;

	*pnNewVolume = (short) lVolume;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engcontrol.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of a script's control structures.
//

/*#include "stdinc.h"
#include "engcontrol.h"*/
#include "pchscript.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autperformance.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicPerformance.
//

/*#include "stdinc.h"
#include "autperformance.h"
#include <limits>
#include "dmusicf.h"*/

#include "pchscript.h"

const WCHAR CAutDirectMusicPerformance::ms_wszClassName[] = L"Performance";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_SetMasterTempo = 1;
const DISPID DMPDISP_GetMasterTempo = 2;
const DISPID DMPDISP_SetMasterVolume = 3;
const DISPID DMPDISP_GetMasterVolume = 4;
const DISPID DMPDISP_SetMasterGrooveLevel = 5;
const DISPID DMPDISP_GetMasterGrooveLevel = 6;
const DISPID DMPDISP_SetMasterTranspose = 7;
const DISPID DMPDISP_GetMasterTranspose = 8;
const DISPID DMPDISP_Trace = 9;
const DISPID DMPDISP_Rand = 10;

const AutDispatchMethod CAutDirectMusicPerformance::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_SetMasterTempo,				L"SetMasterTempo",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// tempo!New value for master tempo scaling factor as a percentage.  For example, 50 would halve the tempo and 200 would double it.
						ADT_None },
				/// Calls IDirectMusicPerformance::SetGlobalParam(GUID_PerfMasterTempo, tempo / 100, sizeof(float)).
		{ DMPDISP_GetMasterTempo,				L"GetMasterTempo",
						ADT_Long,		true,	&IID_NULL,						// Current master tempo scaling factor as a percentage.
						ADT_None },
				/// Calls IDirectMusicPerformance::GetGlobalParam(GUID_PerfMasterTempo, X, sizeof(float)) and returns X * 100.
		{ DMPDISP_SetMasterVolume,	L"SetMasterVolume",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// volume!New value for master volume attenuation.
						ADT_Long,		true,	&IID_NULL,						// duration
						ADT_None },
				/// Calls IDirectMusicPerformance::SetGlobalParam(GUID_PerfMasterVolume, volume, sizeof(long)).
				/// Range is 100th of a dB.  0 is full volume.
		{ DMPDISP_GetMasterVolume,	L"GetMasterVolume",
						ADT_Long,		true,	&IID_NULL,						// Current value of master volume attenuation.
						ADT_None },
				/// Calls IDirectMusicPerformance::GetGlobalParam(GUID_PerfMasterVolume, X, sizeof(long)) and returns X.
		{ DMPDISP_SetMasterGrooveLevel,			L"SetMasterGrooveLevel",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// groove level!New value for the global groove level, which is added to the level in the command track.
						ADT_None },
		{ DMPDISP_GetMasterGrooveLevel,			L"GetMasterGrooveLevel",
						ADT_Long,		true,	&IID_NULL,						// Current value of the global groove level, which is added to the level in the command track.
						ADT_None },
		{ DMPDISP_SetMasterTranspose,			L"SetMasterTranspose",
						ADPARAM_NORETURN,
						ADT_Long,		false,	&IID_NULL,						// transpose!Number of semitones to transpose everything.
						ADT_None },
		{ DMPDISP_GetMasterTranspose,			L"GetMasterTranspose",
						ADT_Long,		true,	&IID_NULL,						// Current global transposition (number of semitones).
						ADT_None },
		{ DMPDISP_Trace,						L"Trace",
						ADPARAM_NORETURN,
						ADT_Bstr,		false,	&IID_NULL,						// string!text to output to testing log
						ADT_None },
				/// This allocates, stamps, and sends a DMUS_LYRIC_PMSG with the following fields:
				/// <ul>
				/// <li> dwPChannel = channel
				/// <li> dwVirtualTrackID = 0
				/// <li> dwGroupID = -1
				/// <li> mtTime = GetTime(X, 0) is called and X * 10000 is used
				/// <li> dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME
				/// <li> dwType = DMUS_PMSGT_SCRIPTLYRIC
				/// <li> wszString = string
				/// </ul>
				/// This is used to send text to a trace log for debugging purposes.  Less commonly, a script could be
				/// running in an application that listens and reacts to the script's trace output.
		{ DMPDISP_Rand,							L"Rand",
						ADT_Long,		true,	&IID_NULL,						// Returns a randomly-generated number
						ADT_Long,		false,	&IID_NULL,						// Max value--returned number will be between 1 and this max.  Cannot be zero or negative.
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicPerformance> CAutDirectMusicPerformance::ms_Handlers[] =
	{
		{ DMPDISP_SetMasterTempo, SetMasterTempo },
		{ DMPDISP_GetMasterTempo, GetMasterTempo },
		{ DMPDISP_SetMasterVolume, SetMasterVolume },
		{ DMPDISP_GetMasterVolume, GetMasterVolume },
		{ DMPDISP_SetMasterGrooveLevel, SetMasterGrooveLevel },
		{ DMPDISP_GetMasterGrooveLevel, GetMasterGrooveLevel },
		{ DMPDISP_SetMasterTranspose, SetMasterTranspose },
		{ DMPDISP_GetMasterTranspose, GetMasterTranspose },
		{ DMPDISP_Trace, _Trace },
		{ DMPDISP_Rand, Rand },
        { DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicPerformance::CAutDirectMusicPerformance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpPerf(pUnknownOuter, iid, ppv, phr),
	m_nTranspose(0),
	m_nVolume(0)
{
	// set the random seed used by the Rand method
	m_lRand = GetTickCount();

	*phr = m_pITarget->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&m_scomGraph));

	if (SUCCEEDED(*phr))
	{
		// Due to the aggregation contract, our object is wholely contained in the lifetime of
		// the outer object and we shouldn't hold any references to it.
		ULONG ulCheck = m_pITarget->Release();
		assert(ulCheck);
	}
}

HRESULT
CAutDirectMusicPerformance::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicPerformance *pInst = new CAutDirectMusicPerformance(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Automation methods

HRESULT
CAutDirectMusicPerformance::SetMasterTempo(AutDispatchDecodedParams *paddp)
{
	LONG lTempo = paddp->params[0].lVal;
	float fltTempo = ConvertToTempo(lTempo);
	if (fltTempo < DMUS_MASTERTEMPO_MIN)
		fltTempo = DMUS_MASTERTEMPO_MIN;
	else if (fltTempo > DMUS_MASTERTEMPO_MAX)
		fltTempo = DMUS_MASTERTEMPO_MAX;
	return m_pITarget->SetGlobalParam(GUID_PerfMasterTempo, &fltTempo, sizeof(float));
}

HRESULT
CAutDirectMusicPerformance::GetMasterTempo(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	float fltTempo = 1; // default value is 1 (multiplicative identity)
	HRESULT hr = this->GetMasterParam(GUID_PerfMasterTempo, &fltTempo, sizeof(float));
	if (SUCCEEDED(hr))
		*plRet = ConvertFromTempo(fltTempo);
	return hr;
}

HRESULT
CAutDirectMusicPerformance::SetMasterVolume(AutDispatchDecodedParams *paddp)
{
	if (!m_scomGraph)
	{
		assert(false);
		return E_FAIL;
	}

	LONG lVol = paddp->params[0].lVal;
	LONG lDuration = paddp->params[1].lVal;

	return SendVolumePMsg(lVol, lDuration, DMUS_PCHANNEL_BROADCAST_PERFORMANCE, m_scomGraph, m_pITarget, &m_nVolume);
}

HRESULT
CAutDirectMusicPerformance::GetMasterVolume(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_nVolume;
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::SetMasterGrooveLevel(AutDispatchDecodedParams *paddp)
{
	LONG lGroove = paddp->params[0].lVal;
	char chGroove = (char) ClipLongRange(lGroove,-127,127); 
    return m_pITarget->SetGlobalParam(GUID_PerfMasterGrooveLevel, reinterpret_cast<void*>(&chGroove), sizeof(char));
}

HRESULT
CAutDirectMusicPerformance::GetMasterGrooveLevel(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (!plRet)
		return S_OK;

	char chGroove = 0; // default value is 0 (additive identity)
	HRESULT hr = this->GetMasterParam(GUID_PerfMasterGrooveLevel, reinterpret_cast<void*>(&chGroove), sizeof(char));
	if (SUCCEEDED(hr))
		*plRet = chGroove;
	return hr;
}

HRESULT
CAutDirectMusicPerformance::SetMasterTranspose(AutDispatchDecodedParams *paddp)
{
	LONG lTranspose = paddp->params[0].lVal;
	short nTranspose = (short) ClipLongRange(lTranspose,-32767,32767);

	SmartRef::PMsg<DMUS_TRANSPOSE_PMSG> pmsg(m_pITarget);
	HRESULT hr = pmsg.hr();
	if FAILED(hr)
		return hr;

	// Generic PMSG stuff
	hr = m_pITarget->GetTime(&pmsg.p->rtTime, NULL);
	if (FAILED(hr))
		return hr;
	pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	pmsg.p->dwType = DMUS_PMSGT_TRANSPOSE;
	pmsg.p->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	pmsg.p->dwVirtualTrackID = 0;
	pmsg.p->dwGroupID = -1;

	// Transpose PMSG stuff
	pmsg.p->nTranspose = nTranspose;
	pmsg.p->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

	pmsg.StampAndSend(m_scomGraph);
	hr = pmsg.hr();
	if (SUCCEEDED(hr))
		m_nTranspose = nTranspose;
	return hr;
}

HRESULT
CAutDirectMusicPerformance::GetMasterTranspose(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	if (plRet)
		*plRet = m_nTranspose;
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::_Trace(AutDispatchDecodedParams *paddp)
{
	BSTR bstr = paddp->params[0].bstrVal;
	int cwch = wcslen(bstr);

	SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(m_pITarget, cwch * sizeof(WCHAR));
	HRESULT hr = pmsg.hr();
	if (FAILED(hr))
		return hr;

	// Generic PMSG stuff
	hr = m_pITarget->GetTime(&pmsg.p->rtTime, NULL);
	if (FAILED(hr))
		return hr;
	pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
	pmsg.p->dwType = DMUS_PMSGT_SCRIPTLYRIC;
	pmsg.p->dwPChannel = 0;
	pmsg.p->dwVirtualTrackID = 0;
	pmsg.p->dwGroupID = -1;

	// Lyric PMSG stuff
	wcscpy(pmsg.p->wszString, bstr);

	pmsg.StampAndSend(m_scomGraph);
	return pmsg.hr();
}

HRESULT
CAutDirectMusicPerformance::Rand(AutDispatchDecodedParams *paddp)
{
	LONG *plRet = reinterpret_cast<LONG*>(paddp->pvReturn);
	LONG lMax = paddp->params[0].lVal;

	if (lMax < 1 || lMax > 0x7fff)
		return E_INVALIDARG;

	// Use random number generation lifted from the standard library's rand.c.  We don't just
	// use the rand function because the multithreaded library has a per-thread random chain,
	// but this function is called from various threads and it would be difficult to manage
	// getting them seeded.  Generates pseudo-random numbers 0 through 32767.
	long lRand = ((m_lRand = m_lRand * 214013L + 2531011L) >> 16) & 0x7fff;

	if (plRet)
		*plRet = lRand % lMax + 1; // trim to the requested range [1,lMax]
	return S_OK;
}

HRESULT
CAutDirectMusicPerformance::GetMasterParam(const GUID &guid, void *pParam, DWORD dwSize)
{
	HRESULT hr = m_pITarget->GetGlobalParam(guid, pParam, dwSize);
	if (SUCCEEDED(hr) || hr == E_INVALIDARG) // E_INVALIDARG is the performance's polite way of telling us the param hasn't been set yet
		return S_OK;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autconstants.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Functions that implement the automation interfaces for the DirectMusic constants.
//

/*#include "stdinc.h"
#include "autconstants.h"
#include "oleaut.h"*/

#include "pchscript.h"

struct AutConstantDef
{
	DISPID dispid;
	const WCHAR *pwszName;
	LONG lVal;
};

// Performance

const DISPID DMCONSTDISP_IsSecondary = 1;
const DISPID DMCONSTDISP_IsControl = 2;
const DISPID DMCONSTDISP_AtFinish = 3;
const DISPID DMCONSTDISP_AtGrid = 4;
const DISPID DMCONSTDISP_AtBeat = 5;
const DISPID DMCONSTDISP_AtMeasure = 6;
const DISPID DMCONSTDISP_AtMarker = 7;
const DISPID DMCONSTDISP_AtImmediate = 8;
const DISPID DMCONSTDISP_AlignToBar = 9;
const DISPID DMCONSTDISP_AlignToBeat = 10;
const DISPID DMCONSTDISP_AlignToSegment = 11;
const DISPID DMCONSTDISP_PlayFill = 12;
const DISPID DMCONSTDISP_PlayIntro = 13;
const DISPID DMCONSTDISP_PlayBreak = 14;
const DISPID DMCONSTDISP_PlayEnd = 15;
const DISPID DMCONSTDISP_PlayEndAndIntro = 16;
const DISPID DMCONSTDISP_PlayModulate = 17;
const DISPID DMCONSTDISP_UseClockTime = 18;
const DISPID DMCONSTDISP_NoCutoff = 19;

const AutConstantDef gs_Constants[] =
	{
		{ DMCONSTDISP_IsSecondary,						L"IsSecondary",						ScriptConstants::IsSecondary },
		{ DMCONSTDISP_IsControl,						L"IsControl",						ScriptConstants::IsControl },
		{ DMCONSTDISP_AtFinish,							L"AtFinish",						ScriptConstants::AtFinish },
		{ DMCONSTDISP_AtGrid,							L"AtGrid",							ScriptConstants::AtGrid },
		{ DMCONSTDISP_AtBeat,							L"AtBeat",							ScriptConstants::AtBeat },
		{ DMCONSTDISP_AtMeasure,						L"AtMeasure",						ScriptConstants::AtMeasure },
		{ DMCONSTDISP_AtMarker,							L"AtMarker",						ScriptConstants::AtMarker },
		{ DMCONSTDISP_AtImmediate,						L"AtImmediate",						ScriptConstants::AtImmediate },
		{ DMCONSTDISP_AlignToBar,						L"AlignToBar",						ScriptConstants::AlignToBar },
		{ DMCONSTDISP_AlignToBeat,						L"AlignToBeat",						ScriptConstants::AlignToBeat },
		{ DMCONSTDISP_AlignToSegment,					L"AlignToSegment",					ScriptConstants::AlignToSegment },
		{ DMCONSTDISP_PlayFill,							L"PlayFill",						ScriptConstants::PlayFill },
		{ DMCONSTDISP_PlayIntro,						L"PlayIntro",						ScriptConstants::PlayIntro },
		{ DMCONSTDISP_PlayBreak,						L"PlayBreak",						ScriptConstants::PlayBreak },
		{ DMCONSTDISP_PlayEnd,							L"PlayEnd",							ScriptConstants::PlayEnd },
		{ DMCONSTDISP_PlayEndAndIntro,					L"PlayEndAndIntro",					ScriptConstants::PlayEndAndIntro },
		{ DMCONSTDISP_PlayModulate,						L"PlayModulate",					ScriptConstants::PlayModulate },
		{ DMCONSTDISP_NoCutoff,							L"NoCutoff",						ScriptConstants::NoCutoff },
		{ DISPID_UNKNOWN }
	};

HRESULT
AutConstantsGetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	V_INAME(AutConstantsGetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	for (c = 0; gs_Constants[c].dispid != DISPID_UNKNOWN; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], gs_Constants[c].pwszName))
		{
			rgDispId[0] = gs_Constants[c].dispid;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT AutConstantsInvoke(
			DISPID dispIdMember,
			REFIID riid,
			LCID lcid,
			WORD wFlags,
			DISPPARAMS __RPC_FAR *pDispParams,
			VARIANT __RPC_FAR *pVarResult,
			EXCEPINFO __RPC_FAR *pExcepInfo,
			UINT __RPC_FAR *puArgErr)
{
	V_INAME(AutConstantsInvoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_PROPERTYGET))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	// Find the constant

	for (const AutConstantDef *pConst = gs_Constants;
			pConst->dispid != DISPID_UNKNOWN && pConst->dispid != dispIdMember;
			++pConst)
	{
	}

	if (pConst->dispid == DISPID_UNKNOWN)
		return DISP_E_MEMBERNOTFOUND;

	// Return the value value

	if (pVarResult)
	{
		pVarResult->vt = VT_I4;
		pVarResult->lVal = pConst->lVal;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\autsegment.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAutDirectMusicSegment.
//

/*#include "stdinc.h"
#include "autsegment.h"
#include "activescript.h"
#include "autconstants.h"
#include <limits>*/

#include "pchscript.h"

const WCHAR CAutDirectMusicSegment::ms_wszClassName[] = L"Segment";

//////////////////////////////////////////////////////////////////////
// Method Names/DispIDs

const DISPID DMPDISP_Load = 1;
const DISPID DMPDISP_Play = 2;
const DISPID DMPDISP_Stop = 3;
const DISPID DMPDISP_DownloadSoundData = 4;
const DISPID DMPDISP_UnloadSoundData = 5;
const DISPID DMPDISP_Recompose = 6;

const AutDispatchMethod CAutDirectMusicSegment::ms_Methods[] =
	{
		// dispid,				name,
			// return:	type,	(opt),	(iid),
			// parm 1:	type,	opt,	iid,
			// parm 2:	type,	opt,	iid,
			// ...
			// ADT_None
		{ DMPDISP_Load,							L"Load",
						ADPARAM_NORETURN,
						ADT_None },
		{ DMPDISP_Play,							L"Play",
						ADT_Interface,	true,	&IID_IUnknown,					// returned segment state
						ADT_Long,		true,	&IID_NULL,						// flags
						ADT_Interface,	true,	&IID_IDirectMusicAudioPath,		// audio path
						ADT_Interface,	true,	&IID_IDirectMusicSegment,		// template segment for transition
						ADT_Interface,	true,	&IID_IDirectMusicSegmentState,	// playing segment to replace
						ADT_None },
		{ DMPDISP_Stop,							L"Stop",
						ADPARAM_NORETURN,
						ADT_Long,		true,	&IID_NULL,						// flags
						ADT_None },
		{ DMPDISP_DownloadSoundData,					L"DownloadSoundData",
						ADPARAM_NORETURN,
						ADT_Interface,	true,	&IID_IDirectMusicAudioPath,		// audio path
						ADT_None },
		{ DMPDISP_UnloadSoundData,					L"UnloadSoundData",
						ADPARAM_NORETURN,
						ADT_Interface,	true,	&IID_IDirectMusicAudioPath,		// audio path
						ADT_None },
		{ DMPDISP_Recompose,					L"Recompose",
						ADPARAM_NORETURN,
						ADT_None },
		{ DISPID_UNKNOWN }
	};

const DispatchHandlerEntry<CAutDirectMusicSegment> CAutDirectMusicSegment::ms_Handlers[] =
	{
		{ DMPDISP_Load, Load },
		{ DMPDISP_Play, Play },
		{ DMPDISP_Stop, Stop },
		{ DMPDISP_DownloadSoundData, DownloadSoundData },
		{ DMPDISP_UnloadSoundData, UnloadSoundData },
		{ DMPDISP_Recompose, Recompose },
		{ DISPID_UNKNOWN }
	};

//////////////////////////////////////////////////////////////////////
// Creation

CAutDirectMusicSegment::CAutDirectMusicSegment(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv,
		HRESULT *phr)
  : BaseImpSegment(pUnknownOuter, iid, ppv, phr)
{
}

HRESULT CAutDirectMusicSegment::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	HRESULT hr = S_OK;
	CAutDirectMusicSegment *pInst = new CAutDirectMusicSegment(pUnknownOuter, iid, ppv, &hr);
	if (FAILED(hr))
	{
		delete pInst;
		return hr;
	}
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Private Functions

HRESULT
CAutDirectMusicSegment::Load(AutDispatchDecodedParams *paddp)
{
	// Loading is actually implemented generically by container items.
	// If we're here, we're already loaded and don't need to do anything.
	return S_OK;
}

const FlagMapEntry gc_flagmapPlay[] =
	{
		{ ScriptConstants::IsSecondary,		DMUS_SEGF_SECONDARY },
		{ ScriptConstants::IsControl,		DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY },
		{ ScriptConstants::AtFinish,		DMUS_SEGF_QUEUE },
		{ ScriptConstants::AtGrid,			DMUS_SEGF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_SEGF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_SEGF_MEASURE },
		{ ScriptConstants::AtMarker,		DMUS_SEGF_MARKER },
		{ ScriptConstants::AtImmediate,		DMUS_SEGF_DEFAULT }, // this flag gets flipped later
		{ ScriptConstants::AlignToBar,		DMUS_SEGF_ALIGN | DMUS_SEGF_MEASURE | DMUS_SEGF_VALID_START_BEAT },
		{ ScriptConstants::AlignToBeat,		DMUS_SEGF_ALIGN | DMUS_SEGF_BEAT | DMUS_SEGF_VALID_START_GRID },
		{ ScriptConstants::AlignToSegment,	DMUS_SEGF_ALIGN | DMUS_SEGF_SEGMENTEND | DMUS_SEGF_VALID_START_MEASURE },
		{ ScriptConstants::NoCutoff,		DMUS_SEGF_NOINVALIDATE },
		{ 0 }
	};

const FlagMapEntry gc_flagmapPlayTransCommand[] =
	{
		{ ScriptConstants::PlayFill,		DMUS_COMMANDT_FILL },
		{ ScriptConstants::PlayIntro,		DMUS_COMMANDT_INTRO },
		{ ScriptConstants::PlayBreak,		DMUS_COMMANDT_BREAK },
		{ ScriptConstants::PlayEnd,			DMUS_COMMANDT_END },
		{ ScriptConstants::PlayEndAndIntro,	DMUS_COMMANDT_ENDANDINTRO },
		{ 0 }
	};

const FlagMapEntry gc_flagmapPlayTransFlags[] =
	{
		{ ScriptConstants::AtFinish,		DMUS_COMPOSEF_SEGMENTEND },
		{ ScriptConstants::AtGrid,			DMUS_COMPOSEF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_COMPOSEF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_COMPOSEF_MEASURE },
		{ ScriptConstants::AtMarker,		DMUS_COMPOSEF_MARKER },
		{ ScriptConstants::AtImmediate,		DMUS_COMPOSEF_IMMEDIATE },
		{ ScriptConstants::AlignToBar,		DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_MEASURE },
		{ ScriptConstants::AlignToBeat,		DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_BEAT },
		{ ScriptConstants::AlignToSegment,	DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_SEGMENTEND },
		{ ScriptConstants::PlayModulate,	DMUS_COMPOSEF_MODULATE },
		{ 0 }
	};

HRESULT
CAutDirectMusicSegment::Play(AutDispatchDecodedParams *paddp)
{
	IDirectMusicSegmentState **ppSegSt = reinterpret_cast<IDirectMusicSegmentState **>(paddp->pvReturn);
	LONG lFlags = paddp->params[0].lVal;
	IDirectMusicAudioPath *pAudioPath = reinterpret_cast<IDirectMusicAudioPath*>(paddp->params[1].iVal);
	IDirectMusicSegment *pTransitionSegment = reinterpret_cast<IDirectMusicSegment*>(paddp->params[2].iVal);
	IDirectMusicSegmentState *pFromSegmentState = reinterpret_cast<IDirectMusicSegmentState*>(paddp->params[3].iVal);

	const LONG lFlagsNonPrimary = ScriptConstants::IsSecondary | ScriptConstants::IsControl;
	const LONG lFlagsTransition = ScriptConstants::PlayFill | ScriptConstants::PlayIntro | ScriptConstants::PlayBreak | ScriptConstants::PlayEnd | ScriptConstants::PlayEndAndIntro;
	if ((lFlags & lFlagsNonPrimary) && (lFlags & lFlagsTransition))
	{
		// Transitions may only be used when playing primary segments.  Return a runtime error.
		Trace(1, "Error: Play called with IsSecondary or IsControl flag as well as a transition flag (PlayFill, PlayIntro, etc..). Transitions can only be used with primary segments.\n");
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
	if (lFlags & lFlagsTransition)
	{
		// do a transition
		DWORD dwCommand = MapFlags(lFlags, gc_flagmapPlayTransCommand);
		assert(dwCommand < std::numeric_limits<WORD>::max()); // the command parameter is a WORD. this just checks that there's nothing truncated.
		DWORD dwFlags = MapFlags(lFlags, gc_flagmapPlayTransFlags);
        // Always play the entire transition instead of doing the old (slightly strange) 1 bar / long stuff.
        // Also, always use an embedded audio path if one exists.
        dwFlags |= (DMUS_COMPOSEF_ENTIRE_TRANSITION | DMUS_COMPOSEF_USE_AUDIOPATH);
		IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
		hr = pComposer->AutoTransition(pPerformance, m_pITarget, (WORD)dwCommand, dwFlags, NULL, NULL, ppSegSt, NULL);
	}
	else
	{
		DWORD dwFlags = MapFlags(lFlags, gc_flagmapPlay);

		// Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
		//dwFlags ^= DMUS_SEGF_DEFAULT;

        //If we're "borrowing" the default flag to signify "immediate" then we'll assume other SEGF transition flags aren't specified and simply
        //  turn off this bug.
        //  If other transition flags ARE specified then they'll override "immediate".
        if (dwFlags & DMUS_SEGF_DEFAULT)
        {
    		dwFlags ^= DMUS_SEGF_DEFAULT;
        }

        //If we're NOT borrowing the default flag to signify "immediate", it may or may not be necessary to add.  It will only be necessary if
        //  no other transition flags were specified.
        else
        {
            if (!(dwFlags & (DMUS_SEGF_SEGMENTEND | DMUS_SEGF_GRID | DMUS_SEGF_BEAT | DMUS_SEGF_MEASURE | DMUS_SEGF_MARKER | DMUS_SEGF_ALIGN)))
            {
	            dwFlags |= DMUS_SEGF_DEFAULT;
            }
        }

		if (pTransitionSegment)
			dwFlags |= DMUS_SEGF_AUTOTRANSITION;

		__int64 i64IntendedStartTime;
		DWORD dwIntendedStartTimeFlags;
		CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);

		hr = pPerformance->PlaySegmentEx(m_pITarget, 0, pTransitionSegment, dwFlags | dwIntendedStartTimeFlags, i64IntendedStartTime, ppSegSt, pFromSegmentState, pAudioPath);
	}
	if (FAILED(hr))
		return hr;

	return S_OK;
}

const FlagMapEntry gc_flagmapStop[] =
	{
		{ ScriptConstants::AtGrid,			DMUS_SEGF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_SEGF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_SEGF_MEASURE },
		{ ScriptConstants::AtMarker,		DMUS_SEGF_MARKER },
		{ ScriptConstants::AtImmediate,		DMUS_SEGF_DEFAULT }, // this flag gets flipped later
		{ 0 }
	};

const FlagMapEntry gc_flagmapStopTransFlags[] =
	{
		{ ScriptConstants::AtGrid,			DMUS_COMPOSEF_GRID },
		{ ScriptConstants::AtBeat,			DMUS_COMPOSEF_BEAT },
		{ ScriptConstants::AtMeasure,		DMUS_COMPOSEF_MEASURE },
		{ ScriptConstants::AtMarker,		DMUS_COMPOSEF_MARKER },
		{ ScriptConstants::AtImmediate,		DMUS_COMPOSEF_IMMEDIATE },
		{ 0 }
	};

HRESULT
CAutDirectMusicSegment::Stop(AutDispatchDecodedParams *paddp)
{
	LONG lFlags = paddp->params[0].lVal;

	HRESULT hr = S_OK;
	IDirectMusicPerformance8 *pPerformance = CActiveScriptManager::GetCurrentPerformanceWEAK();
    if (lFlags & ScriptConstants::PlayEnd)
    {
        // do a transition to silence
        DWORD dwFlags = MapFlags(lFlags, gc_flagmapStopTransFlags);
        // Always play the entire transition instead of doing the old (slightly strange) 1 bar / long stuff.
        // Also, always use an embedded audio path if one exists.
        dwFlags |= (DMUS_COMPOSEF_ENTIRE_TRANSITION | DMUS_COMPOSEF_USE_AUDIOPATH);
        IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
        hr = pComposer->AutoTransition(pPerformance, NULL, DMUS_COMMANDT_END, dwFlags, NULL, NULL, NULL, NULL);
    }
	else
	{
		DWORD dwFlags = MapFlags(lFlags, gc_flagmapStop);
		// Reverse the default flag because our flag means the opposite.  Default is the default and immediate is the flag.
		//dwFlags ^= DMUS_SEGF_DEFAULT;

        //If we're "borrowing" the default flag to signify "immediate" then we'll assume other SEGF transition flags aren't specified and simply
        //  turn off this bug.
        //  If other transition flags ARE specified then they'll override "immediate".
        if (dwFlags & DMUS_SEGF_DEFAULT)
        {
    		dwFlags ^= DMUS_SEGF_DEFAULT;
        }

        //If we're NOT borrowing the default flag to signify "immediate", it may or may not be necessary to add.  It will only be necessary if
        //  no other transition flags were specified.
        else
        {
            if (!(dwFlags & (DMUS_SEGF_SEGMENTEND | DMUS_SEGF_GRID | DMUS_SEGF_BEAT | DMUS_SEGF_MEASURE | DMUS_SEGF_MARKER | DMUS_SEGF_ALIGN)))
            {
	            dwFlags |= DMUS_SEGF_DEFAULT;
            }
        }

		__int64 i64IntendedStartTime;
		DWORD dwIntendedStartTimeFlags;
		CActiveScriptManager::GetCurrentTimingContext(&i64IntendedStartTime, &dwIntendedStartTimeFlags);
#ifdef DXAPI
		hr = pPerformance->Stop(m_pITarget, NULL, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
#else
        hr = pPerformance->StopEx(m_pITarget, i64IntendedStartTime, dwFlags | dwIntendedStartTimeFlags);
#endif
	}
	return hr;
}

HRESULT
CAutDirectMusicSegment::Recompose(AutDispatchDecodedParams *paddp)
{
	IDirectMusicComposer8 *pComposer = CActiveScriptManager::GetComposerWEAK();
    IDirectMusicComposer8P *pComposerP = NULL;
    HRESULT hr = pComposer->QueryInterface(IID_IDirectMusicComposer8P, (void**)&pComposerP);
    if (SUCCEEDED(hr))
    {
	    hr = pComposerP->ComposeSegmentFromTemplateEx(NULL, m_pITarget, 0, 0, NULL, NULL);
        pComposerP->Release();
    }
	return hr;
}

HRESULT
CAutDirectMusicSegment::DownloadOrUnload(bool fDownload, AutDispatchDecodedParams *paddp)
{
	IUnknown *pAudioPathOrPerf = reinterpret_cast<IDirectMusicAudioPath*>(paddp->params[0].iVal);
	if (!pAudioPathOrPerf)
		pAudioPathOrPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();

	return fDownload
				? m_pITarget->Download(pAudioPathOrPerf)
				: m_pITarget->Unload(pAudioPathOrPerf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engcontrol.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of a script's control structures.
//

#pragma once

#include "englookup.h"
#include "englex.h"

//////////////////////////////////////////////////////////////////////
// Statement structures

// forward decls and collections
class Routine;
typedef Slots<Routine> Routines;
class Variable;
typedef Slots<Variable> Variables;
class ReferenceName;
typedef Slots<ReferenceName> ReferenceNames;
class VariableReference;
typedef Slots<VariableReference> VariableReferences;
class Statement;
typedef Slots<Statement> Statements;
class Value;
typedef Slots<Value> Values;
class Call;
typedef Slots<Call> Calls;
class ExprBlock;
typedef Slots<ExprBlock> ExprBlocks;
class IfBlock;
typedef Slots<IfBlock> IfBlocks;
class Assignment;
typedef Slots<Assignment> Assignments;

class Variable
{
public:
	Variable(Strings::index _istrIdentifier, DISPID _dispid = DISPID_UNKNOWN) : istrIdentifier(_istrIdentifier), dispid(_dispid) {}

	Strings::index istrIdentifier;
	DISPID dispid; // this is set to a value other than DISPID_UNKNOWN if the variable is a member of the global dispatch instead of an item in the script itself

private:
	friend class SmartRef::Vector<Variable>;
	Variable() {}
};

// Names used in a sequence for dereferencing attributes or function calls.
// For example, a and b in "a.b" or x and y in "x.y(3)".
class ReferenceName
{
public:
	ReferenceName(Strings::index _istrIdentifier) : istrIdentifier(_istrIdentifier) {}

	Strings::index istrIdentifier; // -1 is used to end a sequence of names

private:
	friend class SmartRef::Vector<ReferenceName>;
	ReferenceName() {}
};

class VariableReference
{
public:
	enum kind { _global, _local };
	VariableReference(kind _k, ReferenceNames::index _irname, Variables::index _ivar)
		: k(_k), irname(_irname), ivar(_ivar) {}

	kind k;
	ReferenceNames::index irname;
	Variables::index ivar; // slot of the first name within (global/local/temporary) variables

private:
	friend class SmartRef::Vector<VariableReference>;
	VariableReference() {}
};

class Value
{
public:
	// dummy types to differentiate constructors
	enum cons_numvalue {};
	enum cons_strvalue {};
	enum cons_varref {};

	enum kind { _numvalue, _strvalue, _varref };

	Value(cons_numvalue e, int iVal) : k(_numvalue) { inumvalue = iVal; }
	Value(cons_strvalue e, Strings::index iStr) : k(_strvalue) { istrvalue = iStr; }
	Value(cons_varref e, VariableReferences::index _ivarref) : k(_varref) { ivarref = _ivarref; }

	kind k;
	union
	{
		int inumvalue;
		Strings::index istrvalue;
		VariableReferences::index ivarref;
	};

private:
	friend class SmartRef::Vector<Value>;
	Value() {}
};

class Call
{
public:
	// dummy types to differentiate constructors
	enum cons_global {};
	enum cons_dereferenced {};

	enum kind { _global, _dereferenced };

	Call() {} // all fields are set after creation

	kind k;
	union
	{
		Strings::index istrname;			// _global
		VariableReferences::index ivarref;	// _dereferenced
	};
	ExprBlocks::index iexprParams; // doubly-terminated list of lists. each parameter is terminated with an _end block and the final parameter is also terminated with a second _end block.
};

class ExprBlock
{
public:
	// dummy types to differentiate constructors
	enum cons_end {};
	enum cons_op {};
	enum cons_val {};
	enum cons_call {};
	enum cons_omitted {}; // used only in a routine call, stands for an omitted parameter

	enum kind { _end = 0, _op, _val, _call, _omitted };

	// Note: For unary - (negation), TOKEN_sub is used instead of TOKEN_op_minus.
	ExprBlock(cons_end e) : k(_end) {}
	ExprBlock(cons_op e, Token __op) : k(_op) { op = __op; assert(CheckOperatorType(op, true, true, true, false) || op == TOKEN_sub); }
	ExprBlock(cons_val e, Values::index _ival) : k(_val) { ival = _ival; }
	ExprBlock(cons_call e, Calls::index _icall) : k(_call) { icall = _icall; }
	ExprBlock(cons_omitted e) : k(_omitted) {}

	operator bool() { return k != _end; }

	kind k;

	union
	{
		Token op;
		Values::index ival;
		Calls::index icall;
	};

private:
	friend class SmartRef::Vector<ExprBlock>;
	friend class SmartRef::Stack<ExprBlock>;
	ExprBlock() {}
};

class Assignment
{
public:
	Assignment(bool _fSet, VariableReferences::index _ivarrefLHS, ExprBlocks::index _iexprRHS) : fSet(_fSet), ivarrefLHS(_ivarrefLHS), iexprRHS(_iexprRHS) {}

	bool fSet;
	VariableReferences::index ivarrefLHS;
	ExprBlocks::index iexprRHS;

private:
	friend class SmartRef::Vector<Assignment>;
	Assignment() {}
};

class IfBlock
{
public:
	// _end: end of blocks without an 'else'
	// _else: end of blocks with an 'else'
	// _cond: a conditional block, from 'if' (first one) or 'elseif' (later ones)
	enum kind { _end = 0, _else, _cond };

	IfBlock() : k(_end) {}
	IfBlock(Statements::index _istmtBlock) : k(_else), istmtBlock(_istmtBlock) {}
	IfBlock(ExprBlocks::index _iexprCondition, Statements::index _istmtBlock) : k(_cond), iexprCondition(_iexprCondition), istmtBlock(_istmtBlock) {}

	kind k;
	ExprBlocks::index iexprCondition; // only used by cond kind
	Statements::index istmtBlock; // not used by end kind
};

class Statement
{
public:
	typedef int index;

	// dummy types to differentiate constructors
	enum cons_end {};
	enum cons_asgn {};
	enum cons_if {};
	enum cons_call {};

	enum kind { _end = 0, _if, _asgn, _call }; // _end is used as a terminator for a block of statements

	Statement(cons_end e, int _iLine) : k(_end), iLine(_iLine) {}
	Statement(cons_asgn e, Assignments::index _iasgn, int _iLine) : k(_asgn), iLine(_iLine) { iasgn = _iasgn; }
	Statement(cons_if e, int _iLine) : k(_if), iLine(_iLine) { iif = 0; istmtIfTail = 0; }
	Statement(cons_call e, Calls::index _icall, int _iLine) : k(_call), iLine(_iLine) { icall = _icall; }

	operator bool() { return k != _end; }

	kind k;
	int iLine;
	union
	{
		Assignments::index iasgn;
		struct
		{
			IfBlocks::index iif;
			Statements::index istmtIfTail;
		};
		Calls::index icall;
	};

private:
	friend class SmartRef::Vector<Statement>;
	Statement() {}
};

class Routine
{
public:
	Routine(Strings::index _istrIdentifier) : istrIdentifier(_istrIdentifier), istmtBody(0), ivarNextLocal(0) {}

	Strings::index istrIdentifier;
	Statements::index istmtBody;
	Variables::index ivarNextLocal; // while parsing, this is the next local slot to use.  by runtime, this as the total number of local slots needed by the routine.

private:
	friend class SmartRef::Vector<Routine>;
	Routine() {}
};

class Script
{
public:
	Script() {}

	Routines routines;
	Variables globals;
	Strings strings;
	Statements statements;
	ReferenceNames rnames;
	VariableReferences varrefs;
	Values vals;
	Calls calls;
	ExprBlocks exprs;
	IfBlocks ifs;
	Assignments asgns;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engdisp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of EngineDispatch.
//

// Implements the IDispatch interface for the script that exposes its routines, variables, and type information.
#ifndef ENGDISP_H
#define ENGDISP_H
#include "engcontrol.h"
#include "engexec.h"

class EngineDispatch
  : public IDispatch,
	public ITypeInfo
{
public:
	// CAudioVBScriptEngine will create EngineDispatch and pass itself as the punkParent.
	// CAudioVBScriptEngine::Close releases CAudioVBScriptEngine's ref (coming from the creation) on EngineDispatch.
	// The final call of EngineDispatch::Release in turn releases the ref (coming from holding the parent) on CAudioVBScriptEngine.
	EngineDispatch(IUnknown *punkParent, Script &script, IDispatch *pGlobalDispatch);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr);

	// implemented ITypeInfo methods
	HRESULT STDMETHODCALLTYPE GetTypeAttr(
		/* [out] */ TYPEATTR **ppTypeAttr);
	void STDMETHODCALLTYPE ReleaseTypeAttr(
		/* [in] */ TYPEATTR *pTypeAttr);
	HRESULT STDMETHODCALLTYPE GetFuncDesc(
		/* [in] */ UINT index,
		/* [out] */ FUNCDESC **ppFuncDesc);
	void STDMETHODCALLTYPE ReleaseFuncDesc(
		/* [in] */ FUNCDESC *pFuncDesc);
	HRESULT STDMETHODCALLTYPE GetVarDesc(
		/* [in] */ UINT index,
		/* [out] */ VARDESC **ppVarDesc);
	void STDMETHODCALLTYPE ReleaseVarDesc(
		/* [in] */ VARDESC *pVarDesc);
	HRESULT STDMETHODCALLTYPE GetNames(
		/* [in] */ MEMBERID memid,
		/* [length_is][size_is][out] */ BSTR *rgBstrNames,
		/* [in] */ UINT cMaxNames,
		/* [out] */ UINT *pcNames);

	// unimplemented ITypeInfo methods
	HRESULT STDMETHODCALLTYPE GetTypeComp(
		/* [out] */ ITypeComp **ppTComp) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetRefTypeOfImplType(
		/* [in] */ UINT index,
		/* [out] */ HREFTYPE *pRefType) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetImplTypeFlags(
		/* [in] */ UINT index,
		/* [out] */ INT *pImplTypeFlags) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		/* [size_is][in] */ LPOLESTR *rgszNames,
		/* [in] */ UINT cNames,
		/* [size_is][out] */ MEMBERID *pMemId) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Invoke(
		/* [in] */ PVOID pvInstance,
		/* [in] */ MEMBERID memid,
		/* [in] */ WORD wFlags,
		/* [out][in] */ DISPPARAMS *pDispParams,
		/* [out] */ VARIANT *pVarResult,
		/* [out] */ EXCEPINFO *pExcepInfo,
		/* [out] */ UINT *puArgErr) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetDocumentation(
		/* [in] */ MEMBERID memid,
		/* [out] */ BSTR *pBstrName,
		/* [out] */ BSTR *pBstrDocString,
		/* [out] */ DWORD *pdwHelpContext,
		/* [out] */ BSTR *pBstrHelpFile) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetDllEntry(
		/* [in] */ MEMBERID memid,
		/* [in] */ INVOKEKIND invKind,
		/* [out] */ BSTR *pBstrDllName,
		/* [out] */ BSTR *pBstrName,
		/* [out] */ WORD *pwOrdinal) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetRefTypeInfo(
		/* [in] */ HREFTYPE hRefType,
		/* [out] */ ITypeInfo **ppTInfo) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE AddressOfMember(
		/* [in] */ MEMBERID memid,
		/* [in] */ INVOKEKIND invKind,
		/* [out] */ PVOID *ppv) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE CreateInstance(
		/* [in] */ IUnknown *pUnkOuter,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ PVOID *ppvObj) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetMops(
		/* [in] */ MEMBERID memid,
		/* [out] */ BSTR *pBstrMops) { assert(false); return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetContainingTypeLib(
		/* [out] */ ITypeLib **ppTLib,
		/* [out] */ UINT *pIndex) { assert(false); return E_NOTIMPL; }

private:
	// Data
	long m_cRef;
	SmartRef::ComPtr<IUnknown> m_scomParent;
	Script &m_script;
	Executor m_exec;
};
#endif // ENGDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engerror.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CActiveScriptError.
//

/*#include "stdinc.h"
#include "enginc.h"
#include "engerror.h"
#include "oleaut.h"*/

#include "pchscript.h"

CActiveScriptError::CActiveScriptError(HRESULT hr, Lexer &lexer, const char *pszDescription)
  : m_scode(hr),
	m_wstrDescription(pszDescription),
	m_pwszSource(NULL),
	m_ulLineNumber(lexer.line() - 1), // line is reported zero-based from IActiveScriptError
	m_lCharacterPosition(lexer.column() - 1) // character position is reported zero-based from IActiveScriptError
{
	assert(pszDescription && lexer.line() > 0 && lexer.column() > 0);

	// build the near text from the lexer's current position to the end of the line
	for (const WCHAR *pwsz = lexer.m_p; *pwsz && *pwsz != '\n' && *pwsz != '\r'; ++pwsz)
	{}

	m_wstrSourceLine.Assign(lexer.m_p, pwsz - lexer.m_p);

	// fill in the source text based on hresult
	if (hr == DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR)
	{
		m_pwszSource = L"Microsoft AudioVBScript syntax error";
	}
	else if (hr == DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR)
	{
		m_pwszSource = L"Microsoft AudioVBScript runtime error";
	}
	else
	{
		assert(hr == DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE);
		m_pwszSource = L"Microsoft AudioVBScript operation failure";
	}
}

STDMETHODIMP
CActiveScriptError::GetExceptionInfo(
		/* [out] */ EXCEPINFO *pexcepinfo)
{
	V_INAME(CActiveScriptError::GetExceptionInfo);
	V_PTR_WRITE(pexcepinfo, *pexcepinfo);

	Zero(pexcepinfo);
	pexcepinfo->scode = m_scode;

	if (m_wstrDescription)
		pexcepinfo->bstrDescription = DMS_SysAllocString(g_fUseOleAut, m_wstrDescription);
	if (!pexcepinfo->bstrDescription)
		return E_OUTOFMEMORY;

	pexcepinfo->bstrSource = DMS_SysAllocString(g_fUseOleAut, m_pwszSource);
	if (!pexcepinfo->bstrSource)
		return E_OUTOFMEMORY;

	return S_OK;
}

STDMETHODIMP
CActiveScriptError::GetSourcePosition(
		/* [out] */ DWORD *pdwSourceContext,
		/* [out] */ ULONG *pulLineNumber,
		/* [out] */ LONG *plCharacterPosition)
{
	V_INAME(CActiveScriptError::GetSourcePosition);
	V_PTR_WRITE_OPT(pdwSourceContext, *pdwSourceContext);
	V_PTR_WRITE(pulLineNumber, *pulLineNumber);
	V_PTR_WRITE(plCharacterPosition, *plCharacterPosition);

	assert(!pdwSourceContext);
	*pulLineNumber = m_ulLineNumber;
	*plCharacterPosition = m_lCharacterPosition;
	return S_OK;
}

STDMETHODIMP
CActiveScriptError::GetSourceLineText(
		/* [out] */ BSTR *pbstrSourceLine)
{
	V_INAME(CActiveScriptError::GetSourceLineText);
	V_PTR_WRITE(pbstrSourceLine, *pbstrSourceLine);

	*pbstrSourceLine = NULL;
	if (m_wstrSourceLine)
		*pbstrSourceLine = DMS_SysAllocString(g_fUseOleAut, m_wstrSourceLine);
	if (!*pbstrSourceLine)
		return E_OUTOFMEMORY;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engerror.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CActiveScriptError.  Object that implements IActiveScriptError for returning error information from the script engine.
//

#pragma once

#include "englex.h"
#include "activescript.h"
#include "unkhelp.h"

class CActiveScriptError
  : public IActiveScriptError,
	public ComSingleInterface
{
public:
	ComSingleInterfaceUnknownMethods(IActiveScriptError)

	CActiveScriptError(HRESULT hr, Lexer &lexer, const char *pszDescription);

	// IActiveScriptError
	STDMETHOD(GetExceptionInfo)(
		/* [out] */ EXCEPINFO *pexcepinfo);
	STDMETHOD(GetSourcePosition)(
		/* [out] */ DWORD *pdwSourceContext,
		/* [out] */ ULONG *pulLineNumber,
		/* [out] */ LONG *plCharacterPosition);
	STDMETHOD(GetSourceLineText)(
		/* [out] */ BSTR *pbstrSourceLine);

private:
	HRESULT m_scode;
	SmartRef::WString m_wstrDescription;
	const WCHAR *m_pwszSource;

	ULONG m_ulLineNumber;
	LONG m_lCharacterPosition;
	SmartRef::WString m_wstrSourceLine;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\dll.cpp ===
//
// dll.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

/*#include "stdinc.h"

#include "oledll.h"
#include "dll.h"
#include "dmscript.h"
#include "track.h"
#include "engine.h"
#include "autperformance.h"
#include "autsegment.h"
#include "autsong.h"
#include "autsegmentstate.h"
#include "autaudiopathconfig.h"
#include "autaudiopath.h"
#include "dmscriptautguids.h"
#include "sourcetext.h"
#include "scriptthread.h"
#include "..\shared\xcreate.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Globals

#ifndef XBOX

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cLock = 0;

// Version information for our class
//
char g_szDMScriptFriendlyName[]						= "DirectMusic Script Object";
char g_szDMScriptVerIndProgID[]						= "Microsoft.DirectMusicScript";
char g_szDMScriptProgID[]							= "Microsoft.DirectMusicScript.1";

char g_szScriptTrackFriendlyName[]					= "DirectMusicScriptTrack";
char g_szScriptTrackVerIndProgID[]					= "Microsoft.DirectMusicScriptTrack";
char g_szScriptTrackProgID[]						= "Microsoft.DirectMusicScriptTrack.1";

char g_szAudioVBScriptFriendlyName[]				= "DirectMusic Audio VB Script Language";
char g_szAudioVBScriptVerIndProgID[]				= "AudioVBScript";
char g_szAudioVBScriptVerIndProgID_DMScript[]		= "AudioVBScript\\DMScript";
char g_szAudioVBScriptProgID[]						= "AudioVBScript.1";
char g_szAudioVBScriptProgID_DMScript[]				= "AudioVBScript.1\\DMScript";

char g_szDMScriptSourceTextFriendlyName[]			= "DirectMusic Script Source Code Loader";
char g_szDMScriptSourceTextVerIndProgID[]			= "Microsoft.DirectMusicScripSourceCodeLoader";
char g_szDMScriptSourceTextProgID[]					= "Microsoft.DirectMusicScripSourceCodeLoader.1";

char g_szDMScriptAutPerformanceFriendlyName[]		= "DirectMusic Script AutoImp Performance";
char g_szDMScriptAutPerformanceVerIndProgID[]		= "Microsoft.DirectMusicScriptAutoImpPerformance";
char g_szDMScriptAutPerformanceProgID[]				= "Microsoft.DirectMusicScriptAutoImpPerformance.1";

char g_szDMScriptAutSegmentFriendlyName[]			= "DirectMusic Script AutoImp Segment";
char g_szDMScriptAutSegmentVerIndProgID[]			= "Microsoft.DirectMusicScriptAutoImpSegment";
char g_szDMScriptAutSegmentProgID[]					= "Microsoft.DirectMusicScriptAutoImpSegment.1";

char g_szDMScriptAutSongFriendlyName[]				= "DirectMusic Script AutoImp Song";
char g_szDMScriptAutSongVerIndProgID[]				= "Microsoft.DirectMusicScriptAutoImpSong";
char g_szDMScriptAutSongProgID[]					= "Microsoft.DirectMusicScriptAutoImpSong.1";

char g_szDMScriptAutSegmentStateFriendlyName[]		= "DirectMusic Script AutoImp SegmentState";
char g_szDMScriptAutSegmentStateVerIndProgID[]		= "Microsoft.DirectMusicScriptAutoImpSegmentState";
char g_szDMScriptAutSegmentStateProgID[]			= "Microsoft.DirectMusicScriptAutoImpSegmentState.1";

char g_szDMScriptAutAudioPathConfigFriendlyName[]	= "DirectMusic Script AutoImp AudioPathConfig";
char g_szDMScriptAutAudioPathConfigVerIndProgID[]	= "Microsoft.DirectMusicScriptAutoImpAudioPathConfig";
char g_szDMScriptAutAudioPathConfigProgID[]			= "Microsoft.DirectMusicScriptAutoImpAudioPathConfig.1";

char g_szDMScriptAutAudioPathFriendlyName[]			= "DirectMusic Script AutoImp AudioPath";
char g_szDMScriptAutAudioPathVerIndProgID[]			= "Microsoft.DirectMusicScriptAutoImpAudioPath";
char g_szDMScriptAutAudioPathProgID[]				= "Microsoft.DirectMusicScriptAutoImpAudioPath.1";

#endif // XBOX

//////////////////////////////////////////////////////////////////////
// CDMScriptingFactory IUnknown methods

HRESULT __stdcall
CDMScriptingFactory::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDMScriptingFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IClassFactory)
		*ppv = static_cast<IClassFactory*>(this);
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CDMScriptingFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CDMScriptingFactory::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDMScriptingFactory IClassFactory methods

HRESULT __stdcall
CDMScriptingFactory::CreateInstance(IUnknown* pUnknownOuter,
									const IID& iid,
									void** ppv)
{
	V_INAME(CDMScriptingFactory::CreateInstance);
	V_INTERFACE_OPT(pUnknownOuter);
	V_PTR_WRITE(ppv, void*);

	try
	{
		return m_pfnCreate(pUnknownOuter, iid, ppv);
	}
	catch( ... )
	{
		return E_OUTOFMEMORY;
	}

	return E_NOINTERFACE;
}

HRESULT __stdcall
CDMScriptingFactory::LockServer(BOOL bLock)
{
	LockModule(!!bLock);
	return S_OK;
}

#ifndef XBOX

//////////////////////////////////////////////////////////////////////
// Dll entry points

STDAPI DllCanUnloadNow()
{
    if (g_cLock)
        return S_FALSE;

    return S_OK;
}

STDAPI DllGetClassObject
	(
	const CLSID& clsid,
	const IID& iid,
	void** ppv
	)
{
	IUnknown* pIUnknown = NULL;

	PFN_CreateInstance *pfnCreate = NULL;
	if (clsid == CLSID_DirectMusicScript)
	{
		pfnCreate = CDirectMusicScript::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicScriptTrack)
	{
		// I couldn't get it to compile if I just used TrackHelpCreateInstance<CDirectMusicScriptTrack>
		// for the function pointer so I created this function that calls it.
		struct LocalNonTemplateDeclaration
		{
			static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
			{
				return TrackHelpCreateInstance<CDirectMusicScriptTrack>(pUnknownOuter, iid, ppv);
			}
		};
		pfnCreate = LocalNonTemplateDeclaration::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicAudioVBScript)
	{
		pfnCreate = CAudioVBScriptEngine::CreateInstance;
	}
	else if (clsid == CLSID_DirectMusicSourceText)
	{
		pfnCreate = CSourceText::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicPerformance)
	{
		pfnCreate = CAutDirectMusicPerformance::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSegment)
	{
		pfnCreate = CAutDirectMusicSegment::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSong)
	{
		pfnCreate = CAutDirectMusicSong::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicSegmentState)
	{
		pfnCreate = CAutDirectMusicSegmentState::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
	{
		pfnCreate = CAutDirectMusicAudioPathConfig::CreateInstance;
	}
	else if (clsid == CLSID_AutDirectMusicAudioPath)
	{
		pfnCreate = CAutDirectMusicAudioPath::CreateInstance;
	}

	if (pfnCreate)
	{
		pIUnknown = static_cast<IUnknown*>(new CDMScriptingFactory(pfnCreate));
		if(!pIUnknown)
			return E_OUTOFMEMORY;
	}
	else
	{
		return CLASS_E_CLASSNOTAVAILABLE;
	}

	return pIUnknown->QueryInterface(iid, ppv);
}

#endif // XBOX

//////////////////////////////////////////////////////////////////////
// DirectMusicScriptCreate

STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript)
{
	return CDirectMusicScript::CreateInstance(NULL, iid, (void**) ppScript);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicScriptTrackCreate

STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack)
{
    return TrackHelpCreateInstance<CDirectMusicScriptTrack>(NULL, iid, (void**) ppTrack);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAutAudioPathConfigCreate

STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicAudioPathConfig::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAudioPathCreate

STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicAudioPath::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAutSongCreate

STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicSong::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAutPerformanceCreate

STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicPerformance::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAutSegmentCreate

STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicSegment::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAutSegmentCreate

STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto)
{
	return CAutDirectMusicSegmentState::CreateInstance(pUnkOuter, iid, (void**) ppAuto);
}

#ifndef XBOX

STDAPI DllUnregisterServer()
{
	UnregisterServer(
		CLSID_DirectMusicScript,
		g_szDMScriptFriendlyName,
		g_szDMScriptVerIndProgID,
		g_szDMScriptProgID);
	UnregisterServer(CLSID_DirectMusicScriptTrack,
		g_szScriptTrackFriendlyName,
		g_szScriptTrackVerIndProgID,
		g_szScriptTrackProgID);
	UnregisterServer(CLSID_DirectMusicAudioVBScript,
		g_szAudioVBScriptFriendlyName,
		g_szAudioVBScriptVerIndProgID,
		g_szAudioVBScriptProgID);
	UnregisterServer(
		CLSID_DirectMusicSourceText,
		g_szDMScriptSourceTextFriendlyName,
		g_szDMScriptSourceTextVerIndProgID,
		g_szDMScriptSourceTextProgID);
	UnregisterServer(CLSID_AutDirectMusicPerformance,
		g_szDMScriptAutPerformanceFriendlyName,
		g_szDMScriptAutPerformanceVerIndProgID,
		g_szDMScriptAutPerformanceProgID);
	UnregisterServer(CLSID_AutDirectMusicSegment,
		g_szDMScriptAutSegmentFriendlyName,
		g_szDMScriptAutSegmentVerIndProgID,
		g_szDMScriptAutSegmentProgID);
	UnregisterServer(CLSID_AutDirectMusicSong,
		g_szDMScriptAutSongFriendlyName,
		g_szDMScriptAutSongVerIndProgID,
		g_szDMScriptAutSongProgID);
	UnregisterServer(CLSID_AutDirectMusicSegmentState,
		g_szDMScriptAutSegmentStateFriendlyName,
		g_szDMScriptAutSegmentStateVerIndProgID,
		g_szDMScriptAutSegmentStateProgID);
	UnregisterServer(CLSID_AutDirectMusicAudioPathConfig,
		g_szDMScriptAutAudioPathConfigFriendlyName,
		g_szDMScriptAutAudioPathConfigVerIndProgID,
		g_szDMScriptAutAudioPathConfigProgID);
	UnregisterServer(CLSID_AutDirectMusicAudioPath,
		g_szDMScriptAutAudioPathFriendlyName,
		g_szDMScriptAutAudioPathVerIndProgID,
		g_szDMScriptAutAudioPathProgID);
	return S_OK;
}

STDAPI DllRegisterServer()
{
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicScript,
		g_szDMScriptFriendlyName,
		g_szDMScriptVerIndProgID,
		g_szDMScriptProgID);
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicScriptTrack,
		g_szScriptTrackFriendlyName,
		g_szScriptTrackVerIndProgID,
		g_szScriptTrackProgID);
	RegisterServer(
		g_hModule,
		CLSID_DirectMusicSourceText,
		g_szDMScriptSourceTextFriendlyName,
		g_szDMScriptSourceTextVerIndProgID,
		g_szDMScriptSourceTextProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicPerformance,
		g_szDMScriptAutPerformanceFriendlyName,
		g_szDMScriptAutPerformanceVerIndProgID,
		g_szDMScriptAutPerformanceProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSegment,
		g_szDMScriptAutSegmentFriendlyName,
		g_szDMScriptAutSegmentVerIndProgID,
		g_szDMScriptAutSegmentProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSong,
		g_szDMScriptAutSongFriendlyName,
		g_szDMScriptAutSongVerIndProgID,
		g_szDMScriptAutSongProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicSegmentState,
		g_szDMScriptAutSegmentStateFriendlyName,
		g_szDMScriptAutSegmentStateVerIndProgID,
		g_szDMScriptAutSegmentStateProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicAudioPathConfig,
		g_szDMScriptAutAudioPathConfigFriendlyName,
		g_szDMScriptAutAudioPathConfigVerIndProgID,
		g_szDMScriptAutAudioPathConfigProgID);
	RegisterServer(
		g_hModule,
		CLSID_AutDirectMusicAudioPath,
		g_szDMScriptAutAudioPathFriendlyName,
		g_szDMScriptAutAudioPathVerIndProgID,
		g_szDMScriptAutAudioPathProgID);

	RegisterServer(
		g_hModule,
		CLSID_DirectMusicAudioVBScript,
		g_szAudioVBScriptFriendlyName,
		g_szAudioVBScriptVerIndProgID,
		g_szAudioVBScriptProgID);
	// AudioVBScript also needs an additional DMScript key set to mark it as a custom scripting engine.
	HKEY hk;
	if (ERROR_SUCCESS == RegCreateKeyEx(
							HKEY_CLASSES_ROOT,
							g_szAudioVBScriptVerIndProgID_DMScript,
							0,
							NULL,
							0,
							KEY_ALL_ACCESS,
							NULL,
							&hk,
							NULL))
		RegCloseKey(hk);
	if (ERROR_SUCCESS == RegCreateKeyEx(
							HKEY_CLASSES_ROOT,
							g_szAudioVBScriptProgID_DMScript,
							0,
							NULL,
							0,
							KEY_ALL_ACCESS,
							NULL,
							&hk,
							NULL))
		RegCloseKey(hk);
	return S_OK;
}

#ifdef DBG
static char* aszReasons[] =
{
	"DLL_PROCESS_DETACH",
	"DLL_PROCESS_ATTACH",
	"DLL_THREAD_ATTACH",
	"DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY
DllMain
	(
	HINSTANCE hModule,
	DWORD dwReason,
	void *lpReserved
	)
{
	static int nReferenceCount = 0;

#ifdef DBG
	if (dwReason < nReasons)
	{
		Trace(1, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
	}
	else
	{
		Trace(1, "DllMain: Unknown dwReason <%u>\n", dwReason);
	}
#endif

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			if (++nReferenceCount == 1)
			{
				#ifdef DBG
					DebugInit();
				#endif

				if (!DisableThreadLibraryCalls(hModule))
				{
					Trace(1, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;
			}
			break;

		case DLL_PROCESS_DETACH:
			if (--nReferenceCount == 0)
			{
				Trace(1, "Unloading\n");
                // Assert if we still have some objects hanging around
                assert(g_cLock == 0);
			}
            break;
			
	}
		
	return TRUE;
}

#endif ! XBOX

//////////////////////////////////////////////////////////////////////
// Global Functions

#ifdef XBOX

void
LockModule(bool fLock)
{
}

long *GetModuleLockCounter()
{
	static long dummyLock;
	return &dummyLock;
}

#else

void
LockModule(bool fLock)
{
	if (fLock)
	{
		InterlockedIncrement(&g_cLock);
	}
	else
	{
		if (!InterlockedDecrement(&g_cLock))
		{
			// Clean up the shared thread used to talk to VBScript.  Needs to be done before the .dll could be unloaded,
			// which otherwise would make for problems because the thread could keep running while the .dll's address
			// space becomes invalid.
			CSingleThreadedScriptManager::TerminateThread();
		}
	}
}

long *GetModuleLockCounter()
{
	return &g_cLock;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engexpr.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of ExprBlock.
//

/*#include "stdinc.h"
#include "engexpr.h"*/

#include "pchscript.h"

HRESULT
Expression::Generate()
{
	HRESULT hr = InfixToPostfix();
	if (FAILED(hr))
	{
		// clean up the working stack
		while (!m_stack.empty())
			m_stack.pop();

		return hr;
	}

	return S_OK;
}

int Precedence(Token t)
{
	switch(t)
	{
	case TOKEN_op_pow:		return 10;
	case TOKEN_sub:			return 9; // unary - (negation)
	case TOKEN_op_mult:		return 8;
	case TOKEN_op_div:		return 7;
	case TOKEN_op_mod:		return 6;
	case TOKEN_op_plus:
	case TOKEN_op_minus:	return 5;
	case TOKEN_op_lt:
	case TOKEN_op_leq:
	case TOKEN_op_gt:
	case TOKEN_op_geq:
	case TOKEN_op_eq:
	case TOKEN_op_neq:
	case TOKEN_is:			return 4;
	case TOKEN_op_not:		return 3;
	case TOKEN_and:			return 2;
	case TOKEN_or:			return 1;
	case TOKEN_lparen:		return 0;
	default:
		assert(false);
		return 12;
	}
}

// Infix to postfix conversion is performed by a single scan of the infix expression blocks.
// A stack is used to hold some of the blocks before they eventually are appended to the postfix expression.
//
// The algorithm follows the following rules:
// * If the current item is an value it is immediately appended.
// * If the current item is an operator, pop and append each operator on the stack until one is encountered that:
//         - has lower precedence than the current operator OR
//         - is a left paren OR
//         - is a unary operator and the current item is also unary
//   Once done with this popping, push the current item onto the stack.
// * If the current item is a left paren, push it onto the stack.
// * If the current item is a right paren, pop and append all the operators until the matching left paren is found.
//   Discard the left and right paren as parens are not needed in postfix.
// * After scanning all items of the input, pop and append any operators that remain on the stack.
//
// Before working with this code, try out a few expressions on paper to see how this works.

HRESULT
Expression::InfixToPostfix()
{
	assert(m_stack.empty());

	HRESULT hr = S_OK;

	ExprBlocks::index iLast = m_e.Next();
	assert(iLast > 0);
	for (ExprBlocks::index i = 0; i < iLast; ++i)
	{
		const ExprBlock &b = m_e[i];
		if (b.k == ExprBlock::_val || b.k == ExprBlock::_call)
		{
			// this is an operand -- send it directly to the postfix output
			hr = m_eblocks.Add(b);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			if (b.op == TOKEN_rparen)
			{
				// pop whatever's left until the matching lparen
				for (;;)
				{
					if (m_stack.empty())
					{
						assert(false);
						return E_FAIL;
					}

					ExprBlock bPop = m_stack.top();
					if (bPop.op == TOKEN_lparen)
					{
						m_stack.pop();
						break;
					}
					hr = m_eblocks.Add(bPop);
					if (FAILED(hr))
						return hr;
					m_stack.pop();
				}
				continue;
			}
			else if (b.op != TOKEN_lparen)
			{
				// Pop all operators of lower precedence off the stack.  (This won't pass a left paren because its precedence is set to 0.)
				// Exception: don't pop a unary operator if the new one is also unary.
				int iNewPrecidence = Precedence(b.op);
				bool fNewUnary = b.op == TOKEN_sub || b.op == TOKEN_op_not;
				while (!m_stack.empty()) // note that there's a break inside the loop as well
				{
					ExprBlock bPop = m_stack.top();
					if (Precedence(bPop.op) < iNewPrecidence)
						break;

					if (fNewUnary && (bPop.op == TOKEN_sub || bPop.op == TOKEN_op_not))
						break;

					hr = m_eblocks.Add(bPop);
					if (FAILED(hr))
						return hr;
					m_stack.pop();
				}
			}

			// now push the new operator onto the stack
			hr = m_stack.push(b);
			if (FAILED(hr))
				return hr;
		}
	}

	while (!m_stack.empty())
	{
		ExprBlock bPop = m_stack.top();
		if (bPop.op == TOKEN_lparen)
		{
			assert(false);
			return E_FAIL;
		}
		hr = m_eblocks.Add(bPop);
		if (FAILED(hr))
			return hr;
		m_stack.pop();
	}

	// Add the teminating (_end) block
	hr = m_eblocks.Add(ExprBlock(ExprBlock::cons_end()));
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\enginc.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Standard included stuff for the AudioVBScript engine.
//

/*#include "stdinc.h"
#include "enginc.h"*/

#include "pchscript.h"

const char *g_rgszBuiltInConstants[] = { "true", "false", "nothing" };
const int g_cBuiltInConstants = ARRAY_SIZE(g_rgszBuiltInConstants);


DISPID
GetDispID(IDispatch *pIDispatch, const char *pszBase)
{
	SmartRef::WString wstrBase = pszBase;
	if (!wstrBase)
		return DISPID_UNKNOWN;

	DISPID dispid = DISPID_UNKNOWN;
	const WCHAR *wszBase = wstrBase;
	pIDispatch->GetIDsOfNames(IID_NULL, const_cast<WCHAR**>(&wszBase), 1, lcidUSEnglish, &dispid);
	return dispid;
}

// See oleaut.h for more info about why this is necessary.
HRESULT
InvokeAttemptingNotToUseOleAut(
		IDispatch *pDisp,
		DISPID dispIdMember,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr)
{
	if (g_fUseOleAut)
	{
		// Engine is set to always use oleaut32.dll.
		return pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}

	// Try not to use oleaut32.dll.
	HRESULT hr = pDisp->Invoke(dispIdMember, g_guidInvokeWithoutOleaut, lcidUSEnglish, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (hr != DISP_E_UNKNOWNINTERFACE)
		return hr;

	// It didn't like being called that way.  Must be some other scripting language or non-DMusic dispatch interface.
	// Use regular oleaut32.dll calling convention.
	if (pVarResult)
	{
		// We need to convert the return into our own kind of variant.
		VARIANT var;
		DMS_VariantInit(true, &var);
		hr = pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, &var, pExcepInfo, puArgErr);
		DMS_VariantCopy(false, pVarResult, &var);
		DMS_VariantClear(true, &var);
	}
	else
	{
		// There's no result so no conversion is necessary.
		hr = pDisp->Invoke(dispIdMember, IID_NULL, lcidUSEnglish, wFlags, pDispParams, NULL, pExcepInfo, puArgErr);
	}

	// If an exception occurred, we need to convert the error strings into our own kind of BSTR.
	if (hr == DISP_E_EXCEPTION)
		ConvertOleAutExceptionBSTRs(true, false, pExcepInfo);

	return hr;
}

HRESULT
SetDispatchProperty(IDispatch *pDisp, DISPID dispid, bool fSetRef, const VARIANT &v, EXCEPINFO *pExcepInfo)
{
	DISPID dispidPropPut = DISPID_PROPERTYPUT;
	DISPPARAMS dispparams;
	dispparams.rgvarg = const_cast<VARIANT*>(&v);
	dispparams.rgdispidNamedArgs = &dispidPropPut;
	dispparams.cArgs = 1;
	dispparams.cNamedArgs = 1;

	HRESULT hr = InvokeAttemptingNotToUseOleAut(
			pDisp,
			dispid,
			fSetRef ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT,
			&dispparams,
			NULL,
			pExcepInfo,
			NULL);
	return hr;
}

HRESULT
GetDispatchProperty(IDispatch *pDisp, DISPID dispid, VARIANT &v, EXCEPINFO *pExcepInfo)
{
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	HRESULT hr = InvokeAttemptingNotToUseOleAut(
			pDisp,
			dispid,
			DISPATCH_PROPERTYGET | DISPATCH_METHOD,
				// DISPATCH_METHOD is also set because in VB syntax a function with no parameters
				// can be accessed like a property.  Example "x = GetMasterGrooveLevel" is a
				// shortcut for "x = GetMasterGrooveLevel()".
			&dispparamsNoArgs,
			&v,
			pExcepInfo,
			NULL);
	return hr;
}

// If needed, converts the BSTRs in an EXCEPINFO structure between formats using or not using OleAut.
void ConvertOleAutExceptionBSTRs(bool fCurrentlyUsesOleAut, bool fResultUsesOleAut, EXCEPINFO *pExcepInfo)
{
	if (pExcepInfo && fCurrentlyUsesOleAut != fResultUsesOleAut)
	{
		BSTR bstrSource = pExcepInfo->bstrSource;
		BSTR bstrDescription = pExcepInfo->bstrDescription;
		BSTR bstrHelpFile = pExcepInfo->bstrHelpFile;

		pExcepInfo->bstrSource = DMS_SysAllocString(fResultUsesOleAut, bstrSource);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fResultUsesOleAut, bstrDescription);
		pExcepInfo->bstrHelpFile = DMS_SysAllocString(fResultUsesOleAut, bstrHelpFile);

		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrSource);
		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrDescription);
		DMS_SysFreeString(fCurrentlyUsesOleAut, bstrHelpFile);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engexpr.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Expression.
//

#pragma once

#include "engcontrol.h"

//    The expression class takes input of a well-formed expression in infix (the order appearing in the script source)
// notation.  The blocks are converted to postfix notation and appeanded to the given script's exprs list and followed
// with an _end block.
//    A working stack is used to perform the conversion.  The stack to use is passed by reference so that the same stack
// may be used to evaluate multiple expressions.  This allows the stack to grow as needed until it reaches the max size
// needed to process the expressions, minimizing reallocation thereafter.
class Expression
{
public:
	Expression(Script &script, SmartRef::Stack<ExprBlock> &stack, ExprBlocks *peblocks) : m_script(script), m_stack(stack), m_eblocks(peblocks ? *peblocks : m_script.exprs) {}

	// Note: For unary - (negation), use TOKEN_sub instead of TOKEN_op_minus.
	HRESULT Add(ExprBlock b) { if (b.k == ExprBlock::_end) {assert(false); return E_INVALIDARG;} return m_e.Add(b); }
	HRESULT Generate();

private:
	HRESULT InfixToPostfix();

private:
	ExprBlocks m_e;

	Script &m_script;
	SmartRef::Stack<ExprBlock> &m_stack;
	ExprBlocks &m_eblocks;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\dmscript.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScript.
//

// CDirectMusicScript is the script object.  A script object is loaded from a script file
// using the loader's GetObject method.  A script file contains source code in VBScript
// or another activeX scripting language.  Once loaded, the script object can be used
// to set and get the value of variables and to call routines inside the script.  The
// script routines can in turn call DirectMusic's automation model (or any other
// IDispatch-based API's).
//
// This allows programmers to separate the application's core C++ code from the
// API calls that to manipulate the musical score.  The application core loads
// scripts and calls routines at the appropriate times.  Sound designers implement
// those routines using any activeX scripting language.  The resulting scripts can
// be modified and auditioned without changing any code in the core application and
// without recompiling.

#pragma once
#include "scriptthread.h"
#include "containerdisp.h"
#include "dmusicf.h"
#include "..\shared\dmusicp.h"
#include "trackshared.h"

class CGlobalDispatch;

class CDirectMusicScript : public CMemTrack,
    public IDirectMusicScript,
	public IDirectMusicScriptPrivate,
	public IPersistStream,
	public IDirectMusicObject,
	public IDirectMusicObjectP,
	public IDispatch
{
friend class CGlobalDispatch;

public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions (only Load is implemented)
	STDMETHOD(GetClassID)(CLSID* pClassID) {return E_NOTIMPL;}
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream);
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject
	STDMETHOD(GetDescriptor)(LPDMUS_OBJECTDESC pDesc);
	STDMETHOD(SetDescriptor)(LPDMUS_OBJECTDESC pDesc);
	STDMETHOD(ParseDescriptor)(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

	// IDirectMusicScript
	STDMETHOD(Init)(IDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableVariant)(WCHAR *pwszVariableName, VARIANT varValue, BOOL fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableVariant)(WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
#ifdef XBOX
    STDMETHOD(CallRoutine)(const char *pszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableNumber)(const char *pszVariableName, LONG lValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableNumber)(const char *pszVariableName, LONG *plValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableObject)(const char *pszVariableName, IUnknown *punkValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableObject)(const char *pszVariableName, REFIID riid, LPVOID FAR *ppv, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
    STDMETHOD(SetVariableString)(const char *pszVariableName, const char *pszValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
    STDMETHOD(GetVariableString)(const char *pszVariableName, char *pszValue, LONG lBufferSize, LONG *plConverted, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
#else
	STDMETHOD(CallRoutine)(WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableNumber)(WCHAR *pwszVariableName, LONG lValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableNumber)(WCHAR *pwszVariableName, LONG *plValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(SetVariableObject)(WCHAR *pwszVariableName, IUnknown *punkValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	STDMETHOD(GetVariableObject)(WCHAR *pwszVariableName, REFIID riid, LPVOID FAR *ppv, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
#endif
    STDMETHOD(EnumRoutine)(DWORD dwIndex, WCHAR *pwszName);
	STDMETHOD(EnumVariable)(DWORD dwIndex, WCHAR *pwszName);

	// IDirectMusicScriptPrivate
	STDMETHOD(ScriptTrackCallRoutine)(
		WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags);

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

	// Methods that allow CActiveScriptManager access to private script interfaces
	IDispatch *GetGlobalDispatch();
	IDirectMusicPerformance8 *GetPerformance() { assert(m_pPerformance8); return m_pPerformance8; }
	IDirectMusicLoader8P *GetLoader8P() { return m_pLoader8P; }
	IDirectMusicComposer8 *GetComposer() { return m_pComposer8; }
	const WCHAR *GetFilename() { return m_info.wstrFilename; }

private:
	// Methods

	CDirectMusicScript();
	void ReleaseObjects();

	// Data

	CRITICAL_SECTION m_CriticalSection;
	bool m_fCriticalSectionInitialized;

	long m_cRef;
	bool m_fZombie;

	IDirectMusicPerformance8 *m_pPerformance8;
	IDirectMusicLoader8P *m_pLoader8P; // NULL if loader doesn't support private interface. Use AddRefP/ReleaseP.
	IDispatch *m_pDispPerformance;
	IDirectMusicComposer8 *m_pComposer8;

	// Standard object info
	struct HeaderInfo
	{
		// Descriptor info
		SmartRef::RiffIter::ObjectInfo oinfo;
		SmartRef::WString wstrFilename;
		bool fLoaded;
	} m_info;

	// Properties of the script
	DMUS_IO_SCRIPT_HEADER m_iohead;
	SmartRef::WString m_wstrLanguage;
	DMUS_VERSION m_vDirectMusicVersion;

	// Active Scripting
	bool m_fUseOleAut;
	ScriptManager *m_pScriptManager; // Reference-counted

	CContainerDispatch *m_pContainerDispatch;
	CGlobalDispatch *m_pGlobalDispatch;
	bool m_fInitError;
	DMUS_SCRIPT_ERRORINFO m_InitErrorInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\enginc.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Standard included stuff for the AudioVBScript engine.
//

#pragma once

#include "oleaut.h"

const LCID lcidUSEnglish = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
const bool g_fUseOleAut = false;

// Constants built into the langauge.  These will be treated as global variables and given fixed values.
extern const char *g_rgszBuiltInConstants[];
extern const int g_cBuiltInConstants;

// Helpers for working with IDispatch
DISPID GetDispID(IDispatch *pIDispatch, const char *pszBase); // returns DISPID_UNKNOWN on failure.
HRESULT InvokeAttemptingNotToUseOleAut(
			IDispatch *pDisp,
			DISPID dispIdMember,
			WORD wFlags,
			DISPPARAMS *pDispParams,
			VARIANT *pVarResult,
			EXCEPINFO *pExcepInfo,
			UINT *puArgErr);
HRESULT SetDispatchProperty(IDispatch *pDisp, DISPID dispid, bool fSetRef, const VARIANT &v, EXCEPINFO *pExcepInfo);
HRESULT GetDispatchProperty(IDispatch *pDisp, DISPID dispid, VARIANT &v, EXCEPINFO *pExcepInfo);
void ConvertOleAutExceptionBSTRs(bool fCurrentlyUsesOleAut, bool fResultUsesOleAut, EXCEPINFO *pExcepInfo);

// Holds a variant value.  Inits it on construction and clears it on destruction.  Any failure on clearing is ignored.
class SmartVariant
{
public:
	SmartVariant() { DMS_VariantInit(g_fUseOleAut, &m_v); }
	~SmartVariant() { DMS_VariantClear(g_fUseOleAut, &m_v); }

	operator VARIANT &() { return m_v; }
	VARIANT *operator &() { return &m_v; }

    void Clear(){ DMS_VariantClear(g_fUseOleAut, &m_v); DMS_VariantInit(g_fUseOleAut, &m_v); }

private:
	VARIANT m_v;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engine.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CAudioVBScriptEngine.
//

/*#include "stdinc.h"
#include "dll.h"
#include "engine.h"
#include "englex.h" // 
#include "engparse.h" // */

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Creation

CAudioVBScriptEngine::CAudioVBScriptEngine()
  : m_cRef(0)
{
	LockModule(true);
}

HRESULT
CAudioVBScriptEngine::CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
{
	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	CAudioVBScriptEngine *pInst = new CAudioVBScriptEngine;
	if (pInst == NULL)
		return E_OUTOFMEMORY;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CAudioVBScriptEngine::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CAudioVBScriptEngine::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IActiveScript)
	{
		*ppv = static_cast<IActiveScript*>(this);
	}
	else if (iid == IID_IActiveScriptParse)
	{
		*ppv = static_cast<IActiveScriptParse*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CAudioVBScriptEngine::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAudioVBScriptEngine::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IActiveScript

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::SetScriptSite(
		/* [in] */ IActiveScriptSite __RPC_FAR *pass)
{
	V_INAME(CAudioVBScriptEngine::SetScriptSite);
	V_INTERFACE(pass);

	m_scomActiveScriptSite = pass;
	pass->AddRef();
	return S_OK;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::Close(void)
{
	m_scomActiveScriptSite.Release();
	m_scomEngineDispatch.Release();
	return S_OK;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::AddNamedItem(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwFlags)
{
	// We only provide limited support for named items.  We only take a single global item.  We don't even remember its name.

	if (!m_scomActiveScriptSite || !(dwFlags & SCRIPTITEM_GLOBALMEMBERS) || m_scomGlobalDispatch)
		return E_UNEXPECTED;

	IUnknown *punkGlobal = NULL;
	HRESULT hr = m_scomActiveScriptSite->GetItemInfo(pstrName, SCRIPTINFO_IUNKNOWN, &punkGlobal, NULL);
	if (FAILED(hr))
		return hr;

	hr = punkGlobal->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&m_scomGlobalDispatch));
	punkGlobal->Release();
	return hr;
}

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::GetScriptDispatch(
		/* [in] */ LPCOLESTR pstrItemName,
		/* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp)
{
	V_INAME(CAudioVBScriptEngine::GetScriptDispatch);
	V_BUFPTR_READ_OPT(pstrItemName, 2);
	V_PTR_WRITE(ppdisp, IDispatch *);

	if (pstrItemName)
		return E_NOTIMPL;

	if (!m_scomEngineDispatch)
		m_scomEngineDispatch = new EngineDispatch(static_cast<IActiveScript*>(this), m_script, m_scomGlobalDispatch);
	if (!m_scomEngineDispatch)
		return E_OUTOFMEMORY;
	
	return m_scomEngineDispatch->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(ppdisp));
}

//////////////////////////////////////////////////////////////////////
// IActiveScriptParse

HRESULT STDMETHODCALLTYPE
CAudioVBScriptEngine::ParseScriptText(
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ IUnknown __RPC_FAR *punkContext,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ VARIANT __RPC_FAR *pvarResult,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo)
{
	V_INAME(CAudioVBScriptEngine::ParseScriptText);
	V_BUFPTR_READ(pstrCode, 2);

	if (pstrItemName || pstrDelimiter || ulStartingLineNumber != 0 || dwFlags != 0 || pvarResult)
		return E_UNEXPECTED;

	Lexer lexer(pstrCode);
	Parser p(lexer, m_script, m_scomActiveScriptSite, m_scomGlobalDispatch);
	return p.hr();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engine.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CAudioVBScriptEngine.
//

// CAudioVBScriptEngine is an ActiveX scripting engine that supports a carefully chosen subset of the VBScript language.
// It's goal in life is to be as small and fast as possible and to run on every platform that ports DirectMusic.

#pragma once

#include "activscp.h"
#include "engdisp.h"

const GUID CLSID_DirectMusicAudioVBScript = { 0x4ee17959, 0x931e, 0x49e4, { 0xa2, 0xc6, 0x97, 0x7e, 0xcf, 0x36, 0x28, 0xf3 } }; // {4EE17959-931E-49e4-A2C6-977ECF3628F3}

class CAudioVBScriptEngine
  : public IActiveScript,
	public IActiveScriptParse
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IActiveScript
	HRESULT STDMETHODCALLTYPE SetScriptSite(
		/* [in] */ IActiveScriptSite __RPC_FAR *pass);
	HRESULT STDMETHODCALLTYPE GetScriptSite(
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE SetScriptState(
		/* [in] */ SCRIPTSTATE ss) { return S_OK; }
	HRESULT STDMETHODCALLTYPE GetScriptState(
		/* [out] */ SCRIPTSTATE __RPC_FAR *pssState) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Close(void);
	HRESULT STDMETHODCALLTYPE AddNamedItem(
		/* [in] */ LPCOLESTR pstrName,
		/* [in] */ DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE AddTypeLib(
		/* [in] */ REFGUID rguidTypeLib,
		/* [in] */ DWORD dwMajor,
		/* [in] */ DWORD dwMinor,
		/* [in] */ DWORD dwFlags) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptDispatch(
		/* [in] */ LPCOLESTR pstrItemName,
		/* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
	HRESULT STDMETHODCALLTYPE GetCurrentScriptThreadID(
		/* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptThreadID(
		/* [in] */ DWORD dwWin32ThreadId,
		/* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE GetScriptThreadState(
		/* [in] */ SCRIPTTHREADID stidThread,
		/* [out] */ SCRIPTTHREADSTATE __RPC_FAR *pstsState) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE InterruptScriptThread(
		/* [in] */ SCRIPTTHREADID stidThread,
		/* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo,
		/* [in] */ DWORD dwFlags) { return E_NOTIMPL; }
	HRESULT STDMETHODCALLTYPE Clone(
		/* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppscript) { return E_NOTIMPL; }

	// IActiveScriptParse
    HRESULT STDMETHODCALLTYPE InitNew(void) { return S_OK; }
    HRESULT STDMETHODCALLTYPE AddScriptlet(
        /* [in] */ LPCOLESTR pstrDefaultName,
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ LPCOLESTR pstrSubItemName,
        /* [in] */ LPCOLESTR pstrEventName,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ BSTR __RPC_FAR *pbstrName,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo) { return E_NOTIMPL; }
    HRESULT STDMETHODCALLTYPE ParseScriptText(
        /* [in] */ LPCOLESTR pstrCode,
        /* [in] */ LPCOLESTR pstrItemName,
        /* [in] */ IUnknown __RPC_FAR *punkContext,
        /* [in] */ LPCOLESTR pstrDelimiter,
        /* [in] */ DWORD dwSourceContextCookie,
        /* [in] */ ULONG ulStartingLineNumber,
        /* [in] */ DWORD dwFlags,
        /* [out] */ VARIANT __RPC_FAR *pvarResult,
        /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);

private:
	// Methods
	CAudioVBScriptEngine();

	// Data
	long m_cRef;
	SmartRef::ComPtr<IActiveScriptSite> m_scomActiveScriptSite;
	SmartRef::ComPtr<EngineDispatch> m_scomEngineDispatch;

	Script m_script;
	SmartRef::ComPtr<IDispatch> m_scomGlobalDispatch;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\containerdisp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CContainerDispatch.
//

/*#include "stdinc.h"
#include "containerdisp.h"
#include "oleaut.h"
#include "dmusicf.h"
#include "activescript.h"
#include "authelper.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// CContainerItemDispatch

CContainerItemDispatch::CContainerItemDispatch(
		IDirectMusicLoader *pLoader,
		const WCHAR *wszAlias,
		const DMUS_OBJECTDESC &desc,
		bool fPreload,
		bool fAutodownload,
		HRESULT *phr)
  : m_pLoader(pLoader),
	m_pLoader8P(NULL),
	m_wstrAlias(wszAlias),
	m_desc(desc),
	m_fLoaded(false),
	m_pDispLoadedItem(NULL),
	m_fAutodownload(fAutodownload),
	m_pPerfForUnload(NULL)
{
	assert(pLoader && phr);
	*phr = S_OK;

	HRESULT hr = m_pLoader->QueryInterface(IID_IDirectMusicLoader8P, reinterpret_cast<void**>(&m_pLoader8P));
	if (SUCCEEDED(hr))
	{
		// Hold only a private ref on the loader.  See IDirectMusicLoader8P::AddRefP for more info.
		m_pLoader8P->AddRefP();
		m_pLoader->Release(); // offset the QI
	}
	else
	{
		// It's OK if there's no private interface.  We just won't tell the garbage collector about stuff we load.
		// And we hold a normal reference.
		m_pLoader->AddRef();
	}

	if (fPreload)
		*phr = this->Load(false);
}

CContainerItemDispatch::~CContainerItemDispatch()
{
	if (m_pPerfForUnload)
	{
		// We need to unload to correspond with the automatic download done when we were loaded.
		this->DownloadOrUnload(false, m_pPerfForUnload);
	}

	SafeRelease(m_pPerfForUnload);
	ReleaseLoader();
	SafeRelease(m_pDispLoadedItem);
}

STDMETHODIMP
CContainerItemDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	// If we're loaded and have a dispatch interface, defer to the real object.
	if (m_pDispLoadedItem)
		return m_pDispLoadedItem->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);

	// Otherwise implement just the Load method.
	return AutLoadDispatchGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

STDMETHODIMP
CContainerItemDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	// If we're loaded and have a dispatch interface, defer to the real object.
	if (m_pDispLoadedItem)
		return m_pDispLoadedItem->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);

	// Otherwise implement just the Load method.
	bool fUseOleAut = false;
	HRESULT hr = AutLoadDispatchInvoke(&fUseOleAut, dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	if (FAILED(hr))
		return hr;

	InitWithPerfomanceFailureType eFailureType = IWP_Success;

	hr = m_fLoaded
			? S_OK					// if we've already been loaded, load can be called again and is a no-op
			: this->Load(true);		// otherwise, actually load the object

	if (SUCCEEDED(hr))
	{
		IDirectMusicPerformance *pPerf = CActiveScriptManager::GetCurrentPerformanceWEAK();
		if (pPerf)
		{
			hr = this->InitWithPerformance(pPerf, &eFailureType);
		}
		else
		{
			assert(false);
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		return hr; // everything worked--we're done

	// From here on, we've failed and need to return an exception.
	if (!pExcepInfo)
		return DISP_E_EXCEPTION;

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(fUseOleAut, L"Microsoft DirectMusic Runtime Error");

	const WCHAR *pwszErrorBeg = NULL;
	if (eFailureType == IWP_DownloadFailed)
	{
		pwszErrorBeg = L"Unable to download the requested content (";
	}
	else if (eFailureType == IWP_ScriptInitFailed && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
	{
		pwszErrorBeg = L"Syntax error loading the requested script (";
	}
	else
	{
		// Must have been a problem before InitWithPerformance or a problem with the script
		// that wasn't a syntax error.
		pwszErrorBeg = L"Unable to load the requested content (";
	}

	static const WCHAR wszErrorEnd[] = L".Load)";
	WCHAR *pwszDescription = new WCHAR[wcslen(pwszErrorBeg) + wcslen(m_wstrAlias) + wcslen(wszErrorEnd) + 1];
	if (!pwszDescription)
	{
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, pwszErrorBeg);
		wcscat(pwszDescription, m_wstrAlias);
		wcscat(pwszDescription, wszErrorEnd);
		pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = hr;

	return DISP_E_EXCEPTION;
}

HRESULT
CContainerItemDispatch::InitWithPerformance(IDirectMusicPerformance *pPerf, InitWithPerfomanceFailureType *peFailureType)
{
	if (!m_fLoaded || !pPerf || !peFailureType)
	{
		assert(false);
		return E_FAIL;
	}

	*peFailureType = IWP_Success;

	if (!m_pDispLoadedItem)
		return S_OK; // don't have an active item so no initialization is necessary

	HRESULT hr = S_OK;
	if (m_fAutodownload)
	{
		hr = this->DownloadOrUnload(true, pPerf);
		if (hr == S_OK)
		{
			m_pPerfForUnload = pPerf;
			m_pPerfForUnload->AddRef();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_DownloadFailed;
			return hr;
		}
	}

	if (m_desc.guidClass == CLSID_DirectMusicScript)
	{
		IDirectMusicScript *pScript = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicScript, reinterpret_cast<void**>(&pScript));
		if (SUCCEEDED(hr))
		{
			hr = pScript->Init(pPerf, NULL);
			pScript->Release();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_ScriptInitFailed;
			return hr;
		}
	}
	else if (m_desc.guidClass == CLSID_DirectMusicSong)
	{
		IDirectMusicSong *pSong = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSong, reinterpret_cast<void**>(&pSong));
		if (SUCCEEDED(hr))
		{
			hr = pSong->Compose();
			pSong->Release();
		}
		if (FAILED(hr))
		{
			*peFailureType = IWP_DownloadFailed;
			return hr;
		}
	}

	return S_OK;
}

void CContainerItemDispatch::ReleaseLoader()
{
	if (m_pLoader8P)
	{
		// If we had the private interface, we just need to do a private release.
		m_pLoader8P->ReleaseP();
		m_pLoader8P = NULL;
		m_pLoader = NULL;
	}
	else
	{
		// We just have the public interface, so do a normal release.
		SafeRelease(m_pLoader);
	}
}

HRESULT
CContainerItemDispatch::Load(bool fDynamicLoad)
{
	HRESULT hr = S_OK;
	assert(m_pLoader);

	IUnknown *punkLoadedItem = NULL;
	if (fDynamicLoad && m_pLoader8P)
	{
		IDirectMusicObject *pScriptObject = CActiveScriptManager::GetCurrentScriptObjectWEAK();
		hr = m_pLoader8P->GetDynamicallyReferencedObject(pScriptObject, &m_desc, IID_IUnknown, reinterpret_cast<void**>(&punkLoadedItem));
	}
	else
	{
		// It's OK if there's no private interface.  We just won't tell the garbage collector about this load.
		hr = m_pLoader->GetObject(&m_desc, IID_IUnknown, reinterpret_cast<void**>(&punkLoadedItem));
	}

	if (SUCCEEDED(hr))
	{
		assert(punkLoadedItem);
		ReleaseLoader();
		m_fLoaded = true;

		// save the object's IDispatch interface, if it has one
		punkLoadedItem->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&m_pDispLoadedItem));
		punkLoadedItem->Release();
	}
	return hr;
}

HRESULT
CContainerItemDispatch::DownloadOrUnload(bool fDownload, IDirectMusicPerformance *pPerf)
{
	HRESULT hr = S_OK;
	if (m_desc.guidClass == CLSID_DirectMusicSegment)
	{
		assert(pPerf);
		IDirectMusicSegment8 *pSegment = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSegment8, reinterpret_cast<void**>(&pSegment));
		if (FAILED(hr))
			return hr;
		hr = fDownload
				? pSegment->Download(pPerf)
				: pSegment->Unload(pPerf);
		pSegment->Release();
	}
	else if (m_desc.guidClass == CLSID_DirectMusicSong)
	{
		assert(pPerf);
		IDirectMusicSong8 *pSong = NULL;
		hr = m_pDispLoadedItem->QueryInterface(IID_IDirectMusicSong8, reinterpret_cast<void**>(&pSong));
		if (FAILED(hr))
			return hr;
		hr = fDownload
				? pSong->Download(pPerf)
				: pSong->Unload(pPerf);
		pSong->Release();
	}
	else
	{
		hr = S_FALSE; // this type of object doesn't need to be downloaded
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CContainerDispatch

CContainerDispatch::CContainerDispatch(IDirectMusicContainer *pContainer, IDirectMusicLoader *pLoader, DWORD dwScriptFlags, HRESULT *phr)
{
	assert(pContainer && pLoader && phr);

	*phr = S_OK;
	DMUS_OBJECTDESC desc;
	ZeroAndSize(&desc);
	WCHAR wszAlias[MAX_PATH] = L"";

	// we need to download all the segments when the script is initialized if both loading and downloading are on
	bool fLoad = !!(dwScriptFlags & DMUS_SCRIPTIOF_LOAD_ALL_CONTENT);
	bool fDownload = !!(dwScriptFlags & DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS);
	m_fDownloadOnInit = fLoad && fDownload;

	DWORD i = 0;
	for (;;)
	{
		// Read an item out of the container
		*phr = pContainer->EnumObject(GUID_DirectMusicAllTypes, i, &desc, wszAlias);
		if (FAILED(*phr))
			return;
		if (*phr == S_FALSE)
		{
			// we've read all the items
			*phr = S_OK;
			return;
		}

		// Make an object to represent the item
		CContainerItemDispatch *pNewItem = new CContainerItemDispatch(
													pLoader,
													wszAlias,
													desc,
													fLoad,
													fDownload,
													phr);
		if (!pNewItem)
			*phr = E_OUTOFMEMORY;
		if (FAILED(*phr))
		{
            if(pNewItem)
            {
			    pNewItem->Release();
            }

			return;
		}

		// Add an entry to the table
		UINT iSlot = m_vecItems.size();
		if (!m_vecItems.AccessTo(iSlot))
		{
			pNewItem->Release();
			*phr = E_OUTOFMEMORY;
			return;
		}
		m_vecItems[iSlot] = pNewItem;

		// Set up for next iteration
		ZeroAndSize(&desc);
		wszAlias[0] = L'\0';
		++i;
	}
}

CContainerDispatch::~CContainerDispatch()
{
	UINT iEnd = m_vecItems.size();
	for (UINT i = 0; i < m_vecItems.size(); ++i)
	{
		m_vecItems[i]->Release();
	}
}

HRESULT
CContainerDispatch::OnScriptInit(IDirectMusicPerformance *pPerf)
{
	if (m_fDownloadOnInit)
	{
		UINT iEnd = m_vecItems.size();
		for (UINT i = 0; i < m_vecItems.size(); ++i)
		{
			CContainerItemDispatch::InitWithPerfomanceFailureType eFailureType;
			m_vecItems[i]->InitWithPerformance(pPerf, &eFailureType);
		}
	}

	return S_OK;
}

HRESULT
CContainerDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	// Otherwise implement just the Load method.
	V_INAME(CContainerDispatch::GetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	// See if we have a method with the first name
	UINT cEnd = m_vecItems.size();
	for (c = 0; c < cEnd; ++c)
	{
		if (0 == _wcsicmp(rgszNames[0], m_vecItems[c]->Alias()))
		{
			rgDispId[0] = c + 1;
			break;
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

HRESULT
CContainerDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	V_INAME(CContainerDispatch::Invoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(pExcepInfo, EXCEPINFO);

	bool fUseOleAut = !!(riid == IID_NULL);

	// Additional parameter validation

	if (!fUseOleAut && riid != g_guidInvokeWithoutOleaut)
		return DISP_E_UNKNOWNINTERFACE;

	if (!(wFlags & DISPATCH_PROPERTYGET))
		return DISP_E_MEMBERNOTFOUND;

	if (pDispParams->cArgs > 0)
		return DISP_E_BADPARAMCOUNT;

	if (pDispParams->cNamedArgs > 0)
		return DISP_E_NONAMEDARGS;

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	if (pVarResult)
	{
		DMS_VariantInit(fUseOleAut, pVarResult);
	}

	if (dispIdMember > (DISPID) m_vecItems.size())
		return DISP_E_MEMBERNOTFOUND;

	// Return the value
	if (pVarResult)
	{
		pVarResult->vt = VT_DISPATCH;
		pVarResult->pdispVal = m_vecItems[dispIdMember - 1]->Item();
		pVarResult->pdispVal->AddRef();
	}

	return S_OK;
}

HRESULT
CContainerDispatch::EnumItem(DWORD dwIndex, WCHAR *pwszName)
{
	if (dwIndex >= m_vecItems.size())
		return S_FALSE;

	CContainerItemDispatch *pItem = m_vecItems[dwIndex];
	return wcsTruncatedCopy(pwszName, pItem->Alias(), MAX_PATH);
}

HRESULT
CContainerDispatch::GetVariableObject(WCHAR *pwszVariableName, IUnknown **ppunkValue)
{
	assert(pwszVariableName && ppunkValue);
	UINT cEnd = m_vecItems.size();
	for (UINT c = 0; c < cEnd; ++c)
	{
		if (0 == _wcsicmp(pwszVariableName, m_vecItems[c]->Alias()))
		{
			*ppunkValue = m_vecItems[c]->Item();
			(*ppunkValue)->AddRef();
			return S_OK;
		}
	}
	return DMUS_E_SCRIPT_VARIABLE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\dmscript.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of CDirectMusicScript.
//

/*#include "stdinc.h"
#include "dll.h"
#include "dmscript.h"
#include "oleaut.h"
#include "globaldisp.h"
#include "activescript.h"
#include "sourcetext.h"
#include "..\shared\xcreate.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Creation

CDirectMusicScript::CDirectMusicScript()
  : m_cRef(0),
	m_fZombie(false),
	m_fCriticalSectionInitialized(false),
	m_pPerformance8(NULL),
	m_pLoader8P(NULL),
	m_pDispPerformance(NULL),
	m_pComposer8(NULL),
	m_fUseOleAut(true),
	m_pScriptManager(NULL),
	m_pContainerDispatch(NULL),
	m_pGlobalDispatch(NULL),
	m_fInitError(false), 
    CMemTrack(DMTRACK_SCRIPT)
{
	LockModule(true);
	INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
	m_fCriticalSectionInitialized = TRUE;

	m_info.fLoaded = false;
	m_vDirectMusicVersion.dwVersionMS = 0;
	m_vDirectMusicVersion.dwVersionLS = 0;
	Zero(&m_iohead);
	ZeroAndSize(&m_InitErrorInfo);
}

void CDirectMusicScript::ReleaseObjects()
{
	if (m_pScriptManager)
	{
		m_pScriptManager->Close();
		SafeRelease(m_pScriptManager);
	}
	SafeRelease(m_pPerformance8);
	SafeRelease(m_pDispPerformance);
	if (m_pLoader8P)
	{
		m_pLoader8P->ReleaseP();
		m_pLoader8P = NULL;
	}
	SafeRelease(m_pComposer8);
	delete m_pContainerDispatch;
	m_pContainerDispatch = NULL;
	delete m_pGlobalDispatch;
	m_pGlobalDispatch = NULL;
}

HRESULT CDirectMusicScript::CreateInstance(
		IUnknown* pUnknownOuter,
		const IID& iid,
		void** ppv)
{
	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	CDirectMusicScript *pInst = new CDirectMusicScript;
	if (pInst == NULL)
		return E_OUTOFMEMORY;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CDirectMusicScript::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicScript::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicScript)
	{
		*ppv = static_cast<IDirectMusicScript*>(this);
	}
	else if (iid == IID_IDirectMusicScriptPrivate)
	{
		*ppv = static_cast<IDirectMusicScriptPrivate*>(this);
	}
	else if (iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if (iid == IID_IDirectMusicObjectP)
	{
		*ppv = static_cast<IDirectMusicObjectP*>(this);
	}
	else if (iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if (iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else if (iid == IID_IDispatch)
	{
		*ppv = static_cast<IDispatch*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CDirectMusicScript::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CDirectMusicScript::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		this->Zombie();
		DELETE_CRITICAL_SECTION(&m_CriticalSection);
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP
CDirectMusicScript::Load(IStream* pStream)
{
	V_INAME(CDirectMusicScript::Load);
	V_INTERFACE(pStream);

	CHECK_ZOMBIE(m_fZombie);

	HRESULT hr = S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	// Clear any old info
	this->ReleaseObjects();
	m_info.fLoaded = false;
	m_info.oinfo.Clear();
	m_vDirectMusicVersion.dwVersionMS = 0;
	m_vDirectMusicVersion.dwVersionLS = 0;
	m_wstrLanguage = NULL;
	m_fInitError = false;

	// Get the loader from stream
	IDirectMusicGetLoader *pIDMGetLoader = NULL;
	SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
	hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void **>(&pIDMGetLoader));
	if (FAILED(hr))
	{
		Trace(1, "Error: unable to load script from a stream because it doesn't support the IDirectMusicGetLoader interface.\n");
		return DMUS_E_UNSUPPORTED_STREAM;
	}

	hr = pIDMGetLoader->GetLoader(&scomLoader);
	pIDMGetLoader->Release();
	if (FAILED(hr))
		return hr;

	hr = scomLoader->QueryInterface(IID_IDirectMusicLoader8P, reinterpret_cast<void **>(&m_pLoader8P)); // OK if this fails -- just means the scripts won't be garbage collected
	if (SUCCEEDED(hr))
	{
		// Hold only a private ref on the loader.  See IDirectMusicLoader8P::AddRefP for more info.
		m_pLoader8P->AddRefP();
		m_pLoader8P->Release(); // offset the QI
	}

	// Read the script's header information

	SmartRef::RiffIter riForm(pStream);
	if (!riForm)
	{
#ifdef DBG
		if (SUCCEEDED(riForm.hr()))
		{
			Trace(1, "Error: Unable to load script: Unexpected end of file.\n");
		}
#endif
		return SUCCEEDED(riForm.hr()) ? DMUS_E_SCRIPT_INVALID_FILE : riForm.hr();
	}
	hr = riForm.FindRequired(SmartRef::RiffIter::Riff, DMUS_FOURCC_SCRIPT_FORM, DMUS_E_SCRIPT_INVALID_FILE);
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == DMUS_E_SCRIPT_INVALID_FILE)
		{
			Trace(1, "Error: Unable to load script: Form 'DMSC' not found.\n");
		}
#endif
		return hr;
	}

	SmartRef::RiffIter ri = riForm.Descend();
	if (!ri)
		return ri.hr();

	hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPT_CHUNK, DMUS_E_SCRIPT_INVALID_FILE);
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == DMUS_E_SCRIPT_INVALID_FILE)
		{
			Trace(1, "Error: Unable to load script: Chunk 'schd' not found.\n");
		}
#endif
		return hr;
	}

	hr = SmartRef::RiffIterReadChunk(ri, &m_iohead);
	if (FAILED(hr))
		return hr;

	hr = ri.LoadObjectInfo(&m_info.oinfo, SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTVERSION_CHUNK);
	if (FAILED(hr))
		return hr;

	hr = SmartRef::RiffIterReadChunk(ri, &m_vDirectMusicVersion);
	if (FAILED(hr))
		return hr;

	// Read the script's embedded container
	IDirectMusicContainer *pContainer = NULL;
	hr = ri.FindAndGetEmbeddedObject(
				SmartRef::RiffIter::Riff,
				DMUS_FOURCC_CONTAINER_FORM,
				DMUS_E_SCRIPT_INVALID_FILE,
				scomLoader,
				CLSID_DirectMusicContainer,
				IID_IDirectMusicContainer,
				reinterpret_cast<void**>(&pContainer));
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == DMUS_E_SCRIPT_INVALID_FILE)
		{
			Trace(1, "Error: Unable to load script: Form 'DMCN' no found.\n");
		}
#endif
		return hr;
	}

	// Build the container object that will represent the items in the container to the script

	m_pContainerDispatch = new CContainerDispatch(pContainer, scomLoader, m_iohead.dwFlags, &hr);
	pContainer->Release();
	if (!m_pContainerDispatch)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	// Create the global dispatch object

	m_pGlobalDispatch = new CGlobalDispatch(this);
	if (!m_pGlobalDispatch)
		return E_OUTOFMEMORY;

	// Get the script's language

	hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK, DMUS_E_SCRIPT_INVALID_FILE);
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == DMUS_E_SCRIPT_INVALID_FILE)
		{
			Trace(1, "Error: Unable to load script: Chunk 'scla' no found.\n");
		}
#endif
		return hr;
	}

	hr = ri.ReadText(&m_wstrLanguage);
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == E_FAIL)
		{
			Trace(1, "Error: Unable to load script: Problem reading 'scla' chunk.\n");
		}
#endif
		return hr == E_FAIL ? DMUS_E_SCRIPT_INVALID_FILE : hr;
	}

	// Get the script's source code

	SmartRef::WString wstrSource;
	for (++ri; ;++ri)
	{
		if (!ri)
		{
			Trace(1, "Error: Unable to load script: Expected chunk 'scsr' or list 'DMRF'.\n");
			return DMUS_E_SCRIPT_INVALID_FILE;
		}

		SmartRef::RiffIter::RiffType type = ri.type();
		FOURCC id = ri.id();

		if (type == SmartRef::RiffIter::Chunk)
		{
			if (id == DMUS_FOURCC_SCRIPTSOURCE_CHUNK)
			{
				hr = ri.ReadText(&wstrSource);
				if (FAILED(hr))
				{
#ifdef DBG
					if (hr == E_FAIL)
					{
						Trace(1, "Error: Unable to load script: Problem reading 'scsr' chunk.\n");
					}
#endif
					return hr == E_FAIL ? DMUS_E_SCRIPT_INVALID_FILE : hr;
				}
			}
			break;
		}
		else if (type == SmartRef::RiffIter::List)
		{
			if (id == DMUS_FOURCC_REF_LIST)
			{
				DMUS_OBJECTDESC desc;
				hr = ri.ReadReference(&desc);
				if (FAILED(hr))
					return hr;
				// The resulting desc shouldn't have a name or GUID (the plain text file can't hold name/GUID info)
				// and it should have a clsid should be GUID_NULL, which we'll replace with the clsid of our private
				// source helper object.
				if (desc.dwValidData & (DMUS_OBJ_NAME | DMUS_OBJ_OBJECT) ||
						!(desc.dwValidData & DMUS_OBJ_CLASS) || desc.guidClass != GUID_NULL)
				{
#ifdef DBG
					if (desc.dwValidData & (DMUS_OBJ_NAME | DMUS_OBJ_OBJECT))
					{
						Trace(1, "Error: Unable to load script: 'DMRF' list must have dwValidData with DMUS_OBJ_CLASS and guidClassID of GUID_NULL.\n");
					}
					else
					{
						Trace(1, "Error: Unable to load script: 'DMRF' list cannot have dwValidData with DMUS_OBJ_NAME or DMUS_OBJ_OBJECT.\n");
					}
#endif
					return DMUS_E_SCRIPT_INVALID_FILE;
				}
				desc.guidClass = CLSID_DirectMusicSourceText;
				IDirectMusicSourceText *pISource = NULL;
				hr = scomLoader->EnableCache(CLSID_DirectMusicSourceText, false); // This is a private object we just use temporarily. Don't want these guys hanging around in the cache.
				if (FAILED(hr))
					return hr;
				hr = scomLoader->GetObject(&desc, IID_IDirectMusicSourceText, reinterpret_cast<void**>(&pISource));
				if (FAILED(hr))
					return hr;
				DWORD cwchSourceBufferSize = 0;
				pISource->GetTextLength(&cwchSourceBufferSize);
				WCHAR *pwszSource = new WCHAR[cwchSourceBufferSize];
				if (!pwszSource)
					return E_OUTOFMEMORY;
				pISource->GetText(pwszSource);
				*&wstrSource = pwszSource;
				pISource->Release();
			}
			break;
		}
	}

	m_info.fLoaded = true;

	// Now that we are loaded and initialized, we can start active scripting

#ifdef XBOX
	bool fCustomScriptEngine = TRUE;
#else // XBOX
	// See if we're dealing with a custom DirectMusic scripting engine.  Such engines are marked with the key DMScript.  They can be
	// called on multiple threads and they don't use oleaut32.  Ordinary active scripting engines are marked with the key OLEScript.
	SmartRef::HKey shkeyLanguage;
	SmartRef::HKey shkeyMark;
	SmartRef::AString astrLanguage = m_wstrLanguage;
	if (ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, astrLanguage, 0, KEY_QUERY_VALUE, &shkeyLanguage) || !shkeyLanguage)
	{
		Trace(1, "Error: Unable to load script: Scripting engine for language %s does not exist or is not registered.\n", astrLanguage);
		return DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
	}
	bool fCustomScriptEngine = ERROR_SUCCESS == ::RegOpenKeyEx(shkeyLanguage, "DMScript", 0, KEY_QUERY_VALUE, &shkeyMark) && shkeyMark;
	if (!fCustomScriptEngine)
	{
		if (ERROR_SUCCESS != ::RegOpenKeyEx(shkeyLanguage, "OLEScript", 0, KEY_QUERY_VALUE, &shkeyMark) || !shkeyMark)
		{
			Trace(1, "Error: Unable to load script: Language %s refers to a COM object that is not registered as a scripting engine (OLEScript key).\n", astrLanguage);
			return DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE;
		}
	}
#endif // XBOX

	m_fUseOleAut = !fCustomScriptEngine;
	if (fCustomScriptEngine)
	{
		m_pScriptManager = new CActiveScriptManager(
										m_fUseOleAut,
										m_wstrLanguage,
										wstrSource,
										this,
										&hr,
										&m_InitErrorInfo);
	}
#ifndef XBOX
	else
	{
		m_pScriptManager = new CSingleThreadedScriptManager(
										m_fUseOleAut,
										m_wstrLanguage,
										wstrSource,
										this,
										&hr,
										&m_InitErrorInfo);
	}
#endif
	if (!m_pScriptManager)
		return E_OUTOFMEMORY;

	if (FAILED(hr))
	{
		SafeRelease(m_pScriptManager);
	}

	if (hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
	{
		// If we fail here, load would fail and client would never be able to get the
		// error information.  Instead, return S_OK and save the error to return from Init.
		m_fInitError = true;
		hr = S_OK;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP 
CDirectMusicScript::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	V_INAME(CDirectMusicScript::GetDescriptor);
	V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
	
	ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
	pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

	CHECK_ZOMBIE(m_fZombie);
	
	if (wcslen(m_info.oinfo.wszName) > 0)
	{
		pDesc->dwValidData |= DMUS_OBJ_NAME;
		wcscpy(pDesc->wszName, m_info.oinfo.wszName);
		pDesc->wszName[DMUS_MAX_NAME-1] = L'\0';
	}

	if (GUID_NULL != m_info.oinfo.guid)
	{
		pDesc->guidObject = m_info.oinfo.guid;
		pDesc->dwValidData |= DMUS_OBJ_OBJECT;
	}

	pDesc->vVersion = m_info.oinfo.vVersion;
	pDesc->dwValidData |= DMUS_OBJ_VERSION;

	pDesc->guidClass = CLSID_DirectMusicScript;
	pDesc->dwValidData |= DMUS_OBJ_CLASS;

	if (m_info.wstrFilename)
	{
		wcscpy(pDesc->wszFileName, m_info.wstrFilename);
		pDesc->dwValidData |= DMUS_OBJ_FILENAME;
	}

	if (m_info.fLoaded)
	{
		pDesc->dwValidData |= DMUS_OBJ_LOADED;
	}

	return S_OK;
}

STDMETHODIMP 
CDirectMusicScript::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	V_INAME(CDirectMusicScript::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

	CHECK_ZOMBIE(m_fZombie);
	
	DWORD dwTemp = pDesc->dwValidData;

	if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
	{
		m_info.oinfo.guid = pDesc->guidObject;
	}

	if (pDesc->dwValidData & DMUS_OBJ_CLASS)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_CLASS;
	}

	if (pDesc->dwValidData & DMUS_OBJ_NAME)
	{
		wcscpy(m_info.oinfo.wszName, pDesc->wszName);
	}

	if (pDesc->dwValidData & DMUS_OBJ_CATEGORY)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_CATEGORY;
	}

	if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
	{
		m_info.wstrFilename = pDesc->wszFileName;
	}

	if (pDesc->dwValidData & DMUS_OBJ_FULLPATH)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_FULLPATH;
	}

	if (pDesc->dwValidData & DMUS_OBJ_URL)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_URL;
	}

	if (pDesc->dwValidData & DMUS_OBJ_VERSION)
	{
		m_info.oinfo.vVersion = pDesc->vVersion;
	}
	
	if (pDesc->dwValidData & DMUS_OBJ_DATE)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_DATE;
	}

	if (pDesc->dwValidData & DMUS_OBJ_LOADED)
	{
		pDesc->dwValidData &= ~DMUS_OBJ_LOADED;
	}
	
	return dwTemp == pDesc->dwValidData ? S_OK : S_FALSE;
}

STDMETHODIMP 
CDirectMusicScript::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
	V_INAME(CDirectMusicScript::ParseDescriptor);
	V_INTERFACE(pStream);
	V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
	
	ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
	pDesc->dwSize = sizeof(DMUS_OBJECTDESC);

	CHECK_ZOMBIE(m_fZombie);
	
	SmartRef::CritSec CS(&m_CriticalSection);

	// Read the script's header information

	SmartRef::RiffIter riForm(pStream);
	if (!riForm)
	{
#ifdef DBG
		if (SUCCEEDED(riForm.hr()))
		{
			Trace(2, "Error: ParseDescriptor on a script failed: Unexpected end of file. "
						"(Note that this may be OK, such as when ScanDirectory is used to parse a set of unknown files, some of which are not scripts.)\n");
		}
#endif
		return SUCCEEDED(riForm.hr()) ? DMUS_E_SCRIPT_INVALID_FILE : riForm.hr();
	}
	HRESULT hr = riForm.FindRequired(SmartRef::RiffIter::Riff, DMUS_FOURCC_SCRIPT_FORM, DMUS_E_SCRIPT_INVALID_FILE);
	if (FAILED(hr))
	{
#ifdef DBG
		if (hr == DMUS_E_SCRIPT_INVALID_FILE)
		{
			Trace(1, "Error: ParseDescriptor on a script failed: Form 'DMSC' not found. "
						"(Note that this may be OK, such as when ScanDirectory is used to parse a set of unknown files, some of which are not scripts.)\n");
		}
#endif
		return hr;
	}

	SmartRef::RiffIter ri = riForm.Descend();
	if (!ri)
		return ri.hr();

	hr = ri.LoadObjectInfo(&m_info.oinfo, SmartRef::RiffIter::Chunk, DMUS_FOURCC_SCRIPTVERSION_CHUNK);
	if (FAILED(hr))
		return hr;

	hr = this->GetDescriptor(pDesc);
	return hr;
}

STDMETHODIMP_(void)
CDirectMusicScript::Zombie()
{
	m_fZombie = true;
	this->ReleaseObjects();
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicScript

STDMETHODIMP
CDirectMusicScript::Init(IDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::Init);
	V_INTERFACE(pPerformance);
	V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);

	CHECK_ZOMBIE(m_fZombie);

	SmartRef::ComPtr<IDirectMusicPerformance8> scomPerformance8;
	HRESULT hr = pPerformance->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void **>(&scomPerformance8));
	if (FAILED(hr))
		return hr;
	
	// Don't take the critical section if the script is already initialized.
	// For example, this is necessary in the following situation:
	//  - The critical section has already been taken by CallRoutine.
	//  - The routine played a segment with a script track referencing this script.
	//  - The script track calls Init (from a different thread) to make sure the script
	//    is initialized.
	if (m_pPerformance8)
	{
		// Additional calls to Init are ignored.
		// First call wins.  Return S_FALSE if performance doesn't match.
		if (m_pPerformance8 == scomPerformance8)
			return S_OK;
		else
			return S_FALSE;
	}

	SmartRef::CritSec CS(&m_CriticalSection);
	if (m_fInitError)
	{
//#ifndef XBOX    // XBOX doesn't care about returning errors.
		if (pErrorInfo)
		{
			// Syntax errors in a script occur as it is loaded, before SetDescriptor gives a script
			// its filename.  We'll have it after the load (before init is called) so can add it
			// back in here.
#ifdef XBOX
			if (m_InitErrorInfo.wszSourceFile[0] == L'\0' && m_info.wstrFilename)
				wcstombs(m_InitErrorInfo.wszSourceFile, m_info.wstrFilename, DMUS_MAX_FILENAME);
#else
			if (m_InitErrorInfo.wszSourceFile[0] == L'\0' && m_info.wstrFilename)
				wcsTruncatedCopy(m_InitErrorInfo.wszSourceFile, m_info.wstrFilename, DMUS_MAX_FILENAME);
#endif
			CopySizedStruct(pErrorInfo, &m_InitErrorInfo);
		}
//#endif
		return DMUS_E_SCRIPT_ERROR_IN_SCRIPT;
	}

	if (!m_info.fLoaded)
	{
		Trace(1, "Error: IDirectMusicScript::Init called before the script has been loaded.\n");
		return DMUS_E_NOT_LOADED;
	}
    ENTER_API_CRITICAL_SECTION;
	// Get the dispatch interface for the performance
	SmartRef::ComPtr<IDispatch> scomDispPerformance = NULL;
	hr = pPerformance->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&scomDispPerformance));
	if (SUCCEEDED(hr))
    {
	    // Get a composer object
	    hr = DirectMusicCreateInstance(CLSID_DirectMusicComposer, NULL, IID_IDirectMusicComposer8, reinterpret_cast<void **>(&m_pComposer8));
    }
    if (SUCCEEDED(hr))
    {
	    m_pDispPerformance = scomDispPerformance.disown();
	    m_pPerformance8 = scomPerformance8.disown();

    	hr = m_pScriptManager->Start(pErrorInfo);
    }
	if (SUCCEEDED(hr))
    {
    	hr = m_pContainerDispatch->OnScriptInit(m_pPerformance8);
    }
    LEAVE_API_CRITICAL_SECTION;
	return hr;
}

// Returns DMUS_E_SCRIPT_ROUTINE_NOT_FOUND if routine doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::CallRoutine(
#ifdef XBOX
                                const char *pszRoutineName,
#else
                                WCHAR *pwszRoutineName, 
#endif
                                DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::CallRoutine);
	V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);
	CHECK_ZOMBIE(m_fZombie);
#ifdef XBOX
    V_BUFPTR_READ(pszRoutineName, 1);
    WCHAR *pwszRoutineName = new WCHAR[strlen(pszRoutineName)+1];
    assert(pwszRoutineName);
    mbstowcs( pwszRoutineName, pszRoutineName, MAX_PATH );
#else
	V_BUFPTR_READ(pwszRoutineName, 2);
#endif
    HRESULT hr;
	SmartRef::CritSec CS(&m_CriticalSection);
	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::CallRoutine.\n");
		hr = DMUS_E_NOT_INIT;
	}
    else
    {
        ENTER_API_CRITICAL_SECTION;
	    hr = m_pScriptManager->CallRoutine(pwszRoutineName, pErrorInfo);
        LEAVE_API_CRITICAL_SECTION;
    }
#ifdef XBOX
    delete [] pwszRoutineName;
#endif
	return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableVariant(
		WCHAR *pwszVariableName,
		VARIANT varValue,
		BOOL fSetRef,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::SetVariableVariant);
	V_BUFPTR_READ(pwszVariableName, 2);
	V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);

	switch (varValue.vt)
	{
	case VT_BSTR:
		V_BUFPTR_READ_OPT(varValue.bstrVal, sizeof(OLECHAR));
		// We could be more thorough and verify each character until we hit the terminator but
		// that would be inefficient.  We could also use the length preceding a BSTR pointer,
		// but that would be cheating COM's functions that encapsulate BSTRs and could lead to
		// problems in future versions of windows such as 64 bit if the BSTR format changes.
		break;
	case VT_UNKNOWN:
		V_INTERFACE_OPT(varValue.punkVal);
		break;
	case VT_DISPATCH:
		V_INTERFACE_OPT(varValue.pdispVal);
		break;
	}

	CHECK_ZOMBIE(m_fZombie);

	SmartRef::CritSec CS(&m_CriticalSection);

	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::SetVariableVariant.\n");
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = m_pScriptManager->SetVariable(pwszVariableName, varValue, !!fSetRef, pErrorInfo);
	if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
	{
		// There are also items in the script's container that the m_pScriptManager object isn't available.
		// If that's the case, we should return a more specific error message.
		IUnknown *punk = NULL;
		hr = m_pContainerDispatch->GetVariableObject(pwszVariableName, &punk);
		if (SUCCEEDED(hr))
		{
			// We don't actually need the object--it can't be set.  Just needed to find out if it's there
			// in order to return a more specific error message.
			punk->Release();
			return DMUS_E_SCRIPT_CONTENT_READONLY;
		}
	}
	return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and empty value if variable doesn't exist in the script.
// Certain varient types such as BSTRs and interface pointers must be freed/released according to the standards for VARIANTS.
// If unsure, use VariantClear (requires oleaut32).
STDMETHODIMP
CDirectMusicScript::GetVariableVariant(WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::GetVariableVariant);
	V_BUFPTR_READ(pwszVariableName, 2);
	V_PTR_WRITE(pvarValue, VARIANT);
	V_PTR_WRITE_OPT(pErrorInfo, DMUS_SCRIPT_ERRORINFO);
	
	DMS_VariantInit(m_fUseOleAut, pvarValue);

	CHECK_ZOMBIE(m_fZombie);

	SmartRef::CritSec CS(&m_CriticalSection);

	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::GetVariableVariant.\n");
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = m_pScriptManager->GetVariable(pwszVariableName, pvarValue, pErrorInfo);

	if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
	{
		// There are also items in the script's container that we need to return.
		// This is implemented by the container, which returns the IUnknown pointer directly rather than through a variant.
		IUnknown *punk = NULL;
		hr = m_pContainerDispatch->GetVariableObject(pwszVariableName, &punk);
		if (SUCCEEDED(hr))
		{
			pvarValue->vt = VT_UNKNOWN;
			pvarValue->punkVal = punk;
		}
	}

#ifdef DBG
	if (hr == DMUS_E_SCRIPT_VARIABLE_NOT_FOUND)
	{
		Trace(1, "Error: Attempt to get variable '%S' that is not defined in the script.\n", pwszVariableName);
	}
#endif

#ifndef DMS_NEVER_USE_OLEAUT
	if (!m_fUseOleAut && pvarValue->vt == VT_BSTR)
	{
		// m_fUseOleAut is false when we're using our own custom scripting engine that avoids
		// depending on oleaut32.dll.  But in this case we're returning a BSTR variant to the
		// caller.  We have to allocate this string with SysAllocString (from oleaut32)
		// because the caller is going to free it with SysFreeString--the standard thing to
		// do with a variant BSTR.
		BSTR bstrOle = DMS_SysAllocString(true, pvarValue->bstrVal); // allocate a copy with oleaut
		DMS_SysFreeString(false, pvarValue->bstrVal); // free the previous value (allocated without oleaut)
		pvarValue->bstrVal = bstrOle; // return the oleaut string to the user
		if (!bstrOle)
			hr = E_OUTOFMEMORY;
	}
#endif

	return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableNumber(
#ifdef XBOX
                                      const char *pszVariableName,
#else
                                      WCHAR *pwszVariableName, 
#endif
                                      LONG lValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::SetVariableNumber);
#ifdef XBOX
    V_BUFPTR_READ(pszVariableName, 1);
    WCHAR *pwszVariableName = new WCHAR[strlen(pszVariableName)+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, MAX_PATH );
#endif
	VARIANT var;
	var.vt = VT_I4;
	var.lVal = lValue;

    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = this->SetVariableVariant(pwszVariableName, var, false, pErrorInfo);
    LEAVE_API_CRITICAL_SECTION;
#ifdef XBOX
    delete [] pwszVariableName;
#endif
	return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and 0 if variable doesn't exist in the script.
// Returns DISP_E_TYPEMISMATCH if variable's datatype cannot be converted to LONG.
STDMETHODIMP
CDirectMusicScript::GetVariableNumber(
#ifdef XBOX
                                      const char *pszVariableName,
#else
                                      WCHAR *pwszVariableName, 
#endif
                                      LONG *plValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::GetVariableNumber);
	V_PTR_WRITE(plValue, LONG);
	*plValue = 0;
#ifdef XBOX
    V_BUFPTR_READ(pszVariableName, 1);
    WCHAR *pwszVariableName = new WCHAR[strlen(pszVariableName)+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, MAX_PATH );
#endif
	VARIANT var;
    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = this->GetVariableVariant(pwszVariableName, &var, pErrorInfo);
	if (!(FAILED(hr) && (hr != S_FALSE) && (hr != DMUS_S_GARBAGE_COLLECTED)))
    {
    	hr = DMS_VariantChangeType(m_fUseOleAut, &var, &var, 0, VT_I4);
    	if (SUCCEEDED(hr))
        {
    	    *plValue = var.lVal;
        }
        // GetVariableVariant forces a BSTR to be allocated with SysAllocString;
        // so if we allocated a BSTR there, we need to free it with SysAllocString here.
        bool fUseOleAut = m_fUseOleAut;
#ifndef DMS_NEVER_USE_OLEAUT
        if (!m_fUseOleAut && var.vt == VT_BSTR)
	    {
            fUseOleAut = true;
        }
#endif
	    DMS_VariantClear(fUseOleAut, &var);
    }
    LEAVE_API_CRITICAL_SECTION;
#ifdef XBOX
    delete [] pwszVariableName;
#endif
    return hr;
}

#ifdef XBOX
// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableString(const char *pszVariableName,
                                      const char *pszValue, 
                                      DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::SetVariableString);
    V_BUFPTR_READ(pszVariableName, 1);
    V_BUFPTR_READ(pszValue, 1);
    LONG lName = strlen(pszVariableName);
    WCHAR *pwszVariableName = new WCHAR[lName+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, lName + 1 );

    // Make a wide-char copy of the value
    LONG lValue = strlen(pszValue);
    WCHAR *pwszValue = new WCHAR[lValue+1];
    assert( pwszValue );
    mbstowcs( pwszValue, pszValue, lValue + 1 );

	VARIANT var;
	var.vt = VT_BSTR;
	var.bstrVal = (BSTR)pwszValue;

    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = this->SetVariableVariant(pwszVariableName, var, false, pErrorInfo);
    LEAVE_API_CRITICAL_SECTION;
    delete [] pwszVariableName;
    delete [] pwszValue;
	return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and empty if variable doesn't exist in the script.
// Returns DISP_E_TYPEMISMATCH if variable's datatype cannot be converted to BSTR/char *.
STDMETHODIMP
CDirectMusicScript::GetVariableString( const char *pszVariableName,
                                       char *pszValue,
                                       LONG lBufferSize,
                                       LONG *plConverted,
                                       DMUS_SCRIPT_ERRORINFO *pErrorInfo )
{
    V_INAME(CDirectMusicScript::GetVariableString);
    if( pszValue )
        *pszValue = '\0';

    V_BUFPTR_READ(pszVariableName, 1);
    LONG lName = strlen(pszVariableName);
    WCHAR *pwszVariableName = new WCHAR[lName+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, lName + 1 );

    VARIANT var;
    ENTER_API_CRITICAL_SECTION;
    HRESULT hr = this->GetVariableVariant( pwszVariableName, &var, pErrorInfo );
    if( !(FAILED(hr) && (hr != S_FALSE) && (hr != DMUS_S_GARBAGE_COLLECTED)) )
    {
        hr = DMS_VariantChangeType(m_fUseOleAut, &var, &var, 0, VT_BSTR);
        if( SUCCEEDED(hr))
        {
            LONG lConverted;
            lConverted = wcstombs( pszValue, var.bstrVal, lBufferSize );

            // If it converted exactly lBufferSize chars, then there's
            // no terminator
            if( pszValue && lConverted == lBufferSize )
            {
                pszValue[ lConverted - 1 ] = '\0';
            }
            else
            {
                // Otherwise, either we didn't convert anything, or
                // we did convert and it did add a terminator.
                // Either way, add the terminator in to the count
                assert( !pszValue || pszValue[ lConverted ] == '\0' );
                lConverted += 1;
            }

            // Is caller asking for either # converted or size needed?
            if( plConverted != NULL )
                *plConverted = lConverted;

        }
        // GetVariableVariant forces a BSTR to be allocated with SysAllocString;
        // so if we allocated a BSTR there, we need to free it with SysAllocString here.
        bool fUseOleAut = m_fUseOleAut;
#ifndef DMS_NEVER_USE_OLEAUT
        if (!m_fUseOleAut && var.vt == VT_BSTR)
	    {
            fUseOleAut = true;
        }
#endif
	    DMS_VariantClear(fUseOleAut, &var);
    }
    LEAVE_API_CRITICAL_SECTION;

    delete [] pwszVariableName;
    return hr;
}
#endif // XBOX

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND if variable doesn't exist in the script.
STDMETHODIMP
CDirectMusicScript::SetVariableObject(
#ifdef XBOX
                                      const char *pszVariableName,
#else
                                      WCHAR *pwszVariableName, 
#endif 
                                      IUnknown *punkValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::SetVariableObject);
#ifdef XBOX
    V_BUFPTR_READ(pszVariableName, 1);
    WCHAR *pwszVariableName = new WCHAR[strlen(pszVariableName)+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, MAX_PATH );
#endif
	VARIANT var;
	var.vt = VT_UNKNOWN;
	var.punkVal = punkValue;
    ENTER_API_CRITICAL_SECTION;
    HRESULT hr = this->SetVariableVariant(pwszVariableName, var, true, pErrorInfo);
    LEAVE_API_CRITICAL_SECTION;
#ifdef XBOX
    delete [] pwszVariableName;
#endif
    return hr;
}

// Returns DMUS_E_SCRIPT_VARIABLE_NOT_FOUND and NULL if variable doesn't exist in the script.
// Returns DISP_E_TYPEMISMATCH if variable's datatype cannot be converted to IUnknown.
STDMETHODIMP
CDirectMusicScript::GetVariableObject(
#ifdef XBOX
                                      const char *pszVariableName,
#else
                                      WCHAR *pwszVariableName, 
#endif
                                      REFIID riid, LPVOID FAR *ppv, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	V_INAME(CDirectMusicScript::GetVariableObject);
	V_PTR_WRITE(ppv, IUnknown *);
	*ppv = NULL;
#ifdef XBOX
    V_BUFPTR_READ(pszVariableName, 1);
    WCHAR *pwszVariableName = new WCHAR[strlen(pszVariableName)+1];
    assert(pwszVariableName);
    mbstowcs( pwszVariableName, pszVariableName, MAX_PATH );
#endif
	VARIANT var;
    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = this->GetVariableVariant(pwszVariableName, &var, pErrorInfo);
	if (SUCCEEDED(hr) && (hr != DMUS_S_GARBAGE_COLLECTED))
    {
	    hr = DMS_VariantChangeType(m_fUseOleAut, &var, &var, 0, VT_UNKNOWN);
	    if (SUCCEEDED(hr))
		    hr = var.punkVal->QueryInterface(riid, ppv);
	    DMS_VariantClear(m_fUseOleAut, &var);
    }
	LEAVE_API_CRITICAL_SECTION;
#ifdef XBOX
    delete [] pwszVariableName;
#endif
    return hr;
}

STDMETHODIMP
CDirectMusicScript::EnumRoutine(DWORD dwIndex, WCHAR *pwszName)
{
	V_INAME(CDirectMusicScript::EnumRoutine);
	V_BUFPTR_WRITE(pwszName, MAX_PATH);

	*pwszName = L'\0';

	CHECK_ZOMBIE(m_fZombie);

	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::EnumRoutine.\n");
		return DMUS_E_NOT_INIT;
	}

	return m_pScriptManager->EnumItem(true, dwIndex, pwszName, NULL);
}

STDMETHODIMP
CDirectMusicScript::EnumVariable(DWORD dwIndex, WCHAR *pwszName)
{
	V_INAME(CDirectMusicScript::EnumRoutine);
	V_BUFPTR_WRITE(pwszName, MAX_PATH);

	*pwszName = L'\0';

	CHECK_ZOMBIE(m_fZombie);

	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before IDirectMusicScript::EnumVariable.\n");
		return DMUS_E_NOT_INIT;
	}

	int cScriptItems = 0;
	HRESULT hr = m_pScriptManager->EnumItem(false, dwIndex, pwszName, &cScriptItems);
	if (FAILED(hr))
		return hr;

	if (hr == S_FALSE)
	{
		// There are also items in the script's container that we need to report.
		assert(dwIndex >= (DWORD) cScriptItems);
		hr = m_pContainerDispatch->EnumItem(dwIndex - cScriptItems, pwszName);
	}

	return hr;
}

STDMETHODIMP
CDirectMusicScript::ScriptTrackCallRoutine(
		WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	V_INAME(CDirectMusicScript::CallRoutine);
	V_BUFPTR_READ(pwszRoutineName, 2);
	V_INTERFACE(pSegSt);

	CHECK_ZOMBIE(m_fZombie);

	SmartRef::CritSec CS(&m_CriticalSection);

	if (!m_pScriptManager || !m_pPerformance8)
	{
        Trace(1, "Error: Unitialized Script elements in an attempt to call a Script Routine.\n");
		return DMUS_E_NOT_INIT;
	}

	return m_pScriptManager->ScriptTrackCallRoutine(
								pwszRoutineName,
								pSegSt,
								dwVirtualTrackID,
								fErrorPMsgsEnabled,
								i64IntendedStartTime,
								dwIntendedStartTimeFlags);
}

STDMETHODIMP
CDirectMusicScript::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(CDirectMusicScript::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, UINT);
	*pctinfo = 0;

	CHECK_ZOMBIE(m_fZombie);

	return S_OK;
}

STDMETHODIMP
CDirectMusicScript::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo)
{
	*ppTInfo = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicScript::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	if (m_fZombie)
	{
		if (rgDispId)
		{
			for (UINT i = 0; i < cNames; ++i)
			{
				rgDispId[i] = DISPID_UNKNOWN;
			}
		}
    }
    CHECK_ZOMBIE(m_fZombie);
	
	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before GetIDsOfNames.\n");
		return DMUS_E_NOT_INIT;
	}

	return m_pScriptManager->DispGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
}

STDMETHODIMP
CDirectMusicScript::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	if (m_fZombie)
	{
		if (pVarResult)
			DMS_VariantInit(m_fUseOleAut, pVarResult);
    }
    CHECK_ZOMBIE(m_fZombie);

	if (!m_pScriptManager || !m_pPerformance8)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before Invoke.\n");
		return DMUS_E_NOT_INIT;
	}

	return m_pScriptManager->DispInvoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
}

//////////////////////////////////////////////////////////////////////
// Methods that allow CActiveScriptManager access to private script interfaces

IDispatch *CDirectMusicScript::GetGlobalDispatch()
{
	assert(m_pGlobalDispatch);
	return m_pGlobalDispatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englex.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Lexer.
//

// Lexical analyzer for AudioVBScript.  Breaks down the characters of source code into a stream tokens.

#pragma once

const int g_iMaxBuffer = 256; // max length for VBScript identifiers is 255

enum LexErr
{
	LEXERR_NoError = 0,
	LEXERR_InvalidCharacter,
	LEXERR_NonAsciiCharacterInStringLiteral = LEXERR_InvalidCharacter,
	LEXERR_IdentifierTooLong,
	LEXERR_StringLiteralTooLong,
	LEXERR_StringLiteralUnterminated,
	LEXERR_NumericLiteralTooLarge,
	LEXERR_Max
};

enum Token
{
	TOKEN_eof = 0, // used for end of file or an error (nenzero error_num() indicates an error)
	TOKEN_sub,
	TOKEN_dim,
	TOKEN_if,
	TOKEN_then,
	TOKEN_end,
	TOKEN_elseif,
	TOKEN_else,
	TOKEN_set,
	TOKEN_call,
	TOKEN_lparen,
	TOKEN_rparen,
	TOKEN_comma,
	TOKEN_op_minus,
	TOKEN_op_not,
	TOKEN_op_pow,
	TOKEN_op_mult,
	TOKEN_op_div,
	TOKEN_op_mod,
	TOKEN_op_plus,
	TOKEN_op_lt,
	TOKEN_op_leq,
	TOKEN_op_gt,
	TOKEN_op_geq,
	TOKEN_op_eq,
	TOKEN_op_neq,
	TOKEN_is,
	TOKEN_and,
	TOKEN_or,
	TOKEN_linebreak,
	TOKEN_identifier,
	TOKEN_identifierdot,
	TOKEN_stringliteral,
	TOKEN_numericliteral
};

struct TokenKeysym
{
	WCHAR c;
	Token t;
};
extern const TokenKeysym g_TokenKeysyms[];

struct TokenKeyword
{
	const WCHAR *s;
	Token t;
};
extern const TokenKeyword g_TokenKeywords[];

bool CheckOperatorType(Token t, bool fAcceptParens, bool fAcceptUnary, bool fAcceptBinary, bool fAcceptOverloadedAssignmentTokens);

class Lexer
{
public:
	Lexer(const WCHAR *pwszSource);

	Lexer &operator++() { Next(); Scan(); return *this; }
	int line() { return m_iLine; }
	int column() { return m_iColumn; }
	operator Token() { return m_t; }

	// Additional token-specific info.  Only valid while on this token.

	// error
	int error_num() { assert(m_t == TOKEN_eof); return num(); } // 0 if no error
	const char *error_descr() { assert(m_t == TOKEN_eof); return str(); }

	// identifier and identifierdot
	const char *identifier_name() { assert(m_t == TOKEN_identifier || m_t == TOKEN_identifierdot); return str(); }

	// numeric literal
	int numericliteral_val() { assert(m_t == TOKEN_numericliteral); return num(); }

	// string literal
	const char *stringliteral_text() { assert(m_t == TOKEN_stringliteral); return str(); }

private:
	friend class CActiveScriptError;

	void Next();
	void Scan(); // handling for line break tokens and calls ScanMain
	void ScanMain();

	const char *str() { return m_szStr; } // Multipurpose string info set by some tokens.
	void err(LexErr iErr);
	int num() { return m_iNum; } // Multipurpose numeric info set by some tokens.

	const WCHAR *m_p;
	const WCHAR *m_pNext; // If this is set then the next Next call will advance the pointer (and the column) to this point.
	int m_iLine;
	int m_iColumn;
	Token m_t;

	char m_szStr[g_iMaxBuffer];
	int m_iNum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englog.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper functions for logging script parsing.  Useful for debugging, but never turned on in released builds.
//

#error This file should never be used in released builds. // 

#pragma once

#include "englex.h"
#include "engcontrol.h"

void LogToken(Lexer &l);
void LogRoutine(Script &script, Routines::index irtn);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englookup.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Strings and Hash.
//

/*#include "stdinc.h"
#include "englookup.h"
#include "englex.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Strings

// Note: Actually this is half the initial size since the first time will realloc and double.
const Strings::index Strings::ms_iInitialSize = 256; //  Tune this.  16 chars * 32 items / 2 -> 256.

Strings::Strings() : m_pszBuf(NULL), m_iCur(0), m_iSize(ms_iInitialSize)
{
    m_iBase = 0;
}

Strings::~Strings(){
    char* p = m_pszBuf;
    while(p){
        char* p2 = *(char**) p;
        delete [] p;
        p = p2;
    }
}

HRESULT
Strings::Add(const char *psz, index &i)
{
	assert(ms_iInitialSize * 2 >= g_iMaxBuffer); // the initial size (doubled) must be large enough to hold the biggest possible identifier
	int cch = strlen(psz) + 1; // including the null
	if (!m_pszBuf || m_iCur + cch > m_iSize)
	{
		// realloc
		m_iSize *= 2;
        DWORD newAlloc = m_iSize - m_iBase;
		char *pszBuf = new char[newAlloc + sizeof(char*)];
		if (!pszBuf)
			return E_OUTOFMEMORY;
        m_iBase = m_iCur;

		// thread new allocation
        *(char**) pszBuf = m_pszBuf;
		m_pszBuf = pszBuf;
	}

	// append the string
    char* pDest = m_pszBuf + m_iCur - m_iBase + sizeof(char*);
	strcpy(pDest, psz);
	i = (int) pDest; // Yep, i is really a pointer.
	m_iCur += cch;

	return S_OK;
}

const char *
Strings::operator[](index i)
{
	if (!m_pszBuf || ! i)
	{
		assert(false);
		return NULL;
	}

	return (char*) i; // Yep, i is really a pointer.
}

//////////////////////////////////////////////////////////////////////
// Lookup

HRESULT Lookup::FindOrAddInternal(bool fAdd, const char *psz, slotindex &iSlot, Strings::index &iString)
{
	StrKey k;
	k.psz = psz;

	stringhash::entry &e = m_h.Find(k);
	if (e.fFound())
	{
		assert(!fAdd || iSlot > e.v.iSlot);
		iSlot = e.v.iSlot;
		iString = e.v.iString;
		return S_OK;
	}

	if (!fAdd)
		return S_FALSE;

	indices v;
	v.iSlot = iSlot;
	HRESULT hr = m_strings.Add(psz, iString);
	if (FAILED(hr))
		return hr;
	v.iString = iString;
	k.psz = m_strings[v.iString]; // need to save key with the string from the permanent store

	hr = m_h.Add(e, k, v);
	if (FAILED(hr))
		return hr;

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englookup.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Strings, Slots, and Hash.
//

// Strings holds a collection of strings in one big chunk of memory.
// Slots is just a collection that can be appended to and accessed
// Lookup is used during parsing and then discarded at runtime.  It maps strings to consecutive slots and positions in Strings.

#pragma once

class Strings
{
public:
#ifdef _WIN64
	typedef __int64 index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#else
	typedef int index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#endif

	Strings();
	~Strings();

	HRESULT Add(const char *psz, index &i);

    // The address of the stored string returned by operator[]
    // is guarenteed to not change over the lifetime of the Strings object.
    // (The Lookup class implementation requires this behavior.)

	const char *operator[](index i);

private:
	char *m_pszBuf;
	index m_iCur;
	index m_iSize;
    index m_iBase;
	static const index ms_iInitialSize;
};

template<class T>
class Slots
{
public:
#ifdef _WIN64
	typedef __int64 index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#else
	typedef int index; // use an index type. this would allow us to do type checking to ensure that the appropriate indices are used with the appropriate collections if we really wanted to. (in order to test this we'd need to make a class in order to create a "real" type, which a mere typedef doesn't do. )
#endif

	index Next() { return m_v.size(); }
	HRESULT Add(T t) { index i = m_v.size(); if (!m_v.AccessTo(i)) return E_OUTOFMEMORY; m_v[i] = t; return S_OK; }
	T& operator[](index i) { return m_v[i]; }

private:
	SmartRef::Vector<T> m_v;
};

// hungarian: lku
class Lookup
{
public:
#ifdef _WIN64
	typedef __int64 slotindex; // don't want to have to template this on the kind of slot just for its index since it is just an int anyway
#else
	typedef int slotindex; // don't want to have to template this on the kind of slot just for its index since it is just an int anyway
#endif

	struct indices
	{
		Strings::index iString;
		slotindex iSlot;
	};

	Lookup(HRESULT *phr, Strings &strings, int iInitialSize) : m_h(phr, iInitialSize), m_strings(strings) {}
	indices &operator[](const char *psz) { StrKey k; k.psz = psz; return m_h[k]; }

	// both indices are out parameters, set only if the entry is found
	bool Find(const char *psz, slotindex &iSlot, Strings::index &iString) { return S_OK == FindOrAddInternal(false, psz, iSlot, iString); }

	// iSlot is in (next slot to add items) and out (slot if found in existing items).  iString is out only.  returns E_OUTOFMEMORY, S_OK (found), or S_FALSE (added).
	HRESULT FindOrAdd(const char *psz, slotindex &iSlot, Strings::index &iString) { return FindOrAddInternal(true, psz, iSlot, iString); }

private:
	HRESULT FindOrAddInternal(bool fAdd, const char *psz, slotindex &iSlot, Strings::index &iString);

	bool m_fInitialized;

	struct StrKey
	{
		const char *psz;
		int Hash() { int i = 0; for (const char *p = psz; *p != '\0'; i += tolower(*p++)) {} return i; };
		bool operator ==(const StrKey &o) { return 0 == _stricmp(psz, o.psz); }
	};

	typedef SmartRef::Hash<StrKey, indices> stringhash;
	stringhash m_h;
	Strings &m_strings;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engparse.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Parser.
//

#pragma once

#include "englex.h"
#include "englookup.h"
#include "activescript.h"
#include "engcontrol.h"

// Parser for AudioVBScript.  Reads tokens from Lexer and produces program structures ready for execution.

//////////////////////////////////////////////////////////////////////
// helper structures

// saves the identifier of a dereference like x.y where y would be the name.  used to map char * into single instances in strings during parsing.
class Name_Parse
{
public:
	Name_Parse(Strings::index _istrIdentifier = 0) : istrIdentifier(_istrIdentifier) {}

	Strings::index istrIdentifier;
};
typedef Slots<Name_Parse> Names_Parse;

// Holds information about an identifier (eg "x") or identifiers (eg "x.y") until the context it will be
//    used in (variable reference or function call) becomes known.
// Returned by ParseNameReference.  Used later with VariableReferenceFromNameReference or CallFromNameReference.
struct NameReference
{
	NameReference() : fSingleItem(true), ivarrefMultiple(0) {}

	bool fSingleItem;
	SmartRef::AString strSingle; // used if fSingleItem is true: this saves the name until we know whether it's the name or a variable or a function
	VariableReferences::index ivarrefMultiple; // used if fSingleItem is false: it must reference a variable
};

//////////////////////////////////////////////////////////////////////
// error codes

enum ParseErr
{
	PARSEERR_LexerError = 0,
	PARSEERR_ExpectedSubOrDim,
	PARSEERR_ExpectedIdentifier,
	PARSEERR_ExpectedLineBreak,
	PARSEERR_ExpectedEndSub,
	PARSEERR_ExpectedSub,
	PARSEERR_ExpectedStatement,
	PARSEERR_ExpectedLparen,
	PARSEERR_ExpectedEq,
	PARSEERR_DimAfterSub,
	PARSEERR_InvalidExprLineBreak,
	PARSEERR_InvalidExprThen,
	PARSEERR_InvalidExprRparen,
	PARSEERR_StringInExprBlock,
	PARSEERR_ExpectedExprValue,
	PARSEERR_DuplicateVariable,
	PARSEERR_DuplicateRoutine,
	PARSEERR_ExpectedRparen,
	PARSEERR_UnexpectedRparen,
	PARSEERR_ExpectedThen,
	PARSEERR_ExpectedEndIf,
	PARSEERR_ExpectedIf,
	PARSEERR_IntendedElseIf,
	PARSEERR_AssignedToBuiltInConstant,
	PARSEERR_ParensUsedCallingSub,
	PARSEERR_ExpectedVariableButRoutineFound,
	PARSEERR_Max
};

//////////////////////////////////////////////////////////////////////
// Parser class

class Parser
{
public:
	Parser(Lexer &lexer, Script &script, IActiveScriptSite *pActiveScriptSite, IDispatch *pGlobalDispatch);
	~Parser();

	HRESULT hr() { return m_hr; }

private:
	// Parsing functions. Each reads a certain kind of structure. m_hr and m_pexcepinfo are set on failure.

	void ParseScript();
	void ParseSub();
	void ParseDim();
	Statements::index ParseStatements(Routines::index irtnContext, Lookup &lkuLocals);
	void ParseAssignmentOrCall(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, bool fCall);
	VariableReferences::index ParseDottedVariableReference(Routines::index irtnContext, Lookup &lkuLocals);
	Assignments::index ParseAssignment(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, VariableReferences::index ivarrefLHS);
	void ParseIf(Routines::index irtnContext, Lookup &lkuLocals);
	ExprBlocks::index ParseExpression(Routines::index irtnContext, Lookup &lkuLocals, ExprBlocks *peblocks, bool fAllowRparenAtEnd, bool fDetectSpecialErrorForSubCallWithParen);
	ExprBlocks::index ParseParameters(Routines::index irtnContext, Lookup &lkuLocals, bool fParenthesized);
	void ParseNameReference(Routines::index irtnContext, Lookup &lkuLocals, NameReference &nref);

	// Parsing helpers.

	// Advance the lexer one token. If an error token is encountered, the error is reported and true is returned.
	bool Advance() { if (!++m_lexer && m_lexer.error_num()) { Error(PARSEERR_LexerError); return true; } return false; }
	// Advances if the current token is t. If an error token is next, it is reported and true is returned.
	bool Skip(Token t) { if (m_lexer == t) { return Advance(); } return false; }
	// Same as Skip, but if t isn't next then the error iErr is reported and true is returned.
	bool Expect(Token t, ParseErr iErr) { if (m_lexer == t) { return Advance(); } Error(iErr); return true; }
	// Advance. If the next token isn't t then report iErr and return true.
	bool ExpectNext(Token t, ParseErr iErr) { if (Advance()) return true; if (m_lexer == t) return false; Error(iErr); return true; }

	// Add a variable reference using the info from a NameReference.
	VariableReferences::index VariableReferenceFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref);
	// Add a call using the info from a NameReference.  Also parses the parameters.
	Calls::index CallFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref, bool fParametersParenthesized);

	// Shared implementation for VariableReferenceFromNameReference (pszName is set) and ParseDottedVariableReference (pszName is NULL).
	VariableReferences::index VariableReferenceInternal(Routines::index irtnContext, Lookup &lkuLocals, const char *pszName);

	void Error(ParseErr iErr); // call to report a syntax error

	Lexer &m_lexer;
	Script &m_script;

	HRESULT m_hr;
	IActiveScriptSite *m_pActiveScriptSite;
	IDispatch *m_pGlobalDispatch;

	Lookup *m_plkuRoutines;
	Lookup *m_plkuGlobals;
	Lookup *m_plkuVarRefs;

	Lookup *m_plkuNames;
	Names_Parse m_names;
	SmartRef::Stack<ExprBlock> m_stack; // working stack for expression evaluation
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\globaldisp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implements a script's global dispatch object.
//

/*#include "stdinc.h"
#include "globaldisp.h"
#include "autconstants.h"
#include "autperformance.h"*/

#include "pchscript.h"

  // We need to shift the DISPID's of the performance, constants, and contained
// content so that they can be assembled into one range.  The performance will be first,
// followed by the others, which are shifted.
const DISPID g_dispidShiftConstants = 1000;
const DISPID g_dispidShiftContent = g_dispidShiftConstants + 1000;


//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CGlobalDispatch::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CGlobalDispatch::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDispatch)
	{
		*ppv = static_cast<IDispatch*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDispatch

STDMETHODIMP
CGlobalDispatch::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(CGlobalDispatch::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, UINT);

	*pctinfo = 0;
	return S_OK;
}

STDMETHODIMP
CGlobalDispatch::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo)
{
	*ppTInfo = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP
CGlobalDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId)
{
	HRESULT hr = S_OK;

	hr = AutConstantsGetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (hr != DISP_E_UNKNOWNNAME)
	{
		if (SUCCEEDED(hr))
			rgDispId[0] += g_dispidShiftConstants;
		return hr;
	}

	// Try the performance next.  Conceptually we're doing this:
	//    hr = m_pParentScript->m_pDispPerformance->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	// However, because AudioVBScript may try and resolve names during parsing (before a performance is set by Init),
	//    we will won't use a live perfomance object for this.  Instead we'll use the dispatch helper and the
	//    performance's table to return the ID.
	hr = AutDispatchGetIDsOfNames(CAutDirectMusicPerformance::ms_Methods, riid, rgszNames, cNames, lcid, rgDispId);
	if (hr != DISP_E_UNKNOWNNAME)
		return hr;

	hr = m_pParentScript->m_pContainerDispatch->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	if (SUCCEEDED(hr))
		rgDispId[0] += g_dispidShiftContent;

	return hr;
}

STDMETHODIMP
CGlobalDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr)
{
	// If script functions are being called, it is an error if the script has not been
	// initialized with a performance.
	if (!m_pParentScript->m_pDispPerformance)
	{
		Trace(1, "Error: IDirectMusicScript::Init must be called before the script can be used.\n");
		return DMUS_E_NOT_INIT;
	}

	if (dispIdMember < g_dispidShiftConstants)
	{
		// Performance method
		return m_pParentScript->m_pDispPerformance->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	else if (dispIdMember < g_dispidShiftContent)
	{
		// Constants
		return AutConstantsInvoke(dispIdMember - g_dispidShiftConstants, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
	else
	{
		// Contained content item
		return m_pParentScript->m_pContainerDispatch->Invoke(dispIdMember - g_dispidShiftContent, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engexec.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Executor.
//

// Runs the script, interpreting its routines and managing its variables.

#ifndef ENGEXEC_H
#define ENGEXEC_H

#include "engcontrol.h"
#include "enginc.h"
#include "oleaut.h"

#ifdef XBOX
#define MULTITHREAD_ENGINE
#endif

class CallStack
{
public:
	CallStack() : m_iNext(0) {}

	UINT Next() { return m_iNext; }
	VARIANT &operator[](UINT i) { assert(i < m_iNext); return m_vec[i]; }

	// used for routines' local variables
	HRESULT Push(UINT i); // pushes i empty slots
	void PopTo(UINT i); // pops everything down to and including i (following this, i will be Next)

private:
	SmartRef::Vector<VARIANT> m_vec;
	UINT m_iNext;
};

class Executor
{
public:
	Executor(Script &script, IDispatch *pGlobalDispatch);
	~Executor();

	HRESULT SetGlobal(Variables::index ivar, const VARIANT &varValue, bool fPutRef, EXCEPINFO *pExcepInfo);
	const VARIANT &GetGlobal(Variables::index ivar);
	HRESULT ExecRoutine(Routines::index irtn, EXCEPINFO *pExcepInfo);

private:
	enum DispatchOperationType { _get, _put, _putref, _call };

	HRESULT EnsureInitialized();

	HRESULT Error(EXCEPINFO *pExcepInfo, bool fOperation, const WCHAR *pwszBeginning, const char *paszMiddle = NULL, const WCHAR *pwszEnd = NULL); // A bit hokey, but it works. Creates an error using wide strings with an ascii string (typically an identifier) in between.
	HRESULT ErrorIfImproperRef(const VARIANT &v, bool fRef, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo);
	HRESULT ErrorObjectRequired(Strings::index istrIdentifier, EXCEPINFO *pExcepInfo) { return Error(pExcepInfo, false, L"Object required: '", m_script.strings[istrIdentifier], L"'"); }
	HRESULT ErrorIfInvokeProblem(DispatchOperationType e, HRESULT hr, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo);

	HRESULT ExecStatements(Statements::index istmt, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecAssignment(Assignments::index iasgn, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecIf(IfBlocks::index iif, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecCall(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT ExecCallInternal(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals); // helper used by ExecCall

	HRESULT EvalExpression(VARIANT &varResult, ExprBlocks::index iexpr, EXCEPINFO *pExcepInfo, UINT iLocals);
	HRESULT EvalValue(Values::index ival, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals); // evaluates ival, saving the result in v
	HRESULT EvalUnaryOp(Token t, VARIANT &v); // evaluates t on v -- saving the result back into v
	HRESULT EvalBinaryOp(Token t, VARIANT &v1, VARIANT &v2, EXCEPINFO *pExcepInfo); // evaluates t on v1 and v2 -- saving the result back into v2

	HRESULT GetVariableReference(Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals) { return VariableReferenceInternal(_get, ivarref, v, pExcepInfo, iLocals); }
	HRESULT SetVariableReference(bool fSet, Variables::index ivarref, const VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals) { return VariableReferenceInternal(fSet ? _putref : _put, ivarref, const_cast<VARIANT&>(v), pExcepInfo, iLocals); }
	HRESULT VariableReferenceInternal(DispatchOperationType e, Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals);

	HRESULT ChangeToDispatch(VARIANT &var, EXCEPINFO *pExcepInfo, ReferenceNames::index irnameIdentifier);

	// Data
	bool m_fInitialized;
	Script &m_script;
	SmartRef::ComPtr<IDispatch> m_scomGlobalDispatch;

	VARIANT m_varEmpty; // varient we hold around so we can return a ref to a cleared variant
	CallStack m_stack;
#ifdef MULTITHREAD_ENGINE
    CRITICAL_SECTION m_csStackSection; // Used to control access to the stack
#endif
};

#endif // ENGEXEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\globaldisp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implements a script's global dispatch object.
// Calls are delegated to the performance, constants, or contained content held on the parent CDirectMusicScript object.
// AddRef/Release are ignored, because it is completely contained within the lifetime of CDirectMusicScript.
//

#pragma once
#include "dmscript.h"

class CGlobalDispatch
  : public IDispatch
{
public:
	CGlobalDispatch(CDirectMusicScript *pParentScript) : m_pParentScript(pParentScript) { assert(m_pParentScript); }

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)() { return 2; }
	STDMETHOD_(ULONG, Release)() { return 2; }

	// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid,
		LPOLESTR __RPC_FAR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS __RPC_FAR *pDispParams,
		VARIANT __RPC_FAR *pVarResult,
		EXCEPINFO __RPC_FAR *pExcepInfo,
		UINT __RPC_FAR *puArgErr);

private:
	CDirectMusicScript *m_pParentScript;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\guids.cpp ===
// Copyright (c) 1999 Microsoft Corporation
//#include "initguid.h"
/*#include "dmusicip.h"
#include "dmscriptautguids.h"
#include "dmstrm.h"
#include "..\shared\dmusicp.h"*/

#include "pchscript.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\guids_dmscript.cpp ===
// Allows us to compile the source code in guids.cpp to product an object file guids_dmscript.obj
// (Which avoids an error when linking dmusic.lib.)

//#define INITGUID
/*#include "dmusicip.h"
#include "dmscriptautguids.h"
#include "dmstrm.h"
#include "..\shared\dmusicp.h"*/

#include "pchscript.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engexec.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Executor.
//

/*#include "stdinc.h"
#include "enginc.h"
#include "engexec.h"
#include "math.h"
#include "packexception.h"*/

#include "pchscript.h"

#ifdef MULTITHREAD_ENGINE

class CriticalSectionHelper{
public:
    CriticalSectionHelper(CRITICAL_SECTION* pCS){
        m_pCS = pCS;
        EnterCriticalSection(m_pCS);
    }
    ~CriticalSectionHelper(){
        LeaveCriticalSection(m_pCS);
    }
private:
    CriticalSectionHelper(const CriticalSectionHelper&);
    CriticalSectionHelper& operator=(const CriticalSectionHelper&);

    CRITICAL_SECTION* m_pCS;
};

#define WITH_STACK_PROTECTED CriticalSectionHelper helper(&m_csStackSection)

class StackLevelHelper {
public:
    StackLevelHelper(CallStack* pStack){
        m_pStack = pStack;
        m_uiLevel = pStack->Next();
    }
    ~StackLevelHelper(){
        assert(m_uiLevel == m_pStack->Next());
    }
private:
    StackLevelHelper(const StackLevelHelper&);
    StackLevelHelper& operator=(const StackLevelHelper&);

    CallStack* m_pStack;
    UINT m_uiLevel;
};

#else // not MULTITHREAD_ENGINE

#define WITH_STACK_PROTECTED

#endif // MULTITHREAD_ENGINE

//////////////////////////////////////////////////////////////////////
// CallStack

HRESULT
CallStack::Push(UINT i)
{
	UINT iInitialSize = m_vec.size();
	if (!m_vec.AccessTo(m_iNext + i - 1))
		return E_OUTOFMEMORY;
	
	UINT iNewNext = m_iNext + i;
	for (UINT iInit = std::max<UINT>(m_iNext, iInitialSize); iInit < iNewNext; ++iInit)
		DMS_VariantInit(g_fUseOleAut, &m_vec[iInit]);

	m_iNext = iNewNext;
	return S_OK;
}

void
CallStack::PopTo(UINT i)
{
	for (UINT iInit = i; iInit < m_iNext; ++iInit)
		DMS_VariantClear(g_fUseOleAut, &m_vec[iInit]);

	m_iNext = std::min<UINT>(m_iNext, i);
}


//////////////////////////////////////////////////////////////////////
// Executor

Executor::Executor(Script &script, IDispatch *pGlobalDispatch)
  : m_fInitialized(false),
	m_script(script),
	m_scomGlobalDispatch(pGlobalDispatch)
{
	DMS_VariantInit(g_fUseOleAut, &m_varEmpty);
    InitializeCriticalSection(&m_csStackSection);
}

Executor::~Executor()
{
	m_stack.PopTo(0); // clear any varients on the stack that might be holding refs
    DeleteCriticalSection(&m_csStackSection);
}

HRESULT
Executor::SetGlobal(Variables::index ivar, const VARIANT &varValue, bool fPutRef, EXCEPINFO *pExcepInfo)
{
    WITH_STACK_PROTECTED;

	HRESULT hr = EnsureInitialized();
	if (FAILED(hr))
		return hr;

    hr = ErrorIfImproperRef(varValue, fPutRef, m_script.globals[ivar].istrIdentifier, pExcepInfo);
	if (FAILED(hr))
		return hr;

	assert(ivar <= m_script.globals.Next());
	return DMS_VariantCopy(g_fUseOleAut, &m_stack[ivar], &varValue);
}

const VARIANT &
Executor::GetGlobal(Variables::index ivar)
{
    WITH_STACK_PROTECTED;

	if (!m_fInitialized)
	{
		// No variable gets or routine calls have been performed yet (or they failed).
		// But we don't want to return an error here.  Since nothing's been used yet, the correct
		// thing to do is to return an empty value.
		return m_varEmpty;
	}

	assert(ivar <= m_script.globals.Next());
	return m_stack[ivar];
}

HRESULT
Executor::ExecRoutine(Routines::index irtn, EXCEPINFO *pExcepInfo)
{
    WITH_STACK_PROTECTED;
 
    HRESULT hr = EnsureInitialized();
	if (FAILED(hr))
		return hr;

	Routine r = m_script.routines[irtn];

	UINT iLocals = m_stack.Next();
	hr = m_stack.Push(r.ivarNextLocal);
	if (FAILED(hr))
		return hr;

	hr = ExecStatements(r.istmtBody, pExcepInfo, iLocals);
	m_stack.PopTo(iLocals);
	return hr;
}

HRESULT
Executor::EnsureInitialized()
{
	if (m_fInitialized)
		return S_OK;

	// we'll keep the global variables right at the bottom of the stack
	// this function ensures that they get pushed on before any operations that use them
	HRESULT hr = m_stack.Push(m_script.globals.Next());
	if (FAILED(hr))
		return hr;

	// Also set the first items to the build in constant values True, False, and Nothing.
	// See also engparse.cpp which creates these global variables before parsing each script.
	if (m_stack.Next() < 3)
	{
		assert(false);
		return E_UNEXPECTED;
	}
	VARIANT &vTrue = m_stack[0];
	vTrue.vt = VT_I4;
	vTrue.lVal = VARIANT_TRUE;
	VARIANT &vFalse = m_stack[1];
	vFalse.vt = VT_I4;
	vFalse.lVal = VARIANT_FALSE;
	VARIANT &vNothing = m_stack[2];
	vNothing.vt = VT_UNKNOWN;
	vNothing.punkVal = NULL;
	
	m_fInitialized = true;
	return S_OK;
}

HRESULT
Executor::Error(EXCEPINFO *pExcepInfo, bool fOperation, const WCHAR *pwszBeginning, const char *paszMiddle, const WCHAR *pwszEnd)
{
	if (!pExcepInfo)
	{
		assert(false); // our script host should always request error info
		return DISP_E_EXCEPTION;
	}

	// NULL for beginning, middle, or end treated as empty string
	if (!pwszBeginning)
		pwszBeginning = L"";
	if (!paszMiddle)
		paszMiddle = "";
	if (!pwszEnd)
		pwszEnd = L"";

	pExcepInfo->wCode = 0;
	pExcepInfo->wReserved = 0;
	pExcepInfo->bstrSource = DMS_SysAllocString(g_fUseOleAut, fOperation ? L"Microsoft AudioVBScript Operation Failed" : L"Microsoft AudioVBScript Runtime Error");

	SmartRef::WString wstrMiddle = paszMiddle;
	WCHAR *pwszDescription = NULL;
	if (wstrMiddle)
	{
		pwszDescription = new WCHAR[wcslen(pwszBeginning) + wcslen(wstrMiddle) + wcslen(pwszEnd) + 1];
	}
	if (!pwszDescription)
	{
		// Oh well.  Just return no description if we're out of memory.
		pExcepInfo->bstrDescription = NULL;
	}
	else
	{
		wcscpy(pwszDescription, pwszBeginning);
		wcscat(pwszDescription, wstrMiddle);
		wcscat(pwszDescription, pwszEnd);
		pExcepInfo->bstrDescription = DMS_SysAllocString(g_fUseOleAut, pwszDescription);
		delete[] pwszDescription;
	}
	pExcepInfo->bstrHelpFile = NULL;
	pExcepInfo->pvReserved = NULL;
	pExcepInfo->pfnDeferredFillIn = NULL;
	pExcepInfo->scode = fOperation ? DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE : DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR;

	return DISP_E_EXCEPTION;
}

HRESULT
Executor::ErrorIfImproperRef(const VARIANT &v, bool fRef, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo)
{
	bool fIsObject = v.vt == VT_DISPATCH || v.vt == VT_UNKNOWN;
	if (fRef != fIsObject)
	{
		if (fRef)
			return ErrorObjectRequired(istrIdentifier, pExcepInfo);
		else
			return Error(pExcepInfo, false, L"Type mismatch: '", m_script.strings[istrIdentifier], L"'.  Likely cause is missing Set statement.");
	}

	return S_OK;
}

// Check for the error HRESULTs returned by IDispatch::Invoke.  Those that we expect to occur in AudioVBScript need to
// be converted into exception (DISP_E_EXCEPTION) so that the user gets a nice error message.

// The first parameter lets us know the kind of Invoke call that was made (property get, property set, function/sub call)
// so that we can tailor the message.

HRESULT
Executor::ErrorIfInvokeProblem(DispatchOperationType e, HRESULT hr, Strings::index istrIdentifier, EXCEPINFO *pExcepInfo)
{
	if (SUCCEEDED(hr) || HRESULT_FACILITY(hr) != FACILITY_DISPATCH || hr == DISP_E_EXCEPTION)
		return hr;

	const char *pszName = m_script.strings[istrIdentifier];
	if (hr == DISP_E_BADPARAMCOUNT)
	{
		// This can happen with a _call (obviously) and also with a get because property gets are also treated as function
		// calls with no arguments.  "x=GetMasterVolume" is valid but "x=Trace" would produce this error.  But I can't
		// see that this should occur with property sets.
		assert(e == _get || e == _call);

		return Error(pExcepInfo, false, L"Wrong number of parameters in call to '", pszName, L"'");
	}
	else if (hr == DISP_E_MEMBERNOTFOUND)
	{
		if (e == _call)
		{
			// Because Invoke was called, GetIDsOfNames must have succeeded, so the thing's name exists
			// but it must not be a method.
			return Error(pExcepInfo, false, L"Type mismatch: '", pszName, L"' is not a routine or method");
		}
		else if (e == _put || e == _putref)
		{
			return Error(pExcepInfo, false, L"Type mismatch: '", pszName, L"' is not a variable or is a read-only property");
		}
		else
		{
			// As mentioned above, a property get can be treated as either gets or function calls so they
			// shouldn't fail in this way.
			assert(false);
		}
	}
	else if (hr == DISP_E_TYPEMISMATCH)
	{
		// This indicates that one of the parameters was of the wrong type.
		if (e == _call)
		{
			return Error(pExcepInfo, false, L"Type mismatch: a parameter in call to '", pszName, L"' is not of the expected type");
		}
		else if (e == _put || e == _putref)
		{
			return Error(pExcepInfo, false, L"Type mismatch: value assigned to '", pszName, L"' is not of the expected type");
		}
		else
		{
			// Property gets don't have any parameters so this shouldn't happen.
			assert(false);
		}
	}
	else if (hr == DISP_E_PARAMNOTOPTIONAL)
	{
		if (e == _call)
		{
			return Error(pExcepInfo, false, L"A required parameter was omitted in call to '", pszName, L"'");
		}
		else
		{
			// Only calls should send an optional parameters.
			assert(false);
		}
	}

	// The other errors shouldn't normally occur in AudioVBScript.  They could occur if someone was
	// doing something ususual in a custom IDispatch interface, but we'll consider them exceptional cases and
	// just return the error HRESULT (meaning the user won't get a friendly text message).  Assert so we'll
	// find out if there are regular cases where this is happening in our testing.
	assert(false);

	// DISP_E_BADVARTYPE: We just use standard variant types.
	// DISP_E_NONAMEDARGS: We don't do named args.
	// DISP_E_OVERFLOW: AudioVBScript uses VT_I4 and so do our DMusic dispatch interfaces.
	// DISP_E_PARAMNOTFOUND: Only applies with named args.
	// DISP_E_UNKNOWNINTERFACE, DISP_E_UNKNOWNLCID: AudioVBScript uses calling convention and locale matching the DMusic dispatch interfaces.

	return hr;
}

HRESULT
Executor::ExecStatements(Statements::index istmt, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

	for (Statements::index istmtCur = istmt; /* ever */; ++istmtCur)
	{
		//  Check if this generates fast retail code.  If not, walk a pointer instead of using the index.

		Statement s = m_script.statements[istmtCur];
		switch (s.k)
		{
		case Statement::_end:
			return hr;

		case Statement::_asgn:
			hr = ExecAssignment(s.iasgn, pExcepInfo, iLocals);
			break;

		case Statement::_if:
			hr = ExecIf(s.iif, pExcepInfo, iLocals);
			istmtCur = s.istmtIfTail - 1;
			break;

		case Statement::_call:
			hr = ExecCall(s.icall, false, pExcepInfo, iLocals);
			break;
		}

		if (FAILED(hr))
		{
			if (hr == DISP_E_EXCEPTION)
			{
				// Save the statement's line number in the exception info.
				// Hack: See packexception.h for more info
				ULONG ulLine = s.iLine - 1; // The IActiveScript interfaces expects zero-based line and column numbers while we have them one-based.
				PackExceptionFileAndLine(g_fUseOleAut, pExcepInfo, NULL, &ulLine);
			}

			return hr;
		}
	}
}

HRESULT
Executor::ExecAssignment(Assignments::index iasgn, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	Assignment a = m_script.asgns[iasgn];

	VARIANT var;
	DMS_VariantInit(g_fUseOleAut, &var);
	HRESULT hr = EvalExpression(var, a.iexprRHS, pExcepInfo, iLocals);
	if (FAILED(hr))
		return hr;

	hr = SetVariableReference(a.fSet, a.ivarrefLHS, var, pExcepInfo, iLocals);
	DMS_VariantClear(g_fUseOleAut, &var);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
Executor::ExecIf(IfBlocks::index iif, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	for (IfBlocks::index i = iif; /* ever */; ++i)
	{
		IfBlock &ib = m_script.ifs[i];
		if (ib.k == IfBlock::_end)
        {
            break;
        }

		bool fMatch = true; // default to true because an else block always matches
		if (ib.k == IfBlock::_cond)
		{
			// if the condition isn't true, set match to false
			SmartVariant svar;
			EvalExpression(svar, ib.iexprCondition, pExcepInfo, iLocals);

			VARTYPE vt = static_cast<VARIANT&>(svar).vt;
			if (vt != VT_I4)
			{
				if (vt == VT_BSTR)
					return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement evaluated as a string where a numeric True/False value was expected", NULL, NULL);
				else if (vt == VT_UNKNOWN || vt == VT_DISPATCH)
					return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement evaluated as an object where a numeric True/False value was expected", NULL, NULL);
				return Error(pExcepInfo, false, L"Type mismatch: the condition of an if statement did not evaluate to a numeric True/False value", NULL, NULL);
			}
			if (static_cast<VARIANT&>(svar).lVal != VARIANT_TRUE)
				fMatch = false;
		}

		if (fMatch)
		{
			// found the block to take -- execute its statements and we're done
			return ExecStatements(ib.istmtBlock, pExcepInfo, iLocals);
		}
	}

	return S_OK;
}

// Helper function that eats up a set amount of stack space.
const UINT g_uiExecCallCheckStackBytes = 1484 * 4;
void ExecCallCheckStack();

// Helper function that returns true if the exception code needs to be caught.
LONG ExecCallExceptionFilter(DWORD dwExceptionCode)
{
	// We need to access violations as well as stack overflows.  The first time we run out
	// of stack space we get a stack overflow.  The next time we get an access violation.
	return dwExceptionCode == EXCEPTION_STACK_OVERFLOW || dwExceptionCode == EXCEPTION_ACCESS_VIOLATION;
}

HRESULT Executor::ExecCall(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	// This is a wrapper for ExecCallInternal, which actually does the work.  Here, we just want
	// to catch a potential stack overflow and return it as an error instead of GPF-ing.
	HRESULT hr = E_FAIL;
	__try
	{
		// It is better to fail now than to actually go ahead and call the routine and fail at some point we
		// can't predict.  Routines could do lots of different things including calling into DirectMusic or the
		// OS and we can't be sure we'd get the stack overflow exception and return in a good state.  This
		// routine uses more stack space than we'd expect recursive calls to require to get back to this point
		// again.  In essence, it clears the way, checking if there's enough stack space in a way we know is safe.
		ExecCallCheckStack();

#ifdef DBG
		// The value for g_uiExecCallCheckStackBytes was determined by experiment.  Each time through ExecCall,
		// the following code prints out the address of a char on the current stack and the difference between
		// the previous call.  I found that two scripts, which each evaluated an if statement (always true) and
		// then called the other one produced a difference of 1476.  Then I multiplied that by 4 for good measure.
		char c;
		static char *s_pchPrev = &c;
		DWORD s_dwPrevThreadID = 0;
		DWORD dwGrowth = 0;
		if (s_pchPrev > &c && s_dwPrevThreadID == GetCurrentThreadId())
			dwGrowth = s_pchPrev-&c;
		TraceI(4, "Stack: 0x%08x, -%lu\n", &c, dwGrowth);

		// This assert will fire if a path is executed where a recursive path back to this function takes
		// more stack space than g_uiExecCallCheckStackBytes.  If that's the case then g_uiExecCallCheckStackBytes
		// probably needs to be increased.
		assert(dwGrowth <= g_uiExecCallCheckStackBytes);

		s_pchPrev = &c;
		s_dwPrevThreadID = GetCurrentThreadId();
#endif

		// If we fail inside this call, it means g_uiExecCallCheckStackBytes probably needs to be increased because
		// ExecCallCheckStack didn't catch the stack overflow.
		hr = ExecCallInternal(icall, fPushResult, pExcepInfo, iLocals);
	}
	__except(ExecCallExceptionFilter(GetExceptionCode()))
	{
		Trace(1, "Error: Stack overflow.\n");

		// determine routine name
		Call &c = m_script.calls[icall];
		const char *pszCall = NULL;
		if (c.k == Call::_global)
		{
			pszCall = m_script.strings[c.istrname];
		}
		else
		{
			// name to use is last of the call's reference names
			for (ReferenceNames::index irname = m_script.varrefs[c.ivarref].irname; m_script.rnames[irname].istrIdentifier != -1; ++irname)
			{}
			pszCall = m_script.strings[m_script.rnames[irname - 1].istrIdentifier];
		}
		if (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW)
		{
			hr = Error(pExcepInfo, false, L"Out of stack space: '", pszCall, L"'.  Too many nested function calls.");
		}
		else
		{
			hr = Error(pExcepInfo, false, L"Out of stack space or catastrophic error: '", pszCall, L"'.");
		}
	}
	return hr;
}

// This function doesn't actually do anything besides occupying stack space.  Turn off optimization so the
// copiler doesn't get all clever on us and skip it.
#pragma optimize("", off)
void ExecCallCheckStack()
{
	char chFiller[g_uiExecCallCheckStackBytes];
	chFiller[g_uiExecCallCheckStackBytes - 1] = '\0';
}
#pragma optimize("", on)

HRESULT Executor::ExecCallInternal(Calls::index icall, bool fPushResult, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;
	SmartVariant svar; // holds temporary variant values at various points
	SmartVariant svar2; // ditto

	Call &c = m_script.calls[icall];

	IDispatch *pDispCall = NULL;
	Strings::index istrCall = 0;
	const char *pszCall = NULL;

	if (c.k == Call::_global)
	{
		istrCall = c.istrname;
		pszCall = m_script.strings[istrCall];

		// Handle the call directly if it is a call to one of the script's own Routines.
		Routines::index irtnLast = m_script.routines.Next();
		for (Routines::index irtn = 0; irtn < irtnLast; ++irtn)
		{
			if (0 == _stricmp(pszCall, m_script.strings[m_script.routines[irtn].istrIdentifier]))
			{
				return ExecRoutine(irtn, pExcepInfo);
			}
		}

		// Must be a call to the global script API.
		pDispCall = m_scomGlobalDispatch;
	}
	else
	{
		assert(c.k == Call::_dereferenced);
		// count the reference names (needed later)
		for (ReferenceNames::index irname = m_script.varrefs[c.ivarref].irname; m_script.rnames[irname].istrIdentifier != -1; ++irname)
		{}
		assert(irname - m_script.varrefs[c.ivarref].irname > 1); // if there was only one name, this should have been a global call

		hr = VariableReferenceInternal(_call, c.ivarref, svar, pExcepInfo, iLocals);
		if (FAILED(hr))
			return hr;
		hr = ChangeToDispatch(svar, pExcepInfo, irname - 2);
		if (FAILED(hr))
			return hr;
		pDispCall = static_cast<VARIANT>(svar).pdispVal;

		// the method name is the last reference name
		istrCall = m_script.rnames[irname - 1].istrIdentifier;
		pszCall = m_script.strings[istrCall];
	}

	DISPID dispidCall = GetDispID(pDispCall, pszCall);
	if (dispidCall == DISPID_UNKNOWN)
	{
		return Error(pExcepInfo, false, L"The routine '", pszCall, L"' does not exist");
	}

	// We'll push the parameters onto the stack.  (The function we're calling doesn't actually read them directly using the stack, but
	// it is a convenient place for us to keep them temporarily.)

	// First, count the parameters.
	UINT cParams = 0;
	for (ExprBlocks::index iexpr = c.iexprParams; m_script.exprs[iexpr]; ++iexpr)
	{
		// each parameter is an expression terminated by an end block
		++cParams;
		while (m_script.exprs[++iexpr])
		{}
	}

	// Make space for them.
	UINT iParamSlots = m_stack.Next();
	hr = m_stack.Push(std::max<UINT>(cParams, fPushResult ? 1 : 0)); // even if there are no params, leave one slot for the result if fPushResult is true
	if (FAILED(hr))
		return hr;

	// Fill the params in reverse order.
	iexpr = c.iexprParams;
	for (UINT iParam = iParamSlots + cParams - 1; iParam >= iParamSlots; --iParam)
	{
		if (m_script.exprs[iexpr].k == ExprBlock::_omitted)
		{
			// write the variant value IDispatch::Invoke uses for an omitted parameter
			m_stack[iParam].vt = VT_ERROR;
			m_stack[iParam].scode = DISP_E_PARAMNOTFOUND;
		}
		else
		{
			hr = EvalExpression(svar, iexpr, pExcepInfo, iLocals);
			if (FAILED(hr))
				return hr;

			hr = DMS_VariantCopy(g_fUseOleAut, &m_stack[iParam], &svar);
			if (FAILED(hr))
				return hr;
		}

		// each parameter is an expression terminated by an end block
		++iexpr;
		while (m_script.exprs[iexpr++])
		{}
	}

	DISPPARAMS dispparams;
	Zero(&dispparams);
	dispparams.rgvarg = cParams > 0 ? &m_stack[iParamSlots] : NULL;
	dispparams.rgdispidNamedArgs = NULL;
	dispparams.cArgs = cParams;
	dispparams.cNamedArgs = 0;

	// Make the call.
	// Push the result onto the stack if fPushResult is true.


	hr = InvokeAttemptingNotToUseOleAut(
			pDispCall,
			dispidCall,
			DISPATCH_METHOD,
			&dispparams,
			fPushResult ? &svar2 : NULL, // We can't save the result directly onto the stack because we could be makeing a 
                                         // recursive script call that could cause a stack to be reallocation, 
                                         // invalidating the address so we use svar2 instead.
			pExcepInfo,
			NULL);

	hr = ErrorIfInvokeProblem(_call, hr, istrCall, pExcepInfo);
	if (SUCCEEDED(hr) && fPushResult)
	{
		hr = DMS_VariantCopy(g_fUseOleAut, &m_stack[iParamSlots], &svar2);
	}

	m_stack.PopTo(iParamSlots + (fPushResult ? 1 : 0));
	if (FAILED(hr))
		return hr;

	return S_OK;
}

// possible error-message type returns: DISP_E_TYPEMISMATCH
HRESULT
Executor::EvalExpression(VARIANT &varResult, ExprBlocks::index iexpr, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

    UINT iTempSlots = m_stack.Next();

	for (ExprBlocks::index iexprCur = iexpr; /* ever */; ++iexprCur)
	{
		ExprBlock &e = m_script.exprs[iexprCur];
		switch (e.k)
		{
		case ExprBlock::_end:
			// pop the result and return it
			if (m_stack.Next() != iTempSlots + 1)
			{
				assert(false);
				return E_FAIL;
			}

			DMS_VariantCopy(g_fUseOleAut, &varResult, &m_stack[iTempSlots]);
			m_stack.PopTo(iTempSlots);
			return hr;

		case ExprBlock::_op:
			// Pop one (unary operator) or two (binary operator) items, apply the operator, and push the result.
			// (Actually, I just assign the result into the stack instead of pushing it, but conceptually the is
			//    the same as popping and pushing the new value.)
			{
				Token t = e.op;
				bool fUnary = t == TOKEN_op_not || t == TOKEN_sub;

				UINT iNext = m_stack.Next();
				if (iNext < iTempSlots + (fUnary ? 1 : 2))
				{
					assert(false);
					return E_FAIL;
				}

				VARIANT &v1 = m_stack[iNext - 1];
				if (fUnary)
					hr = EvalUnaryOp(t, v1);
				else
				{
					VARIANT &v2 = m_stack[iNext - 2];
					hr = EvalBinaryOp(t, v1, v2, pExcepInfo);
					m_stack.PopTo(iNext - 1);
				}
			}
			break;

		case ExprBlock::_val:
			{
				// push it
				hr = m_stack.Push(1);
				VARIANT &varToPush = m_stack[m_stack.Next() - 1];
				if (SUCCEEDED(hr))
					hr = EvalValue(e.ival, varToPush, pExcepInfo, iLocals);
				if (varToPush.vt == VT_EMPTY)
				{
					// treat an empty value as zero
					varToPush.vt = VT_I4;
					varToPush.lVal = 0;
				}
			}
			break;

		case ExprBlock::_call:
			// push it
			if (SUCCEEDED(hr))
				hr = ExecCall(e.icall, true, pExcepInfo, iLocals);
			break;
		}

		if (FAILED(hr))
		{
			m_stack.PopTo(iTempSlots);
			return hr;
		}
	}

	return S_OK;
}

HRESULT
Executor::EvalValue(Values::index ival, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	Value val = m_script.vals[ival];
	switch (val.k)
	{
	case Value::_numvalue:
		v.vt = VT_I4;
		v.lVal = val.inumvalue;
		break;

	case Value::_strvalue:
		{
			v.vt = VT_BSTR;
			SmartRef::WString wstr = m_script.strings[val.istrvalue];
			if (!wstr)
				return E_OUTOFMEMORY;
			v.bstrVal = DMS_SysAllocString(g_fUseOleAut, wstr);
			if (!v.bstrVal)
				return E_OUTOFMEMORY;
			break;
		}

	case Value::_varref:
		HRESULT hr = GetVariableReference(val.ivarref, v, pExcepInfo, iLocals);
		if (FAILED(hr))
			return hr;
	}

	return S_OK;
}

HRESULT
Executor::EvalUnaryOp(Token t, VARIANT &v)
{
	if (v.vt != VT_I4)
	{
		assert(false);
		return DISP_E_TYPEMISMATCH;
	}

	if (t == TOKEN_op_not)
	{
		v.lVal = ~v.lVal;
	}
	else
	{
		assert(t == TOKEN_sub);
		v.lVal = -v.lVal;
	}

	return S_OK;
}

HRESULT
Executor::EvalBinaryOp(Token t, VARIANT &v1, VARIANT &v2, EXCEPINFO *pExcepInfo)
{
	if (v1.vt == VT_DISPATCH || v1.vt == VT_UNKNOWN)
	{
		// the only operator that accepts object values is is
		if (t != TOKEN_is || !(v2.vt == VT_DISPATCH || v2.vt == VT_UNKNOWN))
		{
#ifdef XBOX
            // This assert is commented out on XBOX because it was causing problems. The assert was
            // fireing when a syntacticly incorrect script was executed. But this is just a script error,
            // nothing that we should assert about. (v2.vt is VT_I4 in this case.)
            // The offending code appears to be:
            //
            // if not (PSeg1 is Nothing) then
            //     Set PSeg1 = Nothing
            //
            // Presumably the value of Nothing is the integer 0, or something like that.
            // See bug 5337 DMusic: Scripting: Checking to see if variable/object is "nothing" can cause assert + int 3

#else
			assert(false);
#endif
			return DISP_E_TYPEMISMATCH;
		}

		HRESULT hr = DMS_VariantChangeType(g_fUseOleAut, &v1, &v1, 0, VT_UNKNOWN);
		if (FAILED(hr))
			return hr;
		hr = DMS_VariantChangeType(g_fUseOleAut, &v2, &v2, 0, VT_UNKNOWN);
		if (FAILED(hr))
			return hr;

		bool fIs = v1.punkVal == v2.punkVal;

		hr = DMS_VariantClear(g_fUseOleAut, &v2);
		if (FAILED(hr))
			return hr;

		v2.vt = VT_I4;
		v2.lVal = BoolForVB(fIs);
		return S_OK;
	}

	if (v1.vt != VT_I4 || v2.vt != VT_I4)
	{
		assert(false);
		return DISP_E_TYPEMISMATCH;
	}

	switch (t)
	{
	case TOKEN_op_minus:
		v2.lVal -= v1.lVal;
		break;
	case TOKEN_op_pow:
		v2.lVal = _Pow_int(v2.lVal, v1.lVal);
		break;
	case TOKEN_op_mult:
		v2.lVal *= v1.lVal;
		break;
	case TOKEN_op_div:
		if (v1.lVal == 0)
			return Error(pExcepInfo, false, L"Division by zero", NULL, NULL);
		v2.lVal /= v1.lVal;
		break;
	case TOKEN_op_mod:
        if (v1.lVal == 0)
            return Error(pExcepInfo, false, L"Mod by zero", NULL, NULL);
		v2.lVal %= v1.lVal;
		break;
	case TOKEN_op_plus:
		v2.lVal += v1.lVal;
		break;
	case TOKEN_op_lt:
		v2.lVal = BoolForVB(v2.lVal < v1.lVal);
		break;
	case TOKEN_op_leq:
		v2.lVal = BoolForVB(v2.lVal <= v1.lVal);
		break;
	case TOKEN_op_gt:
		v2.lVal = BoolForVB(v2.lVal > v1.lVal);
		break;
	case TOKEN_op_geq:
		v2.lVal = BoolForVB(v2.lVal >= v1.lVal);
		break;
	case TOKEN_op_eq:
		v2.lVal = BoolForVB(v2.lVal == v1.lVal);
		break;
	case TOKEN_op_neq:
		v2.lVal = BoolForVB(v2.lVal != v1.lVal);
		break;
	case TOKEN_and:
		v2.lVal &= v1.lVal;
		break;
	case TOKEN_or:
		v2.lVal |= v1.lVal;
		break;
	default:
		assert(false);
		return E_UNEXPECTED;
	}

	return S_OK;
}

// O.K. This is a bit funky, but bear with me.  This function has four different behaviors determined by the first (e) parameter.
// This is some ugly code, but at least this way I get to use it for multiple purposes.

// _get:    Returns the value of the variable reference via out parameter v.
// _put:    Sets the value of the variable reference to the in parameter v.
// _putref: Same as _put, but assigns by reference ala VB's 'set' statements.
// _call:   Same as _get, but returns the second-to-last value in the chain via out parameter v.
//           For example, if the reference is 'a.b.c' this returns the value of 'a.b', which can then be used to invoke function c.
//           It is an error to call VariableReferenceInternal in this way with only a single item such as 'a'.

HRESULT
Executor::VariableReferenceInternal(DispatchOperationType e, Variables::index ivarref, VARIANT &v, EXCEPINFO *pExcepInfo, UINT iLocals)
{
	HRESULT hr = S_OK;

	VariableReference r = m_script.varrefs[ivarref];
	bool fGlobal = r.k == VariableReference::_global;

	SmartVariant svar;

	assert(m_script.rnames[r.irname].istrIdentifier != -1);
	bool fJustOnePart = m_script.rnames[r.irname + 1].istrIdentifier == -1;
	if (fJustOnePart && e == _call)
	{
		assert(false);
		return E_UNEXPECTED;
	}

	//
	// Handle the base item of the reference, which is either a script variable or an item on the global dispatch.
	// If we're doing a set and there aren't more parts to the rnames, just do the set.
	// Otherwise, get the result into 'var'.
	//
	// Example:
	// x = 1
	//     There is just one part and it is a set.  Determine whether x is in the script or part of the global dispatch, set it to 1,
	//     and we're done.
	// x.y = 1
	//     x is the base.  Determine whether x is in the script or part of the global dispatch and get its value.  (We'll worry about
	//     setting the y property later in this function.
	//

	// check if the base is part of the global dispatch
	DISPID dispid = DISPID_UNKNOWN;
	if (fGlobal)
	{
		dispid = m_script.globals[r.ivar].dispid;
	}
	if (dispid != DISPID_UNKNOWN)
	{
		// base is part of global dispatch
		if (fJustOnePart && (e == _put || e == _putref))
		{
			// set it and we're done
			hr = SetDispatchProperty(m_scomGlobalDispatch, dispid, e == _putref, v, pExcepInfo);
			hr = ErrorIfInvokeProblem(e, hr, m_script.globals[r.ivar].istrIdentifier, pExcepInfo);
			return hr;
		}
		else
		{
			hr = GetDispatchProperty(m_scomGlobalDispatch, dispid, svar, pExcepInfo);
			hr = ErrorIfInvokeProblem(e, hr, m_script.globals[r.ivar].istrIdentifier, pExcepInfo);
			if (FAILED(hr))
				return hr;
		}
	}
	else
	{
		// base is in script
		VARIANT &vVariable = m_stack[r.ivar + (fGlobal ? 0 : iLocals)];

		if (fJustOnePart && (e == _put || e == _putref))
		{
			// set it and we're done
			hr = ErrorIfImproperRef(v, e == _putref, m_script.rnames[r.irname].istrIdentifier, pExcepInfo);
			if (FAILED(hr))
				return hr;
			hr = DMS_VariantCopy(g_fUseOleAut, &vVariable, &v);
			return hr;
		}
		else
		{
			hr = DMS_VariantCopy(g_fUseOleAut, &svar, &vVariable);
			if (FAILED(hr))
				return hr;
		}
	}

	//
	// Great!  The base value is now held in svar.  Any remaining rnames are a chain of properties we need to get from that object.
	// And the last rname needs to be a set if we're in one of the put modes or the last name is ignored if we're in the _call mode.
	//

	if (m_script.rnames[r.irname + 1].istrIdentifier != -1)
	{
		// the base value must be of object type
		hr = ErrorIfImproperRef(svar, true, m_script.rnames[r.irname].istrIdentifier, pExcepInfo);
		if (FAILED(hr))
			return hr;

		for (ReferenceNames::index irname = r.irname + 1; /* ever */; ++irname)
		{
			bool fLastPart = m_script.rnames[irname + 1].istrIdentifier == -1;
			if (fLastPart && e == _call)
				break;

			// get its IDispatch interface
			hr = ChangeToDispatch(svar, pExcepInfo, irname - 1);
			if (FAILED(hr))
				return hr;
			IDispatch *pDisp = static_cast<VARIANT>(svar).pdispVal;

			// get the dispid
			ReferenceName &rname = m_script.rnames[irname];
			DISPID dispidName = GetDispID(pDisp, m_script.strings[rname.istrIdentifier]);
			if (dispidName == DISPID_UNKNOWN)
				return Error(pExcepInfo, false, L"The property '", m_script.strings[rname.istrIdentifier], L"' does not exist");

			if (fLastPart && (e == _put || e == _putref))
			{
				// set it and we're done
				hr = SetDispatchProperty(pDisp, dispidName, e == _putref, v, pExcepInfo);
				hr = ErrorIfInvokeProblem(e, hr, rname.istrIdentifier, pExcepInfo);
				return hr;
			}
			else
			{
                svar.Clear();
				hr = GetDispatchProperty(pDisp, dispidName, svar, pExcepInfo);
				hr = ErrorIfInvokeProblem(e, hr, rname.istrIdentifier, pExcepInfo);
				if (FAILED(hr))
					return hr;
			}

			if (fLastPart)
			{
				// we've done all the names
				break;
			}
			else
			{
				// the new value must be of object type
				hr = ErrorIfImproperRef(svar, true, rname.istrIdentifier, pExcepInfo);
				if (FAILED(hr))
					return hr;
			}
		}
	}

	//
	// We're done.  Now we just have to return the value we calculated.  (We know that a set would have already returned.)
	//

	hr = DMS_VariantCopy(g_fUseOleAut, &v, &svar);
	return hr;
}

HRESULT
Executor::ChangeToDispatch(VARIANT &var, EXCEPINFO *pExcepInfo, ReferenceNames::index irnameIdentifier)
{
	HRESULT hr = DMS_VariantChangeType(g_fUseOleAut, &var, &var, 0, VT_DISPATCH);
	if (FAILED(hr))
		return ErrorObjectRequired(m_script.rnames[irnameIdentifier].istrIdentifier, pExcepInfo);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\oleaut.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper routines that wrap called to functions in oleaut32.  This enables us to
// compile free from any dependency on oleaut32.dll.  Each function takes a bool as
// its first argument, which is true if the oleaut32 function is to be called.  When
// false, our own implementation of the function is used.  In this case, some
// functionality is lost.  For example, only certain types of VARIANT variables are
// handled correctly in the abscence of oleaut32.
//
// oleaut32 is demand-loaded when the first function is called with a true parameter,
// unless one of the following is defined:
//  DMS_ALWAYS_USE_OLEAUT
//     causes oleaut32 to be used in all cases and statically linked.
//  DMS_NEVER_USE_OLEAUT
//     for use on platforms where oleaut32 isn't available -- always uses the
//     internal functions and asserts if true is ever passed.
//

#pragma once

// If this GUID is passed for riid when calling Invoke, the DirectMusic automation methods will behave according to a special
// calling convention whereby the functions in this file are used (with fUseOleAut as false) instead of those from
// oleaut32.
const GUID g_guidInvokeWithoutOleaut = { 0x1fcc43db, 0xbad8, 0x4a88, { 0xbc, 0x77, 0x4e, 0x1a, 0xe0, 0x2d, 0x9c, 0x79 } };


#ifdef DMS_ALWAYS_USE_OLEAUT

// VARIANTs
inline void DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg) { VariantInit(pvarg); }
inline HRESULT DMS_VariantClear(bool fUseOleAut, VARIANTARG *pvarg) { return VariantClear(pvarg); }
inline HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG *pvargDest, const VARIANTARG *pvargSrc) { return VariantCopy(pvargDest, const_cast<VARIANT*>(pvargSrc)); }
inline HRESULT DMS_VariantChangeType(bool fUseOleAut, VARIANTARG *pvargDest, VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt) { return VariantChangeType(pvargDest, pvarSrc, wFlags, vt); }

// BSTRs
inline BSTR DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz) { return SysAllocString(pwsz); }
inline void DMS_SysFreeString(bool fUseOleAut, BSTR bstr) { SysFreeString(bstr); }

#else

// VARIANTs
//  Without fUseOleAut, Only handles types VT_I4, VT_I2, VT_UNKNOWN, VT_DISPATCH and
//  doesn't call dispatch pointers for their value properties.
void DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg);
HRESULT DMS_VariantClear(bool fUseOleAut, VARIANTARG * pvarg);
HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG * pvargDest, const VARIANTARG * pvargSrc);
HRESULT DMS_VariantChangeType(bool fUseOleAut, VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);

// BSTRs
//  Without fUseOleAut, doesn't include size prefix -- plain C WCHAR strings.
BSTR DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz);
void DMS_SysFreeString(bool fUseOleAut, BSTR bstr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\oledll.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard crap for OLE server DLL
//
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

static const char g_szCLSID[]           = "CLSID";
static const char g_szCLSIDSlash[]      = "CLSID\\";
static const char g_szInProc32[]        = "InProcServer32";
static const char g_szProgIDKey[]       = "ProgID";
static const char g_szVerIndProgIDKey[] = "VersionIndependentProgID";
static const char g_szCurVer[]          = "CurVer"; 
static const char g_szThreadingModel[]	= "ThreadingModel";
static const char g_szBoth[]		= "Both";

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCSTR pstrKey, LPCSTR pstrSubkey, LPCSTR pstrValueName, LPCSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    char szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);
	strcat(szClsKey, "\\");
	strcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           char *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(char *szStr,
		   CLSID &clsid,
		   int cbStr)
{
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
}
   

static LONG
RegSetDefValue(LPCSTR pstrKey,
               LPCSTR pstrSubkey,
			   LPCSTR pstrValueName,
               LPCSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    char sz[1024];
    LPCSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        strcpy(sz, pstrKey);
        strcat(sz, "\\");
        strcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+strlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

    char szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engdisp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of EngineDispatch.
//

/*#include "stdinc.h"
#include "enginc.h"
#include "engdisp.h"
#include "limits"
#include "oleaut.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Global constants

const DISPID g_dispidFirstRoutine = 1;
const DISPID g_dispidFirstGlobal = 1000001;

//////////////////////////////////////////////////////////////////////
// ASCII comparison of WCHAR and char strings

bool wcsstrimatch(const WCHAR *pwsz, const char *pasz)
{
	for (;;)
	{
		if (*pwsz > 127) // Out of range for char?
			return false;

		char ch1 = (char)tolower((char)*pwsz++); //  make sure tolower is the right kind of function
		char ch2 = (char)tolower((char)*pasz++);
		if (ch1 != ch2)
			return false;

		if (!ch1)
			return true;
	}
}

//////////////////////////////////////////////////////////////////////
// Creation

EngineDispatch::EngineDispatch(IUnknown *punkParent, Script &script, IDispatch *pGlobalDispatch)
  : m_cRef(1),
	m_scomParent(punkParent),
	m_script(script),
	m_exec(script, pGlobalDispatch)
{
	punkParent->AddRef();
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
EngineDispatch::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(EngineDispatch::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDispatch)
	{
		*ppv = static_cast<IDispatch*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
EngineDispatch::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
EngineDispatch::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDispatch

STDMETHODIMP
EngineDispatch::GetTypeInfoCount(UINT *pctinfo)
{
	V_INAME(EngineDispatch::GetTypeInfoCount);
	V_PTR_WRITE(pctinfo, *pctinfo);

	*pctinfo = 1;
	return S_OK;
}

STDMETHODIMP
EngineDispatch::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	V_INAME(EngineDispatch::GetTypeInfo);
	V_PTR_WRITE(ppTInfo, *ppTInfo);

	if (iTInfo != 0)
		return DISP_E_BADINDEX;

	*ppTInfo = static_cast<ITypeInfo *>(this);
	this->AddRef();
	return S_OK;
}

STDMETHODIMP
EngineDispatch::GetIDsOfNames(
		REFIID riid,
		LPOLESTR *rgszNames,
		UINT cNames,
		LCID lcid,
		DISPID *rgDispId)
{
	V_INAME(EngineDispatch::GetIDsOfNames);
	V_BUFPTR_READ(rgszNames, sizeof(LPOLESTR) * cNames);
	V_BUFPTR_WRITE(rgDispId, sizeof(DISPID) * cNames);

	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0)
		return S_OK;

	// Clear out dispid's
	for (UINT c = 0; c < cNames; ++c)
	{
		rgDispId[c] = DISPID_UNKNOWN;
	}

	//  Possible optimization: sort the routines/globals so that we can bsearch for names.

	// See if we have a routine with the first name
	Routines::index irtnLast = m_script.routines.Next();
	for (Routines::index irtn = 0; irtn < irtnLast; ++irtn)
	{
		if (wcsstrimatch(rgszNames[0], m_script.strings[m_script.routines[irtn].istrIdentifier]))
		{
			rgDispId[0] = g_dispidFirstRoutine + irtn;
			break;
		}
	}

	if (rgDispId[0] == DISPID_UNKNOWN)
	{
		// See if we have a global variable with the first name
		Variables::index ivarLast = m_script.globals.Next();
		for (Variables::index ivar = g_cBuiltInConstants; ivar < ivarLast; ++ivar)
		{
			Variable &variable = m_script.globals[ivar];
			if (variable.dispid == DISPID_UNKNOWN &&   // variable must be in script (not member of global dispatch)
					wcsstrimatch(rgszNames[0], m_script.strings[variable.istrIdentifier]))
			{
				rgDispId[0] = g_dispidFirstGlobal + ivar;
				break;
			}
		}
	}

	// Additional names requested (cNames > 1) are named parameters to the method,
	//    which isn't something we support.
	// Return DISP_E_UNKNOWNNAME in this case, and in the case that we didn't match
	//    the first name.
	if (rgDispId[0] == DISPID_UNKNOWN || cNames > 1)
		return DISP_E_UNKNOWNNAME;

	return S_OK;
}

STDMETHODIMP
EngineDispatch::Invoke(
		DISPID dispIdMember,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pDispParams,
		VARIANT *pVarResult,
		EXCEPINFO *pExcepInfo,
		UINT *puArgErr)
{
	V_INAME(EngineDispatch::Invoke);
	V_PTR_READ(pDispParams, DISPPARAMS);
	V_PTR_WRITE_OPT(pVarResult, VARIANT);
	V_PTR_WRITE_OPT(puArgErr, UINT);

	// Additional parameter validation

	bool fReturnValueUsingOleAut = g_fUseOleAut || riid != g_guidInvokeWithoutOleaut;
	// This is true unless g_fUseOleAut is false (script engine is set to always use oleaut32.dll
	// and riid is g_guidInvokeWithoutOleaut (caller expects this not to return values allocated with
	// oleaut32.dll.  See oleaut.h for more info.

	if (fReturnValueUsingOleAut && riid != IID_NULL)
	{
		return DISP_E_UNKNOWNINTERFACE;
	}

	// Zero the out params

	if (puArgErr)
		*puArgErr = 0;

	HRESULT hr = S_OK;
	if (dispIdMember < g_dispidFirstGlobal)
	{
		// it's a routine
		if (!(wFlags & DISPATCH_METHOD))
			return DISP_E_MEMBERNOTFOUND;

		Routines::index irtn = dispIdMember - g_dispidFirstRoutine;
		if (irtn >= m_script.routines.Next())
			return DISP_E_MEMBERNOTFOUND;

		if (pDispParams->cArgs > 0)
			return DISP_E_BADPARAMCOUNT;
		if (pDispParams->cNamedArgs > 0)
			return DISP_E_NONAMEDARGS;

		if (pVarResult)
		{
			assert(false);
			return E_UNEXPECTED;
		}

		hr = m_exec.ExecRoutine(irtn, pExcepInfo);
	}
	else
	{
		// it's a global variable
		Variables::index ivar = dispIdMember - g_dispidFirstGlobal;
		if (ivar >= m_script.globals.Next())
			return DISP_E_MEMBERNOTFOUND;

		if (wFlags & DISPATCH_PROPERTYGET)
		{
			if (pDispParams->cArgs > 0)
				return DISP_E_BADPARAMCOUNT;
			if (pDispParams->cNamedArgs > 0)
				return DISP_E_NONAMEDARGS;

			if (pVarResult)
			{
				DMS_VariantInit(fReturnValueUsingOleAut, pVarResult);
				DMS_VariantCopy(fReturnValueUsingOleAut, pVarResult, &m_exec.GetGlobal(ivar));
			}

			return S_OK;
		}
		else
		{
			if (!(wFlags & (DISPATCH_PROPERTYPUTREF | DISPATCH_PROPERTYPUT)))
				return DISP_E_MEMBERNOTFOUND;

			bool fPutRef = !!(wFlags & DISPATCH_PROPERTYPUTREF);
			assert(fPutRef || wFlags & DISPATCH_PROPERTYPUT);

			if (pDispParams->cArgs != 1)
				return DISP_E_BADPARAMCOUNT;
			if (pDispParams->cNamedArgs != 1)
				return DISP_E_BADPARAMCOUNT;
			if (*pDispParams->rgdispidNamedArgs != DISPID_PROPERTYPUT)
				return DISP_E_PARAMNOTFOUND;

			if (pVarResult)
				return E_INVALIDARG;

			hr = m_exec.SetGlobal(ivar, pDispParams->rgvarg[0], fPutRef, pExcepInfo);
		}
	}

	// If an exception occurred, we need to convert the error strings into our own kind of BSTR.
	if (hr == DISP_E_EXCEPTION)
		ConvertOleAutExceptionBSTRs(false, fReturnValueUsingOleAut, pExcepInfo);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// ITypeInfo

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetTypeAttr(
		/* [out] */ TYPEATTR **ppTypeAttr)
{
	V_INAME(EngineDispatch::GetTypeAttr);
	V_PTR_WRITE(ppTypeAttr, *ppTypeAttr);

	*ppTypeAttr = new TYPEATTR;
	if (!*ppTypeAttr)
		return E_OUTOFMEMORY;

	Zero(*ppTypeAttr);

	(*ppTypeAttr)->cFuncs = (unsigned short)m_script.routines.Next();

	// Count the global variables  -- necessary because some are on the global dispatch
	// and we don't want to report them.
	int cVars = 0;
	Variables::index iLastGlobal = m_script.globals.Next();
	for (Variables::index  iGlobal = g_cBuiltInConstants; iGlobal < iLastGlobal; ++iGlobal)
	{
		if (m_script.globals[iGlobal].dispid == DISPID_UNKNOWN)
			++cVars;
	}
	(*ppTypeAttr)->cVars = (unsigned short)cVars;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseTypeAttr(
		/* [in] */ TYPEATTR *pTypeAttr)
{
	assert(!IsBadReadPtr(pTypeAttr, sizeof(*pTypeAttr)));
	delete pTypeAttr;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetFuncDesc(
		/* [in] */ UINT index,
		/* [out] */ FUNCDESC **ppFuncDesc)
{
	V_INAME(EngineDispatch::GetFuncDesc);
	V_PTR_WRITE(ppFuncDesc, *ppFuncDesc);
	if (index >= (UINT) m_script.routines.Next())
		return E_INVALIDARG;

	*ppFuncDesc = new FUNCDESC;
	if (!*ppFuncDesc)
		return E_OUTOFMEMORY;

	Zero(*ppFuncDesc);
	(*ppFuncDesc)->funckind = FUNC_DISPATCH;
	(*ppFuncDesc)->invkind = INVOKE_FUNC;
	(*ppFuncDesc)->cParams = 0;
	(*ppFuncDesc)->memid = index + g_dispidFirstRoutine;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseFuncDesc(
		/* [in] */ FUNCDESC *pFuncDesc)
{
	assert(!IsBadReadPtr(pFuncDesc, sizeof(*pFuncDesc)));
	delete pFuncDesc;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetVarDesc(
		/* [in] */ UINT index,
		/* [out] */ VARDESC **ppVarDesc)
{
	V_INAME(EngineDispatch::GetVarDesc);
	V_PTR_WRITE(ppVarDesc, *ppVarDesc);

	// Count until we find the global (non-dispatch-based) variable at the index position.
	UINT cFuncs = 0;
	Variables::index iLastGlobal = m_script.globals.Next();
	for (Variables::index  iGlobal = g_cBuiltInConstants; iGlobal < iLastGlobal; ++iGlobal)
	{
		if (m_script.globals[iGlobal].dispid == DISPID_UNKNOWN)
		{
			if (cFuncs == index)
				break;
			else
				++cFuncs;
		}
	}

	if (cFuncs < index)
	{
		// there aren't that many variables
		return E_INVALIDARG;
	}

	*ppVarDesc = new VARDESC;
	if (!*ppVarDesc)
		return E_OUTOFMEMORY;

	Zero(*ppVarDesc);
	(*ppVarDesc)->varkind = VAR_DISPATCH;
	(*ppVarDesc)->memid = iGlobal + g_dispidFirstGlobal;

	return S_OK;
}

void STDMETHODCALLTYPE
EngineDispatch::ReleaseVarDesc(
		/* [in] */ VARDESC *pVarDesc)
{
	assert(!IsBadReadPtr(pVarDesc, sizeof(*pVarDesc)));
	delete pVarDesc;
}

HRESULT STDMETHODCALLTYPE
EngineDispatch::GetNames(
		/* [in] */ MEMBERID memid,
		/* [length_is][size_is][out] */ BSTR *rgBstrNames,
		/* [in] */ UINT cMaxNames,
		/* [out] */ UINT *pcNames)
{
	V_INAME(EngineDispatch::GetNames);
	if (memid < g_dispidFirstRoutine)
		return E_INVALIDARG;
	V_PTR_WRITE(rgBstrNames, *rgBstrNames);
	if (cMaxNames != 1)
		return E_INVALIDARG;
	V_PTR_WRITE(pcNames, *pcNames);

	assert(g_dispidFirstRoutine < g_dispidFirstGlobal);
	Strings::index iStr = 0;
	if (memid < g_dispidFirstGlobal)
	{
		const int iSlot = memid - g_dispidFirstRoutine;
		if (iSlot >= m_script.routines.Next())
			return E_INVALIDARG;
		iStr = m_script.routines[iSlot].istrIdentifier;
	}
	else
	{
		const int iSlot = memid - g_dispidFirstGlobal;
		if (iSlot >= m_script.globals.Next())
			return E_INVALIDARG;
		iStr = m_script.globals[iSlot].istrIdentifier;
	}

	SmartRef::WString wstrName = m_script.strings[iStr];
	if (!wstrName)
		return E_OUTOFMEMORY;
	*rgBstrNames = DMS_SysAllocString(g_fUseOleAut, wstrName);
	if (!*rgBstrNames)
		return E_OUTOFMEMORY;

	*pcNames = 1;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\packexception.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of PackExceptionFileAndLine and UnpackExceptionFileAndLine.
//

/*#include "stdinc.h"
#include "packexception.h"
#include "oleaut.h"*/

#include "pchscript.h"

const WCHAR g_wszDescriptionFileSeparator[] = L""; // magic character for separating the filename, line, and description
const WCHAR g_wchDescriptionFileSeparator = g_wszDescriptionFileSeparator[0];

void SeparateDescriptionFileAndLine(BSTR bstrDescription, const WCHAR **ppwszFilename, const WCHAR **ppwszLine, const WCHAR **ppwszDescription)
{
    assert(bstrDescription && ppwszFilename && ppwszLine && ppwszDescription);

    // if there aren't any packed fields, the whole thing is the description
    *ppwszDescription = bstrDescription;

    WCHAR *pwszLine = wcsstr(bstrDescription, g_wszDescriptionFileSeparator);
    if (!pwszLine)
        return;

    WCHAR *pwszDescription = wcsstr(pwszLine + 1, g_wszDescriptionFileSeparator);
    if (!pwszDescription)
        return;

    // String looks like this:
    //                             MyScript.spt23Description of the error
    // pExcepInfo->bstrDescription-^  pwszLine-^  ^-pwszDescription

    *ppwszFilename = bstrDescription;
    assert(*pwszLine == g_wchDescriptionFileSeparator);
    *ppwszLine = pwszLine + 1;
    assert(*pwszDescription == g_wchDescriptionFileSeparator);
    *ppwszDescription = pwszDescription + 1;
}

bool wcsIsBlankTillSeparator(const WCHAR *pwsz)
{
    return !pwsz[0] || pwsz[0] == g_wchDescriptionFileSeparator;
}

void wcscpyTillSeparator(WCHAR *pwszDestination, const WCHAR *pwszSource)
{
    assert(pwszDestination && pwszSource);
    while (!wcsIsBlankTillSeparator(pwszSource))
    {
        *pwszDestination++ = *pwszSource++;
    }
    *pwszDestination = L'\0';
}

void wcscatTillSeparator(WCHAR *pwszDestination, const WCHAR *pwszSource)
{
    assert(pwszDestination && pwszSource);
    while (*pwszDestination != L'\0')
        ++pwszDestination;

    wcscpyTillSeparator(pwszDestination, pwszSource);
}

void PackExceptionFileAndLine(bool fUseOleAut, EXCEPINFO *pExcepInfo, const WCHAR *pwszFilename, const ULONG *pulLine)
{
    if (!pExcepInfo || !pExcepInfo->bstrDescription)
        return;

    const WCHAR *pwszDescrFilename = L"";
    const WCHAR *pwszDescrLine = L"";
    const WCHAR *pwszDescrDescription = L"";

    SeparateDescriptionFileAndLine(pExcepInfo->bstrDescription, &pwszDescrFilename, &pwszDescrLine, &pwszDescrDescription);

    if (wcsIsBlankTillSeparator(pwszDescrFilename) && pwszFilename)
    {
        // Filename is blank.  Use the specified filename.
        pwszDescrFilename = pwszFilename;
    }

    WCHAR wszLineBuffer[34] = L""; // MSDN documentation for _ultow says max is 33 characters
    if (wcsIsBlankTillSeparator(pwszDescrLine) && pulLine)
    {
        // Line is blank.  Use the specified line.
        _ultow(*pulLine, wszLineBuffer, 10);
        pwszDescrLine = wszLineBuffer;
    }

    WCHAR *pwszNewDescription = new WCHAR[wcslen(pwszDescrFilename) + wcslen(pwszDescrLine) + wcslen(pwszDescrDescription) + (wcslen(g_wszDescriptionFileSeparator) * 2 + 1)];
    if (pwszNewDescription)
    {
        wcscpyTillSeparator(pwszNewDescription, pwszDescrFilename);
        wcscat(pwszNewDescription, g_wszDescriptionFileSeparator);
        wcscatTillSeparator(pwszNewDescription, pwszDescrLine);
        wcscat(pwszNewDescription, g_wszDescriptionFileSeparator);
        wcscat(pwszNewDescription, pwszDescrDescription);
        DMS_SysFreeString(fUseOleAut, pExcepInfo->bstrDescription);
        pExcepInfo->bstrDescription = DMS_SysAllocString(fUseOleAut, pwszNewDescription);
        delete[] pwszNewDescription;
    }
}

void UnpackExceptionFileAndLine(BSTR bstrDescription, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    assert(pErrorInfo && bstrDescription);

    if (pErrorInfo && bstrDescription)
    {

        const WCHAR *pwszDescrFilename = L"";
        const WCHAR *pwszDescrLine = L"";
        const WCHAR *pwszDescrDescription = L"";

        SeparateDescriptionFileAndLine(bstrDescription, &pwszDescrFilename, &pwszDescrLine, &pwszDescrDescription);

        // String looks like this:
        //                             CoolScriptFile.spt23Description of the error
        //           pwszDescrFilename-^    pwszDescrLine-^  ^-pwszDescrDescription
        // Except that if these weren't found then they point to a separate empty string.

        if (!wcsIsBlankTillSeparator(pwszDescrFilename))
        {
            // Filename is present.  Copy to pErrorInfo.
            assert(*(pwszDescrLine - 1) == g_wchDescriptionFileSeparator);
#ifdef DXAPI
            wcsTruncatedCopy(pErrorInfo->wszSourceFile,
                                pwszDescrFilename,
                                std::min<UINT>(DMUS_MAX_FILENAME, pwszDescrLine - pwszDescrFilename));
#else
            wcstombs(pErrorInfo->wszSourceFile,
                                pwszDescrFilename,
                                std::min<UINT>(DMUS_MAX_FILENAME, pwszDescrLine - pwszDescrFilename));
#endif
        }

        if (!wcsIsBlankTillSeparator(pwszDescrLine))
        {
            // Line is present.  Copy to pErrorInfo.
            WCHAR *pwszLineSeparator = const_cast<WCHAR *>(pwszDescrDescription - 1);
            assert(*pwszLineSeparator == g_wchDescriptionFileSeparator);
            *pwszLineSeparator = L'\0'; // terminate the line for wcstoul
            pErrorInfo->ulLineNumber = wcstoul(pwszDescrLine, NULL, 10);
            *pwszLineSeparator = g_wchDescriptionFileSeparator; // restore the separator
        }

        // Always copy the description
#ifdef DXAPI
        wcsTruncatedCopy(pErrorInfo->wszDescription, pwszDescrDescription, DMUS_MAX_FILENAME);
#else
        wcstombs(pErrorInfo->wszDescription, pwszDescrDescription, DMUS_MAX_FILENAME);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\pchscript.h ===
#include "stdinc.h"
#include <objbase.h> // Need IClassFactory
#include <initguid.h>
#include "..\shared\critsec.h"
#include "engcontrol.h"
#include "oledll.h"
#include "globaldisp.h"
#include "activescript.h"
#include "activscp.h"
#include "unkhelp.h"
#include "dll.h"
#include "containerdisp.h"
#include "dmscript.h"
#include "packexception.h"
#include "oleaut.h"
#include "dmscript.h"
#include "authelper.h"
#include "packexception.h"
#include "engine.h"
#include "track.h"
#include "dmusicf.h"
#include "trackshared.h"
#include "dmusicp.h"
#include "engine.h"
#include "englex.h" // 
#include "engparse.h" // 
#include "enginc.h"
#include "engerror.h"
#include "engdisp.h"
#include "engexpr.h"
#include "engexec.h"
#include "englookup.h"
#ifdef LIMITEDVBSCRIPT_LOGLEXER
#include "englog.h"
#endif
#include "math.h"
#include "packexception.h"
#include "autperformance.h"
#include <limits>
#include "dmusicf.h"
#include "autsegment.h"
#include "autsong.h"
#include "autsegmentstate.h"
#include "autaudiopathconfig.h"
#include "autaudiopath.h"
#include "globaldisp.h"
#include "autconstants.h"
#include "dmscriptautguids.h"
#include "sourcetext.h"
#include "scriptthread.h"
#include "..\shared\xcreate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\packexception.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Hack: There's no room in the EXCEPINFO for a filename and line number.  This is a problem when scripts
// call each other because the filename/line need to percolate with the error so that the eventual
// error message displays the filename/line of the script where the error orgiginated.
//    We'll just pack the error in with the description and then unpack it when the IDirectMusicScript
// interface returns its DMUS_SCRIPT_ERRORINFO, which does have a filename.
//

#pragma once

// Saves filname and line number into the description of the exception.  Any of the parameters may be null.
void PackExceptionFileAndLine(bool fUseOleAut, EXCEPINFO *pExcepInfo, const WCHAR *pwszFilename, const ULONG *pulLine);

// Retrieves filname and line number using a description from the exception.
// The ulLineNumber, wszSourceFile, and wszDescription fields of pErrorInfo are set if they are present in the description.
// Neither parameter may be null.
void UnpackExceptionFileAndLine(BSTR bstrDescription, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

	sources.

Abstract:

	This file specifies the target component being built and the list of
	sources files needed to build that component.  Also specifies optional
	compiler switches and libraries that are unique for the component being
	built.


Author:

	Jim Geist (JimGe) 29-Aug-97

NOTE:	Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmscript$(LIBEXT)
TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj
USE_MAPSYM=1

!if $(USE_VC7)
ENABLE_LINK_TIME_CODE_GENERATION=0
!endif

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DDMS_NEVER_USE_OLEAUT -D_MT

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchscript.h
PRECOMPILED_PCH=pchscript.pch
PRECOMPILED_OBJ=pchscript.obj

INCLUDES = $(INCLUDES);   \
	       ..\..\shared; \
	       ..\..\xprivate; \
               ..

SOURCES=\
	activescript.cpp			\
	autaudiopath.cpp			\
	autaudiopathconfig.cpp	\
	autconstants.cpp			\
	authelper.cpp			\
	autperformance.cpp		\
	autsegment.cpp			\
	autsegmentstate.cpp		\
	autsong.cpp				\
	containerdisp.cpp		\
	dll_dmscript.cpp		\
	dmscript.cpp				\
	engdisp.cpp				\
	engerror.cpp				\
	engexec.cpp				\
	engexpr.cpp				\
	enginc.cpp				\
	engine.cpp				\
	englex.cpp				\
	englookup.cpp			\
	engparse.cpp				\
	globaldisp.cpp			\
	oleaut.cpp				\
	packexception.cpp		\
	sourcetext.cpp			\
	track.cpp				\
	trackshared.cpp			\
	unkhelp.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\sourcetext.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSourceText.
//

/*#include "stdinc.h"
#include "dll.h"
#include "sourcetext.h"*/

#include "pchscript.h"

const GUID CLSID_DirectMusicSourceText = { 0xc70eb77f, 0xefd4, 0x4678, { 0xa2, 0x7b, 0xbf, 0x16, 0x48, 0xf3, 0xd, 0x4 } }; // {C70EB77F-EFD4-4678-A27B-BF1648F30D04}
const GUID IID_IDirectMusicSourceText = { 0xa384ffed, 0xa708, 0x48de, { 0x85, 0x5b, 0x90, 0x63, 0x8b, 0xa5, 0xc0, 0xac } }; // {A384FFED-A708-48de-855B-90638BA5C0AC}

//////////////////////////////////////////////////////////////////////
// Creation

CSourceText::CSourceText()
  : m_cRef(0)
{
	LockModule(true);
}

HRESULT
CSourceText::CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv)
{
	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	CSourceText *pInst = new CSourceText;
	if (pInst == NULL)
		return E_OUTOFMEMORY;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CSourceText::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CSourceText::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicSourceText)
	{
		*ppv = static_cast<IDirectMusicSourceText*>(this);
	}
	else if (iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if (iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if (iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG)
CSourceText::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CSourceText::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP
CSourceText::Load(IStream* pStream)
{
	V_INAME(CSourceText::Load);
	V_INTERFACE(pStream);

	// Record the stream's current position
	LARGE_INTEGER li;
	ULARGE_INTEGER ulStart;
	ULARGE_INTEGER ulEnd;
	li.HighPart = 0;
	li.LowPart = 0;

	HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ulStart);
	if (FAILED(hr))
		return hr;

	assert(ulStart.HighPart == 0); // We don't expect streams that big.
	DWORD dwSavedPos = ulStart.LowPart;

	// Get the stream's end and record the total size
	hr = pStream->Seek(li, STREAM_SEEK_END, &ulEnd);
	if (FAILED(hr))
		return hr;

	assert(ulEnd.HighPart == 0);
	assert(ulEnd.LowPart > dwSavedPos);
	DWORD cch = ulEnd.LowPart - dwSavedPos;

	// Go back to the start and copy the characters
	li.HighPart = 0;
	li.LowPart = dwSavedPos;
	hr = pStream->Seek(li, STREAM_SEEK_SET, &ulStart);
	if (FAILED(hr))
		return hr;
	assert(ulStart.LowPart == dwSavedPos);

	CHAR *paszSource = new CHAR[cch + 1];
	if (!paszSource)
		return E_OUTOFMEMORY;

	DWORD cbRead;
	hr = pStream->Read(paszSource, cch, &cbRead);
	if (FAILED(hr))
	{
		assert(false);
		return hr;
	}

	paszSource[cch] = '\0';

	m_wstrText.AssignFromA(paszSource);
	delete[] paszSource;
	if (!m_wstrText)
		return E_OUTOFMEMORY;

	m_cwchText = wcslen(m_wstrText);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicSourceText

STDMETHODIMP_(void)
CSourceText::GetTextLength(DWORD *pcwchRequiredBufferSize)
{
	*pcwchRequiredBufferSize = m_cwchText + 1;
}

STDMETHODIMP_(void)
CSourceText::GetText(WCHAR *pwszText)
{
	wcscpy(pwszText, m_wstrText);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\scriptthread.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSingleThreadedScriptManager.
// Wraps CActiveScriptManager to accept calls from multiple scripts and behind the
//    scenes farms them out to a single worker thread that actually talks to the script engine.
//
// The virtual base class ScriptManager can be used to talk to either
//    CActiveScriptManager or CSingleThreadedActiveScriptManager.
//

#pragma once

#include "workthread.h"

// forward declaration
class CDirectMusicScript;

class ScriptManager
{
public:
	virtual HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT ScriptTrackCallRoutine(
						const WCHAR *pwszRoutineName,
						IDirectMusicSegmentState *pSegSt,
						DWORD dwVirtualTrackID,
						bool fErrorPMsgsEnabled,
						__int64 i64IntendedStartTime,
						DWORD dwIntendedStartTimeFlags) = 0;
	virtual HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo) = 0;
	virtual HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems) = 0; // fRoutine true to get a routine, false to get a variable. pcItems (if supplied) is set to the total number of items
	virtual HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId) = 0;
	virtual HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr) = 0;
	virtual void Close() = 0;
	STDMETHOD_(ULONG, Release)() = 0;
};

#ifndef XBOX
// VBScript (and likely any other scripting languages besides our custom engine) fails if called from different threads.
// This class wraps such an engine, providing a ScriptManager interface that can be called from multiple threads but marshals
// all the calls to the engine onto a single worker thread.
class CSingleThreadedScriptManager : public ScriptManager
{
public:
	// The worker thread needs to be cleaned up using the static member function before the .dll is unloaded.
	static void TerminateThread() { ms_Thread.Terminate(true); }
	CSingleThreadedScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo);

	HRESULT Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT ScriptTrackCallRoutine(
				const WCHAR *pwszRoutineName,
				IDirectMusicSegmentState *pSegSt,
				DWORD dwVirtualTrackID,
				bool fErrorPMsgsEnabled,
				__int64 i64IntendedStartTime,
				DWORD dwIntendedStartTimeFlags);
	HRESULT SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
	HRESULT EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems);
	HRESULT DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId);
	HRESULT DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);
	void Close();
	STDMETHOD_(ULONG, Release)();

private:
	friend void F_Create(void *pvParams);
	static CWorkerThread ms_Thread;
	ScriptManager *m_pScriptManager;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\sourcetext.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSourceText.
//
// This is a DirectMusic object whose sole purpose is to load a plain text file and return the text.
// It is used by the CDirectMusicScript object to read its source code from a separate non-riff text file.

#pragma once

//////////////////////////////////////////////////////////////////////
// Interface for getting the text

extern const GUID CLSID_DirectMusicSourceText;
extern const GUID IID_IDirectMusicSourceText;

#undef  INTERFACE
#define INTERFACE IDirectMusicSourceText
DECLARE_INTERFACE_(IDirectMusicSourceText, IUnknown)
{
	STDMETHOD_(void, GetTextLength)(DWORD *pcwchRequiredBufferSize); // size of buffer to allocate (includes a space for the terminator)
	STDMETHOD_(void, GetText)(WCHAR *pwszText); // buffer must be of size from GetTextLength
};

//////////////////////////////////////////////////////////////////////
// The object iteself

//  Does this object need a critical section?  GetObject should serialize access and nobody but the
// script can hold onto it.

class CSourceText
  : public IDirectMusicSourceText,
	public IPersistStream,
	public IDirectMusicObject
{
public:
	static HRESULT CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);

	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions (only Load is implemented)
	STDMETHOD(GetClassID)(CLSID* pClassID) {return E_NOTIMPL;}
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream);
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject
	// (This interface must exist in order for the object to be loaded, but the methods aren't actually
	//  implemented to provide/save any information.)
	STDMETHOD(GetDescriptor)(LPDMUS_OBJECTDESC pDesc) { pDesc->dwValidData = 0; return S_OK; }
	STDMETHOD(SetDescriptor)(LPDMUS_OBJECTDESC pDesc) { return S_OK; }
	STDMETHOD(ParseDescriptor)(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) { pDesc->dwValidData = 0; return S_OK; }

	// IDirectMusicSourceText
	STDMETHOD_(void, GetTextLength)(DWORD *pcwchRequiredBufferSize); // size of buffer to allocate (includes a space for the terminator)
	STDMETHOD_(void, GetText)(WCHAR *pwszText); // buffer must be of size from GetTextLength

private:
	CSourceText();

	long m_cRef;
	SmartRef::WString m_wstrText;
	DWORD m_cwchText;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\stdinc.h ===
// Copyright (c) 1999 Microsoft Corporation
#pragma once

#define IDirectSoundWave IUnknown
#define IDirectSoundConnect IUnknown

#include <xutility>

#include "dmusicip.h"
#include "Validate.h"
#include "debug.h"
#include "smartref.h"
#include "miscutil.h"

// undefine min and max from WINDEF.H
// use std::_MIN and std::_MAX instead
#undef min
#undef max

//const g_ScriptCallTraceLevel = -1; // always log
const g_ScriptCallTraceLevel = 4; // only log at level 4 and above

// Pragma reminders
#define QUOTE0(a)           #a
#define QUOTE1(a)           QUOTE0(a)
#define MESSAGE(a)          message(__FILE__ ", line " QUOTE1(__LINE__) ": " a)
#define TODO(a)             MESSAGE("TODO: " a)

#ifdef XBOX
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct  _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;
#endif // !_SECURITY_ATTRIBUTES_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\track.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScriptTrack.
//

// This track type holds events that cause script routines to be called during
// playback of a segment.

#pragma once

#include "tlist.h"
#include "trackhelp.h"
#include "trackshared.h"

//////////////////////////////////////////////////////////////////////
// Types

// List of events
struct EventInfo
{
	EventInfo() : dwFlags(0), lTriggerTime(0), lTimePhysical(0), pIDMScript(NULL), pIDMScriptPrivate(NULL), pwszRoutineName(NULL) {}
	~EventInfo() {
		SafeRelease(pIDMScript);
		SafeRelease(pIDMScriptPrivate);
		delete[] pwszRoutineName;
	}

	HRESULT Clone(const EventInfo &o, MUSIC_TIME mtStart)
	{
		pwszRoutineName = new WCHAR[wcslen(o.pwszRoutineName) + 1];
		if (!pwszRoutineName)
			return E_OUTOFMEMORY;
		wcscpy(pwszRoutineName, o.pwszRoutineName);

		dwFlags = o.dwFlags;
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;

		pIDMScript = o.pIDMScript;
		pIDMScript->AddRef();
		pIDMScriptPrivate = o.pIDMScriptPrivate;
		pIDMScriptPrivate->AddRef();

		return S_OK;
	}

	// from event header chunk <scrh>
	DWORD dwFlags;
	MUSIC_TIME lTriggerTime; // logical time
	MUSIC_TIME lTimePhysical;
	// from reference <DMRF>
	IDirectMusicScript *pIDMScript;
	IDirectMusicScriptPrivate *pIDMScriptPrivate;
	WCHAR *pwszRoutineName;
};

class CScriptTrackEvent : public IUnknown
{
public:
    CScriptTrackEvent() : 
      m_pSegSt(NULL), 
      m_pEvent(NULL), 
      m_i64IntendedStartTime(0), 
      m_dwIntendedStartTimeFlags(0), 
      m_cRef(1) 
      {
      }

    ~CScriptTrackEvent();

    // IUnknown
    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

    // CScriptTrackEvent
    HRESULT Init(const EventInfo &item, IDirectMusicSegmentState* pSegSt);

    void SetTime(REFERENCE_TIME rtTime, DWORD dwFlags)
    {
		m_i64IntendedStartTime = rtTime;
		m_dwIntendedStartTimeFlags = dwFlags;
    }

    void Call(DWORD dwdwVirtualTrackID, bool fErrorPMsgsEnabled);

private:
	IDirectMusicSegmentState *m_pSegSt;
	EventInfo *m_pEvent; // event to execute
	// scheduled time of the routine call
	__int64 m_i64IntendedStartTime;
	DWORD m_dwIntendedStartTimeFlags;

    long m_cRef;
};

//////////////////////////////////////////////////////////////////////
// CDirectMusicScriptTrack

class CDirectMusicScriptTrack;
typedef CPlayingTrack<CDirectMusicScriptTrack, EventInfo> CDirectMusicScriptTrackBase;

class CDirectMusicScriptTrack
  : public CDirectMusicScriptTrackBase,
	public IDirectMusicTool
{
public:
	CDirectMusicScriptTrack(HRESULT *pHr);
	~CDirectMusicScriptTrack()
    {
        TListItem<EventInfo>* pItem = m_EventList.GetHead();
        for ( ; pItem; pItem = pItem->GetNext() )
        {
            SafeRelease(pItem->GetItemValue().pIDMScript);
            SafeRelease(pItem->GetItemValue().pIDMScriptPrivate);
        }
    }

	// initialize each referenced script in InitPlay
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

	// Need to implement IUnknown as part of the IDirectMusic tool interface.  (Just used to receive callbacks -- you can't actually QI to it.)
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv) { return CDirectMusicScriptTrackBase::QueryInterface(iid, ppv); }
	STDMETHOD_(ULONG, AddRef)() { return CDirectMusicScriptTrackBase::AddRef(); }
	STDMETHOD_(ULONG, Release)() { return CDirectMusicScriptTrackBase::Release(); }

	// IDirectMusicTool methods (since we aren't in a graph, only ProcessPMsg and Flush are called)
	STDMETHOD(Init)(IDirectMusicGraph* pGraph) { return E_UNEXPECTED; }
	STDMETHOD(GetMsgDeliveryType)(DWORD* pdwDeliveryType)  { return E_UNEXPECTED; }
	STDMETHOD(GetMediaTypeArraySize)(DWORD* pdwNumElements)  { return E_UNEXPECTED; }
	STDMETHOD(GetMediaTypes)(DWORD** padwMediaTypes, DWORD dwNumElements)  { return E_UNEXPECTED; }
	STDMETHOD(ProcessPMsg)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG);
	STDMETHOD(Flush)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime) { return DMUS_S_FREE; } // If the performance was stopped before the event actually fired, just ignore it.

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid);
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData);

protected:
	HRESULT PlayItem(
		const EventInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadEvent(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	bool m_fErrorPMsgsEnabled;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\trackshared.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Code that needs to be shared between the script track (CDirectMusicScriptTrack) and
// the script object (CDirectMusicScript, etc.).
//

#pragma once

// Private script interface used by the  script track to call routines.  This is needed because
// VBScript routines must be triggered asynchronously in order to avoid deadlocks with other
// threads.  This also helps to avoid starving the performance if routines have long loops.

static const GUID IID_IDirectMusicScriptPrivate = 
	{ 0xf9a5071b, 0x6e0d, 0x498c, { 0x8f, 0xed, 0x56, 0x57, 0x1c, 0x1a, 0xb1, 0xa9 } };// {F9A5071B-6E0D-498c-8FED-56571C1AB1A9}

interface IDirectMusicScriptPrivate : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE ScriptTrackCallRoutine(
											WCHAR *pwszRoutineName,
											IDirectMusicSegmentState *pSegSt,
											DWORD dwVirtualTrackID,
											bool fErrorPMsgsEnabled,
											__int64 i64IntendedStartTime,
											DWORD dwIntendedStartTimeFlags)=0;
};

// Shared function used by the script track and by the script object for ScriptTrackCallRoutine.
// Fills out and sends a DMUS_SCRIPT_TRACK_ERROR_PMSG for the given error.
HRESULT FireScriptTrackErrorPMsg(IDirectMusicPerformance *pPerf, IDirectMusicSegmentState *pSegSt, DWORD dwVirtualTrackID, DMUS_SCRIPT_ERRORINFO *pErrorInfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\trackshared.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Code that needs to be shared between the script track (CDirectMusicScriptTrack) and
// the script object (CDirectMusicScript, etc.).
//

/*#include "stdinc.h"
#include "trackshared.h"
#include "dmusicp.h"*/

#include "pchscript.h"

HRESULT FireScriptTrackErrorPMsg(IDirectMusicPerformance *pPerf, IDirectMusicSegmentState *pSegSt, DWORD dwVirtualTrackID, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	SmartRef::ComPtr<IDirectMusicGraph> scomGraph;
    if(!pSegSt){
        return E_INVALIDARG;
    }
	HRESULT hr = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&scomGraph));
	if (FAILED(hr))
		return hr;

	SmartRef::PMsg<DMUS_SCRIPT_TRACK_ERROR_PMSG> pmsgScriptTrackError(pPerf);
	hr = pmsgScriptTrackError.hr();
	if (FAILED(hr))
		return hr;

	// generic PMsg fields

	REFERENCE_TIME rtTimeNow = 0;
	hr = pPerf->GetTime(&rtTimeNow, NULL);
	if (FAILED(hr))
		return hr;

	pmsgScriptTrackError.p->rtTime = rtTimeNow;
	pmsgScriptTrackError.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
	// dwPChannel: the script doesn't have a channel so leave as 0
	pmsgScriptTrackError.p->dwVirtualTrackID = dwVirtualTrackID;
	pmsgScriptTrackError.p->dwType = DMUS_PMSGT_SCRIPTTRACKERROR;
	pmsgScriptTrackError.p->dwGroupID = -1; // the script track doesn't have a group so just say all

	// error PMsg fields

	CopyMemory(&pmsgScriptTrackError.p->ErrorInfo, pErrorInfo, sizeof(pmsgScriptTrackError.p->ErrorInfo));

	// send it
	pmsgScriptTrackError.StampAndSend(scomGraph);
	hr = pmsgScriptTrackError.hr();
	if (FAILED(hr))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englex.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of Lexer.
//

//#define LIMITEDVBSCRIPT_LOGLEXER // 

/*#include "stdinc.h"
#include "enginc.h"
#include "englex.h"
#include "limits"

#ifdef LIMITEDVBSCRIPT_LOGLEXER
#include "englog.h"
#endif*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Unicode/ASCII character classification

inline bool iswasciialpha(WCHAR c) { return (c >= L'a' && c <= L'z') || (c >= L'A' && c <= L'Z'); }
inline bool iswasciidigit(WCHAR c) { return c >= L'0' && c <= L'9'; }
inline bool iswasciialnum(WCHAR c) { return iswasciialpha(c) || iswasciidigit(c); }
inline WCHAR towasciilower(WCHAR c) { return (c >= L'A' && c <= L'Z') ? c + (L'a' - L'A') : c; }

//////////////////////////////////////////////////////////////////////
// token tables

const TokenKeysym g_TokenKeysyms[] =
	{
		{ L'(', TOKEN_lparen },
		{ L')', TOKEN_rparen },
		{ L',', TOKEN_comma },
		{ L'-', TOKEN_op_minus },
		{ L'^', TOKEN_op_pow },
		{ L'*', TOKEN_op_mult },
		{ L'\\', TOKEN_op_div },
		{ L'+', TOKEN_op_plus },
		{ L'<', TOKEN_op_lt },
		{ L'>', TOKEN_op_gt },
		{ L'=', TOKEN_op_eq },
		{ L'\0', TOKEN_eof }
	};

const TokenKeyword g_TokenKeywords[] =
	{
		{ L"sub", TOKEN_sub },
		{ L"dim", TOKEN_dim },
		{ L"if", TOKEN_if },
		{ L"then", TOKEN_then },
		{ L"end", TOKEN_end },
		{ L"elseif", TOKEN_elseif },
		{ L"else", TOKEN_else },
		{ L"set", TOKEN_set },
		{ L"call", TOKEN_call },
		{ L"not", TOKEN_op_not },
		{ L"mod", TOKEN_op_mod },
		{ L"is", TOKEN_is },
		{ L"and", TOKEN_and },
		{ L"or", TOKEN_or },
		{ NULL, TOKEN_eof }
	};

//////////////////////////////////////////////////////////////////////
// helper functions

bool
CheckOperatorType(Token t, bool fAcceptParens, bool fAcceptUnary, bool fAcceptBinary, bool fAcceptOverloadedAssignmentTokens)
{
	switch (t)
	{
	case TOKEN_set:
	case TOKEN_sub:
		return fAcceptOverloadedAssignmentTokens;

	case TOKEN_lparen:
	case TOKEN_rparen:
		return fAcceptParens;

	case TOKEN_op_minus:
		return fAcceptUnary || fAcceptBinary;

	case TOKEN_op_not:
		return fAcceptUnary;

	case TOKEN_op_pow:
	case TOKEN_op_mult:
	case TOKEN_op_div:
	case TOKEN_op_mod:
	case TOKEN_op_plus:
	case TOKEN_op_lt:
	case TOKEN_op_leq:
	case TOKEN_op_gt:
	case TOKEN_op_geq:
	case TOKEN_op_eq:
	case TOKEN_op_neq:
	case TOKEN_is:
	case TOKEN_and:
	case TOKEN_or:
		return fAcceptBinary;
	}

	return false;
}

//////////////////////////////////////////////////////////////////////
// Lexer

Lexer::Lexer(const WCHAR *pwszSource)
  : m_p(pwszSource),
	m_pNext(NULL),
	m_iLine(1),
	m_iColumn(1),
	m_t(TOKEN_sub)
{
	this->Scan();
}

void
Lexer::Next()
{
	assert(m_t != TOKEN_eof);
	if (m_pNext)
	{
		m_iColumn += (int)(m_pNext - m_p);
		m_p = m_pNext;
		m_pNext = NULL;
	}
	else
	{
		++m_p;
		++m_iColumn;
	}
}

void
Lexer::Scan()
{
	m_szStr[0] = L'\0';
	m_iNum = 0;
	bool fLineBreak = m_t == TOKEN_linebreak;
	for (;;)
	{
		if (fLineBreak)
		{
			// line breaks tokens are reported on the line/column that they occur so this isn't isn't adjusted until the next pass
			++m_iLine;
			m_iColumn = 1;
		}

		ScanMain();
		if (!fLineBreak || m_t != TOKEN_linebreak)
			break;

		Next();
	}

#ifdef LIMITEDVBSCRIPT_LOGLEXER
	LogToken(*this);
#endif
}

void
Lexer::ScanMain()
{
	for (;; this->Next())
	{
		switch (*m_p)
		{
		case L'\0':
			// end of script
			m_t = TOKEN_eof;
			return;

		case L'\'':
			// comment till end of line
			for (; *m_p && *m_p != L'\n'; ++m_p)
			{}

			--m_p; // put one char back so the next loop can process it
			break;

		case L'\t': case L' ':
			// ignore horizontal white space
			break;

		case L'\r':
			// ignore carriage returns
			--m_iColumn; // in fact, they don't even count as characters
			break;

		case L'\n':
			// line break
			m_t = TOKEN_linebreak;
			return;

		default:
			if (*m_p == L'\"')
			{
				// string literal
				m_pNext = m_p + 1;
				char *pszDest = m_szStr;
				const char *pszMax = m_szStr + g_iMaxBuffer - 1;
				do
				{
					if ((*m_pNext) > 0x007F) // !iswascii() 
					{
						this->Next(); // this will update the current position to the offending character -- indicating the correct column of the error
						this->err(LEXERR_NonAsciiCharacterInStringLiteral);
						return;
					}

					if (*m_pNext == L'\n' || *m_pNext == L'\r')
					{
						this->err(LEXERR_StringLiteralUnterminated);
						return;
					}

					if (*m_pNext == L'\"')
					{
						if (*++m_pNext != L'\"')
							break; // found terminating quote

						// There were two quotes, the escape sequence for a single quote.  The first was skipped and we're all ready to append the second.
					}
					
					*pszDest++ = (char) *m_pNext++; // we know this works because the character is ascii and those codes correspond to the same numbers in Unicode
				} while (pszDest <= pszMax);

				if (pszDest > pszMax)
				{
					this->err(LEXERR_StringLiteralTooLong);
				}
				else
				{
					*pszDest = L'\0';
					m_t = TOKEN_stringliteral;
				}
				return;
			}

			if (iswasciidigit(*m_p))
			{
				// numeric literal
				// Cant find a _wtoi like function that handles overflow so do the conversion myself.

				//  Look at runtime version to be sure these aren't constantly recomputed
				const long iMaxChop = 0x7FFFFFFF / 10; // if number gets bigger than this and there's another digit then we're going to overflow
				const WCHAR wchMaxLast = 0x7FFFFFFF % 10 + L'0'; // if number equals iMaxChop and the next digit is bigger than this then we're going to overflow

				m_pNext = m_p;
				m_iNum = 0;
				do
				{
					m_iNum *= 10;
					m_iNum += *m_pNext++ - L'0';
				} while (iswasciidigit(*m_pNext) && (m_iNum < iMaxChop || (m_iNum == iMaxChop && *m_pNext <= wchMaxLast)));

				if (iswasciidigit(*m_pNext))
					this->err(LEXERR_NumericLiteralTooLarge);
				else
					m_t = TOKEN_numericliteral;
				return;
			}

			if (!iswasciialpha(*m_p) && !(*m_p == L'_'))
			{
				// look for a token in the table of symbols
				for (int i = 0; g_TokenKeysyms[i].c; ++i)
				{
					if (*m_p == g_TokenKeysyms[i].c)
					{
						// we have a match
						m_t = g_TokenKeysyms[i].t;

						// check for the two-character symbols (>=, <=, <>)
						if (m_t == TOKEN_op_lt)
						{
							WCHAR wchNext = *(m_p + 1);
							if (wchNext == L'=')
							{
								m_t = TOKEN_op_leq;
								m_pNext = m_p + 2;
							}
							else if (wchNext == L'>')
							{
								m_t = TOKEN_op_neq;
								m_pNext = m_p + 2;
							}
						}
						else if (m_t == TOKEN_op_gt)
						{
							if (*(m_p + 1) == L'=')
							{
								m_t = TOKEN_op_geq;
								m_pNext = m_p + 2;
							}
						}

						return;
					}
				}

				// the symbol was not recognized
				this->err(LEXERR_InvalidCharacter);
				return;
			}

			// look for a token in the table of keywords
			for (int i = 0; g_TokenKeywords[i].s; ++i)
			{
				const WCHAR *pwchToken = g_TokenKeywords[i].s;
				const WCHAR *pwchSource = m_p;
				while (*pwchToken && *pwchSource && towasciilower(*pwchToken) == towasciilower(*pwchSource))
				{
					++pwchToken;
					++pwchSource;
				}

				if (!*pwchToken && !iswasciialnum(*pwchSource))
				{
					// made it to the end of Token and source word
					m_t = g_TokenKeywords[i].t;
					m_pNext = pwchSource;
					return;
				}
			}

			// must be an identifier
			for (m_pNext = m_p + 1; iswasciialnum(*m_pNext) || *m_pNext == L'_'; ++m_pNext)
			{}

			if (m_pNext - m_p > g_iMaxBuffer - 1)
			{
				this->err(LEXERR_IdentifierTooLong);
				return;
			}

			char *psz = m_szStr;
			for (const WCHAR *pwsz = m_p; pwsz < m_pNext; ++psz, ++pwsz)
			{
				*psz = (char) *pwsz;
			}

			*psz = '\0';

			if (*m_pNext == L'.')
			{
				++m_pNext;
				m_t = TOKEN_identifierdot;
			}
			else
			{
				m_t = TOKEN_identifier;
			}
			return;
		}
	}
}

void Lexer::err(LexErr iErr)
{
	static const char *s_rgpszErrorText[] =
		{
		"Unexpected error!", // shouldn't ever get this error
		"Invalid character",
		"Identifier too long",
		"String too long",
		"Unterminated string constant",
		"Number too large"
 		};

	assert(ARRAY_SIZE(s_rgpszErrorText) == LEXERR_Max);
	if (iErr <= 0 || iErr >= LEXERR_Max)
	{
		assert(false);
		iErr = LEXERR_NoError;
	}

	m_t = TOKEN_eof;
	m_iNum = iErr;

	// copy error into the buffer
	const char *psz = s_rgpszErrorText[iErr];
	const char *pszMax = m_szStr + g_iMaxBuffer - 1;
	for (char *pszDest = m_szStr; pszDest < pszMax && *psz; *pszDest++ = *psz++)
	{}

	assert(!*psz); // since this function is used with hard-coded strings we shouldn't ever get one too long
	*pszDest = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\oleaut.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper routines that wrap called to functions in oleaut32.  This enables us to
// compile free from any dependency on oleaut32.dll.  In this case, some functionality
// is lost.  For example, only certain types of VARIANT variables are handled correctly
// in the abscence of oleaut32.
//
// Defining DMS_USE_OLEAUT allows oleaut32 to be used.
//

/*#include "stdinc.h"
#include "oleaut.h"*/

#include "pchscript.h"

#ifndef DMS_ALWAYS_USE_OLEAUT

#ifndef DMS_NEVER_USE_OLEAUT
//////////////////////////////////////////////////////////////////////
// Handling LoadLibrary of OleAut32

bool g_fCalledLoadLibrary = false;
HINSTANCE g_hinstOleAut = NULL;

#define OLEAUTAPI_FUNC_PTR STDAPICALLTYPE *
void (OLEAUTAPI_FUNC_PTR g_pfnVariantInit)(VARIANTARG *pvarg) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantClear)(VARIANTARG *pvarg) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantCopy)(VARIANTARG *pvargDest, VARIANTARG *pvargSrc) = NULL;
HRESULT (OLEAUTAPI_FUNC_PTR g_pfnVariantChangeType)(VARIANTARG *pvargDest, VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt) = NULL;
BSTR (OLEAUTAPI_FUNC_PTR g_pfnSysAllocString)(const OLECHAR *) = NULL;
void (OLEAUTAPI_FUNC_PTR g_pfnSysFreeString)(BSTR) = NULL;

bool FEnsureOleAutLoaded()
{
	if (!g_fCalledLoadLibrary)
	{
		Trace(4, "Loading oleaut32.\n");

		g_fCalledLoadLibrary = true;
		g_hinstOleAut = LoadLibrary("oleaut32");
		assert(g_hinstOleAut);

		if (g_hinstOleAut)
		{
			*reinterpret_cast<FARPROC*>(&g_pfnVariantInit) = GetProcAddress(g_hinstOleAut, "VariantInit");
			if (!g_pfnVariantInit)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantClear) = GetProcAddress(g_hinstOleAut, "VariantClear");
			if (!g_pfnVariantClear)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantCopy) = GetProcAddress(g_hinstOleAut, "VariantCopy");
			if (!g_pfnVariantCopy)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnVariantChangeType) = GetProcAddress(g_hinstOleAut, "VariantChangeType");
			if (!g_pfnVariantChangeType)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnSysAllocString) = GetProcAddress(g_hinstOleAut, "SysAllocString");
			if (!g_pfnSysAllocString)
				goto Fail;
			*reinterpret_cast<FARPROC*>(&g_pfnSysFreeString) = GetProcAddress(g_hinstOleAut, "SysFreeString");
			if (!g_pfnSysFreeString)
				goto Fail;
			return true;
		}
	}

	return !!g_hinstOleAut;

Fail:
	Trace(1, "Error: Unable to load oleaut32.dll.\n");
	g_hinstOleAut = NULL;
	return false;
}
#endif

//////////////////////////////////////////////////////////////////////
// VARIANT functions

// private functions

inline bool FIsRefOrArray(VARTYPE vt)
{
	return (vt & VT_BYREF) || (vt & VT_ARRAY);
}

// public functions

void
DMS_VariantInit(bool fUseOleAut, VARIANTARG *pvarg)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
		{
			g_pfnVariantInit(pvarg);
			return;
		}
	}
#else
	assert(!fUseOleAut);
#endif
	{
		V_INAME(DMS_VariantInit);
		assert(!IsBadWritePtr(pvarg, sizeof(VARIANTARG)));

		pvarg->vt = VT_EMPTY;
	}
}

HRESULT
DMS_VariantClear(bool fUseOleAut, VARIANTARG * pvarg)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantClear(pvarg);
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantClear);
	V_PTR_WRITE(pvarg, VARIANTARG);

	if (FIsRefOrArray(pvarg->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	switch (pvarg->vt)
	{
	case VT_UNKNOWN:
		SafeRelease(pvarg->punkVal);
		break;
	case VT_DISPATCH:
		SafeRelease(pvarg->pdispVal);
		break;
	case VT_BSTR:
		DMS_SysFreeString(fUseOleAut, pvarg->bstrVal);
		pvarg->bstrVal = NULL;
		break;
	}

	pvarg->vt = VT_EMPTY;
	return S_OK;
}

HRESULT DMS_VariantCopy(bool fUseOleAut, VARIANTARG * pvargDest, const VARIANTARG * pvargSrc)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantCopy(pvargDest, const_cast<VARIANT*>(pvargSrc));
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantCopy);
	V_PTR_WRITE(pvargDest, VARIANTARG);
	V_PTR_READ(pvargSrc, VARIANTARG);

	if (pvargDest == pvargSrc)
	{
		assert(false);
		return E_INVALIDARG;
	}

	if (FIsRefOrArray(pvargSrc->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	HRESULT hr = DMS_VariantClear(fUseOleAut, pvargDest);
	if (FAILED(hr))
		return hr;

	switch (pvargSrc->vt)
	{
	case VT_UNKNOWN:
		if (pvargSrc->punkVal)
			pvargSrc->punkVal->AddRef();
		break;
	case VT_DISPATCH:
		if (pvargSrc->pdispVal)
			pvargSrc->pdispVal->AddRef();
		break;
	case VT_BSTR:
		pvargDest->vt = VT_BSTR;
		pvargDest->bstrVal = DMS_SysAllocString(fUseOleAut, pvargSrc->bstrVal);
		return S_OK;
	}

	*pvargDest = *pvargSrc;

	return S_OK;
}

HRESULT
DMS_VariantChangeType(
		bool fUseOleAut,
		VARIANTARG * pvargDest,
		VARIANTARG * pvarSrc,
		USHORT wFlags,
		VARTYPE vt)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			return g_pfnVariantChangeType(pvargDest, pvarSrc, wFlags, vt);
		else
			return DMUS_E_SCRIPT_CANTLOAD_OLEAUT32;
	}
#else
	assert(!fUseOleAut);
#endif
	V_INAME(DMS_VariantChangeType);
	V_PTR_WRITE(pvargDest, VARIANTARG);
	V_PTR_READ(pvarSrc, VARIANTARG);

	bool fConvertInPlace = pvarSrc == pvargDest;
	if (vt == pvarSrc->vt)
	{
		// No conversion necessary
		if (fConvertInPlace)
			return S_OK;
		return DMS_VariantCopy(fUseOleAut, pvargDest, pvarSrc);
	}

	if (FIsRefOrArray(vt) || FIsRefOrArray(pvarSrc->vt))
	{
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}

	switch (vt)
	{
	case VT_I4:
		{
			// Get the value
			LONG lVal = 0;
			switch (pvarSrc->vt)
			{
			case VT_I2:
				lVal = pvarSrc->iVal;
				break;
			case VT_EMPTY:
				break;
			case VT_UNKNOWN:
			case VT_DISPATCH:
			case VT_BSTR:
				return DISP_E_TYPEMISMATCH;
			default:
				Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
				return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
			}

			// Write the result
			pvargDest->vt = VT_I4;
			pvargDest->lVal = lVal;
			return S_OK;
		}

	case VT_DISPATCH:
	case VT_UNKNOWN:
		{
			// We can convert between IDispatch and IUnknown.
			bool fConvertToUnknown = vt == VT_UNKNOWN; // true if IUnknown is dest, false if IDispatch is dest

			// We'll assume that both fields (pdispVal/punkVal) are stored in the same slot in the VARIANT union.
			// This will make things simpler because we can just manipulate the same pointer now matter whether we're
			//  converting to or from Dispatch/Unknown. 
			assert(reinterpret_cast<void**>(&pvarSrc->pdispVal) == reinterpret_cast<void**>(&pvarSrc->punkVal));
			assert(reinterpret_cast<void**>(&pvargDest->pdispVal) == reinterpret_cast<void**>(&pvargDest->punkVal));

			IUnknown *punkCur = pvarSrc->punkVal; // Current value we're going to convert.
			void *pval = NULL; // New value result of conversion.

			switch (pvarSrc->vt)
			{
			case VT_DISPATCH:
			case VT_UNKNOWN:
				{
					if (!punkCur)
						return E_INVALIDARG;
					HRESULT hrDispQI = punkCur->QueryInterface(fConvertToUnknown ? IID_IUnknown : IID_IDispatch, &pval);
					if (FAILED(hrDispQI))
						return hrDispQI;
					break;
				}
			case VT_I4:
			case VT_I2:
			case VT_BSTR:
			case VT_EMPTY:
				return DISP_E_TYPEMISMATCH;
			default:
				Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
				return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
			}

			// Write the result
			if (fConvertInPlace)
				punkCur->Release();
			pvargDest->vt = fConvertToUnknown ? VT_UNKNOWN : VT_DISPATCH;
			pvargDest->punkVal = reinterpret_cast<IUnknown*>(pval);

			return S_OK;
		}

    case VT_BSTR:
        {
            // Can convert empty and I2/I4 to string
            switch( pvarSrc->vt )
            {
            case VT_I4:
            case VT_I2:
            case VT_EMPTY:
                OLECHAR wsz[12];
                if( pvarSrc->vt == VT_EMPTY )
                    wsz[0] = L'\0';
                else
                    swprintf( wsz, L"%d", pvarSrc->lVal );

                pvargDest->vt = VT_BSTR;
                pvargDest->bstrVal = DMS_SysAllocString( fUseOleAut, wsz );
                break;

            case VT_DISPATCH:
            case VT_UNKNOWN:
                return DISP_E_TYPEMISMATCH;

            default:
				Trace(1, "Error: A variant was used that had a type that is not supported by AudioVBScript.\n");
				return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;

            }
            return S_OK;
        }

	default:
		Trace(1, "Error: A varient was used that had a type that is not supported by AudioVBScript.\n");
		return DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE;
	}
}

//////////////////////////////////////////////////////////////////////
// BSTR functions

const UINT cwchCountPrefix = sizeof(DWORD) / sizeof(WCHAR);

BSTR
DMS_SysAllocString(bool fUseOleAut, const OLECHAR *pwsz)
{
#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
		{
			BSTR bstrReturn = g_pfnSysAllocString(pwsz);

			// Use this to trace memory being allocated in case you need to debug a corruption problem.
			TraceI(4, "DMS_SysAllocString: 0x%08x, \"%S\", %S\n", bstrReturn, bstrReturn ? bstrReturn : L"", L"oleaut");

			return bstrReturn;
		}
		else
		{
			return NULL;
		}
	}
#else
	assert(!fUseOleAut);
#endif
	if (!pwsz)
		return NULL;

	BSTR bstr = new WCHAR[wcslen(pwsz) + 1];
	if (!bstr)
		return NULL;
	wcscpy(bstr, pwsz);

	// Use this to trace memory being allocated in case you need to debug a corruption problem.
	TraceI(4, "DMS_SysAllocString: 0x%08x, \"%S\", %S\n", bstr, bstr ? bstr : L"", L"no oleaut");

	return bstr;
}

void
DMS_SysFreeString(bool fUseOleAut, BSTR bstr)
{
	// Use this to trace memory being deallocated in case you need to debug a corruption problem.
	// All DMS_SysAllocString with "no oleaut" should be neatly balanced by an opposing DMS_SysAllocFreeString.
	// There are some unbalanced calls with "oleaut" because we don't see the allocations and frees made by VBScript.
	TraceI(4, "DMS_SysFreeString: 0x%08x, \"%S\", %S\n", bstr, bstr ? bstr : L"", fUseOleAut ? L"oleaut" : L"no oleaut");

#ifndef DMS_NEVER_USE_OLEAUT
	if (fUseOleAut)
	{
		if (FEnsureOleAutLoaded())
			g_pfnSysFreeString(bstr);
		return;
	}
#else
	assert(!fUseOleAut);
#endif

	delete[] bstr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\unkhelp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper classes for implementing IUnknown.
//

/*#include "stdinc.h"
#include "unkhelp.h"
#include "dll.h"*/

#include "pchscript.h"

ComRefCount::ComRefCount()
  : m_cRef(1)
{
	LockModule(true);
}

STDMETHODIMP_(ULONG)
ComRefCount::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
ComRefCount::Release()
{
	if (!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		LockModule(false);
		return 0;
	}

	return m_cRef;
}

STDMETHODIMP
ComSingleInterface::QueryInterface(const IID &iid, void **ppv, const IID&iidExpected, void *pvInterface)
{
	V_INAME(ComSingleInterface::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == iidExpected)
	{
		*ppv = pvInterface;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	this->AddRef();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\unkhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper classes for implementing IUnknown.
//

#pragma once

// Implements AddRef/Release with ref count beginning at 1. Also handles module locking.
class ComRefCount
  : public IUnknown
{
public:
	ComRefCount();
	virtual ~ComRefCount() {}

	// IUnknown
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

private:
	long m_cRef;
};

// Use this macro to declare AddRef and Release in the public section of your derived class.  This is necessary because
// the IUnknown section of any interfaces aren't linked to the methods in this base class.
#define ComRefCountAddRefRelease STDMETHOD_(ULONG, AddRef)() { return ComRefCount::AddRef(); } STDMETHOD_(ULONG, Release)() { return ComRefCount::Release(); }

// Implements QueryInterface for a single interface (in addition to IUnknown). You must pass the IID of your interface (iidExpected)
// and a pointer to that interface (pvInterface).
class ComSingleInterface
  : public ComRefCount
{
public:
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv, const IID&iidExpected, void *pvInterface);
};

// Use this macro to declare AddRef, Release, and QueryInterface function in the public section of your derived class.
#define ComSingleInterfaceUnknownMethods(IMyInterface) ComRefCountAddRefRelease STDMETHOD(QueryInterface)(const IID &iid, void **ppv) { return ComSingleInterface::QueryInterface(iid, ppv, IID_##IMyInterface, static_cast<IMyInterface*>(this)); }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\workthread.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CWorkerThread.
//

#include "stdinc.h"
#include <process.h>
#include "workthread.h"

unsigned int __stdcall WorkerThread(LPVOID lpThreadParameter)
{
	reinterpret_cast<CWorkerThread*>(lpThreadParameter)->Main();
	return 0;
}

HRESULT
CWorkerThread::Create()
{
	if (m_hThread)
		return S_FALSE;

	if (!m_hEvent)
		return E_FAIL; // The constructor was unable to create the event we'll need to run the thread so we can't create it.

	m_hrCOM = E_FAIL;
	m_fEnd = false;
	m_hThread = reinterpret_cast<HANDLE>(_beginthreadex(NULL, 0, WorkerThread, this, 0, &m_uiThreadId));
	return m_hThread ? S_OK : E_FAIL;
}

void
CWorkerThread::Terminate(bool fWaitForThreadToExit)
{
	if (!m_hThread)
		return;

	EnterCriticalSection(&m_CriticalSection);
	m_fEnd = true;
	SetEvent(m_hEvent);
	LeaveCriticalSection(&m_CriticalSection);

	if (fWaitForThreadToExit)
	{
		// Wait until the other thread stops processing.
		WaitForSingleObject(m_hThread, INFINITE);
	}

	CloseHandle(m_hThread);
	m_hThread = NULL;
}

CWorkerThread::CWorkerThread(bool fUsesCOM, bool fDeferCreation)
  : m_hThread(NULL),
	m_uiThreadId(0),
	m_fUsesCOM(fUsesCOM)
{
	InitializeCriticalSection(&m_CriticalSection);

	m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (!m_hEvent)
		return;

	if (!fDeferCreation)
		Create();
}

CWorkerThread::~CWorkerThread()
{
	Terminate(false);
	CloseHandle(m_hEvent);
	DeleteCriticalSection(&m_CriticalSection);
}

HRESULT CWorkerThread::Call(FunctionPointer pfn, void *pvParams, UINT cbParams, bool fBlock)
{
	if (!m_hThread)
		return E_FAIL;

	if (fBlock && GetCurrentThreadId() == m_uiThreadId)
	{
		// The call is already on this thread so just do it.
		pfn(pvParams);
		return S_OK;
	}

	TListItem<CallInfo> *pItem = new TListItem<CallInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;

	CallInfo &rinfo = pItem->GetItemValue();
	rinfo.pfn = pfn;
	rinfo.hEventOut = fBlock ? CreateEvent(NULL, FALSE, FALSE, NULL) : 0;
	if (rinfo.hEventOut)
	{
		// Synchronous call -- OK to reference via pointer to params
		rinfo.pvParams = pvParams;
	}
	else
	{
		// Asynchronous call -- need to copy params
		rinfo.pvParams = new char[cbParams];
		if (!rinfo.pvParams)
		{
			delete pItem;
			return E_OUTOFMEMORY;
		}
		CopyMemory(rinfo.pvParams, pvParams, cbParams);
	}

	EnterCriticalSection(&m_CriticalSection);
	m_Calls.AddHead(pItem);
	HANDLE hEventCall = rinfo.hEventOut; // Can't refer to rinfo after we set the event because the worker will delete the event.
	SetEvent(m_hEvent);
	LeaveCriticalSection(&m_CriticalSection);

	if (hEventCall)
	{
		WaitForSingleObject(hEventCall, INFINITE);
		if (FAILED(m_hrCOM))
			return m_hrCOM;
		CloseHandle(hEventCall);
	}

	return S_OK;
}

void CWorkerThread::Main()
{
#ifndef XBOX
	if (m_fUsesCOM)
	{
		m_hrCOM = CoInitialize(NULL);
		if (FAILED(m_hrCOM))
		{
			Trace(1, "Error: CoInitialize failed: 0x%08x.\n", m_hrCOM);
		}
	}
#endif // ! XBOX

	for (;;)
	{
		// block until there's something to do
		WaitForSingleObject(m_hEvent, INFINITE);

		EnterCriticalSection(&m_CriticalSection);

		// check for end
		if (m_fEnd)
		{
			LeaveCriticalSection(&m_CriticalSection);
#ifndef XBOX
			if (m_fUsesCOM && SUCCEEDED(m_hrCOM))
				CoUninitialize();
#endif // ! XBOX
			_endthreadex(0);
		}

		// take all the list items
		TListItem<CallInfo> *m_pCallHead = m_Calls.GetHead();
		m_Calls.RemoveAll();

		LeaveCriticalSection(&m_CriticalSection);

		// call each function
		TListItem<CallInfo> *m_pCall = m_pCallHead;
		while (m_pCall)
		{
			CallInfo &rinfo = m_pCall->GetItemValue();
			if (SUCCEEDED(m_hrCOM))
				rinfo.pfn(rinfo.pvParams);

			if (rinfo.hEventOut)
				SetEvent(rinfo.hEventOut);
			else
				delete[] rinfo.pvParams;

			TListItem<CallInfo> *m_pNext = m_pCall->GetNext();
			delete m_pCall;
			m_pCall = m_pNext;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\workthread.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CWorkerThread.
// Creates worker threads, calls functions on them, and optionally waits for results.
//

#pragma once

#include "tlist.h"

class CWorkerThread
{
public:
	typedef void (*FunctionPointer)(void *pvParams);

	CWorkerThread(
		bool fUsesCOM,		// setting fUsesCOM means the thread will call CoInitialize
		bool fDeferCreation	// set to true not to automatically create thread in constructor
		);
	~CWorkerThread();

	HRESULT Call(FunctionPointer pfn, void *pvParams, UINT cbParams, bool fBlock); // if fBlock is true, the current thread will block until the called function returns

	// These can be used to dynamically create and destroy the thread.
	// Call fails (E_FAIL) when the thread isn't going.
	HRESULT Create();
	void Terminate(bool fWaitForThreadToExit);

private:
	friend unsigned int __stdcall WorkerThread(LPVOID lpThreadParameter);

	void Main();

	HANDLE m_hThread;
	unsigned int m_uiThreadId;
	HANDLE m_hEvent;

	CRITICAL_SECTION m_CriticalSection;
	struct CallInfo
	{
		FunctionPointer pfn;
		void *pvParams;
		HANDLE hEventOut; // if non-null, the main thread is waiting for a signal when the function has returned
	};
	TList<CallInfo> m_Calls;
	bool m_fUsesCOM;
	HRESULT m_hrCOM; // HRESULT from initializing COM
	bool m_fEnd; // set to true when the script thread should stop running
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\scriptthread.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSingleThreadedActiveScriptManager.
//

#include "stdinc.h"
#include "scriptthread.h"
#include "activescript.h"
#include "workthread.h"


#define S_STD_PARAMS ScriptManager *pmgr; HRESULT *phr;

CWorkerThread CSingleThreadedScriptManager::ms_Thread(true, true);

//////////////////////////////////////////////////////////////////////
// Construction

struct S_Create
{
	CSingleThreadedScriptManager *_this;
	bool fUseOleAut;
	const WCHAR *pwszLanguage;
	const WCHAR *pwszSource;
	CDirectMusicScript *pParentScript;
	HRESULT *phr;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_Create(void *pvParams)
{
	S_Create *pS = reinterpret_cast<S_Create*>(pvParams);
	pS->_this->m_pScriptManager = new CActiveScriptManager(pS->fUseOleAut, pS->pwszLanguage, pS->pwszSource, pS->pParentScript, pS->phr, pS->pErrorInfo);
}

CSingleThreadedScriptManager::CSingleThreadedScriptManager(
		bool fUseOleAut,
		const WCHAR *pwszLanguage,
		const WCHAR *pwszSource,
		CDirectMusicScript *pParentScript,
		HRESULT *phr,
		DMUS_SCRIPT_ERRORINFO *pErrorInfo)
  : m_pScriptManager(NULL)
{
	S_Create S = { this, fUseOleAut, pwszLanguage, pwszSource, pParentScript, phr, pErrorInfo };
	HRESULT hr = ms_Thread.Create();
	if (SUCCEEDED(hr))
	{
		hr = ms_Thread.Call(F_Create, &S, sizeof(S), true);
	}
	if (FAILED(hr)) // Only overwrite phr if the call itself failed.  Otherwise the call itself sets phr via struct S.
		*phr = hr;
}

//////////////////////////////////////////////////////////////////////
// Start

struct S_Start
{
	S_STD_PARAMS

	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_Start(void *pvParams)
{
	S_Start *pS = reinterpret_cast<S_Start*>(pvParams);
	*pS->phr = pS->pmgr->Start(pS->pErrorInfo);
}

HRESULT
CSingleThreadedScriptManager ::Start(DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_Start S = { m_pScriptManager, &hr, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_Start, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CallRoutine

struct S_CallRoutine
{
	S_STD_PARAMS

	const WCHAR *pwszRoutineName;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_CallRoutine(void *pvParams)
{
	S_CallRoutine *pS = reinterpret_cast<S_CallRoutine*>(pvParams);
	*pS->phr = pS->pmgr->CallRoutine(pS->pwszRoutineName, pS->pErrorInfo);
}

HRESULT CSingleThreadedScriptManager::CallRoutine(const WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_CallRoutine S = { m_pScriptManager, &hr, pwszRoutineName, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_CallRoutine, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// ScriptTrackCallRoutine

struct S_ScriptTrackCallRoutine
{
	S_STD_PARAMS

	IDirectMusicSegmentState *pSegSt;
	DWORD dwVirtualTrackID;
	bool fErrorPMsgsEnabled;
	__int64 i64IntendedStartTime;
	DWORD dwIntendedStartTimeFlags;
	WCHAR wszRoutineName[1]; // dynamically allocate extra space to hold the actual string within this structure
};

void F_ScriptTrackCallRoutine(void *pvParams)
{
	S_ScriptTrackCallRoutine *pS = reinterpret_cast<S_ScriptTrackCallRoutine*>(pvParams);
	pS->pmgr->ScriptTrackCallRoutine(
				pS->wszRoutineName,
				pS->pSegSt,
				pS->dwVirtualTrackID,
				pS->fErrorPMsgsEnabled,
				pS->i64IntendedStartTime,
				pS->dwIntendedStartTimeFlags);
	pS->pSegSt->Release(); // release the interface held in CSingleThreadedScriptManager::ScriptTrackCallRoutine
}

HRESULT CSingleThreadedScriptManager::ScriptTrackCallRoutine(
		const WCHAR *pwszRoutineName,
		IDirectMusicSegmentState *pSegSt,
		DWORD dwVirtualTrackID,
		bool fErrorPMsgsEnabled,
		__int64 i64IntendedStartTime,
		DWORD dwIntendedStartTimeFlags)
{
	// We need to allocate the structure with extra space to hold the routine name.  This is because
	// the call is asynchonous so a copy of the text will be needed because copying the pwszRoutineName
	// would fail because we can't be sure the string it points to will remain be allocated.
	int cbS = sizeof(S_ScriptTrackCallRoutine) + (sizeof(WCHAR) * wcslen(pwszRoutineName));
	S_ScriptTrackCallRoutine *pS = reinterpret_cast<S_ScriptTrackCallRoutine *>(new char[cbS]);
	if (!pS)
		return E_OUTOFMEMORY;
	pS->pmgr = m_pScriptManager;
	pS->phr = NULL;
	pS->pSegSt = pSegSt;
	pS->pSegSt->AddRef(); // hold a ref because the call is asynchronous and the interface we were passed may be released
	pS->dwVirtualTrackID = dwVirtualTrackID;
	pS->fErrorPMsgsEnabled = fErrorPMsgsEnabled;
	pS->i64IntendedStartTime = i64IntendedStartTime;
	pS->dwIntendedStartTimeFlags = dwIntendedStartTimeFlags;
	wcscpy(pS->wszRoutineName, pwszRoutineName);

	// Call asynchronously.  Needed to avoid deadlocks between the VBScript thread and
	// performance or to avoid blocking the performance if the VBScript routine goes into
	// a long loop.                                                          VVVVV
	HRESULT hrThreadCall = ms_Thread.Call(F_ScriptTrackCallRoutine, pS, cbS, false);
    delete [] reinterpret_cast<char *>(pS);
	return hrThreadCall;
}

//////////////////////////////////////////////////////////////////////
// SetVariable

struct S_SetVariable
{
	S_STD_PARAMS

	const WCHAR *pwszVariableName;
	VARIANT *pvarValue; // pass struct by reference
	bool fSetRef;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_SetVariable(void *pvParams)
{
	S_SetVariable *pS = reinterpret_cast<S_SetVariable*>(pvParams);
	*pS->phr = pS->pmgr->SetVariable(pS->pwszVariableName, *pS->pvarValue, pS->fSetRef, pS->pErrorInfo);
}

HRESULT CSingleThreadedScriptManager::SetVariable(const WCHAR *pwszVariableName, VARIANT varValue, bool fSetRef, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_SetVariable S	= { m_pScriptManager, &hr, pwszVariableName, &varValue, fSetRef, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_SetVariable, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// GetVariable

struct S_GetVariable
{
	S_STD_PARAMS

	const WCHAR *pwszVariableName;
	VARIANT *pvarValue;
	DMUS_SCRIPT_ERRORINFO *pErrorInfo;
};

void F_GetVariable(void *pvParams)
{
	S_GetVariable *pS = reinterpret_cast<S_GetVariable*>(pvParams);
	*pS->phr = pS->pmgr->GetVariable(pS->pwszVariableName, pS->pvarValue, pS->pErrorInfo);
}


HRESULT CSingleThreadedScriptManager::GetVariable(const WCHAR *pwszVariableName, VARIANT *pvarValue, DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
	HRESULT hr = E_FAIL;
	S_GetVariable S = { m_pScriptManager, &hr, pwszVariableName, pvarValue, pErrorInfo };
	HRESULT hrThreadCall = ms_Thread.Call(F_GetVariable, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// EnumRoutine

struct S_EnumItem
{
	S_STD_PARAMS

	bool fRoutine;
	DWORD dwIndex;
	WCHAR *pwszName;
	int *pcItems;
};

void F_EnumItem(void *pvParams)
{
	S_EnumItem *pS = reinterpret_cast<S_EnumItem*>(pvParams);
	*pS->phr = pS->pmgr->EnumItem(pS->fRoutine, pS->dwIndex, pS->pwszName, pS->pcItems);
}

HRESULT CSingleThreadedScriptManager::EnumItem(bool fRoutine, DWORD dwIndex, WCHAR *pwszName, int *pcItems)
{
	HRESULT hr = E_FAIL;
	S_EnumItem S = { m_pScriptManager, &hr, fRoutine, dwIndex, pwszName, pcItems };
	HRESULT hrThreadCall = ms_Thread.Call(F_EnumItem, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// DispGetIDsOfNames

struct S_DispGetIDsOfNames
{
	S_STD_PARAMS

	const IID *piid; // use pointer instead of reference to leave struct as simple aggregate type
	LPOLESTR __RPC_FAR *rgszNames;
	UINT cNames;
	LCID lcid;
	DISPID *rgDispId;
};

void F_DispGetIDsOfNames(void *pvParams)
{
	S_DispGetIDsOfNames *pS = reinterpret_cast<S_DispGetIDsOfNames*>(pvParams);
	*pS->phr = pS->pmgr->DispGetIDsOfNames(*pS->piid, pS->rgszNames, pS->cNames, pS->lcid, pS->rgDispId);
}

HRESULT CSingleThreadedScriptManager::DispGetIDsOfNames(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId)
{
	HRESULT hr = E_FAIL;
	S_DispGetIDsOfNames S = { m_pScriptManager, &hr, &riid, rgszNames, cNames, lcid, rgDispId };
	HRESULT hrThreadCall = ms_Thread.Call(F_DispGetIDsOfNames, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// DispInvoke

struct S_DispInvoke
{
	S_STD_PARAMS

	DISPID dispIdMember;
	const IID *piid; // use pointer instead of reference to leave struct as simple aggregate type
	LCID lcid;
	WORD wFlags;
	DISPPARAMS __RPC_FAR *pDispParams;
	VARIANT __RPC_FAR *pVarResult;
	EXCEPINFO __RPC_FAR *pExcepInfo;
	UINT __RPC_FAR *puArgErr;
};

void F_DispInvoke(void *pvParams)
{
	S_DispInvoke *pS = reinterpret_cast<S_DispInvoke*>(pvParams);
	*pS->phr = pS->pmgr->DispInvoke(pS->dispIdMember, *pS->piid, pS->lcid, pS->wFlags, pS->pDispParams, pS->pVarResult, pS->pExcepInfo, pS->puArgErr);
}

HRESULT CSingleThreadedScriptManager::DispInvoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams, VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr)
{
	HRESULT hr = E_FAIL;
	S_DispInvoke S = { m_pScriptManager, &hr, dispIdMember, &riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr };
	HRESULT hrThreadCall = ms_Thread.Call(F_DispInvoke, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Close

struct S_Close
{
	ScriptManager *pmgr;
};

void F_Close(void *pvParams)
{
	S_Close *pS = reinterpret_cast<S_Close*>(pvParams);
	pS->pmgr->Close();
}

void CSingleThreadedScriptManager::Close()
{
	S_Close S = { m_pScriptManager };
	ms_Thread.Call(F_Close, &S, sizeof(S), true);
}

//////////////////////////////////////////////////////////////////////
// Release

struct S_Release
{
	ScriptManager *pmgr;
	DWORD *pdw;
};

void F_Release(void *pvParams)
{
	S_Release *pS = reinterpret_cast<S_Release*>(pvParams);
	*pS->pdw = pS->pmgr->Release();
}

STDMETHODIMP_(ULONG)
CSingleThreadedScriptManager::Release()
{
	DWORD dw = 1;
	S_Release S = { m_pScriptManager, &dw };
	if (m_pScriptManager) // if creation failed, release will be called when m_pScriptManager hasn't been set
	{
		ms_Thread.Call(F_Release, &S, sizeof(S), true);
	}

	if (!dw)
		delete this;

	return dw;
}

/*
Template I used to stamp these things out...

//////////////////////////////////////////////////////////////////////
// XXX

struct S_XXX
{
	S_STD_PARAMS

	YYY
};

void F_XXX(void *pvParams)
{
	S_XXX *pS = reinterpret_cast<S_XXX*>(pvParams);
	*pS->phr = pS->pmgr->XXX(YYY);
}

HRESULT
CSingleThreadedScriptManager::XXX(YYY)
{
	HRESULT hr = E_FAIL;
	S_XXX S = { m_pScriptManager, &hr, YYY };
	HRESULT hrThreadCall = ms_Thread.Call(F_XXX, &S, sizeof(S), true);
	if (FAILED(hrThreadCall))
		return hrThreadCall;
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\xguids_dmscript.cpp ===
// Allows us to compile the source code in xguids.cpp to product an object file xguids_dmscript.obj
// (Which avoids an error when linking dmusic.lib.)

#include "pchscript.h"
#include "xguids.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\engparse.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Implementation of Parser.
//

//#define LIMITEDVBSCRIPT_LOGPARSER // 

/*#include "stdinc.h"
#include "enginc.h"
#include "engparse.h"
#include "engerror.h"
#include "engexpr.h"

#ifdef LIMITEDVBSCRIPT_LOGPARSER
#include "englog.h"
#endif*/

#include "pchscript.h"

// initial sizes for hash tables
//  tune these values?
const int g_cInitialRoutineLookup = 32;
const int g_cInitialGlobalsLookup = 32;
const int g_cInitialVarRefsLookup = 64;
const int g_cInitialAttrsLookup = 32;
const int g_cInitialLocalsLookup = 32;

// The parser will just hold weak references to the passed interfaces because we know that the parser is fully
// contained in the lifetime of its parent -- CAudioVBScriptEngine.
Parser::Parser(Lexer &lexer, Script &script, IActiveScriptSite *pActiveScriptSite, IDispatch *pGlobalDispatch)
  : m_lexer(lexer),
	m_plkuRoutines(NULL),
	m_plkuGlobals(NULL),
	m_plkuVarRefs(NULL),
	m_plkuNames(NULL),
	m_pActiveScriptSite(pActiveScriptSite),
	m_script(script),
	m_pGlobalDispatch(pGlobalDispatch)
{
	m_plkuRoutines = new Lookup(&m_hr, m_script.strings, g_cInitialRoutineLookup);
	if (!m_plkuRoutines)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuGlobals = new Lookup(&m_hr, m_script.strings, g_cInitialGlobalsLookup);
	if (!m_plkuGlobals)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuVarRefs = new Lookup(&m_hr, m_script.strings, g_cInitialVarRefsLookup);
	if (!m_plkuVarRefs)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	m_plkuNames = new Lookup(&m_hr, m_script.strings, g_cInitialAttrsLookup);
	if (!m_plkuNames)
		m_hr = E_OUTOFMEMORY;
	if (FAILED(m_hr))
		return;

	// Set up the built in constants as the first global variables.
	for (int i = 0; i < g_cBuiltInConstants; ++i)
	{
		Variables::index iSlot = m_script.globals.Next();
		Strings::index iStr;
		m_hr = m_plkuGlobals->FindOrAdd(g_rgszBuiltInConstants[i], iSlot, iStr);
		if (FAILED(m_hr))
			return;
		assert(m_hr == S_FALSE);
		Variable variable(iStr);
		m_hr = m_script.globals.Add(variable);
		if (FAILED(m_hr))
			return;
	}
	assert(m_script.globals.Next() == g_cBuiltInConstants); // they occupy the slots 0 to g_cBuiltInConstants - 1

	ParseScript();
}

Parser::~Parser()
{
	delete m_plkuRoutines;
	delete m_plkuGlobals;
	delete m_plkuVarRefs;
	delete m_plkuNames;
}

// top-level loop that parses the script
void
Parser::ParseScript()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// make sure the lexer has a token to start with
	if (!m_lexer)
	{
		if (m_lexer.error_num())
			Error(PARSEERR_LexerError);
		return;
	}
	if (Skip(TOKEN_linebreak) || !m_lexer)
		return;

	// parse subs and dims...
	bool fSub = false; // used to ensure that add Dim statements occur before all Sub statements
	for (;;)
	{
		if (m_lexer == TOKEN_dim)
		{
			if (fSub)
				Error(PARSEERR_DimAfterSub);
			else
				ParseDim();
		}
		else if (m_lexer == TOKEN_sub)
		{
			fSub = true;
			ParseSub();
		}
		else
		{
			Error(PARSEERR_ExpectedSubOrDim);
		}

		if (FAILED(m_hr) || !m_lexer)
			return;

		// must be followed by line break
		if (Expect(TOKEN_linebreak, PARSEERR_ExpectedLineBreak) || !m_lexer)
			return;
	}
}

// pre:  at sub
// post: beyond end sub
void
Parser::ParseSub()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// sub followed by identifier
	assert(m_lexer == TOKEN_sub);
	if (ExpectNext(TOKEN_identifier, PARSEERR_ExpectedIdentifier))
		return;

	const char *pszName = m_lexer.identifier_name();

	// check if there's already a variable with this name
	Variables::index iVar;
	Strings::index iStrVar;
	if (m_plkuGlobals->Find(pszName, iVar, iStrVar))
	{
		Error(PARSEERR_DuplicateVariable);
		return;
	}

	Routines::index iSlot = m_script.routines.Next();
	Strings::index iStr;
	m_hr = m_plkuRoutines->FindOrAdd(pszName, iSlot, iStr);
	if (FAILED(m_hr))
		return;
	if (m_hr == S_FALSE)
	{
		Routine routine(iStr);

		m_hr = m_script.routines.Add(routine);
		if (FAILED(m_hr))
			return;
	}
	else
	{
		Error(PARSEERR_DuplicateRoutine);
		return;
	}

	if (ExpectNext(TOKEN_linebreak, PARSEERR_ExpectedLineBreak))
		return;

	Lookup lkuLocals(&m_hr, m_script.strings, g_cInitialLocalsLookup);
	if (FAILED(m_hr))
		return;

	m_script.routines[iSlot].istmtBody = ParseStatements(iSlot, lkuLocals);
	if (FAILED(m_hr))
		return;

	if (m_lexer != TOKEN_end)
	{
		if (m_lexer == TOKEN_dim)
		{
			// AudioVBScript disallows dim statements except at the top of the script.
			// If one was found in the sub, users should receive the more specific error message.
			Error(PARSEERR_DimAfterSub);
		}
		else
		{
			Error(PARSEERR_ExpectedEndSub);
		}
		return;
	}
	if (Advance())
		return;
	if (Expect(TOKEN_sub, PARSEERR_ExpectedSub))
		return;

#ifdef LIMITEDVBSCRIPT_LOGPARSER
	LogRoutine(m_script, iSlot);
#endif
}

// pre:  at dim
// post: beyond dim <identifier>
void
Parser::ParseDim()
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	assert(m_lexer == TOKEN_dim);
	if (ExpectNext(TOKEN_identifier, PARSEERR_ExpectedIdentifier))
		return;

	Variables::index iSlot = m_script.globals.Next();
	Strings::index iStr;
	m_hr = m_plkuGlobals->FindOrAdd(m_lexer.identifier_name(), iSlot, iStr);
	if (FAILED(m_hr))
		return;
	if (m_hr == S_FALSE)
	{
		Variable variable(iStr);

		m_hr = m_script.globals.Add(variable);
		if (FAILED(m_hr))
			return;
	}
	else
	{
		Error(PARSEERR_DuplicateVariable);
		return;
	}

	if (Advance())
		return;
}

// pre:  at line break preceding the expected statements
// post: after end of line at token that isn't the start of another statement
Statements::index
Parser::ParseStatements(Routines::index irtnContext, Lookup &lkuLocals)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	assert(m_lexer == TOKEN_linebreak);
	if (Skip(TOKEN_linebreak))
		return 0;

	Statements::index istmtStart = m_script.statements.Next();
	for (;;) // ever
	{
		bool fBreakLoop = false;
		switch (m_lexer)
		{
		case TOKEN_if:
			ParseIf(irtnContext, lkuLocals);
			break;

		case TOKEN_set:
			if (Advance())
				return 0;
			ParseAssignmentOrCall(irtnContext, lkuLocals, true, false);
			break;

		case TOKEN_call:
			if (Advance())
				return 0;
			ParseAssignmentOrCall(irtnContext, lkuLocals, false, true);
			break;

		case TOKEN_identifier:
		case TOKEN_identifierdot:
			ParseAssignmentOrCall(irtnContext, lkuLocals, false, false);
			break;

		default:
			fBreakLoop = true;
			break;
		}

		if (fBreakLoop)
			break;

		if (FAILED(m_hr) || Expect(TOKEN_linebreak, PARSEERR_ExpectedLineBreak))
			return 0;
	}

	m_hr = m_script.statements.Add(Statement(Statement::cons_end(), 0));
	if (FAILED(m_hr))
		return 0;
	return istmtStart;
}

// pre:  at identifier or identifierdot (ambiguous as to whether this is going to be an assignment "x = 1" or call "x(1)")
// post: at line break beyond statement
void
Parser::ParseAssignmentOrCall(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, bool fCall)
{
	assert(!(fSet && fCall));

	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	assert(m_lexer == TOKEN_identifier || m_lexer == TOKEN_identifierdot);

	NameReference nref;
	ParseNameReference(irtnContext, lkuLocals, nref);
	if (FAILED(m_hr))
		return;

	if (fCall ? ExpectNext(TOKEN_lparen, PARSEERR_ExpectedLparen) : Advance())
		return;

	if (m_lexer == TOKEN_op_eq)
	{
		VariableReferences::index ivarrefLHS = VariableReferenceFromNameReference(irtnContext, lkuLocals, nref);
		if (FAILED(m_hr))
			return;
		Assignments::index iasgn = ParseAssignment(irtnContext, lkuLocals, fSet, ivarrefLHS);
		if (FAILED(m_hr))
			return;
		m_hr = m_script.statements.Add(Statement(Statement::cons_asgn(), iasgn, m_lexer.line()));
		if (FAILED(m_hr))
			return;
	}
	else
	{
		if (fSet)
		{
			Error(PARSEERR_ExpectedEq);
			return;
		}

		// add the call and its statement
		Calls::index icall = CallFromNameReference(irtnContext, lkuLocals, nref, fCall);
		if (FAILED(m_hr))
			return;
		m_hr = m_script.statements.Add(Statement(Statement::cons_call(), icall, m_lexer.line()));
		if (FAILED(m_hr))
			return;
	}
}

// pre:  at identifierdot
// post: at identifier
VariableReferences::index Parser::ParseDottedVariableReference(Routines::index irtnContext, Lookup &lkuLocals)
{
	return VariableReferenceInternal(irtnContext, lkuLocals, NULL);
}

// pre:  at =
// post: at line break beyond statement
Assignments::index
Parser::ParseAssignment(Routines::index irtnContext, Lookup &lkuLocals, bool fSet, VariableReferences::index ivarrefLHS)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	// make sure they're not trying to assign to one of the built in constants
	VariableReference &vr = m_script.varrefs[ivarrefLHS];
	if (vr.k == VariableReference::_global && vr.ivar < g_cBuiltInConstants)
	{
		Error(PARSEERR_AssignedToBuiltInConstant);
		return 0;
	}

	assert(m_lexer == TOKEN_op_eq);
	if (Skip(TOKEN_op_eq))
		return 0;

	ExprBlocks::index iexprRHS = ParseExpression(irtnContext, lkuLocals, NULL, false, false);
	if (FAILED(m_hr))
		return 0;

	if (m_lexer != TOKEN_linebreak)
	{
		Error(PARSEERR_InvalidExprLineBreak);
		return 0;
	}

	Assignments::index iasgn = m_script.asgns.Next();
	m_hr = m_script.asgns.Add(Assignment(fSet, ivarrefLHS, iexprRHS));
	if (FAILED(m_hr))
		return 0;

	return iasgn;
}

// pre:  at if
// post: beyond end if
void
Parser::ParseIf(Routines::index irtnContext, Lookup &lkuLocals)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return;
	}

	// Temporarily place if blocks in separate slots.
	// After completing the whole if statement then we'll append them to m_script.ifs.
	// This is necessary because we could end up recursively parsing nested ifs and the parent if
	// can't have its if blocks interleaved with its children.
	IfBlocks ifsTemp;

	// add the main if statement, which needs to go on first before we add the statements from its body
	Statements::index istmtIf = m_script.statements.Next();
	m_hr = m_script.statements.Add(Statement(Statement::cons_if(), m_lexer.line()));
	if (FAILED(m_hr))
		return;

	bool fFirst = true;

	do
	{
		// determine what part of the if (if/elseif/else) we're dealing with
		bool fCondition = true;
		if (fFirst)
		{
			assert(m_lexer == TOKEN_if);
			fFirst = false;
		}
		else
		{
			assert(m_lexer == TOKEN_elseif || m_lexer == TOKEN_else);
			if (m_lexer == TOKEN_else)
				fCondition = false;
		}
		if (Advance())
			return;

		ExprBlocks::index iexprIf = 0;
		if (fCondition)
		{
			// read the condition followed by then
			iexprIf = ParseExpression(irtnContext, lkuLocals, NULL, false, false);
			if (FAILED(m_hr))
				return;
			if (Expect(TOKEN_then, PARSEERR_ExpectedThen))
				return;
		}

		// line break
		if (m_lexer != TOKEN_linebreak)
		{
			Error(!fCondition && m_lexer == TOKEN_if ? PARSEERR_IntendedElseIf : PARSEERR_ExpectedLineBreak);
			return;
		}

		// statements
		Statements::index istmtIfBody = ParseStatements(irtnContext, lkuLocals);
		if (FAILED(m_hr))
			return;

		// add the if block
		if (fCondition)
			m_hr = ifsTemp.Add(IfBlock(iexprIf, istmtIfBody));
		else
			m_hr = ifsTemp.Add(IfBlock(istmtIfBody));
		if (FAILED(m_hr))
			return;
	}
	while (m_lexer != TOKEN_end);

	if (Advance())
		return;
	if (Expect(TOKEN_if, PARSEERR_ExpectedIf))
		return;

	// copy the temp if blocks into the script's real blocks
	IfBlocks::index iifIf = m_script.ifs.Next();
	IfBlocks::index iifTempNext = ifsTemp.Next();
	for (IfBlocks::index iifTemp = 0; iifTemp < iifTempNext; ++iifTemp)
	{
		m_hr = m_script.ifs.Add(ifsTemp[iifTemp]);
		if (FAILED(m_hr))
			return;
	}

	// terminate the if blocks
	m_hr = m_script.ifs.Add(IfBlock());
	if (FAILED(m_hr))
		return;

	// now set the main if statement's if blocks and tail
	Statement &stmtIf = m_script.statements[istmtIf];
	stmtIf.iif = iifIf;
	stmtIf.istmtIfTail = m_script.statements.Next();
}

// pre:  none (at location where expression is exprected)
// post: beyond last token that is part of a legal expression
ExprBlocks::index
Parser::ParseExpression(Routines::index irtnContext, Lookup &lkuLocals, ExprBlocks *peblocks, bool fAllowRparenAtEnd, bool fDetectSpecialErrorForSubCallWithParen)
{
	// if peblocks is non-null then the expression is appended there
	// otherwise it goes onto the blocks in the script
	ExprBlocks &eblocks = peblocks ? *peblocks : m_script.exprs;

	Expression expr(m_script, m_stack, peblocks);
	
	if (m_lexer == TOKEN_stringliteral)
	{
		// a string literal is the only element of an expression
		Strings::index iStr;
		m_hr = m_script.strings.Add(m_lexer.stringliteral_text(), iStr);
		if (FAILED(m_hr))
			return 0;
		Values::index ival = m_script.vals.Next();
		m_hr = m_script.vals.Add(Value(Value::cons_strvalue(), iStr));
		if (FAILED(m_hr))
			return 0;
		m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
		if (FAILED(m_hr))
			return 0;
		if (Advance())
			return 0;
	}
	else
	{
		// The format of an expression is:
		// 1) zero or more unary operators
		// 2) a value
		// 3) either end here or have a binary operator and go back to step 1

		// Oh yeah?  What about parentheses?
		// * If a left paren is encountered in step 2, we increase a paren count and go back to stage 1.
		// * In stage three, if there is paren count then a right paren is expected instead of ending.
		//   After a matching right paren, we decrease the paren count and pop back to stage 3.

		UINT cParens = 0;

		for (;;)
		{
			// stage 1
			while (CheckOperatorType(m_lexer, false, true, false, false))
			{
				// replace minus with sub so that the expression evaluator can identify unary (negation) vs binary (subtraction)
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer == TOKEN_op_minus ? TOKEN_sub : m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
			}

			// stage 2
			if (m_lexer == TOKEN_lparen)
			{
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;

				++cParens;
				continue;
			}
			else if (m_lexer == TOKEN_identifier || m_lexer == TOKEN_identifierdot)
			{
				NameReference nref;
				ParseNameReference(irtnContext, lkuLocals, nref);
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;

				if (m_lexer == TOKEN_lparen)
				{
					// add the call and the expression block
					Calls::index icall = CallFromNameReference(irtnContext, lkuLocals, nref, true);
					m_hr = expr.Add(ExprBlock(ExprBlock::cons_call(), icall));
					if (FAILED(m_hr))
						return 0;
				}
				else
				{

					VariableReferences::index ivarref = VariableReferenceFromNameReference(irtnContext, lkuLocals, nref);
					if (FAILED(m_hr))
						return 0;
					Values::index ival = m_script.vals.Next();
					m_hr = m_script.vals.Add(Value(Value::cons_varref(), ivarref));
					if (FAILED(m_hr))
						return 0;
					m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
					if (FAILED(m_hr))
						return 0;
				}
			}
			else if (m_lexer == TOKEN_numericliteral)
			{
				Values::index ival = m_script.vals.Next();
				m_hr = m_script.vals.Add(Value(Value::cons_numvalue(), m_lexer.numericliteral_val()));
				if (FAILED(m_hr))
					return 0;
				m_hr = expr.Add(ExprBlock(ExprBlock::cons_val(), ival));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
			}
			else
			{
				Error(m_lexer == TOKEN_stringliteral ? PARSEERR_StringInExprBlock: PARSEERR_ExpectedExprValue);
				return 0;
			}

			// stage 3
			while (m_lexer == TOKEN_rparen)
			{
				if (cParens == 0)
				{
					if (fAllowRparenAtEnd)
						break;

					Error(PARSEERR_UnexpectedRparen);
					return 0;
				}

				m_hr = expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
				if (FAILED(m_hr))
					return 0;
				if (Advance())
					return 0;
				--cParens;
			}

			if (!CheckOperatorType(m_lexer, false, false, true, false))
			{
				if (cParens > 0)
				{
					if (fDetectSpecialErrorForSubCallWithParen && cParens == 1 && m_lexer == TOKEN_comma)
					{
						// This special error is needed to give a helpful error message in cases like the following:
						//    Segment1.Play(IsSecondary, AP)
						// Here the user has accidentally called a sub using parentheses when they shouldn't.
						Error(PARSEERR_ParensUsedCallingSub);
					}
					else
					{
						Error(PARSEERR_ExpectedRparen);
					}
					return 0;
				}

				// *** this is the only successful exit point from the loop ***
				break;
			}

			expr.Add(ExprBlock(ExprBlock::cons_op(), m_lexer));
			if (Advance())
				return 0;
		}
	}

	ExprBlocks::index iexprStart = eblocks.Next();
	m_hr = expr.Generate();
	if (FAILED(m_hr))
		return 0;
	return iexprStart;
}

// if fParenthesized is true
//    pre:  at lparen
//    post: beyond rparen
// if fParenthesized is false
//    pre:  none (at location where expression for first parameter is expected)
//    post: at linebreak
ExprBlocks::index Parser::ParseParameters(Routines::index irtnContext, Lookup &lkuLocals, bool fParenthesized)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	if (fParenthesized)
	{
		assert(m_lexer == TOKEN_lparen);
		if (Advance())
			return 0;
	}

	// Temporarily place expression blocks in separate slots.
	// After completing the parameters then we'll append them to m_script.exprs.
	// This is necessary because we could end up recursively parsing nested calls inside an expression and
	// the parent parameters can't have their blocks interleaved with subexpression calls.
	ExprBlocks exprsTemp;

	Token tStop = fParenthesized ? TOKEN_rparen : TOKEN_linebreak;
	ParseErr perrExpectedFinish = fParenthesized ? 	PARSEERR_InvalidExprRparen : PARSEERR_InvalidExprLineBreak;

	bool fFirstParam = true;
	while (m_lexer != tStop)
	{
		if (!fFirstParam)
		{
			if (Expect(TOKEN_comma, perrExpectedFinish) || !m_lexer)
				return 0;
		}

		if (m_lexer == TOKEN_comma)
		{
			// This parameter is omitted.  Save it as an empty expression.
			// Example:
			//		MySong.Play , , , OldPlayingSong
			// There the first three parameters are omitted.
			m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_omitted()));
			if (FAILED(m_hr))
				return 0;
			m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_end()));
			if (FAILED(m_hr))
				return 0;
		}
		else
		{
			// The last parameter is set to true to detect a special error when we're calling a sub (!fParenthesized) and when this is
			// the first parameter to that sub (fFirstParam).  This will detect a comma and give a better error message in cases like
			// the following:
			//    Segment1.Play(IsSecondary, AP)
			// Here the user has accidentally called a sub using parameters when they shouldn't.
			ExprBlocks::index iexpr = ParseExpression(irtnContext, lkuLocals, &exprsTemp, fParenthesized, !fParenthesized && fFirstParam);
			if (FAILED(m_hr))
				return 0;
		}

		fFirstParam = false;
	}

	if (fParenthesized)
	{
		assert(m_lexer == TOKEN_rparen);
		if (Advance())
			return 0;
	}
	else
	{
		assert(m_lexer == TOKEN_linebreak);
	}

	// terminate the parameters
	m_hr = exprsTemp.Add(ExprBlock(ExprBlock::cons_end()));
	if (FAILED(m_hr))
		return 0;

	// copy from the temporary blocks into the script
	ExprBlocks::index iexprFirstInScript = m_script.exprs.Next();
	ExprBlocks::index iexprLastInTemp = exprsTemp.Next();
	for (ExprBlocks::index iexpr = 0; iexpr < iexprLastInTemp; ++iexpr)
	{
		m_hr = m_script.exprs.Add(exprsTemp[iexpr]);
		if (FAILED(m_hr))
			return 0;
	}
	return iexprFirstInScript;
}

void Parser::ParseNameReference(Routines::index irtnContext, Lookup &lkuLocals, NameReference &nref)
{
	nref.fSingleItem = m_lexer == TOKEN_identifier;
	nref.ivarrefMultiple = 0;

	if (nref.fSingleItem)
	{
		nref.strSingle = m_lexer.identifier_name();
		if (!nref.strSingle)
		{
			m_hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		nref.ivarrefMultiple = ParseDottedVariableReference(irtnContext, lkuLocals);
	}
}

VariableReferences::index Parser::VariableReferenceFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref)
{
	VariableReferences::index ivarref =
				nref.fSingleItem
					? VariableReferenceInternal(irtnContext, lkuLocals, nref.strSingle)
					: nref.ivarrefMultiple;
	return ivarref;
}

Calls::index Parser::CallFromNameReference(Routines::index irtnContext, Lookup &lkuLocals, const NameReference &nref, bool fParametersParenthesized)
{
	Call c;
	if (nref.fSingleItem)
	{
		// resolve the name in our temporary parsing name table
		Names_Parse::index iSlotName = m_names.Next();
		Strings::index iStrName = 0;
		m_hr = m_plkuNames->FindOrAdd(nref.strSingle, iSlotName, iStrName);
		if (FAILED(m_hr))
			return 0;
		if (m_hr == S_FALSE)
		{
			m_hr = m_names.Add(Name_Parse(iStrName));
			if (FAILED(m_hr))
				return 0;
		}

		c.k = Call::_global;
		c.istrname = iStrName;
	}
	else
	{
		c.k = Call::_dereferenced;
		c.ivarref = nref.ivarrefMultiple;
	}

	c.iexprParams = ParseParameters(irtnContext, lkuLocals, fParametersParenthesized);
	if (FAILED(m_hr))
		return 0;

	// add the call
	Calls::index icall = m_script.calls.Next();
	m_hr = m_script.calls.Add(c);
	if (FAILED(m_hr))
		return 0;

	return icall;
}

VariableReferences::index Parser::VariableReferenceInternal(Routines::index irtnContext, Lookup &lkuLocals, const char *pszName)
{
	if (FAILED(m_hr))
	{
		assert(false);
		return 0;
	}

	assert(pszName || m_lexer == TOKEN_identifierdot);

	ReferenceNames::index irname = m_script.rnames.Next();

	// resolve the first item, which is a variable in the script

	bool fLocal = false;
	Variables::index ivarBase;
	Strings::index iStrBase;
	const char *pszBase = pszName ? pszName : m_lexer.identifier_name();

	// check if there's already a routine with this name
	Variables::index iRtn;
	Strings::index iStrRtn;
	if (m_plkuRoutines->Find(pszBase, iRtn, iStrRtn))
	{
		Error(PARSEERR_ExpectedVariableButRoutineFound);
		return 0;
	}

	// try the globals
	if (!m_plkuGlobals->Find(pszBase, ivarBase, iStrBase))
	{
		// try the locals
		if (lkuLocals.Find(pszBase, ivarBase, iStrBase))
		{
			fLocal = true;
		}
		else
		{
			// try the global dispatch
			DISPID dispid = GetDispID(m_pGlobalDispatch, pszBase);
			if (dispid != DISPID_UNKNOWN)
			{
				// add it as a global
				//  Possible performance optimization. Oops. An unintended consequence is that the script
				//    will reserve a variant slot for this as a global variable at runtime.  Could do something
				//    so save this memory if that's a problem.
				ivarBase = m_script.globals.Next();
				m_hr = m_plkuGlobals->FindOrAdd(pszBase, ivarBase, iStrBase);
				if (FAILED(m_hr))
					return 0;
				assert(m_hr == S_FALSE); // we already tried Find, above so must be added
				Variable variable(iStrBase, dispid);
				m_hr = m_script.globals.Add(variable);
				if (FAILED(m_hr))
					return 0;
			}
			else
			{
				// add to the locals
				fLocal = true;
				ivarBase = m_script.routines[irtnContext].ivarNextLocal;
				m_hr = lkuLocals.FindOrAdd(pszBase, ivarBase, iStrBase);
				if (FAILED(m_hr))
					return 0;
				assert(m_hr == S_FALSE); // we already tried Find, above so must be added
				assert(ivarBase == m_script.routines[irtnContext].ivarNextLocal);
				++m_script.routines[irtnContext].ivarNextLocal;
			}
		}
	}

	// save the name
	m_hr = m_script.rnames.Add(ReferenceName(iStrBase));
	if (FAILED(m_hr))
		return 0;

	if (!pszName)
	{
		// remaining items are scoped outside the script, so just record their names

		do
		{
			// next is identifier or identifierdot
			if (Advance())
				return 0;
			if (m_lexer != TOKEN_identifier && m_lexer != TOKEN_identifierdot)
			{
				Error(PARSEERR_ExpectedIdentifier);
				return 0;
			}

			// resolve the name in our temporary parsing name table
			Names_Parse::index iSlotName = m_names.Next();
			Strings::index iStrName = 0;
			m_hr = m_plkuNames->FindOrAdd(m_lexer.identifier_name(), iSlotName, iStrName);
			if (FAILED(m_hr))
				return 0;
			if (m_hr == S_FALSE)
			{
				m_hr = m_names.Add(Name_Parse(iStrName));
				if (FAILED(m_hr))
					return 0;
			}

			// save the name
			m_hr = m_script.rnames.Add(ReferenceName(iStrName));
			if (FAILED(m_hr))
				return 0;
		}
		while (m_lexer != TOKEN_identifier);
	}

	// terminates the rnames
	m_hr = m_script.rnames.Add(ReferenceName(-1));
	if (FAILED(m_hr))
		return 0;

	//
	// make and return the reference
	//

	VariableReferences::index ivarref = m_script.varrefs.Next();
	m_hr = m_script.varrefs.Add(VariableReference(fLocal ? VariableReference::_local : VariableReference::_global, irname, ivarBase));
	if (FAILED(m_hr))
		return 0;

	return ivarref;
}

void
Parser::Error(ParseErr iErr)
{
	static const char *s_rgpszErrorText[] =
		{
		"Unexpected error!", // shouldn't ever get this error
		"Expected Sub or Dim statement",
		"Expected identifier",
		"Expected line break",
		"Expected End Sub",
		"Expected Sub",
		"Expected statement",
		"Expected '('",
		"Expected '='",
		"All Dim statements must occur before all Sub statements",
		"Invalid expression or missing line break",
		"Invalid expression or missing Then",
		"Invalid expression or missing ')'",
		"Strings may not appear inside numerical expressions",
		"Invalid expression -- expected a number or variable",
		"A variable with this name already exists",
		"Another routine with this name already exists",
		"Invalid expression -- expected ')'",
		"Invalid expression -- encountered ')' without a preceding '('",
		"Expected Then",
		"Expected End If",
		"Expected If",
		"Expected line break or ElseIf should be a single word without space before If",
		"The values True, False, and Nothing are read-only and cannot be set",
		"Cannot use parentheses when calling a Sub",
		"Sub name used where variable was expected"
		};

	assert(ARRAY_SIZE(s_rgpszErrorText) == PARSEERR_Max);

	if (FAILED(m_hr))
	{
		// Something forgot to check m_hr. We were already in an error state previously so leave that error as is and assert.
		assert(false);
		return;
	}

	if ((long)iErr < 0 || iErr > PARSEERR_Max)
	{
		assert(false);
		iErr = PARSEERR_LexerError;
	}

	m_hr = DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR;

	// The error number should be passed as PARSEERR_LexerError if and only if the lexer is in an error state.
	// In this case we'll get our description from the lexer itelf.  Otherwise we look it up in the table.
	assert((iErr == PARSEERR_LexerError) == (m_lexer == TOKEN_eof && m_lexer.error_num()));
	const char *pszErr = (m_lexer == TOKEN_eof && m_lexer.error_num()) ? m_lexer.error_descr() : s_rgpszErrorText[iErr];

	CActiveScriptError *perr = new CActiveScriptError(m_hr, m_lexer, pszErr);
	if (perr)
	{
		m_pActiveScriptSite->OnScriptError(perr);
		perr->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\englog.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Helper functions for logging script parsing.  Useful for debugging, but never turned on in released builds.
//

#error This file should never be used in released builds. // 

#include "stdinc.h"
#include "englog.h"

void LogToken(Lexer &l)
{
	char msg[500] = "";
	char type[500] = "";
	char more[500] = "";

	switch (l)
	{
	case TOKEN_eof:
		if (l.error_num())
		{
			sprintf(msg, "%d(%d): error #%d - %s\n", l.line(), l.column(), l.error_num(), l.error_descr());
			OutputDebugString(msg);
			return;
		}
		strcpy(type, "end-of-file");
		break;
	case TOKEN_sub:
		strcpy(type, "sub");
		break;
	case TOKEN_dim:
		strcpy(type, "dim");
		break;
	case TOKEN_if:
		strcpy(type, "if");
		break;
	case TOKEN_then:
		strcpy(type, "then");
		break;
	case TOKEN_end:
		strcpy(type, "end");
		break;
	case TOKEN_elseif:
		strcpy(type, "elseif");
		break;
	case TOKEN_else:
		strcpy(type, "else");
		break;
	case TOKEN_set:
		strcpy(type, "set");
		break;
	case TOKEN_call:
		strcpy(type, "call");
		break;
	case TOKEN_lparen:
		strcpy(type, "(");
		break;
	case TOKEN_rparen:
		strcpy(type, ")");
		break;
	case TOKEN_comma:
		strcpy(type, ",");
		break;
	case TOKEN_op_minus:
		strcpy(type, "-");
		break;
	case TOKEN_op_not:
		strcpy(type, "not");
		break;
	case TOKEN_op_pow:
		strcpy(type, "^");
		break;
	case TOKEN_op_mult:
		strcpy(type, "*");
		break;
	case TOKEN_op_div:
		strcpy(type, "\\");
		break;
	case TOKEN_op_mod:
		strcpy(type, "mod");
		break;
	case TOKEN_op_plus:
		strcpy(type, "+");
		break;
	case TOKEN_op_lt:
		strcpy(type, "<");
		break;
	case TOKEN_op_leq:
		strcpy(type, "<=");
		break;
	case TOKEN_op_gt:
		strcpy(type, ">");
		break;
	case TOKEN_op_geq:
		strcpy(type, ">=");
		break;
	case TOKEN_op_eq:
		strcpy(type, "=");
		break;
	case TOKEN_op_neq:
		strcpy(type, "<>");
		break;
	case TOKEN_is:
		strcpy(type, "is");
		break;
	case TOKEN_and:
		strcpy(type, "and");
		break;
	case TOKEN_or:
		strcpy(type, "or");
		break;
	case TOKEN_linebreak:
		strcpy(type, "linebreak");
		break;
	case TOKEN_identifier:
		strcpy(type, "identifier");
		strcpy(more, l.identifier_name());
		break;
	case TOKEN_identifierdot:
		strcpy(type, "identifier.");
		strcpy(more, l.identifier_name());
		break;
	case TOKEN_stringliteral:
		strcpy(type, "string-literal");
		strcpy(more, l.stringliteral_text());
		break;
	case TOKEN_numericliteral:
		strcpy(type, "numeric-literal");
		_itoa(l.numericliteral_val(), more, 10);
		break;
	default:
		strcpy(type, "invalid token type!");
		break;
	}
	static const char format[] = "%d(%d): %s\n";
	static const char formatmore[] = "%d(%d): %s(%s)\n";
	sprintf(msg, *more ? formatmore : format, l.line(), l.column(), type, more);
	OutputDebugString(msg);
}

SmartRef::AString GetVarrefName(Script &script, VariableReferences::index ivarref)
{
	VariableReference r = script.varrefs[ivarref];

	const char *pszKind;
	if (r.k == VariableReference::_global)
		pszKind = "G";
	else if (r.k == VariableReference::_local)
		pszKind = "L";

	bool fFirst = true;
	char namebuf[500] = "";
	for (ReferenceNames::index irname = r.irname; script.rnames[irname].istrIdentifier != -1; ++irname)
	{
		if (fFirst)
			fFirst = false;
		else
			strcat(namebuf, ".");
		strcat(namebuf, script.strings[script.rnames[irname].istrIdentifier]);
	}

	Variables::index islot = r.ivar;

	// check if it's a dispatch item
	if (r.k == VariableReference::_global)
	{
		DISPID dispid = script.globals[islot].dispid;
		if (dispid != DISPID_UNKNOWN)
		{
			pszKind = "D";
			islot = dispid; // show the dispid instead of the slot
		}
	}

	char buf[500];
	sprintf(buf, "{%s%d}%s", pszKind, islot, namebuf);

	return buf;
}

SmartRef::AString GetValueName(Script &script, Values::index ival)
{
	const Value &v = script.vals[ival];

	char buf[500];
	if (v.k == Value::_numvalue)
	{
		sprintf(buf, "%d", v.inumvalue);
	}
	else if (v.k == Value::_strvalue)
	{
		sprintf(buf, "\"%s\"", script.strings[v.istrvalue]);
	}
	else
	{
		assert(v.k == Value::_varref);
		return GetVarrefName(script, v.ivarref);
	}

	return buf;
}

void Indent(int iNesting)
{
	for (int i = 0; i < iNesting; ++i)
		OutputDebugString(" ");
}

// forward declaration due to mutual recursion with LogExpression
void LogCall(Script &script, Calls::index icall);

ExprBlocks::index LogExpression(Script &script, ExprBlocks::index _iexpr)
{
	char msg[500] = "";

	bool fFirst = true;
	for (ExprBlocks::index iexpr = _iexpr; script.exprs[iexpr]; ++iexpr)
	{
		ExprBlock expr = script.exprs[iexpr];

		if (fFirst)
			fFirst = false;
		else
			OutputDebugString("|");

		if (expr.k == ExprBlock::_op)
		{
			bool fUnary = false;
			const char *pszOp = "";
			switch (expr.op)
			{
			case TOKEN_sub: fUnary = true; pszOp = "-"; break;
			case TOKEN_op_not: fUnary = true; pszOp = "not"; break;
			case TOKEN_op_minus: pszOp = "-"; break;
			case TOKEN_op_pow: pszOp = "^"; break;
			case TOKEN_op_mult: pszOp = "*"; break;
			case TOKEN_op_div: pszOp = "\\"; break;
			case TOKEN_op_mod: pszOp = "mod"; break;
			case TOKEN_op_plus: pszOp = "+"; break;
			case TOKEN_op_lt: pszOp = "<"; break;
			case TOKEN_op_leq: pszOp = "<="; break;
			case TOKEN_op_gt: pszOp = ">"; break;
			case TOKEN_op_geq: pszOp = ">="; break;
			case TOKEN_op_eq: pszOp = "="; break;
			case TOKEN_op_neq: pszOp = "<>"; break;
			case TOKEN_is: pszOp = "is"; break;
			case TOKEN_and: pszOp = "and"; break;
			case TOKEN_or: pszOp = "or"; break;
			default: assert(false); break;
			}

			if (fUnary)
				sprintf(msg, "%su", pszOp);
			else
				sprintf(msg, "%sb", pszOp);
			OutputDebugString(msg);
		}
		else if (expr.k == ExprBlock::_val)
		{
			SmartRef::AString astrVal = GetValueName(script, expr.ival);
			OutputDebugString(astrVal);
		}
		else
		{
			assert(expr.k == ExprBlock::_call);
			LogCall(script, expr.icall);
		}
	}
	return iexpr;
}

void LogCall(Script &script, Calls::index icall)
{
	Call c = script.calls[icall];

	if (c.k == Call::_global)
	{
		OutputDebugString(script.strings[c.istrname]);
	}
	else
	{
		assert(c.k == Call::_dereferenced);
		SmartRef::AString astrCall = GetVarrefName(script, c.ivarref);
		OutputDebugString(astrCall);
	}

	OutputDebugString("(");
	bool fFirst = true;
	for (ExprBlocks::index iexpr = c.iexprParams; script.exprs[iexpr]; ++iexpr)
	{
		if (fFirst)
			fFirst = false;
		else
			OutputDebugString(", ");
		iexpr = LogExpression(script, iexpr);
	}

	OutputDebugString(")");
}

void LogStatements(Script &script, Statements::index istmt, int iNesting)
{
	char msg[500] = "";
	for (; script.statements[istmt].k; ++istmt)
	{
		Statement s = script.statements[istmt];
		if (s.k == Statement::_asgn)
		{
			Assignment a = script.asgns[s.iasgn];

			SmartRef::AString astrLHS = GetVarrefName(script, a.ivarrefLHS);
			sprintf(msg, "%s = ", astrLHS);
			Indent(iNesting);
			OutputDebugString(msg);

			LogExpression(script, a.iexprRHS);
			OutputDebugString("\n");
		}
		else if (s.k == Statement::_if)
		{
			bool fFirst = true;
			for (IfBlocks::index iif = s.iif; script.ifs[iif].k != IfBlock::_end; ++iif)
			{
				Indent(iNesting);

				IfBlock ib = script.ifs[iif];
				if (fFirst)
				{
					assert(ib.k == IfBlock::_cond);
					OutputDebugString("if ");
					fFirst = false;
				}
				else
				{
					if (ib.k == IfBlock::_cond)
						OutputDebugString("elseif ");
					else if (ib.k == IfBlock::_else)
						OutputDebugString("else");
				}

				if (ib.k == IfBlock::_cond)
				{
					LogExpression(script, ib.iexprCondition);
				}

				OutputDebugString("\n");
				LogStatements(script, ib.istmtBlock, iNesting + 3);				
			}

			istmt = s.istmtIfTail - 1; // -1 to offset the loop, which will increment it back
		}
		else if (s.k == Statement::_call)
		{
			Indent(iNesting);
			LogCall(script, s.icall);
			OutputDebugString("\n");
		}
		else
		{
			assert(false);
			Indent(iNesting);
			OutputDebugString("   Unknown statement type!\n");
		}
	}
}

void LogRoutine(Script &script, Routines::index irtn)
{
	Routine r = script.routines[irtn];
	const char *pszName = script.strings[r.istrIdentifier];
	int cLocals = r.ivarNextLocal;

	char msg[500] = "";
	sprintf(msg, "@ Sub %s (%d locals)\n", pszName, cLocals);
	OutputDebugString(msg);
	LogStatements(script, r.istmtBody, 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#ifndef __AARIFF__
#define __AARIFF__

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <mmsystem.h>
#include <objbase.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};





// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\chordtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       chordtrk.h
//
//--------------------------------------------------------------------------

// ChordTrack.h : Declaration of the CChordTrack

#ifndef __CHORDTRACK_H_
#define __CHORDTRACK_H_

#include "dmsect.h"
#include "dmusicip.h"

/////////////////////////////////////////////////////////////////////////////
// CChordTrack
class CChordTrack : 
	//public IChordTrack,
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CChordTrack();
	CChordTrack(const CChordTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);	
	~CChordTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IChordTrack
public:
// IChordTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);


HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// ChordTrack members
protected:
    long m_cRef;
	TList<DMChord>				m_ChordList;
	BYTE						m_bRoot;			// root of the track's scale
	DWORD						m_dwScalePattern;	// the track's scale pattern
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;

	BYTE						m_bRequiresSave;
	BOOL						m_fNotifyChord;

// protected methods
	void Clear();
	HRESULT SendNotification(REFGUID rguidType,
								MUSIC_TIME mtTime,
								IDirectMusicPerformance*	pPerf,
								IDirectMusicSegmentState*	pSegState,
								DWORD dwFlags);

	HRESULT GetChord(MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, DMUS_CHORD_PARAM* pChordParam);
	HRESULT GetRhythm(MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, DMUS_RHYTHM_PARAM* pRhythmParam);
	HRESULT LoadChordChunk(LPSTREAM pStream, DMChord& rChord);//, DWORD dwChunkSize );
    HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup);

};

#endif //__CHORDTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\cmmdtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cmmdtrk.h
//
//--------------------------------------------------------------------------

// CommandTrack.h : Declaration of the CCommandTrack

#ifndef __COMMANDTRACK_H_
#define __COMMANDTRACK_H_

#include "tlist.h"
#include "dmsect.h"
#include "dmusicip.h"

// Don't think I currently need Command state data...
typedef DWORD CommandStateData;

/////////////////////////////////////////////////////////////////////////////
// CCommandTrack
class CCommandTrack : 
	//public ICommandTrack,
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CCommandTrack();
	CCommandTrack(const CCommandTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CCommandTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// ICommandTrack
public:
// ICommandTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// CommandTrack members
protected:
	void Clear();
	HRESULT SendNotification(DWORD dwCommand, 
								MUSIC_TIME mtTime,
								IDirectMusicPerformance*	pPerf,
								IDirectMusicSegmentState*	pSegState,
								DWORD dwFlags);

	HRESULT GetParam2( 
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		DMUS_COMMAND_PARAM_2* pCommandParam);

	HRESULT GetParamNext( 
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		DMUS_COMMAND_PARAM_2* pCommandParam);

	HRESULT SetParamNext( 
		MUSIC_TIME mtTime,
		DMUS_COMMAND_PARAM_2* pCommandParam);

    long m_cRef;
	TList<DMCommand>			m_CommandList;
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;
	DMUS_COMMAND_PARAM_2*		m_pNextCommand;

	BYTE						m_bRequiresSave;
	BOOL						m_fNotifyCommand;
};

#endif //__COMMANDTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmfourcc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       dmfourcc.h
//
//--------------------------------------------------------------------------

#ifndef __DMFOURCC_H__
#define __DMFOURCC_H__

#define DM_FOURCC_STYLE_FORM        mmioFOURCC('S','T','Y','L')
#define DM_FOURCC_STYLE_UNDO_FORM   mmioFOURCC('s','t','u','n')
#define DM_FOURCC_STYLE_CHUNK       mmioFOURCC('s','t','y','h')
#define DM_FOURCC_STYLE_UI_CHUNK    mmioFOURCC('s','t','y','u')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define DM_FOURCC_PART_LIST	        mmioFOURCC('p','a','r','t')
#define DM_FOURCC_PART_CHUNK        mmioFOURCC('p','r','t','h')
#define DM_FOURCC_NOTE_CHUNK        mmioFOURCC('n','o','t','e')
#define DM_FOURCC_CURVE_CHUNK       mmioFOURCC('c','r','v','e')
#define DM_FOURCC_PATTERN_LIST      mmioFOURCC('p','t','t','n')
#define DM_FOURCC_PATTERN_CHUNK     mmioFOURCC('p','t','n','h')
#define DM_FOURCC_PATTERN_UI_CHUNK  mmioFOURCC('p','t','n','u')
#define DM_FOURCC_RHYTHM_CHUNK      mmioFOURCC('r','h','t','m')
#define DM_FOURCC_PARTREF_LIST      mmioFOURCC('p','r','e','f')
#define DM_FOURCC_PARTREF_CHUNK     mmioFOURCC('p','r','f','c')
#define DM_FOURCC_OLDGUID_CHUNK		mmioFOURCC('j','o','g','c')
#define DM_FOURCC_PATTERN_DESIGN	mmioFOURCC('j','p','n','d')
#define DM_FOURCC_PART_DESIGN		mmioFOURCC('j','p','t','d')
#define DM_FOURCC_PARTREF_DESIGN	mmioFOURCC('j','p','f','d')
#define DM_FOURCC_PIANOROLL_LIST	mmioFOURCC('j','p','r','l')
#define DM_FOURCC_PIANOROLL_CHUNK	mmioFOURCC('j','p','r','c')

struct ioDMStyleVersion
{
	DWORD				m_dwVersionMS;		 // Version # high-order 32 bits
	DWORD				m_dwVersionLS;		 // Version # low-order 32 bits
};

#endif // __DMFOURCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmpublic.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       dmpublic.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// DMPublic: things that will eventually end up in dmusici.h or dmusicf.h

#ifndef __DMPUBLIC_H_
#define __DMPUBLIC_H_

#include "dmusicf.h"

// These should live in dmusici.h
#endif // __DMPUBLIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmsect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmsect.h
//
//--------------------------------------------------------------------------

// DMSection.h : Declaration of the CDMSection

#ifndef __DMSECTION_H_
#define __DMSECTION_H_

#include "dmusicip.h"
#include "dmusicf.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "timesig.h"
#include "dmstylep.h"

#define TRACK_COMMAND	0
#define TRACK_CHORD		1
#define TRACK_RHYTHM	2
#define TRACK_REPEATS	3
#define TRACK_START		4

#define MAJOR_PATTERN	0x91	// 10010001
#define MINOR_PATTERN	0x89	// 10001001

struct DMSubChord
{
	HRESULT Save( IAARIFFStream* pRIFF );
	DMSubChord() : m_dwChordPattern(0), m_dwScalePattern(0), m_dwInversionPoints(0),
		m_bChordRoot(0), m_bScaleRoot(0), m_dwLevels(1 << SUBCHORD_STANDARD_CHORD)
	{}
	DMSubChord(DMUS_SUBCHORD& DMSC)
	{
		m_dwChordPattern = DMSC.dwChordPattern;
		m_dwScalePattern = DMSC.dwScalePattern;
		m_dwInversionPoints = DMSC.dwInversionPoints;
		m_dwLevels = DMSC.dwLevels;
		m_bChordRoot = DMSC.bChordRoot;
		m_bScaleRoot = DMSC.bScaleRoot;
	}
	operator DMUS_SUBCHORD()
	{
		DMUS_SUBCHORD result;
		result.dwChordPattern = m_dwChordPattern;
		result.dwScalePattern = m_dwScalePattern;
		result.dwInversionPoints = m_dwInversionPoints;
		result.dwLevels = m_dwLevels;
		result.bChordRoot = m_bChordRoot;
		result.bScaleRoot = m_bScaleRoot;
		return result;
	}
	DWORD	m_dwChordPattern;		// Notes in the subchord
	DWORD	m_dwScalePattern;		// Notes in the scale
	DWORD	m_dwInversionPoints;	// Where inversions can occur
	DWORD	m_dwLevels;				// Which levels are supported by this subchord
	BYTE	m_bChordRoot;			// Root of the subchord
	BYTE	m_bScaleRoot;			// Root of the scale
};

struct DMChord
{
	HRESULT Save( IAARIFFStream* pRIFF );
	DMChord() : m_strName(""), m_mtTime(0), m_wMeasure(0), m_bBeat(0), m_fSilent(false) {}
	DMChord(DMUS_CHORD_PARAM& DMC);
	DMChord(DMChord& DMC);
	operator DMUS_CHORD_PARAM();
	DMChord& operator= (const DMChord& rDMC);
	String	m_strName;		// Name of the chord
	MUSIC_TIME	m_mtTime;		// Time, in clocks
	WORD	m_wMeasure;		// Measure this falls on
	BYTE	m_bBeat;		// Beat this falls on
	BYTE	m_bKey;			// Underlying key
	DWORD	m_dwScale;		// Underlying scale
	bool	m_fSilent;		// Is this chord silent?
	TList<DMSubChord>	m_SubChordList;	// List of sub chords
};

struct DMCommand
{
	MUSIC_TIME	m_mtTime;		// Time, in clocks
	WORD		m_wMeasure;		// Measure this falls on
	BYTE		m_bBeat;		// Beat this falls on
	BYTE		m_bCommand;		// Command type
	BYTE		m_bGrooveLevel;	// Groove level
	BYTE		m_bGrooveRange; // Groove range
	BYTE		m_bRepeatMode;	// Repeat mode
};

struct MuteMapping
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwPChannelMap;
	BOOL		m_fMute;
};


/////////////////////////////////////////////////////////////////////////////
// CDMSection
class CDMSection : 
	public IDMSection,
	public IDirectMusicObject,
	public IPersistStream
{
public:
	CDMSection();
	~CDMSection();
	void CleanUp(BOOL fStop = FALSE);
	HRESULT LoadSection(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadStyleReference( LPSTREAM pStream, MMCKINFO* pck );
	HRESULT LoadChordList(LPSTREAM pStream, MMCKINFO* pckMain, TList<DMChord>& ChordList);
	HRESULT LoadCommandList(LPSTREAM pStream, MMCKINFO* pckMain, TList<DMCommand>& CommandList);
	HRESULT SaveChordList( IAARIFFStream* pRIFF );
	HRESULT SaveCommandList( IAARIFFStream* pRIFF );
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

protected:
    long m_cRef;
	String	m_strName;				// Name of section
	String	m_strStyleName;			// Name of associated style file
	IDirectMusicStyle* m_pStyle;	// Pointer to the style interface
	DWORD	m_dwTime;				// Time in clocks
	DWORD	m_dwFlags;				// ?
	WORD	m_wTempo;				// Tempo
	WORD	m_wRepeats;				// Repeats
	WORD	m_wMeasureLength;		// Number of measures
	DWORD	m_dwClockLength;		// Total number of clocks
	WORD	m_wClocksPerMeasure;	// Clocks per measure
	WORD	m_wClocksPerBeat;		// Clocks per beat
	WORD	m_wTempoFract;			// ?
	BYTE	m_bRoot;				// Root key of section
	TList<DMChord>		m_ChordList;	// List of chords
	TList<DMCommand>	m_CommandList;	// List of commands
	// style reference
	IDirectMusicBand*	m_pIDMBand;	// Section's band

public:

// IDMSection
public:
	STDMETHOD(CreateSegment)(IDirectMusicSegment* pSegment);
	STDMETHOD(GetStyle)(IUnknown** ppStyle);

	// IDirectMusicStyle methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;
};

#endif //__DMSECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\track.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CDirectMusicScriptTrack.
//

/*#include "stdinc.h"
#include "dll.h"
#include "track.h"
#include "dmusicf.h"
#include "dmusicp.h"*/

#include "pchscript.h"

//////////////////////////////////////////////////////////////////////
// Types

CScriptTrackEvent::~CScriptTrackEvent()
{
	if (m_pSegSt) m_pSegSt->Release();
	if (m_pEvent) delete m_pEvent;
}

HRESULT CScriptTrackEvent::Init(
        const EventInfo &item,
		IDirectMusicSegmentState* pSegSt)
{
    HRESULT hr = S_OK;

	m_pEvent = new EventInfo;
	if (!m_pEvent)
	{
		return E_OUTOFMEMORY;
	}

	hr = m_pEvent->Clone(item, 0);
	if (FAILED(hr))
    {
        delete m_pEvent;
        return E_OUTOFMEMORY;
    }

	m_pSegSt = pSegSt;
	m_pSegSt->AddRef();

    return S_OK;
}

void CScriptTrackEvent::Call(DWORD dwVirtualTrackID, bool fErrorPMsgsEnabled)
{

#ifdef DBG
	//  Probably will want better logging.
	DebugTrace(g_ScriptCallTraceLevel, "Script event %S\n", m_pEvent->pwszRoutineName);
#endif

	HRESULT hrCall = m_pEvent->pIDMScriptPrivate->ScriptTrackCallRoutine(
															m_pEvent->pwszRoutineName,
															m_pSegSt,
															dwVirtualTrackID,
															fErrorPMsgsEnabled,
															m_i64IntendedStartTime,
															m_dwIntendedStartTimeFlags);

#ifdef DBG
	if (FAILED(hrCall))
	{
		DebugTrace(g_ScriptCallTraceLevel, "Call failed 0x%08X\n", hrCall);
	}
#endif

}

STDMETHODIMP CScriptTrackEvent::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    if (iid == IID_IUnknown || iid == IID_CScriptTrackEvent)
    {
        *ppv = static_cast<CScriptTrackEvent*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CScriptTrackEvent::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CScriptTrackEvent::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// Creation

// When the script track plays one of its items, sends a PMsg to itself.  When it receives the PMsg, it calls the specified
// routine.  If an invalidation occurs, the PMsg isn't retracted.  (Perhaps because it sends the PMsgs directly to itself
// without calling StampPMsg.)  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the
// routine a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
// a second time when the FLUSH bit is set.
CDirectMusicScriptTrack::CDirectMusicScriptTrack(HRESULT *pHr)
  : CDirectMusicScriptTrackBase(GetModuleLockCounter(), CLSID_DirectMusicScriptTrack, true, false),
	m_fErrorPMsgsEnabled(false)
{
}

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CDirectMusicScriptTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	struct LocalFunction
	{
		// Helper used by the LoadRiff function when we expected to find something
		// but a RiffIter becomes false.  In this case, if it has a success HR
		// indicating there were no more items then we return DMUS_E_INVALID_SCRIPTTRACK
		// because the stream didn't contain the data we expected.  If it has a
		// failure hr, it was unable to read from the stream and we return its HR.
		static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
		{
			HRESULT hr = ri.hr();
			return SUCCEEDED(hr) ? DMUS_E_INVALID_SCRIPTTRACK : hr;
		}
	};

	// find <scrt>
	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SCRIPTTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load script track: List 'scrt' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(ri);
	}

	// find <scrl>
	SmartRef::RiffIter riEventsList = ri.Descend();
	if (!riEventsList)
		return riEventsList.hr();
	if (!riEventsList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load script track: List 'scrl' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(riEventsList);
	}

	// process each event <scre>
	SmartRef::RiffIter riEvent = riEventsList.Descend();
	if (!riEvent)
		return riEvent.hr();

	for ( ; riEvent; ++riEvent)
	{
		if (riEvent.id() == DMUS_FOURCC_SCRIPTTRACKEVENT_LIST)
		{
			HRESULT hr = this->LoadEvent(riEvent.Descend(), pIDMLoader);
			if (FAILED(hr))
				return hr;
		}
	}
	return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CDirectMusicScriptTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = CDirectMusicScriptTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (FAILED(hr))
		return hr;

	// Init each script in the event list with this performance.
	for (TListItem<EventInfo> *li = m_EventList.GetHead(); li; li = li->GetNext())
	{
		EventInfo &rinfo = li->GetItemValue();
		if (!rinfo.pIDMScript)
		{
			assert(false);
			continue;
		}

		DMUS_SCRIPT_ERRORINFO ErrorInfo;
		if (m_fErrorPMsgsEnabled)
			ZeroAndSize(&ErrorInfo);

		hr = rinfo.pIDMScript->Init(pPerformance, &ErrorInfo);

		if (m_fErrorPMsgsEnabled && hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT)
			FireScriptTrackErrorPMsg(pPerformance, pSegmentState, dwTrackID, &ErrorInfo);
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP
CDirectMusicScriptTrack::ProcessPMsg(
		IDirectMusicPerformance* pPerf,
		DMUS_PMSG* pPMSG)
{
    if (!pPMSG || !pPMSG->punkUser) return E_POINTER;

	CScriptTrackEvent *pScriptEvent = NULL;
    if (SUCCEEDED(pPMSG->punkUser->QueryInterface(IID_CScriptTrackEvent, (void**)&pScriptEvent)))
    {
        pScriptEvent->Call(pPMSG->dwVirtualTrackID, m_fErrorPMsgsEnabled);
        pScriptEvent->Release();
    }

	return DMUS_S_FREE;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack methods

STDMETHODIMP
CDirectMusicScriptTrack::IsParamSupported(REFGUID rguid)
{
	return rguid == GUID_EnableScriptTrackError ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

STDMETHODIMP
CDirectMusicScriptTrack::SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData)
{
	if (rguid == GUID_EnableScriptTrackError)
	{
		m_fErrorPMsgsEnabled = true;
		return S_OK;
	}
	else
	{
		return DMUS_E_SET_UNSUPPORTED;
	}
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CDirectMusicScriptTrack::LoadEvent(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event

	// TListItem<EventInfo> is the item we're going to insert into out event list.
	// SmartRef::Ptr is used instead of a regular pointer because it will automatically
	//    call delete to free the allocated list item if we bail out before the item is
	//    successfully inserted into the event list.
	// See class Ptr in smartref.h for the definition of SmartRef::Ptr.
	SmartRef::Ptr<TListItem<EventInfo> > spItem = new TListItem<EventInfo>;
	if (!spItem)
		return E_OUTOFMEMORY;
	EventInfo &rinfo = spItem->GetItemValue();

	bool fFoundEventHeader = false;

	for ( ; ri; ++ri)
	{
		switch(ri.id())
		{
			case DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK:
				// Read an event chunk
				DMUS_IO_SCRIPTTRACK_EVENTHEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
				if (FAILED(hr))
					return hr;

				fFoundEventHeader = true;
				rinfo.dwFlags = ioItem.dwFlags;
				rinfo.lTriggerTime = ioItem.lTimeLogical;
				rinfo.lTimePhysical = ioItem.lTimePhysical;
				break;

			case DMUS_FOURCC_REF_LIST:
				hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicScript, reinterpret_cast<void**>(&rinfo.pIDMScript));
				if (FAILED(hr))
					return hr;
				hr = rinfo.pIDMScript->QueryInterface(IID_IDirectMusicScriptPrivate, reinterpret_cast<void**>(&rinfo.pIDMScriptPrivate));
				if (FAILED(hr))
					return hr;
				break;

			case DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK:
				{
					hr = ri.ReadText(&rinfo.pwszRoutineName);
					if (FAILED(hr))
					{
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load script track: Problem reading 'scrn' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SCRIPTTRACK : hr;
					}
				}
				break;

			default:
				break;
		}
	}
	hr = ri.hr();

	if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.pIDMScript || !rinfo.pwszRoutineName))
	{
#ifdef DBG
		if (!fFoundEventHeader)
		{
			Trace(1, "Error: Unable to load script track: Chunk 'scrh' not found.\n");
		}
		else if (!rinfo.pIDMScript)
		{
			Trace(1, "Error: Unable to load script track: List 'DMRF' not found.\n");
		}
		else
		{
			Trace(1, "Error: Unable to load script track: Chunk 'scrn' not found.\n");
		}
#endif
		hr = DMUS_E_INVALID_SCRIPTTRACK;
	}

	if (SUCCEEDED(hr))
		m_EventList.AddHead(spItem.disown()); // disown releases SmartRef::Ptr from its obligation to delete the item since that is now handled by the list

	return hr;
}

HRESULT CDirectMusicScriptTrack::PlayItem(
		const EventInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	DWORD dwTimingFlags = 0;

	DMUS_PMSG *pMsg;
	HRESULT hr = pPerf->AllocPMsg(sizeof(DMUS_PMSG), &pMsg);
	if (FAILED(hr))
		return hr;
    ZeroAndSize(pMsg);

    CScriptTrackEvent *pScriptEvent = new CScriptTrackEvent;
	if (!pScriptEvent)
	{
		hr = E_OUTOFMEMORY;
		goto End;
	}

    hr = pScriptEvent->Init(item, pSegSt);
    if (FAILED(hr))
    {
		goto End;
    }

	if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_PREPARE)
		dwTimingFlags = DMUS_PMSGF_TOOL_IMMEDIATE;
	else if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_QUEUE)
		dwTimingFlags = DMUS_PMSGF_TOOL_QUEUE;
	else if (item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)
		dwTimingFlags = DMUS_PMSGF_TOOL_ATTIME;
	else
		dwTimingFlags = DMUS_IO_SCRIPTTRACKF_QUEUE; // default

	if (fClockTime)
	{
		pMsg->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
		pMsg->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | dwTimingFlags;
		if (!(item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)) // with at time, it may already be too late to play at the designated time so Play calls will just use time zero (ASAP)
		{
            pScriptEvent->SetTime(pMsg->rtTime, DMUS_SEGF_REFTIME);
		}
	}
	else
	{
		pMsg->mtTime = item.lTimePhysical + mtOffset;
		pMsg->dwFlags = DMUS_PMSGF_MUSICTIME | dwTimingFlags;
		if (!(item.dwFlags & DMUS_IO_SCRIPTTRACKF_ATTIME)) // with at time, it may already be too late to play at the designated time so Play calls will just use time zero (ASAP)
		{
            pScriptEvent->SetTime(pMsg->mtTime, 0);
		}
	}
	pMsg->dwVirtualTrackID = dwVirtualID;
    pMsg->punkUser = pScriptEvent;
	pMsg->pTool = this;
	this->AddRef(); // will be released when message is sent
	pMsg->dwType = DMUS_PMSGT_USER;

	hr = pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMsg));
	if (FAILED(hr))
	{
		this->Release(); // balance AddRef that now won't be counteracted
		goto End;
	}

	return hr;

End:
    if (pScriptEvent)
    {
        delete pScriptEvent;
    }
    pMsg->punkUser = NULL;
	pPerf->FreePMsg(pMsg);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\chordtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       chordtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// ChordTrack.cpp : Implementation of CChordTrack
//#include "stdafx.h"
//#include "Section.h"
#include "ChordTrk.h"
#include "debug.h"
#include "..\shared\critsec.h"
#include "..\shared\Validate.h"
#include <xboxutil.h>

/////////////////////////////////////////////////////////////////////////////
// CChordTrack

CChordTrack::CChordTrack() : m_bRequiresSave(0),
    m_bRoot(0), m_dwScalePattern(0), m_cRef(1), m_fNotifyChord(FALSE),
    m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// This currently only supports cloning on measure boundaries
// (otherwise time sig info would be needed to get the beats right)
CChordTrack::CChordTrack(const CChordTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0),
    m_bRoot(0), m_dwScalePattern(0), m_cRef(1), 
    m_fNotifyChord(rTrack.m_fNotifyChord),
    m_fCSInitialized(FALSE)

{
    IncrementDLLCount();
    
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    TListItem<DMChord>* pScan = rTrack.m_ChordList.GetHead();
    TListItem<DMChord>* pPrevious = NULL;
    WORD wMeasure = 0;
    BOOL fStarted = FALSE;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMChord& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            TListItem<DMChord>* pNew = new TListItem<DMChord>;
            if (pNew)
            {
                DMChord& rNew = pNew->GetItemValue();
                rNew.m_strName = rScan.m_strName;
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_bBeat = rScan.m_bBeat;
                rNew.m_bKey = rScan.m_bKey;
                rNew.m_dwScale = rScan.m_dwScale;
                TListItem<DMSubChord>* pSubScan = rScan.m_SubChordList.GetHead();
                for(; pSubScan; pSubScan = pSubScan->GetNext())
                {
                    DMSubChord& rSubScan = pSubScan->GetItemValue();
                    TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                    if (pSubNew)
                    {
                        DMSubChord& rSubNew = pSubNew->GetItemValue();
                        rSubNew.m_dwChordPattern = rSubScan.m_dwChordPattern;
                        rSubNew.m_dwScalePattern = rSubScan.m_dwScalePattern;
                        rSubNew.m_dwInversionPoints = rSubScan.m_dwInversionPoints;
                        rSubNew.m_dwLevels = rSubScan.m_dwLevels;
                        rSubNew.m_bChordRoot = rSubScan.m_bChordRoot;
                        rSubNew.m_bScaleRoot = rSubScan.m_bScaleRoot;
                        rNew.m_SubChordList.AddTail(pSubNew);
                    }
                }
                m_ChordList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        DMChord& rPrevious = pPrevious->GetItemValue();
        TListItem<DMChord>* pNew = new TListItem<DMChord>;
        if (pNew)
        {
            DMChord& rNew = pNew->GetItemValue();
            rNew.m_strName = rPrevious.m_strName;
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_bBeat = 0;
            rNew.m_bKey = rPrevious.m_bKey;
            rNew.m_dwScale = rPrevious.m_dwScale;
            TListItem<DMSubChord>* pSubPrevious = rPrevious.m_SubChordList.GetHead();
            for(; pSubPrevious; pSubPrevious = pSubPrevious->GetNext())
            {
                DMSubChord& rSubPrevious = pSubPrevious->GetItemValue();
                TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                if (pSubNew)
                {
                    DMSubChord& rSubNew = pSubNew->GetItemValue();
                    rSubNew.m_dwChordPattern = rSubPrevious.m_dwChordPattern;
                    rSubNew.m_dwScalePattern = rSubPrevious.m_dwScalePattern;
                    rSubNew.m_dwInversionPoints = rSubPrevious.m_dwInversionPoints;
                    rSubNew.m_dwLevels = rSubPrevious.m_dwLevels;
                    rSubNew.m_bChordRoot = rSubPrevious.m_bChordRoot;
                    rSubNew.m_bScaleRoot = rSubPrevious.m_bScaleRoot;
                    rNew.m_SubChordList.AddTail(pSubNew);
                }
            }
            m_ChordList.AddHead(pNew);
        }
    }
}

CChordTrack::~CChordTrack()
{
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    DecrementDLLCount();
}

void CChordTrack::Clear()
{
    m_ChordList.CleanUp();
}

STDMETHODIMP CChordTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CChordTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CChordTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CChordTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CChordTrack Methods
HRESULT CChordTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    V_INAME(CChordTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

// state data is not needed for now
typedef DWORD ChordStateData;

HRESULT CChordTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    ChordStateData* pStateData = new ChordStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *pStateData = 0;
    *ppStateData = pStateData;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return S_OK;
}

HRESULT CChordTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(ChordStateData));
        ChordStateData* pSD = (ChordStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

HRESULT CChordTrack::SendNotification(REFGUID rguidType,
                                      MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }
    IDirectMusicSegment* pSegment = NULL;
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_CHORD;
        pEvent->guidNotificationType = rguidType;

        if( SUCCEEDED( pSegState->GetSegment(&pSegment)))
        {
            if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
            {
                pEvent->dwGroupID = 0xffffffff;
            }
            pSegment->Release();
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            if (rguidType == GUID_NOTIFICATION_PRIVATE_CHORD)
            {
                //stamp this with the internal Performance Tool and process immediately
                pEvent->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
                pPerf->QueryInterface(IID_IDirectMusicTool, (void**)&pEvent->pTool);
                pEvent->pGraph = pGraph;
            }
            else
            {
                pEvent->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
                pGraph->StampPMsg((DMUS_PMSG*) pEvent );
                pGraph->Release();
            }
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CChordTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    V_INAME(CChordTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(ChordStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    bool fNotifyPastChord = false;
    TListItem<DMChord>* pLastChord = NULL;
    // if the dirty flag is set, a controlling segment either just stopped or just started.
    // send a private notification to sync with the current chord in this segment.
    if ( (dwFlags & DMUS_TRACKF_DIRTY) )
    {
        SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
    }
    // If we're seeking and not flushing, we need to notify for the chord that happens
    // before the current start time (if there is one)
    if ( (dwFlags & DMUS_TRACKF_SEEK) && !(dwFlags & DMUS_TRACKF_FLUSH) )
    {
        fNotifyPastChord = true;
    }
    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    for(; pChord && SUCCEEDED(hr); pChord = pChord->GetNext())
    {
        MUSIC_TIME mtChordTime = pChord->GetItemValue().m_mtTime;
        if (mtChordTime < mtStart && fNotifyPastChord)
        {
            pLastChord = pChord;
        }
        else if (mtStart <= mtChordTime && mtChordTime < mtEnd)
        {
            if (pLastChord)
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
                pLastChord = NULL;
            }
            if (SUCCEEDED(hr))
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtChordTime + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtChordTime + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
        }
        else if (mtChordTime >= mtEnd)
        {
            if (pLastChord)
            {
                SendNotification(GUID_NOTIFICATION_PRIVATE_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                if (m_fNotifyChord)
                {
                    hr = SendNotification(GUID_NOTIFICATION_CHORD, mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
            break;
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CChordTrack::GetChord( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_CHORD_PARAM* pChordParam)
{
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    TListItem<DMChord>* pNext = pNext = pChord->GetNext();
    for(; pNext; pNext = pNext->GetNext())
    {
        if (pNext->GetItemValue().m_mtTime <= mtTime) // may be it, but we need a next time
        {
            pChord = pNext;
        }
        else // passed it
        {
            break;
        }
    }
    *pChordParam = pChord->GetItemValue();
    if (pmtNext)
    {
        if (pNext)
        {
            *pmtNext = pNext->GetItemValue().m_mtTime - mtTime;
        }
        else
        {
            MUSIC_TIME mtLength = 0;
            *pmtNext = mtLength;
        }
    }
    TraceI(4, "Current time: %d, Time of Chord: %d\n", mtTime, pChord->GetItemValue().m_mtTime);
    return S_OK;
}

HRESULT CChordTrack::GetRhythm( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_RHYTHM_PARAM* pRhythmParam)
{
    DirectMusicTimeSig TimeSig = pRhythmParam->TimeSig;
    WORD wMeasure = (WORD)TimeSig.ClocksToMeasure(mtTime);
    TListItem<DMChord>* pChord = m_ChordList.GetHead();
    TListItem<DMChord>* pNext = NULL;
    DWORD dwPattern = 0;
    for( ; pChord; pChord = pChord->GetNext())
    {
        DMChord& rChord = pChord->GetItemValue();
        pNext = pChord->GetNext();
        if (rChord.m_wMeasure > wMeasure) // passed the target measure
        {
            break;
        }
        else if (wMeasure == rChord.m_wMeasure && !rChord.m_fSilent) // found (non-silent) part of the pattern
        {
            dwPattern |= 1 << rChord.m_bBeat;
        }
    }
//  DMChord& ChordResult =  pChord->GetItemValue();
    pRhythmParam->dwRhythmPattern = dwPattern;
    if (pmtNext)
    {
        if (pNext)
        {
            *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
        }
        else
        {
            MUSIC_TIME mtLength = 0;
            *pmtNext = mtLength;
        }
    }
    return S_OK;
}

// Returns either the Chord in effect at the beat containing mtTime,
// or the Rhythm pattern for the measure containing mtTime, depending
// on the value of dwCommand.
// ppData points to a struct containing an input time signature
// (used for converting mtTime to measures and beats) and either a list
// of subchords (if we're returning a chord) or a DWORD containing a rhythm
// pattern (if that's what's being returned).
HRESULT CChordTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CChordTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        return E_POINTER;
    }

    HRESULT hr = DMUS_E_NOT_FOUND;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_ChordList.GetHead())  // Something's in the chord list
    {
        if (rCommandGuid == GUID_ChordParam)
        {
            hr = GetChord(mtTime, pmtNext, (DMUS_CHORD_PARAM*)pData);
        }
        else if (rCommandGuid == GUID_RhythmParam)
        {
            hr = GetRhythm(mtTime, pmtNext, (DMUS_RHYTHM_PARAM*)pData);
        }
        else
        {
            hr = DMUS_E_GET_UNSUPPORTED;
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
} 

HRESULT CChordTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CChordTrack::SetParam);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (rCommandGuid == GUID_ChordParam)
    {
        DMUS_CHORD_PARAM* pChordParam = (DMUS_CHORD_PARAM*)(pData);
        TListItem<DMChord>* pChordItem = m_ChordList.GetHead();
        TListItem<DMChord>* pPrevious = NULL;
        TListItem<DMChord>* pChord = new TListItem<DMChord>;
        if (!pChord)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DMChord& rChord = pChord->GetItemValue();
            rChord = (DMChord) *pChordParam;
            rChord.m_mtTime = mtTime;
            rChord.m_wMeasure = 0;  // what value should this have?
            rChord.m_bBeat = 0;    // what value should this have?
            for(; pChordItem != NULL; pChordItem = pChordItem->GetNext())
            {
                if (pChordItem->GetItemValue().m_mtTime >= mtTime) break;
                pPrevious = pChordItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pChord);
                pChord->SetNext(pChordItem);
            }
            else // pChordItem is current head of list
            {
                m_ChordList.AddHead(pChord);
            }
            if (pChordItem && pChordItem->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                pChord->SetNext(pChordItem->GetNext());
                pChordItem->SetNext(NULL);
                delete pChordItem;
            }
        }
    }
    else
        hr = DMUS_E_SET_UNSUPPORTED;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::IsParamSupported(
                /*[in]*/ REFGUID            rGuid
            )
{
    V_INAME(CChordTrack::IsParamSupported);
    V_REFGUID(rGuid);

    return (rGuid == GUID_ChordParam || rGuid == GUID_RhythmParam) ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

// IPersist methods
 HRESULT CChordTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CChordTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicChordTrack;
    return S_OK;
}

// IPersistStream methods
 HRESULT CChordTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CChordTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    V_INAME(CChordTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    DWORD       cb;
    HRESULT     hr;
    TListItem<DMChord>*   pChord;


    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if (!SUCCEEDED(hr))
    {
        goto ON_END;
    }

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {
        DWORD dwRoot = m_bRoot;
        DWORD dwScale = m_dwScalePattern | (dwRoot << 24);
        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (FAILED(hr))
        {
            goto ON_END;
        }
        hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
        if (FAILED(hr))
        {
            goto ON_END;
        }
        hr = pRIFF->Ascend( &ckHeader, 0 );
        if (hr != 0)
        {
            goto ON_END;
        }

        for( pChord = m_ChordList.GetHead() ; pChord != NULL ; pChord = pChord->GetNext() )
        {
            hr = pChord->GetItemValue().Save(pRIFF);
            if (FAILED(hr))
            {
                goto ON_END;
            }
        }
        if( pChord == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release( );
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Greater(DMChord& Chord1, DMChord& Chord2)
{ 
    if (Chord1.m_wMeasure > Chord2.m_wMeasure)
        return TRUE;
    else if (Chord1.m_wMeasure < Chord2.m_wMeasure)
        return FALSE;
    else // same measure; compare beats
        return Chord1.m_bBeat > Chord2.m_bBeat;
}

BOOL Less(DMChord& Chord1, DMChord& Chord2)
{ 
    if (Chord1.m_wMeasure < Chord2.m_wMeasure)
        return TRUE;
    else if (Chord1.m_wMeasure > Chord2.m_wMeasure)
        return FALSE;
    else // same measure; compare beats
        return Chord1.m_bBeat < Chord2.m_bBeat;
}

HRESULT CChordTrack::Load(LPSTREAM pStream )
{
    V_INAME(CChordTrack::Load);
    V_INTERFACE(pStream);

    long lFileSize = 0;
    DWORD dwChunkSize;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    memset(&ck, 0, sizeof(ck));
    MMCKINFO        ckHeader;
    IAARIFFStream*  pRIFF = NULL;
//    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            lFileSize = ckMain.cksize - 4; // subtract off the list type
            DWORD dwScale;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0)
            {
                if (ckHeader.ckid == DMUS_FOURCC_CHORDTRACKHEADER_CHUNK )
                {
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= ckHeader.cksize;
                    hr = pStream->Read( &dwScale, sizeof( dwScale ), &cb );
                    if (FAILED(hr) || cb != sizeof( dwScale ) ) 
                    {
                        if (SUCCEEDED(hr)) hr = DMUS_E_CHUNKNOTFOUND;
                        pRIFF->Ascend( &ckHeader, 0 );
                        goto END;
                    }
                    hr = pRIFF->Ascend( &ckHeader, 0 );
                    if (FAILED(hr))
                    {
                        goto END;
                    }
                }
                else
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto END;
                }
            }
            else
            {
                hr = DMUS_E_CHUNKNOTFOUND;
                goto END;
            }
            m_bRoot = (BYTE) (dwScale >> 24);
            if (m_bRoot > 23) m_bRoot %= 24;
            m_dwScalePattern = dwScale & 0xffffff;
            while (lFileSize > 0)
            {
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0)
                {
                    dwChunkSize = ck.cksize;
                    if (ck.ckid == mmioFOURCC('c','r','d','b') )
                    {
                        TListItem<DMChord>* pChord = new TListItem<DMChord>;
                        if (!pChord) break;
                        DMChord& rChord = pChord->GetItemValue();
                        if (FAILED(LoadChordChunk(pStream, rChord))) break;
                        m_ChordList.AddTail(pChord);
                    }
                    // Otherwise, ignore the chunk.
                    // In either case, ascend and subtract off the chunk size
                    if (pRIFF->Ascend( &ck, 0 ) != 0) break;
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= dwChunkSize;
                }
                else break;
            }
            if (lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0)
            {
                hr = S_OK;
                m_ChordList.MergeSort(Less);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
END:
    if (pRIFF) pRIFF->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CChordTrack::LoadChordChunk(LPSTREAM pStream, DMChord& rChord)//, DWORD dwChunkSize)
{
    DWORD           dwChordSize;
    DWORD           dwSubChordSize;
    DWORD           dwSubChordCount;
    DWORD           cb;
    HRESULT         hr;
    DMUS_IO_CHORD       iChord;
    DMUS_IO_SUBCHORD    iSubChord;

    memset(&iChord , 0, sizeof(iChord));
    memset(&iSubChord , 0, sizeof(iSubChord));

    hr = pStream->Read( &dwChordSize, sizeof( dwChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwChordSize ) ) 
    {
        return E_FAIL;
    }
    //dwChunkSize -= 2; // for the size word
    if( dwChordSize <= sizeof( DMUS_IO_CHORD ) )
    {
        pStream->Read( &iChord, dwChordSize, NULL );
    }
    else
    {
        pStream->Read( &iChord, sizeof( DMUS_IO_CHORD ), NULL );
        StreamSeek( pStream, dwChordSize - sizeof( DMUS_IO_CHORD ), STREAM_SEEK_CUR );
    }
    memset( &rChord, 0, sizeof( rChord) );
    rChord.m_strName = iChord.wszName;
    rChord.m_mtTime = iChord.mtTime;
    rChord.m_bBeat = iChord.bBeat;
    rChord.m_wMeasure = iChord.wMeasure;
    rChord.m_bKey = m_bRoot;
    rChord.m_dwScale = m_dwScalePattern;
    rChord.m_fSilent = (iChord.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    hr = pStream->Read( &dwSubChordCount, sizeof( dwSubChordCount ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordCount ) )
    {
        return E_FAIL;
    }
    //wChunkSize -= 2; // for the count word
    hr = pStream->Read( &dwSubChordSize, sizeof( dwSubChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordSize ) )
    {
        return E_FAIL;
    }
    //wChunkSize -= 2; // for the size word
    for (; dwSubChordCount > 0; dwSubChordCount--)
    {
        if( dwSubChordSize <= sizeof( DMUS_IO_SUBCHORD ) )
        {
            pStream->Read( &iSubChord, dwSubChordSize, NULL );
        }
        else
        {
            pStream->Read( &iSubChord, sizeof( DMUS_IO_SUBCHORD ), NULL );
            StreamSeek( pStream, dwSubChordSize - sizeof( DMUS_IO_SUBCHORD ), STREAM_SEEK_CUR );
        }
        TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>;
        if( pSub )
        {
            DMSubChord& rSubChord = pSub->GetItemValue();
            memset( &rSubChord, 0, sizeof( rSubChord) );
            rSubChord.m_dwChordPattern = iSubChord.dwChordPattern;
            rSubChord.m_dwScalePattern = iSubChord.dwScalePattern;
            rSubChord.m_dwInversionPoints = iSubChord.dwInversionPoints;
            rSubChord.m_dwLevels = iSubChord.dwLevels;
            rSubChord.m_bChordRoot = iSubChord.bChordRoot;
            rSubChord.m_bScaleRoot = iSubChord.bScaleRoot;
            rChord.m_SubChordList.AddTail(pSub);
        }
        else 
        {
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CChordTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_CHORD )
    {
        m_fNotifyChord = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CChordTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CChordTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_CHORD )
    {
        m_fNotifyChord = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CChordTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CChordTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CChordTrack *pDM;
    
    try
    {
        pDM = new CChordTrack(*this, mtStart, mtEnd);

    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// For consistency with other track types
STDMETHODIMP CChordTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CChordTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CChordTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CChordTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CChordTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CChordTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, pContext, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, pContext, dwTrackGroup);
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CChordTrack::JoinInternal(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            DirectMusicTimeSig DMTimeSig = TimeSig;
            WORD wMeasureOffset = (WORD)DMTimeSig.ClocksToMeasure(mtNext + mtOver);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CChordTrack* pOtherTrack = (CChordTrack*)pNewTrack;
    TListItem<DMChord>* pScan = pOtherTrack->m_ChordList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        DMChord& rScan = pScan->GetItemValue();
        TListItem<DMChord>* pNew = new TListItem<DMChord>;
        if (pNew)
        {
            DMChord& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_strName = rScan.m_strName;
            rNew.m_wMeasure = rScan.m_wMeasure + wMeasure;
            rNew.m_bBeat = rScan.m_bBeat;
            rNew.m_bKey = rScan.m_bKey;
            rNew.m_dwScale = rScan.m_dwScale;
            TListItem<DMSubChord>* pSubScan = rScan.m_SubChordList.GetHead();
            for(; pSubScan; pSubScan = pSubScan->GetNext())
            {
                DMSubChord& rSubScan = pSubScan->GetItemValue();
                TListItem<DMSubChord>* pSubNew = new TListItem<DMSubChord>;
                if (pSubNew)
                {
                    DMSubChord& rSubNew = pSubNew->GetItemValue();
                    rSubNew.m_dwChordPattern = rSubScan.m_dwChordPattern;
                    rSubNew.m_dwScalePattern = rSubScan.m_dwScalePattern;
                    rSubNew.m_dwInversionPoints = rSubScan.m_dwInversionPoints;
                    rSubNew.m_dwLevels = rSubScan.m_dwLevels;
                    rSubNew.m_bChordRoot = rSubScan.m_bChordRoot;
                    rSubNew.m_bScaleRoot = rSubScan.m_bScaleRoot;
                    rNew.m_SubChordList.AddTail(pSubNew);
                }
            }
            m_ChordList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmscript\xguids.cpp ===
#define INITGUID
#include <debug.h>
#include <guiddef.h>

// Stupic HACK to get urlmon.h to compile as part of the activscript headers.
typedef struct _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;
#include <activscp.h>
//#endif

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\audtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       audtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

//AudTrk.cpp : Implementation of CAuditionTrack
#include "AudTrk.h"
#include "dmusicip.h"
#include "debug.h"
#include "..\shared\critsec.h"
#include "..\shared\Validate.h"
#include "..\shared\xcreate.h"

//extern IStream* gpTempoStream;

/////////////////////////////////////////////////////////////////////////////
// AuditionTrackState

AuditionTrackState::AuditionTrackState() : 
    m_fTestVariations(TRUE), m_fByGUID(TRUE), m_bVariationLock(0), m_mtSectionOffset(0)
{
    m_pPattern = NULL;
    memset(&m_guidPart, 0, sizeof(m_guidPart));
}

AuditionTrackState::~AuditionTrackState()
{
}

BOOL AuditionTrackState::PlayAsIs()
{
    return m_fTestVariations;
}

DWORD AuditionTrackState::Variations(DirectMusicPartRef& rPartRef, int nPartIndex)
{
    if (m_bVariationLock && rPartRef.m_bVariationLockID == m_bVariationLock)
    {
        TraceI(4, "Variations for locked part\n");
        return m_dwVariation;
    }
    else if ( (m_fByGUID && 
               rPartRef.m_pDMPart && 
               rPartRef.m_dwLogicalPartID == m_dwPart &&
               rPartRef.m_pDMPart->m_guidPartID == m_guidPart) ||
              (!m_fByGUID && rPartRef.m_dwLogicalPartID == m_dwPart) )
    {
        TraceI(4, "Variations for current part\n");
//      return m_pdwVariationMask[wPart] & m_dwVariation;
        return m_dwVariation;
    }
    else
    {
        TraceI(4, "Variations for a different part\n");
        return (m_pVariations[nPartIndex] == 0xff) ? 0 : (1 << m_pVariations[nPartIndex]);
    }
}

HRESULT AuditionTrackState::InitVariationInfo(DWORD dwVariations, DWORD dwPart, REFGUID rGuidPart, BOOL fByGuid)
{
    HRESULT hr = S_OK;
    m_dwVariation = dwVariations;
    m_dwPart = dwPart;
    m_guidPart = rGuidPart;
    m_fByGUID = fByGuid;
    if (!m_pPattern)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        if (rGuidPart == GUID_NULL)
        {
            m_bVariationLock = 0;
        }
        else
        {
            TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
            for (; pPartRef != NULL; pPartRef = pPartRef->GetNext())
            {
                DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
                if ((m_fByGUID && rPartRef.m_pDMPart && rPartRef.m_pDMPart->m_guidPartID == m_guidPart) ||
                    (!m_fByGUID && rPartRef.m_dwLogicalPartID == m_dwPart) )
                {
                    m_bVariationLock = rPartRef.m_bVariationLockID;
                }
            }
        }
    }
    return hr;
}

HRESULT AuditionTrackState::Play(
                  MUSIC_TIME                mtStart, 
                  MUSIC_TIME                mtEnd, 
                  MUSIC_TIME                mtOffset,
                  REFERENCE_TIME rtOffset,
                  IDirectMusicPerformance* pPerformance,
                  DWORD                     dwFlags,
                  BOOL fClockTime
            )
{
    TraceI(4, "Play [%d:%d @ %d]\n", mtStart, mtEnd, mtOffset);
    m_mtPerformanceOffset = mtOffset;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
    BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    if (fControl) // We need to make sure we get chords on beat boundaries
    {
        GetNextChord(mtStart, mtOffset, pPerformance, fStart);
    }
    MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
    if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && !fClockTime &&
        ( mtNotify < mtEnd ) )
    {
        mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
    }
    bool fReLoop = false;

    MUSIC_TIME mtPatternLength = PatternTimeSig().ClocksPerMeasure() * m_pPattern->m_wNumMeasures;
    if ( (fLoop || fStart) && mtPatternLength )
    {
        m_mtSectionOffset = mtStart - (mtStart % mtPatternLength);
    }
    MUSIC_TIME mtLast = m_mtSectionOffset + mtPatternLength;
    MUSIC_TIME mtPartLast = min(mtEnd, mtLast);
    DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
    if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
    if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
    if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fControl)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
    PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);

    if (fReLoop)
    {
        dwPartFlags = PLAYPARTSF_RELOOP;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
    }

    // If we need to reset the section offset, we do it after all the events in all the parts
    // have run. And then we need to run all events from pattern start to mtEnd.
    if (mtStart <= mtLast && mtLast < mtEnd)
    {
        m_mtSectionOffset = mtLast;
        InitPattern(m_pPattern, m_mtSectionOffset);
        dwPartFlags = 0;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        PlayParts(mtStart, mtEnd, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
    }

    if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
        ( mtNotify < mtEnd ) )
    {
        NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// AuditionTrackInfo

AuditionTrackInfo::AuditionTrackInfo() : 
    m_pPattern(NULL), m_pdwVariations(NULL), m_dwVariations(0), m_dwPart(0), m_fByGUID(TRUE)
{
    m_dwPatternTag = DMUS_PATTERN_AUDITION;
    memset(&m_guidPart, 0, sizeof(m_guidPart));
}

AuditionTrackInfo::~AuditionTrackInfo()
{
    if (m_pPattern) m_pPattern->Release();
    if (m_pdwVariations) delete [] m_pdwVariations;
}

HRESULT AuditionTrackInfo::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT AuditionTrackInfo::InitPlay(
                /*[in]*/  IDirectMusicTrack*        pParentrack,
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    IDirectMusicSegment* pSegment = NULL;
    AuditionTrackState* pStateData = new AuditionTrackState;
    if( NULL == pStateData )
    {
        return E_OUTOFMEMORY;
    }
    if (!m_pPattern) return E_POINTER;
    HRESULT hr = S_OK;
//  hr = InitTrackVariations();
//  if (FAILED(hr)) return hr;
    pStateData->m_dwValidate = m_dwValidate;
    *ppStateData = pStateData;
    StatePair SP(pSegmentState, pStateData);
    TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
    if (!pPair) return E_OUTOFMEMORY;
    m_StateList.AddHead(pPair);
    TListItem<StylePair>* pHead = m_pISList.GetHead();
    if (!pHead || !pHead->GetItemValue().m_pStyle) return E_FAIL;
    pHead->GetItemValue().m_pStyle->GetStyleInfo((void **)&pStateData->m_pStyle);
    pStateData->m_pTrack = pParentrack;
    pStateData->m_pPatternTrack = this;
    pStateData->m_dwVirtualTrackID = dwTrackID; 
    pStateData->m_pPattern = NULL;
    pStateData->InitPattern(m_pPattern, 0);
    pStateData->InitVariationInfo(m_dwVariations, m_dwPart, m_guidPart, m_fByGUID);
    pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
    pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
    pStateData->m_mtPerformanceOffset = 0;
    pStateData->m_mtNextChordTime = 0;
    pStateData->m_mtCurrentChordTime = 0;
    hr = pStateData->ResetMappings();
    if (FAILED(hr)) return hr;
#ifdef DXAPI
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
#endif
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
    if (m_lRandomNumberSeed)
    {
        pStateData->InitVariationSeeds(m_lRandomNumberSeed);
    }
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
        {
            pStateData->m_dwGroupID = 0xffffffff;
        }
        pSegment->Release();
    }
    return S_OK;
}

HRESULT AuditionTrackInfo::InitTrackVariations()
{
    // Do the PatternTrackInfo initialization
    PatternTrackInfo::InitTrackVariations(m_pPattern);
    // init the part's variation array
    if (m_pdwVariations)
    {
        delete [] m_pdwVariations;
        m_pdwVariations = NULL;
    }
    m_pdwVariations = new DWORD[m_pPattern->m_PartRefList.GetCount()];
    if (!m_pdwVariations) return E_OUTOFMEMORY;
    TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
    for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        m_pdwVariations[i] = 0;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CAuditionTrack

CAuditionTrack::CAuditionTrack() : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_pTrackInfo = new AuditionTrackInfo;
}

CAuditionTrack::CAuditionTrack(
        const CAuditionTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_pTrackInfo = new AuditionTrackInfo((AuditionTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CAuditionTrack::~CAuditionTrack()
{
    if (m_pTrackInfo)
    {
        delete m_pTrackInfo;
    }
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    DecrementDLLCount();
}

STDMETHODIMP CAuditionTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CAuditionTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
#ifdef DXAPI
    else if (iid == IID_IAuditionTrack)
    {
        *ppv = static_cast<IAuditionTrack*>(this);
    }
    else if (iid == IID_IPrivatePatternTrack)
    {
        *ppv = static_cast<IPrivatePatternTrack*>(this);
    }
#endif
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAuditionTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CAuditionTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CAuditionTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
    V_INAME(CAuditionTrack::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
        return DMUS_E_NOT_INIT;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = m_pTrackInfo->MergePChannels();
    if (SUCCEEDED(hr))
    {
        pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
        hr = m_pTrackInfo->Init(pSegment);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

    return hr;
}

HRESULT CAuditionTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    V_INAME(CAuditionTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}


HRESULT CAuditionTrack::EndPlay(
                /*[in]*/  void*     pStateData
            )
{
    V_INAME(CAuditionTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(AuditionTrackState));

    HRESULT hr = DMUS_E_NOT_INIT;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo)
    {
        hr = m_pTrackInfo->EndPlay((AuditionTrackState*)pStateData);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          REFERENCE_TIME rtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID,
                          BOOL fClockTime
                )
{
    V_INAME(CAuditionTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(AuditionTrackState));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo || m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }

    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    AuditionTrackState* pSD = (AuditionTrackState *)pStateData;

    if (pSD->m_dwValidate != m_pTrackInfo->m_dwValidate)
    {
        // new style inserted in track via Load.  Resync state data.
        MUSIC_TIME mtNext = 0;
        pSD->m_pStyle = pSD->FindStyle(mtStart, mtNext);
        if (!pSD->m_pStyle)
        {
            hr = E_POINTER;
        }
        pSD->InitPattern(pTrackInfo->m_pPattern, 0);
        pSD->m_dwValidate = m_pTrackInfo->m_dwValidate;
    }
    if (pSD && pSD->m_pMappings)
    {
        BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
        BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
        BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
        BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
        if (fStart || fSeek || fLoop || fControl)
        {
            if (pSD->m_fStateActive && !fClockTime) // if timesig events are enabled and using music time...
            {
                pSD->SendTimeSigMessage(mtStart, mtOffset, 0, pPerf);
            }
            pSD->m_fNewPattern = TRUE;
            pSD->m_mtCurrentChordTime = 0;
            pSD->m_mtNextChordTime = 0;
            pSD->m_mtLaterChordTime = 0;
//          pSD->m_CurrentChord.bSubChordCount = 0;
            for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
            {
                pSD->m_pMappings[dw].m_mtTime = 0;
                pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
                pSD->m_pMappings[dw].m_fMute = FALSE;
            }
        }
        hr = pSD->Play(mtStart, mtEnd, mtOffset, rtOffset, pPerf, dwFlags, fClockTime);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}


HRESULT CAuditionTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
{
    return E_NOTIMPL;
}

HRESULT CAuditionTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void * pStateData,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CAuditionTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_PTR_WRITE_OPT(pStateData,1);
    V_REFGUID(rCommandGuid);

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    HRESULT hr = S_OK;
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    if( GUID_Valid_Start_Time == rCommandGuid )
    {
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION) hr = DMUS_E_NOT_INIT;
        else
        {
            AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
            if (!pTrackInfo->m_pPattern) hr = E_POINTER;
            else
            {
                DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
                TListItem<MUSIC_TIME>* pScan = pTrackInfo->m_pPattern->m_StartTimeList.GetHead();
                for (; pScan; pScan = pScan->GetNext())
                {
                    if (pScan->GetItemValue() >= mtTime)
                    {
                        pValidStartData->mtTime = pScan->GetItemValue() - mtTime;
                        break;
                    }
                }
                if (!pScan) hr = DMUS_E_NOT_FOUND;
                else
                {
                    if (pmtNext)
                    {
                        if (pScan = pScan->GetNext())
                        {
                            *pmtNext = pScan->GetItemValue() - mtTime;
                        }
                        else
                        {
                            *pmtNext = 0;
                        }
                    }
                    hr = S_OK;
                }
            }
        }
    }
    else if ( GUID_Variations == rCommandGuid )
    {
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION) hr = DMUS_E_NOT_INIT;
        else
        {
            AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
            if (!pTrackInfo->m_pPattern) hr = E_POINTER;
            else
            {
                if (pStateData)
                {
                    AuditionTrackState* pSD = (AuditionTrackState*)pStateData;
                    DMUS_VARIATIONS_PARAM* pParam = (DMUS_VARIATIONS_PARAM*)pData;
                    if (!pSD->m_pPattern) hr = E_POINTER;
                    else
                    {
                        pParam->dwPChannelsUsed = pSD->m_pPattern->m_PartRefList.GetCount();
                        pParam->padwPChannels = pSD->m_pdwPChannels;
                        TListItem<DirectMusicPartRef>* pPartRef = pTrackInfo->m_pPattern->m_PartRefList.GetHead();
                        for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
                        {
                            DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
                            pTrackInfo->m_pdwVariations[i] = pSD->Variations(rPartRef, i);
                        }
                        pParam->padwVariations = pTrackInfo->m_pdwVariations;
                        if (pmtNext)
                        {
                            DirectMusicTimeSig& TimeSig = pTrackInfo->m_pPattern->m_timeSig;
                            MUSIC_TIME mtToNextChord = !pSD->m_mtNextChordTime ? 0 : pSD->m_mtNextChordTime - mtTime;
                            MUSIC_TIME mtPatternClocks = pTrackInfo->m_pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
                            if (!mtToNextChord || mtToNextChord > mtPatternClocks)
                            {
                                *pmtNext = mtPatternClocks;
                            }
                            else
                            {
                                *pmtNext = mtToNextChord;
                            }
                        }
                    }
                }
                else
                {
                    hr = E_POINTER;
                }
            }
        }
    }
    else if (rCommandGuid == GUID_IDirectMusicPatternStyle)
    {
        TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
        if (pScan)
        {
            IDirectMusicStyle* pDMStyle = NULL;
            IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
            if (!pStyle) 
            {
                hr = E_POINTER;
            }
            else
            {
                pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                // Note: QI with no Release has the effect of an AddRef
                *(IDirectMusicStyle**)pData = pDMStyle;
                if (pmtNext)
                {
                    *pmtNext = 0;
                }
                hr = S_OK;
            }
        }
        else hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
} 

HRESULT CAuditionTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CAuditionTrack::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguid);

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;
#ifdef DXAPI
    if( rguid == GUID_EnableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_DisableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = FALSE;
            hr = S_OK;
        }
    } 
    else
#endif
    if ( rguid == GUID_SeedVariations )
    {
        if (pData)
        {
            m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
            hr = S_OK;
        }
        else hr = E_POINTER;
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CAuditionTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CAuditionTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 

    *pClassID = CLSID_DirectMusicAuditionTrack;
    return S_OK;
}

HRESULT CAuditionTrack::IsParamSupported(
                /*[in]*/ REFGUID            rGuid
            )
{
    V_INAME(CAuditionTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (!m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }

    if ( rGuid == GUID_Valid_Start_Time ||
         rGuid == GUID_SeedVariations || 
         rGuid == GUID_Variations ||
         rGuid == GUID_IDirectMusicPatternStyle)
    {
        return S_OK;
    }
#ifdef DXAPI
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
        if( m_pTrackInfo->m_fActive )
        {
            if( rGuid == GUID_DisableTimeSig ) return S_OK;
            if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rGuid == GUID_EnableTimeSig ) return S_OK;
            if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if(( rGuid == GUID_DisableTimeSig ) ||
           ( rGuid == GUID_EnableTimeSig ) )
        {
            return S_OK;
        }
    }
#endif
    return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CAuditionTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

// Saves the track's pattern in single pattern format
HRESULT CAuditionTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    V_INAME(CAuditionTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO    ckRiff;
    MMCKINFO    ckPattern;
    HRESULT     hr = S_OK;
    AuditionTrackInfo* pTrackInfo = NULL;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION ||
            !pTrackInfo->m_pPattern)
        {
            hr = DMUS_E_NOT_INIT;
        }
    }

    if ( SUCCEEDED(hr) && SUCCEEDED(hr = AllocRIFFStream( pStream, &pRIFF )) )
    {
        ckRiff.fccType = DMUS_FOURCC_PATTERN_FORM;
        hr = pRIFF->CreateChunk(&ckRiff,MMIO_CREATERIFF);
        if (SUCCEEDED(hr))
        {
            ckPattern.fccType = DMUS_FOURCC_PATTERN_LIST;
            hr = pRIFF->CreateChunk( &ckPattern, MMIO_CREATELIST );
            if (SUCCEEDED(hr))
            {
                hr =  pTrackInfo->m_pPattern->DM_SaveSinglePattern( pRIFF );
                if (SUCCEEDED(hr))
                {
                    pRIFF->Ascend(&ckPattern, 0);
                    pRIFF->Ascend(&ckRiff, 0);
                }
            }
        }
        pRIFF->Release();
    }

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CAuditionTrack::Load(LPSTREAM pIStream )
{
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT         hr = E_FAIL;

    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    pTrackInfo->m_pISList.CleanUp();
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            IDMStyle* pINewStyle = NULL;
            hr = DirectMusicCreateInstance(
                CLSID_DirectMusicStyle,
                NULL,
                IID_IDMStyle,
                (void**)&pINewStyle
            );
            if (SUCCEEDED(hr))
            {
                DMStyleStruct* pNewStyle;
                pINewStyle->GetStyleInfo((void**)&pNewStyle);
                memset(pNewStyle, 0, sizeof(DMStyleStruct));
                hr = LoadPattern(pIRiffStream, &ckMain, pNewStyle);
                if (SUCCEEDED(hr))
                {
                    pNew->GetItemValue().m_mtTime = 0;
                    pNew->GetItemValue().m_pStyle = pINewStyle;
                    pTrackInfo->m_pISList.AddTail(pNew);
                }
            }
        }
        pIRiffStream->Release();
        pIRiffStream = NULL;
    }

    m_pTrackInfo->m_dwValidate++;

    hr = m_pTrackInfo->MergePChannels();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::LoadPattern(IAARIFFStream* pIRiffStream,  MMCKINFO* pckMain, DMStyleStruct* pNewStyle)
{
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    DWORD         dwPos;
    HRESULT       hr = S_OK;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_STYLE_CHUNK:
            {
                DMUS_IO_STYLE iDMStyle;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
                hr = pIStream->Read( &iDMStyle, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                pNewStyle->m_TimeSignature.m_bBeatsPerMeasure = iDMStyle.timeSig.bBeatsPerMeasure;
                pNewStyle->m_TimeSignature.m_bBeat = iDMStyle.timeSig.bBeat;
                pNewStyle->m_TimeSignature.m_wGridsPerBeat = iDMStyle.timeSig.wGridsPerBeat;
                pNewStyle->m_dblTempo = iDMStyle.dblTempo;
                break;
            }

            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch( ck.fccType )
                {

                case DMUS_FOURCC_PATTERN_LIST:
                        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
                        CDirectMusicPattern* pPattern = 
                            new CDirectMusicPattern( &pNewStyle->m_TimeSignature, FALSE );
                        if( pPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        ckList.fccType = DMUS_FOURCC_PATTERN_LIST;
                        // Allow this to succeed whether the pattern chunk is
                        // in a RIFF chunk or a LIST chunk.
                        if( (ck.ckid == FOURCC_LIST && pIRiffStream->Descend( &ckList, NULL, MMIO_FINDLIST ) != 0) ||
                            (ck.ckid == FOURCC_RIFF && pIRiffStream->Descend( &ckList, NULL, MMIO_FINDRIFF ) != 0) )
                        {
                            hr = E_FAIL;
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        hr = pPattern->DM_LoadPattern( pIRiffStream, &ckList, pNewStyle );
                        pIRiffStream->Ascend( &ckList, 0 );
                        if( FAILED( hr ) )
                        {
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
                        if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->Release();
                        pTrackInfo->m_pPattern = pPattern;
                        pTrackInfo->InitTrackVariations();
                        break;
                }
                break;

        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

// Creates a segment containing an audition track with a style based on pStyle.
// Also creates a Tempo track, based on the pattern's tempo.  Other tracks
// (e.g. chord and band tracks) must be added to the segment separately.
// NOTE: might want to consider having a MUSIC_TIME parm here, so I can select
// a style.
#ifdef DXAPI
HRESULT CAuditionTrack::CreateSegment(
            IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment)
{
    V_INAME(IDirectMusicPatternTrack::CreateSegment);
    V_INTERFACE(pStyle);
    V_PTRPTR_WRITE(ppSegment);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    // 1. Give the track a style based on the one passed in (but with no patterns)
    IDMStyle* pIS = NULL;
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
    if (SUCCEEDED(hr))
    {
        IDMStyle* pINewStyle = NULL;
        hr = DirectMusicCreateInstance(CLSID_DirectMusicStyle,NULL,IID_IDMStyle,(void**)&pINewStyle);
        if (SUCCEEDED(hr))
        {

            DMStyleStruct* pOldStyle;
            DMStyleStruct* pNewStyle;
            pIS->GetStyleInfo((void**)&pOldStyle);
            pINewStyle->GetStyleInfo((void**)&pNewStyle);
            pNewStyle->m_guid = pOldStyle->m_guid;
            pNewStyle->m_strCategory = pOldStyle->m_strCategory;
            pNewStyle->m_strName = pOldStyle->m_strName;
            pNewStyle->m_dwVersionMS = pOldStyle->m_dwVersionMS;
            pNewStyle->m_dwVersionLS = pOldStyle->m_dwVersionLS;
            pNewStyle->m_TimeSignature = pOldStyle->m_TimeSignature;
            pNewStyle->m_dblTempo = pOldStyle->m_dblTempo;

            // Don't worry about bands and personalities...
            pNewStyle->m_pDefaultBand = NULL;
            pNewStyle->m_pDefaultPers = NULL;
            pNew->GetItemValue().m_mtTime = 0;
            pNew->GetItemValue().m_pStyle = pINewStyle;
            TListItem<DWORD>* pScan = pOldStyle->m_PChannelList.GetHead();
            for (; pScan; pScan = pScan->GetNext() )
            {
                TListItem<DWORD>* pNew = new TListItem<DWORD>(pScan->GetItemValue());
                if (!pNew) 
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pNewStyle->m_PChannelList.AddHead(pNew);
                }
            }
            if (SUCCEEDED(hr))
            {
                pTrackInfo->m_pISList.AddTail(pNew);
                // 2. Create a Tempo Track in which to store the tempo events
                //////////////////////////////////////////////////////////
                DMUS_TEMPO_PARAM tempo;
                tempo.mtTime = 0; 
                tempo.dblTempo = (double) pNewStyle->m_dblTempo; 
                //////////////////////////////////////////////////////////
                //IPersistStream* pIPSTrack;
                IDirectMusicTrack*  pDMTrack = NULL;
                if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,
                    NULL, IID_IDirectMusicTrack,
                    (void**)&pDMTrack )))
                {
                    GUID Guid = GUID_TempoParam;
                    if (!SUCCEEDED(pDMTrack->SetParam(Guid, 0, &tempo)))
                    {
                        pDMTrack = NULL;
                    }
                }
                // 3. Create a segment.
                IDirectMusicSegment *pISegment;
                hr = DirectMusicCreateInstance(CLSID_DirectMusicSegment,NULL,IID_IDirectMusicSegment,(void**)&pISegment);
                if (SUCCEEDED(hr) )
                {
                    // 4. Initialize the segment appropriately.
                    DirectMusicTimeSig& TimeSig = pNewStyle->m_TimeSignature;
                    pISegment->SetLength(TimeSig.ClocksPerMeasure()); // default to a length of 1 measure
                    pISegment->SetDefaultResolution(0);
                    pISegment->InsertTrack(this, 1);
                    if (pDMTrack)
                    {
                        pISegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    hr = S_OK;
                    *ppSegment = pISegment;
                }
            }
        }
        pIS->Release();
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// Sets the pattern for a track, given a style, the name of a pattern
// within the style, and the pattern's type (regular pattern/motif/fragment).
HRESULT CAuditionTrack::SetPatternByName(IDirectMusicSegmentState* pSegState, 
                                        WCHAR* wszName,
                                        IDirectMusicStyle* pStyle,
                                        DWORD dwPatternType,
                                        DWORD* pdwLength)
{
    V_INAME(IDirectMusicPatternTrack::SetPatternByName);
    V_INTERFACE_OPT(pSegState);
    V_PTR_READ(wszName, 1);
    V_INTERFACE(pStyle);
    V_PTR_WRITE(pdwLength, DWORD);

    HRESULT hr = S_OK;
    IDMStyle* pDMStyle = NULL;
    IStream* pStream = NULL;

    hr = pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle);
    if (SUCCEEDED(hr))
    {
        hr = pDMStyle->GetPatternStream(wszName, dwPatternType, &pStream);
        if (S_OK == hr)
        {
            hr = SetPattern(pSegState, pStream, pdwLength);
            pStream->Release();
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
        pDMStyle->Release();
    }

    return hr;
}
    
// Sets the pattern for a track.  The pattern is read from pStream.
// IMPORTANT: Calling SetPattern could change the pattern's PartRef guid, which would make 
// Variations cease to work.  therefore, it's a good idea to call SetVariation after
// caling SetPattern.
HRESULT CAuditionTrack::SetPattern(IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength)
{
    IAARIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = DMUS_E_NOT_INIT;
    CDirectMusicPattern* pOldPattern = NULL;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else
    {
        DMStyleStruct* pStyle = NULL;
        IDMStyle* pIS = NULL;
        TListItem<StylePair>* pStyleItem = NULL;

        PatternTrackState* pPatternState = m_pTrackInfo->FindState(pSegState);
        AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
        if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
        {
            goto ON_END;
        }
        pStyleItem = pTrackInfo->m_pISList.GetHead();
        if (!pStyleItem)
        {
            goto ON_END;
        }
        pIS = pStyleItem->GetItemValue().m_pStyle;
        if (!pIS) goto ON_END;
        pIS->GetStyleInfo((void**)&pStyle);
        // 1. Set up the track's pattern.
        if (pTrackInfo->m_pPattern)
        {
            pOldPattern = pTrackInfo->m_pPattern;
        }
        pTrackInfo->m_pPattern = new CDirectMusicPattern( &pStyle->m_TimeSignature, FALSE );
        if( pTrackInfo->m_pPattern == NULL )
        {
            hr = E_OUTOFMEMORY ;
            goto ON_END;
        }
        // 2. Load the pattern in single Pattern format
        StreamSeek(pStream, 0, STREAM_SEEK_SET);
        if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
        {
            ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

            if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
            {
                hr = pTrackInfo->m_pPattern->DM_LoadPattern( pIRiffStream, &ckMain, pStyle );
                if (SUCCEEDED(hr))
                {
                    DirectMusicTimeSig& TimeSig = 
                        pTrackInfo->m_pPattern->m_timeSig.m_bBeat == 0 ? 
                        pStyle->m_TimeSignature : 
                        pTrackInfo->m_pPattern->m_timeSig;
                    *pdwLength = pTrackInfo->m_pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
                }
            }
            pIRiffStream->Release();

            hr = pTrackInfo->InitTrackVariations();
            // Set up the new pattern.
            if (pPatternState)
            {
                pPatternState->InitPattern(pTrackInfo->m_pPattern, 0, pOldPattern);
            }
            if (SUCCEEDED(hr))
            {
                // merge PChannels
                hr = m_pTrackInfo->MergePChannels();
            }
        }
    }

ON_END:
    if (pOldPattern) pOldPattern->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CAuditionTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart)
{
    V_INAME(IDirectMusicPatternTrack::SetVariation);
    V_INTERFACE_OPT(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    PatternTrackState* pPatternState = NULL;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        goto ON_END;
    }
    pTrackInfo->m_dwVariations = dwVariationFlags;
    pTrackInfo->m_dwPart = dwPart;
    pTrackInfo->m_fByGUID = FALSE;
    pPatternState = m_pTrackInfo->FindState(pSegState);
    if (pPatternState)
    {
        AuditionTrackState* pState = (AuditionTrackState*)pPatternState;
        GUID guidPart;
        memset(&guidPart, 0, sizeof(guidPart));
        pState->InitVariationInfo(dwVariationFlags, dwPart, guidPart, FALSE);
    }
    hr = S_OK;
ON_END:
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

    return hr;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CAuditionTrack::SetVariationByGUID(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, REFGUID rguidPart, DWORD dwPChannel)
{
    HRESULT hr = DMUS_E_NOT_INIT;
    PatternTrackState* pPatternState = NULL;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    AuditionTrackInfo* pTrackInfo = (AuditionTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_AUDITION)
    {
        goto ON_END;
    }
    pTrackInfo->m_dwVariations = dwVariationFlags;
    pTrackInfo->m_guidPart = rguidPart;
    pTrackInfo->m_dwPart = dwPChannel;
    pTrackInfo->m_fByGUID = TRUE;
    pPatternState = m_pTrackInfo->FindState(pSegState);
    if (pPatternState)
    {
        AuditionTrackState* pState = (AuditionTrackState*)pPatternState;
        pState->InitVariationInfo(dwVariationFlags, dwPChannel, rguidPart, TRUE);
    }
    hr = S_OK;
ON_END:
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

    return hr;
}
#endif

HRESULT STDMETHODCALLTYPE CAuditionTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CAuditionTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CAuditionTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CAuditionTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CAuditionTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CAuditionTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;
    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    CAuditionTrack *pDM;
    
    try
    {
        pDM = new CAuditionTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CAuditionTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    return GetParam(rCommandGuid, mtTime, NULL, pmtNext, pData);
}

STDMETHODIMP CAuditionTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext = 0;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), pStateData, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, pStateData, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CAuditionTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

STDMETHODIMP CAuditionTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CAuditionTrack::Play( 
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    HRESULT hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CAuditionTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CAuditionTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstyle2.h ===
// Dx8Style.h : New for DX8
//
// Copyright (c) 1999-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DX8STYLE_H_
#define __DX8STYLE_H_

/*
@interface IDirectMusicStyle8 | 
The <i IDirectMusicStyle8> interface extends the <i IDirectMusicStyle> interface.


@base public | IUnknown

@meth HRESULT | ComposeMelodyFromTemplate | Creates a sequence segment from a 
style and a Melody template (containing a Melody Generation track, a Chord track,
and an optional Style track).  Clones the segment and adds a 
Sequence track containing melodic information.
*/

// This eventually will go in dmusici.h

/*/////////////////////////////////////////////////////////////////////*/

#endif //__DX8STYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\audtrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       audtrk.h
//
//--------------------------------------------------------------------------

// AudTrk.h : Declaration of the CAuditionTrack

#ifndef __AUDITIONTRACK_H_
#define __AUDITIONTRACK_H_

#include "Ptrntrk.h"

struct AuditionTrackInfo : public PatternTrackInfo
{
	AuditionTrackInfo();
	AuditionTrackInfo(const AuditionTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd), 
		  m_pPattern(NULL),	
		  m_pdwVariations(NULL),
		  m_dwVariations(0), 
		  m_dwPart(0),
		  m_fByGUID(TRUE)
	{
		memset(&m_guidPart, 0, sizeof(m_guidPart));
		m_dwPatternTag = DMUS_PATTERN_AUDITION;
		if (pInfo && pInfo->m_pPattern)
		{
			m_pPattern = pInfo->m_pPattern->Clone(mtStart, mtEnd, FALSE);
			PatternTrackInfo::InitTrackVariations(m_pPattern);
		}
	}
	~AuditionTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);
	HRESULT InitTrackVariations();

	CDirectMusicPattern*	m_pPattern;		// The audition track's pattern
	DWORD*					m_pdwVariations;	// Variations currently in use (one DWORD per part)
	DWORD					m_dwVariations;	// The variations to use for m_wPart
	DWORD					m_dwPart;		// The part to use m_dwVariations
	GUID	m_guidPart;			// GUID of the  part to play with the selected variations
	BOOL	m_fByGUID;			// true if selecting parts by GUID, false if by PChannel
};

/////////////////////////////////////////////////////////////////////////////
// CAuditionTrack
class CAuditionTrack : 
#ifdef DXAPI
	public IAuditionTrack,
	public IPrivatePatternTrack,
#endif
	public IDirectMusicTrack8,
	public IPersistStream

{
public:
	CAuditionTrack();
	CAuditionTrack(const CAuditionTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CAuditionTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IAuditionTrack
public:
// IDirectMusicTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;


// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

#ifdef DXAPI
// IAuditionTrack methods
HRESULT STDMETHODCALLTYPE CreateSegment(
			IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment);

HRESULT STDMETHODCALLTYPE SetPatternByName(IDirectMusicSegmentState* pSegState, 
                                          WCHAR* wszName,
                                          IDirectMusicStyle* pStyle,
										  DWORD dwPatternType,
										  DWORD* pdwLength);

HRESULT STDMETHODCALLTYPE SetVariation(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart);

// IPrivatePatternTrack Methods
HRESULT STDMETHODCALLTYPE SetPattern(IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength);

HRESULT STDMETHODCALLTYPE SetVariationByGUID(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, REFGUID rguidPart, DWORD dwPChannel);

// obsolete method (dx7)
HRESULT STDMETHODCALLTYPE SetVariation(
			IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, WORD wPart)
{
    DWORD dwPart = (DWORD)wPart;
    return SetVariation(pSegState, dwVariationFlags, dwPart);
}
#endif

// other stuff
HRESULT LoadPattern(IAARIFFStream* pIRiffStream,  MMCKINFO* pckMain, DMStyleStruct* pNewStyle);
HRESULT GetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
	void * pStateData,
	MUSIC_TIME* pmtNext,
    void *pData);

// IAuditionTrack data members
protected:
// new internal play method
HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
			);

	// attributes
    long						m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct AuditionTrackState : public PatternTrackState
{
	AuditionTrackState();
	~AuditionTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime

			);

	virtual DWORD Variations(DirectMusicPartRef& rPartRef, int nPartIndex);

	virtual BOOL PlayAsIs();

	HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, REFGUID rGuidPart, BOOL fByGuid);

	// attributes
	DWORD	m_dwVariation;		// Which variations to play
	DWORD	m_dwPart;			// PCHannel of the part to play with the selected variations
	GUID	m_guidPart;			// GUID of the  part to play with the selected variations
	BOOL	m_fByGUID;			// true if selecting parts by GUID, false if by PChannel
	BOOL	m_fTestVariations;	// Are we testing individual variations?
	BYTE	m_bVariationLock;	// Variation Lock ID of the selected part
	MUSIC_TIME					m_mtSectionOffset;	// Elapsed time in the section (needed to calculate repeats)
};


#endif //__AUDITIONTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\filter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       filter.cpp
//
//--------------------------------------------------------------------------

#include "dmstyle.h"
#include "styletrk.h"
#include "..\shared\miscutil.h"

HRESULT PatternDispatcher::Filter(DWORD dwType)
{
    HRESULT hr = S_OK;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag && !Test(m_aPatterns[i].pPattern, dwType))
        {
            m_aPatterns[i].dwTag = dwType;
        }
    }
    return hr;
}

HRESULT PatternDispatcher::Scan(DWORD dwType)
{
    HRESULT hr = S_OK;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
             Test(m_aPatterns[i].pPattern, dwType);
        }
    }
    return hr;
}

bool PatternDispatcher::Test(CDirectMusicPattern*& rValue, DWORD dwType)
{
    bool fResult = false;
    if (!rValue) return false;
    short nBits = 0;
    switch(dwType)
    {
    case MATCH_RHYTHM_BITS:
        rValue->MatchRhythm(m_pRhythms, (short)m_nPatternLength, nBits);
        if (m_nWinBits == nBits)
        {
            fResult = true;
        }
        break;
    case MATCH_COMMAND_AND_RHYTHM:
        // the best pattern is the longest pattern with the fewest number of bits in its
        // rhythm map, where all bits match the bits in the actual rhythm.
        rValue->MatchRhythm(m_pRhythms, (short)m_nPatternLength, nBits);
        if (nBits &&
            (!m_nWinBits || nBits <= m_nWinBits) &&
            (!m_nPatternLength || (rValue->m_wNumMeasures <= m_nPatternLength)) &&
            (!m_nNextCommand || (rValue->m_wNumMeasures <= m_nNextCommand)) &&
            rValue->MatchCommand(m_pCommands, (short)m_nPatternLength))
        {
            m_nWinBits = nBits;
            fResult = true;
        }
        break;
    case MATCH_COMMAND_FULL:
        if (rValue->MatchCommand(m_pCommands, (short)m_nPatternLength) &&
            (!m_nPatternLength || (rValue->m_wNumMeasures <= m_nPatternLength)) &&
            (!m_nNextCommand || (rValue->m_wNumMeasures <= m_nNextCommand)) )
        {
            fResult = true;
        }
        break;
    case MATCH_COMMAND_PARTIAL:
        if (rValue->MatchCommand(m_pCommands, 1))
        {
            fResult = true;
        }
        break;
    case MATCH_EMBELLISHMENT:
        if (rValue->MatchEmbellishment(m_pCommands[0]))
        {
            fResult = true;
        }
        break;
    case MATCH_GROOVE_LEVEL:
        if (rValue->MatchGrooveLevel(m_pCommands[0]) && rValue->m_wEmbellishment == EMB_NORMAL)
        {
            fResult = true;
        }
        break;
    case MATCH_NEXT_COMMAND:
        if (m_pStyleTrackState)
        {
            MUSIC_TIME mtNextCommand = 0;
            HRESULT hr = S_OK;
            DMUS_COMMAND_PARAM_2 CommandParam;
            BYTE bActualCommand;
            mtNextCommand = rValue->m_wNumMeasures * m_mtMeasureTime;
            if (m_mtNextCommand && mtNextCommand > m_mtNextCommand)
            {
                mtNextCommand = m_mtNextCommand;
            }
            if (m_pStyle && m_pPerformance)
            {
                hr = m_pStyle->GetCommand(
                            m_mtNow + mtNextCommand, 
                            m_mtOffset, 
                            m_pPerformance, 
                            NULL,
                            m_pStyleTrackState->m_dwGroupID,
                            &CommandParam, 
                            bActualCommand);
            }
            if (FAILED(hr) || !m_pStyle || !m_pPerformance)
            {
                //TraceI(2, "Couldn't get a command! hr: %x Now: %d Next Command: %d Offset: %d\n", hr, m_mtNow, mtNextCommand, m_mtOffset);
                IDirectMusicSegment* pSegment = NULL;
                if (SUCCEEDED(m_pStyleTrackState->m_pSegState->GetSegment(&pSegment)))
                {
                    hr = pSegment->GetParam(
                        GUID_CommandParamNext, m_pStyleTrackState->m_dwGroupID, DMUS_SEG_ANYTRACK, 0, NULL, &CommandParam);
                    pSegment->Release();
                }
                if (FAILED(hr))
                {
                    //TraceI(2, "STILL couldn't get a command! hr: %x\n", hr);
                }
                else
                {
                    //TraceI(2, "Got a command using GUID_CommandParamNext.\n", hr);
                }
            }
            if (SUCCEEDED(hr) && rValue->MatchNextCommand(CommandParam))
            {
                //TraceI(2, "Found a match!\n");
                fResult = true;
            }
        }
        break;
    case FIND_LONGEST_PATTERN:
        if (rValue->m_wNumMeasures > m_MaxBars)
        {
            m_MaxBars = rValue->m_wNumMeasures;
        }
        break;
    case COLLECT_LONGEST_PATTERN:
        if (rValue->m_wNumMeasures == m_MaxBars)
        {
            fResult = true;
        }
        break;
    case FIND_LONGEST_TIMESIG:
        {
            DirectMusicTimeSig TimeSig = rValue->TimeSignature(m_pStyle);
            int nLHS = m_MaxNum * TimeSig.m_bBeat;
            int nRHS = m_MaxDenom * TimeSig.m_bBeatsPerMeasure;
            if ((nLHS < nRHS) ||
                (nLHS == nRHS && m_MaxNum < TimeSig.m_bBeatsPerMeasure))
            {
                m_MaxNum = TimeSig.m_bBeatsPerMeasure;
                m_MaxDenom = TimeSig.m_bBeat;
            }
        }
        break;
    case COLLECT_LONGEST_TIMESIG:
        {
            DirectMusicTimeSig TimeSig = rValue->TimeSignature(m_pStyle);
            if (TimeSig.m_bBeatsPerMeasure == m_MaxNum &&
                TimeSig.m_bBeat == m_MaxDenom)
            {
                fResult = true;
            }
        }
        break;
    }
    return fResult;
}

CDirectMusicPattern* PatternDispatcher::RandomSelect()
{
    int nCount = 0, i = 0, n = 0;
    for (i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
            nCount++;
        }
    }
    if (!nCount) return NULL;
    nCount = dm_rand() % nCount;
    for (i = 0; i < m_nPatternCount; i++)
    {
        if (!m_aPatterns[i].dwTag)
        {
            if (n == nCount) break;
            n++;
        }
    }
    if (i >= m_nPatternCount) return NULL;
    return m_aPatterns[i].pPattern;
}

HRESULT PatternDispatcher::FindPattern(CDirectMusicPattern* pSearchPattern, int& rResult)
{
    HRESULT hr = S_FALSE;
    for (int i = 0; i < m_nPatternCount; i++)
    {
        if (m_aPatterns[i].pPattern == pSearchPattern)
        {
            if (!m_aPatterns[i].dwTag)
            {
                hr = S_OK;
                rResult = i;
            }
            break;
        }
    }
    return hr;
}

void PatternDispatcher::SetMeasureTime(MUSIC_TIME mtMeasureTime)
{
    m_mtMeasureTime = mtMeasureTime;
    MUSIC_TIME mtRoundNextCommand = m_mtNextCommand;
    if (m_mtMeasureTime && m_pStyle && m_pStyle->UsingDX8()) // keeps content created under dx7 consistent
    {
        MUSIC_TIME mtMeasureOverun = mtRoundNextCommand % m_mtMeasureTime;
        if (mtMeasureOverun)
        {
            //TraceI(0, "Next command time: %d\n", mtRoundNextCommand);
            mtRoundNextCommand += m_mtMeasureTime - mtMeasureOverun;
            //TraceI(0, "Overun: %d New next command time: %d\n", mtMeasureOverun, mtRoundNextCommand);
        }
    }
    m_nNextCommand = mtMeasureTime ? (mtRoundNextCommand / mtMeasureTime) : 0;  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\filter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       filter.h
//
//--------------------------------------------------------------------------

//
// filter.h
//
#ifndef __FILTER_H__
#define __FILTER_H__

struct CDirectMusicPattern;
struct StyleTrackState;
struct DMStyleStruct;

enum enumPatternFilter
{
	DISPATCH_RESET				= 0,
	MATCH_COMMAND_AND_RHYTHM	= 1,
	MATCH_COMMAND_FULL			= 2,
	MATCH_COMMAND_PARTIAL		= 3,
	MATCH_EMBELLISHMENT			= 4,
	MATCH_GROOVE_LEVEL			= 5,
	MATCH_RHYTHM_BITS			= 6,
	MATCH_NEXT_COMMAND			= 7,
	FIND_LONGEST_PATTERN		= 8,
	FIND_LONGEST_TIMESIG		= 9,
	COLLECT_LONGEST_PATTERN		= 10,
	COLLECT_LONGEST_TIMESIG		= 11,
	RANDOM_ROW					= 12,
	REMOVED						= 0xffffffff
};

struct TaggedPattern
{
	CDirectMusicPattern* pPattern;
	DWORD dwTag;
};

struct PatternDispatcher
{
	PatternDispatcher() :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_nNextCommand(0),
		m_mtNextCommand(0),
		m_mtNow(0),
		m_mtOffset(0),
		m_mtMeasureTime(0),
		m_pStyleTrackState(NULL),
		m_pPerformance(NULL),
		m_pStyle(NULL),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{}

	PatternDispatcher(
		TList<CDirectMusicPattern*>& InList,
		MUSIC_TIME mtNextCommand, 
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		DMStyleStruct* pStyle) :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_mtNextCommand(mtNextCommand),
		m_nNextCommand(0),
		m_mtNow(mtNow),
		m_mtOffset(mtOffset),
		m_mtMeasureTime(0),
		m_pStyleTrackState(pStyleTrackState),
		m_pPerformance(pPerformance),
		m_pStyle(pStyle),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{
		m_nPatternCount = InList.GetCount();
		if (m_nPatternCount)
		{
			m_aPatterns = new TaggedPattern [m_nPatternCount];
		}
		if (m_aPatterns)
		{
			TListItem<CDirectMusicPattern*>* pScan = InList.GetHead();
			for (int i = 0; pScan && i < m_nPatternCount; pScan = pScan->GetNext(), i++)
			{
				m_aPatterns[i].pPattern = pScan->GetItemValue();
				m_aPatterns[i].dwTag = 0;
			}
		}
		else
		{
			m_nPatternCount = 0;
		}
	}

	~PatternDispatcher()
	{
		if (m_aPatterns) delete [] m_aPatterns;
	}

	bool IsEmpty()
	{
		if (m_fIsEmpty) return true;
		bool fResult = true;
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				fResult = false;
				break;
			}
		}
		if (fResult) m_fIsEmpty = true;
		return fResult;
	}

	HRESULT RestoreAllPatterns()
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			m_aPatterns[i].dwTag = 0;
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT RestorePatterns(DWORD dwType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT SetTag(int nIndex, DWORD dwType)
	{
		if (nIndex < m_nPatternCount)
		{
			m_aPatterns[nIndex].dwTag = dwType;
		}
		if (!dwType) m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT ReplacePatterns(DWORD dwType, DWORD dwRemoveType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
			else if (!m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = dwRemoveType;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	CDirectMusicPattern* GetItem(int n)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				if (n == 0) break;
				n--;
			}
		}
		if (i >= m_nPatternCount || m_aPatterns[i].dwTag) return NULL;
		return m_aPatterns[i].pPattern;
	}

	HRESULT Filter(DWORD dwType);

	HRESULT Scan(DWORD dwType);

	bool Test(CDirectMusicPattern*& rValue, DWORD dwType);

	CDirectMusicPattern* RandomSelect();

	HRESULT FindPattern(CDirectMusicPattern* pSearchPattern, int& rResult);

	void ResetRhythms()
	{
		m_nWinBits = 0;
	}

	void ResetMeasures()
	{
		m_MaxBars = 0;
	}

	void ResetTimeSig()
	{
		m_MaxNum = 0;
		m_MaxDenom = 0;
	}

	void SetPatternLength(int nPatternLength)
	{
		m_nPatternLength = nPatternLength;
	}

	void SetMeasureTime(MUSIC_TIME mtMeasureTime);

	void SetCommands(DMUS_COMMAND_PARAM_2* pCommands, DWORD* pRhythms)
	{
		m_pRhythms = pRhythms;
		m_pCommands = pCommands;
	}


	TaggedPattern* m_aPatterns;
	int m_nPatternCount;
	bool m_fIsEmpty;
	DWORD* m_pRhythms;
	DMUS_COMMAND_PARAM_2* m_pCommands;
	int m_nNextCommand;
	MUSIC_TIME m_mtNextCommand;
	MUSIC_TIME m_mtNow;
	MUSIC_TIME m_mtOffset;
	MUSIC_TIME m_mtMeasureTime;
	DMStyleStruct* m_pStyle;
	StyleTrackState* m_pStyleTrackState;
	IDirectMusicPerformance* m_pPerformance;
	int m_nPatternLength;
	int m_nWinBits;
	int m_MaxBars;
	int m_MaxNum;
	int m_MaxDenom;
};

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstydll.cpp ===
//
// dmstydll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as Class Factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "..\shared\oledll.h"

#include <initguid.h>
#include "dmusicip.h"
#include "DMStyleP.h"
#include "dmstyle.h"
#include "dmsect.h"
#include "chordtrk.h"
#include "cmmdtrk.h"
#include "styletrk.h"
#include "motiftrk.h"
#include "audtrk.h"
#include "mutetrk.h"
#include "mgentrk.h"
#include "..\dmband\dmbndtrk.h"
#include "..\shared\Validate.h"
#include "..\shared\dmscriptautguids.h"
#include "..\shared\xcreate.h"

//////////////////////////////////////////////////////////////////////
// Globals

#ifdef DXAPI

// Version information
//
TCHAR g_szStyleFriendlyName[]    = TEXT("DirectMusicStyle");
TCHAR g_szStyleVerIndProgID[]    = TEXT("Microsoft.DirectMusicStyle");
TCHAR g_szStyleProgID[]          = TEXT("Microsoft.DirectMusicStyle.1");

TCHAR g_szSectionFriendlyName[]    = TEXT("DirectMusicSection");
TCHAR g_szSectionVerIndProgID[]    = TEXT("Microsoft.DirectMusicSection");
TCHAR g_szSectionProgID[]          = TEXT("Microsoft.DirectMusicSection.1");

TCHAR g_szChordTrackFriendlyName[]    = TEXT("DirectMusicChordTrack");
TCHAR g_szChordTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordTrack");
TCHAR g_szChordTrackProgID[]          = TEXT("Microsoft.DirectMusicChordTrack.1");

TCHAR g_szCommandTrackFriendlyName[]    = TEXT("DirectMusicCommandTrack");
TCHAR g_szCommandTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicCommandTrack");
TCHAR g_szCommandTrackProgID[]          = TEXT("Microsoft.DirectMusicCommandTrack.1");

TCHAR g_szStyleTrackFriendlyName[]    = TEXT("DirectMusicStyleTrack");
TCHAR g_szStyleTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicStyleTrack");
TCHAR g_szStyleTrackProgID[]          = TEXT("Microsoft.DirectMusicStyleTrack.1");

TCHAR g_szMotifTrackFriendlyName[]    = TEXT("DirectMusicMotifTrack");
TCHAR g_szMotifTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMotifTrack");
TCHAR g_szMotifTrackProgID[]          = TEXT("Microsoft.DirectMusicMotifTrack.1");

TCHAR g_szMuteTrackFriendlyName[]    = TEXT("DirectMusicMuteTrack");
TCHAR g_szMuteTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMuteTrack");
TCHAR g_szMuteTrackProgID[]          = TEXT("Microsoft.DirectMusicMuteTrack.1");

TCHAR g_szAuditionTrackFriendlyName[]    = TEXT("DirectMusicAuditionTrack");
TCHAR g_szAuditionTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicAuditionTrack");
TCHAR g_szAuditionTrackProgID[]          = TEXT("Microsoft.DirectMusicAuditionTrack.1");

TCHAR g_szMelGenTrackFriendlyName[]    = TEXT("DirectMusicMelodyFormulationTrack");
TCHAR g_szMelGenTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMelodyFormulationTrack");
TCHAR g_szMelGenTrackProgID[]          = TEXT("Microsoft.DirectMusicMelodyFormulationTrack.1");

#endif

#ifndef XBOX

// Dll's hModule
//
HMODULE g_hModule = NULL;

#endif

#ifndef XBOX
// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

#else

extern long g_cLock;

#endif

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::QueryInterface

HRESULT __stdcall
CDirectMusicStyleFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicStyleFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::AddRef

ULONG __stdcall
CDirectMusicStyleFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::Release

ULONG __stdcall
CDirectMusicStyleFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::CreateInstance

HRESULT __stdcall
CDirectMusicStyleFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMStyle *pDM;
    
    try
    {
        pDM = new CDMStyle;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleFactory::LockServer

HRESULT __stdcall
CDirectMusicStyleFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicStyleCreate

STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle)
{
    CDirectMusicStyleFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppStyle);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::QueryInterface

HRESULT __stdcall
CDirectMusicSectionFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicSectionFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::AddRef

ULONG __stdcall
CDirectMusicSectionFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::Release

ULONG __stdcall
CDirectMusicSectionFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::CreateInstance

HRESULT __stdcall
CDirectMusicSectionFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMSection *pDM = new CDMSection;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSectionFactory::LockServer

HRESULT __stdcall
CDirectMusicSectionFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSectionCreate

STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection)
{
    CDirectMusicSectionFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppSection);
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicStyleTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicStyleTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::AddRef

ULONG __stdcall
CDirectMusicStyleTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::Release

ULONG __stdcall
CDirectMusicStyleTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicStyleTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CStyleTrack *pDM;
    
    try
    {
        pDM = new CStyleTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStyleTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicStyleTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicStyleTrackCreate

STDAPI DirectMusicStyleTrackCreate(REFIID iid, void ** ppDMT )
{
    CDirectMusicStyleTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicCommandTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicCommandTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::AddRef

ULONG __stdcall
CDirectMusicCommandTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::Release

ULONG __stdcall
CDirectMusicCommandTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicCommandTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CCommandTrack *pDM;
    try
    {
        pDM = new CCommandTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCommandTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicCommandTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicCommandTrackCreate

STDAPI DirectMusicCommandTrackCreate(REFIID iid, void ** ppDMT )

{
    CDirectMusicCommandTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicChordTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicChordTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::AddRef

ULONG __stdcall
CDirectMusicChordTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::Release

ULONG __stdcall
CDirectMusicChordTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicChordTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CChordTrack *pDM;
    
    try
    {
        pDM = new CChordTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicChordTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicChordTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicChordTrackCreate

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT )
{
    CDirectMusicChordTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}

///////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMotifTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMotifTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMotifTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::Release

ULONG __stdcall
CDirectMusicMotifTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMotifTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMotifTrack *pDM;
    
    try
    {
        pDM = new CMotifTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMotifTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMotifTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicMotifTrackCreate

STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT )
{
    CDirectMusicMotifTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMuteTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMuteTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMuteTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::Release

ULONG __stdcall
CDirectMusicMuteTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMuteTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMuteTrack *pDM;
    
    try
    {
        pDM = new CMuteTrack;
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMuteTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMuteTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicMuteTrackCreate (using CDirectMusicMuteTrackFactory)

STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT )
{
    CDirectMusicMuteTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}

/////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicAuditionTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::AddRef

ULONG __stdcall
CDirectMusicAuditionTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::Release

ULONG __stdcall
CDirectMusicAuditionTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CAuditionTrack *pDM;
    
    try
    {
        pDM = new CAuditionTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicAuditionTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicAuditionTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicPatternTrackCreate (using CDirectMusicAuditionTrackFactory)

STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT )
{
    CDirectMusicAuditionTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicMelodyFormulationTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::AddRef

ULONG __stdcall
CDirectMusicMelodyFormulationTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::Release

ULONG __stdcall
CDirectMusicMelodyFormulationTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CMelodyFormulationTrack *pDM;

    try
    {
        pDM = new CMelodyFormulationTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicMelodyFormulationTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicMelodyFormulationTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicMelodyFormulationTrackCreate

STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT )
{
    CDirectMusicMelodyFormulationTrackFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMT);
}


#ifndef XBOX

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusicStyle)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicStyleFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DMSection) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicSectionFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicChordTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicChordTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicCommandTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicCommandTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicStyleTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicStyleTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMotifTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMotifTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMuteTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMuteTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicAuditionTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicAuditionTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicMelodyFormulationTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicMelodyFormulationTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicStyle,
                     g_szStyleFriendlyName,
                     g_szStyleVerIndProgID,
                     g_szStyleProgID);

    UnregisterServer(CLSID_DMSection,
                     g_szSectionFriendlyName,
                     g_szSectionVerIndProgID,
                     g_szSectionProgID);

    UnregisterServer(CLSID_DirectMusicChordTrack,
                     g_szChordTrackFriendlyName,
                     g_szChordTrackVerIndProgID,
                     g_szChordTrackProgID);

    UnregisterServer(CLSID_DirectMusicCommandTrack,
                     g_szCommandTrackFriendlyName,
                     g_szCommandTrackVerIndProgID,
                     g_szCommandTrackProgID);

    UnregisterServer(CLSID_DirectMusicStyleTrack,
                     g_szStyleTrackFriendlyName,
                     g_szStyleTrackVerIndProgID,
                     g_szStyleTrackProgID);

    UnregisterServer(CLSID_DirectMusicMotifTrack,
                     g_szMotifTrackFriendlyName,
                     g_szMotifTrackVerIndProgID,
                     g_szMotifTrackProgID);

    UnregisterServer(CLSID_DirectMusicMuteTrack,
                     g_szMuteTrackFriendlyName,
                     g_szMuteTrackVerIndProgID,
                     g_szMuteTrackProgID);

    UnregisterServer(CLSID_DirectMusicAuditionTrack,
                     g_szAuditionTrackFriendlyName,
                     g_szAuditionTrackVerIndProgID,
                     g_szAuditionTrackProgID);

	UnregisterServer(CLSID_DirectMusicMelodyFormulationTrack,
                     g_szMelGenTrackFriendlyName,
                     g_szMelGenTrackVerIndProgID,
                     g_szMelGenTrackProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicStyle,
                     g_szStyleFriendlyName,
                     g_szStyleVerIndProgID,
                     g_szStyleProgID);

    RegisterServer(g_hModule,
                   CLSID_DMSection,
                     g_szSectionFriendlyName,
                     g_szSectionVerIndProgID,
                     g_szSectionProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordTrack,
                     g_szChordTrackFriendlyName,
                     g_szChordTrackVerIndProgID,
                     g_szChordTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicCommandTrack,
                     g_szCommandTrackFriendlyName,
                     g_szCommandTrackVerIndProgID,
                     g_szCommandTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicStyleTrack,
                     g_szStyleTrackFriendlyName,
                     g_szStyleTrackVerIndProgID,
                     g_szStyleTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMotifTrack,
                     g_szMotifTrackFriendlyName,
                     g_szMotifTrackVerIndProgID,
                     g_szMotifTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMuteTrack,
                     g_szMuteTrackFriendlyName,
                     g_szMuteTrackVerIndProgID,
                     g_szMuteTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicAuditionTrack,
                     g_szAuditionTrackFriendlyName,
                     g_szAuditionTrackVerIndProgID,
                     g_szAuditionTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicMelodyFormulationTrack,
                     g_szMelGenTrackFriendlyName,
                     g_szMelGenTrackVerIndProgID,
                     g_szMelGenTrackProgID);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

            }
			break;


#ifdef DBG
        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
#endif
            
    }
        
    return TRUE;
}

#endif // !XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\cmmdtrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cmmdtrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// CommandTrack.cpp : Implementation of CCommandTrack
#ifdef XBOX
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif

#include <objbase.h>
#include "CmmdTrk.h"
#include "debug.h"
#include "..\shared\critsec.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CCommandTrack

CCommandTrack::CCommandTrack() : m_bRequiresSave(0),
    m_cRef(1), m_fNotifyCommand(FALSE), m_fCSInitialized(FALSE), m_pNextCommand(NULL)

{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// it is assumed that cloning of commands will only happen on measure boundaries
CCommandTrack::CCommandTrack(const CCommandTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_bRequiresSave(0),
    m_cRef(1), m_fNotifyCommand(rTrack.m_fNotifyCommand),
    m_fCSInitialized(FALSE), m_pNextCommand(NULL)

{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    WORD wMeasure = 0;
    BOOL fStarted = FALSE;
    TListItem<DMCommand>* pScan = rTrack.m_CommandList.GetHead();
    TListItem<DMCommand>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMCommand& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
            if (pNew)
            {
                DMCommand& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_bBeat = rScan.m_bBeat;
                rNew.m_bCommand = rScan.m_bCommand;
                rNew.m_bGrooveLevel = rScan.m_bGrooveLevel;
                rNew.m_bGrooveRange = rScan.m_bGrooveRange;
                rNew.m_bRepeatMode = rScan.m_bRepeatMode;
                m_CommandList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
        if (pNew)
        {
            DMCommand& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_bBeat = 0;
            // Since embellishments are only supposed to last for a bar,
            // start the new segment with a regular groove.
            rNew.m_bCommand = DMUS_COMMANDT_GROOVE;
            // Keep the groove level and range of the previous bar.
            rNew.m_bGrooveLevel = pPrevious->GetItemValue().m_bGrooveLevel;
            rNew.m_bGrooveRange = pPrevious->GetItemValue().m_bGrooveRange;
            // Default to random selection of the pattern.
            rNew.m_bRepeatMode = DMUS_PATTERNT_RANDOM;
            m_CommandList.AddHead(pNew);
        }
    }
}

CCommandTrack::~CCommandTrack()
{
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    if (m_pNextCommand)
    {
        delete m_pNextCommand;
    }
    DecrementDLLCount();
}

void CCommandTrack::Clear()
{
    m_CommandList.CleanUp();
}


STDMETHODIMP CCommandTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CCommandTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CCommandTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CCommandTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CCommandTrack Methods
HRESULT CCommandTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    V_INAME(CCommandTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

HRESULT CCommandTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    HRESULT hr = S_OK;
    CommandStateData* pStateData;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    pStateData = new CommandStateData;
    if( NULL == pStateData )
    {
        hr =  E_OUTOFMEMORY;
    }
    else
    {
        *pStateData = 0;
        *ppStateData = pStateData;
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(CommandStateData));
        CommandStateData* pSD = (CommandStateData*)pStateData;
        delete pSD;
    }
    if (m_pNextCommand) delete m_pNextCommand;
    m_pNextCommand = NULL;
    return S_OK;
}

HRESULT CCommandTrack::SendNotification(DWORD dwCommand, 
                                        MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }
    IDirectMusicSegment* pSegment = NULL;
    DWORD dwOption = DMUS_NOTIFICATION_GROOVE;
    if (dwCommand != DMUS_COMMANDT_GROOVE)
    {
        dwOption = DMUS_NOTIFICATION_EMBELLISHMENT;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = dwOption;
        pEvent->guidNotificationType = GUID_NOTIFICATION_COMMAND;

        if( SUCCEEDED( pSegState->GetSegment(&pSegment)))
        {
            if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
            {
                pEvent->dwGroupID = 0xffffffff;
            }
            pSegment->Release();
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}


HRESULT CCommandTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fNotifyPastCommand = false;
    TListItem<DMCommand>* pLastCommand = NULL;
    // If we're seeking and not flushing, we need to notify for the command that happens
    // before the current start time (if there is one)
    if ( (dwFlags & DMUS_TRACKF_SEEK) && !(dwFlags & DMUS_TRACKF_FLUSH) )
    {
        fNotifyPastCommand = true;
    }
    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_fNotifyCommand)
    {
        TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
        for(; pCommand && SUCCEEDED(hr); pCommand = pCommand->GetNext())
        {
            MUSIC_TIME mtCommandTime = pCommand->GetItemValue().m_mtTime;
            if (mtCommandTime < mtStart && fNotifyPastCommand)
            {
                pLastCommand = pCommand;
            }
            else if (mtStart <= mtCommandTime && mtCommandTime < mtEnd)
            {
                if (pLastCommand)
                {
                    hr = SendNotification(pLastCommand->GetItemValue().m_bCommand, 
                            mtStart + mtOffset, pPerf, pSegState, dwFlags);
                    pLastCommand = NULL;
                }
                if (SUCCEEDED(hr))
                {
                    hr = SendNotification(pCommand->GetItemValue().m_bCommand, 
                            mtCommandTime + mtOffset, pPerf, pSegState, dwFlags);
                }
            }
            else if (mtCommandTime >= mtEnd)
            {
                if (pLastCommand)
                {
                    hr = SendNotification(pLastCommand->GetItemValue().m_bCommand, 
                            mtStart + mtOffset, pPerf, pSegState, dwFlags);
                }
                break;
            }
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

// Returns the Command in effect at the measure containing mtTime.
HRESULT CCommandTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(CCommandTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if (rCommandGuid == GUID_CommandParam2)
    {
        return GetParam2(mtTime, pmtNext, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid == GUID_CommandParamNext)
    {
        return GetParamNext(mtTime, pmtNext, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid != GUID_CommandParam)
    {
        return DMUS_E_GET_UNSUPPORTED;
    }

    HRESULT hr = S_OK;
    if (pData) // Something got passed in 
    {
        ENTER_CRITICAL_SECTION( &m_CriticalSection );
        DMUS_COMMAND_PARAM* pCommandParam = (DMUS_COMMAND_PARAM*) pData;
        // Default to the old groove C
        BYTE bCommand = DMUS_COMMANDT_GROOVE;
        BYTE bGrooveLevel = 62;
        BYTE bGrooveRange = 0;
        BYTE bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<DMCommand>* pNext = m_CommandList.GetHead();
        const int epsilon = DMUS_PPQ / 16; // leave a 64th note on either side...
        for( ; pNext; pNext = pNext->GetNext())
        {
            if ( abs(pNext->GetItemValue().m_mtTime - mtTime) < epsilon ) //  this is it
            {
                bCommand = pNext->GetItemValue().m_bCommand;
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
                pNext = pNext->GetNext();
                break;
            }
            else if (pNext->GetItemValue().m_mtTime < mtTime) // may be it, but we need a next time
            {
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
            }
            else // passed it
            {
                break;
            }
        }
        hr = S_OK;
        pCommandParam->bCommand = bCommand;
        pCommandParam->bGrooveLevel = bGrooveLevel;
        pCommandParam->bGrooveRange = bGrooveRange;
        pCommandParam->bRepeatMode = bRepeatMode;
        if (pmtNext)
        {
            if (pNext)
            {
                *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
            }
            else
            {
                MUSIC_TIME mtLength = 0;
                *pmtNext = mtLength;
            }
        }
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::GetParam2( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    //TraceI(0, "GetParam time: %d\n", mtTime);
    HRESULT hr = S_OK;
    if (pCommandParam) // Something got passed in 
    {
        ENTER_CRITICAL_SECTION( &m_CriticalSection );
        // Default to the old groove C
        MUSIC_TIME mtCommandTime = 0;
        BYTE bCommand = DMUS_COMMANDT_GROOVE;
        BYTE bGrooveLevel = 62;
        BYTE bGrooveRange = 0;
        BYTE bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<DMCommand>* pNext = m_CommandList.GetHead();
        for( ; pNext; pNext = pNext->GetNext())
        {
            if (pNext->GetItemValue().m_mtTime <= mtTime) // may be it, but we need a next time
            {
                mtCommandTime = pNext->GetItemValue().m_mtTime - mtTime;
                bCommand = pNext->GetItemValue().m_bCommand;
                bGrooveLevel = pNext->GetItemValue().m_bGrooveLevel;
                bGrooveRange = pNext->GetItemValue().m_bGrooveRange;
                bRepeatMode = pNext->GetItemValue().m_bRepeatMode;
            }
            else // passed it
            {
                break;
            }
        }
        hr = S_OK;
        pCommandParam->mtTime = mtCommandTime;
        pCommandParam->bCommand = bCommand;
        pCommandParam->bGrooveLevel = bGrooveLevel;
        pCommandParam->bGrooveRange = bGrooveRange;
        pCommandParam->bRepeatMode = bRepeatMode;
        if (pmtNext)
        {
            if (pNext)
            {
                *pmtNext = pNext->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
            }
            else
            {
                *pmtNext = 0;
            }
        }
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::GetParamNext( 
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    HRESULT hr = S_OK;
    if (pCommandParam) // Something got passed in 
    {
        ENTER_CRITICAL_SECTION( &m_CriticalSection );
        if (m_pNextCommand)
        {
            *pCommandParam = *m_pNextCommand;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
            /*// Default to the old groove C
            pCommandParam->bCommand = DMUS_COMMANDT_GROOVE;
            pCommandParam->bGrooveLevel = 62;
            pCommandParam->bGrooveRange = 0;*/
        }
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
} 

HRESULT CCommandTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CCommandTrack::SetParam);
    V_REFGUID(rCommandGuid);

    if (rCommandGuid == GUID_CommandParamNext)
    {
        return SetParamNext(mtTime, (DMUS_COMMAND_PARAM_2*) pData);
    }
    else if (rCommandGuid != GUID_CommandParam)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    HRESULT hr = S_OK;
    if (pData) // Something got passed in 
    {
        ENTER_CRITICAL_SECTION( &m_CriticalSection );
        DMUS_COMMAND_PARAM* pCommandParam = (DMUS_COMMAND_PARAM*) pData;
        //DirectMusicTimeSig TimeSig = ((CommandData *)(pData))->m_TimeSig;
        //WORD wMeasure = ClocksToMeasure(mtTime, TimeSig);
        TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
        TListItem<DMCommand>* pPrevious = NULL;
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DMCommand& rNew = pNew->GetItemValue();
            rNew.m_mtTime = mtTime;
            rNew.m_bBeat = 0;
            rNew.m_bCommand = pCommandParam->bCommand;
            rNew.m_bGrooveLevel = pCommandParam->bGrooveLevel;
            rNew.m_bGrooveRange = pCommandParam->bGrooveRange;
            rNew.m_bRepeatMode = pCommandParam->bRepeatMode;
            for (; pCommand != NULL; pCommand = pCommand->GetNext())
            {
                DMCommand& rCommand = pCommand->GetItemValue();
                if (rCommand.m_mtTime >= mtTime) break;
                pPrevious = pCommand;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pCommand);
            }
            else // pCommand is current head of list
            {
                m_CommandList.AddHead(pNew);
            }
            if (pCommand && pCommand->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                pNew->SetNext(pCommand->GetNext());
                pCommand->SetNext(NULL);
                delete pCommand;
            }
            hr = S_OK;
        }
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    else 
        return E_POINTER;
}

HRESULT CCommandTrack::SetParamNext( 
    MUSIC_TIME mtTime,
    DMUS_COMMAND_PARAM_2* pCommandParam)
{
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pNextCommand)
    {
        delete m_pNextCommand;
        m_pNextCommand = NULL;
    }
    if (pCommandParam)
    {
        m_pNextCommand = new DMUS_COMMAND_PARAM_2;
        if (!m_pNextCommand)
        {
            LEAVE_CRITICAL_SECTION( &m_CriticalSection );
            return E_OUTOFMEMORY;
        }
        *m_pNextCommand = *pCommandParam;
    }
    // Otherwise, allow a null pCommandParam to act as a reset.
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return S_OK;
} 

// IPersist methods
 HRESULT CCommandTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CCommandTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicCommandTrack;
    return S_OK;
}

HRESULT CCommandTrack::IsParamSupported(
                /*[in]*/ REFGUID    rGuid
            )
{
    V_INAME(CCommandTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_CommandParam || 
        rGuid == GUID_CommandParam2 || 
        rGuid == GUID_CommandParamNext)
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

// IPersistStream methods
 HRESULT CCommandTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CCommandTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CCommandTrack::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF ;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<DMCommand>* pCommand;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF  );
    if (!SUCCEEDED(hr))
    {
        goto ON_END;
    }
    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pCommand = m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            DMCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = rCommand.m_mtTime;
            iCommand.wMeasure = rCommand.m_wMeasure;
            iCommand.bBeat = rCommand.m_bBeat;
            iCommand.bCommand = rCommand.m_bCommand;
            iCommand.bGrooveLevel = rCommand.m_bGrooveLevel;
            iCommand.bGrooveRange = rCommand.m_bGrooveRange;
            iCommand.bRepeatMode = rCommand.m_bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CCommandTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Greater(DMCommand& Command1, DMCommand& Command2)
{ return Command1.m_wMeasure > Command2.m_wMeasure; }

BOOL Less(DMCommand& Command1, DMCommand& Command2)
{ return Command1.m_wMeasure < Command2.m_wMeasure; }

HRESULT CCommandTrack::Load(LPSTREAM pStream )
{
    V_INAME(CCommandTrack::Load);
    V_INTERFACE(pStream);

    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    MMCKINFO        ck;
    IAARIFFStream*  pRIFF;
//    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DMUS_IO_COMMAND     iCommand;
    DWORD dwPos;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    ck.ckid = FOURCC_COMMAND;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
    {
        lFileSize = ck.cksize;
        hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMCommand>* pCommand;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pCommand = new TListItem<DMCommand>;
                    if( pCommand )
                    {
                        DMCommand& rCommand = pCommand->GetItemValue();
                        if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                        {
                            pStream->Read( &iCommand, dwNodeSize, NULL );
                        }
                        else
                        {
                            pStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                            StreamSeek( pStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                        }
                        memset( &rCommand, 0, sizeof( rCommand ) );
                        rCommand.m_mtTime = iCommand.mtTime;
                        rCommand.m_wMeasure = iCommand.wMeasure;
                        rCommand.m_bBeat = iCommand.bBeat;
                        rCommand.m_bCommand = iCommand.bCommand;
                        rCommand.m_bGrooveLevel = iCommand.bGrooveLevel;
                        if( iCommand.bGrooveRange > 100 )
                        {
                            Trace(1, "Warning: Illegal value %d read for Command's groove range.\n", iCommand.bGrooveRange);
                            rCommand.m_bGrooveRange = 0;
                        }
                        else
                        {
                            rCommand.m_bGrooveRange = iCommand.bGrooveRange;
                        }
                        if( iCommand.bRepeatMode > DMUS_PATTERNT_RANDOM_ROW )
                        {
                            Trace(1, "Warning: Illegal value %d read for Command's repeat mode.\n", iCommand.bRepeatMode);
                            rCommand.m_bRepeatMode = 0;
                        }
                        else
                        {
                            rCommand.m_bRepeatMode = iCommand.bRepeatMode;
                        }
                        m_CommandList.AddTail(pCommand);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
            m_CommandList.MergeSort(Less);
            BYTE bLastGrooveLevel = 62;
            TListItem<DMCommand>* pCommand = m_CommandList.GetHead();
            for(; pCommand != NULL; pCommand = pCommand->GetNext())
            {
                if (!pCommand->GetItemValue().m_bGrooveLevel)
                {
                    pCommand->GetItemValue().m_bGrooveLevel = bLastGrooveLevel;
                }
                else
                {
                    bLastGrooveLevel = pCommand->GetItemValue().m_bGrooveLevel;
                }
            }
        }
        pRIFF->Release();
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CCommandTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CCommandTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_COMMAND )
    {
        m_fNotifyCommand = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CCommandTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CCommandTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_COMMAND )
    {
        m_fNotifyCommand = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CCommandTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CCommandTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CCommandTrack *pDM;
    try
    {
        pDM = new CCommandTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CCommandTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CCommandTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CCommandTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    TList<DMCommand> ResultList;
    CCommandTrack* pResultTrack = NULL;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CCommandTrack*)*ppResultTrack;
        while(!pResultTrack->m_CommandList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_CommandList.RemoveHead());
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_CommandList.IsEmpty() && 
              m_CommandList.GetHead()->GetItemValue().m_mtTime < mtJoin)
        {
            ResultList.AddHead(m_CommandList.RemoveHead());
        }
        m_CommandList.CleanUp();
    }
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            DirectMusicTimeSig DMTimeSig = TimeSig;
            WORD wMeasureOffset = (WORD)DMTimeSig.ClocksToMeasure(mtNext + mtOver);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CCommandTrack* pOtherTrack = (CCommandTrack*)pNewTrack;
    TListItem<DMCommand>* pScan = pOtherTrack->m_CommandList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMCommand>* pNew = new TListItem<DMCommand>(pScan->GetItemValue());
        if (pNew)
        {
            pNew->GetItemValue().m_mtTime += mtJoin;
            pNew->GetItemValue().m_wMeasure += wMeasure;
            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_CommandList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_CommandList.AddHead(ResultList.RemoveHead());
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstyle.h ===
// DMStyle.h : Declaration of the CDMStyle
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMSTYLE_H_
#define __DMSTYLE_H_


#include "dmusicip.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "alist.h"
#include "dmstylep.h"
#include "filter.h"
#include "..\shared\dmusicp.h"

#include "timesig.h"

#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;
const int MAX_VARIATION_LOCKS = 255;  // max number of variation lock ids

extern DirectMusicTimeSig DefaultTimeSig;

struct CompositionFragment;
struct StyleTrackState;

#define EMB_NORMAL	0
#define EMB_FILL	1
#define EMB_BREAK	2
#define EMB_INTRO	4
#define EMB_END		8
#define EMB_MOTIF	16
// User-defined embellishments live in the high byte of the embellishment word
#define EMB_USER_DEFINED	0xff00

// #defines to replace need for dynamic casts
#define DMUS_EVENT_NOTE				1
#define DMUS_EVENT_CURVE			2
#define DMUS_EVENT_MARKER			3
#define DMUS_EVENT_ANTICIPATION		4

// Curve flip flags
#define CURVE_FLIPTIME	1
#define CURVE_FLIPVALUE	2

#define STYLEF_USING_DX8 1

struct DirectMusicPart;
struct DirectMusicPartRef;
class CDMStyle;
struct DMStyleStruct;
struct CDirectMusicPattern;

struct CDirectMusicEventItem : public AListItem
{
//friend class CDirectMusicPattern;
//public:
	CDirectMusicEventItem* MergeSort(DirectMusicTimeSig& TimeSig); 
//protected:
	void Divide(CDirectMusicEventItem* &pHalf1, CDirectMusicEventItem* &pHalf2);
	CDirectMusicEventItem* Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig);
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) AListItem::GetNext(); }
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
										DWORD* pdwVariation = NULL, 
										DWORD* pdwID = NULL, 
										WORD* pwMusic = NULL, 
										BYTE* pbPlaymode = NULL,
                                        BYTE* pbFlags = NULL);

//protected:
	short		m_nGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	DWORD		m_dwEventTag;		// what type of event this is (note, curve, ...)
};

struct CDirectMusicEventList : public AList
{
//public:
	~CDirectMusicEventList();
    CDirectMusicEventItem *GetHead() { return (CDirectMusicEventItem *)AList::GetHead();};
    CDirectMusicEventItem *RemoveHead() { return (CDirectMusicEventItem *)AList::RemoveHead();};
	void MergeSort(DirectMusicTimeSig& TimeSig); // Destructively mergeSorts the list
};

struct CDMStyleNote : public CDirectMusicEventItem
{
//friend class CDirectMusicPattern;
//public:
	CDMStyleNote() : m_bPlayModeFlags(0), m_bFlags(0), m_dwFragmentID(0)
	{
		m_dwEventTag = DMUS_EVENT_NOTE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
									    DWORD* pdwVariation, 
										DWORD* pdwID, 
										WORD* pwMusic, 
										BYTE* pbPlaymode,
                                        BYTE* pbFlags);
//protected:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	DWORD		m_dwFragmentID;		// for melody formulation, the fragment this note came from
	BYTE		m_bFlags;			// values from DMUS_NOTEF_FLAGS
};

struct CDMStyleCurve : public CDirectMusicEventItem
{
	CDMStyleCurve()
	{
		m_dwEventTag = DMUS_EVENT_CURVE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, short nOffset);
	MUSIC_TIME	m_mtDuration;	// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset it
	short		m_StartValue;	// curve's start value
	short		m_EndValue;		// curve's end value
	short		m_nResetValue;	// curve's reset value
    BYTE		m_bEventType;	// type of curve
	BYTE		m_bCurveShape;	// shape of curve
	BYTE		m_bCCData;		// CC#
	BYTE		m_bFlags;		// flags. Bit 1=TRUE means to send the reset value. Other bits reserved.
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
};

struct CDMStyleMarker : public CDirectMusicEventItem
{
	CDMStyleMarker()
	{
		m_dwEventTag = DMUS_EVENT_MARKER;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
	WORD	m_wFlags;		// flags for how to interpret this marker.
};

struct CDMStyleAnticipation : public CDirectMusicEventItem
{
	CDMStyleAnticipation()
	{
		m_dwEventTag = DMUS_EVENT_ANTICIPATION;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
    BYTE		m_bTimeRange;		// Range to randomize start time.
};

struct Marker
{
	MUSIC_TIME	mtTime;
	WORD		wFlags;
};

struct DirectMusicPart
{
	DirectMusicPart(DirectMusicTimeSig *pTimeSig = NULL);
	~DirectMusicPart() { }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	HRESULT DM_LoadPart(  
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );
	HRESULT DM_SavePart( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveNoteList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveCurveList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveMarkerList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveAnticipationList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveResolutionList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern );
	HRESULT GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult);
	bool IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord);
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern ); 

	long m_cRef;
	GUID							m_guidPartID;
	DirectMusicTimeSig				m_timeSig;			// can override pattern's
	WORD							m_wNumMeasures;		// length of the Part
	DWORD							m_dwVariationChoices[32];	// MOAW choices bitfield
	BYTE							m_bPlayModeFlags;	// see PLAYMODE flags (in ioDMStyle.h)
	BYTE							m_bInvertUpper;		// inversion upper limit
	BYTE							m_bInvertLower;		// inversion lower limit
	DWORD							m_dwFlags;   		// various flags
	CDirectMusicEventList			EventList;			// list of events (notes, curves, etc.)
	TList<Marker>					m_StartTimes[32];	// Array of start time lists (1 per variation)
	TList<DMUS_IO_STYLERESOLUTION>	m_ResolutionList;	// list of variation resolutions
};

struct InversionGroup 
{
	// Inversion groups are used for keeping track of groups of notes to be played
	// without inversion
	WORD		m_wGroupID;	// Group this represents.
	WORD		m_wCount;	// How many are in the group, still waiting to be played.
	short		m_nOffset;	// Number to add to all notes for offsetting.
};

const short INVERSIONGROUPLIMIT = 16;

short FindGroup(InversionGroup aGroup[], WORD wID);
short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short m_nOffset);

struct PatternTrackState;

struct DirectMusicPartRef
{
	DirectMusicPartRef() : 
		m_bPriority(100), 
		m_pDMPart(NULL), 
		m_bVariationLockID(0), 
		//m_wLogicalPartID(LOGICAL_PART_PIANO),
		m_bSubChordLevel(SUBCHORD_STANDARD_CHORD)
	{  }
	~DirectMusicPartRef() { if (m_pDMPart) m_pDMPart->Release(); }
	HRESULT DM_LoadPartRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle);
	HRESULT DM_SavePartRef( IAARIFFStream* pIRiffStream );
	void SetPart( DirectMusicPart* pPart );

	HRESULT ConvertMusicValue(CDMStyleNote* pNoteEvent, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlaymode,
							  BOOL fPlayAsIs,
							  InversionGroup aInversionGroups[],
							  IDirectMusicPerformance* pPerformance,
							  BYTE& rbMidiValue,
							  short& rnMidiOffset);
	HRESULT ConvertMIDIValue(BYTE bMIDI, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlayModeFlags,
							  IDirectMusicPerformance* pPerformance,
							  WORD& rwMusicValue);

	DirectMusicPart* m_pDMPart; // the Part to which this refers
	DWORD	m_dwLogicalPartID;	// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;		// Determines order in which variations are played.
};

#define COMPUTE_VARIATIONSF_USE_MASK	0x1
#define COMPUTE_VARIATIONSF_NEW_PATTERN	0x2
#define COMPUTE_VARIATIONSF_CHORD_ALIGN	0x4
#define COMPUTE_VARIATIONSF_MARKER		0x8
#define COMPUTE_VARIATIONSF_START		0x10
#define COMPUTE_VARIATIONSF_DX8			0x20
#define COMPUTE_VARIATIONSF_CHANGED		0x40

struct CDirectMusicPattern
{
friend class CDMStyle;
//public:
	CDirectMusicPattern( DirectMusicTimeSig* pTimeSig = NULL, BOOL fMotif = FALSE );
	~CDirectMusicPattern() { CleanUp(); }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	CDirectMusicPattern* Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif);
	void CleanUp();
	HRESULT DM_LoadPattern(
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );

	HRESULT LoadPattern(
		IAARIFFStream* pRIFF, 
		MMCKINFO* pckMain,
		TList<DirectMusicPart*> &partList,
		DMStyleStruct& rStyleStruct
	);
	HRESULT AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem);
	void DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem);
	void DMusMoawFlags(MUSIC_TIME mtTime, 
					   MUSIC_TIME mtNextChord,
					   DMUS_CHORD_PARAM& rCurrentChord, 
					   DMUS_CHORD_PARAM& rNextChord,
					   bool fIsDX8,
					   DWORD& dwNaturals,
					   DWORD& dwSharps,
					   DWORD& dwFlats);
	DWORD IMA25MoawFlags(MUSIC_TIME mtTime, 
						 MUSIC_TIME mtNextChord,
						 DMUS_CHORD_PARAM& rCurrentChord,
						 DMUS_CHORD_PARAM& rNextChord);
	HRESULT ComputeVariations(DWORD dwFlags,
							  DMUS_CHORD_PARAM& rCurrentChord, 
							  DMUS_CHORD_PARAM& rNextChord,
							  BYTE abVariationGroups[],
							  DWORD adwVariationMask[],
							  DWORD adwRemoveVariations[],
							  BYTE abVariation[],
							  MUSIC_TIME mtTime,
							  MUSIC_TIME mtNextChord,
							  PatternTrackState* pState = NULL);
	HRESULT ComputeVariationGroup(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	HRESULT ComputeVariation(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	BOOL MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength);
	void MatchRhythm(DWORD pRhythms[], short nPatternLength, short& nBits);
	BOOL MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand);

	HRESULT LoadEvents(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadNoteList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	HRESULT LoadCurveList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	DirectMusicPart* FindPart(BYTE bChannelID);
	TListItem<DirectMusicPartRef>* FindPartRefByPChannel(DWORD dwPChannel);
	TListItem<DirectMusicPartRef>* CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures = 1 );
	HRESULT Save( IStream* pIStream );
	HRESULT DM_SaveSinglePattern( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternChunk( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternRhythm( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternInfoList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle );
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle ); 

    long				m_cRef;
	String				m_strName;			// pattern name
	DirectMusicTimeSig	m_timeSig;			// Patterns can override the Style's Time sig.
	WORD				m_wID;				// ID to identify for pattern playback (instead of name)
	BYTE				m_bGrooveBottom;	// bottom of groove range
	BYTE				m_bGrooveTop;		// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of groove range for next pattern
	BYTE				m_bDestGrooveTop;		// top of groove range for next pattern
	WORD				m_wEmbellishment;	// Fill, Break, Intro, End, Normal, Motif
	WORD				m_wNumMeasures;		// length in measures
	DWORD*				m_pRhythmMap;		// variable array of rhythms for chord matching
	TList<DirectMusicPartRef> m_PartRefList;	// list of part references
	//////// motif settings:
	BOOL		m_fSettings;	  // Have these been set?
	DWORD       m_dwRepeats;      // Number of repeats. By default, 0.
    MUSIC_TIME  m_mtPlayStart;    // Start of playback. By default, 0.
    MUSIC_TIME  m_mtLoopStart;    // Start of looping portion. By default, 0.
    MUSIC_TIME  m_mtLoopEnd;      // End of loop. Must be greater than dwPlayStart. By default equal to length of motif.
    DWORD       m_dwResolution;   // Default resolution.
	//////// motif band:
	IDirectMusicBand*	m_pMotifBand;
	TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this pattern
	DWORD		m_dwFlags;		// various flags 
};

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel);

struct DMStyleStruct
{
	DirectMusicPart* AllocPart(  );
	void DeletePart( DirectMusicPart* pPart );

	HRESULT GetCommand(
		MUSIC_TIME mtTime, 
		MUSIC_TIME mtOffset, 
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		DWORD dwGroupID,
		DMUS_COMMAND_PARAM_2* pCommand,
		BYTE& rbActualCommand);

	DirectMusicPart* FindPartByGUID( GUID guidPartID );
	DirectMusicTimeSig& TimeSignature() { return m_TimeSignature; }
	bool UsingDX8() { return (m_dwFlags & STYLEF_USING_DX8) ? true : false; }

	CDirectMusicPattern* SelectPattern(bool fNewMode, 
								   DMUS_COMMAND_PARAM_2* pCommands, 
								   StyleTrackState* StyleTrackState, 
								   PatternDispatcher& rDispatcher);

	HRESULT GetPattern(
		bool fNewMode,
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		CDirectMusicPattern*& rpTargetPattern,
		MUSIC_TIME& rmtMeasureTime, 
		MUSIC_TIME& rmtNextCommand);


	bool				m_fLoaded;				// is the style loaded in memory?
    GUID				m_guid;					// the style's GUID
    String				m_strCategory;			// Describes musical category of style
	String				m_strName;				// style name
	DWORD				m_dwVersionMS;			// Version # high-order 32 bits
	DWORD				m_dwVersionLS;			// Version # low-order 32 bits
	DirectMusicTimeSig	m_TimeSignature;		// The style's time signature
	double				m_dblTempo;				// The style's tempo
	TList<DirectMusicPart*> m_PartList;			// Parts used by the style
	TList<CDirectMusicPattern*> m_PatternList;	// Patterns used by the style
	TList<CDirectMusicPattern*> m_MotifList;		// Motifs used by the style
	TList<IDirectMusicBand *>  m_BandList;		// Bands used by the style
	IDirectMusicBand*		   m_pDefaultBand;   // Default band for style
	TList<IDirectMusicChordMap *>  m_PersList;		// Personalities used by the style
	IDirectMusicChordMap*		  m_pDefaultPers;   // Default Personality for style
	TList<DWORD>  m_PChannelList;		// PChannels used by the style
	DWORD				m_dwFlags;			// various flags
	//TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this style
};

/*
@interface IDirectMusicStyle | 
The <i IDirectMusicStyle> interface provides access to a Style object. 
The Style provides the Interactive Music Engine with the information it needs to perform 
a style of music (hence the name.) 
The application can also access information about the style, including the name, 
time signature, and recommended tempo.
Since styles usually include sets of Personalities, Bands, and Motifs, the <i IDirectMusicStyle> interface 
also provides functions for accessing them.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.


@base public | IUnknown

@meth HRESULT | EnumMotif | Returns the name of a motif, by location, from a Style's list of motifs.
@meth HRESULT | GetMotif | Returns a motif, by name, from a Style's list of motifs.
@meth HRESULT | EnumBand |  Returns the name of a band, by location, from a Style's list of bands.
@meth HRESULT | GetBand | Returns a band, by name, from a Style's list of bands. 
@meth HRESULT | GetDefaultBand | Returns a Style's default band. 
@meth HRESULT | EnumChordMap | Returns the name of a ChordMap, by location, from a Style's list of personalities.
@meth HRESULT | GetChordMap | Returns a ChordMap, by name, from a Style's list of personalities. 
@meth HRESULT | GetDefaultChordMap | Returns a Style's default ChordMap.  
@meth HRESULT | GetTimeSignature | Returns the time signature of a Style.
@meth HRESULT | GetEmbellishmentLength | Determines the length of a particular embellishment
in a Style. 
@meth HRESULT | GetTempo | Returns the recommended tempo of a Style. 

*/

/////////////////////////////////////////////////////////////////////////////
// CDMStyle
class CDMStyle : 
	public IDMStyle,
#ifdef DXAPI
    public IDirectMusicStyle8P,
#endif
	public IDirectMusicStyle8,
	public IDirectMusicObject,
	public IPersistStream
{
public:
    CDMStyle();
    ~CDMStyle();
	HRESULT CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
		DWORD dwRepeats);

// IDMStyle
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicStyle methods
	// Returns: S_OK if the index refers to a motif; S_FALSE if it doesn't
	HRESULT STDMETHODCALLTYPE EnumMotif(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);
	HRESULT STDMETHODCALLTYPE GetMotif(
		/*in*/	const WCHAR* pwszName,			// name of the motif for a secondary segment
		/*out*/	IDirectMusicSegment** ppSegment
	);
	HRESULT STDMETHODCALLTYPE GetBand(
		/*in*/	const WCHAR* pwszName,
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE EnumBand(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultBand(
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE GetChordMap(
		/*in*/	const WCHAR* pwszName,
		/*out*/	IDirectMusicChordMap** ppChordMap	
	);

	HRESULT STDMETHODCALLTYPE EnumChordMap(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultChordMap(
		/*out*/	IDirectMusicChordMap **ppChordMap
	);

	HRESULT STDMETHODCALLTYPE GetTimeSignature(
		/*out*/	DMUS_TIMESIGNATURE* pTimeSig			
	);

	HRESULT STDMETHODCALLTYPE GetEmbellishmentLength(
		/*in*/	DWORD dwType,			
		/*in*/	DWORD dwLevel,			
		/*out*/	DWORD* pdwMin,			
		/*out*/	DWORD* pdwMax
	);

	HRESULT STDMETHODCALLTYPE GetTempo(double* pTempo);

	// IDirectMusicStyle8 methods
	HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle*			pStyle,
		IDirectMusicSegment*		pTempSeg,
		IDirectMusicSegment**		ppSeqSeg
	);

	HRESULT STDMETHODCALLTYPE EnumPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*in*/  DWORD dwPatternType,	// type of pattern
		/*out*/	WCHAR *wszName			// name of the indexed motif
	);

	// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

	/* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

	// IDMStyle
#ifdef DXAPI
	HRESULT STDMETHODCALLTYPE GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream);
	HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid);
#endif
    HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData);
	HRESULT STDMETHODCALLTYPE IsDX8();
	HRESULT STDMETHODCALLTYPE CritSec(bool fEnter);
	HRESULT STDMETHODCALLTYPE GenerateTrack(//IDirectMusicTrack* pChordTrack,
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack);


protected: /* methods */
    void CleanUp();
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck );
    HRESULT IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  BOOL fDefault);
	HRESULT IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault );
    HRESULT DM_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle);
	HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
						IDirectMusicStyle* pStyle,
						IDirectMusicTrack* pSequenceTrack,
						DWORD dwTrackGroup,
						IDirectMusicSegment** ppSectionSeg);

	HRESULT CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
								IDirectMusicTrack*& pSequenceTrack);

	HRESULT CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
								DirectMusicTimeSig& rTimeSig,
								double dblTempo,
								MUSIC_TIME mtLength,
								BYTE bPlaymode,
								IDirectMusicTrack*& pPatternTrack);

	HRESULT STDMETHODCALLTYPE EnumRegularPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);

	HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime);

protected: /* attributes */
    long m_cRef;
	BOOL				m_fDirty;				// has the style been modified?
    CRITICAL_SECTION	m_CriticalSection;		// for i/o
    BOOL                m_fCSInitialized;
	DMStyleStruct		m_StyleInfo;			// The details of the style
	InversionGroup		m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

#endif //__DMSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstyle2.cpp ===
// DMStyle2.cpp : Further Implementation of CDMStyle
//
// Copyright (c) 1999-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

#include "DMStyle.h"
#include "debug.h"

#include "..\shared\Validate.h"
#include "iostru.h"
#include "mgentrk.h"
#include "..\shared\xcreate.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif

struct FirstTimePair
{
    DWORD dwPart;
    MUSIC_TIME mtTime;
};

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicStyle2

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeMelodyFromTemplate | Creates a sequence segment from a 
style and a Melody template (containing a Melody Generation track, a Chord track, and an 
optional Style track).  Clones the segment and adds a Sequence track containing melodic 
information.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and <p ppSeqSeg> is an invalid pointer.
@flag E_INVALIDARG | <p pStyle> is NULL and there is no Style track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL, 
a Style is retrieved from <p pTempSeg>'s Style track.
The length of the section segment is equal to the length of the template section
passed in.
*/

HRESULT CDMStyle::ComposeMelodyFromTemplate(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to create the sequence segment.
                    IDirectMusicSegment*        pTempSeg, // @parm The template from which to create the sequence segment.
                    IDirectMusicSegment**       ppSeqSeg // @parm Returns the created sequence segment.
            )
{
    V_INAME(ComposeMelodyFromTemplate)

    V_PTR_WRITE_OPT(pStyle, 1);
    V_PTR_WRITE(pTempSeg, 1);
    V_PTRPTR_WRITE(ppSeqSeg);

    DWORD dwTrackGroup = 0xffffffff;
    BOOL fStyleFromTrack = FALSE;
    HRESULT hr = S_OK;
    IDirectMusicTrack* pPatternTrack = NULL;
    IDirectMusicTrack* pMelGenTrack = NULL;
    MUSIC_TIME mtLength = 0;
    hr = pTempSeg->GetLength(&mtLength);
    if (FAILED(hr)) goto ON_END;

    // get the MelGen track and its track group.
    hr = pTempSeg->GetTrack(CLSID_DirectMusicMelodyFormulationTrack, 0xffffffff, 0, &pMelGenTrack);
    if (S_OK != hr) goto ON_END;
    if (FAILED(pTempSeg->GetTrackGroup(pMelGenTrack, &dwTrackGroup)))
    {
        dwTrackGroup = 0xffffffff;
    }

    // Get the style (either use the passed-in style or get one from a style track)
    if (!pStyle)
    {
        if (FAILED(hr = GetStyle(pTempSeg, 0, dwTrackGroup, pStyle)))
        {
            hr = E_INVALIDARG;
            goto ON_END;
        }
        fStyleFromTrack = TRUE;
    }

    // Using style, and melgen track, create a pattern track
    hr = GenerateTrack(pTempSeg, NULL, dwTrackGroup, pStyle, pMelGenTrack, mtLength, pPatternTrack);
    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
        {
            if (pPatternTrack) pPatternTrack->Release();
            pPatternTrack = NULL;
        }
        HRESULT hrCopy = CopySegment(pTempSeg, pStyle, pPatternTrack, dwTrackGroup, ppSeqSeg);
        if (FAILED(hrCopy)) hr = hrCopy;
    }

ON_END:
    // release from Addref in GetTrack
    if (pMelGenTrack) pMelGenTrack->Release();     
    // release from CoCreateInstance in CreatePatternTrack
    if (pPatternTrack) pPatternTrack->Release(); 
    // Release from Addref in GetStyle
    if (fStyleFromTrack) pStyle->Release();

    return hr;
}

HRESULT CDMStyle::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle)
{
    HRESULT hr = S_OK;
    // Get the segment's style track.
    IDirectMusicTrack* pStyleTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicStyleTrack, dwTrackGroup, 0, &pStyleTrack);
    if (S_OK != hr) return hr;
    // Get the style from the style track
    hr = pStyleTrack->GetParam(GUID_IDirectMusicStyle, mt, NULL, (void*) &rpStyle);
    pStyleTrack->Release();
    return hr;
}

HRESULT CDMStyle::CopySegment(IDirectMusicSegment* pTempSeg,
                              IDirectMusicStyle* pStyle,
                              IDirectMusicTrack* pPatternTrack,
                              DWORD dwTrackGroup,
                              IDirectMusicSegment** ppSectionSeg)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    long                    nClocks                 = 0;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;

    DMUS_BAND_PARAM DMBandParam;
    pTempSeg->GetLength(&nClocks);
    /////////////////////////////////////////////////////////////
    // clone the template segment to get a section segment
    hr = pTempSeg->Clone(0, nClocks, ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);

    // Remove all style tracks from the new segment.
    do
    {
        hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, dwTrackGroup, 0, &pIStyleTrack);
        if (S_OK == hr)
        {
            (*ppSectionSeg)->RemoveTrack(pIStyleTrack);
            pIStyleTrack->Release();
            pIStyleTrack = NULL;
        }
    } while (S_OK == hr);

    // hr is no longer S_OK, so reset it.
    hr = S_OK;

    // if there's no tempo track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicTempoTrack, dwTrackGroup, 0, &pDMTrack)))
    {
        // Create a Tempo Track in which to store the tempo events
        DMUS_TEMPO_PARAM tempo;
        tempo.mtTime = 0;

        pStyle->GetTempo(&tempo.dblTempo);
        if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,
            NULL, IID_IDirectMusicTrack,(void**)&pDMTrack )))
        {
            if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
            {
                (*ppSectionSeg)->InsertTrack( pDMTrack, dwTrackGroup );
            }
        }
    }
    // if there's no band track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicBandTrack, dwTrackGroup, 0, &pBandTrack)))
    {
        // Create band track
        hr = DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,NULL,IID_IDirectMusicTrack,(void**)&pBandTrack);
        
        if(!SUCCEEDED(hr)) goto ON_END;
        
        // Load default band from style into track
        hr = pStyle->GetDefaultBand(&pBand);
        if (!SUCCEEDED(hr)) goto ON_END;
        DMBandParam.mtTimePhysical = -64;
        DMBandParam.pBand = pBand;
        hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
        if (!SUCCEEDED(hr)) goto ON_END;
        (*ppSectionSeg)->InsertTrack(pBandTrack, dwTrackGroup);
    }

    // Add the pattern track
    if (pPatternTrack)
    {
        (*ppSectionSeg)->InsertTrack(pPatternTrack, dwTrackGroup);
    }

    // Initialize the segment
    (*ppSectionSeg)->SetRepeats(0);
    TraceI(4, "Segment Length: %d\n", nClocks);
    (*ppSectionSeg)->SetLength(nClocks);

ON_END:
    if (pDMTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by DirectMusicCreateInstance
        pDMTrack->Release();
    }
    if (pBandTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by DirectMusicCreateInstance
        pBandTrack->Release();
    }
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

HRESULT CDMStyle::GenerateTrack(IDirectMusicSegment* pTempSeg,
                                IDirectMusicSong* pSong,
                                DWORD dwTrackGroup,
                                IDirectMusicStyle* pStyle,
                                IDirectMusicTrack* pMelGenTrack,
                                MUSIC_TIME mtLength,
                                IDirectMusicTrack*& pNewTrack)
{
    if (!pStyle || !pMelGenTrack) return E_INVALIDARG;

    HRESULT hr = S_OK;

    // CoCreate the pattern track
    hr = DirectMusicCreateInstance(CLSID_DirectMusicPatternTrack,NULL,IID_IDirectMusicTrack,(void**)&pNewTrack);
    if (FAILED(hr)) return hr;

    // Get the Style's info struct
    IDMStyle* pDMStyle = NULL;
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle);
    if (FAILED(hr)) return hr;
    DMStyleStruct* pStyleStruct = NULL;
    pDMStyle->GetStyleInfo((void**)&pStyleStruct);

    MUSIC_TIME mtNewFragment = 0;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtRealNextChord = 0;
    MUSIC_TIME mtNextChord = 0;
    MUSIC_TIME mtLaterChord = 0;
    DMUS_MELODY_FRAGMENT DMUS_Fragment;
    memset(&DMUS_Fragment, 0, sizeof(DMUS_Fragment));
    DMUS_CHORD_PARAM CurrentChord;
    DMUS_CHORD_PARAM RealCurrentChord;
    DMUS_CHORD_PARAM NextChord;
    CDirectMusicPattern* pPattern;
    TList<CompositionFragment> listFragments;
    TListItem<CompositionFragment>* pLastFragment = NULL;
    CompositionFragment CompRepeat;
    FirstTimePair* aFirstTimes = NULL;
    BYTE bPlaymode = 0;
    pMelGenTrack->GetParam(GUID_MelodyPlaymode, 0, NULL,  (void*)&bPlaymode);
    if (bPlaymode & DMUS_PLAYMODE_NONE)
    {
        bPlaymode = DMUS_PLAYMODE_ALWAYSPLAY;
    }
    // for each melody fragment:
    do
    {
        pLastFragment = listFragments.GetHead();
        // get the fragment
        HRESULT hrFragment = pMelGenTrack->GetParam(GUID_MelodyFragment, mtNewFragment, &mtNext, (void*)&DMUS_Fragment);
        if (FAILED(hrFragment)) break;
        MelodyFragment Fragment = DMUS_Fragment;
        if (mtNext) mtNewFragment += mtNext;
        else mtNewFragment = 0;

        // get its repeat
        MelodyFragment repeatFragment = Fragment;
        hr = pMelGenTrack->GetParam(GUID_MelodyFragmentRepeat, 0, NULL, (void*)&DMUS_Fragment);
        if (SUCCEEDED(hr))
        {
            repeatFragment = DMUS_Fragment;
        }
        else // failing to get a repeat just means this fragment doesn't repeat; composition can still continue
        {
            hr = S_OK;
        }
        
        // If the fragment repeats an earlier fragment, get the earlier fragment.
        // Regardless, get the fragment's pattern.
        ZeroMemory( &CompRepeat, sizeof(CompRepeat));
        if (SUCCEEDED(hrFragment) && Fragment.UsesRepeat())
        {
            TListItem<CompositionFragment>* pScan = listFragments.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().GetID() == repeatFragment.GetID())
                {
                    CompRepeat = pScan->GetItemValue();
                }
            }
            pPattern = CompRepeat.m_pPattern;
        }
        else
        {
            Fragment.GetPattern(pStyleStruct, pPattern, pLastFragment);
        }
        // bail if we couldn't get a pattern
        if (!pPattern)
        {
            hr = DMUS_E_NOT_FOUND;
            break;
        }

        // get the pattern's partrefs
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        int nParts = pPattern->m_PartRefList.GetCount();
        
        // clear all inversion groups for the fragment
        Fragment.ClearInversionGroups();
        
        // get the starting chords for the fragment
        Fragment.GetChord(pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord, mtRealNextChord, RealCurrentChord);

        Fragment.GetChord(mtNextChord, pTempSeg, pSong, dwTrackGroup, mtLaterChord, NextChord);

        // initializations
        TListItem<CompositionFragment>* pFragmentItem = new TListItem<CompositionFragment>(Fragment);
        if (!pFragmentItem)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        hr = rFragment.Init(pPattern, pStyleStruct, nParts);
        if (FAILED(hr))
        {
            break;
        }
        if (aFirstTimes) delete [] aFirstTimes;
        aFirstTimes = new FirstTimePair[nParts];
        if (!aFirstTimes)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // If we're repeating using transposition intervals:
        // go through each part, attempting to fit the repeated part to the constraints.
        // If this process fails for any part, abort the process.
        // If it succeeds for every part, we can skip everything else that follows.
        // (ASSUMPTION 1: constraints are pattern-wide, and so must be satisfied by every part)
        // (ASSUMPTION 2: different parts are allowed to transpose by different intervals)
        HRESULT hrSkipVariations = S_OK;
        if (Fragment.RepeatsWithConstraints()) // if repeating using transposition intervals
        {
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                aFirstTimes[i].dwPart = pPartRef->GetItemValue().m_dwLogicalPartID;
                aFirstTimes[i].mtTime = 0;
                hrSkipVariations = Fragment.GetRepeatedEvents(CompRepeat,
                                                              CurrentChord,
                                                              RealCurrentChord,
                                                              bPlaymode,
                                                              i,
                                                              pPartRef->GetItemValue(),
                                                              pLastFragment,
                                                              aFirstTimes[i].mtTime,
                                                              rFragment.EventList(i));
                if (FAILED(hrSkipVariations)) break;
            }
        }
        else
        {
            hrSkipVariations = E_FAIL;
        }

        if (FAILED(hrSkipVariations))
        {
            // If we're repeating, make sure the repeat fragment actually has variations,
            // and is not itself repeating an earlier fragment.
            // (we don't need to get the pattern again; that will be the same for all repeats)
            CompositionFragment CompLast = CompRepeat;
            while (repeatFragment.UsesRepeat())
            {
                DWORD dwRepeatID = repeatFragment.GetRepeatID();
                ZeroMemory( &CompRepeat, sizeof(CompRepeat));
                TListItem<CompositionFragment>* pScan = listFragments.GetHead();
                for (; pScan; pScan = pScan->GetNext())
                {
                    if (pScan->GetItemValue().GetID() == dwRepeatID)
                    {
                        CompRepeat = pScan->GetItemValue();
                        repeatFragment = CompRepeat;
                        if (!CompLast.m_abVariations && CompRepeat.m_abVariations)
                        {
                            ZeroMemory( &CompLast, sizeof(CompLast));
                            CompLast = CompRepeat;
                        }
                    }
                }
            }

            // Get variations for the Fragment
            Fragment.GetVariations(rFragment, CompRepeat, CompLast, CurrentChord, NextChord, mtNextChord, pLastFragment);

            bool fNeedChord = false;

            // for each part in the pattern:
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                // Clean up anything that might have happened with repeats
                rFragment.CleanupEvents(i);

                if (fNeedChord)
                {
                    Fragment.GetChord(pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord, mtRealNextChord, RealCurrentChord);
                    Fragment.GetChord(mtNextChord, pTempSeg, pSong, dwTrackGroup, mtLaterChord, NextChord);
                    fNeedChord = false;
                }

                DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
                DirectMusicTimeSig& TimeSig = rFragment.GetTimeSig(pPart);
                aFirstTimes[i].dwPart = pPartRef->GetItemValue().m_dwLogicalPartID;
                aFirstTimes[i].mtTime = 0;
                bool fFoundFirst = false;
                // for each note in the variation:
                CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
                for (; pEvent; pEvent = pEvent->GetNext())
                {
                    if ( pEvent->m_dwVariation & (1 << rFragment.m_abVariations[i]) )
                    {
                        TListItem<EventWrapper>* pEventItem = NULL;
                        // get the time (offset from the start of the track)
                        MUSIC_TIME mtNow = Fragment.GetTime() +
                            TimeSig.GridToClocks(pEvent->m_nGridStart) + pEvent->m_nTimeOffset;
                        // Make sure this doesn't overlap with the next fragment.
                        MUSIC_TIME mtDuration = 0;
                        switch (pEvent->m_dwEventTag)
                        {
                        case DMUS_EVENT_NOTE:
                            mtDuration = ((CDMStyleNote*)pEvent)->m_mtDuration;
                            break;
                        case DMUS_EVENT_CURVE:
                            mtDuration = ((CDMStyleCurve*)pEvent)->m_mtDuration;
                            break;
                        }
                        bool fAddToOverlap = false;
                        if ( !mtNewFragment || mtNow + mtDuration <= mtNewFragment )
                        {
                            if (pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION)
                            {
                                fAddToOverlap = true;
                            }
                            else
                            {
                                // use proper chord for non-anticipated notes
                                if (mtRealNextChord != mtNextChord && mtNow >= mtRealNextChord)
                                {
                                    mtRealNextChord = mtNextChord;
                                    RealCurrentChord = CurrentChord;
                                }
                                // get a new chord if necessary
                                if (mtNextChord && mtNow >= mtNextChord)
                                {
                                    Fragment.GetChord(mtNow, pTempSeg, pSong, dwTrackGroup, mtNextChord, CurrentChord);
                                    mtRealNextChord = mtNextChord;
                                    RealCurrentChord = CurrentChord;
                                    fNeedChord = true;
                                }
                                // Convert the event to a wrapped event
                                hr = Fragment.GetEvent(pEvent, CurrentChord, RealCurrentChord, mtNow, pPartRef->GetItemValue(), pEventItem);
                                // Add the new event to a list of wrapped events.
                                if (hr == S_OK)
                                {
                                    rFragment.AddEvent(i, pEventItem);
                                }
                                if (!fFoundFirst || mtNow < aFirstTimes[i].mtTime)
                                {
                                    fFoundFirst = true;
                                    aFirstTimes[i].mtTime = mtNow;
                                }
                            }
                        }
                        // ignore anticipations that start after the next fragment
                        else if (pEvent->m_dwEventTag != DMUS_EVENT_ANTICIPATION)
                        {
                            fAddToOverlap = true;
                        }
                        if (fAddToOverlap)
                        {
                            TListItem<EventOverlap>* pOverlap = new TListItem<EventOverlap>;
                            if (pOverlap)
                            {
                                EventOverlap& rOverlap = pOverlap->GetItemValue();
                                rOverlap.m_PartRef = pPartRef->GetItemValue();
                                rOverlap.m_pEvent = pEvent;
                                rOverlap.m_mtTime = mtNow;
                                rOverlap.m_mtDuration = mtDuration;
                                rOverlap.m_Chord = CurrentChord;
                                rOverlap.m_RealChord = RealCurrentChord;
                                rFragment.AddOverlap(pOverlap);
                            }
                        }
                    }
                }
                if (!fFoundFirst) aFirstTimes[i].mtTime = mtNewFragment;
                // Sort the sequence items in reverse order, so that the last element is easy to find
                rFragment.SortEvents(i);
                        }
                // Clear this so the pointers it may reference aren't deleted twice.
                ZeroMemory( &CompLast, sizeof(CompLast));
        }
        listFragments.AddHead(pFragmentItem);
        // Go through the list of overlaps for the last fragment, adding any events that don't 
        // actually overlap (and processing anticipations)
        // alg for processing anticipations:
        //   if the overlap list contains an anticipation for a part:
        //     find the first event in that part's fragment list
        //     make the start time of that event be the start time of the anticipation
        //     add to the duration of the event the difference between the event's start time
        //       and the anticipation's start time
        if (pLastFragment)
        {
            TListItem<EventWrapper>* pEventItem = NULL;
            CompositionFragment& rLastFragment = pLastFragment->GetItemValue();
            TListItem<EventOverlap>* pTupleItem;
            pTupleItem = rLastFragment.GetOverlapHead();
            for (; pTupleItem; pTupleItem = pTupleItem->GetNext() )
            {
                EventOverlap& rTuple = pTupleItem->GetItemValue();
                for (int i = 0; i < nParts; i++)
                {
                    if (rTuple.m_PartRef.m_dwLogicalPartID == aFirstTimes[i].dwPart) break;
                }
                if (i >= nParts || 
                    !aFirstTimes[i].mtTime || 
                    rTuple.m_mtTime < aFirstTimes[i].mtTime)
                {
                    if (rTuple.m_pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION)
                    {
                        if (i < nParts && aFirstTimes[i].mtTime)
                        {
                            TListItem<EventWrapper>* pFirstNote = NULL;
                            TListItem<EventWrapper>* pScan = rFragment.GetEventHead(i);
                            // since the list is sorted in reverse order, the first note in
                            // the fragment will be the last one in the list.
                            for (; pScan; pScan = pScan->GetNext()) 
                            {
                                if (pScan->GetItemValue().m_pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
                                {
                                    pFirstNote = pScan;
                                }
                            }
                            if (pFirstNote)
                            {
                                EventWrapper& rFirstNote = pFirstNote->GetItemValue();
                                CDMStyleNote* pNoteEvent = (CDMStyleNote*)rFirstNote.m_pEvent;
                                pNoteEvent->m_mtDuration += (rFirstNote.m_mtTime - rTuple.m_mtTime);
                                rFirstNote.m_mtTime = rTuple.m_mtTime;
                            }
                        }
                    }
                    else
                    {
                        hr = rLastFragment.GetEvent(rTuple.m_pEvent, rTuple.m_Chord, rTuple.m_RealChord, rTuple.m_mtTime, rTuple.m_PartRef, pEventItem);
                        if (i < nParts && 
                            aFirstTimes[i].mtTime &&
                            rTuple.m_mtTime + rTuple.m_mtDuration >= aFirstTimes[i].mtTime)
                        {
                            int nDiff = rTuple.m_mtTime + rTuple.m_mtDuration - aFirstTimes[i].mtTime;
                            if (pEventItem && pEventItem->GetItemValue().m_pEvent)
                            {
                                switch (pEventItem->GetItemValue().m_pEvent->m_dwEventTag)
                                {
                                case DMUS_EVENT_NOTE:
                                    ((CDMStyleNote*)pEventItem->GetItemValue().m_pEvent)->m_mtDuration -= nDiff;
                                    break;
                                case DMUS_EVENT_CURVE:
                                    ((CDMStyleCurve*)pEventItem->GetItemValue().m_pEvent)->m_mtDuration -= nDiff;
                                    break;
                                }
                            }
                        }
                        rLastFragment.InsertEvent(i, pEventItem);
                    }
                }
            }
        }
        // NOTE:  Need to apply transformations (invert, reverse...) here.
        // I should also move the individual sorts out of the overlapped notes code,
        // and put it directly preceding the transformations.

    } while (mtNext != 0);

    // Clear this so the pointers it may reference aren't deleted twice.
    ZeroMemory( &CompRepeat, sizeof(CompRepeat));

    // Once pattern tracks are introduced, I need to change this to create a pattern track.
    // I should allow an option to create one or the other (?).
    if (SUCCEEDED(hr))
    {
        hr = CreatePatternTrack(listFragments, 
                                pStyleStruct->m_TimeSignature, 
                                pStyleStruct->m_dblTempo,
                                mtLength,
                                bPlaymode,
                                pNewTrack);
    }
    
    if (aFirstTimes) delete [] aFirstTimes;

    pDMStyle->Release();
    return hr;
}

TListItem<DMUS_IO_SEQ_ITEM>* ConvertToSequenceEvent(TListItem<EventWrapper>* pEventItem)
{
    TListItem<DMUS_IO_SEQ_ITEM>* pResult = new TListItem<DMUS_IO_SEQ_ITEM>;
    if (pResult)
    {
        DMUS_IO_SEQ_ITEM& rSeq = pResult->GetItemValue();
        EventWrapper& rEvent = pEventItem->GetItemValue();
        rSeq.bStatus = 0x90;  // MIDI note on (with channel nibble stripped out)
        rSeq.mtTime = rEvent.m_mtTime;
        rSeq.bByte1 = rEvent.m_bMIDI;
        rSeq.dwPChannel = rEvent.m_dwPChannel;
        rSeq.nOffset = rEvent.m_pEvent->m_nTimeOffset;
        if (rEvent.m_pEvent)
        {
            switch (rEvent.m_pEvent->m_dwEventTag)
            {
            case DMUS_EVENT_NOTE:
                rSeq.mtDuration = ((CDMStyleNote*)rEvent.m_pEvent)->m_mtDuration;
                rSeq.bByte2 = ((CDMStyleNote*)rEvent.m_pEvent)->m_bVelocity;
                break;
            case DMUS_EVENT_CURVE:
                rSeq.mtDuration = ((CDMStyleCurve*)rEvent.m_pEvent)->m_mtDuration;
                rSeq.bByte2 = 0;  // Actually, curves shouldn't end up as note events...
                break;
            }
        }
    }
    return pResult;
}

HRESULT CDMStyle::CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
                                IDirectMusicTrack*& pSequenceTrack)
{
    HRESULT hr = S_OK;

    TList<DMUS_IO_SEQ_ITEM> SeqList;

    // fold all the individual event lists into one list
    TListItem<CompositionFragment>* pFragmentItem = rlistFragments.GetHead();
    for (; pFragmentItem; pFragmentItem = pFragmentItem->GetNext())
    {
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        int nParts = rFragment.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; i < nParts; i++)
        {
            while (!rFragment.IsEmptyEvents(i))
            {
                TListItem<EventWrapper>* pHead = rFragment.RemoveEventHead(i);
                SeqList.AddHead(ConvertToSequenceEvent(pHead));
            }
        }
    }

    // Sort the sequence items
    SeqList.MergeSort(Less);

    // Now, persist the sequence events into the Sequence track
    IPersistStream* pIPSTrack = NULL;
    if( SUCCEEDED( pSequenceTrack->QueryInterface( IID_IPersistStream, (void**)&pIPSTrack )))
    {
        // Create a stream in which to place the events so we can
        // give it to the SeqTrack.Load.
        IStream* pEventStream;
        if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
        {
            // Save the events into the stream
            TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem = NULL;
            ULONG   cb, cbWritten;
            // Save the chunk id
            DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Save the overall size. Count the number of events to determine.
            DWORD dwSize = 0;
            for( pSeqItem = SeqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                dwSize++;
            }
            dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
            // add 12 --- 8 for the subchunk header and overall size, 
            // and 4 for the DMUS_IO_SEQ_ITEM size DWORD in the subchunk
            dwSize += 12;
            pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
            // Save the subchunk id
            dwTemp = DMUS_FOURCC_SEQ_LIST;
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Subtract the previously added 8 (for subchunk header and overall size)
            dwSize -= 8;
            // Save the size of the subchunk (including the DMUS_IO_SEQ_ITEM size DWORD)
            pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
            // Save the structure size.
            dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
            pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
            // Save the events.
            cb = sizeof(DMUS_IO_SEQ_ITEM);
            for( pSeqItem = SeqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
                pEventStream->Write( &rSeqItem, cb, &cbWritten );
                if( cb != cbWritten ) // error!
                {
                    pEventStream->Release();
                    pEventStream = NULL;
                    hr = DMUS_E_CANNOTREAD;
                    break;
                }
            }
            if( pEventStream ) // may be NULL
            {
                StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                pIPSTrack->Load( pEventStream );
                pEventStream->Release();
            }
        }
        pIPSTrack->Release();
    }

    return hr;
}

CDirectMusicEventItem* ConvertToPatternEvent(TListItem<EventWrapper>* pEventWrapper,
                                             DWORD dwID,
                                             BYTE bPlaymode,
                                             DirectMusicTimeSig& TimeSig)
{
    if (!pEventWrapper) return NULL;
    BYTE bEventPlaymode = pEventWrapper->GetItemValue().m_bPlaymode;
    if (bPlaymode == bEventPlaymode)
    {
        bEventPlaymode = DMUS_PLAYMODE_NONE;
    }
    CDirectMusicEventItem* pWrappedEvent = pEventWrapper->GetItemValue().m_pEvent;
    if (!pWrappedEvent) return NULL;
    MUSIC_TIME mtClocksPerGrid = TimeSig.ClocksPerGrid();
    short nGrid = 0;
    short nOffset = 0;
    if (mtClocksPerGrid)
    {
        nGrid = (short) (pEventWrapper->GetItemValue().m_mtTime / mtClocksPerGrid);
        nOffset = (short) (pWrappedEvent->m_nTimeOffset + pEventWrapper->GetItemValue().m_mtTime % mtClocksPerGrid);
    }
    DWORD dwVariations = 0xffffffff;
    BYTE bFlags = 0;
    if (pEventWrapper->GetItemValue().m_pEvent && 
        pEventWrapper->GetItemValue().m_pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
    {
        bFlags = ((CDMStyleNote*)pEventWrapper->GetItemValue().m_pEvent)->m_bFlags;
    }
    return pWrappedEvent->ReviseEvent(nGrid, nOffset, &dwVariations, &dwID, &pEventWrapper->GetItemValue().m_wMusic, &bEventPlaymode, &bFlags);
}

HRESULT CDMStyle::CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
                                     DirectMusicTimeSig& rTimeSig,
                                     double dblTempo,
                                     MUSIC_TIME mtLength,
                                     BYTE bPlaymode,
                                     IDirectMusicTrack*& pPatternTrack)
{
    HRESULT hr = S_OK;

    CDirectMusicPattern* pPattern = new CDirectMusicPattern(&rTimeSig);
    if (!pPattern) return E_OUTOFMEMORY;
    pPattern->m_strName = "<Composed Pattern>";

    // fold all the individual event lists into corresponding parts in the pattern
    TListItem<CompositionFragment>* pFragmentItem = rlistFragments.GetHead();
    for (; pFragmentItem; pFragmentItem = pFragmentItem->GetNext())
    {
        CompositionFragment& rFragment = pFragmentItem->GetItemValue();
        TListItem<DirectMusicPartRef>* pPartRef = rFragment.m_pPattern->m_PartRefList.GetHead();
        int nParts = rFragment.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; i < nParts && pPartRef; i++, pPartRef = pPartRef->GetNext() )
        {
            DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
            TListItem<DirectMusicPartRef>* pNewPartRef = pPattern->CreatePart(rPartRef, bPlaymode);
            if (!pNewPartRef)
            {
                hr = E_OUTOFMEMORY; 
                break;
            }
            DirectMusicPart* pPart = pNewPartRef->GetItemValue().m_pDMPart;
            if (!pPart)
            {
                hr = E_FAIL;    
                break;
            }
            while (!rFragment.IsEmptyEvents(i))
            {
                TListItem<EventWrapper>* pHead = rFragment.RemoveEventHead(i);
                CDirectMusicEventItem* pNew = ConvertToPatternEvent(pHead, rFragment.GetID(), bPlaymode, rTimeSig);
                if (pNew)
                {
                    pPart->EventList.AddHead(pNew);
                }
                delete pHead;
            }
        }
        if (FAILED(hr)) break;
    }
    WORD wNumMeasures = 0;
    MUSIC_TIME mtClocksPerMeasure = rTimeSig.ClocksPerMeasure();
    if (mtClocksPerMeasure)
    {
        wNumMeasures = (WORD)(mtLength / mtClocksPerMeasure);
        if (mtLength % mtClocksPerMeasure)
        {
            wNumMeasures++;
        }
    }
    pPattern->m_wNumMeasures = wNumMeasures;
    pPattern->m_pRhythmMap = new DWORD[wNumMeasures];
    if (pPattern->m_pRhythmMap)
    {
        for (int i = 0; i < wNumMeasures; i++)
        {
            pPattern->m_pRhythmMap[i] = 0;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    if (SUCCEEDED(hr))
    {
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        int nParts = pPattern->m_PartRefList.GetCount();
        // Sort the event lists for each part, and set the number of measures.
        for (int i = 0; i < nParts && pPartRef; i++, pPartRef = pPartRef->GetNext() )
        {
            DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
            if (pPart)
            {
                pPart->m_wNumMeasures = wNumMeasures;
                pPart->EventList.MergeSort(rTimeSig);
                // remove notes so close that they might as well be overlapping
                CDirectMusicEventItem* pThisEvent = pPart->EventList.GetHead();
                CDirectMusicEventItem* pLastEvent = NULL;
                for (; pThisEvent; pThisEvent = pThisEvent->GetNext())
                {
                    if (pThisEvent->m_dwEventTag == DMUS_EVENT_NOTE)
                    {
                        CDMStyleNote* pThisNote = (CDMStyleNote*)pThisEvent;
                        CDirectMusicEventItem* pNextEvent = pThisEvent->GetNext();
                        for (; pNextEvent; pNextEvent = pNextEvent->GetNext())
                        {
                            if (pNextEvent->m_dwEventTag == DMUS_EVENT_NOTE) break;
                        }
                        if (pNextEvent)
                        {
                            CDMStyleNote* pNextNote = (CDMStyleNote*)pNextEvent;
                            MUSIC_TIME mtThis = rTimeSig.GridToClocks(pThisNote->m_nGridStart) + pThisNote->m_nTimeOffset;
                            MUSIC_TIME mtNext = rTimeSig.GridToClocks(pNextNote->m_nGridStart) + pNextNote->m_nTimeOffset;
                            if ( (pNextNote->m_dwFragmentID != pThisNote->m_dwFragmentID) &&
                                 ((mtThis < mtNext && mtThis + OVERLAP_DELTA > mtNext) ||
                                  (mtThis > mtNext && mtThis + OVERLAP_DELTA < mtNext)) ) // could happen with negative offsets...
                            {
                                if (pLastEvent)
                                {
                                    pLastEvent->SetNext(pThisEvent->GetNext());
                                }
                                else // the note I want to remove is the first event
                                {
                                    pPart->EventList.RemoveHead();
                                }
                                pThisEvent->SetNext(NULL);
                                delete pThisEvent;
                                pThisEvent = pLastEvent;
                            }
                        }
                    }
                    pLastEvent = pThisEvent;
                }
            }
        }
        // Now, save the newly created pattern to a pattern track
        IPersistStream* pIPSTrack = NULL;
        IAARIFFStream* pIRiffStream;
        MMCKINFO ckMain;
        if( SUCCEEDED( pPatternTrack->QueryInterface( IID_IPersistStream, (void**)&pIPSTrack )))
        {
            // Create a stream in which to place the events so we can
            // give it to the PatternTrack.Load.
            IStream* pEventStream;
            if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
            {
                if( SUCCEEDED( AllocRIFFStream( pEventStream, &pIRiffStream ) ) )
                {
                    ckMain.fccType = DMUS_FOURCC_PATTERN_FORM;
                    if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0 )
                    {
                        MMCKINFO ckHeader;
                        ckHeader.ckid = DMUS_FOURCC_STYLE_CHUNK;
                        if( pIRiffStream->CreateChunk( &ckHeader, 0 ) != 0 )
                        {
                            hr = E_FAIL;
                        }
                        if (SUCCEEDED(hr))
                        {
                            // Prepare DMUS_IO_STYLE
                            DMUS_IO_STYLE oDMStyle;
                            DWORD dwBytesWritten = 0;
                            memset( &oDMStyle, 0, sizeof(DMUS_IO_STYLE) );
                            oDMStyle.timeSig.bBeatsPerMeasure = rTimeSig.m_bBeatsPerMeasure;
                            oDMStyle.timeSig.bBeat = rTimeSig.m_bBeat;
                            oDMStyle.timeSig.wGridsPerBeat = rTimeSig.m_wGridsPerBeat;
                            oDMStyle.dblTempo = dblTempo;
                            // Write chunk data
                            hr = pEventStream->Write( &oDMStyle, sizeof(DMUS_IO_STYLE), &dwBytesWritten);
                            if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLE) )
                            {
                                hr = E_FAIL;
                            }
                            
                            if( SUCCEEDED(hr) && pIRiffStream->Ascend( &ckHeader, 0 ) != 0 )
                            {
                                hr = E_FAIL;
                            }
                        }

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPattern->Save( pEventStream );
                            pPartRef = pPattern->m_PartRefList.GetHead();
                            for (; pPartRef; pPartRef = pPartRef->GetNext())
                            {
                                if (pPartRef->GetItemValue().m_pDMPart)
                                {
                                    delete pPartRef->GetItemValue().m_pDMPart;
                                    pPartRef->GetItemValue().m_pDMPart = NULL;
                                }
                            }
                            pPattern->CleanUp();
                            delete pPattern;
                            if ( SUCCEEDED( hr ) && pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                    pIRiffStream->Release();
                }
                if( SUCCEEDED(hr) )
                {
                    StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( pEventStream );
                }
                pEventStream->Release();
            }
            pIPSTrack->Release();
        }
    }

    if (hr == S_OK && !rlistFragments.GetHead()) hr = S_FALSE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmsect.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmsect.cpp
//
//--------------------------------------------------------------------------

// DMSection.cpp : Implementation of CDMSection
#include "DMSect.h"
#include "DMStyle.h"
#include <initguid.h>
#include "debug.h"
#include "..\dmloader\ima.h"
#include "..\shared\Validate.h"
#include "..\shared\xcreate.h"
#include "..\shared\critsec.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif

HRESULT CDMSection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	return S_OK;
}

HRESULT CDMSection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	return S_OK;
}

HRESULT CDMSection::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
	return S_OK;
}

STDMETHODIMP CDMSection::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CDMSection::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDMSection)
    {
        *ppv = static_cast<IDMSection*>(this);
    } 
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } 
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
	else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMSection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMSection::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDMSection

STDMETHODIMP CDMSection::GetStyle(IUnknown * * ppStyle)
{
	HRESULT hr;
	if (m_pStyle)
	{
		IUnknown* pIU = NULL;
		hr = m_pStyle->QueryInterface(IID_IUnknown, (void**)&pIU);
		if (SUCCEEDED(hr))
		{
			*ppStyle = pIU;
			pIU->Release();
			hr = S_OK;
		}
	}
	else
		hr = E_FAIL;
	return hr;
}

STDMETHODIMP CDMSection::CreateSegment(IDirectMusicSegment* pISegment)
{
	HRESULT					hr						= S_OK;
	IDirectMusicTrack*		pIStyleTrack			= NULL;
	IDirectMusicTrack*		pICommandTrack			= NULL;
	IDirectMusicTrack*		pIChordTrack			= NULL;
	IDirectMusicTrack*		pBandTrack				= NULL;
	IDirectMusicTrack*		pDMTrack				= NULL;
    IAARIFFStream*			pCommandRIFF			= NULL;
    IAARIFFStream*			pChordRIFF				= NULL;
	IStream*				pICommandStream			= NULL;
	IStream*				pIChordStream			= NULL;
	IPersistStream*			pICommandTrackStream	= NULL;
	IPersistStream*			pIChordTrackStream		= NULL;
	IStyleTrack*			pS						= NULL;
	IUnknown*				pU						= NULL;
	DMUS_BAND_PARAM			DMBandParam;

	// 1. Create Style, Command, and Chord Tracks.
	hr = DirectMusicCreateInstance(CLSID_DirectMusicStyleTrack,NULL,IID_IDirectMusicTrack,(void**)&pIStyleTrack);
	if (FAILED(hr)) goto ON_END;
	hr = DirectMusicCreateInstance(CLSID_DirectMusicCommandTrack,NULL,IID_IDirectMusicTrack,(void**)&pICommandTrack);
	if (FAILED(hr)) goto ON_END;
	hr = DirectMusicCreateInstance(CLSID_DirectMusicChordTrack,NULL,IID_IDirectMusicTrack,(void**)&pIChordTrack);
	if (FAILED(hr)) goto ON_END;
	hr = DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,NULL,IID_IDirectMusicTrack,(void**)&pBandTrack);
	if (FAILED(hr)) goto ON_END;

	// 2/3. Use the section's style create a style track.
	hr = m_pStyle->QueryInterface(IID_IUnknown, (void**)&pU);
	if (FAILED(hr)) goto ON_END;
	hr = pIStyleTrack->QueryInterface(IID_IStyleTrack, (void**)&pS);
	if (FAILED(hr)) goto ON_END;
	pS->SetTrack(pU);
	m_pStyle->AddRef(); // Whenever I create a track from a style, I need to addref the style
	// 4. Write the section's command list out to a stream.
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
	if (FAILED(hr)) goto ON_END;
	hr = AllocRIFFStream( pICommandStream, &pCommandRIFF);
	if (FAILED(hr)) goto ON_END;
	SaveCommandList(pCommandRIFF);
	// 5. Write the section's chord list out to a stream.
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
	if (S_OK != hr) goto ON_END;
	hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
	if (FAILED(hr)) goto ON_END;
	SaveChordList(pChordRIFF);
	// 6. Use the command list stream as input to the Command Track's Load method.
	hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
	if (FAILED(hr)) goto ON_END;
	StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
	hr = pICommandTrackStream->Load(pICommandStream);
	if (FAILED(hr)) goto ON_END;
	// 7a. Use the chord list stream as input to the Chord Track's Load method.
	hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
	if (FAILED(hr)) goto ON_END;
	StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
	hr = pIChordTrackStream->Load(pIChordStream);
	if(FAILED(hr)) goto ON_END;
	// 7b. Load band into band track
	DMBandParam.mtTimePhysical = -64;
	DMBandParam.pBand = m_pIDMBand;
	hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
	if (FAILED(hr)) goto ON_END;

	// 8. Create a Segment has been removed it is now passed in

	// 9. Initialize the segment appropriately.
	pISegment->SetRepeats(m_wRepeats);
	pISegment->SetDefaultResolution((DWORD)m_wClocksPerBeat);
	pISegment->SetLength(m_dwClockLength); // need the length of the section!
	/////////////////////////////////////////////////////////////////
	DMUS_TEMPO_PARAM tempo;
	tempo.mtTime = 0; //ConvertTime( dwTime );
	tempo.dblTempo = (double) m_wTempo; //((double)dw) / 64;
	/////////////////////////////////////////////////////////////////
	hr = S_OK;
	// Create a Tempo Track in which to store the tempo events
	if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,NULL, IID_IDirectMusicTrack,(void**)&pDMTrack )))
	{
		GUID Guid = GUID_TempoParam;
		if ( SUCCEEDED(pDMTrack->SetParam(Guid, 0, &tempo)))
		{
			pISegment->InsertTrack( pDMTrack, 1 );
		}
	}
	// 10. Insert the three Tracks into the Segment's Track list.
	pISegment->InsertTrack(pBandTrack, 1);	
	pISegment->InsertTrack(pIStyleTrack, 1);
	pISegment->InsertTrack(pICommandTrack, 1);
	pISegment->InsertTrack(pIChordTrack, 1);

	// Note: the segment must release the track objects...
ON_END:
	if (pDMTrack) pDMTrack->Release();
	if (pIChordStream) pIChordStream->Release();
	if (pIChordTrackStream) pIChordTrackStream->Release();
	if (pICommandStream) pICommandStream->Release();
	if (pICommandTrackStream) pICommandTrackStream->Release();
	if (pCommandRIFF) pCommandRIFF->Release();
	if (pChordRIFF) pChordRIFF->Release();
	if (pS) pS->Release();
	if (pU) pU->Release();
	if (pIStyleTrack) pIStyleTrack->Release();
	if (pICommandTrack) pICommandTrack->Release();
	if (pIChordTrack) pIChordTrack->Release();
	if (pBandTrack) pBandTrack->Release();
	return hr;
}

CDMSection::CDMSection() : m_pStyle(NULL), m_pIDMBand(NULL), m_cRef(1)
{
	IncrementDLLCount();
}

CDMSection::~CDMSection()
{
    CleanUp();
	DecrementDLLCount();
}

void CDMSection::CleanUp( BOOL fStop)
{
	if(m_pIDMBand)
	{
		m_pIDMBand->Release();
	}

	// let whoever used the section release the style.
	if (m_pStyle)
	{
		m_pStyle->Release();
	}
}

static BYTE setchordbits( long lPattern )
{
LONG    i;
short   count = 0;
BYTE bBits = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( lPattern & (1L << i) )
            count++;
    }
    bBits |= CHORD_INVERT;
    if( count > 3 )
		bBits |= CHORD_FOUR;
    if( lPattern & (15L << 18L) )
		bBits |= CHORD_UPPER;
    bBits &= ~CHORD_COUNT;
    bBits |= count;
	return bBits;
}

HRESULT CDMSection::LoadChordList( LPSTREAM pStream, LPMMCKINFO pck, TList<DMChord>& ChordList )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	long		lSize;
    TListItem<DMChord>*   pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;

    lSize = pck->cksize;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
    FixBytes( FBT_SHORT, &wSizeChord );
	lSize -= cb;
	while( lSize > 0 )
	{
        pChord = new TListItem<DMChord>;
        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        }
        lSize -= wSizeChord;

        //WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->name, sizeof( pChord->name ), NULL, NULL );
        DMChord& rChord = pChord->GetItemValue();
		rChord.m_bKey = m_bRoot;
		rChord.m_dwScale = 	DEFAULT_SCALE_PATTERN;	
		rChord.m_strName = iChordSelection.wstrName;
        rChord.m_bBeat = iChordSelection.bBeat;
        rChord.m_wMeasure = iChordSelection.wMeasure;
		rChord.m_mtTime = m_wClocksPerMeasure * rChord.m_wMeasure + m_wClocksPerBeat * rChord.m_bBeat;
		// If chordpattern contains <= n notes (for an n-note chord)
		//   create a single subchord
		// Else
		//   create 2 subchords, with the 1st having the lower n notes and the 
		//   2nd having the upper n notes (assumes there are <= 2n notes)
		BYTE bBits = setchordbits( iChordSelection.aChord[0].lChordPattern );
		short nChordCount = bBits & CHORD_COUNT;
		// The root of the lower chord is the input chord's root, 
		// relative to the scale (section) root.
		BYTE bChordRoot = iChordSelection.aChord[0].bRoot;
		//	(bBits & CHORD_UPPER) ? (iChordSelection.aChord[0].bRoot  - 12) : iChordSelection.aChord[0].bRoot; 
		bChordRoot -= m_bRoot;
		if ((char) bChordRoot < 0) bChordRoot += 12;
		if ((bBits & CHORD_FOUR && nChordCount <= 4) || 
			(!(bBits & CHORD_FOUR) && nChordCount <= 3))
		{
			// single subchord with all info from input chord
			TListItem<DMSubChord>* pSubChord = new TListItem<DMSubChord>;
			if( pSubChord == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERR;
			}
			DMSubChord& rSubChord = pSubChord->GetItemValue();
			if (iChordSelection.aChord[0].lChordPattern)
			{
				rSubChord.m_dwChordPattern = iChordSelection.aChord[0].lChordPattern;
			}
			else
			{
			}
			rSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
			rSubChord.m_dwInversionPoints = 0xffffff;	// default: inversions everywhere
			rSubChord.m_dwLevels = (1 << SUBCHORD_BASS) | (1 << SUBCHORD_STANDARD_CHORD);
			rSubChord.m_bChordRoot = bChordRoot;
			rSubChord.m_bScaleRoot = m_bRoot;		// scale root is root of the section
			rChord.m_SubChordList.AddTail(pSubChord);
		}
		else
		{
			// two subchords both with scale and roots from input chord, and:
			// 1st chord: chord pattern from lower n notes of input chord
			// 2nd chord: chord pattern from upper n notes of input chord
			DWORD dwLowerSubChord = 0L;
			DWORD dwUpperSubChord = 0L;
			BYTE bUpperRoot = bChordRoot;
			DWORD dwChordPattern = iChordSelection.aChord[0].lChordPattern;
			short nIgnoreHigh = (bBits & CHORD_FOUR) ? 4 : 3;
			short nIgnoreLow = (bBits & CHORD_FOUR) ? nChordCount - 4 : nChordCount - 3;
			short nLowestUpper = 0;
			for (short nPos = 0, nCount = 0; nPos < 24; nPos++)
			{
				if (dwChordPattern & 1)
				{
					if (nCount < nIgnoreHigh)
					{
						dwLowerSubChord |= 1L << nPos;
					}
					if (nCount >= nIgnoreLow)
					{
						if (!nLowestUpper)
						{
							nLowestUpper = nPos;
							bUpperRoot = (bUpperRoot + (BYTE) nLowestUpper);
						}
						dwUpperSubChord |= 1L << (nPos - nLowestUpper);
					}
					nCount++;
					if (nCount >= nChordCount)
						break;
				}
				dwChordPattern >>= 1L;
			}
			// now, create the two subchords.
			TListItem<DMSubChord>* pLowerSubChord = new TListItem<DMSubChord>;
			if( pLowerSubChord == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERR;
			}
			DMSubChord& rLowerSubChord = pLowerSubChord->GetItemValue();
			rLowerSubChord.m_dwChordPattern = dwLowerSubChord;
			rLowerSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
			rLowerSubChord.m_dwInversionPoints = 0xffffff;	// default: inversions everywhere
			rLowerSubChord.m_dwLevels = (1 << SUBCHORD_BASS);
			rLowerSubChord.m_bChordRoot = bChordRoot;
			rLowerSubChord.m_bScaleRoot = m_bRoot;		// scale root is root of the section
			rChord.m_SubChordList.AddTail(pLowerSubChord);
			TListItem<DMSubChord>* pUpperSubChord = new TListItem<DMSubChord>;
			if( pUpperSubChord == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERR;
			}
			DMSubChord& rUpperSubChord = pUpperSubChord->GetItemValue();
			rUpperSubChord.m_dwChordPattern = dwUpperSubChord;
			rUpperSubChord.m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
			rUpperSubChord.m_dwInversionPoints = 0xffffff;	// default: inversions everywhere
			rUpperSubChord.m_dwLevels = (1 << SUBCHORD_STANDARD_CHORD);
			rUpperSubChord.m_bChordRoot = bUpperRoot % 24;
			while (rUpperSubChord.m_bChordRoot < rLowerSubChord.m_bChordRoot)
				rUpperSubChord.m_bChordRoot += 12;
			rUpperSubChord.m_bScaleRoot = m_bRoot;		// scale root is root of the section
			rChord.m_SubChordList.AddTail(pUpperSubChord);
		}

		ChordList.AddTail(pChord);
    }
ON_ERR:
    return hr;
}

HRESULT CDMSection::LoadCommandList( LPSTREAM pStream, LPMMCKINFO pck, TList<DMCommand>& CommandList )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	long		lSize;
    TListItem<DMCommand>* pCommand;
    ioCommand   iCommand;
    WORD        wSizeCommand;

    lSize = pck->cksize;
    // load size of command structure
    hr = pStream->Read( &wSizeCommand, sizeof( wSizeCommand ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeCommand ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
    FixBytes( FBT_SHORT, &wSizeCommand );
	lSize -= cb;
	while( lSize > 0 )
	{
        pCommand = new TListItem<DMCommand>;
        if( pCommand == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }
        if( wSizeCommand > sizeof( ioCommand ) )
        {
            hr = pStream->Read( &iCommand, sizeof( ioCommand ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioCommand ) )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCOMMAND, &iCommand );
            StreamSeek( pStream, wSizeCommand - sizeof( ioCommand ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iCommand, wSizeCommand, &cb );
            if( FAILED( hr ) || cb != wSizeCommand )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOCOMMAND, &iCommand );
        }
        lSize -= wSizeCommand;

		DMCommand& rCommand = pCommand->GetItemValue();
		////////////////////////////////////////////////////////////////////
		// Change this from absolute time to measures and beats!
		////////////////////////////////////////////////////////////////////
		 // To convert clock time to measures and beats:
		 // 1. Use clocksPerMeasure to find the measure
		 // 2. Use clocksPerBeat to find the beat
		 //DWORD dwClocks = rCommand.m_dwTime - m_dwTime;
		 rCommand.m_wMeasure = (WORD) (ConvertTime(iCommand.lTime) / m_wClocksPerMeasure); // assumes 1st measure is 0
		 rCommand.m_bBeat = (BYTE) ((ConvertTime(iCommand.lTime) % m_wClocksPerMeasure) / m_wClocksPerBeat); // ditto
         rCommand.m_mtTime = ConvertTime(iCommand.lTime);
		/////////////////////////////////////////////////////////////////////
		 switch (iCommand.dwCommand & PF_RIFF)
		 {
		 case PF_INTRO:
			 rCommand.m_bCommand = DMUS_COMMANDT_INTRO;
			 break;
		 case PF_END:
			 rCommand.m_bCommand = DMUS_COMMANDT_END;
			 break;
		 case PF_BREAK:
			 rCommand.m_bCommand = DMUS_COMMANDT_BREAK;
			 break;
		 case PF_FILL:
			 rCommand.m_bCommand = DMUS_COMMANDT_FILL;
			 break;
		 default:
			 rCommand.m_bCommand = DMUS_COMMANDT_GROOVE;
		 }
		 switch (iCommand.dwCommand & PF_GROOVE)
		 {
		 case PF_A:
			 rCommand.m_bGrooveLevel = 12; 
			 break;
		 case PF_B:
			 rCommand.m_bGrooveLevel = 37; 
			 break;
		 case PF_C:
			 rCommand.m_bGrooveLevel = 62; 
			 break;
		 case PF_D:
			 rCommand.m_bGrooveLevel = 87; 
			 break;
		 default:
			 rCommand.m_bGrooveLevel = 0;
		 }
		 rCommand.m_bGrooveRange = 0;
		 rCommand.m_bRepeatMode = DMUS_PATTERNT_RANDOM;

		CommandList.AddTail(pCommand);
    }
ON_ERR:
    return hr;
}

HRESULT CDMSection::LoadStyleReference( LPSTREAM pStream, MMCKINFO* pck)
{
    HRESULT hr;
    DWORD   cb;
	DWORD	cSize;
    //char    szName[40];
	wchar_t	wstrName[40];
    //IAALoader* pLoader;

    cSize = min( pck->cksize, sizeof( wstrName ) );
    hr = pStream->Read( wstrName, cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
	{
        return E_FAIL;
	}
	m_strStyleName = wstrName;
	DMUS_OBJECTDESC ObjectDescript;
	ObjectDescript.dwSize = sizeof(DMUS_OBJECTDESC);
	ObjectDescript.guidClass = CLSID_DirectMusicStyle;
	wcscpy(ObjectDescript.wszName, wstrName);
	ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_NAME;
	IDirectMusicLoader* pLoader;
	IDirectMusicGetLoader *pIGetLoader;  // <==============
	hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );// <========
	if (SUCCEEDED(hr))
	{
		hr = pIGetLoader->GetLoader(&pLoader);  // <========
		if (SUCCEEDED(hr))                      // <========
		{                                       // <========
			hr = pLoader->GetObject(&ObjectDescript,IID_IDirectMusicStyle, (void**)&m_pStyle);
			pLoader->Release();
		}                                       // <========
		pIGetLoader->Release();                 // <========
	}
    return hr;
}



HRESULT CDMSection::LoadSection( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    HRESULT     hr = S_OK;
    HRESULT     hrBand = S_OK;
    ioSection   iSection;
    MMCKINFO    ck;
	DWORD		cb;
	DWORD		cSize;
	IStream*	pStream;
	BOOL		fLoadedSection = FALSE;

    pStream = pRIFF->GetStream();
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
        case FOURCC_SECTION:
            cSize = min( ck.cksize, sizeof( iSection ) );
            hr = pStream->Read( &iSection, cSize, &cb );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            FixBytes( FBT_IOSECTION, &iSection );

			m_strName = iSection.wstrName;
            m_dwTime = iSection.lTime;
            m_wTempo = iSection.wTempo;
			// wRepeats refers to repeats after the first play.
            m_wRepeats = iSection.wRepeats;
            m_wMeasureLength = iSection.wMeasureLength;
            m_wClocksPerMeasure = ConvertTime(iSection.wClocksPerMeasure);
            m_wClocksPerBeat = ConvertTime(iSection.wClocksPerBeat);
            m_wTempoFract = iSection.wTempoFract;
            m_dwFlags = iSection.dwFlags;
			m_bRoot = (char)( iSection.chKey & ~KEY_FLAT );
            m_dwClockLength = (long)m_wMeasureLength * (long)m_wClocksPerMeasure;

			fLoadedSection = TRUE;
            break;
		case FOURCC_STYLEREF:
            if( fLoadedSection )
            {
                hr = LoadStyleReference( pStream, &ck );
				if (hr != S_OK)
				{
					hrBand = hr;
				}
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;

		case FOURCC_RIFF:
			switch(ck.fccType)
			{
				case FOURCC_BAND_FORM:
				{
					// Create a band
					hr = DirectMusicCreateInstance(CLSID_DirectMusicBand,NULL,IID_IDirectMusicBand,(void**)&m_pIDMBand);
					if(SUCCEEDED(hr))
					{
						// Seek back to begining of Riff chunk
						// This is the amount read by Descend when descending into a FOURCC_RIFF chunk
						// Get current position
						LARGE_INTEGER li;
						ULARGE_INTEGER ul;
						li.HighPart = 0;
						li.LowPart = 0;
						hr = pStream->Seek(li,
										   STREAM_SEEK_CUR,
										   &ul);
						
						if(SUCCEEDED(hr))
						{
							li.HighPart = 0;
							// This is always a valid operation
							li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
							hr = pStream->Seek(li, 
											   STREAM_SEEK_SET,
											   &ul);
						}
					}

					if(SUCCEEDED(hr))
					{
						// Load band
						IPersistStream* pIPersistStream;
						hr = m_pIDMBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
						
						if(SUCCEEDED(hr))
						{
							hr = pIPersistStream->Load(pStream);
							if (hr != S_OK)
							{
								hrBand = hr;
							}
							pIPersistStream->Release();
						}
					}
					
					if(FAILED(hr))
					{
						goto ON_ERR;
					}
				}	
				break;
			}
			break;

        case FOURCC_CHORD:
            if( fLoadedSection )
            {
                hr = LoadChordList( pStream, &ck, m_ChordList );
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;
        case FOURCC_COMMAND:
            if( fLoadedSection )
            {
                hr = LoadCommandList( pStream, &ck, m_CommandList );
                if( FAILED( hr ) )
                {
                    goto ON_ERR;
                }
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }


ON_ERR:
    if( FAILED( hr ) )
    {
        if(m_pIDMBand)
		{
			m_pIDMBand->Release();
            m_pIDMBand = NULL;
		}
    }
    pStream->Release( );
	if (hr == S_OK && hrBand != S_OK)
	{
		hr = hrBand;
	}
    return hr;
}

HRESULT CDMSection::Load(
						LPSTREAM pStream )	// Pointer to a stream that contains the
											// Section information to load.
{
    DWORD dwPos;
    IAARIFFStream*  pRIFF;
    MMCKINFO        ckMain;
    HRESULT         hr;

    if ( pStream == NULL ) return E_INVALIDARG;
    hr = E_FAIL;
    CleanUp( FALSE );

    dwPos = StreamTell( pStream );

    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = FOURCC_SECTION_FORM;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = LoadSection( pRIFF, &ckMain );
            pRIFF->Ascend( &ckMain, 0 );
        }
        pRIFF->Release( );
    }
    return hr;
}



DMChord::DMChord(DMUS_CHORD_PARAM& DMC)
{
	m_strName = DMC.wszName;
	m_wMeasure = DMC.wMeasure;
	m_bBeat = DMC.bBeat;
	m_bKey = DMC.bKey;
	m_dwScale = DMC.dwScale;
	m_fSilent = (DMC.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
	for (BYTE n = 0; n < DMC.bSubChordCount; n++)
	{
		TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(DMC.SubChordList[n]);
		if (pSub)
		{
			m_SubChordList.AddTail(pSub);
		}
	}
}

DMChord::DMChord(DMChord& DMC)
{
	m_strName = DMC.m_strName;
	m_wMeasure = DMC.m_wMeasure;
	m_bBeat = DMC.m_bBeat;
	m_bKey = DMC.m_bKey;
	m_dwScale = DMC.m_dwScale;
	m_fSilent = DMC.m_fSilent;
	TListItem<DMSubChord>* pScan = DMC.m_SubChordList.GetHead();
	for (; pScan != NULL; pScan = pScan->GetNext())
	{
		TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(pScan->GetItemValue());
		if (pSub)
		{
			m_SubChordList.AddTail(pSub);
		}
	}
}

DMChord& DMChord::operator=(const DMChord& DMC)
{
	if (this != &DMC)
	{
		m_strName = DMC.m_strName;
		m_wMeasure = DMC.m_wMeasure;
		m_bBeat = DMC.m_bBeat;
		m_bKey = DMC.m_bKey;
		m_dwScale = DMC.m_dwScale;
		m_fSilent = DMC.m_fSilent;
		m_SubChordList.CleanUp();
		TListItem<DMSubChord>* pScan = DMC.m_SubChordList.GetHead();
		for (; pScan != NULL; pScan = pScan->GetNext())
		{
			TListItem<DMSubChord>* pSub = new TListItem<DMSubChord>(pScan->GetItemValue());
			if (pSub)
			{
				m_SubChordList.AddTail(pSub);
			}
		}
	}
	return *this;
}

DMChord::operator DMUS_CHORD_PARAM()
{
	DMUS_CHORD_PARAM result;
	wcscpy(result.wszName, m_strName);
	result.wMeasure = m_wMeasure;
	result.bBeat = m_bBeat;
	result.bKey = m_bKey;
	result.dwScale = m_dwScale;
	result.bFlags = 0;
	if (m_fSilent) result.bFlags |= DMUS_CHORDKEYF_SILENT;
	BYTE n = 0;
	TListItem<DMSubChord>* pSub = m_SubChordList.GetHead();
	for (; pSub != NULL; pSub = pSub->GetNext(), n++)
	{
		result.SubChordList[n] = pSub->GetItemValue();
	}
	result.bSubChordCount = n;
	return result;
}

HRESULT DMChord::Save( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    MMCKINFO    ck;
    DWORD       cb;
    DMUS_IO_CHORD	iChord;
	DMUS_IO_SUBCHORD	iSubChord;
    DWORD        dwSize;
	HRESULT hr = E_FAIL;

    pStream = pRIFF->GetStream();
    ck.ckid = mmioFOURCC('c','r','d','b');
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
		memset( &iChord, 0, sizeof( iChord ) );
		m_strName = iChord.wszName;
		//MultiByteToWideChar( CP_ACP, 0, m_strName, -1, iChord.wszName, sizeof( iChord.wszName ) / sizeof( wchar_t ) );
		iChord.mtTime = m_mtTime;
		iChord.wMeasure = m_wMeasure;
		iChord.bBeat = m_bBeat;
		iChord.bFlags = 0;
		if (m_fSilent) iChord.bFlags |= DMUS_CHORDKEYF_SILENT;
		dwSize = sizeof( iChord );
		hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
		if( SUCCEEDED(hr) &&
			SUCCEEDED( pStream->Write( &iChord, sizeof( iChord), &cb ) ) &&
			cb == sizeof( iChord) ) // &&
			//pRIFF->Ascend( &ck, 0 ) == 0 )
		{
			//ck.ckid = mmioFOURCC('s','u','b','c');
			//if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
			{
				DWORD dwCount = (WORD) m_SubChordList.GetCount();
				hr = pStream->Write( &dwCount, sizeof( dwCount ), &cb );
				if( FAILED( hr ) || cb != sizeof( dwSize ) )
				{
					pStream->Release();
					return E_FAIL;
				}
				dwSize = sizeof( iSubChord );
				hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
				if( FAILED( hr ) || cb != sizeof( dwSize ) )
				{
					pStream->Release();
					return E_FAIL;
				}
				for (TListItem<DMSubChord>* pSub = m_SubChordList.GetHead(); pSub != NULL; pSub = pSub->GetNext())
				{
					DMSubChord& rSubChord = pSub->GetItemValue();
					memset( &iSubChord, 0, sizeof( iSubChord ) );
					iSubChord.dwChordPattern = rSubChord.m_dwChordPattern;
					iSubChord.dwScalePattern = rSubChord.m_dwScalePattern;
					iSubChord.dwInversionPoints = rSubChord.m_dwInversionPoints;
					iSubChord.dwLevels = rSubChord.m_dwLevels;
					iSubChord.bChordRoot = rSubChord.m_bChordRoot;
					iSubChord.bScaleRoot = rSubChord.m_bScaleRoot;
					if( FAILED( pStream->Write( &iSubChord, sizeof( iSubChord ), &cb ) ) ||
						cb != sizeof( iSubChord ) )
					{
						break;
					}
				}
				// ascend from chord body chunk
				if( pSub == NULL &&
					pRIFF->Ascend( &ck, 0 ) != 0 )
				{
					hr = S_OK;
				}
			}
		}
	}
	pStream->Release();
	return hr;
}


HRESULT CDMSection::SaveChordList( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    //LPSECT      pSection;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    HRESULT     hr;
    DWORD       cb;
    //WORD        wSize;
    TListItem<DMChord>*   pChord;
    //int         i;


    pStream = pRIFF->GetStream();
    //pSection = (LPSECT)m_pSection->lpDLL1;

	ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
	hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
	if (SUCCEEDED(hr))
    {
       // wSize = sizeof( ioChordSelection );
		//FixBytes( FBT_SHORT, &wSize );
       // hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
       // if( FAILED( hr ) || cb != sizeof( wSize ) )
       // {
       //     RELEASE( pStream );
       //     return E_FAIL;
        //}

		DWORD dwRoot = m_bRoot;
		const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
		DWORD dwScale = DEFAULT_SCALE_PATTERN | (dwRoot << 24);

		ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
		hr = pRIFF->CreateChunk(&ckHeader, 0);
		if (FAILED(hr))
		{
			pStream->Release();
			return hr;
		}
		hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
		if (FAILED(hr))
		{
			pStream->Release();
			return hr;
		}
		hr = pRIFF->Ascend( &ckHeader, 0 );
		if (hr != 0)
		{
			pStream->Release();
			return hr;
		}

        for( pChord = m_ChordList.GetHead() ; pChord != NULL ; pChord = pChord->GetNext() )
        {
			hr = pChord->GetItemValue().Save(pRIFF);
			if (FAILED(hr))
			{
				pStream->Release();
				return hr;
			}
        }
        if( pChord == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}


HRESULT CDMSection::SaveCommandList( IAARIFFStream* pRIFF )
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD       dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<DMCommand>* pCommand;

    pStream = pRIFF->GetStream();
	if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
			DMCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = rCommand.m_mtTime;
            iCommand.wMeasure = rCommand.m_wMeasure;
			iCommand.bBeat = rCommand.m_bBeat;
            iCommand.bCommand = rCommand.m_bCommand;
			iCommand.bGrooveLevel = rCommand.m_bGrooveLevel;
 			iCommand.bGrooveRange = rCommand.m_bGrooveRange;
 			iCommand.bRepeatMode = rCommand.m_bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}


HRESULT CDMSection::Save(
						LPSTREAM pStream,		// Stream to store Section.
						BOOL /*fClearDirty*/ )	// TRUE to clear dirty flag, FALSE to leave
												// dirty flag unchanged.
{
    IAARIFFStream*  pRIFF;
    HRESULT         hr;
    MMCKINFO        ckMain;

    hr = E_FAIL;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = FOURCC_SECTION_FORM;
        if( pRIFF->CreateChunk( &ckMain, MMIO_CREATERIFF ) != 0 )
        {
            goto ON_ERR;
        }

        if( FAILED( SaveChordList( pRIFF ) ) ||
            FAILED( SaveCommandList( pRIFF ) ) )
        {
            goto ON_ERR;
        }

        if( pRIFF->Ascend( &ckMain, 0 ) != 0 )
        {
            goto ON_ERR;
        }
        hr = S_OK;
ON_ERR:
        pRIFF->Release();
    }
    return hr;
}



/* IPersist methods */
 HRESULT CDMSection::GetClassID( LPCLSID pclsid )
{
    return E_NOTIMPL;
}

 HRESULT CDMSection::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CDMSection::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\motiftrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       motiftrk.h
//
//--------------------------------------------------------------------------

// MotifTrk.h : Declaration of the CMotifTrack

#ifndef __MOTIFTRACK_H_
#define __MOTIFTRACK_H_

//#include "resource.h"       // main symbols
#include "Ptrntrk.h"

struct MotifTrackInfo : public PatternTrackInfo
{
	MotifTrackInfo();
	MotifTrackInfo(const MotifTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd), 
		  m_pPattern(NULL)	
	{
		m_dwPatternTag = DMUS_PATTERN_MOTIF;
		if (pInfo)
		{
			m_pPattern = pInfo->m_pPattern;
			InitTrackVariations(m_pPattern);
			if (m_pPattern) m_pPattern->AddRef();
		}
	}
	~MotifTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

	CDirectMusicPattern*		m_pPattern; // The motif's pattern
};

/////////////////////////////////////////////////////////////////////////////
// CMotifTrack
class CMotifTrack : 
	public IMotifTrack,
	public IDirectMusicTrack8,
	public IPersistStream

{
public:
	CMotifTrack();
	CMotifTrack(const CMotifTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CMotifTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IMotifTrack
public:
// IMotifTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID	rCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);


// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;


// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle, void* pPattern);


// IMotifTrack data members
protected:
// new internal play method
HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
			);

	// attributes
    long m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct MotifTrackState : public PatternTrackState
{
	MotifTrackState();
	~MotifTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime

			);


	// attributes
	MUSIC_TIME					m_mtMotifStart;		// When the motif started relative to
													// its primary segment
};


#endif //__MOTIFTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstyle.cpp ===
// DMStyle.cpp : Implementation of CDMStyle
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

#ifdef XBOX
#include <xtl.h>
#endif // XBOX

#include "DMStyle.h"
#include "score.h"
#include "..\shared\critsec.h"
#include "..\dmband\dmbandp.h"
#include "..\shared\Validate.h"
#include "..\shared\miscutil.h"
#include <mmreg.h>
#include "dmsect.h"
#include "ptrntrk.h"
#include "StyleTrk.h"
#include "..\shared\dmscriptautguids.h"
#include "..\shared\xcreate.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif

V_INAME(DMStyle)

#define NBR_VARIATIONS 32
#define DX8_PART_SIZE 160
#define DX8_PARTREF_SIZE 28

DirectMusicTimeSig DefaultTimeSig(4, 4, 4);

static char achMappings[128] = {
         0,         //0 },
         35,        //1  },
         36,        //2  },
         38,        //3  },
         40,        //4  },
         41,        //5  },
         45,        //6  },
         48,        //7  },
         42,        //8  },
         44,        //9  },
         46,        //10 },
         39,        //11 },
         37,        //12 },
         51,        //13 },
         49,        //14 },
         54,        //15 },
         56,        //16 },
         61,        //17 },
         60,        //18 },
         64,        //19 },
         63,        //20 },
         66,        //21 },
         65,        //22 },
         69,        //23 },
         70,        //24 },
         71,        //25 },
         72,        //26 },
         73,        //27 },
         75,        //28 },
         47,        //29 },
         50,        //30 },
         53,        //31 },
         57,        //32 },
         52,        //33 },
         74,        //34 },
         35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
         55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
         75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
         95, 96, 97, 98,
         87,        //99 },
         86,        //100 },
         85,        //101 },
         84,        //102 },
         83,        //103 },
         82,        //104 },
         81,        //105 },
         80,        //106 },
         79,        //107 },
         78,        //108 },
         77,        //109 },
         76,        //110 },
         68,        //111 },
         67,        //112 },
         62,        //113 },
         59,        //114 },
         58,        //115 },
         55,        //116 },
         43,        //117 },
         34,        //118 },
         33,        //119 },
         32,        //120 },
         31,        //121 },
         30,        //122 },
         29,        //123 },
         28,        //124 },
         27,        //125 },
         26,        //126 },
         25,        //127 }
};

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

HRESULT ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, String& pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwBytesRead;
    
    pstrText = "";
    
    wstrText = new wchar_t[dwSize];
    if( wstrText == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERR;
    }

    hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
    if( FAILED( hr ) ||  dwBytesRead != dwSize )
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        goto ON_ERR;
    }

    pstrText = wstrText;
    
ON_ERR:
    if( wstrText )
    {
        delete [] wstrText;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SaveMBStoWCS

HRESULT SaveMBStoWCS( IStream* pIStream, String* pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwLength;
    DWORD       dwBytesWritten;
        
    if( pstrText == NULL )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }

    dwLength = pstrText->GetLength() + 1;
    wstrText = new wchar_t[dwLength];
    if( wstrText == NULL )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }

     wcscpy(wstrText, *pstrText);
    dwLength *= sizeof(wchar_t);

    hr = pIStream->Write( wstrText, dwLength, &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != dwLength )
    {
        goto ON_ERR;
    }

ON_ERR:
    if( wstrText )
        delete [] wstrText;
    return hr;
}

DirectMusicPart::DirectMusicPart(DirectMusicTimeSig *pTimeSig) :
    m_cRef(1), 
    m_wNumMeasures(1),
    m_bPlayModeFlags(DMUS_PLAYMODE_NORMALCHORD), 
    m_bInvertLower(0), 
    m_bInvertUpper(127),
    m_dwFlags(0)
{
    memset(&m_guidPartID, 0, sizeof(GUID));

    if (pTimeSig)
    {
        m_timeSig = *pTimeSig;
    }

    for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
    {
        m_dwVariationChoices[i] = 0;    
    }

}

STDMETHODIMP_(ULONG) DirectMusicPart::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) DirectMusicPart::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_LoadPart

HRESULT DirectMusicPart::DM_LoadPart( 
        IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwByteCount;
    long lSize;
    DWORD dwStructSize;
    WORD wExtra;

    if( pStyle == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if( pIStream == NULL ) return E_FAIL;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PART_CHUNK:
            {
                DMUS_IO_STYLEPART iDMStylePart;
                memset(&iDMStylePart, 0, sizeof(iDMStylePart));

                lSize = min( ck.cksize, sizeof( DMUS_IO_STYLEPART ) );
                if (ck.cksize >= DX8_PART_SIZE) pStyle->m_dwFlags |= STYLEF_USING_DX8;
                hr = pIStream->Read( &iDMStylePart, lSize, &dwByteCount );
                if( FAILED( hr ) ||  (long)dwByteCount != lSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                if( pStyle->FindPartByGUID( iDMStylePart.guidPartID ) )
                {
                    hr = S_FALSE;   // Style already contains a Part with this GUID
                    goto ON_ERROR;  // so we must bypass this Part
                }

                m_timeSig.m_bBeatsPerMeasure = iDMStylePart.timeSig.bBeatsPerMeasure;
                m_timeSig.m_bBeat = iDMStylePart.timeSig.bBeat;
                m_timeSig.m_wGridsPerBeat = iDMStylePart.timeSig.wGridsPerBeat;

                m_wNumMeasures = iDMStylePart.wNbrMeasures;
                m_bInvertUpper = iDMStylePart.bInvertUpper;
                m_bInvertLower = iDMStylePart.bInvertLower;
                m_bPlayModeFlags = iDMStylePart.bPlayModeFlags;
                m_dwFlags = iDMStylePart.dwFlags;

                memcpy( &m_guidPartID, &iDMStylePart.guidPartID, sizeof(GUID) );
                memcpy( &m_dwVariationChoices, &iDMStylePart.dwVariationChoices, sizeof(m_dwVariationChoices) );

                for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
                {
                    if( m_dwVariationChoices[i] == 0xFFFFFFFF )
                    {
                        m_dwVariationChoices[i] = 0x3FFFFFFF;   
                    }
                    if (pStyle->UsingDX8() && m_dwVariationChoices[i] == 0x3FFFFFFF)
                    {
                        m_dwVariationChoices[i] = 0x7FFFFFFF;   
                    }
                }
                break;
            }

            case DMUS_FOURCC_NOTE_CHUNK:
            {
                CDMStyleNote* pNote;
                DMUS_IO_STYLENOTE iDMStyleNote;
                memset(&iDMStyleNote, 0, sizeof(DMUS_IO_STYLENOTE));

                lSize = ck.cksize;

                // Read size of the note structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLENOTE ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLENOTE ) );
                    dwStructSize = sizeof( DMUS_IO_STYLENOTE );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the notes
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleNote, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Note (if note event is legal)
                    if (iDMStyleNote.mtGridStart >= 0)
                    {
                        pNote = new CDMStyleNote;
                        if( pNote )
                        {
                            pNote->m_nGridStart = (short)iDMStyleNote.mtGridStart;
                            pNote->m_dwVariation = iDMStyleNote.dwVariation;
                            pNote->m_mtDuration = iDMStyleNote.mtDuration;
                            pNote->m_nTimeOffset = iDMStyleNote.nTimeOffset;

                            pNote->m_wMusicValue = iDMStyleNote.wMusicValue;
                            pNote->m_bVelocity = iDMStyleNote.bVelocity;
                            pNote->m_bTimeRange = iDMStyleNote.bTimeRange;
                            pNote->m_bDurRange = iDMStyleNote.bDurRange;
                            pNote->m_bVelRange = iDMStyleNote.bVelRange;
                            pNote->m_bInversionId = iDMStyleNote.bInversionID; 
                            pNote->m_bPlayModeFlags = iDMStyleNote.bPlayModeFlags;
                            pNote->m_bFlags = iDMStyleNote.bNoteFlags;

                            // Place note in Part's event list
                            EventList.AddHead( pNote ); 
                        }
                    }
                }
                break;
            }

            case DMUS_FOURCC_CURVE_CHUNK:
            {
                CDMStyleCurve* pCurve;
                DMUS_IO_STYLECURVE iDMStyleCurve;
                memset(&iDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE));

                lSize = ck.cksize;

                // Read size of the curve structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLECURVE ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLECURVE ) );
                    dwStructSize = sizeof( DMUS_IO_STYLECURVE );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the curves
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleCurve, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Curve (if curve event is legal)
                    if (iDMStyleCurve.mtGridStart >= 0)
                    {
                        pCurve = new CDMStyleCurve;
                        if( pCurve )
                        {
                            pCurve->m_nGridStart = (short)iDMStyleCurve.mtGridStart;
                            pCurve->m_dwVariation = iDMStyleCurve.dwVariation;
                            pCurve->m_mtDuration = iDMStyleCurve.mtDuration;
                            pCurve->m_nTimeOffset = iDMStyleCurve.nTimeOffset;

                            pCurve->m_StartValue = iDMStyleCurve.nStartValue;
                            pCurve->m_EndValue = iDMStyleCurve.nEndValue;
                            pCurve->m_bEventType = iDMStyleCurve.bEventType;
                            pCurve->m_bCurveShape = iDMStyleCurve.bCurveShape;
                            pCurve->m_bCCData = iDMStyleCurve.bCCData;

                            pCurve->m_mtResetDuration = iDMStyleCurve.mtResetDuration;
                            pCurve->m_nResetValue = iDMStyleCurve.nResetValue;
                            pCurve->m_bFlags = iDMStyleCurve.bFlags;
                            // dx8 stuff
                            // Sometimes, we get a pitch bend in a file that has bogus data in wParamType, which will
                            // cause pitch bend range to be set incorrectly.
                            if (pCurve->m_bEventType == DMUS_CURVET_PBCURVE)
                            {
                                pCurve->m_wParamType = 0;
                            }
                            else
                            {
                                pCurve->m_wParamType = iDMStyleCurve.wParamType;
                            }
                            pCurve->m_wMergeIndex = iDMStyleCurve.wMergeIndex;
                            // Place curve in Part's event list
                            EventList.AddHead( pCurve ); 
                        }
                    }
                }
                break;
            }

            case DMUS_FOURCC_MARKER_CHUNK:
            {
                CDMStyleMarker* pMarker;
                DMUS_IO_STYLEMARKER iDMStyleMarker;
                memset(&iDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER));

                lSize = ck.cksize;

                // Read size of the marker structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLEMARKER ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLEMARKER ) );
                    dwStructSize = sizeof( DMUS_IO_STYLEMARKER );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the markers
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleMarker, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Marker (if marker event is legal)
                    if (iDMStyleMarker.mtGridStart >= 0)
                    {
                        pMarker = new CDMStyleMarker;
                        if( pMarker )
                        {
                            pMarker->m_nGridStart = (short)iDMStyleMarker.mtGridStart;
                            pMarker->m_dwVariation = iDMStyleMarker.dwVariation;
                            pMarker->m_nTimeOffset = 0; // ignore offsets
                            pMarker->m_wFlags = iDMStyleMarker.wMarkerFlags;
                            // Place marker in Part's event list
                            EventList.AddHead( pMarker ); 
                        }
                    }
                }
                break;
            }
            case DMUS_FOURCC_ANTICIPATION_CHUNK:
            {
                CDMStyleAnticipation* pAnticipation;
                DMUS_IO_STYLE_ANTICIPATION iDMStyleAnticipation;
                memset(&iDMStyleAnticipation, 0, sizeof(DMUS_IO_STYLE_ANTICIPATION));

                lSize = ck.cksize;

                // Read size of the anticipation structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLE_ANTICIPATION ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLE_ANTICIPATION ) );
                    dwStructSize = sizeof( DMUS_IO_STYLE_ANTICIPATION );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the markers
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleAnticipation, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music Anticipation (if anticipation event is legal)
                    if (iDMStyleAnticipation.mtGridStart >= 0)
                    {
                        pAnticipation = new CDMStyleAnticipation;
                        if( pAnticipation )
                        {
                            pAnticipation->m_nGridStart = (short)iDMStyleAnticipation.mtGridStart;
                            pAnticipation->m_dwVariation = iDMStyleAnticipation.dwVariation;
                            pAnticipation->m_nTimeOffset = iDMStyleAnticipation.nTimeOffset;
                            pAnticipation->m_bTimeRange = iDMStyleAnticipation.bTimeRange;
                            // Place anticipation in Part's event list
                            EventList.AddHead( pAnticipation ); 
                        }
                    }
                }
                break;
            }
            case DMUS_FOURCC_RESOLUTION_CHUNK:
            {
                TListItem<DMUS_IO_STYLERESOLUTION>* pResolutionItem;
                DMUS_IO_STYLERESOLUTION iDMStyleResolution;
                memset(&iDMStyleResolution, 0, sizeof(DMUS_IO_STYLERESOLUTION));

                lSize = ck.cksize;

                // Read size of the resolution structure
                hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof( dwStructSize ) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                lSize -= dwByteCount;

                if( dwStructSize > sizeof( DMUS_IO_STYLERESOLUTION ) )
                {
                    wExtra = static_cast<WORD>( dwStructSize - sizeof( DMUS_IO_STYLERESOLUTION ) );
                    dwStructSize = sizeof( DMUS_IO_STYLERESOLUTION );
                }
                else
                {
                    wExtra = 0;
                }

                // now read in the resolutions
                while( lSize > 0 )
                {
                    hr = pIStream->Read( &iDMStyleResolution, dwStructSize, &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != dwStructSize )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                    lSize -= dwStructSize;

                    if( wExtra > 0 )
                    {
                        StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
                        lSize -= wExtra;
                    }

                    // Create Direct Music resolution
                    pResolutionItem = new TListItem<DMUS_IO_STYLERESOLUTION>;
                    if( pResolutionItem )
                    {
                        pResolutionItem->GetItemValue() = iDMStyleResolution;
                        // Place marker in Part's resolution list
                        m_ResolutionList.AddHead( pResolutionItem ); 
                    }
                }
                break;
            }
        }

        pIRiffStream->Ascend( &ck, 0 );

    }
    // Sort the Event List
    EventList.MergeSort(m_timeSig);

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDMStyle

STDMETHODIMP CDMStyle::QueryInterface(
    const IID &iid,   // Interface to query for
    void **ppv)       // The requested interface will be returned here
{
    V_INAME(CDMStyle::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicStyle)
    {
        *ppv = static_cast<IDirectMusicStyle*>(this);
    }
    else if (iid == IID_IDirectMusicStyle8)
    {
        *ppv = static_cast<IDirectMusicStyle8*>(this);
        m_StyleInfo.m_dwFlags |= STYLEF_USING_DX8;
    }
#ifdef DXAPI
    else if (iid == IID_IDirectMusicStyle8P)
    {
        *ppv = static_cast<IDirectMusicStyle8P*>(this);
    }
#endif
    else if (iid == IID_IDMStyle)
    {
        *ppv = static_cast<IDMStyle*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMStyle::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMStyle::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicStyle;
    if (m_StyleInfo.m_fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }
    if (m_StyleInfo.m_guid.Data1 || m_StyleInfo.m_guid.Data2)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_StyleInfo.m_guid;
    }
    if (m_StyleInfo.m_strCategory)
    {
        pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
        wcscpy(pDesc->wszCategory, m_StyleInfo.m_strCategory);
    }
    if (m_StyleInfo.m_strName)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcscpy(pDesc->wszName, m_StyleInfo.m_strName);
    }
    if (m_StyleInfo.m_dwVersionMS || m_StyleInfo.m_dwVersionLS)
    {
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
        pDesc->vVersion.dwVersionMS = m_StyleInfo.m_dwVersionMS;
        pDesc->vVersion.dwVersionLS = m_StyleInfo.m_dwVersionLS;
    }
    return S_OK;
}

HRESULT CDMStyle::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::SetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_StyleInfo.m_guid = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            m_StyleInfo.m_strName = pDesc->wszName;
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            m_StyleInfo.m_strCategory = pDesc->wszCategory;
            dw |= DMUS_OBJ_CATEGORY;
        }
        if ( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_StyleInfo.m_dwVersionMS = pDesc->vVersion.dwVersionMS;
            m_StyleInfo.m_dwVersionLS = pDesc->vVersion.dwVersionLS;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & (~dw) )
        {
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CDMStyle::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMStyle::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    IAARIFFStream*  pRIFF;
    MMCKINFO        ckMain;
    HRESULT         hr = S_OK;
    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    hr = AllocRIFFStream( pStream, &pRIFF );
    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_ParseDescriptor( pRIFF, &ckMain, pDesc );
            fFoundFormat = TRUE;
        }
        pRIFF->Release();
        pRIFF = NULL;
    }
    else
    {
        return hr;
    }

    // Check for IMA 2.5 format
    if( fFoundFormat )
    {
        hr = S_OK;
    }
#ifdef DXAPI
    else
    {
        MMCKINFO        ck;
        DWORD           dwPos;
        DWORD           cb;
        DWORD           cSize;
        ioStyle         iStyle;
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

        hr = AllocRIFFStream( pStream, &pRIFF );
        if( SUCCEEDED( hr ) )
        {
            ckMain.fccType = FOURCC_STYLE_FORM;

            if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDRIFF ) != 0 )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            ck.ckid = FOURCC_STYLE;
            if( pRIFF->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) != 0 )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            cSize = min( ck.cksize, sizeof( iStyle ) );
            hr = pStream->Read( &iStyle, cSize, &cb );
            FixBytes( FBT_IOSTYLE, &iStyle );
            if( FAILED( hr ) || cb != cSize )
            {
                pRIFF->Release();
                return DMUS_E_CHUNKNOTFOUND;
            }

            pDesc->dwValidData = DMUS_OBJ_CLASS;
            pDesc->guidClass = CLSID_DirectMusicStyle;

            wcscpy(pDesc->wszName,iStyle.wstrName);
            if(pDesc->wszName[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
                pDesc->wszName[16] = 0;
            }
            wcscpy(pDesc->wszCategory,iStyle.wstrCategory);
            if(pDesc->wszCategory[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                pDesc->wszCategory[16] = 0;
            }
            if(iStyle.guid.Data1 || iStyle.guid.Data2 || iStyle.guid.Data3)
            {
                pDesc->guidObject = iStyle.guid;
                pDesc->dwValidData |= DMUS_OBJ_OBJECT;
            }
            pRIFF->Release();
        }
        else
        {
            return hr;
        }
    }
#endif
    return hr;
}

// Note: this needs to be called from inside a critical section.
HRESULT CDMStyle::CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
                                     DWORD dwRepeats)
{
    HRESULT hr = S_OK;
    //1.  Create a Motif track.
    IDirectMusicTrack* pIMotifTrack = NULL;
    hr = DirectMusicCreateInstance(CLSID_DirectMusicMotifTrack,NULL,IID_IDirectMusicTrack,(void**)&pIMotifTrack);
    if (SUCCEEDED(hr))
    {
        // 2. Set the Track's Motif
        DirectMusicTimeSig& TimeSig = 
            pPattern->m_timeSig.m_bBeat == 0 ? m_StyleInfo.m_TimeSignature : pPattern->m_timeSig;
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->m_PartRefList.GetHead();
        for(; pPartRef != NULL; pPartRef = pPartRef->GetNext())
        {
            DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
            DirectMusicTimeSig& TS = 
                pPart->m_timeSig.m_bBeat == 0 ? TimeSig : pPart->m_timeSig;
            pPart->EventList.MergeSort(TS);
        }
        IMotifTrack* pIMT;
        hr = pIMotifTrack->QueryInterface(IID_IMotifTrack, (void**)&pIMT);
        if (SUCCEEDED(hr))
        {
            IDirectMusicStyle* pIDMS = NULL;
            hr = ((IDMStyle*)this)->QueryInterface(IID_IDirectMusicStyle, (void**)&pIDMS);
            hr = pIMT->SetTrack(pIDMS, pPattern);
            pIDMS->Release();
            DWORD dwLength;
            dwLength = pPattern->m_wNumMeasures * TimeSig.ClocksPerMeasure();
            // 3. Create a secondary segment for the motif.
            IDirectMusicSegment *pISegment;
            hr = DirectMusicCreateInstance(CLSID_DirectMusicSegment,NULL,IID_IDirectMusicSegment,(void**)&pISegment);
            if (SUCCEEDED(hr) )
            {
                // 4. Initialize the segment appropriately.
                pISegment->SetLength(dwLength);
                if (pPattern->m_fSettings)
                {
                    pISegment->SetRepeats(pPattern->m_dwRepeats);
                    pISegment->SetDefaultResolution(pPattern->m_dwResolution);
                    pISegment->SetStartPoint(pPattern->m_mtPlayStart);
                    pISegment->SetLoopPoints(pPattern->m_mtLoopStart, pPattern->m_mtLoopEnd);
                }
                else
                {
                    pISegment->SetRepeats(dwRepeats);
                    pISegment->SetDefaultResolution(DMUS_SEGF_BEAT);
                }
                pISegment->InsertTrack(pIMotifTrack, 1);

                // create and insert a band track, if the motif references a band
                if (pPattern->m_pMotifBand)
                {
                    IDirectMusicTrack* pBandTrack = NULL;
                    hr = DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,NULL,
                        IID_IDirectMusicTrack,(void**)&pBandTrack);
                    if (SUCCEEDED(hr))
                    {
                        DMUS_BAND_PARAM DMBandParam;
                        DMBandParam.mtTimePhysical = -64;
                        DMBandParam.pBand = pPattern->m_pMotifBand;
                        hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
                        if (SUCCEEDED(hr))
                        {
                            pISegment->InsertTrack(pBandTrack, 1);
                        }
                        pBandTrack->Release();
                    }
                }

                // Note: the segment must release the track objects...
                if (SUCCEEDED(hr))
                {
                    IUnknown *pUnknown;
                    hr = pISegment->QueryInterface(IID_IUnknown, (void**)&pUnknown);
                    if (SUCCEEDED(hr))
                    {
                        *ppSegment = pUnknown;
                        pISegment->Release();
                    }
                }
            }
            pIMT->Release();
        }
        pIMotifTrack->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveSinglePattern

HRESULT CDirectMusicPattern::DM_SaveSinglePattern( IAARIFFStream* pIRiffStream )
{
    TList<DirectMusicPart*> PartList;
    TListItem<DirectMusicPartRef>* pPartRefItem;
    TListItem<DirectMusicPart*>* pPartItem;
    DirectMusicPart* pPart;
    HRESULT hr = S_OK;
    IStream* pIStream;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

// Save Pattern chunk
    hr = DM_SavePatternChunk( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

// Save Pattern rhythm
    hr = DM_SavePatternRhythm( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

/*// Save Pattern switch points
    hr = DM_SavePatternSwitchPoints( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }*/

// Save Pattern info
    hr = DM_SavePatternInfoList( pIRiffStream );
    if( FAILED ( hr ) )
    {
        goto ON_ERROR;
    }

// Build list of Parts
    pPartRefItem = m_PartRefList.GetHead();
    for( ; pPartRefItem; pPartRefItem = pPartRefItem->GetNext() )
    {
        DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
        if( rPartRef.m_pDMPart == NULL )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }

        for (pPartItem = PartList.GetHead(); pPartItem; pPartItem = pPartItem->GetNext())
        {
            if (pPartItem->GetItemValue() == rPartRef.m_pDMPart)
                break;
        }
        if( pPartItem == NULL )
        {
            pPartItem = new TListItem<DirectMusicPart*>(rPartRef.m_pDMPart);
            if (pPartItem)
            {
                PartList.AddTail( pPartItem ); 
            }
        }
    }

// Save Parts
    pPartItem = PartList.GetHead();
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        pPart = pPartItem->GetItemValue();

        hr = pPart->DM_SavePart( pIRiffStream );
        if( FAILED ( hr ) )
        {
            goto ON_ERROR;
        }
    }

// Save Part References
    pPartRefItem = m_PartRefList.GetHead();
    for( ; pPartRefItem; pPartRefItem = pPartRefItem->GetNext() )
    {
        DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();

        hr = rPartRef.DM_SavePartRef( pIRiffStream );
        if( FAILED ( hr ) )
        {
            goto ON_ERROR;
        }
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternRhythm

HRESULT CDirectMusicPattern::DM_SavePatternRhythm( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr = S_OK;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    int i;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Rhythm chunk header
    ck.ckid = DMUS_FOURCC_RHYTHM_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save the RhythmMap for each measure
    for( i = 0 ;  i < m_wNumMeasures ;  i++ )
    {
        // Write Rhythm chunk data
        hr = pIStream->Write( &m_pRhythmMap[i], sizeof(DWORD), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DWORD) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }
    
    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternSwitchPoints

/*
HRESULT CDirectMusicPattern::DM_SavePatternSwitchPoints( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    int i;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern Switch Point chunk header
    ck.ckid = DMUS_FOURCC_SWITCH_POINT_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save the Switch Points for each measure
    for( i = 0 ;  i < m_wNumMeasures ;  i++ )
    {
        // Write Switch Point chunk data
        hr = pIStream->Write( &m_pSwitchPoints[i], sizeof(DWORD), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DWORD) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }
    
    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternInfoList

HRESULT CDirectMusicPattern::DM_SavePatternInfoList( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

    if( m_strName.IsEmpty() )
    {
        return S_OK;
    }

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write UNFO LIST header
    ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern name
    if( !m_strName.IsEmpty() )
    {
        ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
        if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }

        hr = SaveMBStoWCS( pIStream, &m_strName );
        if( FAILED( hr ) )
        {
            goto ON_ERROR;
        }

        if( pIRiffStream->Ascend(&ck, 0) != 0 )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternChunk

HRESULT CDirectMusicPattern::DM_SavePatternChunk( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_PATTERN oDMPattern;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Pattern chunk header
    ck.ckid = DMUS_FOURCC_PATTERN_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_PATTERN
    memset( &oDMPattern, 0, sizeof(DMUS_IO_PATTERN) );

    oDMPattern.timeSig.bBeatsPerMeasure = m_timeSig.m_bBeatsPerMeasure;
    oDMPattern.timeSig.bBeat = m_timeSig.m_bBeat;
    oDMPattern.timeSig.wGridsPerBeat = m_timeSig.m_wGridsPerBeat;

    oDMPattern.bGrooveBottom = m_bGrooveBottom;
    oDMPattern.bGrooveTop = m_bGrooveTop;
    oDMPattern.bDestGrooveBottom = m_bDestGrooveBottom;
    oDMPattern.bDestGrooveTop = m_bDestGrooveTop;
    oDMPattern.wEmbellishment = m_wEmbellishment;
    oDMPattern.wNbrMeasures = m_wNumMeasures;
    oDMPattern.dwFlags = m_dwFlags;

    // Write Pattern chunk data
    hr = pIStream->Write( &oDMPattern, sizeof(DMUS_IO_PATTERN), &dwBytesWritten);
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(DMUS_IO_PATTERN) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }
    
    if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


HRESULT CDirectMusicPattern::Save( IStream* pIStream )
{
    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

   IAARIFFStream* pIRiffStream;
   MMCKINFO ckMain;
   HRESULT hr = E_FAIL;

    // Single Pattern (Direct Music format)
    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;
        if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
            &&  SUCCEEDED( DM_SaveSinglePattern( pIRiffStream ) )
            &&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
        {
            hr = S_OK;
        }
        pIRiffStream->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPartRef::DM_SavePartRef

HRESULT DirectMusicPartRef::DM_SavePartRef( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream = NULL;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_PARTREF oDMPartRef;

    if ( m_pDMPart == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write PartRef list header
    ckMain.fccType = DMUS_FOURCC_PARTREF_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write PartRef chunk header
    ck.ckid = DMUS_FOURCC_PARTREF_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_PARTREF structure
    memset( &oDMPartRef, 0, sizeof(DMUS_IO_PARTREF) );

    oDMPartRef.dwPChannel = m_dwLogicalPartID;  
    oDMPartRef.wLogicalPartID = (WORD) m_dwLogicalPartID;   
    oDMPartRef.bVariationLockID = m_bVariationLockID; 
    oDMPartRef.bSubChordLevel = m_bSubChordLevel;
    oDMPartRef.bPriority = m_bPriority;

    memcpy( &oDMPartRef.guidPartID, &m_pDMPart->m_guidPartID, sizeof(GUID) );

    // Write PartRef chunk data
    hr = pIStream->Write( &oDMPartRef, sizeof(DMUS_IO_PARTREF), &dwBytesWritten);
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_PARTREF) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }
    
    if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    if (pIStream) pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePart

HRESULT DirectMusicPart::DM_SavePart( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    DMUS_IO_STYLEPART oDMStylePart;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Part list header
    ckMain.fccType = DMUS_FOURCC_PART_LIST;
    if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Part chunk header
    ck.ckid = DMUS_FOURCC_PART_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Prepare DMUS_IO_STYLEPART structure
    memset( &oDMStylePart, 0, sizeof(DMUS_IO_STYLEPART) );

    oDMStylePart.timeSig.bBeatsPerMeasure = m_timeSig.m_bBeatsPerMeasure;
    oDMStylePart.timeSig.bBeat = m_timeSig.m_bBeat;
    oDMStylePart.timeSig.wGridsPerBeat = m_timeSig.m_wGridsPerBeat;

    oDMStylePart.wNbrMeasures = m_wNumMeasures;
    oDMStylePart.bInvertUpper = m_bInvertUpper;
    oDMStylePart.bInvertLower = m_bInvertLower;
    oDMStylePart.bPlayModeFlags = m_bPlayModeFlags;
    oDMStylePart.dwFlags = m_dwFlags;

    memcpy( &oDMStylePart.guidPartID, &m_guidPartID, sizeof(GUID) );
    memcpy( &oDMStylePart.dwVariationChoices, &m_dwVariationChoices, sizeof(m_dwVariationChoices) );

    // Write Part chunk data
    hr = pIStream->Write( &oDMStylePart, sizeof(DMUS_IO_STYLEPART), &dwBytesWritten);
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLEPART) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    CDirectMusicEventItem* pEvent;

    // Save Part note list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_NOTE )
        {
            hr = DM_SaveNoteList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part curve list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_CURVE )
        {
            hr = DM_SaveCurveList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part marker list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_MARKER )
        {
            hr = DM_SaveMarkerList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // Save Part anticipation list (when applicable)
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION )
        {
            hr = DM_SaveAnticipationList( pIRiffStream );
            if( FAILED( hr ) )
            {
                goto ON_ERROR;
            }
            break;
        }

        pEvent = pEvent->GetNext();
    }

    // save resolution list (when applicable)
    if (m_ResolutionList.GetHead())
    {
        hr = DM_SaveResolutionList(pIRiffStream);
        if( FAILED( hr ) )
        {
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveNoteList

HRESULT DirectMusicPart::DM_SaveNoteList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleNote* pNote;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLENOTE oDMStyleNote;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Write Note chunk header
    ck.ckid = DMUS_FOURCC_NOTE_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLENOTE structure
    dwSize = sizeof(DMUS_IO_STYLENOTE);
    hr = pIStream->Write( &dwSize, sizeof(DWORD), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(DWORD) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the notes
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_NOTE )
        {
            pNote = (CDMStyleNote*)pEvent;

            // Prepare DMUS_IO_STYLENOTE structure
            memset( &oDMStyleNote, 0, sizeof(DMUS_IO_STYLENOTE) );

            oDMStyleNote.mtGridStart = pNote->m_nGridStart;
            oDMStyleNote.dwVariation = pNote->m_dwVariation;
            oDMStyleNote.nTimeOffset = pNote->m_nTimeOffset;    

            oDMStyleNote.mtDuration = pNote->m_mtDuration;
            oDMStyleNote.wMusicValue = pNote->m_wMusicValue;    
            oDMStyleNote.bVelocity = pNote->m_bVelocity;    
            oDMStyleNote.bTimeRange = pNote->m_bTimeRange;  
            oDMStyleNote.bDurRange = pNote->m_bDurRange;    
            oDMStyleNote.bVelRange = pNote->m_bVelRange;    
            oDMStyleNote.bInversionID = pNote->m_bInversionId;  
            oDMStyleNote.bPlayModeFlags = pNote->m_bPlayModeFlags;
            oDMStyleNote.bNoteFlags = pNote->m_bFlags;

            // Write DMUS_IO_STYLENOTE structure
            hr = pIStream->Write( &oDMStyleNote, sizeof(DMUS_IO_STYLENOTE), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLENOTE) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveCurveList

HRESULT DirectMusicPart::DM_SaveCurveList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleCurve* pCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLECURVE oDMStyleCurve;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_CURVE_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLECURVE structure
    dwSize = sizeof(DMUS_IO_STYLECURVE);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the curves
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_CURVE )
        {
            pCurve = (CDMStyleCurve*)pEvent;

            // Prepare DMUS_IO_STYLECURVE structure
            memset( &oDMStyleCurve, 0, sizeof(DMUS_IO_STYLECURVE) );

            oDMStyleCurve.mtGridStart = pCurve->m_nGridStart;
            oDMStyleCurve.dwVariation = pCurve->m_dwVariation;
            oDMStyleCurve.nTimeOffset = pCurve->m_nTimeOffset;  

            oDMStyleCurve.mtDuration = pCurve->m_mtDuration;
            oDMStyleCurve.nStartValue = pCurve->m_StartValue;   
            oDMStyleCurve.nEndValue = pCurve->m_EndValue;   
            oDMStyleCurve.bEventType = pCurve->m_bEventType;    
            oDMStyleCurve.bCurveShape = pCurve->m_bCurveShape;  
            oDMStyleCurve.bCCData = pCurve->m_bCCData;  

            oDMStyleCurve.mtResetDuration = pCurve->m_mtResetDuration;
            oDMStyleCurve.nResetValue = pCurve->m_nResetValue;
            oDMStyleCurve.bFlags = pCurve->m_bFlags;
            // dx8 stuff
            oDMStyleCurve.wParamType = pCurve->m_wParamType;
            oDMStyleCurve.wMergeIndex = pCurve->m_wMergeIndex;

            // Write DMUS_IO_STYLECURVE structure
            hr = pIStream->Write( &oDMStyleCurve, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveMarkerList

HRESULT DirectMusicPart::DM_SaveMarkerList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleMarker* pMarker;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLEMARKER oDMStyleMarker;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_MARKER_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLEMARKER structure
    dwSize = sizeof(DMUS_IO_STYLEMARKER);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the markers
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_MARKER )
        {
            pMarker = (CDMStyleMarker*)pEvent;

            // Prepare DMUS_IO_STYLEMARKER structure
            memset( &oDMStyleMarker, 0, sizeof(DMUS_IO_STYLEMARKER) );

            oDMStyleMarker.mtGridStart = pMarker->m_nGridStart;
            oDMStyleMarker.dwVariation = pMarker->m_dwVariation;

            oDMStyleMarker.wMarkerFlags = pMarker->m_wFlags;

            // Write DMUS_IO_STYLEMARKER structure
            hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
            if( FAILED( hr )
            ||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveAnticipationList

HRESULT DirectMusicPart::DM_SaveAnticipationList( IAARIFFStream* pIRiffStream )
{
    CDirectMusicEventItem* pEvent;
    CDMStyleAnticipation* pAnticipation;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLE_ANTICIPATION oDMStyleAnticipation;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_ANTICIPATION_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLE_ANTICIPATION structure
    dwSize = sizeof(DMUS_IO_STYLE_ANTICIPATION);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the anticipations
    pEvent = EventList.GetHead();
    while( pEvent )
    {
        if( pEvent->m_dwEventTag == DMUS_EVENT_ANTICIPATION )
        {
            pAnticipation = (CDMStyleAnticipation*)pEvent;

            // Prepare DMUS_IO_STYLE_ANTICIPATION structure
            memset( &oDMStyleAnticipation, 0, sizeof(DMUS_IO_STYLE_ANTICIPATION) );

            oDMStyleAnticipation.mtGridStart = pAnticipation->m_nGridStart;
            oDMStyleAnticipation.dwVariation = pAnticipation->m_dwVariation;
            oDMStyleAnticipation.nTimeOffset = pAnticipation->m_nTimeOffset;
            oDMStyleAnticipation.bTimeRange = pAnticipation->m_bTimeRange;

            // Write DMUS_IO_STYLE_ANTICIPATION structure
            hr = pIStream->Write( &oDMStyleAnticipation, sizeof(DMUS_IO_STYLE_ANTICIPATION), &dwBytesWritten );
            if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLE_ANTICIPATION) )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
        }

        pEvent = pEvent->GetNext();
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DirectMusicPart::DM_SaveResolutionList

HRESULT DirectMusicPart::DM_SaveResolutionList( IAARIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwBytesWritten;
    WORD dwSize;
    DMUS_IO_STYLERESOLUTION oDMStyleResolution;
    TListItem<DMUS_IO_STYLERESOLUTION>* pScan = m_ResolutionList.GetHead();

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    ck.ckid = DMUS_FOURCC_RESOLUTION_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Save size of DMUS_IO_STYLERESOLUTION structure
    dwSize = sizeof(DMUS_IO_STYLERESOLUTION);
    hr = pIStream->Write( &dwSize, sizeof(dwSize), &dwBytesWritten );
    if( FAILED( hr ) ||  dwBytesWritten != sizeof(dwSize) )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

    // Now save all of the resolutions
    for(; pScan; pScan = pScan->GetNext() )
    {
        // Prepare DMUS_IO_STYLERESOLUTION structure
        oDMStyleResolution = pScan->GetItemValue();

        // Write DMUS_IO_STYLERESOLUTION structure
        hr = pIStream->Write( &oDMStyleResolution, sizeof(DMUS_IO_STYLERESOLUTION), &dwBytesWritten );
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(DMUS_IO_STYLERESOLUTION) )
        {
            hr = E_FAIL;
            goto ON_ERROR;
        }
    }

    if( pIRiffStream->Ascend(&ck, 0) != 0 )
    {
        hr = E_FAIL;
        goto ON_ERROR;
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}
#ifdef DXAPI
HRESULT CDMStyle::GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream)
{
    V_PTRPTR_WRITE(ppStream);

    TListItem<CDirectMusicPattern*>* pPattern = NULL;
    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        pPattern = m_StyleInfo.m_PatternList.GetHead();
        break;
    case DMUS_STYLET_MOTIF:
        pPattern = m_StyleInfo.m_MotifList.GetHead();
        break;
        // case for melody fragments...
    }
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == wszName)
            break;
    }
    if (pPattern != NULL)
    {
        // Create a stream
        IStream *pIPatternStream;
        HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pIPatternStream);
        if (SUCCEEDED(hr))
        {
            // Persist the pattern to the stream
            pPattern->GetItemValue()->Save(pIPatternStream);
            // Return the stream
            *ppStream = pIPatternStream;
        }
        return hr;
    }
    else
    {
        return S_FALSE;
    }
}
#endif
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetMotif | Creates a segment containing
the named motif.

@rdesc Returns one of the following:

@flag S_OK | Success.
@flag S_FALSE | No motif with the given name.
@flag E_POINTER | <p ppSegment> is not a valid address.

@comm Searches the Style's list of motifs for one whose name matches <p wszName>. If one 
is found, a segment is created containing a Motif track.  The track references the Style as
its associated style and the motif as its pattern.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetMotif(
            const WCHAR* pwszName,                    // @parm The name of the motif to be retrieved.
            IDirectMusicSegment** ppSegment // @parm A segment containing the named motif.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppSegment);

    String str = pwszName;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == str)
            break;
    }
    if (pPattern != NULL)
    {
        // AddRef the style
        ((IDirectMusicStyle*)this)->AddRef();
        // create a segment containing a motif track
        IUnknown* pIUSegment;
        // make a motif with the given number of repeats
        CreateMotifSegment(pPattern->GetItemValue(), &pIUSegment, 0);
        HRESULT hr = pIUSegment->QueryInterface(IID_IDirectMusicSegment, (void**)ppSegment);
        pIUSegment->Release();
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    else
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return S_FALSE;
    }
}

#ifdef DXAPI
HRESULT STDMETHODCALLTYPE CDMStyle::EnumPartGuid(
        DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid)
{
    HRESULT hr = S_OK;
    TListItem<CDirectMusicPattern*>* pPattern = NULL;

    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        pPattern = m_StyleInfo.m_PatternList.GetHead();
        break;
    case DMUS_STYLET_MOTIF:
        pPattern = m_StyleInfo.m_MotifList.GetHead();
        break;
        // case for melody fragments...
    }
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        if (pPattern->GetItemValue()->m_strName == wszName)
            break;
    }
    if (pPattern != NULL)
    {
        TListItem<DirectMusicPartRef>* pPartRef = pPattern->GetItemValue()->m_PartRefList.GetHead();
        for (DWORD dw = 0; dw < dwIndex; dw++)
        {
            if (pPartRef) pPartRef = pPartRef->GetNext();
        }
        if (pPartRef)
        {
            rGuid = pPartRef->GetItemValue().m_pDMPart->m_guidPartID;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}
#endif

// NOTE: assumes wszName is preallocated to DMUS_MAX_NAME
HRESULT STDMETHODCALLTYPE CDMStyle::EnumPattern(
            DWORD dwIndex,
            DWORD dwPatternType,
            WCHAR *wszName
        )
{
    HRESULT hr = E_INVALIDARG;
    switch (dwPatternType)
    {
    case DMUS_STYLET_PATTERN:
        hr = EnumRegularPattern(dwIndex, wszName);
        break;
    case DMUS_STYLET_MOTIF:
        hr = EnumMotif(dwIndex, wszName);
        break;
        // case for melody fragments...
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CDMStyle::EnumRegularPattern(
            DWORD dwIndex,
            WCHAR *wszName
        )
{
    V_PTR_WRITE(wszName, 1);
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    for (DWORD dw = 0; pPattern != NULL; pPattern = pPattern->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    HRESULT hr = S_OK;
    if (pPattern != NULL)
    {
        if (pPattern->GetItemValue()->m_strName.GetLength() < DMUS_MAX_NAME)
        {
            wcscpy(wszName, pPattern->GetItemValue()->m_strName);
            hr = S_OK;
        }
        else
        {
            for (int i = 0; i < (DMUS_MAX_NAME - 1); i++)
            {
                wszName[i] = pPattern->GetItemValue()->m_strName[i];
            }
            wszName[DMUS_MAX_NAME - 1] = L'\0';
            hr = DMUS_S_STRING_TRUNCATED;
        }
    }
    else 
    {
        hr = S_FALSE;
    }
    return hr;
}

// enum the list of start times common to all patterns referenced by the associated type, level, and range.
// (i.e. if more than one such pattern, skip start times not comon to all)
// return S_FALSE when no start times remain.
HRESULT STDMETHODCALLTYPE CDMStyle::EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime)
{
    int nRange = (int)pCommand->bGrooveRange / 2;
    int nLow = (int)pCommand->bGrooveLevel - nRange;
    if (nLow < 0) nLow = 0;
    int nHigh = (int)pCommand->bGrooveLevel + nRange;
    if (nHigh > 100) nHigh = 100;
    TList<CDirectMusicPattern*> MatchList;
    int nMatchCount = 0;
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    if (!pPattern) return S_FALSE;
    TListItem<MUSIC_TIME>** apStartTimes = NULL;
    HRESULT hr = S_OK;
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPattern->GetItemValue();
        if (rpPattern->m_bGrooveBottom <= (BYTE)nHigh && 
            rpPattern->m_bGrooveTop >= (BYTE)nLow)
        {
            if ( (pCommand->bCommand == DMUS_COMMANDT_FILL &&
                    rpPattern->m_wEmbellishment == EMB_FILL) ||
                 (pCommand->bCommand == DMUS_COMMANDT_INTRO &&
                    rpPattern->m_wEmbellishment == EMB_INTRO) ||
                 (pCommand->bCommand == DMUS_COMMANDT_BREAK &&
                    rpPattern->m_wEmbellishment == EMB_BREAK) ||
                 (pCommand->bCommand == DMUS_COMMANDT_END &&
                    rpPattern->m_wEmbellishment == EMB_END) ||
                 (pCommand->bCommand == DMUS_COMMANDT_GROOVE &&
                    rpPattern->m_wEmbellishment == EMB_NORMAL) ||
                 (rpPattern->m_wEmbellishment & EMB_USER_DEFINED && 
                    (rpPattern->m_wEmbellishment >> 8) == (WORD)pCommand->bCommand) )
            {
                if (rpPattern && rpPattern->m_StartTimeList.GetHead())
                {
                    TListItem<CDirectMusicPattern*>* pNewPattern;
                    pNewPattern = new TListItem<CDirectMusicPattern*>(rpPattern);
                    if (!pNewPattern)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    MatchList.AddHead(pNewPattern);
                    nMatchCount++;
                }
            }
        }
    }
    if (S_OK == hr)
    {
        if (nMatchCount)
        {
            apStartTimes = new TListItem<MUSIC_TIME>*[nMatchCount];
            if (!apStartTimes) hr = E_OUTOFMEMORY;
        }
        else hr = S_FALSE;
    }
    if (S_OK == hr)
    {
        MUSIC_TIME mtMin = 0, mtMax = 0;
        TListItem<CDirectMusicPattern*>* pMatch = MatchList.GetHead();
        // initialize the array of start time pointers
        int nPattern;
        for (nPattern = 0; pMatch; pMatch = pMatch->GetNext(), nPattern++)
        {
            apStartTimes[nPattern] = pMatch->GetItemValue()->m_StartTimeList.GetHead();
        }
        for (DWORD dw = 0; S_OK == hr && dw <= dwIndex; dw++)
        {
            // get the min and max times for the first item in each list
            mtMin = mtMax = apStartTimes[0]->GetItemValue();
            for (nPattern = 0; nPattern < nMatchCount; nPattern++)
            {
                if (apStartTimes[nPattern]->GetItemValue() < mtMin)
                {
                    mtMin = apStartTimes[nPattern]->GetItemValue();
                }
                if (apStartTimes[nPattern]->GetItemValue() > mtMax)
                {
                    mtMax = apStartTimes[nPattern]->GetItemValue();
                }
            }
            // sync up all the start times by making sure max == min.
            // set hr to S_FALSE if any lists run out.
            while (S_OK == hr && mtMax != mtMin)
            {
                // We'll only be changing values less than max, so the
                // new min will be not greater than that.
                MUSIC_TIME mtNewMin = mtMax;
                for (nPattern = 0; nPattern < nMatchCount; nPattern++)
                {
                    if (apStartTimes[nPattern]->GetItemValue() < mtMax)
                    {
                        apStartTimes[nPattern] = apStartTimes[nPattern]->GetNext();
                        if (!apStartTimes[nPattern])
                        {
                            hr = S_FALSE;
                            break;
                        }
                        if (apStartTimes[nPattern]->GetItemValue() < mtNewMin)
                        {
                            mtNewMin = apStartTimes[nPattern]->GetItemValue();
                        }
                        if (apStartTimes[nPattern]->GetItemValue() > mtMax)
                        {
                            mtMax = apStartTimes[nPattern]->GetItemValue();
                        }
                    }
                }
                // mtTempMin is the new min, since every instance of the
                // old min was less than max and therefore changed.
                mtMin = mtNewMin;
            }
            if (S_OK != hr) break;
            // if we're going to loop again, increment all the start time pointers.
            if (dw < dwIndex)
            {
                for (nPattern = 0;  nPattern < nMatchCount; nPattern++)
                {
                    apStartTimes[nPattern] = apStartTimes[nPattern]->GetNext();
                    // set hr to S_FALSE if any lists run out.
                    if (!apStartTimes[nPattern])
                    {
                        hr = S_FALSE;
                        break;
                    }
                }
            }
        }
        // if hr is S_OK, max should equal min, so return one of them.
        if (S_OK == hr) *pmtStartTime = mtMax;
        delete [] apStartTimes;
    }
    return hr;
}


/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumMotif | Retrieves the name of the
motif indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No motif at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the motif name is not less than DMUS_MAX_NAME
@flag E_POINTER | <p pwszName> is not a valid address

@comm Searches the Style's list of motifs for the one at the location given by <p dwIndex>.
If there is such a motif, its name is returned in <p pwszName>; if it is not less than DMUS_MAX_NAME,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least DMUS_MAX_NAME.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumMotif(
            DWORD dwIndex, // @parm An index into the Style's motif list (0-based).
            WCHAR *pwszName  // @parm The motif name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,DMUS_MAX_NAME);
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (DWORD dw = 0; pPattern != NULL; pPattern = pPattern->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    HRESULT hr = S_OK;
    if (pPattern != NULL)
    {
        if (pPattern->GetItemValue()->m_strName.GetLength() < DMUS_MAX_NAME)
        {
            wcscpy(pwszName, pPattern->GetItemValue()->m_strName);
            hr =  S_OK;
        }
        else
        {
            for (int i = 0; i < (DMUS_MAX_NAME - 1); i++)
            {
                pwszName[i] = pPattern->GetItemValue()->m_strName[i];
            }
            pwszName[DMUS_MAX_NAME - 1] = L'\0';
            hr =  DMUS_S_STRING_TRUNCATED;
        }
    }
    else 
    {
        hr =  S_FALSE;
    }
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetChordMap | Retrieves the named ChordMap.

@rdesc Returns one of the following:

@flag S_OK | Success.
@flag S_FALSE | No ChordMap with the given name.
@flag E_POINTER | ppChordMap not a valid pointer

@comm Searches the Style's list of personalities for one whose name matches <p wszName>. If one 
is found, it is returned.
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetChordMap(
            const WCHAR* pwszName,                    // @parm The name of the ChordMap to be retrieved.
            IDirectMusicChordMap** ppChordMap   // @parm The named ChordMap.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppChordMap);

    String str1 = pwszName;
    TListItem<IDirectMusicChordMap*>* pPersItem = m_StyleInfo.m_PersList.GetHead();
    IDirectMusicChordMap *pPers =  NULL;
    for (; pPersItem != NULL; pPersItem = pPersItem->GetNext())
    {
        HRESULT hr = S_OK;
        String str2;
        pPers = pPersItem->GetItemValue();
        
        IDirectMusicObject *pIObject = NULL;  
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pPers->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject))) 
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (str1 == str2)
                    {
                        pIObject->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            return hr;
        }

    }
    if (pPersItem != NULL)
    {
        // AddRef the ChordMap
        pPers->AddRef();
        // Return it.
        *ppChordMap = pPers;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumChordMap | Retrieves the name of the
ChordMap indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No ChordMap at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the ChordMap name is not less than DMUS_MAX_NAME
@flag E_POINTER | <p pwszName> is not a valid address
@flag DMUS_E_TYPE_UNSUPPORTED | The ChordMap's descriptor doesn't support DMUS_OBJ_NAME

@comm Searches the Style's list of chord maps for the one at the location given by <p dwIndex>.
If there is such a ChordMap, its name is returned in <p pwszName>; if it is not less than DMUS_MAX_NAME,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least DMUS_MAX_NAME.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumChordMap(
            DWORD dwIndex, // @parm An index into the Style's ChordMap list (0-based).
            WCHAR *pwszName // @parm The ChordMap name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,DMUS_MAX_NAME);

    TListItem<IDirectMusicChordMap*>* pPers = m_StyleInfo.m_PersList.GetHead();
    for (DWORD dw = 0; pPers != NULL; pPers = pPers->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    if (pPers != NULL)
    {
        HRESULT hr = S_OK;
        IDirectMusicChordMap* pChordMap = pPers->GetItemValue();
        
        IDirectMusicObject *pIObject = NULL;  
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pChordMap->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject))) 
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    if (wcslen(Desc.wszName) < DMUS_MAX_NAME)
                    {
                        wcscpy(pwszName, Desc.wszName);
                    }
                    else
                    {
                        for (int i = 0; i < (DMUS_MAX_NAME - 1); i++)
                        {
                            pwszName[i] = Desc.wszName[i];
                        }
                        pwszName[DMUS_MAX_NAME - 1] = L'\0';
                        hr = DMUS_S_STRING_TRUNCATED;
                    }
                }
                else 
                {
                    hr = DMUS_E_TYPE_UNSUPPORTED;
                }
            }
            pIObject->Release();
        }
        return hr;
    }
    else 
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetDefaultChordMap | Gets the style's 
default ChordMap.

@rdesc Returns one of the following

@flag S_OK | Success.
@flag E_POINTER | <p ppChordMap> not a valid pointer.
@flag S_FALSE | Style does not have a default ChordMap.

@comm Returns the Style's default ChordMap in <p ppChordMap>. 
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetDefaultChordMap(
            IDirectMusicChordMap **ppChordMap   // @parm The ChordMap to be returned.
        )
{
    V_PTRPTR_WRITE(ppChordMap);
    
    if(m_StyleInfo.m_pDefaultPers == NULL)
    {
        return S_FALSE;
    }
    
    *ppChordMap = m_StyleInfo.m_pDefaultPers;
    
    (*ppChordMap)->AddRef();
    
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetBand | Retrieves the named band.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | ppBand not a valid pointer
@flag S_FALSE | No band with the given name

@comm Searches the Style's list of bands for one whose name matches <p pwszName>. If one 
is found, it is returned in <p ppBand>. 
*/
HRESULT STDMETHODCALLTYPE CDMStyle::GetBand(
            const WCHAR *pwszName,            // @parm The name of the band to be retrieved.
            IDirectMusicBand **ppBand // @parm The named band.
        )
{
    V_PTR_READ(pwszName,1);
    V_PTRPTR_WRITE(ppBand);

    String str1 = pwszName;
    TListItem<IDirectMusicBand*>* pBandItem = m_StyleInfo.m_BandList.GetHead();
    IDirectMusicBand *pBand =  NULL;
    for (; pBandItem != NULL; pBandItem = pBandItem->GetNext())
    {
        HRESULT hr = S_OK;
        String str2;
        pBand = pBandItem->GetItemValue();
        
        IDirectMusicObject *pIObject = NULL;  
        DMUS_OBJECTDESC Desc;              // Descriptor.
        Desc.dwSize = sizeof(Desc);

        if (SUCCEEDED(hr = pBand->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject))) 
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (str1 == str2)
                    {
                        pIObject->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            return hr;
        }

    }
    if (pBandItem != NULL)
    {
        // AddRef the band
        pBand->AddRef();
        // Return it.
        *ppBand = pBand;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | EnumBand | Retrieves the name of the
band indexed by <p dwIndex>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | No band at the given location
@flag DMUS_S_STRING_TRUNCATED | The length of the band name is not less than DMUS_MAX_NAME
@flag E_POINTER | <p pwszName> is not a valid address
@flag DMUS_E_TYPE_UNSUPPORTED | The band's descriptor doesn't support DMUS_OBJ_NAME

@comm Searches the Style's list of bands for the one at the location given by <p dwIndex>.
If there is such a band, its name is returned in <p pwszName>; if it is not less than DMUS_MAX_NAME,
it is truncated.  This assumes that <p pwszName>
has been pre-allocated to have a length of at least DMUS_MAX_NAME.
*/
HRESULT STDMETHODCALLTYPE CDMStyle::EnumBand(
            DWORD dwIndex, // @parm An index into the Style's band list (0-based).
            WCHAR *pwszName// @parm The band name to be returned.
        )
{
    V_BUFPTR_WRITE(pwszName,DMUS_MAX_NAME);

    TListItem<IDirectMusicBand*>* pBandItem = m_StyleInfo.m_BandList.GetHead();
    for (DWORD dw = 0; pBandItem != NULL; pBandItem = pBandItem->GetNext(), dw++)
    {
        if (dw == dwIndex)
            break;
    }
    if (pBandItem != NULL)
    {
        HRESULT hr = S_OK;
        IDirectMusicBand* pBand = pBandItem->GetItemValue();
        
        IDirectMusicObject *pIObject = NULL;  
        DMUS_OBJECTDESC Desc;              // Descriptor.
        Desc.dwSize = sizeof(Desc);

        if (SUCCEEDED(hr = pBand->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject))) 
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    if (wcslen(Desc.wszName) < DMUS_MAX_NAME)
                    {
                        wcscpy(pwszName, Desc.wszName);
                    }
                    else
                    {
                        for (int i = 0; i < (DMUS_MAX_NAME - 1); i++)
                        {
                            pwszName[i] = Desc.wszName[i];
                        }
                        pwszName[DMUS_MAX_NAME - 1] = L'\0';
                        hr = DMUS_S_STRING_TRUNCATED;
                    }
                }
                else 
                {
                    hr = DMUS_E_TYPE_UNSUPPORTED;
                }
            }
            pIObject->Release();
        }
        return hr;
    }
    else 
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetDefaultBand | Gets the style's default band

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | ppBand not a valid pointer
@flag S_FALSE | Style does not have a default band

@comm Returns the Style's default band in <p ppBand>. 
*/

HRESULT STDMETHODCALLTYPE CDMStyle::GetDefaultBand(
            IDirectMusicBand **ppBand   // @parm The band to be returned.
        )
{
    V_PTRPTR_WRITE(ppBand);
    
    if(m_StyleInfo.m_pDefaultBand == NULL)
    {
        return S_FALSE;
    }
    
    *ppBand = m_StyleInfo.m_pDefaultBand;
    
    (*ppBand)->AddRef();
    
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetTimeSignature | Retrieves the Style's
time signature.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | <p pTimeSig> is not a valid address

@comm Fills in a <t DMUS_TIMESIGNATURE> structure with data from the Style's time signature.
*/
HRESULT CDMStyle::GetTimeSignature(
            DMUS_TIMESIGNATURE* pTimeSig // @parm A pre-allocated <t DMUS_TIMESIGNATURE> structure.
        )
{
    V_PTR_WRITE(pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    pTimeSig->mtTime = 0;
    pTimeSig->wGridsPerBeat = m_StyleInfo.m_TimeSignature.m_wGridsPerBeat;
    pTimeSig->bBeatsPerMeasure = m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure;
    pTimeSig->bBeat = m_StyleInfo.m_TimeSignature.m_bBeat;
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetEmbellishmentLength | Finds the shortest
and longest lengths for patterns of the specified embellishment type and groove level.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | There are no patterns of the specified type and groove level
@flag E_POINTER | Either <p pdwMin> or <p pdwMax> is not a valid address

@comm Finds all patterns in the Style with embellishment type given by <p bType> and groove
range that includes <p bLevel>.  The length of the longest such pattern is returned in 
<p pdwMax>, and the length of the shortest pattern is returned in <p pdwMin>.
Note that <p bLevel> is ignored for non-groove embellishments.
*/
HRESULT CDMStyle::GetEmbellishmentLength(
            DWORD dwType,       // @parm An embellishment type.
            DWORD dwLevel,  // @parm A groove level (1 - 100).
            DWORD* pdwMin,  // @parm Length of the shortest pattern of the specified type
                            // and groove level.
            DWORD* pdwMax       // @parm Length of the longest pattern of the specified type
                            // and groove level.
        )
{
    V_PTR_WRITE(pdwMin, sizeof(DWORD) );
    V_PTR_WRITE(pdwMax, sizeof(DWORD) );
    TListItem<CDirectMusicPattern*>* pPattern = m_StyleInfo.m_PatternList.GetHead();
    *pdwMin = *pdwMax = 0;
    if (!pPattern) return S_FALSE;
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPattern->GetItemValue();
        switch (dwType)
        {
        // need to use == rather than & for all of these because of user-defined embellishments
        case DMUS_COMMANDT_FILL: 
            if (rpPattern->m_wEmbellishment == EMB_FILL) 
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_INTRO: 
            if (rpPattern->m_wEmbellishment == EMB_INTRO)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_BREAK: 
            if (rpPattern->m_wEmbellishment == EMB_BREAK)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_END: 
            if (rpPattern->m_wEmbellishment == EMB_END)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        case DMUS_COMMANDT_GROOVE: // need to use == rather than & since EMB_NORMAL == 0
            if ((rpPattern->m_wEmbellishment == EMB_NORMAL) && 
                rpPattern->m_bGrooveBottom <= (BYTE)dwLevel && 
                rpPattern->m_bGrooveTop >= (BYTE)dwLevel)
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
            break;
        default: // check for user-defined embellishment
            if ( (rpPattern->m_wEmbellishment & EMB_USER_DEFINED) &&
                 (rpPattern->m_wEmbellishment >> 8) == (WORD)dwType )
            {
                if (rpPattern->m_wNumMeasures > *pdwMax)
                    *pdwMax = rpPattern->m_wNumMeasures;
                if (rpPattern->m_wNumMeasures < *pdwMin || *pdwMin == 0)
                    *pdwMin = rpPattern->m_wNumMeasures;
            }
        }
    }
    if (!*pdwMin || !*pdwMax) return S_FALSE;
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicStyle | GetTempo | Retrieves the recommended tempo
of the style.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | <p pTempo> is not a valid pointer

*/
HRESULT CDMStyle::GetTempo
    (
        double* pTempo // @parm The recommended tempo of the style.
    )
{
    V_PTR_WRITE(pTempo, sizeof(double) );
    *pTempo = m_StyleInfo.m_dblTempo;
    return S_OK;
}

CDirectMusicEventItem* CDirectMusicEventItem::MergeSort(DirectMusicTimeSig& TimeSig)
{
    if (m_pNext != NULL)
    {
        CDirectMusicEventItem *pList1, *pList2;
        Divide(pList1, pList2);
        return pList1->MergeSort(TimeSig)->Merge(pList2->MergeSort(TimeSig), TimeSig);
    }
    return this;
}

void CDirectMusicEventItem::Divide(CDirectMusicEventItem*& pHead1, CDirectMusicEventItem*& pHead2)
{
    CDirectMusicEventItem *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
    do
    {
        pHead1 = pCurrent;
        pCurrent = (CDirectMusicEventItem *)pCurrent->m_pNext;
        pHead1->m_pNext = pTail1;
        pTail1 = pHead1;
        if (pCurrent != NULL)
        {
            pHead2 = pCurrent;
            pCurrent = (CDirectMusicEventItem *)pCurrent->m_pNext;
            pHead2->m_pNext = pTail2;
            pTail2 = pHead2;
        }
    } while (pCurrent != NULL);
}

CDirectMusicEventItem* CDirectMusicEventItem::Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig)
{
    if (!pOtherList) return this;
    CDirectMusicEventItem 
        *pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
    while (pThisList && pOtherList)
    {
        if (pThisList->m_nGridStart < pOtherList->m_nGridStart || 
            // Markers need to precede other events occuring at the same time
            ((pThisList->m_dwEventTag == DMUS_EVENT_MARKER) &&
             (pThisList->m_nGridStart) == (pOtherList->m_nGridStart)) ||
            // Within a grid, sort by time offset
            ((pThisList->m_nGridStart) == (pOtherList->m_nGridStart) &&
             (pThisList->m_nTimeOffset < pOtherList->m_nTimeOffset)) )
        {
            pMergeItem = pThisList;
            pThisList = pThisList->GetNext();
        }
        else
        {
            pMergeItem = pOtherList;
            pOtherList = pOtherList->GetNext();
        }
        pMergeItem->SetNext(NULL);
        if (!pResultTail)
        {
            pResultHead = pResultTail = pMergeItem;
        }
        else
        {
            pResultTail->SetNext(pMergeItem);
            pResultTail = pMergeItem;
        }
    }
    if (pThisList) pResultTail->SetNext(pThisList);
    else pResultTail->SetNext(pOtherList);
    return pResultHead;
}

CDirectMusicEventItem* CDirectMusicEventItem::ReviseEvent(short nGrid, 
                                                          short nOffset, 
                                                          DWORD* pdwVariation, 
                                                          DWORD* pdwID, 
                                                          WORD* pwMusic, 
                                                          BYTE* pbPlaymode,
                                                          BYTE* pbFlags)
{
    CDirectMusicEventItem* pEvent = NULL;
    switch (m_dwEventTag)
    {
    case DMUS_EVENT_NOTE:
        pEvent = ((CDMStyleNote*)this)->ReviseEvent(nGrid, nOffset, pdwVariation, pdwID, pwMusic, pbPlaymode, pbFlags);
        break;
    case DMUS_EVENT_CURVE:
        pEvent = ((CDMStyleCurve*)this)->ReviseEvent(nGrid, nOffset);
        break;
    case DMUS_EVENT_MARKER: 
        pEvent = ((CDMStyleMarker*)this)->ReviseEvent(nGrid);
        break;
    case DMUS_EVENT_ANTICIPATION: 
        pEvent = ((CDMStyleAnticipation*)this)->ReviseEvent(nGrid);
        break;
    }
    return pEvent;
}

CDirectMusicEventItem* CDMStyleNote::ReviseEvent(short nGrid, 
                                                 short nOffset, 
                                                 DWORD* pdwVariation, 
                                                 DWORD* pdwID, 
                                                 WORD* pwMusic, 
                                                 BYTE* pbPlaymode,
                                                 BYTE* pbFlags)
{
    CDMStyleNote* pNoteEvent = new CDMStyleNote;
    if (pNoteEvent)
    {
        pNoteEvent->m_nGridStart = nGrid;
        pNoteEvent->m_nTimeOffset = nOffset;
        pNoteEvent->m_dwVariation = pdwVariation ? *pdwVariation : m_dwVariation;
        pNoteEvent->m_dwEventTag = m_dwEventTag;
        pNoteEvent->m_mtDuration = m_mtDuration;
        pNoteEvent->m_bVelocity = m_bVelocity;
        pNoteEvent->m_bTimeRange = m_bTimeRange;
        pNoteEvent->m_bDurRange = m_bDurRange;
        pNoteEvent->m_bVelRange = m_bVelRange;
        pNoteEvent->m_bInversionId = m_bInversionId;
        pNoteEvent->m_bPlayModeFlags = pbPlaymode ? *pbPlaymode : m_bPlayModeFlags;
        pNoteEvent->m_wMusicValue = pwMusic ? *pwMusic : m_wMusicValue;
        pNoteEvent->m_dwFragmentID = pdwID ? *pdwID : m_dwFragmentID;
        pNoteEvent->m_bFlags = pbFlags ? *pbFlags : 0;
    }
    return pNoteEvent;
}

CDirectMusicEventItem* CDMStyleCurve::ReviseEvent(short nGrid, short nOffset)
{
    CDMStyleCurve* pCurveEvent = new CDMStyleCurve;
    if (pCurveEvent)
    {
        pCurveEvent->m_nGridStart = nGrid; 
        pCurveEvent->m_nTimeOffset = nOffset;
        pCurveEvent->m_dwVariation = 0xffffffff;
        pCurveEvent->m_dwEventTag = m_dwEventTag;
        pCurveEvent->m_mtDuration = m_mtDuration;
        pCurveEvent->m_mtResetDuration = m_mtResetDuration;
        pCurveEvent->m_StartValue = m_StartValue;
        pCurveEvent->m_EndValue = m_EndValue;
        pCurveEvent->m_nResetValue = m_nResetValue;
        pCurveEvent->m_bEventType = m_bEventType;
        pCurveEvent->m_bCurveShape = m_bCurveShape;
        pCurveEvent->m_bCCData = m_bCCData;
        pCurveEvent->m_bFlags = m_bFlags;
        pCurveEvent->m_wParamType = m_wParamType;
        pCurveEvent->m_wMergeIndex = m_wMergeIndex;
    }
    return pCurveEvent;
}

CDirectMusicEventItem* CDMStyleMarker::ReviseEvent(short nGrid)
{
    CDMStyleMarker* pMarkerEvent = new CDMStyleMarker;
    if (pMarkerEvent)
    {
        pMarkerEvent->m_nGridStart = nGrid; 
        pMarkerEvent->m_nTimeOffset = 0;
        pMarkerEvent->m_dwVariation = 0xffffffff;
        pMarkerEvent->m_dwEventTag = m_dwEventTag;
        pMarkerEvent->m_wFlags = m_wFlags;
    }
    return pMarkerEvent;
}

CDirectMusicEventItem* CDMStyleAnticipation::ReviseEvent(short nGrid)
{
    CDMStyleAnticipation* pAnticipationEvent = new CDMStyleAnticipation;
    if (pAnticipationEvent)
    {
        pAnticipationEvent->m_nGridStart = nGrid; 
        pAnticipationEvent->m_nTimeOffset = m_nTimeOffset;
        pAnticipationEvent->m_dwVariation = 0xffffffff;
        pAnticipationEvent->m_dwEventTag = m_dwEventTag;
        pAnticipationEvent->m_bTimeRange = m_bTimeRange;
    }
    return pAnticipationEvent;
}

CDirectMusicEventList::~CDirectMusicEventList()

{
    CDirectMusicEventItem *pEvent;
    while (pEvent = RemoveHead())
    {
        delete pEvent;
    }
} 

void CDirectMusicEventList::MergeSort(DirectMusicTimeSig& TimeSig)
{
    if (m_pHead != NULL && m_pHead->GetNext() != NULL)
        m_pHead = ((CDirectMusicEventItem *)m_pHead)->MergeSort(TimeSig);
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern constructor

CDirectMusicPattern::CDirectMusicPattern( DirectMusicTimeSig* pTimeSig, BOOL fMotif ) :
    m_wNumMeasures(1),
    m_cRef(1),
    m_wID(0),
    m_bGrooveBottom(1),
    m_bGrooveTop(100),
    m_bDestGrooveBottom(1),
    m_bDestGrooveTop(100),
    m_pRhythmMap(NULL),
//  m_pSwitchPoints(NULL),
    m_fSettings(FALSE),
    m_dwRepeats(0),
    m_mtPlayStart(0),
    m_mtLoopStart(0),
    m_mtLoopEnd(-1),
    m_dwResolution(0),
    m_pMotifBand(NULL),
    m_dwFlags(0)
{
    if ( pTimeSig != NULL )
    {
        m_timeSig = *pTimeSig;
    }
    // Set defaults
    if( fMotif )
    {
        m_wEmbellishment = EMB_MOTIF;
    }
    else
    {
        m_wEmbellishment = EMB_NORMAL;
    }
}

CDirectMusicPattern* CDirectMusicPattern::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif)
{
    HRESULT hr = S_OK;
    CDirectMusicPattern* pNewPattern = new CDirectMusicPattern(&m_timeSig, fMotif);
    if (pNewPattern)
    {
        WORD wMeasureStart = (WORD)m_timeSig.ClocksToMeasure(mtStart);
        WORD wMeasureEnd = (WORD)m_timeSig.ClocksToMeasure(mtEnd);
        pNewPattern->m_wNumMeasures = wMeasureEnd - wMeasureStart;
        pNewPattern->m_cRef = m_cRef;
        pNewPattern->m_wID = m_wID;
        pNewPattern->m_bGrooveBottom = m_bGrooveBottom;
        pNewPattern->m_bGrooveTop = m_bGrooveTop;
        pNewPattern->m_bDestGrooveBottom = m_bDestGrooveBottom;
        pNewPattern->m_bDestGrooveTop = m_bDestGrooveTop;
        pNewPattern->m_fSettings = m_fSettings;
        pNewPattern->m_dwRepeats = m_dwRepeats;
        pNewPattern->m_strName = m_strName;
        pNewPattern->m_dwResolution = m_dwResolution;
        pNewPattern->m_dwFlags = m_dwFlags;
        if (m_mtPlayStart <= mtStart)
        {
            pNewPattern->m_mtPlayStart = 0;
        }
        else
        {
            pNewPattern->m_mtPlayStart = m_mtPlayStart - mtStart;
        }
        if (m_mtLoopStart <= mtStart)
        {
            pNewPattern->m_mtLoopStart = 0;
        }
        else
        {
            pNewPattern->m_mtLoopStart = m_mtLoopStart - mtStart;
        }
        if (m_mtLoopEnd >= (mtEnd - mtStart))
        {
            pNewPattern->m_mtLoopEnd = mtEnd - mtStart;
        }
        else if (m_mtLoopEnd < 0)
        {
            pNewPattern->m_mtLoopEnd = -1;
        }
        else
        {
            pNewPattern->m_mtLoopEnd = m_mtLoopEnd - mtStart;
        }
        pNewPattern->m_pRhythmMap = new DWORD[pNewPattern->m_wNumMeasures];
        if (!pNewPattern->m_pRhythmMap) 
        {
            hr = E_FAIL;
            goto ON_END;
        }
        for (int i = 0; i < pNewPattern->m_wNumMeasures; i++)
        {
            pNewPattern->m_pRhythmMap[i] = m_pRhythmMap[i + wMeasureStart];
        }
        if (m_pMotifBand)
        {
            pNewPattern->m_pMotifBand = m_pMotifBand;
            pNewPattern->m_pMotifBand->AddRef();
        }
        TListItem<DirectMusicPartRef>* pPartRefItem = m_PartRefList.GetHead();
        int nParts = m_PartRefList.GetCount();
        for (i = 0; pPartRefItem && i < nParts; pPartRefItem = pPartRefItem->GetNext(), i++)
        {
            DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
            DirectMusicPart* pPart = rPartRef.m_pDMPart;
            if (!pPart)
            {
                hr = E_FAIL;    
                goto ON_END;
            }
            TListItem<DirectMusicPartRef>* pNew = pNewPattern->CreatePart(rPartRef, pPart->m_bPlayModeFlags, pNewPattern->m_wNumMeasures);
            if (!pNew)
            {
                hr = E_FAIL;
                goto ON_END;
            }
            DirectMusicPartRef& rNew = pNew->GetItemValue();
            // Now that I've got the new part, I need to add events to its event list based
            // on mtStart and mtEnd
            CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
            MUSIC_TIME mtClocksInGrid = m_timeSig.ClocksPerGrid();
            for (; pEvent; pEvent = pEvent->GetNext())
            {
                MUSIC_TIME mtEvent = m_timeSig.GridToClocks(pEvent->m_nGridStart);
                if (mtEvent >= mtStart && mtEvent < mtEnd)
                {
                    short nNewGrid = (short) ((mtEvent - mtStart) / mtClocksInGrid);
                    short nNewOffset = (short) (pEvent->m_nTimeOffset + (mtEvent - mtStart) % mtClocksInGrid);
                    CDirectMusicEventItem* pNewEvent = pEvent->ReviseEvent(nNewGrid, nNewOffset);
                    if (!pNewEvent)
                    {
                        hr = E_FAIL;
                        goto ON_END;
                    }
                    rNew.m_pDMPart->EventList.AddHead(pNewEvent);
                }
            }
            rNew.m_pDMPart->EventList.MergeSort(m_timeSig);
        }
    }
ON_END:
    if (FAILED(hr))
    {
        if (pNewPattern)
        {
            delete pNewPattern;
            pNewPattern = NULL;
        }
    }
    return pNewPattern;
}

HRESULT CDirectMusicPattern::LoadCurveList( LPSTREAM pStream, LPMMCKINFO pck, short nClickTime)
{
    HRESULT     hr = S_OK;
    DWORD       cb;
    WORD        wCurveSize;
    WORD        wCurveExtra;
    WORD        wSubSize;
    WORD        wSubExtra;
    long        lSize;
    ioSubCurve  iSubCurve;
    ioCurve     iCurve;
    WORD        wCount;
    CDirectMusicEventItem*  pCurve = NULL;

    lSize = pck->cksize;
    // read size of the curve structure
    hr = pStream->Read( &wCurveSize, sizeof( wCurveSize ), &cb );
    FixBytes( FBT_SHORT, &wCurveSize );
    if( FAILED( hr ) || cb != sizeof( wCurveSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wCurveSize > sizeof( ioCurve ) )
    {
        wCurveExtra = static_cast<WORD>( wCurveSize - sizeof( ioCurve ) );
        wCurveSize = sizeof( ioCurve );
    }
    else
    {
        wCurveExtra = 0;
    }
    // read size of the subcurve structure
    hr = pStream->Read( &wSubSize, sizeof( wSubSize ), &cb );
    FixBytes( FBT_SHORT, &wSubSize );
    if( FAILED( hr ) || cb != sizeof( wSubSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wSubSize > sizeof( ioSubCurve ) )
    {
        wSubExtra = static_cast<WORD>( wSubSize - sizeof( ioSubCurve ) );
        wSubSize = sizeof( ioSubCurve );
    }
    else
    {
        wSubExtra = 0;
    }
    // now read in the curve
    while( lSize > 0 )
    {
        hr = pStream->Read( &iCurve, wCurveSize, &cb );
        FixBytes( FBT_IOCURVE, &iCurve );
        if( FAILED( hr ) || cb != wCurveSize )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }
        lSize -= cb;
        if( wCurveExtra > 0 )
        {
            StreamSeek( pStream, wCurveExtra, STREAM_SEEK_CUR );
            lSize -= wCurveExtra;
        }
        pCurve = new CDMStyleCurve;
        if( pCurve == NULL )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }

        pCurve->m_dwVariation = iCurve.wVariation;
        pCurve->m_nGridStart = nClickTime;
        ((CDMStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
        ((CDMStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;

        DirectMusicPart* pPart = FindPart(iCurve.bVoiceID);

        // read subcurve count
        hr = pStream->Read( &wCount, sizeof( wCount ), &cb );
        FixBytes( FBT_SHORT, &wCount );
        if( FAILED( hr ) || cb != sizeof( wCount ) )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }
        lSize -= cb;
        BOOL fEnteredLoop = wCount > 0;
        for( ; wCount > 0 ; --wCount )
        {
            // read subcurves
            hr = pStream->Read( &iSubCurve, wSubSize, &cb );
            FixBytes( FBT_IOSUBCURVE, &iSubCurve );
            if( FAILED( hr ) || cb != wSubSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            lSize -= wSubSize;
            if( wSubExtra > 0 )
            {
                StreamSeek( pStream, wSubExtra, STREAM_SEEK_CUR );
                lSize -= wSubExtra;
            }

            ((CDMStyleCurve*)pCurve)->m_bCurveShape = iSubCurve.bCurveType; // shape
            if (iSubCurve.nMaxTime < iSubCurve.nMinTime)
            {
                short n = iSubCurve.nMaxTime;
                iSubCurve.nMaxTime = iSubCurve.nMinTime;
                iSubCurve.nMinTime = n;
            }
            if (iSubCurve.nMaxValue < iSubCurve.nMinValue)
            {
                short n = iSubCurve.nMaxValue;
                iSubCurve.nMaxValue = iSubCurve.nMinValue;
                iSubCurve.nMinValue = n;
                iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
            }
            if( iSubCurve.fFlipped & CURVE_FLIPTIME )
            {
                switch( ((CDMStyleCurve*)pCurve)->m_bCurveShape )
                {
                    case DMUS_CURVES_LINEAR:
                        if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
                        {
                            iSubCurve.fFlipped = 0;
                        }
                        else
                        {
                            iSubCurve.fFlipped = CURVE_FLIPVALUE;
                        }
                        break;

                    case DMUS_CURVES_INSTANT:
                        iSubCurve.nMinTime = iSubCurve.nMaxTime;
                        iSubCurve.nMaxTime = iSubCurve.nMinTime + 1;
                        break;

                    case DMUS_CURVES_EXP:
                        ((CDMStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_LOG;
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // log is the horiz flipped version of vertical flipped exp
                        break;

                    case DMUS_CURVES_LOG:
                        ((CDMStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_EXP;
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // exp is the horiz flipped version of vertical flipped log
                        break;

                    case DMUS_CURVES_SINE:
                        iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
                        // because horiz. and vert. flip are the same for sine wave
                        break;

                    default:
                        assert( 0 );
                        break;
                }
            }
            
            if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
            {
                ((CDMStyleCurve*)pCurve)->m_StartValue = iSubCurve.nMaxValue;
                ((CDMStyleCurve*)pCurve)->m_EndValue = iSubCurve.nMinValue;
            }
            else
            {
                ((CDMStyleCurve*)pCurve)->m_StartValue = iSubCurve.nMinValue;
                ((CDMStyleCurve*)pCurve)->m_EndValue = iSubCurve.nMaxValue;
            }

            pCurve->m_nTimeOffset = ConvertTime(iSubCurve.nMinTime);
            ((CDMStyleCurve*)pCurve)->m_mtDuration = iSubCurve.nMaxTime - iSubCurve.nMinTime;
            ((CDMStyleCurve*)pCurve)->m_mtResetDuration = 0;
            ((CDMStyleCurve*)pCurve)->m_nResetValue = 0;
            ((CDMStyleCurve*)pCurve)->m_bFlags = 0;

            if (pPart != NULL)
            {
                pPart->EventList.AddHead(pCurve);
            }
            
            pCurve = new CDMStyleCurve;
            if( pCurve == NULL )
            {
              hr = E_FAIL;
             goto ON_ERR;
            }
            pCurve->m_dwVariation = iCurve.wVariation;
            pCurve->m_nGridStart = nClickTime;
            ((CDMStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
            ((CDMStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;

        }
        if (fEnteredLoop) delete pCurve; // the loop generates an extra one 
    }
ON_ERR:
    return hr;
}

HRESULT CDirectMusicPattern::LoadNoteList( LPSTREAM pStream, LPMMCKINFO pck, short nClickTime)
{
    HRESULT     hr = S_OK;;
    ioNote      iNote;
    DWORD       cb;
    WORD        wNoteSize;
    WORD        wExtra;
    long        lSize;
    CDirectMusicEventItem*  pNote = NULL;

    lSize = pck->cksize;
    // read size of the note structure
    hr = pStream->Read( &wNoteSize, sizeof( wNoteSize ), &cb );
    FixBytes( FBT_SHORT, &wNoteSize );
    if( FAILED( hr ) || cb != sizeof( wNoteSize ) )
    {
        hr = E_FAIL;
        goto ON_ERR;
    }
    lSize -= cb;
    if( wNoteSize > sizeof( ioNote ) )
    {
        wExtra = static_cast<WORD>( wNoteSize - sizeof( ioNote ) );
        wNoteSize = sizeof( ioNote );
    }
    else
    {
        wExtra = 0;
    }
    // now read in the notes
    while( lSize > 0 )
    {
        iNote.bPlayMode = 0;
        hr = pStream->Read( &iNote, wNoteSize, &cb );
        FixBytes( FBT_IONOTE, &iNote );
        if( FAILED( hr ) || cb != wNoteSize )
        {
            hr = E_FAIL;
            goto ON_ERR;
        }
        lSize -= wNoteSize;
        if( wExtra > 0 )
        {
            StreamSeek( pStream, wExtra, STREAM_SEEK_CUR );
            lSize -= wExtra;
        }
        pNote = new CDMStyleNote;
        if( pNote != NULL )
        {
            pNote->m_nGridStart = nClickTime;
            pNote->m_nTimeOffset = ConvertTime(iNote.nTime);
            pNote->m_dwVariation = iNote.wVariation;
            ((CDMStyleNote*)pNote)->m_bVelocity = iNote.bVelocity;
            ((CDMStyleNote*)pNote)->m_mtDuration = ConvertTime(iNote.nDuration);
            ((CDMStyleNote*)pNote)->m_bTimeRange = iNote.bTimeRange;
            ((CDMStyleNote*)pNote)->m_bDurRange = iNote.bDurRange;
            ((CDMStyleNote*)pNote)->m_bVelRange = iNote.bVelRange;
            ((CDMStyleNote*)pNote)->m_bInversionId = 0;  // not in IMA2.5
            ((CDMStyleNote*)pNote)->m_bFlags = 0;         // not in IMA2.5
            
            // Make sure SuperJAM! play mode is valid
            if ( !(iNote.bPlayMode & 0x80) )
            {
                iNote.bPlayMode = CHTYPE_NONE;
            }
            // Strip 0x80 before checking SuperJAM! play mode
                switch (iNote.bPlayMode & 0x0F)
                {
                    case CHTYPE_NOTINITIALIZED:
                    case CHTYPE_NONE:
                       ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
                       break;
                    case CHTYPE_DRUM:
                    case CHTYPE_FIXED:
                       ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                       break;
                     case CHTYPE_UPPER:
                     case CHTYPE_BASS:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
                        break;
                    case CHTYPE_SCALEONLY:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
                        break;
                    case CHTYPE_BASSMELODIC:
                    case CHTYPE_UPPERMELODIC:
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
                        break;
                    default:
                        // should never get here...
                        ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                }
            //}
            DirectMusicPart* pPart = FindPart(iNote.bVoiceID);
            if (pPart != NULL)
            {
                pPart->EventList.AddHead(pNote); 
            }
            else
            {
                assert(0);
            }
        // Determine playmode of note
            BYTE bNotePlayModeFlags;

            if( ((CDMStyleNote*)pNote)->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
            {
                bNotePlayModeFlags = pPart->m_bPlayModeFlags;
            }
            else
            {
                bNotePlayModeFlags = ((CDMStyleNote*)pNote)->m_bPlayModeFlags;
            }

            // if ScaleValue is non-zero and the note isn't a pedalpoint, it's purpleized.
            if( iNote.bScaleValue != 0
            &&  bNotePlayModeFlags != DMUS_PLAYMODE_PEDALPOINT )
            {
                ((CDMStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;
            }
            // if the note is a drum event, use the (mapped) MIDI value; 
            if( iNote.bVoiceID == 5 ) // it's a drum part
            {
                if (iNote.bValue <= 127 && achMappings[iNote.bValue] <= 127)
                    ((CDMStyleNote*)pNote)->m_wMusicValue = achMappings[iNote.bValue];
                else
                {
                    ((CDMStyleNote*)pNote)->m_wMusicValue = 0;
                }
            }
            // otherwise, if it's fixed, use the unmapped Midi value
            else if( bNotePlayModeFlags == DMUS_PLAYMODE_FIXED )
            {
                ((CDMStyleNote*)pNote)->m_wMusicValue = iNote.bValue;
            }
            // otherwise, use MusicValue
            else
            {
                ((CDMStyleNote*)pNote)->m_wMusicValue = iNote.nMusicValue;
            }

        }
    }
ON_ERR:
    return hr;
}

HRESULT CDirectMusicPattern::LoadEvents( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    ioClick iClick;
    HRESULT hr = S_OK;
    LPSTREAM pStream;
    MMCKINFO ck;
    DWORD cSize;
    DWORD cb;
    BOOL fClickLoaded = FALSE;

    pStream = pRIFF->GetStream();
    if ( pStream == NULL ) return E_FAIL;

    short nClickTime = 0;
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_CLICK:
            fClickLoaded = TRUE;
            cSize = min( ck.cksize, sizeof( iClick ) );
            hr = pStream->Read( &iClick, cSize, &cb );
            FixBytes( FBT_IOCLICK, &iClick );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            nClickTime = iClick.lTime;
            break;
        case FOURCC_NOTE:
            if (fClickLoaded)
                LoadNoteList( pStream, &ck, nClickTime);
            else
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            break;
        case FOURCC_CURVE:
            if (fClickLoaded)
                LoadCurveList( pStream, &ck, nClickTime);
            else
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }

ON_ERR:
    pStream->Release();
    return hr;
}

void CDirectMusicPattern::CleanUp()
{
    if (m_pRhythmMap != NULL)
    {
        delete [] m_pRhythmMap;
        m_pRhythmMap = NULL;
    }
/*  if (m_pSwitchPoints != NULL)
    {
        delete [] m_pSwitchPoints;
        m_pSwitchPoints = NULL;
    }*/

    if (m_pMotifBand)
    {
        m_pMotifBand->Release();
        m_pMotifBand = NULL;
    }

    m_PartRefList.CleanUp();
}

STDMETHODIMP_(ULONG) CDirectMusicPattern::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDirectMusicPattern::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

DirectMusicPart* CDirectMusicPattern::FindPart(BYTE bVoiceID)
{
    TListItem<DirectMusicPartRef> *li;

    for(li = m_PartRefList.GetHead(); li != NULL; li = li->GetNext())
    {
        if (VOICEID_TO_CHANNEL(bVoiceID + 1) == li->GetItemValue().m_dwLogicalPartID)
            return li->GetItemValue().m_pDMPart;
    }
    return NULL;

}

TListItem<DirectMusicPartRef>* CDirectMusicPattern::FindPartRefByPChannel(DWORD dwPChannel)
{
    TListItem<DirectMusicPartRef> *li;

    for(li = m_PartRefList.GetHead(); li != NULL; li = li->GetNext())
    {
        if (dwPChannel == li->GetItemValue().m_dwLogicalPartID)
            return li;
    }
    return NULL;
}

TListItem<DirectMusicPartRef>* CDirectMusicPattern::CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures )
{
    TListItem<DirectMusicPartRef>* pNewPartRef = FindPartRefByPChannel(rPartRef.m_dwLogicalPartID);
    if (pNewPartRef)
    {
        DirectMusicPartRef& rNewPartRef = pNewPartRef->GetItemValue();
        DirectMusicPart* pFoundPart = rNewPartRef.m_pDMPart;
        DirectMusicPart* pOtherPart = rPartRef.m_pDMPart;
        if (pFoundPart && pOtherPart)
        {
            if (pOtherPart->m_bInvertUpper > pFoundPart->m_bInvertUpper)
            {
                pFoundPart->m_bInvertUpper = pOtherPart->m_bInvertUpper;
            }
            if (pOtherPart->m_bInvertLower < pFoundPart->m_bInvertLower)
            {
                pFoundPart->m_bInvertLower = pOtherPart->m_bInvertLower;
            }
            pFoundPart->m_dwFlags |= pOtherPart->m_dwFlags;
        }
    }
    else
    {
        pNewPartRef = new TListItem<DirectMusicPartRef>;
        if( pNewPartRef )
        {
            DirectMusicPart* pPart = new DirectMusicPart;
            if( !pPart )
            {
                delete pNewPartRef;
                pNewPartRef = NULL;
            }
            else
            {
                DirectMusicPartRef& rNewPartRef = pNewPartRef->GetItemValue();
                // initialize the new part...
                DirectMusicPart* pOtherPart = rPartRef.m_pDMPart;
                if (pPart && pOtherPart)
                {
                    pPart->m_guidPartID = pOtherPart->m_guidPartID;
                    pPart->m_timeSig = m_timeSig;
                    for (int i = 0; i < 32; i++) // activate all variations
                    {
                        pPart->m_dwVariationChoices[i] = 0x7fffffff;
                    }
                    pPart->m_bPlayModeFlags = bPlaymode;
                    pPart->m_bInvertUpper = pOtherPart->m_bInvertUpper;
                    pPart->m_bInvertLower = pOtherPart->m_bInvertLower;
                    pPart->m_dwFlags = pOtherPart->m_dwFlags;
                    pPart->m_wNumMeasures = wMeasures;
                }
                // initialize the new part ref...
                rNewPartRef.m_pDMPart = pPart;
                rNewPartRef.m_dwLogicalPartID = rPartRef.m_dwLogicalPartID;
                rNewPartRef.m_bVariationLockID = rPartRef.m_bVariationLockID;
                rNewPartRef.m_bSubChordLevel = rPartRef.m_bSubChordLevel;
                rNewPartRef.m_bPriority = rPartRef.m_bPriority;
                rNewPartRef.m_bRandomVariation = rPartRef.m_bRandomVariation;   
                m_PartRefList.AddTail(pNewPartRef);
            }
        }
    }
    return pNewPartRef;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_LoadPattern

HRESULT CDirectMusicPattern::DM_LoadPattern( 
            IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    TListItem<DirectMusicPartRef>* pPartRefItem = NULL;
    DirectMusicPart* pPart;
    IStream*    pIStream;
    HRESULT     hr = S_OK;
    DWORD       dwByteCount;
    DWORD       dwSize;
    MMCKINFO    ck;
    MMCKINFO    ckList;
    int         i;

    if ( pStyle == NULL ) return E_INVALIDARG;
    if ( pIRiffStream == NULL ) return E_INVALIDARG;
    if ( pckMain == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    // Load the Pattern
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PATTERN_CHUNK:
            {
                DMUS_IO_PATTERN iDMPattern;
                memset(&iDMPattern, 0, sizeof(iDMPattern));

                dwSize = min( ck.cksize, sizeof( DMUS_IO_PATTERN ) );
                hr = pIStream->Read( &iDMPattern, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_bGrooveBottom = iDMPattern.bGrooveBottom;
                m_bGrooveTop = iDMPattern.bGrooveTop;
                m_wEmbellishment = iDMPattern.wEmbellishment;
                m_bDestGrooveBottom = iDMPattern.bDestGrooveBottom;
                m_bDestGrooveTop = iDMPattern.bDestGrooveTop;
                m_dwFlags = iDMPattern.dwFlags;

                m_timeSig.m_bBeatsPerMeasure = iDMPattern.timeSig.bBeatsPerMeasure;
                m_timeSig.m_bBeat = iDMPattern.timeSig.bBeat;
                m_timeSig.m_wGridsPerBeat = iDMPattern.timeSig.wGridsPerBeat;
                
                m_wNumMeasures = iDMPattern.wNbrMeasures;
                break;
            }

            case DMUS_FOURCC_RHYTHM_CHUNK:
                if( m_pRhythmMap )
                {
                    delete [] m_pRhythmMap;
                    m_pRhythmMap = NULL;
                }
                m_pRhythmMap = new DWORD[m_wNumMeasures];
                if( m_pRhythmMap == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERROR;
                }
                for( i = 0 ;  i < m_wNumMeasures ;  i++ )
                {
                    hr = pIStream->Read( &m_pRhythmMap[i], sizeof(DWORD), &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != sizeof(DWORD) )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                }
                break;

/*          case DMUS_FOURCC_SWITCH_POINT_CHUNK:
                if( m_pSwitchPoints )
                {
                    delete [] m_pSwitchPoints;
                    m_pSwitchPoints = NULL;
                }
                m_pSwitchPoints = new DWORD[m_wNumMeasures];
                if( m_pSwitchPoints == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_ERROR;
                }
                for( i = 0 ;  i < m_wNumMeasures ;  i++ )
                {
                    hr = pIStream->Read( &m_pSwitchPoints[i], sizeof(DWORD), &dwByteCount );
                    if( FAILED( hr ) ||  dwByteCount != sizeof(DWORD) )
                    {
                        hr = E_FAIL;
                        goto ON_ERROR;
                    }
                }
                break;
*/
            case DMUS_FOURCC_MOTIFSETTINGS_CHUNK:
            {
                DMUS_IO_MOTIFSETTINGS ioMotifSettings;
                hr = pIStream->Read( &ioMotifSettings, sizeof(DMUS_IO_MOTIFSETTINGS), &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != sizeof(DMUS_IO_MOTIFSETTINGS) )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                m_fSettings = TRUE;
                m_dwRepeats = ioMotifSettings.dwRepeats;
                m_mtPlayStart = ioMotifSettings.mtPlayStart;
                m_mtLoopStart = ioMotifSettings.mtLoopStart;
                m_mtLoopEnd = ioMotifSettings.mtLoopEnd;
                m_dwResolution = ioMotifSettings.dwResolution;
                break;
            }

            case FOURCC_RIFF:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_BAND_FORM:
                    {
                        // load band associated with the motif
                        if (m_pMotifBand)
                        {
                            m_pMotifBand->Release();
                            m_pMotifBand = NULL;
                        }
            
                        // Create a band
                        hr = DirectMusicCreateInstance(CLSID_DirectMusicBand,NULL,IID_IDirectMusicBand,(void**)&m_pMotifBand);
                        if(SUCCEEDED(hr))
                        {
                            // Seek back to begining of Riff chunk
                            // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                            // Get current position
                            LARGE_INTEGER li;
                            ULARGE_INTEGER ul;
                            li.HighPart = 0;
                            li.LowPart = 0;
                            hr = pIStream->Seek(li,
                                               STREAM_SEEK_CUR,
                                               &ul);
                            if(SUCCEEDED(hr))
                            {
                                li.HighPart = 0;
                                // This is always a valid operation
                                li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                                hr = pIStream->Seek(li, 
                                                   STREAM_SEEK_SET,
                                                   &ul);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Load band
                            IPersistStream* pIPersistStream;
                            hr = m_pMotifBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
                            if(SUCCEEDED(hr))
                            {
                                hr = pIPersistStream->Load(pIStream);
                                pIPersistStream->Release();
                            }
                        }
                        if(FAILED(hr))
                        {
                            if (m_pMotifBand)
                            {
                                m_pMotifBand->Release();
                                m_pMotifBand = NULL;
                            }
                            goto ON_ERROR;
                        }
                        break;
                    }
                }
                break;

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    hr = ReadMBSfromWCS( pIStream, ckList.cksize, m_strName );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;
                                }
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                    case DMUS_FOURCC_PART_LIST:     // only in GUID_SinglePattern format
                        pPart = pStyle->AllocPart();
                        if( pPart == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        hr = pPart->DM_LoadPart( pIRiffStream, &ck, pStyle );
                        if( FAILED( hr ) )
                        {
                            pStyle->DeletePart( pPart );
                            goto ON_ERROR;
                        }
                        if( hr == S_FALSE )
                        {
                            // Bypass this Part because Style already contains a Part
                            // whose GUID matches pPart->m_guidPartID
                            pStyle->DeletePart( pPart );
                        }
                        else // merge the part's marker events
                        {
                            pPart->MergeMarkerEvents(pStyle, this);
                        }
                        break;

                    case DMUS_FOURCC_PARTREF_LIST:
                        hr = AllocPartRef(pPartRefItem);
                        if ( FAILED(hr) )
                        {
                            goto ON_ERROR;
                        }
                        hr = pPartRefItem->GetItemValue().DM_LoadPartRef( pIRiffStream, &ck, pStyle );
                        if ( FAILED( hr ) )
                        {
                            DeletePartRef( pPartRefItem );
                            goto ON_ERROR;
                        }

                        break;
                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::AllocPartRef

HRESULT CDirectMusicPattern::AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem)
{
    rpPartRefItem = new TListItem<DirectMusicPartRef>;

    if (rpPartRefItem)
    {
        // Add PartRef to Pattern's list of Parts
        m_PartRefList.AddTail( rpPartRefItem );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DeletePartRef

void CDirectMusicPattern::DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem)
{
    // add stuff later...
}

#ifdef DXAPI
HRESULT CDirectMusicPattern::LoadPattern(IAARIFFStream* pRIFF, 
                                         MMCKINFO* pckMain,
                                         TList<DirectMusicPart*> &partList,
                                         DMStyleStruct& rStyleStruct
                                         )
{
    int         i;
    int         j;
    ioPattern   iPattern;
    LPSTREAM    pStream;
    HRESULT     hr = S_OK;
    MMCKINFO    ck;
    DWORD       cb;
    DWORD       cSize;
    WORD        wKludge;
    DWORD       dwRhythm = 1;     // make it a whole note pattern by default

    pStream = pRIFF->GetStream();
    if ( pStream == NULL ) return E_FAIL;

    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_PATTERN:
            cSize = min( ck.cksize, sizeof( iPattern ) );
            hr = pStream->Read( &iPattern, cSize, &cb );
            FixBytes( FBT_IOPATTERN, &iPattern );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            m_strName = iPattern.wstrName;
            m_timeSig.m_bBeatsPerMeasure = static_cast<BYTE>( iPattern.dwLength / static_cast<long>( iPattern.wClocksPerBeat ) / iPattern.wMeasures );
            m_timeSig.m_bBeat = static_cast<BYTE>(iPattern.wBeat);
            m_timeSig.m_wGridsPerBeat = iPattern.wClocksPerBeat / iPattern.wClocksPerClick;
            m_wNumMeasures = iPattern.wMeasures;
            // Bottom of groove range is 1 if either level A or no levels were specified;
            // 26 if level B is the lowest level specified, etc.
            if ( iPattern.fFlags & PF_A || !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
                m_bGrooveBottom = 1;
            else if (iPattern.fFlags & PF_B) m_bGrooveBottom = 26;
            else if (iPattern.fFlags & PF_C) m_bGrooveBottom = 51;
            else m_bGrooveBottom = 76;
            // Top of groove range is 100 if either level D or no levels were specified;
            // 75 if level C is the highest level specified, etc.
            if ( iPattern.fFlags & PF_D || !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
                m_bGrooveTop = 100;
            else if (iPattern.fFlags & PF_C) m_bGrooveTop = 75;
            else if (iPattern.fFlags & PF_B) m_bGrooveTop = 50;
            else m_bGrooveTop = 25;
            m_wEmbellishment = EMB_NORMAL;
            if (iPattern.fFlags & PF_FILL) m_wEmbellishment |= EMB_FILL;
            if (iPattern.fFlags & PF_INTRO) m_wEmbellishment |= EMB_INTRO;
            if (iPattern.fFlags & PF_END) m_wEmbellishment |= EMB_END;
            if (iPattern.fFlags & PF_BREAK) m_wEmbellishment |= EMB_BREAK;
            if (iPattern.fFlags & PF_MOTIF) m_wEmbellishment |= EMB_MOTIF;
            m_pRhythmMap = new DWORD[iPattern.wMeasures];
            if( m_pRhythmMap == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto ON_ERR;
            }
            if (iPattern.fFlags & PF_WHOLE) dwRhythm = 1;    // bit 1 set
            if (iPattern.fFlags & PF_HALF) dwRhythm = 5;     // bits 1 and 3
            if (iPattern.fFlags & PF_QUARTER) dwRhythm = 15; // bits 1-4
            for (i = 0; i < iPattern.wMeasures; ++i)
            {
                m_pRhythmMap[i] = dwRhythm;
            }
            for( i = 0 ; i < 16 ; ++i ) // loop over Parts
            {
                TListItem<DirectMusicPart*> *pPartItem = new TListItem<DirectMusicPart*>;
                if( pPartItem == NULL )
                {
                    hr = E_OUTOFMEMORY; 
                    goto ON_ERR;
                }
                DirectMusicPart*& pPart = pPartItem->GetItemValue();
                pPart = new DirectMusicPart;
                if( pPart == NULL )
                {
                    hr = E_OUTOFMEMORY; 
                    goto ON_ERR;
                }
                pPart->m_wNumMeasures = m_wNumMeasures;
                TListItem<DirectMusicPartRef> *pPartRefItem = new TListItem<DirectMusicPartRef>;
                if( pPartRefItem == NULL )
                {
                    hr = E_OUTOFMEMORY; 
                    goto ON_ERR;
                }
                DirectMusicPartRef& rPartRef = pPartRefItem->GetItemValue();
                rPartRef.m_pDMPart = pPart;
                rPartRef.m_pDMPart->AddRef();
                rPartRef.m_dwLogicalPartID = VOICEID_TO_CHANNEL(i + 1);
                AdjoinPChannel(rStyleStruct.m_PChannelList, rPartRef.m_dwLogicalPartID);
                rPartRef.m_bVariationLockID = 0;  // 0 means no locking between parts...
                rPartRef.m_bRandomVariation = DMUS_VARIATIONT_RANDOM;  // (default in 2.5)
                if( iPattern.wInvert & (1 << i) )
                {
                    pPart->m_bInvertLower = iPattern.abInvertLower[i];
                    pPart->m_bInvertUpper = iPattern.abInvertUpper[i];
                }
                else
                {
                    pPart->m_bInvertLower = 0;
                    pPart->m_bInvertUpper = 127;
                }
                if (iPattern.achChordChoice[i] == CHTYPE_UPPER ||
                    iPattern.achChordChoice[i] == CHTYPE_UPPERMELODIC)
                {
                    rPartRef.m_bSubChordLevel = SUBCHORD_STANDARD_CHORD;
                }
                else
                {
                    rPartRef.m_bSubChordLevel = SUBCHORD_BASS;
                }
                switch (iPattern.achChordChoice[i])
                {
                    case CHTYPE_DRUM:
                    case CHTYPE_FIXED:
                       pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                       break;
                     case CHTYPE_UPPER:
                     case CHTYPE_BASS:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
                        break;
                    case CHTYPE_SCALEONLY:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
                        break;
                    case CHTYPE_BASSMELODIC:
                    case CHTYPE_UPPERMELODIC:
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
                        break;
                    default:
                        // should never get here...
                        pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                }



// if none of the variations have the ->I or ->V flag set, set it in all variations
                wKludge = VF_TO1 | VF_TO5;
                for (j = 16; j < 32; j++) pPart->m_dwVariationChoices[j] = 0;
                for( j = 0 ; j < 16 ; ++j )
                {
                    pPart->m_dwVariationChoices[j] = iPattern.awVarFlags[i][j];
                    if( ( pPart->m_dwVariationChoices[j] & VF_TO1 ) != 0 )
                    {
                        wKludge &= ~VF_TO1;
                    }
                    if( ( pPart->m_dwVariationChoices[j] & VF_TO5 ) != 0 )
                    {
                        wKludge &= ~VF_TO5;
                    }
                }
                if( wKludge != 0 )
                {
                    for( j = 0 ; j < 16 ; ++j )
                    {
                        pPart->m_dwVariationChoices[j] |= wKludge;
                    }
                }
                partList.AddTail(pPartItem);
                m_PartRefList.AddTail(pPartRefItem);
            }
            break;
        case FOURCC_LIST:
            switch( ck.fccType )
            {
                case FOURCC_CLICK_LIST:
                    LoadEvents(pRIFF, &ck);
                    break;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }

ON_ERR:
    pStream->Release();
    return hr;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_LoadPartRef

HRESULT DirectMusicPartRef::DM_LoadPartRef(
                IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle )
{
    DirectMusicPart* pPart;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
    DWORD dwByteCount;
    DWORD dwSize;

    if ( pStyle == NULL ) return E_INVALIDARG;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_PARTREF_CHUNK:
            {
                DMUS_IO_PARTREF iDMPartRef;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_PARTREF ) );
                hr = pIStream->Read( &iDMPartRef, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_bRandomVariation = iDMPartRef.bRandomVariation;
                if (dwSize < DX8_PARTREF_SIZE)
                {
                    m_dwLogicalPartID = iDMPartRef.wLogicalPartID;  
                }
                else
                {
                    m_dwLogicalPartID = iDMPartRef.dwPChannel;  
                }
                AdjoinPChannel(pStyle->m_PChannelList, m_dwLogicalPartID);
                m_bVariationLockID = iDMPartRef.bVariationLockID; 
                m_bSubChordLevel = iDMPartRef.bSubChordLevel;
                m_bPriority = iDMPartRef.bPriority;

                pPart = pStyle->FindPartByGUID( iDMPartRef.guidPartID );
                if( pPart == NULL )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                SetPart( pPart );
                break;
            }

        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DirectMusicPartRef::SetPart

void DirectMusicPartRef::SetPart( DirectMusicPart* pPart )
{
    if( m_pDMPart == pPart )
    {
        return;
    }

    if( m_pDMPart ) 
    {
        m_pDMPart->Release();
    }

    if( pPart )
    {
        m_pDMPart = pPart;
        m_pDMPart->AddRef();
    }
}


CDMStyle::CDMStyle() : m_cRef(1), m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    m_StyleInfo.m_fLoaded = false;
    m_StyleInfo.m_dwFlags = 0;
    m_StyleInfo.m_pDefaultBand = NULL;
    m_StyleInfo.m_pDefaultPers = NULL;
}

CDMStyle::~CDMStyle()
{
    if (m_fCSInitialized)
    {
        // Don't need to clean up if critical section failed.
        // DON'T MOVE THIS - it will fault in low memory conditions
        //
        CleanUp();

        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    DecrementDLLCount();
}

HRESULT CDMStyle::GetStyleInfo(void **pData)
{
    *pData = (void *) &m_StyleInfo;
    return S_OK;
}

HRESULT CDMStyle::IsDX8()
{
    return m_StyleInfo.UsingDX8() ? S_OK : S_FALSE;
}

HRESULT CDMStyle::CritSec(bool fEnter)
{
    HRESULT hr = S_OK;
    if (m_fCSInitialized)
    {
        if (fEnter)
        {
            ENTER_CRITICAL_SECTION(&m_CriticalSection);
        }
        else
        {
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

/* IPersist methods */
 HRESULT CDMStyle::GetClassID( LPCLSID pclsid )
{
    //assert ( pclsid != NULL );
    *pclsid = CLSID_DirectMusicStyle;
    return S_OK;
}

HRESULT CDMStyle::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

HRESULT CDMStyle::Save( LPSTREAM pStream, BOOL /*fClearDirty*/ )
{

    return E_NOTIMPL;
}

HRESULT CDMStyle::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMStyle::Load( LPSTREAM pIStream )
{
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT         hr = E_FAIL;

    if( pIStream == NULL )
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CleanUp();
    dwPos = StreamTell( pIStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_LoadStyle( pIRiffStream, &ckMain );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
        pIRiffStream = NULL;
    }

#ifdef DXAPI
    // Check for IMA 2.5 format
    if( !fFoundFormat )
    {
        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

        if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
        {
            ckMain.fccType = FOURCC_STYLE_FORM;

            if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
            {
                hr = IMA25_LoadStyle( pIRiffStream, &ckMain );
                fFoundFormat = TRUE;
            }
            pIRiffStream->Release();
        }
    }
#endif
    if (SUCCEEDED(hr)) m_StyleInfo.m_fLoaded = true;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

void CDMStyle::CleanUp()
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    m_StyleInfo.m_fLoaded = false;
    TListItem<IDirectMusicBand*>* pBandListItem = (m_StyleInfo.m_BandList).GetHead();
    for (; pBandListItem; pBandListItem = pBandListItem->GetNext())
    {
        IDirectMusicBand* pBand = pBandListItem->GetItemValue();
        if(pBand)
        {
            pBand->Release();
        }
    }
    m_StyleInfo.m_BandList.CleanUp();
    TListItem<IDirectMusicChordMap*>* pPersListItem = (m_StyleInfo.m_PersList).GetHead();
    for (; pPersListItem; pPersListItem = pPersListItem->GetNext())
    {
        IDirectMusicChordMap* pPers = pPersListItem->GetItemValue();
        if(pPers)
        {
            pPers->Release();
        }
    }
    m_StyleInfo.m_PersList.CleanUp();

    TListItem<DirectMusicPart*>* pPartListItem = (m_StyleInfo.m_PartList).GetHead();
    for (; pPartListItem; pPartListItem = pPartListItem->GetNext())
    {
        DirectMusicPart* pPart = pPartListItem->GetItemValue();
        if(pPart)
        {
            if (pPart->Release() == 0)
            {
                pPartListItem->GetItemValue() = NULL;
            }
        }
    }
    m_StyleInfo.m_PartList.CleanUp();

    TListItem<CDirectMusicPattern*>* pPatternListItem = (m_StyleInfo.m_PatternList).GetHead();
    for (; pPatternListItem; pPatternListItem = pPatternListItem->GetNext())
    {
        CDirectMusicPattern* pPattern = pPatternListItem->GetItemValue();
        if(pPattern)
        {
            if (pPattern->Release() == 0)
            {
                pPatternListItem->GetItemValue() = NULL;
            }
        }
    }
    m_StyleInfo.m_PatternList.CleanUp();

    pPatternListItem = (m_StyleInfo.m_MotifList).GetHead();
    for (; pPatternListItem; pPatternListItem = pPatternListItem->GetNext())
    {
        CDirectMusicPattern* pPattern = pPatternListItem->GetItemValue();
        if(pPattern)
        {
            pPattern->Release();
        }
    }
    m_StyleInfo.m_MotifList.CleanUp();

    m_StyleInfo.m_PChannelList.CleanUp();

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
}
#ifdef DXAPI
HRESULT CDMStyle::IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck )
{
    ioPersonalityRef ref;
    DWORD dwSize;
    WORD wStructSize;
    String strFileName;
    HRESULT hr = S_OK;
    HRESULT hrChordMap = E_FAIL;

    if ( pStream == NULL ) return E_POINTER;
    dwSize = pck->cksize;
    pStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
    FixBytes( FBT_SHORT, &wStructSize );
    dwSize -= sizeof( wStructSize );
    if( wStructSize > sizeof(ref) )
    {
        hr = pStream->Read( &ref, sizeof(ref), NULL );
        FixBytes( FBT_IOPERSONALITYREF, &ref );
        StreamSeek( pStream, wStructSize - sizeof(ref), STREAM_SEEK_CUR );
    }
    else
    {
        hr = pStream->Read( &ref, wStructSize, NULL );
        FixBytes( FBT_IOPERSONALITYREF, &ref );
    }
    if (!SUCCEEDED(hr)) return hr;
    dwSize -= wStructSize;
    // loader stuff here...
    DMUS_OBJECTDESC ObjectDescript;
    ZeroMemory(&ObjectDescript, sizeof(DMUS_OBJECTDESC));
    ObjectDescript.dwSize = sizeof(DMUS_OBJECTDESC);
    ObjectDescript.guidClass = CLSID_DirectMusicChordMap;
    wcscpy(ObjectDescript.wszName, ref.wstrName);
    ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_NAME;
    IDirectMusicLoader* pLoader;
    IDirectMusicGetLoader *pIGetLoader; 
    hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (!SUCCEEDED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (!SUCCEEDED(hr)) return hr;
    IDirectMusicObject* pObject = NULL;
    // Ignore this result (except for purposes of incorporating it into the style):
    // success or failure of loading individual ChordMap references should have no 
    // bearing on the success or failure of loading the style.
    hrChordMap = pLoader->GetObject(&ObjectDescript, IID_IDirectMusicObject, (void**)&pObject);
    if (!SUCCEEDED(hrChordMap))
    {
        hr = strFileName.ReadWCS( pStream, dwSize );
        if (SUCCEEDED(hr))
        {
            strFileName += ".per";
            wcscpy(ObjectDescript.wszFileName, strFileName);
            ObjectDescript.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
            hrChordMap = pLoader->GetObject(&ObjectDescript, IID_IDirectMusicObject, (void**)&pObject);
        }
    }
    pLoader->Release();
    if (SUCCEEDED(hrChordMap))
    {
        IDirectMusicChordMap* pPers;
        hr = pObject->QueryInterface(IID_IDirectMusicChordMap, (void**)&pPers);
        pObject->Release();
        if (SUCCEEDED(hr))
        {
            hr = IncorporatePersonality(pPers, ref.wstrName, ref.fDefault);
        }
    }

    return hr;
}
#endif

HRESULT CDMStyle::IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault )
{
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    TListItem<IDirectMusicChordMap*>* pScan = m_StyleInfo.m_PersList.GetHead();
    for( ; pScan != NULL ; pScan = pScan->GetNext() )
    {
        HRESULT hr = S_OK;
        String str2;
        
        IDirectMusicObject *pIObject = NULL;  
        DMUS_OBJECTDESC Desc;              // Descriptor.

        if (SUCCEEDED(hr = pScan->GetItemValue()->QueryInterface(IID_IDirectMusicObject,(void **) &pIObject))) 
        {
            if (SUCCEEDED(hr = pIObject->GetDescriptor(&Desc)))
            {
                if (Desc.dwValidData & DMUS_OBJ_NAME)
                {
                    str2 = Desc.wszName;
                    if (strName == str2)
                    {
                        pPers->Release();
                        break;
                    }
                }
                else hr = E_FAIL;
            }
            pIObject->Release();
        }
        if (!SUCCEEDED(hr))
        {
            LEAVE_CRITICAL_SECTION( &m_CriticalSection );
            return hr;
        }
    }
    if( pScan == NULL )
    {
        TListItem<IDirectMusicChordMap*>* pNew = NULL;
        pNew = new TListItem<IDirectMusicChordMap*>(pPers);
        if (pNew)
        {
            m_StyleInfo.m_PersList.AddHead(pNew);
            if (fDefault)
            {
                if (m_StyleInfo.m_pDefaultPers) m_StyleInfo.m_pDefaultPers->Release();
                m_StyleInfo.m_pDefaultPers = pPers;
            }
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDMStyle::DM_ParseDescriptor

HRESULT CDMStyle::DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  )
{
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    HRESULT       hr = S_OK;
    String        str;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicStyle;
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &pDesc->guidObject, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_ERROR;
                }
                else
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
            {
                dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
                hr = pIStream->Read( &pDesc->vVersion, dwSize, &dwByteCount );
                if( FAILED( hr )||  dwByteCount != dwSize )
                {
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_ERROR;
                }
                else
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                    hr = ReadMBSfromWCS( pIStream, ckList.cksize, str );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    wcscpy(pDesc->wszName, str);
                                    if(pDesc->wszName[0])
                                    {
                                        pDesc->dwValidData |= DMUS_OBJ_NAME;
                                        pDesc->wszName[16] = 0;
                                    }
                                    break;

                                case DMUS_FOURCC_CATEGORY_CHUNK:
                                    hr = ReadMBSfromWCS( pIStream, ckList.cksize, str );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    wcscpy(pDesc->wszCategory, str);
                                    if(pDesc->wszCategory[0])
                                    {
                                        pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                                        pDesc->wszCategory[16] = 0;
                                    }
                                    break;
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDMStyle::DM_LoadStyle

HRESULT CDMStyle::DM_LoadStyle( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain  )
{
    DirectMusicPart* pPart;
    IStream*      pIStream;
    MMCKINFO      ck;
    MMCKINFO      ckList;
    DWORD         dwByteCount;
    DWORD         dwSize;
    DWORD         dwPos;
    HRESULT       hr = S_OK;
    HRESULT       hrBand = S_OK;
    BOOL          fFoundDefault = FALSE;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_STYLE_CHUNK:
            {
                DMUS_IO_STYLE iDMStyle;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
                hr = pIStream->Read( &iDMStyle, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure = iDMStyle.timeSig.bBeatsPerMeasure;
                m_StyleInfo.m_TimeSignature.m_bBeat = iDMStyle.timeSig.bBeat;
                m_StyleInfo.m_TimeSignature.m_wGridsPerBeat = iDMStyle.timeSig.wGridsPerBeat;
                m_StyleInfo.m_dblTempo = iDMStyle.dblTempo;
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &m_StyleInfo.m_guid, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
            {
                DMUS_IO_VERSION iDMStyleVersion;

                dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
                hr = pIStream->Read( &iDMStyleVersion, dwSize, &dwByteCount );
                if( FAILED( hr )
                ||  dwByteCount != dwSize )
                {
                    hr = E_FAIL;
                    goto ON_ERROR;
                }

                m_StyleInfo.m_dwVersionMS = iDMStyleVersion.dwVersionMS;
                m_StyleInfo.m_dwVersionLS = iDMStyleVersion.dwVersionLS;
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_STYLE_PERS_REF_LIST:
                    {
                        hr = DM_LoadPersonalityReference( pIRiffStream, &ck );
                        if( FAILED( hr ) )
                        {
                            goto ON_ERROR;
                        }
                        break;
                    }

                    case DMUS_FOURCC_UNFO_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
                        {
                            switch( ckList.ckid )
                            {
                                case RIFFINFO_INAM:
                                case DMUS_FOURCC_UNAM_CHUNK:
                                    hr = ReadMBSfromWCS( pIStream, ckList.cksize, m_StyleInfo.m_strName );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;

                                case DMUS_FOURCC_CATEGORY_CHUNK:
                                    hr = ReadMBSfromWCS( pIStream, ckList.cksize, m_StyleInfo.m_strCategory );
                                    if (FAILED(hr))
                                    {
                                        goto ON_ERROR;
                                    }
                                    break;
                            }
                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;

                    case DMUS_FOURCC_PART_LIST:
                        pPart = m_StyleInfo.AllocPart();
                        if( pPart == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        hr = pPart->DM_LoadPart( pIRiffStream, &ck, &m_StyleInfo );
                        if( FAILED( hr ) )
                        {
                            m_StyleInfo.DeletePart( pPart );
                            goto ON_ERROR;
                        }
                        if( hr == S_FALSE )
                        {
                            // This should not happen when loading a Style!
                            Trace(0, "LOAD CONFLICT: Two parts with the same Guid.\n");
                            assert( 0 );
                            // Bypass this Part because Style already contains a Part
                            // whose GUID matches pPart->m_guidPartID
                            m_StyleInfo.DeletePart( pPart );
                        }
                        break;

                case DMUS_FOURCC_PATTERN_LIST:
                        StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
                        CDirectMusicPattern* pPattern = 
                            new CDirectMusicPattern( &m_StyleInfo.m_TimeSignature, FALSE );
                        if( pPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        ckList.fccType = DMUS_FOURCC_PATTERN_LIST;
                        if( pIRiffStream->Descend( &ckList, NULL, MMIO_FINDLIST ) != 0 )
                        {
                            hr = E_FAIL;
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        hr = pPattern->DM_LoadPattern( pIRiffStream, &ckList, &m_StyleInfo );
                        pIRiffStream->Ascend( &ckList, 0 );
                        if( FAILED( hr ) )
                        {
                            pPattern->Release();
                            goto ON_ERROR;
                        }
                        TListItem<CDirectMusicPattern*>* pPatternItem =
                            new TListItem<CDirectMusicPattern*>(pPattern);
                        if( pPatternItem == NULL )
                        {
                            hr = E_OUTOFMEMORY ;
                            goto ON_ERROR;
                        }
                        if( pPattern->m_wEmbellishment & EMB_MOTIF )
                        {
                            m_StyleInfo.m_MotifList.AddTail( pPatternItem );
                        }
                        else
                        {
                            m_StyleInfo.m_PatternList.AddTail( pPatternItem );
                        }
                        break;
                }
                break;

            case FOURCC_RIFF:
                switch( ck.fccType )
                {
                    case FOURCC_BAND_FORM:
                    case DMUS_FOURCC_BAND_FORM:
                    {
                        TListItem<IDirectMusicBand*>* pBandListItem = new TListItem<IDirectMusicBand*>;
                        if(pBandListItem)
                        {
                            pBandListItem->GetItemValue() = NULL;
    
                            // Create a band
                            hr = DirectMusicCreateInstance(CLSID_DirectMusicBand,NULL,
                                IID_IDirectMusicBand,(void**)&(pBandListItem->GetItemValue()));
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Seek back to begining of Riff chunk
                            // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                            // Get current position
                            LARGE_INTEGER li;
                            ULARGE_INTEGER ul;
                            li.HighPart = 0;
                            li.LowPart = 0;
                            hr = pIStream->Seek(li,
                                               STREAM_SEEK_CUR,
                                               &ul);
                            if(SUCCEEDED(hr))
                            {
                                li.HighPart = 0;
                                // This is always a valid operation
                                li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                                hr = pIStream->Seek(li, 
                                                   STREAM_SEEK_SET,
                                                   &ul);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            // Load band
                            IPersistStream* pIPersistStream;
                            hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
                            if (hr != S_OK)
                            {
                                hrBand = hr;
                            }
                            if(SUCCEEDED(hr))
                            {
                                hr = pIPersistStream->Load(pIStream);
                                pIPersistStream->Release();
                                DWORD dwFlags = 0;
                                if(SUCCEEDED(hr))
                                {
                                    IDirectMusicBandPrivate *pIDMBandP = NULL;
                                    hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = pIDMBandP->GetFlags(&dwFlags);
                                        if(SUCCEEDED(hr))
                                        {
                                            if( (ck.fccType == FOURCC_BAND_FORM && (dwFlags & DMUSB_DEFAULT)) || 
                                                (ck.fccType == DMUS_FOURCC_BAND_FORM && !fFoundDefault) )
                                            {
                                                // We have a default band
                                                m_StyleInfo.m_pDefaultBand = pBandListItem->GetItemValue();
                                                fFoundDefault = TRUE;
                                            }
                                        }
                                        
                                        pIDMBandP->Release();
                                    }
                                }
                            }
                        }
                        if(FAILED(hr))
                        {
                            if(pBandListItem)
                            {
                                IDirectMusicBand* pBand = pBandListItem->GetItemValue();
                                if(pBand)
                                {
                                    pBand->Release();
                                }
                                delete pBandListItem;
                            }
                            goto ON_ERROR;
                        }
                        ENTER_CRITICAL_SECTION(&m_CriticalSection);
                        (m_StyleInfo.m_BandList).AddHead(pBandListItem);
                        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
                    }   
                    break;
                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    // Merge the marker event start times in each of the patterns
    TListItem<CDirectMusicPattern*>* pPattern;
    pPattern = m_StyleInfo.m_PatternList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        pPattern->GetItemValue()->MergeMarkerEvents(&m_StyleInfo);
    }
    pPattern = m_StyleInfo.m_MotifList.GetHead();
    for (; pPattern != NULL; pPattern = pPattern->GetNext())
    {
        pPattern->GetItemValue()->MergeMarkerEvents(&m_StyleInfo);
    }
    pIStream->Release();
    if (hr == S_OK && hrBand != S_OK)
    {
        hr = hrBand;
    }
    return hr;
}


HRESULT CDMStyle::DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
    BOOL    fDefaultPers = TRUE;
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                // Ignore this result: success or failure of loading individual
                // ChordMap references should have no bearing on the success or
                // failure of loading the style.
                //hr = LoadReference(pIStream, pIRiffStream, ck, fDefaultPers);
                LoadReference(pIStream, pIRiffStream, ck, fDefaultPers);
                fDefaultPers = FALSE;
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    pIStream->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDMStyle::LoadReference

HRESULT CDMStyle::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         BOOL fDefault)
{
    if (!pStream || !pIRiffStream) return E_INVALIDARG;

    IDirectMusicChordMap* pChordMap;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;
    
    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;
        
    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    
        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }

    if (!(desc.dwValidData &  DMUS_OBJ_NAME) )
    {
        hr = E_FAIL;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc,IID_IDirectMusicChordMap, (void**)&pChordMap);
        if (SUCCEEDED(hr))
        {
            hr = IncorporatePersonality(pChordMap, desc.wszName, fDefault);
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

#ifdef DXAPI
HRESULT CDMStyle::IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain )
{
    HRESULT     hr = S_OK;
    HRESULT     hrBand = S_OK;
    MMCKINFO    ck;
    DWORD       cb;
    DWORD       cSize;
    LPSTREAM    pStream;
    ioStyle     iStyle; // in iostructs.h
    BOOL fReadStyle = FALSE;

    pStream = pRIFF->GetStream();
    while( pRIFF->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
        case FOURCC_STYLE:
            fReadStyle = TRUE;
            cSize = min( ck.cksize, sizeof( iStyle ) );
            hr = pStream->Read( &iStyle, cSize, &cb );
            FixBytes( FBT_IOSTYLE, &iStyle );
            if( FAILED( hr ) || cb != cSize )
            {
                hr = E_FAIL;
                goto ON_ERR;
            }
            m_StyleInfo.m_dwVersionMS = m_StyleInfo.m_dwVersionLS = 0;  // no version info in IMA 2.5
            m_StyleInfo.m_strName = iStyle.wstrName;
            m_StyleInfo.m_TimeSignature.m_bBeatsPerMeasure = (BYTE) iStyle.wBPM;
            m_StyleInfo.m_TimeSignature.m_bBeat = (BYTE) iStyle.wBeat;
            m_StyleInfo.m_TimeSignature.m_wGridsPerBeat = iStyle.wClocksPerBeat / iStyle.wClocksPerClick;
            m_StyleInfo.m_dblTempo = iStyle.wTempo;
            m_StyleInfo.m_strCategory = iStyle.wstrCategory;
            memcpy( &m_StyleInfo.m_guid, &iStyle.guid, sizeof( m_StyleInfo.m_guid ) );
            break;
        // find ChordMap reference
        case FOURCC_PERSONALITYREF:
            hr = IMA25_LoadPersonalityReference( pStream, &ck );
            if( FAILED( hr ) )
            {
                goto ON_ERR;
            }
             break;
        case FOURCC_RIFF:
            switch( ck.fccType )
            {
                case FOURCC_BAND_FORM:
                {
                    TListItem<IDirectMusicBand*>* pBandListItem = new TListItem<IDirectMusicBand*>;

                    if(pBandListItem)
                    {
                        pBandListItem->GetItemValue() = NULL;

                        // Create a band
                        hr = DirectMusicCreateInstance(CLSID_DirectMusicBand,NULL,
                            IID_IDirectMusicBand,(void**)&(pBandListItem->GetItemValue()));
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Seek back to begining of Riff chunk
                        // This is the amount read by Descend when descending into a FOURCC_RIFF chunk
                        // Get current position
                        LARGE_INTEGER li;
                        ULARGE_INTEGER ul;
                        li.HighPart = 0;
                        li.LowPart = 0;
                        hr = pStream->Seek(li,
                                           STREAM_SEEK_CUR,
                                           &ul);
                        
                        if(SUCCEEDED(hr))
                        {
                            li.HighPart = 0;
                            // This is always a valid operation
                            li.LowPart = ul.LowPart - (2 * sizeof(FOURCC) + sizeof(DWORD));
                            hr = pStream->Seek(li, 
                                               STREAM_SEEK_SET,
                                               &ul);
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load band
                        IPersistStream* pIPersistStream;
                        hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
                        
                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pStream);
                            if (hr != S_OK)
                            {
                                hrBand = hr;
                            }
                            pIPersistStream->Release();
                            DWORD dwFlags = 0;
                            
                            IDirectMusicBandPrivate *pIDMBandP = NULL;
                            hr = (pBandListItem->GetItemValue())->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);
                            if(SUCCEEDED(hr))
                            {
                                hr = pIDMBandP->GetFlags(&dwFlags);
                                if(SUCCEEDED(hr))
                                {
                                    if(dwFlags & DMUSB_DEFAULT)
                                    {
                                        // We have a default band
                                        m_StyleInfo.m_pDefaultBand = pBandListItem->GetItemValue();
                                    }
                                }
                                
                                pIDMBandP->Release();
                            }
                        }
        
                    }
                    
                    if(FAILED(hr))
                    {
                        if(pBandListItem)
                        {
                            IDirectMusicBand* pBand = pBandListItem->GetItemValue();
                            if(pBand)
                            {
                                pBand->Release();
                            }
                            
                            delete pBandListItem;
                        }
                
                        goto ON_ERR;
                    }

                    ENTER_CRITICAL_SECTION(&m_CriticalSection);
                    (m_StyleInfo.m_BandList).AddHead(pBandListItem);
                    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
                }   
                break;

                // find first pattern
                case FOURCC_PATTERN_FORM:
                   if( fReadStyle )
                    {
                        TListItem<CDirectMusicPattern*>* pOldPattern = new TListItem<CDirectMusicPattern*>;
                        if( pOldPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto ON_ERR;
                        }
                        CDirectMusicPattern*& rpOldPattern = pOldPattern->GetItemValue();
                        rpOldPattern = new CDirectMusicPattern;
                        if( rpOldPattern == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            goto ON_ERR;
                        }
                      
                        hr = rpOldPattern->LoadPattern( pRIFF, &ck, m_StyleInfo.m_PartList, m_StyleInfo);
                        if( FAILED( hr ) )
                        {
                            hr = E_FAIL;
                            goto ON_ERR;
                        }
                        if( ( rpOldPattern->m_wEmbellishment & EMB_MOTIF ) != 0 )
                        {
                            ENTER_CRITICAL_SECTION( &m_CriticalSection );
                            m_StyleInfo.m_MotifList.AddTail(pOldPattern);
                            LEAVE_CRITICAL_SECTION( &m_CriticalSection );
                        }
                        else
                        {
                            ENTER_CRITICAL_SECTION( &m_CriticalSection );
                            m_StyleInfo.m_PatternList.AddTail(pOldPattern);
                            LEAVE_CRITICAL_SECTION( &m_CriticalSection );
                        }
                    }
                    break;
            }
            break;
        }
        pRIFF->Ascend( &ck, 0 );
    }
ON_ERR:
    
    
    pStream->Release();
    // sort here
    TListItem<DirectMusicPart*>* pPartItem = m_StyleInfo.m_PartList.GetHead();
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        pPartItem->GetItemValue()->EventList.MergeSort(m_StyleInfo.m_TimeSignature);
    }
    if (hr == S_OK && hrBand != S_OK)
    {
        hr = hrBand;
    }
    return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::FindPartByGUID

DirectMusicPart* DMStyleStruct::FindPartByGUID( GUID guidPartID )
{
    DirectMusicPart* pThePart = NULL;
    DirectMusicPart* pPart;

    TListItem<DirectMusicPart*>* pScan = m_PartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pPart = pScan->GetItemValue();
        
        if( ::IsEqualGUID( pPart->m_guidPartID, guidPartID ) )
        {
            pThePart = pPart;
            break;
        }
    }

    return pThePart;
}


/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::AllocPart

DirectMusicPart* DMStyleStruct::AllocPart(  )
{
    DirectMusicPart* pPart = new DirectMusicPart(&m_TimeSignature);
    if (pPart)
    {
        TListItem<DirectMusicPart*>* pPartItem = new TListItem<DirectMusicPart*>(pPart);
        if( pPartItem)
        {
            // Add Part to Style's list of Parts
            m_PartList.AddTail( pPartItem );
        }
        else
        {
            delete pPart;
            pPart = NULL;
        }
    }

    return pPart;
}

/////////////////////////////////////////////////////////////////////////////
// DMStyleStruct::DeletePart

void DMStyleStruct::DeletePart( DirectMusicPart* pPart )
{
    TListItem<DirectMusicPart*>* pPartItem = m_PartList.GetHead();
    TListItem<DirectMusicPart*>* pPrevious = NULL;
    for ( ; pPartItem; pPartItem = pPartItem->GetNext() )
    {
        DirectMusicPart* pScan = pPartItem->GetItemValue();
        if (pPart == pScan)
        {
            pScan->Release();
            if (pPrevious)
            {
                pPrevious->SetNext(pPartItem->GetNext());
            }
            else
            {
                m_PartList.RemoveHead();
            }
            pPartItem->SetNext(NULL);
            delete pPartItem;
            break;
        }
        pPrevious = pPartItem;
    }
}

HRESULT DMStyleStruct::GetCommand(
                            MUSIC_TIME mtTime, 
                            MUSIC_TIME mtOffset, 
                            IDirectMusicPerformance* pPerformance,
                            IDirectMusicSegment* pSegment,
                            DWORD dwGroupID,
                            DMUS_COMMAND_PARAM_2* pCommand,
                            BYTE& rbActualCommand)
{
    HRESULT hr = S_OK;
    if (!pPerformance && !pSegment) return E_INVALIDARG;
    if (pPerformance)
    {
        hr = pPerformance->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtTime + mtOffset,
                                    NULL, ((void*) pCommand));
    }
    else
    {
        hr = pSegment->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtTime,
                                    NULL, ((void*) pCommand));
    }
    if (FAILED(hr)) return hr;
    // Look at the command's mtTime to see how far in the past it occurred.  If a measure
    // or more, keep the groove level but make the command a regular groove.
    MUSIC_TIME mtMeasureTime = (MUSIC_TIME) m_TimeSignature.ClocksPerMeasure();
    //TraceI(0, "Now: %d Offset: %d Command: %x, Groove Level: %d, Command time: %d  Measure time: %d\n",
    //  mtTime, mtOffset, pCommand->bCommand, pCommand->bGrooveLevel, pCommand->mtTime, mtMeasureTime);
    rbActualCommand = pCommand->bCommand;
    if (pCommand->mtTime + mtMeasureTime <= 0 ||
        (pCommand->mtTime + mtMeasureTime < mtMeasureTime && 
         (mtMeasureTime + pCommand->mtTime) % mtMeasureTime) )
    {
        pCommand->bCommand = DMUS_COMMANDT_GROOVE;
    }
    return hr;
}

struct TaggedCommands
{
    TaggedCommands()
    {
        m_pCommands = NULL;
        m_pRhythms = NULL;
        m_mtTag = 0;
    }
    HRESULT Init(MUSIC_TIME mtTag, int nSize, int nGlobalGroove)
    {
        HRESULT hr = S_OK;
        m_mtTag = mtTag;
        m_pCommands = new DMUS_COMMAND_PARAM_2 [nSize];
        m_pRhythms = new DWORD [nSize];
        if (!m_pCommands || !m_pRhythms)
        {
            Cleanup();
            hr = E_OUTOFMEMORY;
        }
        else
        {
            int nGroove = 62 + nGlobalGroove;
            if (nGroove > 100) nGroove = 100;
            if (nGroove < 1) nGroove = 1;
            m_pCommands[0].bGrooveLevel = (BYTE)nGroove;
            m_pCommands[0].bGrooveLevel = 62;
            m_pCommands[0].bGrooveRange = 0;
            m_pCommands[0].bCommand = DMUS_COMMANDT_GROOVE;
            m_pCommands[0].bRepeatMode = DMUS_PATTERNT_RANDOM;
            m_pRhythms[0] = 0;
        }
        return hr;
    }
    void Cleanup()
    {
        if (m_pCommands) delete [] m_pCommands;
        if (m_pRhythms) delete [] m_pRhythms;
    }
    ~TaggedCommands()
    {
        Cleanup();
    }
    MUSIC_TIME m_mtTag;
    DMUS_COMMAND_PARAM_2* m_pCommands; 
    DWORD* m_pRhythms;
};

TListItem<TaggedCommands>* FindTaggedCommands(MUSIC_TIME mtTag, TList<TaggedCommands>& rCommands)
{
    TListItem<TaggedCommands>* pScan = rCommands.GetHead();
    for(; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().m_mtTag == mtTag) return pScan;
    }
    return NULL;
}

CDirectMusicPattern* DMStyleStruct::SelectPattern(bool fNewMode, 
                                   DMUS_COMMAND_PARAM_2* pCommands, 
                                   StyleTrackState* StyleTrackState, 
                                   PatternDispatcher& rDispatcher)
{
    if (rDispatcher.IsEmpty()) return NULL;
    if (!UsingDX8() || !StyleTrackState)
    {
        return rDispatcher.RandomSelect();
    }
    CDirectMusicPattern* pResult = NULL;
    TListItem<CDirectMusicPattern*>* pNew = NULL;
    TListItem<CDirectMusicPattern*>* pScan = NULL;
    int nIndex = 0;
    if (pCommands)
    {
        switch (pCommands[0].bRepeatMode)
        {
        case DMUS_PATTERNT_RANDOM:
            pResult = rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_REPEAT:
            pResult = (!fNewMode && S_OK == rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex))
                ? StyleTrackState->m_pPattern : rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_SEQUENTIAL:
        case DMUS_PATTERNT_RANDOM_START:
            if (fNewMode)
            {
                if (pCommands[0].bRepeatMode == DMUS_PATTERNT_SEQUENTIAL)
                {
                    pResult = rDispatcher.GetItem(0);
                }
                else
                {
                    pResult = rDispatcher.RandomSelect();
                }
            }
            else
            {
                HRESULT hr = rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex);
                if (hr == S_OK && rDispatcher.GetItem(nIndex + 1))
                {
                    pResult = rDispatcher.GetItem(nIndex + 1);
                }
                else
                {
                    pResult = rDispatcher.GetItem(0);
                }
            }
            break;
        case DMUS_PATTERNT_NO_REPEAT:
            if (!fNewMode)
            {
                HRESULT hr = rDispatcher.FindPattern(StyleTrackState->m_pPattern, nIndex);
                if (hr == S_OK)
                {
                    rDispatcher.SetTag(nIndex, REMOVED);
                }
            }
            pResult = rDispatcher.RandomSelect();
            break;
        case DMUS_PATTERNT_RANDOM_ROW:
            if (fNewMode)
            {
                StyleTrackState->m_PlayedPatterns.CleanUp();
            }
            pScan = StyleTrackState->m_PlayedPatterns.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                HRESULT hr = rDispatcher.FindPattern(pScan->GetItemValue(), nIndex);
                if (hr == S_OK)
                {
                    rDispatcher.SetTag(nIndex, RANDOM_ROW);
                }
            }
            if (rDispatcher.IsEmpty()) // start over, but avoid the one just played
            {
                rDispatcher.RestorePatterns(RANDOM_ROW);
                pScan = StyleTrackState->m_PlayedPatterns.GetHead();
                if (pScan)
                {
                    HRESULT hr = rDispatcher.FindPattern(pScan->GetItemValue(), nIndex);
                    if (hr == S_OK)
                    {
                        rDispatcher.SetTag(nIndex, RANDOM_ROW);
                    }
                }
                StyleTrackState->m_PlayedPatterns.CleanUp();
            }
            pResult = rDispatcher.RandomSelect();
            if (pResult)
            {
                pNew = new TListItem<CDirectMusicPattern*>(pResult);
                if (pNew)
                {
                    StyleTrackState->m_PlayedPatterns.AddHead(pNew);
                }
            }
            break;
        default:
            pResult = rDispatcher.RandomSelect();
            break;
        }
    }
    return pResult;
}

HRESULT DMStyleStruct::GetPattern(
            bool fNewMode,
            MUSIC_TIME mtNow, 
            MUSIC_TIME mtOffset, 
            StyleTrackState* pStyleTrackState,
            IDirectMusicPerformance* pPerformance,
            IDirectMusicSegment* pSegment,
            CDirectMusicPattern*& rpTargetPattern,
            MUSIC_TIME& rmtMeasureTime, 
            MUSIC_TIME& rmtNextCommand)
{
    if (!pSegment && !pPerformance) return E_INVALIDARG;
    static aMatchType[5] = 
        {MATCH_COMMAND_AND_RHYTHM, MATCH_COMMAND_FULL, MATCH_COMMAND_PARTIAL, MATCH_EMBELLISHMENT, MATCH_GROOVE_LEVEL};
    HRESULT hr = S_OK;
    MUSIC_TIME mtNextStyleTime = pStyleTrackState ? pStyleTrackState->m_mtNextStyleTime : 0;
    DMUS_RHYTHM_PARAM ChordRhythm;
    TList<TaggedCommands> Commands;
    int nLongestPattern = 0;
    int nPatternLength = 1;
    DWORD dwGroupID = pStyleTrackState ? pStyleTrackState->m_dwGroupID : 0xffffffff;
    TListItem<CDirectMusicPattern*> *pPatternItem = m_PatternList.GetHead();
    for (; pPatternItem != NULL; pPatternItem = pPatternItem->GetNext())
    {
        CDirectMusicPattern*& rpPattern = pPatternItem->GetItemValue();
        if (rpPattern->m_wNumMeasures > nLongestPattern)
            nLongestPattern = rpPattern->m_wNumMeasures;
    }
    if (nLongestPattern <= 0) return E_POINTER;

   char chGroove;
    if (!pPerformance || 
        !SUCCEEDED(pPerformance->GetGlobalParam((GUID)GUID_PerfMasterGrooveLevel, &chGroove, 1))) 
    {
        chGroove = 0;
    }
    DMUS_COMMAND_PARAM_2 CommandParam;
    // this call to GetParam is for rmtNextCommand only (?)
    HRESULT hrCommand = E_FAIL;
    if (pPerformance)
    {
        hrCommand = pPerformance->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                                &rmtNextCommand, ((void*) &CommandParam));
    }
    else
    {
        hrCommand = pSegment->GetParam(GUID_CommandParam2, dwGroupID, DMUS_SEG_ANYTRACK, mtNow,
                                                &rmtNextCommand, ((void*) &CommandParam));
    }
    if (DMUS_E_TRACK_NOT_FOUND == hrCommand || rmtNextCommand <= 0) // Happens if the performance can't find a segment with a command track
    {
        if (mtNextStyleTime) rmtNextCommand = mtNextStyleTime;
        else if (pStyleTrackState && pStyleTrackState->m_pSegState)
        {
            MUSIC_TIME mtLength = 0;
            IDirectMusicSegment* pSegment = NULL;
            if (SUCCEEDED(pStyleTrackState->m_pSegState->GetSegment(&pSegment)))
            {
                hr = pSegment->GetLength(&mtLength);
                pSegment->Release();
                // GetLength may return DMUS_S_GARBAGE_COLLECTED which FAILED will not catch
                if(hr != S_OK)
                {
                    mtLength = 0x7FFFFFFF;
                }
            }
            rmtNextCommand = mtLength - mtNow;
        }
        else rmtNextCommand = 0;
    }
    MUSIC_TIME mtStyleDifference = mtNextStyleTime ? mtNextStyleTime - mtNow : 0;
    if ( mtStyleDifference > 0 && (!rmtNextCommand || mtStyleDifference < rmtNextCommand) )
    {
        rmtNextCommand = mtStyleDifference;
    }
    if (pStyleTrackState)
    {
        if (FAILED(hrCommand) || pStyleTrackState->m_CommandData.bRepeatMode != CommandParam.bRepeatMode)
        {
            fNewMode = true;
        }
        pStyleTrackState->m_CommandData = CommandParam;
        pStyleTrackState->m_CommandData.bGrooveLevel += chGroove;
    }

    TListItem<TaggedCommands>* pTaggedCommands = NULL;
    PatternDispatcher Dispatcher(m_PatternList, rmtNextCommand, mtNow, mtOffset, pStyleTrackState, pPerformance, this);
    // find a pattern matching the chord rhythm and command
    for (int nMatch = 0; nMatch < 5; nMatch++, Dispatcher.RestoreAllPatterns())
    {
        if (nMatch > 2 && !UsingDX8()) break; // only do these for dx8
        // while more pattern lengths:
        do
        {
            // divide current list into those with the longest patterns and eveything else
            Dispatcher.ResetMeasures();
            Dispatcher.Scan(FIND_LONGEST_PATTERN);
            Dispatcher.Filter(COLLECT_LONGEST_PATTERN);
            // while more time signatures:
            do
            {
                DirectMusicTimeSig TimeSig;
                // divide list into those with "longest" time sigs and everything else
                Dispatcher.ResetTimeSig();
                Dispatcher.Scan(FIND_LONGEST_TIMESIG);
                Dispatcher.Filter(COLLECT_LONGEST_TIMESIG);
                // fill up pCommands and pRhythms (also get mtMeasureTime, based on time sig)
                CDirectMusicPattern* pFirstPattern = Dispatcher.GetItem(0);
                MUSIC_TIME mtMeasureTime = 0;
                if (pFirstPattern)
                {
                    TimeSig = pFirstPattern->TimeSignature(this);
                }
                else
                {
                    TimeSig = m_TimeSignature;
                }
                mtMeasureTime = TimeSig.ClocksPerMeasure();
                Dispatcher.SetMeasureTime(mtMeasureTime);

                IDirectMusicStyle* pThisStyle = NULL;
                MUSIC_TIME mtNextStyle = 0;
                if (SUCCEEDED(pPerformance->GetParam(GUID_IDirectMusicStyle, dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                            &mtNextStyle, (void*) &pThisStyle)))
                {
                    if (mtNextStyle && mtMeasureTime)
                    {
                        nPatternLength = (mtNextStyle / mtMeasureTime);
                        if (!nPatternLength) nPatternLength = 1;
                    }
                    if (nPatternLength > nLongestPattern) nPatternLength = nLongestPattern;
                    pThisStyle->Release();
                }
                Dispatcher.SetPatternLength(nPatternLength);

                 pTaggedCommands = FindTaggedCommands(mtMeasureTime, Commands);
                if (!pTaggedCommands)
                {
                    pTaggedCommands = new TListItem<TaggedCommands>;
                    if (!pTaggedCommands) return E_OUTOFMEMORY;
                    TaggedCommands& rCommands = pTaggedCommands->GetItemValue();
                    hr = rCommands.Init(mtMeasureTime, nPatternLength, chGroove);
                    if (FAILED(hr)) return hr;
                    Commands.AddHead(pTaggedCommands);
                    if (SUCCEEDED(hrCommand))
                    {
                        HRESULT hrChord = S_OK;
                        // get chord rhythm for next measure(s)
                        // get command for next measure(s)
                        ChordRhythm.TimeSig = TimeSig;
                        for (short i = 0; i < nPatternLength; i++)
                        {
                            BYTE bActualCommand;
                            if (S_OK != GetCommand(mtNow + (i * mtMeasureTime), 
                                    mtOffset, pPerformance, pSegment, dwGroupID, &CommandParam, 
                                    bActualCommand))
                            {
                                break;
                            }
                            rCommands.m_pCommands[i] = CommandParam;
                            short nGroove = CommandParam.bGrooveLevel + chGroove;
                            if (nGroove > 100) nGroove = 100;
                            if (nGroove < 1) nGroove = 1;
                            rCommands.m_pCommands[i].bGrooveLevel = (BYTE)nGroove;
                            if (pPerformance)
                            {
                                hrChord = pPerformance->GetParam(GUID_RhythmParam, dwGroupID, DMUS_SEG_ANYTRACK, (mtNow + (i * mtMeasureTime) + mtOffset),
                                                            NULL, (void*) &ChordRhythm);
                            }
                            else
                            {
                                hrChord = pSegment->GetParam(GUID_RhythmParam, dwGroupID, DMUS_SEG_ANYTRACK, (mtNow + (i * mtMeasureTime)),
                                                            NULL, (void*) &ChordRhythm);
                            }
                            if (SUCCEEDED(hrChord))
                            {
                                rCommands.m_pRhythms[i] = ChordRhythm.dwRhythmPattern;
                            }
                            else
                            {
                                rCommands.m_pRhythms[i] = 0;
                            }
                            TraceI(3, "NOW: %d, i: %d, Groove level: %d, command: %d, rhythm: %x\n",
                                mtNow + (i * mtMeasureTime), i, rCommands.m_pCommands[i].bGrooveLevel,
                                rCommands.m_pCommands[i].bCommand, rCommands.m_pRhythms[i]);
                        }
                    }
                }
                TaggedCommands& rCommands = pTaggedCommands->GetItemValue();
                Dispatcher.SetCommands(rCommands.m_pCommands, rCommands.m_pRhythms);
                // filter best matches, using aMatchType[nMatch]
                //   (MATCH_COMMAND_AND_RHYTHM also needs to filter with MATCH_RHYTHM_BITS)
                // break on match
                if (aMatchType[nMatch] == MATCH_COMMAND_AND_RHYTHM)
                {
                    Dispatcher.ResetRhythms();
                }
                Dispatcher.Filter(aMatchType[nMatch]);
                if (!Dispatcher.IsEmpty())
                {
                    if (aMatchType[nMatch] == MATCH_COMMAND_AND_RHYTHM)
                    {
                        Dispatcher.Filter(MATCH_RHYTHM_BITS);
                        if (!Dispatcher.IsEmpty()) break;
                        Dispatcher.RestorePatterns(MATCH_RHYTHM_BITS);
                    }
                    else break;
                }
                Dispatcher.ReplacePatterns(COLLECT_LONGEST_TIMESIG, REMOVED);
            } while (!Dispatcher.IsEmpty());
            if (!Dispatcher.IsEmpty()) break;
            Dispatcher.ReplacePatterns(COLLECT_LONGEST_PATTERN, REMOVED);
        } while (!Dispatcher.IsEmpty());
        if (!Dispatcher.IsEmpty()) break;
    }
    
    if (!Dispatcher.IsEmpty())
    {
        //TraceI(2, "Filtering Destinations...\n");
        Dispatcher.Filter(MATCH_NEXT_COMMAND);
        if (Dispatcher.IsEmpty())
        {
            Dispatcher.RestorePatterns(MATCH_NEXT_COMMAND);
        }
        rpTargetPattern = SelectPattern(fNewMode, pTaggedCommands->GetItemValue().m_pCommands, pStyleTrackState, Dispatcher);
    }
    // if all searches failed, select the first pattern
    if (!rpTargetPattern)
    {
        TraceI(1, "ALL SEARCHES FAILED\n");
        TListItem<CDirectMusicPattern*> *pPattern = m_PatternList.GetHead();
        if (pPattern) // if this is NULL, something's wrong
        {
            rpTargetPattern = pPattern->GetItemValue();
        }
    }
    if (rpTargetPattern) // if pTargetPattern is NULL, something's really wrong
    {
        rmtMeasureTime = rpTargetPattern->TimeSignature(this).ClocksPerMeasure();
        if (pStyleTrackState)
        {
            hr = pStyleTrackState->InitPattern(rpTargetPattern, mtNow);
        }
        TraceI(2, "Pattern: %S (%d, %d/%d) [%d]\n", 
        //TraceI(0, "Pattern: %S (%d, %d/%d) [%d]\n", 
            (const WCHAR *)rpTargetPattern->m_strName, rpTargetPattern->m_wNumMeasures, 
            rpTargetPattern->TimeSignature(this).m_bBeatsPerMeasure,
            rpTargetPattern->TimeSignature(this).m_bBeat, mtNow);
    }
    else hr = E_POINTER;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// AdjoinPChannel

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel)
{
    TListItem<DWORD>* pScan = rPChannelList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        DWORD rdwPChannel = pScan->GetItemValue();
        
        if( dwPChannel ==  rdwPChannel )
        {
            return S_OK;
        }
    }

    TListItem<DWORD>* pNew = new TListItem<DWORD>(dwPChannel);
    if (!pNew) return E_OUTOFMEMORY;
    rPChannelList.AddHead(pNew);
    return S_OK;
}

static inline BOOL InversionPoint(char chNote, DWORD dwInvertPattern)
{
    if (chNote < 0 || chNote >= 24) return FALSE;
    return (dwInvertPattern >> chNote) & 1;
}

static BYTE NotePosition(char chMidiValue, BYTE bRoot)
{
    chMidiValue -= bRoot;
    while (chMidiValue < 0) chMidiValue += 12;
    while (chMidiValue > 23) chMidiValue -= 12;
    return (BYTE)chMidiValue;
}

static char InversionAmountLow(
                BYTE bMidiValue, 
                BYTE bLower, 
                DWORD dwInvertPattern, 
                BYTE bRoot)
{
    char chResult = 0;
    TraceI(3, "InversionAmountLow: MidiValue: %d, Lower: %d, Pattern: %X, Root: %d\n", 
        bMidiValue, bLower, dwInvertPattern, bRoot);
    char chDifference = (char) (bLower - bMidiValue);
    char chPosition = NotePosition(bMidiValue, bRoot);
    while (chDifference > 23) chDifference -= 24;
    TraceI(3, "Position: %d Difference: %d\n", chPosition, chDifference);
    // Right now I'm checking both endpoints.  Is this what I want?
    for (char i = chPosition; chDifference >= 0; (i = (i < 23) ? i + 1 : 0), chDifference--)
    {
        if (InversionPoint(i, dwInvertPattern)) break;
    }
    if (chDifference >= 0)
    {
        while (bLower > bMidiValue + chResult)
        {
            chResult += 12;
        }
    }
    TraceI(3, "Result: %d\n", chResult);
    return chResult;
}

static char InversionAmountHigh(
                BYTE bMidiValue, 
                BYTE bUpper, 
                DWORD dwInvertPattern, 
                BYTE bRoot)
{
    char chResult = 0;
    TraceI(3, "InversionAmountHigh: MidiValue: %d, Upper: %d, Pattern: %X, Root: %d\n", 
        bMidiValue, bUpper, dwInvertPattern, bRoot);
    char chDifference = (char) (bMidiValue - bUpper);
    char chPosition = NotePosition(bMidiValue, bRoot);
    while (chDifference > 23) chDifference -= 24;
    TraceI(3, "Position: %d Difference: %d\n", chPosition, chDifference);
    // Right now I'm checking both endpoints.  Is this what I want?
    for (char i = chPosition; chDifference >= 0; (i = (i > 0) ? i - 1 : 23), chDifference--)
    {
        if (InversionPoint(i, dwInvertPattern)) break;
    }
    if (chDifference >= 0)
    {
        while ((char)bMidiValue + chResult > (char)bUpper)
        {
            chResult -= 12;
        }
    }
    TraceI(3, "Result: %d\n", chResult);
    return chResult;
}

static char InversionAmount(
                BYTE bMidiValue, 
                BYTE bLower, 
                BYTE bUpper, 
                DWORD dwInvertPattern, 
                BYTE bRoot)
{
    char chResult = 0;
    if (bMidiValue & 0x80) return 0; // out of range.
    if (dwInvertPattern & 0xff000000)
    {
        while (bMidiValue + chResult < bLower) chResult += 12;
        while (bMidiValue + chResult > bUpper) chResult -= 12;
        return chResult;
    }
    TraceI(4, "InversionAmount: MidiValue: %d, Lower: %d, Upper: %d, Pattern: %X, Root: %d\n", 
        bMidiValue, bLower, bUpper, dwInvertPattern, bRoot);
    if (bLower <= bMidiValue && bMidiValue <= bUpper) return 0;
    if (bMidiValue < bLower) 
    {
        chResult = InversionAmountLow(bMidiValue, bLower, dwInvertPattern, bRoot);
    }
    else
    {
        chResult = InversionAmountHigh(bMidiValue, bUpper, dwInvertPattern, bRoot);
    }
    return chResult;
}

HRESULT DirectMusicPartRef::ConvertMusicValue(CDMStyleNote* pNoteEvent, 
                              DMUS_CHORD_PARAM& rCurrentChord,
                              BYTE bPlayModeFlags,
                              BOOL fPlayAsIs,
                              InversionGroup aInversionGroups[],
                              IDirectMusicPerformance* pPerformance,
                              BYTE& rbMidiValue,
                              short& rnMidiOffset)
{
    bool fReleasePerformance = false;
    if (!pPerformance)
    {
        fReleasePerformance = true;
        if( FAILED( DirectMusicCreateInstance( CLSID_DirectMusicPerformance,
            NULL, IID_IDirectMusicPerformance,(void**)&pPerformance )))
        {
            return E_FAIL;
        }
    }
    // music value is computed using the current chord info and the playmode flags 
    // musicvalue is a MIDI note value (0-127)
    WORD wMV = pNoteEvent->m_wMusicValue;
    short nMidiOffset = 0;
    if (bPlayModeFlags != DMUS_PLAYMODE_FIXED)
    {
        DMSubChord rSubChord;
        DWORD dwLevel = 1 << m_bSubChordLevel;
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < rCurrentChord.bSubChordCount; dwIndex++)
        {
            if (dwLevel & rCurrentChord.SubChordList[dwIndex].dwLevels)
            {
                rSubChord = rCurrentChord.SubChordList[dwIndex];
                break;
            }
        }
        if (dwIndex == rCurrentChord.bSubChordCount)
        {
            rSubChord = rCurrentChord.SubChordList[0];
            dwIndex = 0;
        }
        DMUS_CHORD_KEY ChordAndKey;
        ZeroMemory(&ChordAndKey, sizeof(DMUS_CHORD_KEY));
        ChordAndKey.dwScale = rCurrentChord.dwScale;
        ChordAndKey.bSubChordCount = rCurrentChord.bSubChordCount;
        ChordAndKey.bKey = rCurrentChord.bKey;
        ChordAndKey.bFlags = 0;
        ChordAndKey.SubChordList[dwIndex].bChordRoot = rSubChord.m_bChordRoot;
        ChordAndKey.SubChordList[dwIndex].bScaleRoot = rSubChord.m_bScaleRoot;
        ChordAndKey.SubChordList[dwIndex].dwChordPattern = rSubChord.m_dwChordPattern;
        ChordAndKey.SubChordList[dwIndex].dwLevels = rSubChord.m_dwLevels;
        ChordAndKey.SubChordList[dwIndex].dwScalePattern = rSubChord.m_dwScalePattern;
        BYTE bChordRoot = 0;
        pPerformance->MusicToMIDI(
            (pNoteEvent->m_wMusicValue & 0xf000),
            &ChordAndKey,
            bPlayModeFlags,
            m_bSubChordLevel, 
            &bChordRoot);
        if (bPlayModeFlags == DMUS_PLAYMODE_CHORD_ROOT) // fixed to chord
        {
            wMV += (rSubChord.m_bChordRoot % 24);
        }
        else if (bPlayModeFlags == DMUS_PLAYMODE_SCALE_ROOT) // fixed to scale
        {
            wMV += rCurrentChord.bKey;
        }
        else
        {
            BYTE bMIDIVal;
            HRESULT hrTest = pPerformance->MusicToMIDI(
                pNoteEvent->m_wMusicValue,
                &ChordAndKey,
                bPlayModeFlags,
                m_bSubChordLevel, 
                &bMIDIVal);
            if (hrTest == S_OK)
            {
                wMV = bMIDIVal;
            }
            else
            {
                wMV = 0;
            }
        }
        if (wMV && !fPlayAsIs )
        {
            if (pNoteEvent->m_bInversionId == 0)
            {
                nMidiOffset = InversionAmount((BYTE)wMV, 
                m_pDMPart->m_bInvertLower,
                m_pDMPart->m_bInvertUpper,
                rSubChord.m_dwInversionPoints,
                bChordRoot);
            }
            else // handle inversion groups
            {
                short nIndex = FindGroup(aInversionGroups, pNoteEvent->m_bInversionId);
                if (nIndex >= 0) // invert according to the existing group
                {
                    nMidiOffset = aInversionGroups[nIndex].m_nOffset;
                    aInversionGroups[nIndex].m_wCount--;
                    if (aInversionGroups[nIndex].m_wCount == 0)
                        aInversionGroups[nIndex].m_wGroupID = 0;
                }
                else // create a new inversion group
                {
                    // 1. find out how many events have this group id for a count
                    WORD wCount = 1; // for this event...
                    CDirectMusicEventItem* pScan = pNoteEvent->GetNext();
                    for (; pScan; pScan = pScan->GetNext())
                    {
                        if (pScan->m_dwEventTag == DMUS_EVENT_NOTE)
                        {
                            CDMStyleNote* pScanEvent = (CDMStyleNote*)pScan;
                            if (pScanEvent->m_bInversionId == pNoteEvent->m_bInversionId)
                                wCount++;
                        }
                    }
                    // 2. call InversionAmount for an offset
                    short nOffset = InversionAmount((BYTE)wMV, 
                        m_pDMPart->m_bInvertLower,
                        m_pDMPart->m_bInvertUpper,
                        rSubChord.m_dwInversionPoints,
                        bChordRoot);
                    // 3. call AddGroup with the id, count, and offset
                    short nIndex2 = AddGroup(aInversionGroups, pNoteEvent->m_bInversionId, wCount, nOffset);
                    // 4. If the add was successful, do the inversion.
                    if (nIndex2 >= 0)
                    {
                        nMidiOffset = aInversionGroups[nIndex2].m_nOffset;
                        aInversionGroups[nIndex2].m_wCount--;
                        if (aInversionGroups[nIndex2].m_wCount == 0)
                            aInversionGroups[nIndex2].m_wGroupID = 0;
                    }
                }
            }
        }
    }
    wMV += nMidiOffset;
    while ((short)wMV < 0) wMV += 12;
    while (wMV > 127) wMV -= 12;
    // NOT IMPLEMENTED: Don't play notes with low priority when the device 
    // runs out of notes
    rbMidiValue = (BYTE) wMV;
    rnMidiOffset = nMidiOffset;
    if (fReleasePerformance) pPerformance->Release();
    return S_OK;
}

HRESULT DirectMusicPartRef::ConvertMIDIValue(BYTE bMIDI, 
                              DMUS_CHORD_PARAM& rCurrentChord,
                              BYTE bPlayModeFlags,
                              IDirectMusicPerformance* pPerformance,
                              WORD& rwMusicValue)
{
    HRESULT hr = S_OK;
    bool fReleasePerformance = false;
    if (!pPerformance)
    {
        fReleasePerformance = true;
        if( FAILED( DirectMusicCreateInstance( CLSID_DirectMusicPerformance,
            NULL, IID_IDirectMusicPerformance,(void**)&pPerformance )))
        {
            return E_FAIL;
        }
    }
    if (bPlayModeFlags != DMUS_PLAYMODE_FIXED)
    {
        DMSubChord rSubChord;
        DWORD dwLevel = 1 << m_bSubChordLevel;
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < rCurrentChord.bSubChordCount; dwIndex++)
        {
            if (dwLevel & rCurrentChord.SubChordList[dwIndex].dwLevels)
            {
                rSubChord = rCurrentChord.SubChordList[dwIndex];
                break;
            }
        }
        if (dwIndex == rCurrentChord.bSubChordCount)
        {
            rSubChord = rCurrentChord.SubChordList[0];
            dwIndex = 0;
        }
        DMUS_CHORD_KEY ChordAndKey;
        ZeroMemory(&ChordAndKey, sizeof(DMUS_CHORD_KEY));
        ChordAndKey.dwScale = rCurrentChord.dwScale;
        ChordAndKey.bSubChordCount = rCurrentChord.bSubChordCount;
        ChordAndKey.bKey = rCurrentChord.bKey;
        ChordAndKey.bFlags = 0;
        ChordAndKey.SubChordList[dwIndex].bChordRoot = rSubChord.m_bChordRoot;
        ChordAndKey.SubChordList[dwIndex].bScaleRoot = rSubChord.m_bScaleRoot;
        ChordAndKey.SubChordList[dwIndex].dwChordPattern = rSubChord.m_dwChordPattern;
        ChordAndKey.SubChordList[dwIndex].dwLevels = rSubChord.m_dwLevels;
        ChordAndKey.SubChordList[dwIndex].dwScalePattern = rSubChord.m_dwScalePattern;
        hr = pPerformance->MIDIToMusic(
                                bMIDI,
                                &ChordAndKey,
                                bPlayModeFlags,
                                m_bSubChordLevel, 
                                &rwMusicValue);
    }
    if (fReleasePerformance) pPerformance->Release();
    return hr;
}

short FindGroup(InversionGroup aGroup[], WORD wID)
{
    for (short n = 0; n < INVERSIONGROUPLIMIT; n++)
        if (wID == aGroup[n].m_wGroupID)
            return n;
    return -1;
}

short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short nOffset)
{
    for (short n = 0; n < INVERSIONGROUPLIMIT; n++)
    {
        if (aGroup[n].m_wGroupID == 0)
        {
            aGroup[n].m_wGroupID = wID;
            aGroup[n].m_wCount = wCount;
            aGroup[n].m_nOffset = nOffset;
            return n;
        }
    }
    return -1;
        
}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves 

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline BYTE RelativeRoot(char chChordRoot, char chScaleRoot)
{
    // is there any reason this should be > 12? 
    while (chScaleRoot > chChordRoot) chChordRoot += 12;
    BYTE bResult = chChordRoot - chScaleRoot;
    return bResult % 12;
}

// returns 1 - 7 for scale positions I - VII and 0 if chord isn't in scale
BYTE ScalePosition(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

// returns 1 - 7 for scale positions #I - #VII, 0 if not a sharp position
BYTE ScalePositionSharp(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    // now shift to see if this is sharp from the next position down
    if (dwRootBit == 1) dwRootBit <<= 11;
    else dwRootBit >>= 1;

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

// returns 1 - 7 for scale positions bI - bVII, 0 if not a flat position
BYTE ScalePositionFlat(DMSubChord& rSubChord, BYTE bKey, DWORD dwScale)
{
    DWORD dwScalePattern = dwScale ? CleanupScale(dwScale) : DEFAULT_SCALE_PATTERN;
    DWORD dwRootBit = (DWORD) (1 << RelativeRoot(rSubChord.m_bChordRoot, bKey));

    // now shift to see if this is flat from the next position up
    if (dwRootBit == (1 << 11)) dwRootBit = 1;
    else dwRootBit <<= 1;

    if (dwRootBit & dwScalePattern)
    {
        BYTE bResult = 0;
        while (dwRootBit > 0)
        {
            if (dwRootBit & dwScalePattern)
                bResult++;
            dwRootBit >>= 1;
        }
        return bResult;
    }
    else return 0;
}

bool IsSimple(DMUS_CHORD_PARAM& Chord)
{
    if (Chord.bSubChordCount <= 1)
    {
        return true;
    }
    else
    {
        bool fResult = true;
        for (int n = 1; n < Chord.bSubChordCount; n++)
        {
            if ( (Chord.SubChordList[n].dwChordPattern != Chord.SubChordList[0].dwChordPattern) ||
                 (Chord.SubChordList[n].dwScalePattern != Chord.SubChordList[0].dwScalePattern) ||
                 (Chord.SubChordList[n].bChordRoot != Chord.SubChordList[0].bChordRoot) ||
                 (Chord.SubChordList[n].bScaleRoot != Chord.SubChordList[0].bScaleRoot) )
            {
                fResult = false;
                break;
            }
        }
        return fResult;
    }
}

bool IsSimple(DMUS_CHORD_PARAM& Chord, int& rCount, int& rSixSeven)
{
    // Combine all the notes from all chord patterns into one pattern
    DWORD dwMOAPatterns = 0;
    int nBaseRoot = Chord.SubChordList[0].bChordRoot;
    for (int n = 0; n < Chord.bSubChordCount; n++)
    {
        int nShift = (int)Chord.SubChordList[n].bChordRoot - nBaseRoot;
        while (nShift < 0) nShift += 12;
        dwMOAPatterns |= (Chord.SubChordList[n].dwChordPattern << nShift);
    }
    // Fold both octaves of the pattern together
    DWORD dwHighOctave = (dwMOAPatterns & 0xfff000) >> 12;
    dwMOAPatterns = (dwMOAPatterns & 0xfff) | dwHighOctave;
    // count the total notes
    rCount = 0;
    rSixSeven = 0;
    for (n = 0; n < 12; n++)
    {
        if (dwMOAPatterns & (1 << n))
        {
            rCount++;
            if (n > 7) rSixSeven++;
        }
    }
    return rCount <= 4;
}

DWORD CDirectMusicPattern::IMA25MoawFlags(MUSIC_TIME mtTime, 
                                          MUSIC_TIME mtNextChord,
                                          DMUS_CHORD_PARAM& rCurrentChord, 
                                          DMUS_CHORD_PARAM& rNextChord)
{
    DWORD dwMoawFlags = 0;
    DMSubChord rSubChord = rCurrentChord.SubChordList[0];
    // set one of bits 0-7 based on chord root and scale root of current chord
    DWORD dwPosition = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    if (dwPosition)
        dwMoawFlags |= 1 << (dwPosition - 1); // bit 0 for scale position I, etc.
    else
        dwMoawFlags |= VF_ACCIDENTAL;
    // set bits based on tonality of 1st subchord of current chord
    if ((rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN)
        dwMoawFlags |= VF_MAJOR;
    else if ((rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
        dwMoawFlags |= VF_MINOR;
    else
        dwMoawFlags |= VF_ALL;
    // set bits if the root of the next chord is I or V
    MUSIC_TIME mtPatternLength = 0;
    mtPatternLength = m_timeSig.ClocksPerMeasure() * m_wNumMeasures;
    if (rNextChord.bSubChordCount > 0)
    {
        DMSubChord SC = rNextChord.SubChordList[0];
        int nNextRoot = ScalePosition(SC, rCurrentChord.bKey, rCurrentChord.dwScale);
        int nThisRoot = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
        if (mtPatternLength + mtTime < mtNextChord)
        {
            nNextRoot = nThisRoot;
        }
        switch (nNextRoot)
        {
        case 1: // Next chord is a I
            dwMoawFlags |= VF_TO1;
            break;
        case 5: // Next chord is a 5
            dwMoawFlags |= VF_TO5;
            break;
        }
    }
    // Set bits for simple and complex chords
    if ( IsSimple(rCurrentChord) )
        dwMoawFlags |= VF_SIMPLE;
    else
        dwMoawFlags |= VF_COMPLEX;
    return dwMoawFlags;
}

void CDirectMusicPattern::DMusMoawFlags(MUSIC_TIME mtTime, 
                                        MUSIC_TIME mtNextChord,
                                        DMUS_CHORD_PARAM& rCurrentChord, 
                                        DMUS_CHORD_PARAM& rNextChord,
                                        bool fIsDX8,
                                        DWORD& dwNaturals, 
                                        DWORD& dwSharps, 
                                        DWORD& dwFlats)
{
    dwNaturals = dwSharps = dwFlats = 0;
    DMSubChord rSubChord = rCurrentChord.SubChordList[0];
    // dwScalePosition holds the scale position of the chord.
    DWORD dwScalePosition = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // dwSharpPosition holds the sharped scale position of the chord.
    DWORD dwSharpPosition = ScalePositionSharp(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // dwFlatPosition holds the flatted scale position of the chord.
    DWORD dwFlatPosition = ScalePositionFlat(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
    // set bits for scale tone, sharp, and flat
    if (dwScalePosition)
    {
        dwNaturals |= DMUS_VARIATIONF_ROOT_SCALE;
        // shift bits based on tonality of 1st subchord of current chord
        if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
        {
            dwNaturals |= 1 << (dwScalePosition - 1);
        }
        else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
        {
            dwNaturals |= 1 << (dwScalePosition + 6);
        }
        else
        {
            dwNaturals |= 1 << (dwScalePosition + 13);
        }
        dwSharps = dwFlats = dwNaturals;
        dwSharpPosition = dwFlatPosition = dwScalePosition;
    }
    else
    {
        if (dwSharpPosition)
        {
            dwSharps |= DMUS_VARIATIONF_ROOT_SHARP;
            // shift bits based on tonality of 1st subchord of current chord
            if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
            {
                dwSharps |= 1 << (dwSharpPosition - 1);
            }
            else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
            {
                dwSharps |= 1 << (dwSharpPosition + 6);
            }
            else
            {
                dwSharps |= 1 << (dwSharpPosition + 13);
            }
        }
        if (dwFlatPosition)
        {
            dwFlats |= DMUS_VARIATIONF_ROOT_FLAT;
            // shift bits based on tonality of 1st subchord of current chord
            if ( (rSubChord.m_dwChordPattern & MAJOR_PATTERN) == MAJOR_PATTERN )
            {
                dwFlats |= 1 << (dwFlatPosition - 1);
            }
            else if ( (rSubChord.m_dwChordPattern & MINOR_PATTERN) == MINOR_PATTERN)
            {
                dwFlats |= 1 << (dwFlatPosition + 6);
            }
            else
            {
                dwFlats |= 1 << (dwFlatPosition + 13);
            }
        }
    }
    // set bits if the root of the next chord is I or V (and it's different from the current chord)
    MUSIC_TIME mtPatternLength = 0;
    mtPatternLength = m_timeSig.ClocksPerMeasure() * m_wNumMeasures;
    if (rNextChord.bSubChordCount > 0)
    {
        DMSubChord SC = rNextChord.SubChordList[0];
        int nNextRoot = ScalePosition(SC, rCurrentChord.bKey, rCurrentChord.dwScale);
        int nThisRoot = ScalePosition(rSubChord, rCurrentChord.bKey, rCurrentChord.dwScale);
        if (mtPatternLength + mtTime < mtNextChord)
        {
            nNextRoot = nThisRoot;
        }
        /* This is easy enough to add if it's desired --- but not having it allows a bit more control
        //Don't require anything but the ->Other flag to be set when staying on the same chord
        if (fIsDX8 && nNextRoot == nThisRoot)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_OTHER;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_OTHER;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_OTHER;
        }
        */
        switch (nNextRoot)
        {
        case 1: // Next chord is a I
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_TO1;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_TO1;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_TO1;
            break;
        case 5: // Next chord is a V
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_TO5;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_TO5;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_TO5;
            break;
        default: // Next chord is neither I nor V
            if (fIsDX8)
            {
                if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_DEST_OTHER;
                if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_DEST_OTHER;
                if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_DEST_OTHER;
            }
            break;
        }
    }
    // Set bits for simple and complex chords
    int nCount = 0;
    int nSixSeven = 0;
    if ( IsSimple(rCurrentChord, nCount, nSixSeven) )
    {
        if (nCount <= 3)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_TRIAD;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_TRIAD;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_TRIAD;
        }
        else if (nCount == 4)
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_6AND7;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_6AND7;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_6AND7;
        }
        else
        {
            if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_COMPLEX;
            if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_COMPLEX;
            if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_COMPLEX;
        }
    }
    else
    {
        if (dwScalePosition) dwNaturals |= DMUS_VARIATIONF_TYPE_COMPLEX;
        if (dwSharpPosition) dwSharps |= DMUS_VARIATIONF_TYPE_COMPLEX;
        if (dwFlatPosition) dwFlats |= DMUS_VARIATIONF_TYPE_COMPLEX;
    }
}


HRESULT CDirectMusicPattern::ComputeVariations(DWORD dwFlags,
                                               DMUS_CHORD_PARAM& rCurrentChord, 
                                               DMUS_CHORD_PARAM& rNextChord,
                                               BYTE abVariationGroups[],
                                               DWORD adwVariationMask[],
                                               DWORD adwRemoveVariations[],
                                               BYTE abVariation[],
                                               MUSIC_TIME mtTime,
                                               MUSIC_TIME mtNextChord,
                                               PatternTrackState* pState)
{
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (short i = 0; i < MAX_VARIATION_LOCKS; i++)
    {
        abVariationGroups[i] = 0xFF;
    }
    // Now, compute the variations for each part.
    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    for (i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        hr = ComputeVariation(
                pPartRef->GetItemValue(),
                i,
                dwFlags,
                rCurrentChord,
                rNextChord,
                abVariationGroups,
                adwVariationMask,
                adwRemoveVariations,
                abVariation,
                mtTime,
                mtNextChord,
                pState);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CDirectMusicPattern::ComputeVariationGroup(DirectMusicPartRef& rPartRef,
                                                   int nPartIndex,
                                                  DWORD dwFlags,
                                                  DMUS_CHORD_PARAM& rCurrentChord, 
                                                  DMUS_CHORD_PARAM& rNextChord,
                                                  BYTE abVariationGroups[],
                                                  DWORD adwVariationMask[],
                                                  DWORD adwRemoveVariations[],
                                                  BYTE abVariation[],
                                                  MUSIC_TIME mtTime,
                                                  MUSIC_TIME mtNextChord,
                                                  PatternTrackState* pState)
{
    HRESULT hr = S_OK;
    BYTE bLockID = rPartRef.m_bVariationLockID;
    bool fChangedVariation = (dwFlags & COMPUTE_VARIATIONSF_CHANGED) ? true : false;
    // If this part is locked, get a new variation for all parts locked to it;
    // otherwise, just get a new variation for this part.
    if (bLockID)
    {
        if (!fChangedVariation)
        {
            // First, initialize the variation group for this variation.
            abVariationGroups[bLockID - 1] = 0xFF;
            // Now, compute the variations for each part locked to this one.
            TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                DirectMusicPartRef& rPartRefScan = pPartRef->GetItemValue();
                if ( (bLockID == rPartRefScan.m_bVariationLockID) )
                {
                    hr = ComputeVariation(
                            rPartRefScan,
                            i,
                            dwFlags,
                            rCurrentChord,
                            rNextChord,
                            abVariationGroups,
                            adwVariationMask,
                            adwRemoveVariations,
                            abVariation,
                            mtTime,
                            mtNextChord,
                            pState);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }
    else
    {
        hr = ComputeVariation(
                rPartRef,
                nPartIndex,
                dwFlags,
                rCurrentChord,
                rNextChord,
                abVariationGroups,
                adwVariationMask,
                adwRemoveVariations,
                abVariation,
                mtTime,
                mtNextChord,
                pState);
    }
    return hr;
}

HRESULT CDirectMusicPattern::ComputeVariation(DirectMusicPartRef& rPartRef,
                                              int nPartIndex,
                                              DWORD dwFlags,
                                              DMUS_CHORD_PARAM& rCurrentChord, 
                                              DMUS_CHORD_PARAM& rNextChord,
                                              BYTE abVariationGroups[],
                                              DWORD adwVariationMask[],
                                              DWORD adwRemoveVariations[],
                                              BYTE abVariation[],
                                              MUSIC_TIME mtTime,
                                              MUSIC_TIME mtNextChord,
                                              PatternTrackState* pState)
{
    int i = nPartIndex;
    bool fUseMask = (dwFlags & COMPUTE_VARIATIONSF_USE_MASK) ? true : false;
    bool fNewPattern = (dwFlags & COMPUTE_VARIATIONSF_NEW_PATTERN) ? true : false;
    bool fChordAlign = (dwFlags & COMPUTE_VARIATIONSF_CHORD_ALIGN) ? true : false;
    bool fMarker = (dwFlags & COMPUTE_VARIATIONSF_MARKER) ? true : false;
    bool fStart = (dwFlags & COMPUTE_VARIATIONSF_START) ? true : false;
    bool fIsDX8 = (dwFlags & COMPUTE_VARIATIONSF_DX8) ? true : false;
    bool fChord = false;
    if (pState && (mtTime == pState->m_mtCurrentChordTime || mtTime == pState->m_mtNextChordTime))
    {
        fChord = true;
    }
    DWORD dwMarkerFlags = DMUS_MARKERF_START;
    DWORD dwDMusNaturals, dwDMusSharps, dwDMusFlats;
    DMusMoawFlags(mtTime, mtNextChord, rCurrentChord, rNextChord, fIsDX8, dwDMusNaturals, dwDMusSharps, dwDMusFlats);
    DWORD dwIMA25MoawFlags = IMA25MoawFlags(mtTime, mtNextChord, rCurrentChord, rNextChord);
//    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    DWORD dwNaturalFlags, dwSharpFlags, dwFlatFlags;
    /*// First, initialize the array of variation groups
    for (short i = 0; i < MAX_VARIATION_LOCKS; i++)
    {
        abVariationGroups[i] = 0xFF;
    }*/
    //for (i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
    //  if (pguidPart && 
    //      pPartRef->GetItemValue().m_pDMPart &&
    //      *pguidPart != pPartRef->GetItemValue().m_pDMPart->m_guidPartID)
    //  {
    //      continue; // the way this was, it wiped out variation locking
    //  }
        DWORD dwVariationChoices = 0xffffffff;
        if (fUseMask)
        {
            dwVariationChoices = adwVariationMask[i];
        }
    //  DirectMusicPartRef& rPartRef = pPartRef->GetItemValue();
        BYTE bLockID = rPartRef.m_bVariationLockID;
        DirectMusicPart* pPart = rPartRef.m_pDMPart;
        MUSIC_TIME mtPartOffset = (pState) ? pState->PartOffset(i) : 0;
        MUSIC_TIME mtNowRelative = (mtTime >= mtPartOffset) ? mtTime - mtPartOffset : 0;
        MUSIC_TIME mtClosestTime = 0;
        // Find a variation whose moaw field matches dwMoawFlags.
        // Variation locking: If a part ref has a variation lock id that has already been
        // recorded, use the recorded variation.  Otherwise, find a variation and, if the
        // part ref has a variation lock id, record the variation.
        if (bLockID && abVariationGroups[bLockID - 1] != 0xFF)
        {
            abVariation[i] = abVariationGroups[bLockID - 1];
            adwVariationMask[i] = abVariationGroups[bLockID - 1];
        }
        else
        {
            // First, collect all matches.
            // Also, find the time of the matching variation closest to but not preceding mtTime.
            BYTE bMode = 0; 
            DWORD dwMatches = 0;
            DWORD dwCompleteMatches = 0;
            short nMatchCount = 0;
            DWORD dwEnabled = 0;
            short nEnabledCount = 0;
            bool fGotClosest = false;
            for (short nV = 0; nV < 32; nV++)
            {
                DWORD dwVariation = 1 << nV;
                if (dwVariation & dwVariationChoices)
                {
                    if ( (pPart->m_dwVariationChoices[nV] & 0x5FFFFFFF) != 0) // enabled
                    {
                        nEnabledCount++;
                        dwEnabled |= dwVariation;
                    }
                    if (pPart->m_dwVariationChoices[nV] & DMUS_VARIATIONF_DMUS_MODE)
                    {
                        dwNaturalFlags = dwDMusNaturals;
                        dwSharpFlags = dwDMusSharps;
                        dwFlatFlags = dwDMusFlats;
                    }
                    else
                    {
                        dwNaturalFlags = dwSharpFlags = dwFlatFlags = dwIMA25MoawFlags;
                    }
                    if ( (dwNaturalFlags && (pPart->m_dwVariationChoices[nV] & dwNaturalFlags) == dwNaturalFlags) ||
                         (dwSharpFlags && (pPart->m_dwVariationChoices[nV] & dwSharpFlags) == dwSharpFlags) ||
                         (dwFlatFlags && (pPart->m_dwVariationChoices[nV] & dwFlatFlags) == dwFlatFlags) )
                    {
                        nMatchCount++;
                        dwMatches |= dwVariation;
                        if ((fStart || fMarker) && pPart && (pPart->m_dwFlags & DMUS_PARTF_USE_MARKERS))
                        {
                            MUSIC_TIME mtTemp = 0;
                            if (SUCCEEDED(pPart->GetClosestTime(nV, mtNowRelative, dwMarkerFlags, fChord, mtTemp)))
                            {
                                if (!fGotClosest || mtTemp < mtClosestTime)
                                {
                                    mtClosestTime = mtTemp;
                                    fGotClosest = true;
                                }
                            }
                        }
                    }
                }
            }
            dwCompleteMatches = dwMatches;
            DWORD dwTemp = dwMatches;
            bMode = rPartRef.m_bRandomVariation;
            if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
            {
                dwTemp &= ~adwRemoveVariations[i];
                if (!dwTemp)
                {
                    // start counting all over, but don't repeat this one
                    adwRemoveVariations[i] = 0;
                    dwTemp = dwMatches;
                    bMode = DMUS_VARIATIONT_NO_REPEAT;
                }
            }
            if ( bMode == DMUS_VARIATIONT_NO_REPEAT && abVariation[i] != 0xff )
            {
                dwTemp &= ~(1 << abVariation[i]);
            }
            if (dwTemp != dwMatches)
            {
                if (dwTemp) // otherwise, keep what we had
                {
                    for (int i = 0; i < 32; i++)
                    {
                        if ( ((1 << i) & dwMatches) && !((1 << i) & dwTemp) )
                        {
                            nMatchCount--;
                        }
                    }
                    dwMatches = dwTemp;
                }
            }
            if (nMatchCount == 0)
            {
                if (nEnabledCount)
                {
                    // if there are any enabled variations, choose from among them
                    nMatchCount = nEnabledCount;
                    dwMatches = dwEnabled;
                }
                else
                {
                    // otherwise, choose any variation from among the first 16
                    // (for compatability with SuperJam)
                    nMatchCount = 16;
                    dwMatches = 0xffffffff;
                }
            }
            adwVariationMask[i] = dwMatches;
            // If we're starting at or past a marker, or we're at a marker,
            // and the part is using markers, filter out all 
            // variations except those with start markers closest to but not preceding mtNow.
            if ( ((fStart && mtTime >= mtClosestTime) || fMarker) && 
                 pPart && (pPart->m_dwFlags & DMUS_PARTF_USE_MARKERS) )
            {
                DWORD dwMatchTemp = dwMatches;
                short nCountTemp = nMatchCount;
                for (nV = 0; nV < 32; nV++)
                {
                    if (dwMatches & (1 << nV))
                    {
                        if ( !pPart->IsMarkerAtTime(nV, mtClosestTime, dwMarkerFlags, fChord) )
                        {
                            dwMatches &= ~(1 << nV);
                            nMatchCount--;
                        }
                    }
                }
                // Fall back to the original matches
                if (!dwMatches)
                {
                    dwMatches = dwMatchTemp;
                    nMatchCount = nCountTemp;
                }
            }

            // Next, select a match.
            // Only select a match if either we're just starting a new pattern,
            // we're at a chord-aligned marker,
            // or the current variation isn't a match.
            // If this part aligns variations to chords, only get a new variation
            // if we're just starting a new pattern,
            // or we're at a chord-aligned marker AND the current variation isn't a match.
            TraceI(3, "Matches: %x\n", dwMatches);
            bool fAlignPartToChord = (pPart->m_dwFlags & DMUS_PARTF_ALIGN_CHORDS) ? true : false;
            bool fMatch = ((1 << abVariation[i]) & dwCompleteMatches) ? true : false;
            bool fFirstRandomInOrder = false;
            if ( fNewPattern || 
                 (!fAlignPartToChord && (fChordAlign || !fMatch)) ||
                 (fAlignPartToChord && fChordAlign && !fMatch) )
            {
                //TraceI(0, "Time: %d, New Pattern: %d Chord Align: %d Variation: %d Matches: %x\n", 
                //  mtTime, fNewPattern, fChordAlign, abVariation[i], dwCompleteMatches);
                switch (rPartRef.m_bRandomVariation)
                {
                case DMUS_VARIATIONT_RANDOM_ROW:
                case DMUS_VARIATIONT_NO_REPEAT:
                case DMUS_VARIATIONT_RANDOM:
                    {
                        short nChoice = 0;
                        if (pState)
                        {
                            nChoice = (short)pState->RandomVariation(mtTime, nMatchCount);
                        }
                        else
                        {
                            nChoice = (short) (dm_rand() % nMatchCount);
                        }
                        short nCount = 0;
                        for (nV = 0; nV < 32; nV++)
                        {
                            if ((1 << nV) & dwMatches)
                            {
                                if (nChoice == nCount)
                                    break;
                                nCount++;
                            }
                        }
                        abVariation[i] = (BYTE) nV;
                        if (rPartRef.m_bRandomVariation == DMUS_VARIATIONT_RANDOM_ROW)
                        {
                            adwRemoveVariations[i] |= (1 << abVariation[i]);
                        }
                        TraceI(3, "New variation: %d at time %d\n", nV, mtTime);
                        break;
                    }
                case DMUS_VARIATIONT_RANDOM_START:
                    // Choose an initial value
                    if (abVariation[i] == 0xff)
                    {
                        fFirstRandomInOrder = true;
                        int nStart = 0;
                        if (pState)
                        {
                            nStart = (BYTE)pState->RandomVariation(mtTime, nMatchCount);
                        }
                        else
                        {
                            nStart = (BYTE) (dm_rand() % nMatchCount);
                        }
                        int nCount = 0;
                        for (nV = 0; nV < 32; nV++)
                        {
                            if ((1 << nV) & dwMatches)
                            {
                                if (nStart == nCount)
                                    break;
                                nCount++;
                            }
                        }
                        abVariation[i] = (BYTE) nV;
                    }
                    // Now, go directly to the sequential case (no break)
                case DMUS_VARIATIONT_SEQUENTIAL:
                    {
                        if (!fFirstRandomInOrder)
                        {
                            do
                            {
                                abVariation[i]++;
                            }
                            while (!((1 << ((nV + abVariation[i]) % 32)) & dwMatches));
                            abVariation[i]  %= 32;
                        }
                        TraceI(3, "New variation: %d at time %d\n", abVariation[i], mtTime);
                        break;
                    }
                }
                // If this is a locked variation, it's the first in its group, so record it.
                if (bLockID)
                {
                    abVariationGroups[bLockID - 1] = abVariation[i];
                }
            }
        }
    }
    return S_OK;
}

// Returns:
// Total number of bits in the pattern if all bits in the rhythm match the pattern.
// 0 otherwise.
void CDirectMusicPattern::MatchRhythm(DWORD pRhythms[], short nPatternLength,
                 short& nBits)
{
    nBits = 0;
    for (int i = 0; i < nPatternLength; i++)
    {
        if (i >= m_wNumMeasures) 
        {
            return;
        }
        if ((pRhythms[i] & m_pRhythmMap[i]) == pRhythms[i])
        {
            for (int n = 0; n < 32; n++)
            {
                nBits += (short) (m_pRhythmMap[i] >> n) & 1;
            }
        }
        else
        {
            nBits = 0;
            return;
        }
    }
}

BOOL CDirectMusicPattern::MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength)
{   
    short nPatternLength = (m_wNumMeasures < nLength) ? m_wNumMeasures : nLength;
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    for (int i = 0; i < nPatternLength; i++)
    {
        if ( (i > 0) && 
             (pCommands[i].bCommand == DMUS_COMMANDT_GROOVE) && 
             (pCommands[i].bGrooveLevel == pCommands[0].bGrooveLevel) )
        {
            continue;
        }
        if (!MatchEmbellishment(pCommands[i])) return FALSE;
        if (!MatchGrooveLevel(pCommands[i])) return FALSE;
    }
    return TRUE;
}

BOOL CDirectMusicPattern::MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand)
{   
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    // Lower the upper range and raise the lower range by half of the total range each
    BYTE bMiddle = rCommand.bGrooveRange / 2;
    BYTE bUpper = (rCommand.bGrooveLevel < bMiddle) ? 1 : rCommand.bGrooveLevel - bMiddle;
    BYTE bLower = (rCommand.bGrooveLevel + bMiddle > 100) ? 100 : rCommand.bGrooveLevel + bMiddle;
    TraceI(3, "Range: %d Upper: %d Lower: %d\n", bMiddle, bUpper, bLower);
    return (bLower >= m_bGrooveBottom && bUpper <= m_bGrooveTop);
}

BOOL CDirectMusicPattern::MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand)
{   
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    if ((m_wEmbellishment & EMB_USER_DEFINED)) // handle user-defined embellishments
    {
        if ((BYTE)(m_wEmbellishment >> 8) != rCommand.bCommand) return FALSE;
    }
    else
    {
        switch (rCommand.bCommand)
        {
        case DMUS_COMMANDT_GROOVE:
            if ((m_wEmbellishment & EMB_NORMAL) != m_wEmbellishment) return FALSE;
            break;
        case DMUS_COMMANDT_FILL:
            if (!(m_wEmbellishment & EMB_FILL)) return FALSE;
            break;
        case DMUS_COMMANDT_INTRO:
            if (!(m_wEmbellishment & EMB_INTRO)) return FALSE;
            break;
        case DMUS_COMMANDT_BREAK:
            if (!(m_wEmbellishment & EMB_BREAK)) return FALSE;
            break;
        case DMUS_COMMANDT_END:
            if (!(m_wEmbellishment & EMB_END)) return FALSE;
            break;
        default: return FALSE;
        }
    }
    return TRUE;
}

BOOL CDirectMusicPattern::MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand)
{   
    TraceI(3, "Next Command: %x (%d) Embellishment: %x [%d %d] <%d %d>\n", rNextCommand.bCommand, rNextCommand.bGrooveLevel,
        m_wEmbellishment, m_bGrooveBottom, m_bGrooveTop, m_bDestGrooveBottom, m_bDestGrooveTop);
    if ((m_wEmbellishment & EMB_MOTIF) == EMB_MOTIF) return FALSE; // discard all motifs
    if (!m_bDestGrooveBottom || !m_bDestGrooveTop) // handle legacy
    {
        return TRUE; 
    }
    // Lower the upper range and raise the lower range by half of the total range each
    BYTE bMiddle = rNextCommand.bGrooveRange / 2;
    BYTE bUpper = (rNextCommand.bGrooveLevel < bMiddle) ? 1 : rNextCommand.bGrooveLevel - bMiddle;
    BYTE bLower = (rNextCommand.bGrooveLevel + bMiddle > 100) ? 100 : rNextCommand.bGrooveLevel + bMiddle;
    TraceI(3, "Range: %d Upper: %d Lower: %d\n", bMiddle, bUpper, bLower);
    return (bLower >= m_bDestGrooveBottom && bUpper <= m_bDestGrooveTop);
}

HRESULT CDirectMusicPattern::MergeMarkerEvents( DMStyleStruct* pStyle )
{
    TListItem<DirectMusicPartRef>* pPartRef = m_PartRefList.GetHead();
    for (; pPartRef; pPartRef = pPartRef->GetNext())
    {
        pPartRef->GetItemValue().m_pDMPart->MergeMarkerEvents(pStyle, this);
    }
    return S_OK;
}

bool Greater(MUSIC_TIME& mt1, MUSIC_TIME& mt2)
{
    return mt1 > mt2;
}

bool Greater(Marker& m1, Marker& m2)
{
    return m1.mtTime > m2.mtTime;
}

template <class T>
HRESULT InsertInOrder(TList<T>& List, T tValue)
{
    TListItem<T>* pNew = new TListItem<T>(tValue);
    if (!pNew) return E_OUTOFMEMORY;
    TListItem<T>* pScan = List.GetHead();
    TListItem<T>* pPrevious = NULL;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (Greater(pScan->GetItemValue(), tValue))
        {
            break;
        }
        pPrevious = pScan;
    }
    if (!pPrevious)
    {
        List.AddHead(pNew);
    }
    else
    {
        pPrevious->SetNext(pNew);
        pNew->SetNext(pScan);
    }
    return S_OK;
}

HRESULT DirectMusicPart::MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern )
{
    DirectMusicTimeSig& TimeSig = TimeSignature(pStyle, pPattern);
    CDirectMusicEventItem* pEvent;
    for (pEvent = EventList.GetHead(); pEvent; pEvent = pEvent->GetNext())
    {
        if (pEvent->m_dwEventTag == DMUS_EVENT_MARKER)
        {
            CDMStyleMarker* pMarker = (CDMStyleMarker*)pEvent;
            if (pMarker->m_wFlags & DMUS_MARKERF_START)
            {
                MUSIC_TIME mtTime = 
                    (MUSIC_TIME)(TimeSig.GridToClocks(pMarker->m_nGridStart) + pMarker->m_nTimeOffset);
                // Put this in all the appropriate variation lists
                for (int i = 0; i < 32; i++)
                {
                    if (pMarker->m_dwVariation & (1 << i))
                    {
                        Marker M;
                        M.mtTime = mtTime;
                        M.wFlags = pMarker->m_wFlags;
                        InsertInOrder(m_StartTimes[i], M);
                    }
                }
                InsertInOrder(pPattern->m_StartTimeList, mtTime);
            }
        }
    }
    return S_OK;
}

HRESULT DirectMusicPart::GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult)
{
    HRESULT hr = E_FAIL;
    rmtResult = 0;
    if (nVariation < 32 && nVariation >= 0)
    {
        TListItem<Marker>* pMarker = m_StartTimes[nVariation].GetHead();
        for (; pMarker; pMarker = pMarker->GetNext())
        {
            if ( pMarker->GetItemValue().mtTime >= mtTime && 
                 (pMarker->GetItemValue().wFlags & dwFlags) == dwFlags &&
                 (fChord || !(pMarker->GetItemValue().wFlags & DMUS_MARKERF_CHORD_ALIGN)) )
            {
                rmtResult = pMarker->GetItemValue().mtTime;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

bool DirectMusicPart::IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord)
{
    bool fResult = false;
    if (nVariation < 32 && nVariation >= 0)
    {
        TListItem<Marker>* pMarker = m_StartTimes[nVariation].GetHead();
        for (; pMarker; pMarker = pMarker->GetNext())
        {
            if ( pMarker->GetItemValue().mtTime == mtTime && 
                 (pMarker->GetItemValue().wFlags & dwFlags) == dwFlags &&
                 (fChord || !(pMarker->GetItemValue().wFlags & DMUS_MARKERF_CHORD_ALIGN)) )
            {
                fResult = true;
                break;
            }
        }
    }

    return fResult;
}

DirectMusicTimeSig& CDirectMusicPattern::TimeSignature( DMStyleStruct* pStyle ) 
{
    if (m_timeSig.m_bBeat != 0)
    {
        return m_timeSig; 
    }
    else if (pStyle)
    {
        return pStyle->TimeSignature();
    }
    else
    {
        return ::DefaultTimeSig; 
    }
}

DirectMusicTimeSig& DirectMusicPart::TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern )
{
    if (m_timeSig.m_bBeat != 0)
    {
        return m_timeSig; 
    }
    else if (pPattern)
    {
        return pPattern->TimeSignature(pStyle);
    }
    else
    {
        return ::DefaultTimeSig; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\dmstylep.h ===
//
// DMStyleP.H
//
// Private include for DMStyle.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//

#ifndef _DMSTYLEP_
#define _DMSTYLEP_

#include "dmusicf.h"

#define SUBCHORD_BASS				0
#define SUBCHORD_STANDARD_CHORD		1

extern long g_cComponent;

// Class factory
//
class CDirectMusicStyleFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSectionFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSectionFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicStyleTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicStyleTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicStyleTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCommandTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicCommandTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicCommandTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicChordTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicChordTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicChordTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMotifTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMotifTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMotifTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMuteTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMuteTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicMuteTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicAuditionTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicAuditionTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicAuditionTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicMelodyFormulationTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicMelodyFormulationTrackFactory() : m_cRef(1) {}

private:
    long m_cRef;
};

// private interfaces
interface IDMSection : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown** ppStyle)=0;
};

interface IStyleTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle)=0;

	virtual HRESULT STDMETHODCALLTYPE GetStyle(IUnknown **ppStyle)=0;
};

interface IDMStyle : IUnknown
{
//	virtual HRESULT STDMETHODCALLTYPE GetPatternName (DWORD dwIndex, WCHAR *wszName)=0;
#ifdef DXAPI
    virtual HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid)=0;
	virtual HRESULT STDMETHODCALLTYPE GetPatternStream(
		WCHAR* wszName, DWORD dwPatternType, IStream** ppStream)=0;
#endif
	virtual HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData)=0;
	virtual HRESULT STDMETHODCALLTYPE IsDX8()=0;
	virtual HRESULT STDMETHODCALLTYPE CritSec(bool fEnter)=0;
	virtual HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime)=0;
	virtual HRESULT STDMETHODCALLTYPE GenerateTrack(
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack)=0;
	// this will go into dmusici.h when melody formulation is made public
/*	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle,
		IDirectMusicSegment* pTemplate,
		IDirectMusicSegment** ppSegment) = 0;*/
    /* Interface needs to look like this in dmusici.h
	STDMETHOD(ComposeMelodyFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   IDirectMusicSegment** ppSegment) PURE;
	*/
};

interface IMotifTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetTrack(IUnknown *pStyle, void* pPattern)=0;
};

interface IPrivatePatternTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState,
		IStream* pStream,
		DWORD* pdwLength)=0;
    virtual HRESULT STDMETHODCALLTYPE SetVariationByGUID(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		REFGUID rguidPart,
		DWORD dwPChannel)=0;
};

///////////////////////////////////////////////////////////////////////////////////////

DEFINE_GUID( IID_IAuditionTrack, 
			 0x9dc278c0, 0x9cb0, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c );

interface IAuditionTrack : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(
		IDirectMusicStyle* pStyle, IDirectMusicSegment** ppSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE SetPattern(
		IDirectMusicSegmentState* pSegState, IStream* pStream, DWORD* pdwLength)=0;
	virtual HRESULT STDMETHODCALLTYPE SetVariation(
		IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, WORD wPart)=0;
};

#define CLSID_DirectMusicAuditionTrack CLSID_DirectMusicPatternTrack

#define DMUS_PCHANNEL_MUTE 0xffffffff

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL		10000		// For converting from reference time to mils 
#define MARGIN_MIN		(100 * REF_PER_MIL) // 
#define MARGIN_MAX		(400 * REF_PER_MIL) // 
#define PREPARE_TIME	(m_dwPrepareTime * REF_PER_MIL)	// Time
#define NEARTIME		(100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)


// private CLSIDs and IIDs

DEFINE_GUID(IID_IDMSection,
	0x3F037240,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IStyleTrack,
	0x3F037246,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IDMStyle,
	0x4D7F3661,0x43D6,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMotifTrack,
	0x7AE499C1,0x51FE,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);
DEFINE_GUID(IID_IMuteTrack, 
	0xbc242fc1, 0xad1d, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
DEFINE_GUID(IID_IPrivatePatternTrack, 
	0x7a8e9c33, 0x5901, 0x4f20, 0x92, 0xde, 0x3a, 0x5b, 0x3e, 0x33, 0xe2, 0x14);

DEFINE_GUID(CLSID_DMSection,
	0x3F037241,0x414E,0x11D1, 0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C);

// GUID and param struct for private version of GetParam (get style Time Signature,
// getting commands and chords from current segment)

struct SegmentTimeSig
{
    IDirectMusicSegment* pSegment;  // Segment passed in
    DMUS_TIMESIGNATURE  TimeSig;    // Time sig returned
};

DEFINE_GUID(GUID_SegmentTimeSig, 0x76612507, 0x4f37, 0x4b35, 0x80, 0x92, 0x50, 0x48, 0x4e, 0xd4, 0xba, 0x92);

// Private melody fragment stuff

// Used to get a repeated melody fragment
DEFINE_GUID(GUID_MelodyFragmentRepeat, 0x8cc92764, 0xf81c, 0x11d2, 0x81, 0x45, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

// This is obslolete and should not be public
#define DMUS_FOURCC_MELODYGEN_TRACK_CHUNK     mmioFOURCC( 'm', 'g', 'e', 'n' )

/*
// This is obslolete and should not be public
    // <mgen-ck>
    'mgen'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )
*/

// GUID for private chord notifications
DEFINE_GUID(GUID_NOTIFICATION_PRIVATE_CHORD, 0xf5c19571, 0x7e1e, 0x4fff, 0xb9, 0x49, 0x7f, 0x74, 0xa6, 0x6f, 0xdf, 0xc0);

// (Private) Guid for getting a style from a pattern track
DEFINE_GUID(GUID_IDirectMusicPatternStyle, 0x689821f4, 0xb3bc, 0x44dd, 0x80, 0xd4, 0xc, 0xf3, 0x2f, 0xe4, 0xd2, 0x1b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\oledll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.h
//
//--------------------------------------------------------------------------

//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\mutetrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       mutetrk.h
//
//--------------------------------------------------------------------------

// MuteTrk.h : Declaration of the CMuteTrack

#ifndef __MUTETRACK_H_
#define __MUTETRACK_H_

#include "tlist.h"
#include "dmsect.h"
#include "dmusicip.h"

// A mute track will have a list of lists of time-stamped MuteData mappings

struct MapSequence
{
	DWORD				m_dwPChannel;
	TList<MuteMapping>	m_Mappings;
};

/////////////////////////////////////////////////////////////////////////////
// CMuteTrack
class CMuteTrack : 
	public IDirectMusicTrack8,
	public IPersistStream
{
public:
	CMuteTrack();
	CMuteTrack(const CMuteTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMuteTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

public:
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// CMuteTrack members
protected:
	void Clear();
    long m_cRef;
	TList<MapSequence>			m_MapSequenceList; // one MapSequence per PChannel
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;

	BYTE						m_bRequiresSave;
};

#endif //__MUTETRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\iostru.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       iostru.h
//
//--------------------------------------------------------------------------

// ioStructs.h
//

#ifndef __IOSTRUCTS_H__
#define __IOSTRUCTS_H__

#pragma pack(2)

#define FOURCC_BAND_FORM        mmioFOURCC('A','A','B','N')
#define FOURCC_CLICK_LIST       mmioFOURCC('A','A','C','L')
#define FOURCC_KEYBOARD_FORM    mmioFOURCC('S','J','K','B')
#define FOURCC_PATTERN_FORM     mmioFOURCC('A','A','P','T')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')
#define FOURCC_SONG_FORM        mmioFOURCC('A','A','S','O')
#define FOURCC_STYLE_FORM       mmioFOURCC('A','A','S','Y')

#define FOURCC_AUTHOR           mmioFOURCC('a','u','t','h')
#define FOURCC_BAND             mmioFOURCC('b','a','n','d')
#define FOURCC_CHORD            mmioFOURCC('c','h','r','d')
#define FOURCC_CLICK            mmioFOURCC('c','l','i','k')
#define FOURCC_COMMAND          mmioFOURCC('c','m','n','d')
#define FOURCC_COPYRIGHT        mmioFOURCC('c','p','y','r')
#define FOURCC_CURVE            mmioFOURCC('c','u','r','v')
#define FOURCC_KEYBOARD         mmioFOURCC('k','y','b','d')
#define FOURCC_LYRIC            mmioFOURCC('l','y','r','c')
#define FOURCC_MUTE             mmioFOURCC('m','u','t','e')
#define FOURCC_NOTE             mmioFOURCC('n','o','t','e')
#define FOURCC_PATTERN          mmioFOURCC('p','a','t','t')
#define FOURCC_PERSONALITYNAME  mmioFOURCC('p','r','n','m')
#define FOURCC_PERSONALITYREF   mmioFOURCC('p','r','e','f')
#define FOURCC_PHRASE           mmioFOURCC('p','h','r','s')
#define FOURCC_PPQN             mmioFOURCC('p','p','q','n')
#define FOURCC_SECTION          mmioFOURCC('s','e','c','n')
#define FOURCC_SECTIONUI        mmioFOURCC('s','c','u','i')
#define FOURCC_STYLE            mmioFOURCC('s','t','y','l')
#define FOURCC_STYLEINFO        mmioFOURCC('i','n','f','o')
#define FOURCC_STYLEREF         mmioFOURCC('s','r','e','f')
#define FOURCC_TITLE            mmioFOURCC('t','i','t','l')

typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;

typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;

typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;

typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;

typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;

typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;

typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;

typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};

typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;

#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;

typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;

typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;

typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif// __IOSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\mutetrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       mutetrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MuteTrk.cpp : Implementation of CMuteTrack

#ifdef XBOX
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif

#include <objbase.h>
#include "MuteTrk.h"
#include "debug.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "..\shared\critsec.h"

/////////////////////////////////////////////////////////////////////////////
// CMuteTrack

CMuteTrack::CMuteTrack() : m_bRequiresSave(0),
	m_cRef(1), m_fCSInitialized(FALSE)

{
	IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CMuteTrack::CMuteTrack(const CMuteTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
	m_bRequiresSave(0), 
	m_cRef(1), m_fCSInitialized(FALSE)

{
	IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	TListItem<MapSequence>* pSeqScan = rTrack.m_MapSequenceList.GetHead();
	for(; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		MapSequence& rSeqScan = pSeqScan->GetItemValue();
		TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
		if (!pNewSeq) break;
		MapSequence& rNewSeq = pNewSeq->GetItemValue();
		rNewSeq.m_dwPChannel = rSeqScan.m_dwPChannel;
		TListItem<MuteMapping>* pScan = rSeqScan.m_Mappings.GetHead();
		TListItem<MuteMapping>* pPrevious = NULL;
		for(; pScan; pScan = pScan->GetNext())
		{
			MuteMapping& rScan = pScan->GetItemValue();
			if (rScan.m_mtTime < mtStart)
			{
				pPrevious = pScan;
			}
			else if (rScan.m_mtTime < mtEnd)
			{
				if (rScan.m_mtTime == mtStart)
				{
					pPrevious = NULL;
				}
				TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
				if (pNew)
				{
					MuteMapping& rNew = pNew->GetItemValue();
					rNew.m_mtTime = rScan.m_mtTime - mtStart;
					rNew.m_dwPChannelMap = rScan.m_dwPChannelMap;
					rNew.m_fMute = rScan.m_fMute;
					rNewSeq.m_Mappings.AddTail(pNew);
				}
			}
			else break;
		}
		if (pPrevious)
		{
			TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
			if (pNew)
			{
				MuteMapping& rNew = pNew->GetItemValue();
				rNew.m_mtTime = 0;
				rNew.m_dwPChannelMap = pPrevious->GetItemValue().m_dwPChannelMap;
				rNew.m_fMute = pPrevious->GetItemValue().m_fMute;
				rNewSeq.m_Mappings.AddHead(pNew);
			}
		}
		if (rNewSeq.m_Mappings.GetHead())
		{
			m_MapSequenceList.AddTail(pNewSeq);
		}
		else
		{
			delete pNewSeq;
		}
	}
}

CMuteTrack::~CMuteTrack()
{
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
	DecrementDLLCount();
}

void CMuteTrack::Clear()
{
	m_MapSequenceList.CleanUp();
}

STDMETHODIMP CMuteTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CMuteTrack::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMuteTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMuteTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


// CMuteTrack Methods
HRESULT CMuteTrack::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	V_INAME(CMuteTrack::Init);
	V_INTERFACE(pSegment);

	return S_OK;
}

HRESULT CMuteTrack::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return S_OK;
}

HRESULT CMuteTrack::EndPlay(
				/*[in]*/  void*						pStateData
			)
{
	return S_OK;
}

HRESULT CMuteTrack::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			)
{
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	// For now: do nothing.
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return DMUS_S_END;
}

HRESULT CMuteTrack::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CMuteTrack::GetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMuteTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	if (rCommandGuid != GUID_MuteParam) return DMUS_E_TYPE_UNSUPPORTED;

	HRESULT hr = S_OK;
	DMUS_MUTE_PARAM* pDMUS_MUTE_PARAM = (DMUS_MUTE_PARAM*) pData;

	MUSIC_TIME mtLength = 0;
//	HRESULT hrMute = E_FAIL;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
//	if (m_pSegment) hrMute = m_pSegment->GetLength(&mtLength);
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();
	// Find a matching map sequence
	for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		if (pSeqScan->GetItemValue().m_dwPChannel == pDMUS_MUTE_PARAM->dwPChannel) break;
	}
	if (pSeqScan)
	{
		// Find the maps directly before (or at) and directly after mtTime
		TListItem<MuteMapping>* pScan = pSeqScan->GetItemValue().m_Mappings.GetHead();
		TListItem<MuteMapping>* pPrevious = NULL;
		for( ; pScan; pScan = pScan->GetNext())
		{
			MUSIC_TIME mt = pScan->GetItemValue().m_mtTime;
			if (mt <= mtTime)
			{
				pPrevious = pScan;
			}
			/*
			// If we're at the end of the segment...
			else if (SUCCEEDED(hrMute) && mtTime == mtLength - 1 && mt == mtLength)
			{
				pPrevious = pScan;
				pScan = NULL;
				break;
			}
			*/
			else
			{
				break;
			}
		}
		if (pPrevious)
		{
			pDMUS_MUTE_PARAM->dwPChannelMap = pPrevious->GetItemValue().m_dwPChannelMap;
			pDMUS_MUTE_PARAM->fMute = pPrevious->GetItemValue().m_fMute;
			//*pmtNext = (pScan) ? (pScan->GetItemValue().m_mtTime - mtTime) : 0; // RSW: bug 167740
		}
		else 
		// Nothing in the list is <= mtTime, so return a map that maps to itself, and the time
		// of the first mapping in the list
		{
			pDMUS_MUTE_PARAM->dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannel;
			pDMUS_MUTE_PARAM->fMute = FALSE;
			//*pmtNext = (pScan) ? (pScan->GetItemValue().m_mtTime - mtTime) : 0; // RSW: bug 167740
		}
		if (pmtNext)
		{
			if (pScan)
			{
				/*
				// If we have a mute at the end of the segment...
				if (SUCCEEDED(hrMute) && pScan->GetItemValue().m_mtTime >= mtLength)
				{
					*pmtNext = (mtLength - 1) - mtTime;
				}
				else
				*/
				{
					*pmtNext = pScan->GetItemValue().m_mtTime - mtTime; // RSW: bug 167740
				}
			}
			else
			{
				/*
				if (SUCCEEDED(hrMute))
				{
					mtLength -= mtTime;
					if (mtLength < 0) mtLength = 0;
				}
				*/
				*pmtNext = mtLength;
			}
		}
	}
	else
	{
		// assume something that maps to itself, with a next time of 0
		pDMUS_MUTE_PARAM->dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannel;
		pDMUS_MUTE_PARAM->fMute = FALSE;
		if (pmtNext)
		{
			*pmtNext = 0;
		}
		hr = S_OK;
	}
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
} 

HRESULT CMuteTrack::SetParam( 
	REFGUID	rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	V_INAME(CMuteTrack::SetParam);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	if (rCommandGuid != GUID_MuteParam) return DMUS_E_TYPE_UNSUPPORTED;

	HRESULT hr = S_OK;
	DMUS_MUTE_PARAM* pDMUS_MUTE_PARAM = (DMUS_MUTE_PARAM*) pData;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();
	for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
	{
		if (pSeqScan->GetItemValue().m_dwPChannel == pDMUS_MUTE_PARAM->dwPChannel) break;
	}
	// make a new mapping
	TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
	if (pNew)
	{
		MuteMapping& rNew = pNew->GetItemValue();
		rNew.m_mtTime = mtTime;
		rNew.m_dwPChannelMap = pDMUS_MUTE_PARAM->dwPChannelMap;
		rNew.m_fMute = pDMUS_MUTE_PARAM->fMute;
		if (pSeqScan)
		{
			// add the mapping to the current list
			pSeqScan->GetItemValue().m_Mappings.AddTail(pNew);
		}
		else
		{
			// make a list containing the mapping, and add it to the sequence list
			TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
			if (pNewSeq)
			{
				MapSequence& rNewSeq = pNewSeq->GetItemValue();
				rNewSeq.m_dwPChannel = pDMUS_MUTE_PARAM->dwPChannel;
				rNewSeq.m_Mappings.AddTail(pNew);
				m_MapSequenceList.AddTail(pNewSeq);
			}
			else
			{
				delete pNew;
				pNew = NULL;
			}
		}
	}
    if (!pNew)
	{
		hr = E_OUTOFMEMORY;
	}
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

// IPersist methods
 HRESULT CMuteTrack::GetClassID( LPCLSID pClassID )
{
	V_INAME(CMuteTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMuteTrack;
	return S_OK;
}

HRESULT CMuteTrack::IsParamSupported(
				/*[in]*/ REFGUID	rGuid
			)
{
	V_INAME(CMuteTrack::IsParamSupported);
	V_REFGUID(rGuid);

    return rGuid == GUID_MuteParam ? S_OK : DMUS_E_TYPE_UNSUPPORTED;
}

// IPersistStream methods
 HRESULT CMuteTrack::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMuteTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
	V_INAME(CMuteTrack::Save);
	V_INTERFACE(pStream);

	IAARIFFStream* pRIFF ;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_MUTE	oMute;
	TListItem<MapSequence>* pSeqScan = m_MapSequenceList.GetHead();

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF  );
	if (!SUCCEEDED(hr))
	{
		goto ON_END;
	}
    hr = E_FAIL;
    ck.ckid = DMUS_FOURCC_MUTE_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_MUTE );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
			if (SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_END;
        }
        for( ; pSeqScan; pSeqScan = pSeqScan->GetNext() )
        {
			MapSequence& rSeqScan = pSeqScan->GetItemValue();
			DWORD dwPChannel = rSeqScan.m_dwPChannel;
			TListItem<MuteMapping>* pScan = rSeqScan.m_Mappings.GetHead();
			for( ; pScan; pScan = pScan->GetNext() )
			{
				MuteMapping& rScan = pScan->GetItemValue();
				memset( &oMute, 0, sizeof( oMute ) );
				oMute.mtTime = rScan.m_mtTime;
				oMute.dwPChannel = dwPChannel;
				oMute.dwPChannelMap = rScan.m_fMute ? DMUS_PCHANNEL_MUTE : rScan.m_dwPChannelMap;
				if( FAILED( pStream->Write( &oMute, sizeof( oMute ), &cb ) ) ||
					cb != sizeof( oMute ) )
				{
					break;
				}
			}
		}
        if( pSeqScan == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CMuteTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
	return E_NOTIMPL;
}

BOOL Less(MuteMapping& Mute1, MuteMapping& Mute2)
{ return Mute1.m_mtTime < Mute2.m_mtTime; }

HRESULT CMuteTrack::Load(LPSTREAM pStream )
{
	V_INAME(CMuteTrack::Load);
	V_INTERFACE(pStream);

    long lFileSize = 0;
	DWORD dwNodeSize;
	DWORD		cb;
    MMCKINFO        ck;
    IAARIFFStream*  pRIFF;
	HRESULT         hr = S_OK;
	DMUS_IO_MUTE		iMute;
    DWORD dwPos;
	TListItem<MapSequence>* pSeqScan;

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	Clear();
	dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
	{
		if (pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
			ck.ckid == DMUS_FOURCC_MUTE_CHUNK)
		{
			lFileSize = ck.cksize;
			hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
			if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
			{
				lFileSize -= 4; // for the size dword
				while( lFileSize > 0 )
				{
					// Once DMUS_IO_MUTE changes, add code here to handle the old struct
					if( dwNodeSize <= sizeof( DMUS_IO_MUTE ) )
					{
						pStream->Read( &iMute, dwNodeSize, NULL );
					}
					else
					{
						pStream->Read( &iMute, sizeof( DMUS_IO_MUTE ), NULL );
						StreamSeek( pStream, lFileSize - sizeof( DMUS_IO_MUTE ), STREAM_SEEK_CUR );
					}
					pSeqScan = m_MapSequenceList.GetHead();
					for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
					{
						if (pSeqScan->GetItemValue().m_dwPChannel == iMute.dwPChannel) break;
					}
					// make a new mapping
					TListItem<MuteMapping>* pNew = new TListItem<MuteMapping>;
					if (pNew)
					{
						MuteMapping& rNew = pNew->GetItemValue();
						memset( &rNew, 0, sizeof( rNew ) );
						rNew.m_mtTime = iMute.mtTime;
						rNew.m_dwPChannelMap = iMute.dwPChannelMap;
						rNew.m_fMute = (iMute.dwPChannelMap == DMUS_PCHANNEL_MUTE) ? TRUE : FALSE;
						if (pSeqScan)
						{
							// add the mapping to the current list
							pSeqScan->GetItemValue().m_Mappings.AddTail(pNew);
						}
						else
						{
							// make a list containing the mapping, and add it to the sequence list
							TListItem<MapSequence>* pNewSeq = new TListItem<MapSequence>;
							if (pNewSeq)
							{
								MapSequence& rNewSeq = pNewSeq->GetItemValue();
								rNewSeq.m_dwPChannel = iMute.dwPChannel;
								rNewSeq.m_Mappings.AddTail(pNew);
								m_MapSequenceList.AddTail(pNewSeq);
							}
							else
							{
								delete pNew;
								pNew = NULL;
							}
						}
					}
					if (!pNew)
					{
						hr = E_OUTOFMEMORY;
					}
					lFileSize -= dwNodeSize;
				}
			}
			if( SUCCEEDED(hr) && 
				lFileSize == 0 &&
				pRIFF->Ascend( &ck, 0 ) == 0 )
			{
				pSeqScan = m_MapSequenceList.GetHead();
				for (; pSeqScan; pSeqScan = pSeqScan->GetNext())
				{
					pSeqScan->GetItemValue().m_Mappings.MergeSort(Less);
				}
			}
			else if (SUCCEEDED(hr)) hr = E_FAIL;
		}
		pRIFF->Release();
	}
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::AddNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::RemoveNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CMuteTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CMuteTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CMuteTrack *pDM;
    
    try
    {
        pDM = new CMuteTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

STDMETHODIMP CMuteTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CMuteTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
	return SetParam(rguidType, (MUSIC_TIME) rtTime, pParam);
}

STDMETHODIMP CMuteTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);


	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	// For now: do nothing.
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return DMUS_S_END;
}


STDMETHODIMP CMuteTrack::Compose(
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CMuteTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\mgentrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       mgentrk.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// MelodyFragment

#ifndef __MELGENTRK_H_
#define __MELGENTRK_H_

#include "dmusicip.h"
#include "TList.h"
//#include "dmpublic.h" // remove when this gets incorporated into dmusici.h/dmusicf.h
#include "dmstyle.h"

#define DMUS_TRANSITIONF_GHOST_FOUND 1
#define DMUS_TRANSITIONF_OVERLAP_FOUND 2
#define DMUS_TRANSITIONF_LAST_FOUND 4
#define DMUS_TRANSITIONF_GHOST_OK 8
#define DMUS_TRANSITIONF_OVERLAP_OK 0x10
#define DMUS_TRANSITIONF_LAST_OK 0x20

// overlap delta is largest value less than a 128th note triplet
#define OVERLAP_DELTA 15

HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom);

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom);

struct CompositionFragment;
struct EventWrapper;

BOOL Less(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2);

BOOL Greater(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2);

BOOL Less(EventWrapper& SeqItem1, EventWrapper& SeqItem2);

BOOL Greater(EventWrapper& SeqItem1, EventWrapper& SeqItem2);

/////////////////////////////////////////////////////////////////////////////
// MelodyFragment
struct MelodyFragment
{
    MelodyFragment() {}

    MelodyFragment(DMUS_MELODY_FRAGMENT& rSource) :
        m_mtTime(rSource.mtTime), 
        m_dwID(rSource.dwID),
        m_dwVariationFlags(rSource.dwVariationFlags),
        m_dwRepeatFragmentID(rSource.dwRepeatFragmentID), 
        m_dwFragmentFlags(rSource.dwFragmentFlags),
        m_dwPlayModeFlags(rSource.dwPlayModeFlags),
        m_dwTransposeIntervals(rSource.dwTransposeIntervals),
        m_ConnectionArc(rSource.ConnectionArc),
        m_Command(rSource.Command)
    {
        wcscpy(m_wszVariationLabel, rSource.wszVariationLabel);
    }

    MelodyFragment(MelodyFragment& rSource) :
        m_mtTime(rSource.m_mtTime), 
        m_dwID(rSource.m_dwID),
        m_dwVariationFlags(rSource.m_dwVariationFlags),
        m_dwRepeatFragmentID(rSource.m_dwRepeatFragmentID), 
        m_dwFragmentFlags(rSource.m_dwFragmentFlags),
        m_dwPlayModeFlags(rSource.m_dwPlayModeFlags),
        m_dwTransposeIntervals(rSource.m_dwTransposeIntervals),
        m_ConnectionArc(rSource.m_ConnectionArc),
        m_Command(rSource.m_Command)
    {
        wcscpy(m_wszVariationLabel, rSource.m_wszVariationLabel);
        for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
        {
            m_aInversionGroups[i] = rSource.m_aInversionGroups[i];
        }
    }

    HRESULT GetPattern(DMStyleStruct* pStyleStruct, 
                       CDirectMusicPattern*& rPattern,
                       TListItem<CompositionFragment>* pLastFragment);

    HRESULT GetVariations(CompositionFragment& rCompFragment,
                          CompositionFragment& rfragmentRepeat,
                          CompositionFragment& rfragmentLast,
                          DMUS_CHORD_PARAM& rCurrentChord, 
                          DMUS_CHORD_PARAM& rNextChord,
                          MUSIC_TIME mtNextChord,
                          TListItem<CompositionFragment>* pLastFragment);

/*  HRESULT GetVariation(DirectMusicPartRef& rPartRef,
                         DMUS_CHORD_PARAM& rCurrentChord,
                         MUSIC_TIME mtNext,
                         MUSIC_TIME mtNextChord,
                         IDirectMusicTrack* pChordTrack,
                         DWORD& rdwVariation);
*/

    HRESULT GetChord(IDirectMusicSegment* pTempSeg, 
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord,
                     MUSIC_TIME& rmtCurrent,
                     DMUS_CHORD_PARAM& rRealCurrentChord);

    HRESULT GetChord(MUSIC_TIME mtTime, 
                     IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord);

    HRESULT TestTransition(BYTE bMIDI,
                           MUSIC_TIME mtTime, 
                           DMUS_CHORD_PARAM& rCurrentChord,
                           int nPartIndex,
                           DirectMusicPartRef& rPartRef,
                           TListItem<CompositionFragment>* pLastFragment);

    HRESULT TestHarmonicConstraints(TListItem<EventWrapper>* pOldEventHead,
                                    TList<EventWrapper>& rNewEventList);

    HRESULT GetFirstNote(int nVariation,
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             CompositionFragment& rCompFragment,
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi,
                             MUSIC_TIME& rmtNote);

    HRESULT GetNote(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi);

    HRESULT GetEvent(CDirectMusicEventItem* pEvent, 
                     DMUS_CHORD_PARAM& rCurrentChord, 
                     DMUS_CHORD_PARAM& rRealCurrentChord, 
                     MUSIC_TIME mtNow, 
                     DirectMusicPartRef& rPartRef,
                     TListItem<EventWrapper>*& rpEventItem);

    HRESULT TransposeEventList(int nInterval,
                               CompositionFragment& rfragmentRepeat,
                               DMUS_CHORD_PARAM& rCurrentChord, 
                               DMUS_CHORD_PARAM& rRealCurrentChord,
                               BYTE bPlaymode,
                               DirectMusicPartRef& rPartRef,
                               TListItem<EventWrapper>*& rpOldEventHead,
                               TList<EventWrapper>& rNewEventList,
                               BYTE& rbFirstMIDI,
                               MUSIC_TIME& rmtFirstTime);

    HRESULT GetRepeatedEvents(CompositionFragment& rfragmentRepeat,
                              DMUS_CHORD_PARAM& rCurrentChord, 
                              DMUS_CHORD_PARAM& rRealCurrentChord,
                              BYTE bPlaymode,
                              int nPartIndex,
                              DirectMusicPartRef& rPartRef,
                              TListItem<CompositionFragment>* pLastFragment,
                              MUSIC_TIME& rmtFirstNote,
                              TList<EventWrapper>& rEventList);

    bool UsesRepeat()
    {
        return (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT) ? true : false;
    }

    bool UsesTransitionRules()
    {
        return (m_ConnectionArc.dwFlags & (DMUS_CONNECTIONF_GHOST | DMUS_CONNECTIONF_INTERVALS | DMUS_CONNECTIONF_OVERLAP)) ? true : false;
    }

    bool RepeatsWithConstraints()
    {
        return 
            UsesRepeat() &&
            ( (m_dwFragmentFlags & (DMUS_FRAGMENTF_SCALE | DMUS_FRAGMENTF_CHORD)) ? true : false );
    }

    DWORD GetID()
    {
        return m_dwID;
    }

    DWORD GetRepeatID()
    {
        return m_dwRepeatFragmentID;
    }

    MUSIC_TIME GetTime()
    {
        return m_mtTime;
    }

    DMUS_COMMAND_PARAM GetCommand()
    {
        return m_Command;
    }

    DMUS_CONNECTION_RULE GetConnectionArc()
    {
        return m_ConnectionArc;
    }

    DWORD GetVariationFlags()
    {
        return m_dwVariationFlags;
    }

    void ClearInversionGroups()
    {
        for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
            m_aInversionGroups[i].m_wGroupID = 0;
    }

protected:

    MUSIC_TIME      m_mtTime;
    DWORD           m_dwID;  // This fragment's ID
    WCHAR           m_wszVariationLabel[DMUS_MAX_FRAGMENTLABEL]; // Each style translates this into a set of variations (held in part ref)
    DWORD           m_dwVariationFlags; // A set of variations
    DWORD           m_dwRepeatFragmentID;  // ID of a fragment to repeat 
    DWORD           m_dwFragmentFlags; // including things like: invert the fragment, transpose it...
    DWORD           m_dwPlayModeFlags; // including new playmodes (only use 8 bits of this)
    DWORD           m_dwTransposeIntervals; // Legal transposition intervals (first 24 bits; two-octave range)
    DMUS_COMMAND_PARAM      m_Command;
    DMUS_CONNECTION_RULE    m_ConnectionArc;
    InversionGroup      m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

// TransitionConstraint (for keeping track of transition constraints)
struct TransitionConstraint
{
    TransitionConstraint() : dwFlags(0), bGhost(0), bOverlap(0), bLastPlayed(0)
    {
    }

    DWORD dwFlags;
    BYTE bGhost;
    BYTE bOverlap;
    BYTE bLastPlayed;
};

// EventOverlap (for remembering events that might overlap succeeding fragments)
struct EventOverlap
{
    ~EventOverlap()
    {
        ZeroMemory(&m_PartRef, sizeof(m_PartRef));
        m_pEvent = NULL;
    }

    DirectMusicPartRef m_PartRef;
    MUSIC_TIME m_mtTime;
    MUSIC_TIME m_mtDuration;
    CDirectMusicEventItem* m_pEvent;
    DMUS_CHORD_PARAM m_Chord;
    DMUS_CHORD_PARAM m_RealChord;
};

struct EventWrapper
{
    EventWrapper() : m_pEvent(NULL), m_mtTime(0), m_bMIDI(0), m_dwPChannel(0), m_wMusic(0), m_bPlaymode(DMUS_PLAYMODE_NONE)
    {
    }

    ~EventWrapper()
    {
        m_pEvent = NULL;
    }

    CDirectMusicEventItem*  m_pEvent;
    MUSIC_TIME              m_mtTime;
    DWORD                   m_dwPChannel;
    WORD                    m_wMusic;
    BYTE                    m_bMIDI;
    BYTE                    m_bScaleFlat;
    BYTE                    m_bScaleSharp;
    BYTE                    m_bChordFlat;
    BYTE                    m_bChordSharp;
    BYTE                    m_bPlaymode;
};

// FragmentPartRecord (for keeping track of previously generated melody fragment parts)
// (in addition to sequence events, may also want to keep track of note events)
struct FragmentPartRecord
{
    FragmentPartRecord()
    {
    }

    ~FragmentPartRecord()
    {
        m_listEvents.CleanUp();
    }

    TList<EventWrapper>     m_listEvents;

};

// CompositionFragment (melody fragment used in the composition process)
struct CompositionFragment : MelodyFragment
{
    CompositionFragment()
    {
        m_aFragmentParts = NULL;
        m_abVariations = NULL;
        m_pStyle = NULL;
        m_pPattern = NULL;
    }

    CompositionFragment(MelodyFragment& rFragment) : MelodyFragment(rFragment)
    {
        m_aFragmentParts = NULL;
        m_abVariations = NULL;
        m_pStyle = NULL;
        m_pPattern = NULL;
    }

    ~CompositionFragment()
    {
        if (m_aFragmentParts) delete [] m_aFragmentParts;
        if (m_abVariations) delete [] m_abVariations;
    }

    HRESULT Init(CDirectMusicPattern* pPattern, DMStyleStruct* pStyleStruct, int nParts)
    {
        m_pStyle = pStyleStruct;
        m_pPattern = pPattern;
        m_abVariations = new BYTE [nParts];
        if (!m_abVariations)
        {
            return E_OUTOFMEMORY;
        }
        m_aFragmentParts = new FragmentPartRecord[nParts];
        if (!m_aFragmentParts)
        {
            delete [] m_abVariations;
            m_abVariations = NULL;
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    void SetPattern(CDirectMusicPattern* pPattern)
    {
        m_pPattern = pPattern;
    }

    void SetStyle(DMStyleStruct* pStyle)
    {
        m_pStyle = pStyle;
    }

    TListItem<EventOverlap>* GetOverlapHead()
    {
        return m_listEventOverlaps.GetHead();
    }

    TList<EventWrapper>& EventList(int i)
    {
        return m_aFragmentParts[i].m_listEvents;
    }

    void AddOverlap(TListItem<EventOverlap>* pOverlap)
    {
        m_listEventOverlaps.AddHead(pOverlap);
    }

    TListItem<EventWrapper>* GetEventHead(int i)
    {
        return m_aFragmentParts[i].m_listEvents.GetHead();
    }

    TListItem<EventWrapper>* RemoveEventHead(int i)
    {
        return m_aFragmentParts[i].m_listEvents.RemoveHead();
    }

    void AddEvent(int i, TListItem<EventWrapper>* pEvent)
    {
        m_aFragmentParts[i].m_listEvents.AddHead(pEvent);
    }

    void InsertEvent(int i, TListItem<EventWrapper>* pEvent)
    {
        TListItem<EventWrapper>* pScan = m_aFragmentParts[i].m_listEvents.GetHead();
        TListItem<EventWrapper>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext() )
        {
            if ( Greater(pEvent->GetItemValue(), pScan->GetItemValue()) ) break;
            pPrevious = pScan;
        }
        if (!pPrevious)
        {
            m_aFragmentParts[i].m_listEvents.AddHead(pEvent);
        }
        else
        {
            pPrevious->SetNext(pEvent);
            pEvent->SetNext(pScan);
        }
    }

    void SortEvents(int i)
    {
        m_aFragmentParts[i].m_listEvents.MergeSort(Greater);
    }

    BOOL IsEmptyEvents(int i)
    {
        return m_aFragmentParts[i].m_listEvents.IsEmpty();
    }

    void CleanupEvents(int i)
    {
        m_aFragmentParts[i].m_listEvents.CleanUp();
    }

    DirectMusicTimeSig& GetTimeSig(DirectMusicPart* pPart)
    {
        if (pPart && pPart->m_timeSig.m_bBeat != 0)
        {
            return pPart->m_timeSig;
        }
        else if (m_pPattern && m_pPattern->m_timeSig.m_bBeat != 0)
        {
            return m_pPattern->m_timeSig;
        }
        else if (m_pStyle && m_pStyle->m_TimeSignature.m_bBeat != 0)
        {
            return m_pStyle->m_TimeSignature;
        }
        else
        {
            return m_staticTimeSig;
        }
    }

    CDirectMusicPattern*        m_pPattern;
    FragmentPartRecord*         m_aFragmentParts;
    BYTE*                       m_abVariations;
    TList<EventOverlap>         m_listEventOverlaps;
    DMStyleStruct*              m_pStyle;
    static DirectMusicTimeSig   m_staticTimeSig;
};

/////////////////////////////////////////////////////////////////////////////
// CMelodyFormulationTrack

class CMelodyFormulationTrack : 
    public IDirectMusicTrack8,
    public IPersistStream
{
public:
    CMelodyFormulationTrack();
    CMelodyFormulationTrack(const CMelodyFormulationTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
    ~CMelodyFormulationTrack();
    void Clear();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

public:
HRESULT STDMETHODCALLTYPE Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            );

HRESULT STDMETHODCALLTYPE InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            );

HRESULT STDMETHODCALLTYPE EndPlay(
                /*[in]*/  void*                     pStateData
            );

HRESULT STDMETHODCALLTYPE Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            );

    HRESULT STDMETHODCALLTYPE GetParam( 
        REFGUID pCommandGuid,
        MUSIC_TIME mtTime,
        MUSIC_TIME* pmtNext,
        void *pData);

    HRESULT STDMETHODCALLTYPE SetParam( 
        /* [in] */ REFGUID pCommandGuid,
        /* [in] */ MUSIC_TIME mtTime,
        /* [out] */ void __RPC_FAR *pData);

    HRESULT STDMETHODCALLTYPE AddNotificationType(
                /* [in] */  REFGUID pGuidNotify
            );

    HRESULT STDMETHODCALLTYPE RemoveNotificationType(
                /* [in] */  REFGUID pGuidNotify
            );

    HRESULT STDMETHODCALLTYPE Clone(
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        IDirectMusicTrack** ppTrack);

    HRESULT STDMETHODCALLTYPE IsParamSupported(
                /*[in]*/ REFGUID            pGuid
            );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
    HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
    HRESULT STDMETHODCALLTYPE IsDirty();

    HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

    HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

    HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// Methods for dealing with melody fragments
    HRESULT SendNotification(MUSIC_TIME mtTime,
                             IDirectMusicPerformance* pPerf,
                             IDirectMusicSegment* pSegment,
                             IDirectMusicSegmentState* pSegState,
                             DWORD dwFlags);
    HRESULT LoadFragments(LPSTREAM pStream, long lFileSize );
    HRESULT SetID(DWORD& rdwID);
    HRESULT GetID(DWORD& rdwID);
    HRESULT AddToSegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicTrack* pNewPatternTrack,
                           DWORD dwGroupBits);

protected:
    // attributes
    long m_cRef;
    CRITICAL_SECTION            m_CriticalSection; // for load and playback
    BYTE                        m_bRequiresSave;

    BOOL                        m_fNotifyRecompose;
    TList<DMUS_MELODY_FRAGMENT> m_FragmentList;
    DWORD                       m_dwLastId;
    BYTE                        m_bPlaymode; // playmode for events in the generated pattern track.
};

#endif // __MELGENTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\mgentrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       mgentrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// MGenTrk.cpp : Implementation of CMelodyFormulationTrack
#include "MGenTrk.h"
#include "dmstyle.h"
#include "debug.h"
#include "..\shared\critsec.h"
#include "..\shared\Validate.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif


DirectMusicTimeSig CompositionFragment::m_staticTimeSig(4, 4, 4);

const BYTE g_bDefaultPlaymode = DMUS_PLAYMODE_ALWAYSPLAY;

// Since one of these is typedef'd to the other, we only need a single
// implementation that does a structure-wide copy (but keep the other 3 implementations
// around, in case we separate the types out later)
HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    rTo.dwPlayModeFlags = DMUS_PLAYMODE_NONE; // only flag supported for dx8
    return S_OK;
}

BOOL Less(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2)
{ return SeqItem1.mtTime + SeqItem1.nOffset < SeqItem2.mtTime + SeqItem2.nOffset; }

BOOL Greater(DMUS_IO_SEQ_ITEM& SeqItem1, DMUS_IO_SEQ_ITEM& SeqItem2)
{ return SeqItem1.mtTime + SeqItem1.nOffset > SeqItem2.mtTime + SeqItem2.nOffset; }

BOOL Less(EventWrapper& SeqItem1, EventWrapper& SeqItem2)
{ 
    MUSIC_TIME mtOffset1 = SeqItem1.m_pEvent ? SeqItem1.m_pEvent->m_nTimeOffset : 0;
    MUSIC_TIME mtOffset2 = SeqItem2.m_pEvent ? SeqItem2.m_pEvent->m_nTimeOffset : 0;
    return SeqItem1.m_mtTime + mtOffset1 < SeqItem2.m_mtTime + mtOffset2;
}

BOOL Greater(EventWrapper& SeqItem1, EventWrapper& SeqItem2)
{ 
    MUSIC_TIME mtOffset1 = SeqItem1.m_pEvent ? SeqItem1.m_pEvent->m_nTimeOffset : 0;
    MUSIC_TIME mtOffset2 = SeqItem2.m_pEvent ? SeqItem2.m_pEvent->m_nTimeOffset : 0;
    return SeqItem1.m_mtTime + mtOffset1 > SeqItem2.m_mtTime + mtOffset2; 
}

/*
HRESULT CopyMelodyFragment(DMUS_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}

HRESULT CopyMelodyFragment(DMUS_IO_MELODY_FRAGMENT& rTo, const DMUS_IO_MELODY_FRAGMENT& rFrom)
{
    rTo = rFrom;
    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CMelodyFormulationTrack


CMelodyFormulationTrack::CMelodyFormulationTrack() : 
    m_bRequiresSave(0), m_dwLastId(0), m_bPlaymode(g_bDefaultPlaymode),
    m_cRef(1), m_fNotifyRecompose(FALSE)

{
    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    IncrementDLLCount();
}

CMelodyFormulationTrack::CMelodyFormulationTrack(const CMelodyFormulationTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_dwLastId(rTrack.m_dwLastId), m_bPlaymode(rTrack.m_bPlaymode),
    m_cRef(1), m_fNotifyRecompose(FALSE)
{
    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    IncrementDLLCount();
    m_bPlaymode = rTrack.m_bPlaymode;
    BOOL fStarted = FALSE;
    TListItem<DMUS_MELODY_FRAGMENT>* pScan = rTrack.m_FragmentList.GetHead();
    TListItem<DMUS_MELODY_FRAGMENT>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMUS_MELODY_FRAGMENT& rScan = pScan->GetItemValue();
        if (rScan.mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.mtTime < mtEnd)
        {
            if (rScan.mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
            }
            TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
            if (pNew)
            {
                DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
                CopyMelodyFragment(rNew, rScan);
                rNew.mtTime = rScan.mtTime - mtStart;
                m_FragmentList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        DMUS_MELODY_FRAGMENT& rPrevious = pPrevious->GetItemValue();
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
        if (pNew)
        {
            DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
            CopyMelodyFragment(rNew, rPrevious);
            rNew.mtTime = 0;
            m_FragmentList.AddHead(pNew);
        }
    }
}

CMelodyFormulationTrack::~CMelodyFormulationTrack()
{
    DELETE_CRITICAL_SECTION( &m_CriticalSection );
    DecrementDLLCount();
}

void CMelodyFormulationTrack::Clear()
{
    m_FragmentList.CleanUp();
    m_dwLastId = 0;
}


HRESULT CMelodyFormulationTrack::SetID(DWORD& rdwID)
{
    m_dwLastId++;
    rdwID = m_dwLastId;
    return S_OK;
}

HRESULT CMelodyFormulationTrack::GetID(DWORD& rdwID)
{
    rdwID = m_dwLastId;
    return S_OK;
}

STDMETHODIMP CMelodyFormulationTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CMelodyFormulationTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMelodyFormulationTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMelodyFormulationTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CMelodyFormulationTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK; // if I return an error, dmime gives me an assertion failure
}

HRESULT CMelodyFormulationTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    return S_OK;
}

HRESULT CMelodyFormulationTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    return S_OK;
}

HRESULT CMelodyFormulationTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? true : false;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? true : false;
    bool fCompose = (dwFlags & DMUS_TRACKF_RECOMPOSE) ? true : false;
    bool fPlayOff = (dwFlags & DMUS_TRACKF_PLAY_OFF) ? true : false;
    HRESULT hr = S_OK;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    DWORD dwTrackGroup = 1;
    if ( fStart || fLoop ) 
    {
        if ( fCompose && !fPlayOff )
        {
            IDirectMusicSegment* pSegment = NULL;
            if (SUCCEEDED(hr = pSegState->GetSegment(&pSegment)))
            {
                IDirectMusicTrack* pTrack = NULL;
                if (SUCCEEDED(hr = QueryInterface(IID_IDirectMusicTrack, (void**)&pTrack)))
                {
                    pSegment->GetTrackGroup(pTrack, &dwTrackGroup);
                    pTrack->Release();
                    // call Track::Compose on this track
                    if (SUCCEEDED(hr = Compose(pSegment, dwTrackGroup, &pTrack)))
                    {
                        if (SUCCEEDED(AddToSegment(pSegment, pTrack, dwTrackGroup)))
                        {
                            // if we recomposed, send a recompose notification
                            SendNotification(mtStart + mtOffset, pPerf, pSegment, pSegState, dwFlags);
                        }
                        pTrack->Release();
                    }
                }
            }
            pSegment->Release();
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

// This will modify an existing segment by adding *only* a pattern track to it.
// Any existing pattern tracks with conflicting group bits will be modifed.
HRESULT CMelodyFormulationTrack::AddToSegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicTrack* pNewPatternTrack,
                           DWORD dwGroupBits)
{
    HRESULT                 hr                          = S_OK;
    IDirectMusicTrack*      pCurrentPatternTrack        = NULL;
    IStream*                pNewPatternStream           = NULL;
    IPersistStream*         pNewPatternTrackStream      = NULL;
    IPersistStream*         pCurrentPatternTrackStream  = NULL;

    // if there exists a pattern track with these group bits, reload this pattern into that
    // track (use the first track that's found).  Otherwise, insert this track into the segment.
    hr = pTempSeg->GetTrack(CLSID_DirectMusicPatternTrack, dwGroupBits, 0, &pCurrentPatternTrack);
    if (S_OK != hr)
    {
        // insert the passed-in track
        hr = pTempSeg->InsertTrack(pNewPatternTrack, dwGroupBits);
    }
    else
    {
        // load the new track into the one that already exists
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pNewPatternStream);
        if (S_OK != hr) goto ON_END;
        hr = pNewPatternTrack->QueryInterface( IID_IPersistStream, (void**)&pNewPatternTrackStream);
        if (S_OK != hr) goto ON_END;
        pNewPatternTrackStream->Save(pNewPatternStream, FALSE);
        hr = pCurrentPatternTrack->QueryInterface(IID_IPersistStream, (void**)&pCurrentPatternTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pNewPatternStream, 0, STREAM_SEEK_SET);
        hr = pCurrentPatternTrackStream->Load(pNewPatternStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }

ON_END:
    if (pCurrentPatternTrack) pCurrentPatternTrack->Release();
    if (pCurrentPatternTrackStream) pCurrentPatternTrackStream->Release();
    if (pNewPatternStream) pNewPatternStream->Release();
    if (pNewPatternTrackStream) pNewPatternTrackStream->Release();
    return hr;
}

HRESULT CMelodyFormulationTrack::SendNotification(MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegment* pSegment,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (!m_fNotifyRecompose || (dwFlags & DMUS_TRACKF_NOTIFY_OFF))
    {
        return S_OK;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_RECOMPOSE;
        pEvent->guidNotificationType = GUID_NOTIFICATION_RECOMPOSE;

        if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
        {
            pEvent->dwGroupID = 0xffffffff;
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CMelodyFormulationTrack::GetParam(
                REFGUID                     rParamGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    V_INAME(CMelodyFormulationTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData, 1);
    V_REFGUID(rParamGuid);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (rParamGuid == GUID_MelodyFragment)
    {
        TListItem<DMUS_MELODY_FRAGMENT>* pMelGen = m_FragmentList.GetHead();
        if (pMelGen)
        {
            TListItem<DMUS_MELODY_FRAGMENT>* pNext = pMelGen->GetNext();
            for(; pNext; pNext = pNext->GetNext())
            {
                if (pNext->GetItemValue().mtTime <= mtTime) // may be it, but we need a next time
                {
                    pMelGen = pNext;
                }
                else // passed it
                {
                    break;
                }
            }
            *(DMUS_MELODY_FRAGMENT*)pData = pMelGen->GetItemValue();
            if (pmtNext)
            {
                if (pNext)
                {
                    *pmtNext = pNext->GetItemValue().mtTime - mtTime;
                }
                else
                {
                    *pmtNext = 0;
                }
            }
            hr = S_OK;
        }
        else hr = DMUS_E_NOT_FOUND;
    }
    else if (rParamGuid == GUID_MelodyFragmentRepeat)
    {
        // replace the passed-in fragment with the one its repeat field refers to
        DMUS_MELODY_FRAGMENT* pFragment = (DMUS_MELODY_FRAGMENT*)pData;
        if (!(pFragment->dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT))
        {
            hr = DMUS_E_NOT_FOUND;
        }
        else
        {
            TListItem<DMUS_MELODY_FRAGMENT>* pMelGen = m_FragmentList.GetHead();
            for(; pMelGen; pMelGen = pMelGen->GetNext())
            {
                if (pMelGen->GetItemValue().dwID == pFragment->dwRepeatFragmentID)
                {
                    break;
                }
            }
            if (pMelGen)
            {
                *(DMUS_MELODY_FRAGMENT*)pData = pMelGen->GetItemValue();
                if (pmtNext)
                {
                    TListItem<DMUS_MELODY_FRAGMENT>* pNext = pMelGen->GetNext();
                    if (pNext)
                    {
                        *pmtNext = pNext->GetItemValue().mtTime - mtTime;
                    }
                    else
                    {
                        *pmtNext = 0;
                    }
                }
                hr = S_OK;
            }
            else hr = DMUS_E_NOT_FOUND;
        }
    }
    else if (rParamGuid == GUID_MelodyPlaymode)
    {
        *(BYTE*)pData = m_bPlaymode;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
} 

HRESULT CMelodyFormulationTrack::SetParam( 
    REFGUID                     rParamGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CMelodyFormulationTrack::SetParam);
    V_PTR_WRITE(pData, 1);
    V_REFGUID(rParamGuid);

    HRESULT hr;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (rParamGuid == GUID_Clear_All_MelodyFragments)
    {
        Clear();
        hr = S_OK;
    }
    else if (rParamGuid == GUID_MelodyFragment)
    {
        DMUS_MELODY_FRAGMENT* pFragment = (DMUS_MELODY_FRAGMENT*)pData;
        TListItem<DMUS_MELODY_FRAGMENT>* pFragmentItem = m_FragmentList.GetHead();
        TListItem<DMUS_MELODY_FRAGMENT>* pPrevious = NULL;
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            pNew->GetItemValue() = *pFragment;
            // overide time in struct with time passed in
            pNew->GetItemValue().mtTime = mtTime; 
            for(; pFragmentItem != NULL; pFragmentItem = pFragmentItem->GetNext())
            {
                if (pFragmentItem->GetItemValue().mtTime >= mtTime) break;
                pPrevious = pFragmentItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pFragmentItem);
            }
            else // pFragmentItem is current head of list
            {
                m_FragmentList.AddHead(pNew);
            }
            if (pFragmentItem && pFragmentItem->GetItemValue().mtTime == mtTime)
            {
                // remove it
                pNew->GetItemValue().dwID = pFragmentItem->GetItemValue().dwID;
                pNew->SetNext(pFragmentItem->GetNext());
                pFragmentItem->SetNext(NULL);
                delete pFragmentItem;
            }
            else
            {
                // give the struct a brand new ID
                SetID(pNew->GetItemValue().dwID);
            }
            hr = S_OK;
        }
    }
    else
    {
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CMelodyFormulationTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CMelodyFormulationTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicMelodyFormulationTrack;
    return S_OK;
}

HRESULT CMelodyFormulationTrack::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    V_INAME(CMelodyFormulationTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_MelodyFragment || 
        rGuid == GUID_MelodyPlaymode ||
        rGuid == GUID_Clear_All_MelodyFragments)
        return S_OK;
    else 
        return DMUS_E_TYPE_UNSUPPORTED;
}

// IPersistStream methods
 HRESULT CMelodyFormulationTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMelodyFormulationTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CMelodyFormulationTrack::Save);
    V_INTERFACE(pStream);

    HRESULT         hr = S_OK;
    IAARIFFStream* pRIFF = NULL;
    MMCKINFO        ckMain, ckHeader, ckBody;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_MELODY_FRAGMENT oMelGen;
    TListItem<DMUS_MELODY_FRAGMENT>* pMelGen;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if ( FAILED( hr ) )
    {
        goto ON_END;
    }

    // Create a chunk to store the MelGen data
    ckMain.fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
    if( pRIFF->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Write MelForm chunk header
    ckHeader.ckid = DMUS_FOURCC_MELODYFORM_HEADER_CHUNK;
    if( pRIFF->CreateChunk( &ckHeader, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Prepare DMUS_IO_MELFORM
    DMUS_IO_MELFORM oMelForm;
    memset( &oMelForm, 0, sizeof(DMUS_IO_MELFORM) );

    oMelForm.dwPlaymode = m_bPlaymode;
        
    // Write MelForm chunk data
    hr = pStream->Write( &oMelForm, sizeof(DMUS_IO_MELFORM), &cb);
    if( FAILED( hr ) ||  cb != sizeof(DMUS_IO_MELFORM) )
    {
        hr = E_FAIL;
        goto ON_END;
    }
    
    if( pRIFF->Ascend( &ckHeader, 0 ) != 0 )
    {
        hr = E_FAIL;
        goto ON_END;
    }

    // Write MelForm chunk body
    ckBody.ckid = DMUS_FOURCC_MELODYFORM_BODY_CHUNK;
    if( pRIFF->CreateChunk( &ckBody, 0 ) == 0 )
    {
        dwSize = sizeof( oMelGen );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pMelGen = m_FragmentList.GetHead(); pMelGen != NULL ; pMelGen = pMelGen->GetNext() )
        {
            DMUS_MELODY_FRAGMENT& rMelGen = pMelGen->GetItemValue();
            memset( &oMelGen, 0, sizeof( oMelGen ) );
            CopyMelodyFragment(oMelGen, rMelGen);
            if( FAILED( pStream->Write( &oMelGen, sizeof( oMelGen ), &cb ) ) ||
                cb != sizeof( oMelGen ) )
            {
                break;
            }
        }
        if( pMelGen == NULL )
        {
            hr = S_OK;
        }

        // Ascend out of the MelForm Body chunk
        if( pRIFF->Ascend( &ckBody, 0 ) != 0 )
        {
            hr = E_FAIL;
            goto ON_END;
        }
    }

    // Ascend out of the MelGen chunk.
    pRIFF->Ascend( &ckMain, 0 );

ON_END:
    if (pRIFF) pRIFF->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CMelodyFormulationTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(DMUS_MELODY_FRAGMENT& MF1, DMUS_MELODY_FRAGMENT& MF2)
{ return MF1.mtTime < MF2.mtTime; }

HRESULT CMelodyFormulationTrack::Load(LPSTREAM pStream )
{
    V_INAME(CMelodyFormulationTrack::Load);
    V_INTERFACE(pStream);

    HRESULT         hr = DMUS_E_CHUNKNOTFOUND;
    DWORD dwPos;
    IAARIFFStream*  pRIFF;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    Clear();
    m_dwLastId = 0;
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    MMCKINFO        ckMain;
    MMCKINFO        ckHeader;
    bool fFoundTrack = false;

    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_MELODYFORM_TRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            // New melform track
            DMUS_IO_MELFORM iMelform;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0)
            {
                if (ckHeader.ckid == DMUS_FOURCC_MELODYFORM_HEADER_CHUNK )
                {
                    hr = pStream->Read( &iMelform, sizeof( iMelform ), &cb );
                    if (FAILED(hr) || cb != sizeof( iMelform ) ) 
                    {
                        if (SUCCEEDED(hr)) hr = DMUS_E_CHUNKNOTFOUND;
                    }
                    else
                    {
                        //m_bPlaymode = (BYTE) iMelform.dwPlaymode;
                        m_bPlaymode = DMUS_PLAYMODE_NONE;  // only flag supported for dx8
                    }
                }
                pRIFF->Ascend( &ckHeader, 0 );
            }
            if (SUCCEEDED(hr))
            {
                hr = DMUS_E_CHUNKNOTFOUND;
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0)
                {
                    if (ck.ckid == DMUS_FOURCC_MELODYFORM_BODY_CHUNK )
                    {
                        if( SUCCEEDED(LoadFragments(pStream, (long) ck.cksize)) )
                        {
                            hr = S_OK;
                            m_FragmentList.MergeSort(Less);
                        }
                    }
                    pRIFF->Ascend( &ck, 0 );
                }
            }

            fFoundTrack = true;
        }
        pRIFF->Release();
        pRIFF = NULL;
    }

    if (!fFoundTrack)
    {
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        // old (obsolete) melform track
        if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
        {
            ck.ckid = DMUS_FOURCC_MELODYGEN_TRACK_CHUNK;
            if ( pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
            {
                if( SUCCEEDED(LoadFragments(pStream, (long) ck.cksize)) &&
                    pRIFF->Ascend( &ck, 0 ) == 0 )
                {
                    hr = S_OK;
                    m_FragmentList.MergeSort(Less);
                }
            }
            pRIFF->Release();
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CMelodyFormulationTrack::LoadFragments(LPSTREAM pStream, long lFileSize )
{
    DWORD dwNodeSize;
    DWORD       cb;
    HRESULT hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
    DMUS_IO_MELODY_FRAGMENT     iMelGen;
    if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
    {
        lFileSize -= 4; // for the size dword
        TListItem<DMUS_MELODY_FRAGMENT>* pMelGen;
        if (lFileSize % dwNodeSize)
        {
            hr = E_FAIL;
        }
        else
        {
            while( lFileSize > 0 )
            {
                pMelGen = new TListItem<DMUS_MELODY_FRAGMENT>;
                if( pMelGen )
                {
                    DMUS_MELODY_FRAGMENT& rMelGen = pMelGen->GetItemValue();
                    if( dwNodeSize <= sizeof( iMelGen ) )
                    {
                        pStream->Read( &iMelGen, dwNodeSize, NULL );
                    }
                    else
                    {
                        pStream->Read( &iMelGen, sizeof( iMelGen ), NULL );
                        DWORD dw = (lFileSize >= sizeof( iMelGen ) ) ? lFileSize - sizeof( iMelGen ) : 0;
                        StreamSeek( pStream, dw, STREAM_SEEK_CUR );
                    }
                    memset( &rMelGen, 0, sizeof( rMelGen ) );
                    CopyMelodyFragment(rMelGen, iMelGen);
                    m_FragmentList.AddHead(pMelGen);
                    lFileSize -= dwNodeSize;
                }
                else break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (lFileSize != 0)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CMelodyFormulationTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CSPstTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    
    CMelodyFormulationTrack *pDM;
    
    try
    {
        pDM = new CMelodyFormulationTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT MelodyFragment::GetChord(IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord,
                     MUSIC_TIME& rmtCurrent,
                     DMUS_CHORD_PARAM& rRealCurrentChord)
{
    HRESULT hr = S_OK;

    hr = GetChord(m_mtTime, pTempSeg, pSong, dwTrackGroup, rmtNext, rRealCurrentChord);

    if ( SUCCEEDED(hr) )
    {
        rmtCurrent = rmtNext;
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_ANTICIPATE)
        {
            hr = GetChord(rmtCurrent, pTempSeg, pSong, dwTrackGroup, rmtNext, rCurrentChord);
        }
        else
        {
            rCurrentChord = rRealCurrentChord;
        }
    }

    return hr;
}

HRESULT MelodyFragment::GetChord(MUSIC_TIME mtTime, 
                     IDirectMusicSegment* pTempSeg,
                     IDirectMusicSong* pSong,
                     DWORD dwTrackGroup,
                     MUSIC_TIME& rmtNext,
                     DMUS_CHORD_PARAM& rCurrentChord)
{
    HRESULT hr = E_FAIL;

    DMUS_CHORD_PARAM DefaultChord;
    wcscpy(DefaultChord.wszName, L"M7");
    DefaultChord.wMeasure = 0;
    DefaultChord.bBeat = 0;
    DefaultChord.bSubChordCount = 1;
    DefaultChord.dwScale = 0xab5ab5;  // default: major scale
    DefaultChord.bKey = 12;    // default: C2
    DefaultChord.SubChordList[0].dwChordPattern = 0x91;   // default: major chord
    DefaultChord.SubChordList[0].dwScalePattern = 0xab5ab5;  // default: major scale
    DefaultChord.SubChordList[0].dwInversionPoints = 0xffffff; // default: inversions everywhere
    DefaultChord.SubChordList[0].dwLevels = 0xffffff; // let this work with anything...
    DefaultChord.SubChordList[0].bChordRoot = 12;      // default: C2
    DefaultChord.SubChordList[0].bScaleRoot = 0;

    if (pTempSeg)
    {
        hr = pTempSeg->GetParam(GUID_ChordParam, dwTrackGroup, 0, mtTime, &rmtNext, (void*)&rCurrentChord);
    }
    else if (pSong)
    {
        hr = pSong->GetParam(GUID_ChordParam, dwTrackGroup, 0, mtTime, &rmtNext, (void*)&rCurrentChord);
    }
    if (SUCCEEDED(hr))
    {
        rmtNext += mtTime;
        hr = S_OK;
    }
    else
    {
        rCurrentChord = DefaultChord;
        rmtNext = 0;
        hr = S_FALSE;
    }


    return hr;
}

HRESULT MelodyFragment::GetPattern(DMStyleStruct* pStyleStruct, 
                       CDirectMusicPattern*& rpPattern,
                       TListItem<CompositionFragment>* pLastFragment)
{
    HRESULT hr = S_OK;
    DMUS_COMMAND_PARAM_2 Command[1];
    Command[0].mtTime = 0;
    if (m_Command.bGrooveLevel == 0 && pLastFragment)
    {
        m_Command = pLastFragment->GetItemValue().GetCommand();
    }
    Command[0].bCommand = m_Command.bCommand;
    Command[0].bGrooveLevel = m_Command.bGrooveLevel;
    Command[0].bGrooveRange = m_Command.bGrooveRange;

    TListItem<CDirectMusicPattern*>* pPatItem = pStyleStruct->m_PatternList.GetHead();
    if (pPatItem)
    {
        // choose the first matching pattern
        for ( ; pPatItem; pPatItem = pPatItem->GetNext())
        {
            CDirectMusicPattern* pPattern = pPatItem->GetItemValue();
            if (pPattern && pPattern->MatchCommand(Command, 1) )
            {
                rpPattern = pPattern;
                hr = S_OK;
                break;
            }
        }
        if (!pPatItem) // problem; fallback to first pattern
        {
            pPatItem = pStyleStruct->m_PatternList.GetHead();
            rpPattern = pPatItem->GetItemValue();
            hr = S_OK;
        }
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

// GetTransitionNotes: given the time of a note, and a fragment, return the appropriate
// transition note tuple (last and overlap; ghost tested separately)
HRESULT GetTransitionNotes(MUSIC_TIME mtTime, 
                           DWORD dwPart,
                           TListItem<CompositionFragment>* pCompFragment, 
                           TransitionConstraint& rTransition)
{
    rTransition.dwFlags &= ~DMUS_TRANSITIONF_OVERLAP_FOUND;
    rTransition.dwFlags &= ~DMUS_TRANSITIONF_LAST_FOUND;
    // Check pCompFragment overlaps for the last note to start before mtTime,
    // and the first note to start on or after mtTime.
    if (pCompFragment)
    {
        CompositionFragment& rFragment = pCompFragment->GetItemValue();
        TListItem<EventOverlap>* pOverlap = rFragment.GetOverlapHead();
        MUSIC_TIME nMinOverlap = 0;
        MUSIC_TIME nMaxPlayed = 0;
        for (; pOverlap; pOverlap = pOverlap->GetNext() )
        {
            EventOverlap& rOverlap = pOverlap->GetItemValue();
            if ( rOverlap.m_PartRef.m_dwLogicalPartID == dwPart &&
                 (rOverlap.m_pEvent->m_dwEventTag & DMUS_EVENT_NOTE) )
            {
                if (rOverlap.m_mtTime >= mtTime) // this note overlaps
                {
                    if ( !(rTransition.dwFlags & DMUS_TRANSITIONF_OVERLAP_FOUND) || 
                          rOverlap.m_mtTime < nMinOverlap )
                    {
                        HRESULT hr = rFragment.GetNote(rOverlap.m_pEvent, rOverlap.m_Chord, rOverlap.m_PartRef, rTransition.bOverlap);
                        if (SUCCEEDED(hr))
                        {
                            nMinOverlap = rOverlap.m_mtTime;
                            rTransition.dwFlags |= DMUS_TRANSITIONF_OVERLAP_FOUND;
                        }
                    }
                }
                if (rOverlap.m_mtTime < mtTime) // this note will be played
                {
                    if ( !(rTransition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND) || 
                          rOverlap.m_mtTime >= nMaxPlayed )
                    {
                        HRESULT hr = rFragment.GetNote(rOverlap.m_pEvent, rOverlap.m_Chord, rOverlap.m_PartRef, rTransition.bLastPlayed);
                        if (SUCCEEDED(hr))
                        {
                            nMaxPlayed = rOverlap.m_mtTime;
                            rTransition.dwFlags |= DMUS_TRANSITIONF_LAST_FOUND;
                        }
                    }
                }
            }
        }
        // If we couldn't find a last note, use the last note in the event list of pCompFragment
        TListItem<CompositionFragment>* pfragmentScan = pCompFragment;
        while (pfragmentScan && !(rTransition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND))
        {
            CompositionFragment& rfragmentScan = pfragmentScan->GetItemValue();
            TListItem<DirectMusicPartRef>* pPartRef = rfragmentScan.m_pPattern->m_PartRefList.GetHead();
            int nParts = rfragmentScan.m_pPattern->m_PartRefList.GetCount();
            for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
            {
                if (pPartRef->GetItemValue().m_dwLogicalPartID == dwPart) break;
            }
            if (i < nParts)
            {
                TListItem<EventWrapper>* pEventItem = rfragmentScan.GetEventHead(i);
                if (pEventItem) 
                {
                    // The list is sorted in reverse order, so the head is the last element
                    rTransition.bLastPlayed = pEventItem->GetItemValue().m_bMIDI;
                    rTransition.dwFlags |= DMUS_TRANSITIONF_LAST_FOUND;
                }
            }
            pfragmentScan = pfragmentScan->GetNext(); // goes backwards to first fragment 
        }
    }

    return S_OK;
}

HRESULT MelodyFragment::TestTransition(BYTE bMIDI,
                                       MUSIC_TIME mtNote, 
                                       DMUS_CHORD_PARAM& rCurrentChord, 
                                       int nPartIndex,
                                       DirectMusicPartRef& rPartRef,
                                       TListItem<CompositionFragment>* pLastFragment)
{ 
    bool fGhost = false;
    bool fOverlap = false;
    bool fGoodInterval = false;
    if (pLastFragment)
    {
        // if this variation doesn't meet the constraints, return S_FALSE; otherwise return S_OK
        DMUS_CONNECTION_RULE Connection = pLastFragment->GetItemValue().GetConnectionArc();

        DWORD dwPart = rPartRef.m_dwLogicalPartID;
        TransitionConstraint Transition;
        ZeroMemory(&Transition , sizeof(Transition));
        
        GetTransitionNotes(mtNote, dwPart, pLastFragment, Transition);

        // Test ghost notes
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_GHOST) )
        {
            BYTE bGhost = 0;
            CDMStyleNote* pNoteEvent = new CDMStyleNote;
            if (pNoteEvent)
            {
                pNoteEvent->m_bDurRange = 0;
                pNoteEvent->m_bFlags = 0;
                pNoteEvent->m_bTimeRange = 0;
                pNoteEvent->m_bVelocity = 0;
                pNoteEvent->m_dwFragmentID = 0;
                pNoteEvent->m_mtDuration = 0;
                pNoteEvent->m_nGridStart = 0;
                pNoteEvent->m_nTimeOffset = 0;
                TListItem<DMUS_IO_STYLERESOLUTION>* pScan = rPartRef.m_pDMPart->m_ResolutionList.GetHead();
                for(; pScan; pScan = pScan->GetNext() )
                {
                    DMUS_IO_STYLERESOLUTION& rResolution = pScan->GetItemValue();
                    pNoteEvent->m_bInversionId = rResolution.bInversionID;
                    pNoteEvent->m_bPlayModeFlags = rResolution.bPlayModeFlags;
                    pNoteEvent->m_dwVariation = rResolution.dwVariation;
                    pNoteEvent->m_wMusicValue = rResolution.wMusicValue;
                    if ((1 << pLastFragment->GetItemValue().m_abVariations[nPartIndex]) & pNoteEvent->m_dwVariation &&
                        SUCCEEDED(GetNote(pNoteEvent, rCurrentChord, rPartRef, bGhost)))
                    {
                        if (bGhost == bMIDI)
                        {
                            fGhost = true;
                            break;
                        }
                    }
                }
                delete pNoteEvent;
            }
        }

        // Test overlap notes 
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_OVERLAP) &&
             (Transition.dwFlags & DMUS_TRANSITIONF_OVERLAP_FOUND) )
        {
                if (Transition.bOverlap == bMIDI) fOverlap = true;
        }

        // Test last played notes
        // Assumptions:
        // 1. intervals go in either direction (up or down)
        // 2. intervals are in absolute semitones.
        if ( (Connection.dwFlags & DMUS_CONNECTIONF_INTERVALS) && 
             (Transition.dwFlags & DMUS_TRANSITIONF_LAST_FOUND) )
        {
            DWORD dwIntervals = Connection.dwIntervals;
            for (int nTranspose = 0; nTranspose <= 12; nTranspose++)
            {
                if ( dwIntervals & (1 << nTranspose) )
                {
                    if (Transition.bLastPlayed + nTranspose == bMIDI ||
                        Transition.bLastPlayed - nTranspose == bMIDI)
                    {
                        fGoodInterval = true;
                    }
                }
            }
        }
    }
    return (fGhost || fOverlap || fGoodInterval) ? S_OK : S_FALSE;
}

// Currently assuming diatonic intervals spanning an octave
#define MAX_INTERVAL 8

// Currently only transposes up...
BYTE TransposeNote(BYTE bMIDI, int nInterval, DMUS_CHORD_PARAM& rChord)
{
    if (!bMIDI) return bMIDI;
    nInterval++; // To correspond to scale intervals
    for (int nSemitone = 0; nSemitone < 24; nSemitone++)
    {
        if (rChord.dwScale & (1 << nSemitone))
        {
            nInterval--;
            if (!nInterval) break;
        }
    }
    if (nSemitone < 24)
    {
        bMIDI = (BYTE) (bMIDI + nSemitone);
    }
    return bMIDI;
}

DWORD ShiftScale(DWORD dwScale, char chRoot)
{
    while (chRoot < 0) chRoot += 12;
    while (chRoot > 11) chRoot -= 12;
    dwScale &= 0xfff;
    dwScale <<= chRoot;
    dwScale |= (dwScale >> 12);
    return dwScale & 0xfff;
}

void ScaleMisses(BYTE bTone, DWORD dwScale, BYTE& rFlats, BYTE& rSharps)
{
    // make sure the flats don't underflow the scale
    bool fUnderflow = true;
    for (int i = 0; i <= bTone; i++)
    {
        if (dwScale & (1 << i))
        {
            fUnderflow = false;
            break;
        }
    }
    if (fUnderflow)
    {
        bTone += 12;
    }
    // make sure the sharps don't overflow the scale
    bool fOverflow = true;
    for (i = bTone; i < 24; i++)
    {
        if (dwScale & (1 << i))
        {
            fOverflow = false;
            break;
        }
    }
    if (fOverflow)
    {
        dwScale |= ((dwScale << 12) & 0xfff000);
    }
    rFlats = rSharps = 0;
    // If this note is in the scale, no need to do any other processing
    if ( !(dwScale & (1 << bTone)) )
    {
        for (i = 0; i <= bTone; i++) 
        {
            if (dwScale & (1 << i))
            {
                rFlats = 0;
            }
            else
            {
                rFlats++;
            }
        }
        for (i = bTone; i < 24; i++) 
        {
            if (dwScale & (1 << i))
            {
                return;
            }
            else
            {
                rSharps++;
            }
        }
    }
}

// Transpose all events in the repeat fragment diatonically, according to the underlying scale given
// in the chord, adjusting all times relative to the the current fragment.  
// Return the time of the first note in the transposed fragment.
HRESULT MelodyFragment::TransposeEventList(int nInterval,
                                           CompositionFragment& rfragmentRepeat,
                                           DMUS_CHORD_PARAM& rCurrentChord, 
                                           DMUS_CHORD_PARAM& rRealCurrentChord,
                                           BYTE bPlaymode,
                                           DirectMusicPartRef& rPartRef,
                                           TListItem<EventWrapper>*& rpOldEventHead,
                                           TList<EventWrapper>& rNewEventList,
                                           BYTE& rbFirstMIDI,
                                           MUSIC_TIME& rmtFirstTime)
{
    DWORD dwScale = ShiftScale(rCurrentChord.dwScale, rCurrentChord.bKey);
    DWORD dwChord = ShiftScale(rCurrentChord.SubChordList[0].dwChordPattern, rCurrentChord.SubChordList[0].bChordRoot);
    rbFirstMIDI = 0;
    rmtFirstTime = 0;
    bool fFirstEvent = true;
    HRESULT hr = S_OK;
    MUSIC_TIME mtElapsed = m_mtTime - rfragmentRepeat.GetTime();
    //if (!mtElapsed) mtElapsed = 0; // clamp mtElapsed to non-negative (??)
    if (m_dwTransposeIntervals & (1 << nInterval))
    {
        rNewEventList.CleanUp();
        // Find the corresponding part in the repeat fragment
        TListItem<DirectMusicPartRef>* pPartRef = rfragmentRepeat.m_pPattern->m_PartRefList.GetHead();
        int nParts = rfragmentRepeat.m_pPattern->m_PartRefList.GetCount();
        for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            if (pPartRef->GetItemValue().m_dwLogicalPartID == rPartRef.m_dwLogicalPartID) break;
        }
        if (i < nParts)
        {
            TListItem<EventWrapper>* pScan = rfragmentRepeat.GetEventHead(i);
            rpOldEventHead = pScan;
            for (; pScan && SUCCEEDED(hr); pScan = pScan->GetNext())
            {
                EventWrapper ScanEvent = pScan->GetItemValue();
                TListItem<EventWrapper>* pEventItem = new TListItem<EventWrapper>;
                if (!pEventItem) hr = E_OUTOFMEMORY;
                else
                {
                    EventWrapper& rEvent = pEventItem->GetItemValue();
                    rEvent.m_mtTime = ScanEvent.m_mtTime + mtElapsed;
                    rEvent.m_bMIDI = TransposeNote(ScanEvent.m_bMIDI, nInterval, rCurrentChord);
                    BYTE bTone = (BYTE) (rEvent.m_bMIDI % 12);
                    ScaleMisses(bTone, dwScale, rEvent.m_bScaleFlat, rEvent.m_bScaleSharp); 
                    ScaleMisses(bTone, dwChord, rEvent.m_bChordFlat, rEvent.m_bChordSharp); 
                    hr = rPartRef.ConvertMIDIValue(rEvent.m_bMIDI, 
                                              rRealCurrentChord,
                                              bPlaymode,
                                              NULL,
                                              rEvent.m_wMusic);
                    if (FAILED(rEvent.m_wMusic))
                    {
                        rEvent.m_wMusic = 0;
                    }
                    rEvent.m_bPlaymode = bPlaymode;
                    rEvent.m_pEvent = ScanEvent.m_pEvent;
                    rEvent.m_dwPChannel = ScanEvent.m_dwPChannel;
                    rNewEventList.AddHead(pEventItem);
                    if (fFirstEvent || rEvent.m_mtTime < rmtFirstTime)
                    {
                        rmtFirstTime = rEvent.m_mtTime;
                        rbFirstMIDI = rEvent.m_bMIDI;
                        fFirstEvent = false;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                rNewEventList.MergeSort(Greater);
            }
        }
        else hr = E_FAIL;
    }
    else hr = E_FAIL;
    return hr;
}

HRESULT MelodyFragment::TestHarmonicConstraints(TListItem<EventWrapper>* pOldEventHead,
                                                TList<EventWrapper>& rNewEventList)
{
    HRESULT hr = S_OK;
    TListItem<EventWrapper>* pOldScan = pOldEventHead;
    TListItem<EventWrapper>* pNewScan = rNewEventList.GetHead();
    for (; pOldScan && pNewScan && SUCCEEDED(hr); pOldScan = pOldScan->GetNext(), pNewScan = pNewScan->GetNext())
    {
        EventWrapper& rOldEvent = pOldScan->GetItemValue();
        EventWrapper& rNewEvent = pNewScan->GetItemValue();
        BYTE bOldFlats, bOldSharps, bNewFlats, bNewSharps;
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_CHORD)
        {
            bOldFlats = rOldEvent.m_bChordFlat;
            bOldSharps = rOldEvent.m_bChordSharp;
            bNewFlats = rNewEvent.m_bChordFlat;
            bNewSharps = rNewEvent.m_bChordSharp;
        }
        else if (m_dwFragmentFlags & DMUS_FRAGMENTF_SCALE)
        {
            bOldFlats = rOldEvent.m_bScaleFlat;
            bOldSharps = rOldEvent.m_bScaleSharp;
            bNewFlats = rNewEvent.m_bScaleFlat;
            bNewSharps = rNewEvent.m_bScaleSharp;
        }
        else // something's wrong
        {
            hr = E_FAIL;
            break;
        }
        if (bOldFlats != bNewFlats && bOldSharps != bNewSharps)
        {
            hr = E_FAIL;
            break;
        }
    }
    return hr;
}

HRESULT MelodyFragment::GetRepeatedEvents(CompositionFragment& rfragmentRepeat,
                              DMUS_CHORD_PARAM& rCurrentChord, 
                              DMUS_CHORD_PARAM& rRealCurrentChord,
                              BYTE bPlaymode,
                              int nPartIndex,
                              DirectMusicPartRef& rPartRef,
                              TListItem<CompositionFragment>* pLastFragment,
                              MUSIC_TIME& rmtFirstNote,
                              TList<EventWrapper>& rEventList)
{
    HRESULT hr = E_FAIL;
    BYTE bMIDI = 0;
    TListItem<EventWrapper>* pOldEventHead;
    // For each transposition interval (unison is always the first interval tested):
    for (int i = 0; i < MAX_INTERVAL; i++)
    {
        if (SUCCEEDED(TransposeEventList(i, rfragmentRepeat, rCurrentChord, rRealCurrentChord, bPlaymode, rPartRef, pOldEventHead, rEventList, bMIDI, rmtFirstNote)))
        {
            // Test transposed notes against harmonic constraints
            if (SUCCEEDED(TestHarmonicConstraints(pOldEventHead, rEventList)))
            {
                // Test transposed notes against transition constraints (assuming there are any)
                // (note: eventually this test may be allowed to add transition notes as appropriate)

                // If there are no transition constraints, don't bother to test them.
                if (!pLastFragment || 
                    !pLastFragment->GetItemValue().UsesTransitionRules()) 
                {
                    hr = S_OK;
                    break;
                }

                if (S_OK == TestTransition(bMIDI, rmtFirstNote, rCurrentChord, nPartIndex, rPartRef, pLastFragment))
                {
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    // If no interval satisfies both constraints, fail.
    if (FAILED(hr)) rEventList.CleanUp();
    return hr;
}

// this should ensure, if possible, that the selected variations
// work for all chords from the current one to mtNext
HRESULT MelodyFragment::GetVariations(CompositionFragment& rCompFragment,
                          CompositionFragment& rfragmentRepeat,
                          CompositionFragment& rfragmentLast,
                          DMUS_CHORD_PARAM& rCurrentChord, 
                          DMUS_CHORD_PARAM& rNextChord,
                          MUSIC_TIME mtNextChord,
                          TListItem<CompositionFragment>* pLastFragment)
{
    DWORD* adwVariationMask = NULL;
    DWORD* adwRemoveVariations = NULL;
    static BYTE abVariationGroups[MAX_VARIATION_LOCKS];
    DWORD dwVariationFlags = 0;
    CDirectMusicPattern* pPattern = NULL;
    int i;

    if (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_REPEAT)
    {
        dwVariationFlags = rfragmentRepeat.GetVariationFlags();
        pPattern = rfragmentRepeat.m_pPattern;
        int nParts = rfragmentRepeat.m_pPattern->m_PartRefList.GetCount();
        adwVariationMask = new DWORD[nParts];
        adwRemoveVariations = new DWORD[nParts];
        if (!adwVariationMask || !adwRemoveVariations)
        {
            return E_OUTOFMEMORY;
        }
        for (i = 0; i < nParts; i++)
        {
            adwRemoveVariations[i] = 0;
        }
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_REJECT_REPEAT) 
        {
            // any variation but the one previously selected (for all parts)
            for (i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = dwVariationFlags ^ (1 << rfragmentLast.m_abVariations[i]);
            }
        }
        else
        {
            // only the variation previously selected (for all parts)
            for (i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = dwVariationFlags & (1 << rfragmentLast.m_abVariations[i]);
            }
        }
    }
    else
    {
        pPattern = rCompFragment.m_pPattern;
        int nParts = rCompFragment.m_pPattern->m_PartRefList.GetCount();
        adwVariationMask = new DWORD[nParts];
        if (!adwVariationMask)
        {
            return E_OUTOFMEMORY;
        }
        adwRemoveVariations = new DWORD[nParts];
        if (!adwRemoveVariations)
        {
            delete [] adwVariationMask;
            return E_OUTOFMEMORY;
        }
        for (i = 0; i < nParts; i++)
        {
            adwRemoveVariations[i] = 0;
        }
        if (m_dwFragmentFlags & DMUS_FRAGMENTF_USE_LABEL)
        {
            delete [] adwVariationMask;
            delete [] adwRemoveVariations;
            return E_NOTIMPL;
        }
        else
        {
            for (i = 0; i < nParts; i++)
            {
                adwVariationMask[i] = rCompFragment.GetVariationFlags();
            }
        }
    }
    // filter variations according to transition constraints
    if (pLastFragment && pLastFragment->GetItemValue().UsesTransitionRules())
    {
        TListItem<DirectMusicPartRef>* pPartRef = rCompFragment.m_pPattern->m_PartRefList.GetHead();
        for (i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            DWORD dwOriginalMask = adwVariationMask[i];
            //int nPart = pPartRef->GetItemValue().m_wLogicalPartID;
            for (int nVar = 0; nVar < 32; nVar++)
            {
                if ( adwVariationMask[i] & (1 << nVar) )
                {
                    // get the first note of the variation
                    BYTE bMIDI = 0;
                    MUSIC_TIME mtNote = 0;
                    HRESULT hrFirst = GetFirstNote(nVar, rCurrentChord, rCompFragment, pPartRef->GetItemValue(), bMIDI, mtNote);
        
                    // if this variation doesn't meet the constraints, remove it from the mask
                    if ( SUCCEEDED(hrFirst) &&
                         S_OK != TestTransition(bMIDI, mtNote, rCurrentChord, i, pPartRef->GetItemValue(), pLastFragment) )
                    {
                        adwVariationMask[i] &= ~(1 << nVar);
                    }    
                }
            }
            // If none of the variations meet all the constraints, fall back to the original mask
            if (!adwVariationMask[i]) adwVariationMask[i] = dwOriginalMask;
        }
    }
    DWORD dwFlags = (COMPUTE_VARIATIONSF_USE_MASK | COMPUTE_VARIATIONSF_NEW_PATTERN | COMPUTE_VARIATIONSF_DX8);
    HRESULT hr = pPattern->ComputeVariations(dwFlags,
                                rCurrentChord,
                                rNextChord,
                                abVariationGroups,
                                adwVariationMask,
                                adwRemoveVariations,
                                rCompFragment.m_abVariations,
                                m_mtTime, 
                                mtNextChord);
    if (adwVariationMask) delete [] adwVariationMask;
    if (adwRemoveVariations) delete [] adwRemoveVariations;
    return hr;
}

HRESULT MelodyFragment::GetFirstNote(int nVariation,
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             CompositionFragment& rCompFragment,
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi,
                             MUSIC_TIME& rmtNote)
{
    HRESULT hr = S_OK;
    DirectMusicPart* pPart = rPartRef.m_pDMPart;
    DirectMusicTimeSig& TimeSig = rCompFragment.GetTimeSig(pPart);
    CDirectMusicEventItem* pEvent = pPart->EventList.GetHead();
    bool fFoundNote = false;
    for (; pEvent; pEvent = pEvent->GetNext())
    {
        if ( pEvent->m_dwVariation & (1 << nVariation) )
        {
            if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE)
            {
                MUSIC_TIME mtNow = GetTime() +
                    TimeSig.GridToClocks(pEvent->m_nGridStart) + pEvent->m_nTimeOffset;
                if (!fFoundNote || mtNow < rmtNote)
                {
                    hr = GetNote(pEvent, rCurrentChord, rPartRef, rbMidi);
                    if (SUCCEEDED(hr))
                    {
                        fFoundNote = true;
                        rmtNote = mtNow;
                    }
                }
            }
        }
    }
    if (!fFoundNote) hr = S_FALSE;
    return hr;
}

HRESULT MelodyFragment::GetNote(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DirectMusicPartRef& rPartRef,
                             BYTE& rbMidi)
{
    HRESULT hr = S_OK;
    // only process note events
    CDMStyleNote* pNoteEvent = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
    {
        pNoteEvent = (CDMStyleNote*)pEvent;
        // get a playmode (either from the note or from the melody fragment)
        BYTE bPlaymode = (BYTE) m_dwPlayModeFlags;
        short nMidiOffset = 0;
        if (bPlaymode == DMUS_PLAYMODE_NONE)
        {
            bPlaymode =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;   
        }
        // generate a MIDI value from the melody note, fragment, chord, and playmode
        hr = rPartRef.ConvertMusicValue(pNoteEvent, 
                                      rCurrentChord,
                                      bPlaymode,
                                      FALSE,
                                      m_aInversionGroups,
                                      NULL,
                                      rbMidi,
                                      nMidiOffset);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT MelodyFragment::GetEvent(CDirectMusicEventItem* pEvent, 
                             DMUS_CHORD_PARAM& rCurrentChord, 
                             DMUS_CHORD_PARAM& rRealCurrentChord, 
                             MUSIC_TIME mtNow, 
                             DirectMusicPartRef& rPartRef,
                             TListItem<EventWrapper>*& rpEventItem)
{
    DWORD dwScale = ShiftScale(rCurrentChord.dwScale, rCurrentChord.bKey);
    DWORD dwChord = ShiftScale(rCurrentChord.SubChordList[0].dwChordPattern, rCurrentChord.SubChordList[0].bChordRoot);
    HRESULT hr = S_OK;
    // only process note events
    CDMStyleNote* pNoteEvent = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
    {
        pNoteEvent = (CDMStyleNote*)pEvent;
        // get a playmode (either from the note or from the melody fragment)
        BYTE bPlaymode = (BYTE) m_dwPlayModeFlags;
        BYTE bMIDI = 0;
        WORD wMusic = 0;
        short nMidiOffset = 0;
        if (bPlaymode == DMUS_PLAYMODE_NONE)
        {
            bPlaymode =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;   
        }
        // generate a MIDI value from the melody note, fragment, chord, and playmode
        HRESULT hrTest = rPartRef.ConvertMusicValue(pNoteEvent, 
                                      rCurrentChord,
                                      bPlaymode,
                                      FALSE,
                                      m_aInversionGroups,
                                      NULL,
                                      bMIDI,
                                      nMidiOffset);
        if (SUCCEEDED(hrTest))
        {
            hrTest = rPartRef.ConvertMIDIValue(bMIDI, 
                                      rRealCurrentChord,
                                      bPlaymode,
                                      NULL,
                                      wMusic);
        }
        if (FAILED(hrTest)) hr = hrTest;
        else
        {
            rpEventItem = new TListItem<EventWrapper>;
            if (!rpEventItem) hr = E_OUTOFMEMORY;
            else
            {
                EventWrapper& rEvent = rpEventItem->GetItemValue();
                rEvent.m_mtTime = mtNow - pNoteEvent->m_nTimeOffset; // remove the offset (it's in m_nTimeOffset)
                rEvent.m_bMIDI = bMIDI;
                BYTE bTone = (BYTE) (bMIDI % 12);
                ScaleMisses(bTone, dwScale, rEvent.m_bScaleFlat, rEvent.m_bScaleSharp); 
                ScaleMisses(bTone, dwChord, rEvent.m_bChordFlat, rEvent.m_bChordSharp); 
                rEvent.m_wMusic = wMusic;
                rEvent.m_pEvent = pNoteEvent;
                rEvent.m_dwPChannel = rPartRef.m_dwLogicalPartID;
                rEvent.m_bPlaymode = bPlaymode;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CMelodyFormulationTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CMelodyFormulationTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(Compose)

    V_INTERFACE(pContext);
    V_PTRPTR_WRITE(ppResultTrack);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    HRESULT hr = S_OK;
    IDirectMusicTrack* pPatternTrack = NULL;
    IDirectMusicStyle* pStyle = NULL;
    IDMStyle* pDMStyle = NULL;
    MUSIC_TIME mtLength = 0;

    IDirectMusicSegment* pTempSeg = NULL;
    IDirectMusicSong* pSong = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pTempSeg)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hr = E_INVALIDARG;
            goto ON_END;
        }
    }

    if (pTempSeg)
    {
        if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle))) goto ON_END;
        if (FAILED(hr = pTempSeg->GetLength(&mtLength))) goto ON_END;
    }
    else if (pSong)
    {
        MUSIC_TIME mtNow = 0;
        MUSIC_TIME mtNext = 0;
        while (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, mtNow, &mtNext, (void*)&pStyle)))
        {
            if (mtNext <= 0) goto ON_END;
            mtNow = mtNext;
        }
        //if (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle))) goto ON_END;
        IDirectMusicSegment* pSeg = NULL;
        DWORD dwSeg = 0;
        while (S_OK == hr)
        {
            if (FAILED(hr = pSong->EnumSegment(dwSeg, &pSeg))) goto ON_END;
            if (hr == S_OK)
            {
                MUSIC_TIME mt = 0;
                hr = pSeg->GetLength(&mt);
                if (FAILED(hr)) goto ON_END;
                mtLength += mt;
                pSeg->Release();
                pSeg = NULL;
                dwSeg++;
            }
        }
    }

    // Using chord track, style, and melgen track, create a pattern track
    hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pDMStyle);
    if (SUCCEEDED(hr))
    {
        hr = pDMStyle->GenerateTrack(pTempSeg, pSong, dwTrackGroup, pStyle, this, mtLength, pPatternTrack);
        if (SUCCEEDED(hr))
        {
            *ppResultTrack = pPatternTrack;
        }
        pDMStyle->Release();
    }

ON_END:
    // Release from Addref in GetStyle
    if (pStyle) pStyle->Release();
    if (pSong) pSong->Release();
    if (pTempSeg) pTempSeg->Release();

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

// if ppResultTrack is NULL, add pNewTrack to the end of the current track;
// otherwise, create a copy of the current track and add pNewTrack to the end of the copy.
// The new track starts at mtJoin, so get rid of everything before that in the current
// track (or its clone).  If cloning, simply clone to mtJoin.
STDMETHODIMP CMelodyFormulationTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    TList<DMUS_MELODY_FRAGMENT> ResultList;
    CMelodyFormulationTrack* pResultTrack = NULL;
    DWORD dwMaxID = 0;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CMelodyFormulationTrack*)*ppResultTrack;
        while(!pResultTrack->m_FragmentList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_FragmentList.RemoveHead());
            DWORD dwThis = ResultList.GetHead()->GetItemValue().dwID;
            if (dwThis > dwMaxID) dwMaxID = dwThis;
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_FragmentList.IsEmpty() && 
              m_FragmentList.GetHead()->GetItemValue().mtTime < mtJoin)
        {
            ResultList.AddHead(m_FragmentList.RemoveHead());
            DWORD dwThis = ResultList.GetHead()->GetItemValue().dwID;
            if (dwThis > dwMaxID) dwMaxID = dwThis;
        }
        m_FragmentList.CleanUp();
    }
    CMelodyFormulationTrack* pOtherTrack = (CMelodyFormulationTrack*)pNewTrack;
    TListItem<DMUS_MELODY_FRAGMENT>* pScan = pOtherTrack->m_FragmentList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMUS_MELODY_FRAGMENT>* pNew = new TListItem<DMUS_MELODY_FRAGMENT>(pScan->GetItemValue());
        if (pNew)
        {
            DMUS_MELODY_FRAGMENT& rNew = pNew->GetItemValue();
            rNew.mtTime += mtJoin;
            rNew.dwID += dwMaxID;
            if (rNew.dwRepeatFragmentID &&
                (rNew.dwFragmentFlags & (DMUS_FRAGMENTF_USE_REPEAT | DMUS_FRAGMENTF_REJECT_REPEAT)) )
            {
                rNew.dwRepeatFragmentID += dwMaxID;
            }

            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_FragmentList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_FragmentList.AddHead(ResultList.RemoveHead());
        }
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\sjdefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjdefs.h
//
//--------------------------------------------------------------------------

#ifndef __SJ_DEFINES_H__
#define __SJ_DEFINES_H__

//#define DEFAULT_STYLE_PATH "\\multim~1\\music\\intera~1\\"

// Score defines

#define VNUM        16  // Total number of variations
#define LAST_INSTR  5   // Total number of displayed instr minus 1
#define MAX_OUTS    6   // Max MIDI out devices supported

#define EDITMODES           3
#define MODE_ALLCHORDS      4
#define MODE_FATCHORDS      8

#define BAND_NAME_SIZE      15
#define SECTION_NAME_SIZE   15
#define SONG_NAME_SIZE      20
#define FILTER_SIZE         40
#define TITLE_SIZE          60
#define SMALLEST_OFFSET     96
#define ERRORTEXT_SIZE      100
#define FILENAME_SIZE       256
#define FILENAMES_SIZE      512

#define BUFFER_SIZE     400

#define EVENT_FREED     0x35
#define EVENT_REMOVE    0x5A
#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

#define FROM_MIDIINPUT  2       // MIDI input
#define DEST_MSG        3       // Post message to app
#define DEST_MIDIOUT    4       // Routed to MIDI mapper
#define DEST_COMPOSER   5       // Routed to composition code
#define DEST_TEMPO      6       // Routed to tempo change code
#define DEST_VOLUME     7       // Routed to volume change code
#define DEST_RTEMPO     8       // Routed to relative tempo change code
#define DEST_RVOLUME    9       // Routed to relative volume change code
#define DEST_REMOVE     10      // Routed to remove code (freeevent)
#define DEST_METRONOME  11      // Routed to metronome code
#define DEST_ENDMOTIF   12      // ends a motif and frees its channels in use
#define DEST_MIDIFILE   13      // Source was a MIDI file, convert to DEST_MIDIOUT

#define NB_OFFSET   0x3     // Offset note up to 7 clicks early

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


#define C_FILL      1       // Do a fill
#define C_INTRO     2       // Do an intro
#define C_BREAK     3       // Do a drum break
#define C_END       4       // End the song

//#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
//#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32


// Section Flags
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

// chord types for use by each instrument in a pattern
// Chord types for use by each instrument in a pattern
enum
{ 
	CHTYPE_NOTINITIALIZED = 0,
	CHTYPE_DRUM,		// superceded by CHTYPE_FIXED
					// no longer in Note Dialog's combo box selections
					// no longer in Pattern Dialog's combo box selections
	CHTYPE_BASS,		// scale + lower chord
	CHTYPE_UPPER,		// scale + upper chord
	CHTYPE_SCALEONLY, 	// scale, no chord
	CHTYPE_BASSMELODIC,
	CHTYPE_UPPERMELODIC,
	CHTYPE_NONE,		// Ignored on Pattern Dialog's menu selections.
	CHTYPE_FIXED
};

#define VF_SCALE        0x7F    // Seven positions in the scale
#define VF_ACCIDENTAL   0x80    // Handles chords outside of scale
#define VF_MAJOR        0x100   // Handles major chords
#define VF_MINOR        0x200   // Handles minor chords
#define VF_ALL          0x400   // Handles all chord types
#define VF_TO1          0x800   // Handles transitions to 1 chord
#define VF_TO5          0x1000  // Handles transitions to 5 chord
#define VF_SIMPLE       0x2000  // handles simple chords
#define VF_COMPLEX      0x4000  // handles complex chords

// this expects a voiceid from 1-16
#define VOICEID_TO_CHANNEL( id ) ((DWORD) ( ( id + 3 ) & 0xf ))

#pragma pack()

#endif // __SJ_DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmstyle$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

!if $(USE_VC7)
ENABLE_LINK_TIME_CODE_GENERATION=0
!endif

TARGETPATH = ..\..\obj
TARGETTYPE=LIBRARY
UMTYPE=xboxdll
DLLDEF=dmstyle.def
DLLENTRY=DllMain
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2 -D_MT -DXBOX -DUNICODE

INCLUDES=$(INCLUDES);   \
    $(BASEDIR)\public\sdk\inc;\
    $(BASEDIR)\private\inc;\
    ..\..\shared;\
    ..\..\xprivate;\
    ..

SOURCES=\
chordtrk.cpp                \
cmmdtrk.cpp                 \
dmsect.cpp                  \
dmstydll.cpp                \
dmstyle.cpp                 \
motiftrk.cpp                \
ptrntrk.cpp                 \
styletrk.cpp                \
audtrk.cpp                  \
mutetrk.cpp                 \
dmstyle2.cpp                \
filter.cpp                  \
mgentrk.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\motiftrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       motiftrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// MotifTrk.cpp : Implementation of CMotifTrack
//#include "stdafx.h"
//#include "Section.h"
#include "MotifTrk.h"
#include <stdlib.h> // for random number generator
#include <time.h>	// to seed random number generator
#include "debug.h"
#include "dmusicip.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "..\shared\miscutil.h"
#include "..\shared\critsec.h"

/////////////////////////////////////////////////////////////////////////////
// MotifTrackState

MotifTrackState::MotifTrackState() : 
	m_mtMotifStart(0)
{
}

MotifTrackState::~MotifTrackState()
{
}

HRESULT MotifTrackState::Play(
				  MUSIC_TIME				mtStart, 
				  MUSIC_TIME				mtEnd, 
				  MUSIC_TIME				mtOffset,
				  REFERENCE_TIME rtOffset,
				  IDirectMusicPerformance* pPerformance,
				  DWORD						dwFlags,
				  BOOL fClockTime
			)
{
	m_mtPerformanceOffset = mtOffset;
	BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
	BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
	BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
	if (fControl) // We need to make sure we get chords on beat boundaries
	{
		GetNextChord(mtStart, mtOffset, pPerformance, fStart);
	}
	MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
	if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
		( mtNotify < mtEnd ) )
	{
		mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
	}

	bool fReLoop = false;
	DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
	if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
	if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
	if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fControl)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
	PlayParts(mtStart, mtEnd, mtOffset, rtOffset, 0, pPerformance, dwPartFlags, dwFlags, fReLoop);

	if (fReLoop)
	{
		dwPartFlags = PLAYPARTSF_RELOOP;
		if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
		PlayParts(mtStart, mtEnd, mtOffset, rtOffset, 0, pPerformance, dwPartFlags, dwFlags, fReLoop);
	}

	if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat &&  !fClockTime &&
		( mtNotify < mtEnd ) )
	{
		NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// MotifTrackInfo

MotifTrackInfo::MotifTrackInfo() : 
	m_pPattern(NULL)
{
	m_dwPatternTag = DMUS_PATTERN_MOTIF;
}

MotifTrackInfo::~MotifTrackInfo()
{
	if (m_pPattern) m_pPattern->Release();
}

HRESULT MotifTrackInfo::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	return S_OK;
}

HRESULT MotifTrackInfo::InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	IDirectMusicSegment* pSegment = NULL;
	MotifTrackState* pStateData = new MotifTrackState;
	if( NULL == pStateData )
	{
		return E_OUTOFMEMORY;
	}
	*ppStateData = pStateData;
	StatePair SP(pSegmentState, pStateData);
	TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
	if (!pPair) return E_OUTOFMEMORY;
	m_StateList.AddHead(pPair);
	TListItem<StylePair>* pHead = m_pISList.GetHead();
	if (!pHead || !pHead->GetItemValue().m_pStyle) return E_FAIL;
	pHead->GetItemValue().m_pStyle->GetStyleInfo((void **)&pStateData->m_pStyle);
	pStateData->m_pTrack = pParentrack;
	pStateData->m_pPatternTrack = this;
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPattern = NULL;
	pStateData->InitPattern(m_pPattern, 0);
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_mtPerformanceOffset = 0;
	pStateData->m_mtCurrentChordTime = 0;
	pStateData->m_mtNextChordTime = 0;
 	pStateData->m_mtMotifStart = 0;
	HRESULT hr = pStateData->ResetMappings();
	if (FAILED(hr)) return hr;
#ifdef DXAPI
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
#endif
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	if (m_lRandomNumberSeed)
	{
		pStateData->InitVariationSeeds(m_lRandomNumberSeed);
	}
	if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
	{
		if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
		{
			pStateData->m_dwGroupID = 0xffffffff;
		}
		pSegment->Release();
	}
	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CMotifTrack

CMotifTrack::CMotifTrack() : 
	m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
	IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	dm_srand((unsigned int)time(NULL));
	m_pTrackInfo = new MotifTrackInfo;
}

CMotifTrack::CMotifTrack(const CMotifTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
	m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
	IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	dm_srand((unsigned int)time(NULL));
	m_pTrackInfo = new MotifTrackInfo((MotifTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CMotifTrack::~CMotifTrack()
{
	if (m_pTrackInfo)
	{
		delete m_pTrackInfo;
	}
    if (m_fCSInitialized)
    {
    	DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
	DecrementDLLCount();
}

STDMETHODIMP CMotifTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CMotifTrack::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else if (iid == IID_IMotifTrack)
    {
        *ppv = static_cast<IMotifTrack*>(this);
    }
	else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMotifTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMotifTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CMotifTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
	V_INAME(CMotifTrack::Init);
	V_INTERFACE(pSegment);

	HRESULT hr = S_OK;
	if (!m_pTrackInfo)
		return DMUS_E_NOT_INIT;

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	hr = m_pTrackInfo->MergePChannels();
	if (SUCCEEDED(hr))
	{
		pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
		hr = m_pTrackInfo->Init(pSegment);
	}
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

	return hr;
}

HRESULT CMotifTrack::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	V_INAME(CMotifTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	HRESULT hr = S_OK;
	if (!m_pTrackInfo)
	{
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;

}


HRESULT CMotifTrack::EndPlay(
				/*[in]*/  void*		pStateData
			)
{
	V_INAME(CMotifTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(MotifTrackState));

	HRESULT hr = DMUS_E_NOT_INIT;

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (m_pTrackInfo)
	{
		hr = m_pTrackInfo->EndPlay((MotifTrackState*)pStateData);
	}
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT CMotifTrack::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID,
						  BOOL fClockTime
				)
{
	V_INAME(CMotifTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(MotifTrackState));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegState);

	HRESULT hr = DMUS_E_NOT_INIT;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	MotifTrackState* pSD = (MotifTrackState *)pStateData;
	if (pSD && pSD->m_pMappings)
	{
		BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
		BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
		BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
		BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
 		if (fStart || fSeek || fLoop || fControl)
		{
			pSD->m_fNewPattern = TRUE;
			pSD->m_mtCurrentChordTime = 0;
			pSD->m_mtNextChordTime = 0;
			pSD->m_mtLaterChordTime = 0;
//			pSD->m_CurrentChord.bSubChordCount = 0;
			for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
			{
				pSD->m_pMappings[dw].m_mtTime = 0;
				pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
				pSD->m_pMappings[dw].m_fMute = FALSE;
			}
		}
		hr = pSD->Play(mtStart, mtEnd, mtOffset, rtOffset, pPerf, dwFlags, fClockTime);
	}
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}


HRESULT CMotifTrack::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CMotifTrack::GetParam( 
	REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMotifTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_PTR_WRITE(pData,1);
	V_REFGUID(rCommandGuid);

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	HRESULT hr = S_OK;
	if( GUID_Valid_Start_Time == rCommandGuid )
	{
		if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_MOTIF) hr = E_FAIL;
		else
		{
			MotifTrackInfo* pTrackInfo = (MotifTrackInfo*)m_pTrackInfo;
			if (!pTrackInfo->m_pPattern) hr = E_POINTER;
			else
			{
				DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
				TListItem<MUSIC_TIME>* pScan = pTrackInfo->m_pPattern->m_StartTimeList.GetHead();
				for (; pScan; pScan = pScan->GetNext())
				{
					if (pScan->GetItemValue() >= mtTime)
					{
						pValidStartData->mtTime = pScan->GetItemValue() - mtTime;
						break;
					}
				}
				if (!pScan) hr = DMUS_E_NOT_FOUND;
				else
				{
					if (pmtNext)
					{
						if (pScan = pScan->GetNext())
						{
							*pmtNext = pScan->GetItemValue() - mtTime;
						}
						else
						{
							*pmtNext = 0;
						}
					}
					hr = S_OK;
				}
			}
		}
	}
	else
	{
		hr = DMUS_E_GET_UNSUPPORTED;
	}

	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
} 

HRESULT CMotifTrack::SetParam( 
	REFGUID	rguid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	V_INAME(CMotifTrack::SetParam);
	V_PTR_WRITE_OPT(pData,1);
	V_REFGUID(rguid);

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}

	HRESULT hr = DMUS_E_SET_UNSUPPORTED;
#ifdef DXAPI
	if( rguid == GUID_EnableTimeSig )
	{
		if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
		else
		{
			m_pTrackInfo->m_fStateSetBySetParam = TRUE;
			m_pTrackInfo->m_fActive = TRUE;
			hr = S_OK;
		}
	}
	else if( rguid == GUID_DisableTimeSig )
	{
		if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
		else
		{
			m_pTrackInfo->m_fStateSetBySetParam = TRUE;
			m_pTrackInfo->m_fActive = FALSE;
			hr = S_OK;
		}
	}
	else if ( rguid == GUID_SeedVariations )
	{
		if (pData)
		{
			m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
			hr = S_OK;
		}
		else hr = E_POINTER;
	}
#endif
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

// IPersist methods
 HRESULT CMotifTrack::GetClassID( LPCLSID pClassID )
{
	V_INAME(CMotifTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMotifTrack;
	return S_OK;
}

HRESULT CMotifTrack::IsParamSupported(
				/*[in]*/ REFGUID	rGuid
			)
{
	V_INAME(CMotifTrack::IsParamSupported);
	V_REFGUID(rGuid);

	if (!m_pTrackInfo)
	{
		return DMUS_E_NOT_INIT;
	}

	if ( rGuid == GUID_Valid_Start_Time )
	{
		return S_OK;
	}
	else if ( rGuid == GUID_SeedVariations )
	{
		return S_OK;
	}
#ifdef DXAPI
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
		if( m_pTrackInfo->m_fActive )
		{
			if( rGuid == GUID_DisableTimeSig ) return S_OK;
			if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
		}
		else
		{
			if( rGuid == GUID_EnableTimeSig ) return S_OK;
			if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
		}
	}
    else
    {
		if(( rGuid == GUID_DisableTimeSig ) ||
		   ( rGuid == GUID_EnableTimeSig ) )
		{
			return S_OK;
		}
    }
#endif
	return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CMotifTrack::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CMotifTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

	return E_NOTIMPL;
}

HRESULT CMotifTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CMotifTrack::Load(LPSTREAM pStream )
{
	return E_NOTIMPL;
}

HRESULT CMotifTrack::SetTrack(IUnknown* pStyle, void* pPattern)
{
	if (!pStyle) return E_POINTER;
	HRESULT hr = E_FAIL;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (!m_pTrackInfo)
	{
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
		return DMUS_E_NOT_INIT;
	}
	MotifTrackInfo* pTrackInfo = (MotifTrackInfo*)m_pTrackInfo;
	if (m_pTrackInfo->m_dwPatternTag == DMUS_PATTERN_MOTIF)
	{
		IDMStyle* pIS = NULL;
		hr = pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
		if (SUCCEEDED(hr))
		{
			if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->Release();
			pTrackInfo->m_pPattern = (CDirectMusicPattern*) pPattern;
			if (pTrackInfo->m_pPattern) pTrackInfo->m_pPattern->AddRef();
			pTrackInfo->InitTrackVariations(pTrackInfo->m_pPattern);
			TListItem<StylePair>* pNew = new TListItem<StylePair>;
			if (!pNew) hr = E_OUTOFMEMORY;
			else
			{
				pNew->GetItemValue().m_mtTime = 0;
				pNew->GetItemValue().m_pStyle = pIS;
				pTrackInfo->m_pISList.AddTail(pNew);
				hr = S_OK;
			}
			pIS->Release();
		}
	}
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::AddNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	V_INAME(CMotifTrack::AddNotificationType);
	V_REFGUID(rGuidNotify);

	HRESULT hr = S_OK;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (m_pTrackInfo)
		hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
	else
		hr = DMUS_E_NOT_INIT;
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::RemoveNotificationType(
	/* [in] */  REFGUID	rGuidNotify)
{
	V_INAME(CMotifTrack::RemoveNotificationType);
	V_REFGUID(rGuidNotify);

	HRESULT hr = S_OK;
	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (m_pTrackInfo)
		hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
	else
		hr = DMUS_E_NOT_INIT;
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CMotifTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CMotifTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CMotifTrack *pDM;
    try
    {
        pDM = new CMotifTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

STDMETHODIMP CMotifTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CMotifTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
	return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

STDMETHODIMP CMotifTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CMotifTrack::Play( 
    void *pStateData,	// @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,	// @parm The start time to play.
    MUSIC_TIME mtEnd,	// @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
						// <om IDirectMusicPerformance.SendPMsg>.
	DWORD dwFlags,		// @parm Flags that indicate the state of this call.
						// See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
						// normal Play call continuing playback from the previous
						// Play call.
	IDirectMusicPerformance* pPerf,	// @parm The <i IDirectMusicPerformance>, used to
						// call <om IDirectMusicPerformance.AllocPMsg>,
						// <om IDirectMusicPerformance.SendPMsg>, etc.
	IDirectMusicSegmentState* pSegSt,	// @parm The <i IDirectMusicSegmentState> this
						// track belongs to. QueryInterface() can be called on this to
						// obtain the SegmentState's <i IDirectMusicGraph> in order to
						// call <om IDirectMusicGraph.StampPMsg>, for instance.
	DWORD dwVirtualID	// @parm This track's virtual track id, which must be set
						// on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
						// will be queued to <om IDirectMusicPerformance.SendPMsg>.
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CMotifTrack::Compose(
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CMotifTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\timesig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       timesig.h
//
//--------------------------------------------------------------------------

// TimeSig.h : time signature stuff
#ifndef __TIME_CONVERT__
#define __TIME_CONVERT__
#include "dmusicip.h"
#include "dmusicf.h"
#include "score.h"
#include "debug.h"

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }

	DirectMusicTimeSig(BYTE bBPM, BYTE bBeat, WORD wGPB) : 
		m_bBeatsPerMeasure(bBPM), 
		m_bBeat(bBeat),
		m_wGridsPerBeat(wGPB) 
	{ }

	DirectMusicTimeSig(DMUS_TIMESIGNATURE& TSE) : 
		m_bBeatsPerMeasure(TSE.bBeatsPerMeasure), 
		m_bBeat(TSE.bBeat), 
		m_wGridsPerBeat(TSE.wGridsPerBeat) 
	{ }

	operator DMUS_TIMESIGNATURE()
	{
		DMUS_TIMESIGNATURE TSE;
		TSE.bBeatsPerMeasure = m_bBeatsPerMeasure; 
		TSE.bBeat = m_bBeat;
		TSE.wGridsPerBeat = m_wGridsPerBeat; 
		TSE.mtTime = 0;
		return TSE;
	}

	MUSIC_TIME ClocksPerBeat()
	{	
		if (m_bBeat)
		{
			return DMUS_PPQ * 4 / m_bBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME FloorBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat || mtTime < mtOneBeat) ? 0 : (mtTime - (mtTime % mtOneBeat));
	}

	MUSIC_TIME CeilingBeat(MUSIC_TIME mtTime)
	{	return OnBeat(mtTime) ? mtTime : (FloorBeat(mtTime) + ClocksPerBeat());
	}

	BOOL OnBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat) ? FALSE : !(mtTime % mtOneBeat);
	}

	MUSIC_TIME GridsToMeasure(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) / m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridsToBeat(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) % m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridOffset(WORD wGrid)
	{	
		if (m_wGridsPerBeat)
		{
			return wGrid - ((wGrid / m_wGridsPerBeat) * m_wGridsPerBeat);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerGrid()
	{
		if (m_wGridsPerBeat)
		{
			return ClocksPerBeat() / m_wGridsPerBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerMeasure()
	{ 
		return ClocksPerBeat() * m_bBeatsPerMeasure;
	}

	MUSIC_TIME ClocksToMeasure(DWORD dwTotalClocks)
	{ 
		MUSIC_TIME mtCPM = ClocksPerMeasure();
		if (mtCPM)
		{
			return (dwTotalClocks / mtCPM);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksToBeat(DWORD dwTotalClocks)
	{
		MUSIC_TIME mtCPB = ClocksPerBeat();
		if (mtCPB)
		{
			return dwTotalClocks / mtCPB;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME MeasureAndBeatToClocks(WORD wMeasure, BYTE bBeat)
	{ 
		return ClocksPerMeasure() * wMeasure + (ClocksPerBeat() * bBeat);
	}

	MUSIC_TIME GridToClocks(WORD wGrid)
	{
		if (m_wGridsPerBeat)
		{
			return (ClocksPerBeat() * (wGrid / m_wGridsPerBeat)) + (ClocksPerGrid() * (wGrid % m_wGridsPerBeat));
		}
		else
		{
			return ClocksPerGrid() * wGrid;
		}
	}

	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};

// Convert old clocks to new clocks
template <class T>
inline T ConvertTime(T oldTime)
{ return (T)((DMUS_PPQ / PPQN) * oldTime); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\ptrntrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       ptrntrk.cpp
//
//--------------------------------------------------------------------------

// PtrnTrk.cpp : Implementation of the Pattern Track info and state structs

#include "PtrnTrk.h"
#include "..\shared\miscutil.h"

#include "dmusicip.h"
#include "dmusicf.h"

#include "debug.h"

/////////////////////////////////////////////////////////////////////////////
// PatternTrackState

PatternTrackState::PatternTrackState() : 
    m_pStyle(NULL), 
    m_pSegState(NULL),
    m_pPerformance(NULL),
    m_mtPerformanceOffset(0),
    m_dwVirtualTrackID(0),
    m_pPatternTrack(NULL),
    m_pTrack(NULL),
    m_mtCurrentChordTime(0),
    m_mtNextChordTime(0),
    m_mtLaterChordTime(0),
    m_pPattern(NULL),
    m_pdwPChannels(NULL),
    m_pVariations(NULL),
    m_pdwVariationMask(NULL),
    m_pdwRemoveVariations(NULL),
    m_pmtPartOffset(NULL),
    m_nInversionGroupCount(0),
    m_fNewPattern(TRUE),
    m_fStateActive(TRUE),
//  m_fStatePlay(TRUE),
    m_pMappings(NULL),
    m_ppEventSeek(NULL),
    m_dwGroupID(0xffffffff),
    m_plVariationSeeds(NULL),
    m_nTotalGenerators(0),
    m_mtPatternStart(0),
    m_dwValidate(0),
    m_hrPlayCode(S_OK),
    m_pfChangedVariation(NULL)
{
    ZeroMemory(&m_NextChord, sizeof(DMUS_CHORD_PARAM));
    wcscpy(m_CurrentChord.wszName, L"M7");
    m_CurrentChord.wMeasure = 0;
    m_CurrentChord.bBeat = 0;
    m_CurrentChord.bSubChordCount = 1;
    m_CurrentChord.bKey = 12;
    m_CurrentChord.dwScale = DEFAULT_SCALE_PATTERN;
    m_CurrentChord.bFlags = 0;
    for (int n = 0; n < DMUS_MAXSUBCHORD; n++)
    {
        m_CurrentChord.SubChordList[n].dwChordPattern = DEFAULT_CHORD_PATTERN;
        m_CurrentChord.SubChordList[n].dwScalePattern = DEFAULT_SCALE_PATTERN;
        m_CurrentChord.SubChordList[n].dwInversionPoints = 0xffffff;
        m_CurrentChord.SubChordList[n].dwLevels = 0xffffffff;
        m_CurrentChord.SubChordList[n].bChordRoot = 12; // 2C
        m_CurrentChord.SubChordList[n].bScaleRoot = 0;
    }
    for (int i = 0; i < INVERSIONGROUPLIMIT; i++)
        m_aInversionGroups[i].m_wGroupID = 0;
}


PatternTrackState::~PatternTrackState()
{
    if (m_pmtPartOffset)
        delete [] m_pmtPartOffset;
    if (m_pdwPChannels) 
        delete [] m_pdwPChannels;
    if (m_pVariations)
        delete [] m_pVariations;
    if (m_pdwVariationMask)
        delete [] m_pdwVariationMask;
    if (m_pdwRemoveVariations)
        delete [] m_pdwRemoveVariations;
    if (m_pMappings) delete [] m_pMappings;
    if (m_ppEventSeek) delete [] m_ppEventSeek;
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    if (m_pPattern) m_pPattern->Release();
    if (m_pfChangedVariation)
    {
        delete [] m_pfChangedVariation;
    }
}


HRESULT PatternTrackState::InitPattern(CDirectMusicPattern* pTargetPattern, MUSIC_TIME mtNow, CDirectMusicPattern* pOldPattern)
{
    m_fNewPattern = TRUE;
    m_mtPatternStart = mtNow;
    short nPartCount = (short) pTargetPattern->m_PartRefList.GetCount();
    // initialize an array to keep track of variations in parts.
    // if the current pattern is the same as the previous pattern,
    // use the existing array.
    if (m_pPattern != pTargetPattern || pOldPattern)
    {
        ////////////////// create an array of variation bools //////////////////
        if (m_pfChangedVariation) delete [] m_pfChangedVariation;
        m_pfChangedVariation = new bool[nPartCount];
        if (!m_pfChangedVariation)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create an array of part offsets //////////////////
        if (m_pmtPartOffset != NULL) delete [] m_pmtPartOffset;
        m_pmtPartOffset = new MUSIC_TIME[nPartCount];
        if (!m_pmtPartOffset)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create an array of seek pointers //////////////////
        if (m_ppEventSeek) delete [] m_ppEventSeek;
        m_ppEventSeek = new CDirectMusicEventItem*[nPartCount];
        if (!m_ppEventSeek)
        {
            return E_OUTOFMEMORY;
        }
        ////////////////// create and initialize PChannels //////////////////
        if (m_pdwPChannels != NULL) delete [] m_pdwPChannels;
        m_pdwPChannels = new DWORD[nPartCount];
        if (!m_pdwPChannels)
        {
            return E_OUTOFMEMORY;
        }
        TListItem<DirectMusicPartRef>* pPartRef = pTargetPattern->m_PartRefList.GetHead();
        for (int i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
        {
            m_pdwPChannels[i] = pPartRef->GetItemValue().m_dwLogicalPartID;
        }
        if (!pOldPattern ||
            pTargetPattern->m_strName != pOldPattern->m_strName ||
            nPartCount != pOldPattern->m_PartRefList.GetCount() )
        {
            ////////////////// create and initialize variations //////////////////
            if (m_pVariations != NULL) delete [] m_pVariations;
            m_pVariations = new BYTE[nPartCount];
            if (!m_pVariations)
            {
                return E_OUTOFMEMORY;
            }
            if (m_pdwVariationMask != NULL) delete [] m_pdwVariationMask;
            m_pdwVariationMask = new DWORD[nPartCount];
            if (!m_pdwVariationMask)
            {
                return E_OUTOFMEMORY;
            }
            if (m_pdwRemoveVariations != NULL) delete [] m_pdwRemoveVariations;
            m_pdwRemoveVariations = new DWORD[nPartCount];
            if (!m_pdwRemoveVariations)
            {
                return E_OUTOFMEMORY;
            }
            for (int i = 0; i < nPartCount; i++)
            {
                m_pdwVariationMask[i] = 0;
                if ( (pTargetPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
                     m_pPatternTrack &&
                     m_pPatternTrack->m_pVariations &&
                     m_pPatternTrack->m_pdwRemoveVariations )
                {
                    m_pVariations[i] = m_pPatternTrack->m_pVariations[i];
                    m_pdwRemoveVariations[i] = m_pPatternTrack->m_pdwRemoveVariations[i];
                }
                else
                {
                    m_pVariations[i] = -1;
                    m_pdwRemoveVariations[i] = 0;
                }
            }
        }
    }
    // initialize the part offset array and seek pointer array.
    for (int i = 0; i < nPartCount; i++)
    {
        m_pmtPartOffset[i] = 0;
        m_ppEventSeek[i] = NULL;
    }
    
    // Set up the new pattern.
    if (m_pPattern != pTargetPattern)
    {
        pTargetPattern->AddRef();
        if (m_pPattern) m_pPattern->Release();
        m_pPattern = pTargetPattern;
    }
    return S_OK;
}

// This assumes the time sig remains constant for the length of the segment.
// If time sigs change, we won't necessarily have one generator per beat, but
// this will still give consistent playback behavior under most circumstances;
// the exception is a controlling segment that interupts somewhere after the 
// time signature changes.
HRESULT PatternTrackState::InitVariationSeeds(long lBaseSeed)
{
    // Get the Segment length
    MUSIC_TIME mtLength = 0;
    IDirectMusicSegment* pSegment = NULL;
    if (m_pSegState)
    {
        if (SUCCEEDED(m_pSegState->GetSegment(&pSegment)))
        {
            pSegment->GetLength(&mtLength);
            pSegment->Release();
        }
    }
    else
    {
        return E_POINTER;
    }

    // Get the current time sig and use it to get the number of beats in the segment
    DirectMusicTimeSig TimeSig = PatternTimeSig();
    int nBeats = TimeSig.ClocksToBeat(mtLength);

    // Create an array with the required number of beats, and use the Base Seed to
    //   seed a random number generator at each beat
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    m_plVariationSeeds = new CRandomNumbers[nBeats];
    if (!m_plVariationSeeds)
    {
        m_nTotalGenerators = 0;
        return E_OUTOFMEMORY;
    }
    else
    {
        m_nTotalGenerators = nBeats;
        for (int i = 0; i < nBeats; i++)
        {
            m_plVariationSeeds[i].Seed(lBaseSeed);
            lBaseSeed = m_plVariationSeeds[i].Next();
        }
        return S_OK;
    }
}

HRESULT PatternTrackState::RemoveVariationSeeds()
{
    if (m_plVariationSeeds) delete [] m_plVariationSeeds;
    m_plVariationSeeds = NULL;
    m_nTotalGenerators = 0;
    return S_OK;
}

long PatternTrackState::RandomVariation(MUSIC_TIME mtTime, long lModulus)
{
    if (m_plVariationSeeds)
    {
        DirectMusicTimeSig TimeSig = PatternTimeSig();
        int nBeat = TimeSig.ClocksToBeat(mtTime);
        // In case time sigs change somehow, make sure we get a valid generator
        if (nBeat >= m_nTotalGenerators) nBeat = m_nTotalGenerators - 1;
        return m_plVariationSeeds[nBeat].Next(lModulus);
    }
    else
    {
        // regular old dm_rand...
        return dm_rand() % lModulus;
    }
}

void PatternTrackState::GetNextChord(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fStart, BOOL fSkipVariations)
{
    HRESULT hr = S_OK;
    {
        hr = pPerformance->GetParam(GUID_ChordParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
                                    &m_mtNextChordTime, (void*) &m_CurrentChord);
        if (SUCCEEDED(hr))
        {
            m_mtCurrentChordTime = mtNow;
            if (m_mtNextChordTime) m_mtNextChordTime += mtNow;
            TraceI(4, "[1] Offset: %d Next Chord: %d\n", mtOffset, m_mtNextChordTime);
#ifdef DBG
            if (!m_CurrentChord.bSubChordCount)
            {
                Trace(2, "Warning: Attempt to get a chord resulted in a chord with no subchords.\n");
            }
#endif
        }
    }
    // instead of failing here completely, I'll just give m_mtNextChordTime and m_CurrentChord
    // fallback values
    if (FAILED(hr))
    {
        m_mtCurrentChordTime = 0;
        m_mtNextChordTime = 0;
        if (!m_pStyle || !m_pStyle->UsingDX8()) // otherwise use current chord info
        {
            wcscpy(m_CurrentChord.wszName, L"M7");
            m_CurrentChord.wMeasure = 0;
            m_CurrentChord.bBeat = 0;
            m_CurrentChord.bSubChordCount = 1;
            m_CurrentChord.bKey = 12;
            m_CurrentChord.dwScale = DEFAULT_SCALE_PATTERN;
            m_CurrentChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
            m_CurrentChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
            m_CurrentChord.SubChordList[0].dwInversionPoints = 0xffffff;
            m_CurrentChord.SubChordList[0].dwLevels = 0xffffffff;
            m_CurrentChord.SubChordList[0].bChordRoot = 12; // 2C
            m_CurrentChord.SubChordList[0].bScaleRoot = 0;
        }
    }
    TraceI(3, "Current Chord: %d %s [%d] HRESULT: %x\n", 
        m_CurrentChord.SubChordList[0].bChordRoot, m_CurrentChord.wszName, mtNow, hr);
    if (m_mtNextChordTime > 0)
    {
        HRESULT hr = S_OK;
        hr = pPerformance->GetParam(GUID_ChordParam, m_dwGroupID, DMUS_SEG_ANYTRACK, m_mtNextChordTime + mtOffset,
                                    &m_mtLaterChordTime, (void*) &m_NextChord);
        if (SUCCEEDED(hr))
        {
            if (m_mtLaterChordTime) m_mtLaterChordTime += m_mtNextChordTime;
            TraceI(4, "[3] Offset: %d Later Chord: %d\n", mtOffset, m_mtLaterChordTime);
#ifdef DBG
            if (!m_NextChord.bSubChordCount)
            {
                Trace(2, "Warning: Attempt to get a chord resulted in a chord with no subchords.\n");
            }
#endif
        }
    }
    if (!fSkipVariations)
    {
        // select a variation for each part in the pattern, based on the moaw and the 
        //previous and next chords.
        DWORD dwFlags = 0;
        if (m_fNewPattern) dwFlags |= COMPUTE_VARIATIONSF_NEW_PATTERN;
        if (fStart) dwFlags |= COMPUTE_VARIATIONSF_START;
        if (m_pStyle && m_pStyle->UsingDX8()) dwFlags |= COMPUTE_VARIATIONSF_DX8;
        m_pPattern->ComputeVariations(dwFlags, m_CurrentChord, m_NextChord,
            m_abVariationGroups, m_pdwVariationMask, m_pdwRemoveVariations, m_pVariations, mtNow, m_mtNextChordTime, this);
        m_fNewPattern = FALSE;
        if ( (m_pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
              m_pPatternTrack &&
              m_pPatternTrack->m_pVariations &&
              m_pPatternTrack->m_pdwRemoveVariations)
        {
            // update track's m_pVariations and m_pdwRemoveVariations (for each part)
            for (int i = 0; i < m_pPattern->m_PartRefList.GetCount(); i++)
            {
                m_pPatternTrack->m_pVariations[i] = m_pVariations[i];
                m_pPatternTrack->m_pdwRemoveVariations[i] = m_pdwRemoveVariations[i];
            }
        }
    }
}

DMStyleStruct* PatternTrackState::FindStyle(MUSIC_TIME mtTime, MUSIC_TIME& rmtTime)
{
    IDMStyle* pStyle = NULL;
    DMStyleStruct* pResult = NULL;
    if (m_pPatternTrack && m_pPatternTrack->m_pISList.GetHead())
    {
        TListItem<StylePair>* pScan = m_pPatternTrack->m_pISList.GetHead();
        for(; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().m_pStyle) break;
        }
        if (pScan)
        {
            pStyle = pScan->GetItemValue().m_pStyle;
            for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                StylePair& rScan = pScan->GetItemValue();
                if (rScan.m_pStyle)
                {
                    if ( mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                }
            }
            rmtTime = (pScan != NULL) ? pScan->GetItemValue().m_mtTime : 0;
            if (pStyle)
            {
                pStyle->GetStyleInfo((void**)&pResult);
            }
            else
            {
                return NULL;
            }
        }
    }
    return pResult;
}

DWORD PatternTrackState::Variations(DirectMusicPartRef&, int nPartIndex)
{
    return (m_pVariations[nPartIndex] == 0xff) ? 0 : (1 << m_pVariations[nPartIndex]);
}

BOOL PatternTrackState::PlayAsIs()
{
    return FALSE;
}

BOOL PatternTrackState::MapPChannel(DWORD dwPChannel, DWORD& dwMapPChannel)
{
    for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
    {
        if (m_pPatternTrack->m_pdwPChannels[dw] == dwPChannel)
        {
            dwMapPChannel = m_pMappings[dw].m_dwPChannelMap;
            return m_pMappings[dw].m_fMute;
        }
    }
    dwMapPChannel = 0;
    return FALSE;
}

inline int RandomExp(BYTE bRange)
{
    int nResult = 0;
    if (0 <= bRange && bRange <= 190)
    {
        nResult = bRange;
    }
    else if (191 <= bRange && bRange <= 212)
    {
        nResult = ((bRange - 190) * 5) + 190;
    }
    else if (213 <= bRange && bRange <= 232)
    {
        nResult = ((bRange - 212) * 10) + 300;
    }
    else // bRange > 232
    {
        nResult = ((bRange - 232) * 50) + 500;
    }
    return (dm_rand() % nResult) - (nResult >> 1);
}

HRESULT PatternTrackState::PlayParts(MUSIC_TIME mtStart, 
                                     MUSIC_TIME mtEnd, 
                                     MUSIC_TIME mtOffset,
                                     REFERENCE_TIME rtOffset,
                                     MUSIC_TIME mtSection,
                                     IDirectMusicPerformance* pPerformance,
                                     DWORD dwPartFlags,
                                     DWORD dwPlayFlags,
                                     bool& rfReLoop)
{
    if (dwPlayFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    if (!m_pPattern) // This shouldn't happen
    {
        return DMUS_E_NOT_INIT;
    }

    HRESULT hr = S_OK;
    bool fClockTime = (dwPartFlags & PLAYPARTSF_CLOCKTIME) ? true : false;
    bool fStart = (dwPartFlags & PLAYPARTSF_START) ? true : false;
    bool fGetChordStart = fStart;
    bool fFirstCall = (dwPartFlags & PLAYPARTSF_FIRST_CALL) ? true : false;
    bool fReloop = (dwPartFlags & PLAYPARTSF_RELOOP) ? true : false;
    bool fFlush = (dwPartFlags & PLAYPARTSF_FLUSH) ? true : false;
    MUSIC_TIME mtNewChord = mtStart;

    TListItem<DirectMusicPartRef>* pPartRef = m_pPattern->m_PartRefList.GetHead();
    for (short i = 0; pPartRef != NULL; pPartRef = pPartRef->GetNext(), i++)
    {
        m_pfChangedVariation[i] = false;
        MUSIC_TIME mtFinish = mtEnd;
        CurveSeek Curves;
        MUSIC_TIME mtNow = 0;
        DirectMusicPart* pPart = pPartRef->GetItemValue().m_pDMPart;
        DirectMusicTimeSig& TimeSig = 
            (pPart->m_timeSig.m_bBeat != 0) ? pPart->m_timeSig : PatternTimeSig();
        MUSIC_TIME mtPartLength = TimeSig.ClocksPerMeasure() * pPart->m_wNumMeasures;
        if (fFirstCall)
        {
            if (fFlush)
            {
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, 0, mtStart, mtOffset, pPerformance, fClockTime);
                m_ppEventSeek[i] = NULL;
            }
            if (fStart)
            {
                m_pmtPartOffset[i] = 0;
            }
            if (mtPartLength)
            {
                while (mtStart >= mtSection + m_pmtPartOffset[i] + mtPartLength)
                {
                    m_pmtPartOffset[i] += mtPartLength;
                }
            }
            if (mtFinish > mtSection + m_pmtPartOffset[i] + mtPartLength)
            {
                rfReLoop = TRUE;
                mtFinish = mtSection + m_pmtPartOffset[i] + mtPartLength;
            }
        }
        if (!fReloop || mtFinish > mtSection + m_pmtPartOffset[i] + mtPartLength)
        {
            if (fReloop)
            {
                m_pmtPartOffset[i] += mtPartLength;
            }
            CDirectMusicEventItem* pEvent = NULL;
            if (fFirstCall) pEvent = m_ppEventSeek[i];
            if (!pEvent) pEvent = pPart->EventList.GetHead();
            BumpTime(pEvent, TimeSig, mtSection + m_pmtPartOffset[i], mtNow);
            if (pEvent)
            {
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, mtStart, mtNow, mtOffset, pPerformance, fClockTime);
            }
            while (pEvent != NULL && mtNow < mtFinish) 
            {
                if (fFirstCall && fStart &&
                    mtNow < mtStart &&
                    pEvent->m_dwEventTag == DMUS_EVENT_CURVE)
                {
                    if (Variations(pPartRef->GetItemValue(), i) & 
                        pEvent->m_dwVariation)
                    {
                        TraceI(4, "Found a curve\n");
                        Curves.AddCurve(pEvent, mtNow);
                    }
                }
                if (mtNow >= mtStart)
                {
                    if (mtNow < mtNewChord)
                    {
                        // Revert to the chord in effect at mtNow
                        TraceI(4, "WARNING: Reverting to chord at %d\n", mtNow); 
                        GetNextChord(mtNow, mtOffset, pPerformance, (dwPartFlags & PLAYPARTSF_START) ? true : false);
                        mtNewChord = mtNow;
                    }
                    else if ((mtNow >= m_mtNextChordTime) || m_mtNextChordTime == 0)
                    {
                        TraceI(4, "Getting new chord.  Now: %d Next: %d\n", mtNow, m_mtNextChordTime); 
                        GetNextChord(mtNow, mtOffset, pPerformance, fGetChordStart);
                        mtNewChord = mtNow;
                        fGetChordStart = false;
                    }
                    TraceI(4, "Play %d (%d + %d + %d)\n", mtNow, TimeSig.GridToClocks(pEvent->m_nGridStart), mtSection, m_pmtPartOffset[i]);
                    PlayPatternEvent(
                        mtNow,
                        pEvent,
                        TimeSig, 
                        mtSection + m_pmtPartOffset[i], 
                        mtOffset,
                        rtOffset,
                        pPerformance,
                        i, 
                        pPartRef->GetItemValue(),
                        fClockTime,
                        0,
                        m_pfChangedVariation[i]);
                }
                pEvent = pEvent->GetNext();
                BumpTime(pEvent, TimeSig, mtSection + m_pmtPartOffset[i], mtNow);
                MUSIC_TIME mtMute = pEvent ? mtNow : mtFinish - 1;
                GetNextMute(pPartRef->GetItemValue().m_dwLogicalPartID, mtStart, mtMute, mtOffset, pPerformance, fClockTime);
            }
            m_ppEventSeek[i] = pEvent;
            // If we've got curve events, send them now
            if (fFirstCall && fStart)
            {
                TraceI(4, "Playing curves (after loop)\n");
                Curves.PlayCurves(this,
                        TimeSig, 
                        mtSection + m_pmtPartOffset[i],
                        mtOffset,
                        rtOffset,
                        pPerformance,
                        i, 
                        pPartRef->GetItemValue(),
                        fClockTime,
                        mtStart - (mtSection + m_pmtPartOffset[i]));
            }
        }
    }
    return hr;
}

// when creating a note event, both the passed in offset and the note's offset must
// be added to the note's time
void PatternTrackState::PlayPatternEvent(
        MUSIC_TIME mtNow,
        CDirectMusicEventItem* pEventItem, 
        DirectMusicTimeSig& TimeSig,
        MUSIC_TIME mtPartOffset, 
        MUSIC_TIME mtSegmentOffset, 
        REFERENCE_TIME rtOffset, 
        IDirectMusicPerformance* pPerformance,
        short nPart,
        DirectMusicPartRef& rPartRef,
        BOOL fClockTime,
        MUSIC_TIME mtPartStart,
        bool& rfChangedVariation)
{
    DMUS_NOTE_PMSG* pNote = NULL;
    DMUS_CURVE_PMSG* pCurve = NULL;
    DWORD dwMapPChannel = 0;
    BOOL fMute = MapPChannel(rPartRef.m_dwLogicalPartID, dwMapPChannel);
    if ( (!fMute) &&
         (Variations(rPartRef, nPart) & pEventItem->m_dwVariation) )
    {
        CDMStyleCurve* pCurveEvent = NULL;
        CDMStyleNote* pNoteEvent = NULL;
        CDMStyleMarker* pMarkerEvent = NULL;
        if (pEventItem->m_dwEventTag == DMUS_EVENT_MARKER) // we have a marker event
        {
            // If we're not ignoring marker events and we've hit a variation stop point that's 
            // either not chord-aligned or on the chord, then get a new variation.
            pMarkerEvent = (CDMStyleMarker*)pEventItem;
            if ( (rPartRef.m_pDMPart && (rPartRef.m_pDMPart->m_dwFlags & DMUS_PARTF_USE_MARKERS)) &&
                 (pMarkerEvent->m_wFlags & DMUS_MARKERF_STOP) &&
                 (mtNow != m_mtPatternStart) &&
                 (!(pMarkerEvent->m_wFlags & DMUS_MARKERF_CHORD_ALIGN) ||
                   (mtNow == m_mtCurrentChordTime) ||
                   (mtNow == m_mtNextChordTime)) )
            {
                TraceI(3, "Computing variations at %d Pattern start: %d...\n", mtNow, m_mtPatternStart);
                DWORD dwFlags = COMPUTE_VARIATIONSF_NEW_PATTERN | COMPUTE_VARIATIONSF_MARKER;
                if ((pMarkerEvent->m_wFlags & DMUS_MARKERF_CHORD_ALIGN))
                {
                    dwFlags |= COMPUTE_VARIATIONSF_CHORD_ALIGN;
                }
                if (m_pStyle && m_pStyle->UsingDX8()) dwFlags |= COMPUTE_VARIATIONSF_DX8;
                if (rfChangedVariation) dwFlags |= COMPUTE_VARIATIONSF_CHANGED;
                m_pPattern->ComputeVariationGroup(
                    rPartRef,
                    nPart,
                    dwFlags, 
                    m_CurrentChord, 
                    m_NextChord, 
                    m_abVariationGroups, 
                    m_pdwVariationMask, 
                    m_pdwRemoveVariations, 
                    m_pVariations, 
                    mtNow + pMarkerEvent->m_nTimeOffset, 
                    m_mtNextChordTime, 
                    this);
                rfChangedVariation = true;
                if ( (m_pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) &&
                     m_pPatternTrack &&
                     m_pPatternTrack->m_pVariations &&
                     m_pPatternTrack->m_pdwRemoveVariations )
                {
                    // update track's m_pVariations and m_pdwRemoveVariations (for this part)
                    m_pPatternTrack->m_pVariations[nPart] = m_pVariations[nPart];
                    m_pPatternTrack->m_pdwRemoveVariations[nPart] = m_pdwRemoveVariations[nPart];
                }
            }
            else
            {
                TraceI(3, "NOT computing variations at %d Pattern start: %d  Chord times: %d, %d Flags: %x\n", 
                    mtNow, m_mtPatternStart, m_mtCurrentChordTime, m_mtNextChordTime, pMarkerEvent->m_wFlags);
            }
        }
        else if (pEventItem->m_dwEventTag == DMUS_EVENT_CURVE) // we have a curve event
        {
            pCurveEvent = (CDMStyleCurve*)pEventItem; 
            if (SUCCEEDED(pPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                    (DMUS_PMSG**) &pCurve)))
            {
                MUSIC_TIME mtSegmentTime = TimeSig.GridToClocks(pCurveEvent->m_nGridStart) +
                    pCurveEvent->m_nTimeOffset + mtPartOffset;
                if (fClockTime)
                {
                    pCurve->wMeasure = 0;
                    pCurve->bBeat = 0;
                    pCurve->bGrid = 0;
                    pCurve->nOffset = pCurveEvent->m_nTimeOffset;
                    pCurve->rtTime = (mtSegmentTime * REF_PER_MIL) + rtOffset;
                    pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    pCurve->wMeasure = (WORD)TimeSig.GridsToMeasure(pCurveEvent->m_nGridStart);
                    pCurve->bBeat = (BYTE)TimeSig.GridsToBeat(pCurveEvent->m_nGridStart);
                    pCurve->bGrid = (BYTE)TimeSig.GridOffset(pCurveEvent->m_nGridStart);
                    pCurve->nOffset = pCurveEvent->m_nTimeOffset;
                    pCurve->mtTime = mtSegmentTime + mtSegmentOffset;
                    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;
                }
                pCurve->mtResetDuration = pCurveEvent->m_mtResetDuration;
                pCurve->mtDuration = pCurveEvent->m_mtDuration;
                pCurve->nResetValue = pCurveEvent->m_nResetValue;
                pCurve->bFlags = pCurveEvent->m_bFlags;
                pCurve->dwType = DMUS_PMSGT_CURVE;
                pCurve->dwPChannel = dwMapPChannel;
                pCurve->dwVirtualTrackID = m_dwVirtualTrackID; // ??
                pCurve->nStartValue = pCurveEvent->m_StartValue;    // curve's start value
                pCurve->nEndValue = pCurveEvent->m_EndValue;    // curve's end value
                pCurve->bType = pCurveEvent->m_bEventType;  // type of curve
                pCurve->bCurveShape = pCurveEvent->m_bCurveShape;   // shape of curve
                pCurve->bCCData = pCurveEvent->m_bCCData;       // CC# if this is a control change type
                pCurve->dwGroupID = m_dwGroupID;
                pCurve->wParamType = pCurveEvent->m_wParamType;
                pCurve->wMergeIndex = pCurveEvent->m_wMergeIndex;
                // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                pCurve->dwFlags |= DMUS_PMSGF_DX8;
                if (mtPartStart) // only set on invalidation
                {
                    MUSIC_TIME mtOffset = mtPartOffset + mtSegmentOffset;
                    if (pCurve->mtTime + pCurve->mtDuration >= mtPartStart + mtOffset)
                    {
                        pCurve->mtOriginalStart = pCurve->mtTime;
                        pCurve->mtTime = mtPartStart + mtOffset;
                    }
                    else
                    {
                        pCurve->mtResetDuration -= (mtPartStart + mtOffset - pCurve->mtTime);
                        if (pCurve->mtResetDuration < 0) pCurve->mtResetDuration = 0;
                        pCurve->mtTime = mtPartStart + mtOffset;
                        pCurve->bCurveShape = DMUS_CURVES_INSTANT;
                    }
                }
                IDirectMusicGraph* pGraph;
                if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                    (void**)&pGraph )))
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pCurve );
                    pGraph->Release();
                }
                if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pCurve)))
                {
                    pPerformance->FreePMsg( (DMUS_PMSG*)pCurve);
                }
            }
        }
        else if (pEventItem->m_dwEventTag == DMUS_EVENT_NOTE) // we have a note event
        {
            pNoteEvent = (CDMStyleNote*)pEventItem;
            BYTE bPlayModeFlags =
                (pNoteEvent->m_bPlayModeFlags & DMUS_PLAYMODE_NONE) ?
                    rPartRef.m_pDMPart->m_bPlayModeFlags :
                    pNoteEvent->m_bPlayModeFlags;
            BYTE bMidiValue = 0;
            short nMidiOffset = 0;
            HRESULT hr = rPartRef.ConvertMusicValue(pNoteEvent, 
                                      m_CurrentChord,
                                      bPlayModeFlags,
                                      PlayAsIs(),
                                      m_aInversionGroups,
                                      pPerformance,
                                      bMidiValue,
                                      nMidiOffset);
            if (SUCCEEDED(hr) &&
                SUCCEEDED(pPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
                    (DMUS_PMSG**) &pNote)))
            {
                pNote->bFlags = DMUS_NOTEF_NOTEON | pNoteEvent->m_bFlags;
                MUSIC_TIME mtSegmentTime = TimeSig.GridToClocks(pNoteEvent->m_nGridStart) +
                    pNoteEvent->m_nTimeOffset + mtPartOffset;
                if (fClockTime)
                {
                    pNote->wMeasure = 0;
                    pNote->bBeat = 0;
                    pNote->bGrid = 0;
                    pNote->nOffset = pNoteEvent->m_nTimeOffset;
                    pNote->rtTime = (mtSegmentTime * REF_PER_MIL) + rtOffset;
                    pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    pNote->wMeasure = (WORD)TimeSig.GridsToMeasure(pNoteEvent->m_nGridStart);
                    pNote->bBeat = (BYTE)TimeSig.GridsToBeat(pNoteEvent->m_nGridStart);
                    pNote->bGrid = (BYTE)TimeSig.GridOffset(pNoteEvent->m_nGridStart);
                    pNote->nOffset = pNoteEvent->m_nTimeOffset;
                    pNote->mtTime = mtSegmentTime + mtSegmentOffset;
                    pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
                }
                // time needs be jiggled by pNoteEvent->m_bTimeRange
                if (pNoteEvent->m_bTimeRange)
                    pNote->mtTime += RandomExp(pNoteEvent->m_bTimeRange);
                pNote->mtDuration = pNoteEvent->m_mtDuration;
                // duration needs be jiggled by pNoteEvent->m_bDurRange
                if (pNoteEvent->m_bDurRange)
                    pNote->mtDuration += RandomExp(pNoteEvent->m_bDurRange);
                    //  (dm_rand() % pNoteEvent->m_bDurRange) - (pNoteEvent->m_bDurRange >> 1);
                pNote->bVelocity = pNoteEvent->m_bVelocity;
                // velocity needs be jiggled by pNoteEvent->m_bVelRange
                if (pNoteEvent->m_bVelRange)
                    pNote->bVelocity += 
                      (dm_rand() % pNoteEvent->m_bVelRange) - (pNoteEvent->m_bVelRange >> 1);
                if (pNote->bVelocity < 1) pNote->bVelocity = 1;
                if (pNote->bVelocity > 127) pNote->bVelocity = 127;
                pNote->wMusicValue = pNoteEvent->m_wMusicValue;
                pNote->bMidiValue = bMidiValue;
                pNote->dwType = DMUS_PMSGT_NOTE;
                pNote->bPlayModeFlags = bPlayModeFlags;
                pNote->dwPChannel = dwMapPChannel;
                pNote->dwVirtualTrackID = m_dwVirtualTrackID; // ??
                pNote->bSubChordLevel = rPartRef.m_bSubChordLevel;
                pNote->dwGroupID = m_dwGroupID;
                pNote->bTimeRange = pNoteEvent->m_bTimeRange;
                pNote->bDurRange = pNoteEvent->m_bDurRange;
                pNote->bVelRange = pNoteEvent->m_bVelRange;
                pNote->cTranspose = (char) nMidiOffset;

                IDirectMusicGraph* pGraph;
                if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                    (void**)&pGraph )))
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pNote );
                    pGraph->Release();
                }

                if (pNote->dwFlags & DMUS_PMSGF_REFTIME)
                {
                    TraceI(5, "PLAY %d @%d\n", rPartRef.m_dwLogicalPartID, 
                        (MUSIC_TIME) (pNote->rtTime/REF_PER_MIL));
                }
                else
                {
                    TraceI(5, "PLAY %d @%d: %x [%d]{%x}\n", rPartRef.m_dwLogicalPartID, pNote->mtTime, 
                        pNote->wMusicValue, pNote->bMidiValue, Variations(rPartRef, nPart));
                }
                if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pNote) ))
                {
                    pPerformance->FreePMsg( (DMUS_PMSG*)pNote);
                }
            }
        }
    }
}


void PatternTrackState::SendTimeSigMessage(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, MUSIC_TIME mtTime, IDirectMusicPerformance* pPerformance)
{
    if (!m_pStyle) return;
    IDirectMusicGraph* pGraph = NULL;
    DMUS_TIMESIG_PMSG* pTimeSig;
    if( FAILED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }
    if( SUCCEEDED( pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
        (DMUS_PMSG**)&pTimeSig )))
    {
        if( mtTime < mtNow )
        {
            // this only happens in the case where we've puposefully seeked
            // and need to time stamp this event with the start time
            pTimeSig->mtTime = mtNow + mtOffset;
        }
        else
        {
            pTimeSig->mtTime = mtTime + mtOffset;
        }
        pTimeSig->bBeatsPerMeasure = m_pStyle->m_TimeSignature.m_bBeatsPerMeasure;
        pTimeSig->bBeat = m_pStyle->m_TimeSignature.m_bBeat;
        pTimeSig->wGridsPerBeat = m_pStyle->m_TimeSignature.m_wGridsPerBeat;
        pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
        pTimeSig->dwVirtualTrackID = m_dwVirtualTrackID;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        pTimeSig->dwGroupID = m_dwGroupID;

        if( pGraph )
        {
            pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
            pGraph->Release();
        }
        TraceI(3, "TimeSigtrk: TimeSig event\n");
        if(FAILED(pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
        {
            pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
        }
    }
}

// send measure and beat notifications
MUSIC_TIME PatternTrackState::NotifyMeasureBeat( 
    MUSIC_TIME mtStart, MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, DWORD dwFlags )
{
    if (dwFlags & DMUS_TRACKF_NOTIFY_OFF)
    {
        return S_OK;
    }

    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    BYTE bCurrentBeat;
    WORD wCurrentMeasure;
    DirectMusicTimeSig& rTimeSig = PatternTimeSig();

    // now actually generate the beat events.
    // Generate events that are on beat boundaries, from mtStart to mtEnd
    long lQuantize = ( DMUS_PPQ * 4 ) / rTimeSig.m_bBeat;
    long lAbsoluteBeat = mtStart / lQuantize;

    bCurrentBeat = (BYTE) (lAbsoluteBeat % rTimeSig.m_bBeatsPerMeasure);
    wCurrentMeasure = (WORD) (lAbsoluteBeat / rTimeSig.m_bBeatsPerMeasure);
    while( mtStart < mtEnd )
    {
        if( SUCCEEDED( pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtStart + mtOffset;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

            pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
            pEvent->dwField1 = bCurrentBeat;
            pEvent->dwField2 = wCurrentMeasure;
            pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
            pEvent->dwGroupID = m_dwGroupID;
            pEvent->dwVirtualTrackID = m_dwVirtualTrackID;

            IDirectMusicGraph* pGraph;
            if( SUCCEEDED( m_pSegState->QueryInterface( IID_IDirectMusicGraph,
                (void**)&pGraph )))
            {
                pGraph->StampPMsg((DMUS_PMSG*) pEvent );
                pGraph->Release();
            }
            if(FAILED(pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
            {
                pPerformance->FreePMsg( (DMUS_PMSG*)pEvent);;
            }
        }
        bCurrentBeat++;
        if( bCurrentBeat >= rTimeSig.m_bBeatsPerMeasure )
        {
            bCurrentBeat = 0;
            wCurrentMeasure++;
        }
        mtStart += lQuantize;
    }
    return mtEnd;
}

MUSIC_TIME PatternTrackState::PartOffset(int nPartIndex)
{
    return m_pmtPartOffset[nPartIndex];
}

/////////////////////////////////////////////////////////////////////////////
// PatternTrackInfo

PatternTrackInfo::PatternTrackInfo() : 
    m_fNotifyMeasureBeat(FALSE), m_dwPChannels(0), m_pdwPChannels(NULL),
    m_fActive(TRUE),
//  m_fTrackPlay(TRUE),
#ifdef DXAPI
    m_fStateSetBySetParam(FALSE),
#endif
//  m_fStatePlaySetBySetParam(FALSE),
    m_fChangeStateMappings(FALSE),
    m_lRandomNumberSeed(0),
    m_dwValidate(0),
    m_pVariations(NULL),
    m_pdwRemoveVariations(NULL)
{
}

PatternTrackInfo::PatternTrackInfo(
        const PatternTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : 
    m_dwPChannels(0), m_pdwPChannels(NULL), m_lRandomNumberSeed(0), m_dwValidate(0),
    m_pVariations(NULL), m_pdwRemoveVariations(NULL)
{
    if (pInfo)
    {
        m_fChangeStateMappings = pInfo->m_fChangeStateMappings;
        m_fNotifyMeasureBeat = pInfo->m_fNotifyMeasureBeat;
        m_fActive = pInfo->m_fActive;
//      m_fTrackPlay = pInfo->m_fTrackPlay;
#ifdef DXAPI
        m_fStateSetBySetParam = pInfo->m_fStateSetBySetParam;
#endif
//      m_fStatePlaySetBySetParam = pInfo->m_fStatePlaySetBySetParam;
    }
    TListItem<StylePair>* pScan = pInfo->m_pISList.GetHead();
    //1////////////////////////////////////////
    TListItem<StylePair>* pPrevious = NULL;
    //1////////////////////////////////////////
    for(; pScan; pScan = pScan->GetNext())
    {
        StylePair& rScan = pScan->GetItemValue();
        //2////////////////////////////////////////
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        //2////////////////////////////////////////
        else if (rScan.m_mtTime < mtEnd)
        {
            //3////////////////////////////////////////
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            //3////////////////////////////////////////
            TListItem<StylePair>* pNew = new TListItem<StylePair>;
            if (pNew)
            {
                StylePair& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_pStyle = rScan.m_pStyle;
                if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
                m_pISList.AddTail(pNew);
            }
        }
    }
    //4////////////////////////////////////////
    if (pPrevious)
    {
        TListItem<StylePair>* pNew = new TListItem<StylePair>;
        if (pNew)
        {
            StylePair& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_pStyle = pPrevious->GetItemValue().m_pStyle;
            if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
            m_pISList.AddHead(pNew);
        }
    }
    //4////////////////////////////////////////
}

PatternTrackInfo::~PatternTrackInfo()
{
    if (m_pdwPChannels) delete [] m_pdwPChannels;
    if (m_pVariations) delete [] m_pVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
}

PatternTrackState* PatternTrackInfo::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}

HRESULT PatternTrackInfo::EndPlay(PatternTrackState* pStateData)
{
    if (!pStateData) return E_FAIL;
    for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        StatePair& rPair = pScan->GetItemValue();
        if (pStateData == rPair.m_pStateData)
        {
            m_StateList.Remove(pScan);
            delete pScan;
            break;
        }
    }
    delete pStateData;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE PatternTrackInfo::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    if( rGuidNotify == GUID_NOTIFICATION_MEASUREANDBEAT )
    {
        m_fNotifyMeasureBeat = TRUE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE PatternTrackInfo::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    if( rGuidNotify == GUID_NOTIFICATION_MEASUREANDBEAT )
    {
        m_fNotifyMeasureBeat = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT PatternTrackInfo::InitTrackVariations(CDirectMusicPattern* pPattern)
{
    HRESULT hr = S_OK;
    if ( pPattern && (pPattern->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL) )
    {
        // delete the variation arrays if they exist;
        if (m_pVariations)
        {
            delete [] m_pVariations;
            m_pVariations = NULL;
        }
        if (m_pdwRemoveVariations)
        {
            delete [] m_pdwRemoveVariations;
            m_pdwRemoveVariations = NULL;
        }
        // init the variation arrays to the number of parts in the pattern
        int nPartCount = pPattern->m_PartRefList.GetCount();
        m_pVariations = new BYTE[nPartCount];
        if (!m_pVariations)
        {
            return E_OUTOFMEMORY;
        }
        m_pdwRemoveVariations = new DWORD[nPartCount];
        if (!m_pdwRemoveVariations)
        {
            return E_OUTOFMEMORY;
        }
        for (int i = 0; i < nPartCount; i++)
        {
            m_pVariations[i] = -1;
            m_pdwRemoveVariations[i] = 0;
        }
    }
    return hr;
}

HRESULT PatternTrackInfo::MergePChannels()
{
    TList<DWORD> PChannelList;
    DMStyleStruct* pStruct = NULL;
    HRESULT hr = S_OK;

    TListItem<StylePair>* pScan = m_pISList.GetHead();
    for( ; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().m_pStyle)
        {
            pScan->GetItemValue().m_pStyle->GetStyleInfo((void**)&pStruct);
            TListItem<DWORD>* pChannel = pStruct->m_PChannelList.GetHead();
            for (; pChannel; pChannel = pChannel->GetNext() )
            {
                AdjoinPChannel(PChannelList, pChannel->GetItemValue() );
            }
        }
    }
    if (PChannelList.IsEmpty())
    {
        AdjoinPChannel(PChannelList, 0);
    }

    TListItem<DWORD>* pPChannel = PChannelList.GetHead();

    m_dwPChannels = pPChannel->GetCount();
    if (m_pdwPChannels) delete [] m_pdwPChannels;
    m_pdwPChannels = new DWORD[m_dwPChannels];
    if (!m_pdwPChannels)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (int i = 0; i < (int)m_dwPChannels; i++)
        {
            m_pdwPChannels[i] = pPChannel->GetItemValue();
            pPChannel = pPChannel->GetNext();
        }
        m_fChangeStateMappings = TRUE;
    }
    return hr;
}

inline int CurveIndex(CDirectMusicEventItem* pEvent)
{
    CDMStyleCurve* pCurve = NULL;
    if (pEvent->m_dwEventTag == DMUS_EVENT_CURVE)
    {
        pCurve = (CDMStyleCurve*)pEvent;
        switch (pCurve->m_bEventType)
        {
        case DMUS_CURVET_CCCURVE:
            return pCurve->m_bCCData & 0x7f;
        case DMUS_CURVET_PATCURVE:
            return (pCurve->m_bCCData & 0x7f) + 128;
        case DMUS_CURVET_PBCURVE:
            return 256;
        case DMUS_CURVET_MATCURVE:
            return 257;
        default:
            return -1;
        }
    }
    return -1;
}

CurveSeek::CurveSeek()
{
    for (int nType = 0; nType < CURVE_TYPES; nType++)
    {
        m_apCurves[nType] = NULL;
        m_amtTimeStamps[nType] = 0;
    }
    m_fFoundCurve = false;
}

void CurveSeek::AddCurve(CDirectMusicEventItem* pEvent, MUSIC_TIME mtTimeStamp)
{
    int nIndex = CurveIndex(pEvent);
    if (nIndex >= 0)
    {
        if (!m_apCurves[nIndex] || 
            m_amtTimeStamps[nIndex] < mtTimeStamp)
        {
            m_apCurves[nIndex] = pEvent;
            m_amtTimeStamps[nIndex] = mtTimeStamp;
            m_fFoundCurve = true;
        }
    }
}

void CurveSeek::PlayCurves(
        PatternTrackState* pStateData,
        DirectMusicTimeSig& TimeSig,
        MUSIC_TIME mtPatternOffset, 
        MUSIC_TIME mtOffset, 
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerformance,
        short nPart,
        DirectMusicPartRef& rPartRef,
        BOOL fClockTime,
        MUSIC_TIME mtPartStart)
{
    if (m_fFoundCurve)
    {
        for (int nType = 0; nType < CURVE_TYPES; nType++)
        {
            CDirectMusicEventItem* pScan = m_apCurves[nType];
            if (pScan)
            {
                int nGrid = pScan->m_nGridStart;
                CDirectMusicEventItem* pWinner = pScan;
                MUSIC_TIME mtBiggest = pWinner->m_nTimeOffset;
                for (; pScan && pScan->m_nGridStart == nGrid; pScan = pScan->GetNext())
                {
                    if (pScan->m_dwEventTag == DMUS_EVENT_CURVE &&
                        pScan->m_nTimeOffset > mtBiggest)
                    {
                        pWinner = pScan;
                        mtBiggest = pWinner->m_nTimeOffset;
                    }
                }
                MUSIC_TIME mtNow = 0;
                bool fChange = false;
                pStateData->BumpTime(pWinner, TimeSig, mtPatternOffset, mtNow);
                pStateData->PlayPatternEvent(
                    mtNow,
                    pWinner, 
                    TimeSig, 
                    mtPatternOffset,
                    mtOffset,
                    rtOffset,
                    pPerformance,
                    nPart, 
                    rPartRef,
                    fClockTime,
                    mtPartStart,
                    fChange);
            }
        }
        m_fFoundCurve = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\adapter.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// Kernel mode DirectMusic DLS level 1 Software Synthesizer
//

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "kmsynth: "
#define MAX_MINIPORTS 1

#include "common.h"
#include "private.h"


#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
);

NTSTATUS
StartDevice
(
    IN      PVOID           Context1,       // Context for the class driver.
    IN      PVOID           Context2,       // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);

#pragma code_seg("PAGE")

/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();

    //
    // Tell the class driver to initialize the driver.
    //
    return InitializeAdapterDriver(Context1,Context2, AddDevice);
}

/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();

    //
    // Tell the class driver to add the device.
    //
    return AddAdapterDevice(Context1,Context2, StartDevice,MAX_MINIPORTS);
}

/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniports.  This code is specific to
 * the adapter because it calls out miniports for functions that are specific
 * to the adapter.
 */
NTSTATUS
StartDevice
(
    IN      PVOID           Context1,       // Context for the class driver.
    IN      PVOID           Context2,       // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
   PAGED_CODE();

   ASSERT(Context1);
   ASSERT(Context2);
   ASSERT(ResourceList);

    // We only care about having a dummy MIDI miniport
    //
    PPORT       port;
    NTSTATUS    nt = NewPort(&port, CLSID_PortSynthesizer);

    if (!NT_SUCCESS(nt))
    {
        return nt;
    }

    PUNKNOWN pPortInterface;
    
    nt = port->QueryInterface(IID_IPortSynthesizer, (LPVOID*)&pPortInterface);
    if (!NT_SUCCESS(nt))
    {
        port->Release();
        return nt;
    }

    PUNKNOWN miniport;
    nt = CreateMiniportDmSynth(&miniport, NULL, NonPagedPool);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        return nt;
    }

    nt = port->Init(Context1, Context2, miniport, NULL, ResourceList);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        miniport->Release();
        return nt;
    }

    
    nt = RegisterSubdevice(Context1, Context2, L"MSSWSynth", port);
    if (!NT_SUCCESS(nt))
    {
        pPortInterface->Release();
        port->Release();
        miniport->Release();
        return nt;
    }

    return nt;
}


#pragma code_seg()

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virtual function called" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list
	HRESULT Copy(TList<T>& rList); // Copies one list to another

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\clist.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.cpp
//
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include "clist.h"
#endif

LONG CListItem::GetCount(void) const
{
    LONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

BOOL CListItem::IsMember(CListItem *pItem)

{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

CListItem * CListItem::GetItem(LONG index)

{
	CListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)

{
	CListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\clist.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      clist.h
//

#ifndef __CLIST_H__
#define __CLIST_H__

class CListItem
{
public:
    CListItem() { m_pNext=NULL; };
    CListItem *GetNext() const {return m_pNext;};
    void SetNext(CListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    BOOL IsMember(CListItem *pItem);
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) {pItem->SetNext(NULL); return Cat(pItem);};
    CListItem* Remove(CListItem* pItem);
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;
};

class CList
{
public:
    CList() {m_pHead=NULL;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    void Cat(CListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(CList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(CListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(CListItem *pItem)
    {
    	if (m_pHead == NULL)
    	{
    		AddHead(pItem);
    	}
    	else
    	{
    		m_pHead=m_pHead->AddTail(pItem);
    	}
    };
    void Remove(CListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    CListItem *GetPrev(CListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(CListItem *pItem) {return (m_pHead->IsMember(pItem));};
    CListItem *RemoveHead(void)
        {
            CListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            if (li)
                li->SetNext(NULL);
            return li;
        }

protected:
    CListItem *m_pHead;
};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\score.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       score.h
//
//--------------------------------------------------------------------------

#ifndef __SCORE_H__
#define __SCORE_H__

/*  Defines ============================================================*/

#define INUM                16  // Number of band members
#define PPQN                192 // Pulses per quarter note
#define PPQNx4              ( PPQN << 2 )
#define PPQN_2              ( PPQN >> 1 )

#define ROOT_MIN            0   // Scale (or chord) root min and max
#define ROOT_MAX            23

// Section Flags, WPARAM of SECTION_STARTED/ENDED
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

/*  Section Commands ===================================================*/

#define SCTSEC_PLAY_SECTION         2
#define SCTSEC_SET_ROOT             4
//#define SCTSEC_SET_STYLE            6
#define SCTSEC_SET_LENGTH           8
#define SCTSEC_SET_REPEATS          9
//#define SCTSEC_SET_PERSONALITY      15

#define BAND_MELODY   0     // Use BAND flags with RTC_SET_VOLUME,
#define BAND_STRING   1     // RTC_SET_PAN, RTC_SET_PATCH, SCTSEC_SET_VOLUME,
#define BAND_GUITAR   2     // SCTSEC_SET_PAN and SCTSEC_SET_PATCH
#define BAND_PIANO    3
#define BAND_BASS     4     // These are the default SCT band members
#define BAND_DRUM     5

#define BAND_ALL      50
#define BAND_NONE     51

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

/*  Band member mute flags =============================================*/

#define MUTE_MELODY   0x0001   // Use MUTE flags with sctSetMutes()
#define MUTE_STRING   0x0002
#define MUTE_GUITAR   0x0004
#define MUTE_PIANO    0x0008
#define MUTE_BASS     0x0010
#define MUTE_DRUM     0x0020
#define MUTE_ALL      0xFFFF

/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// Options for sctComposeTransitionEx

#define TRANS_CHANGE    1   // Chord transitions to next section instead of resolving
#define TRANS_LONG      2   // Transition lasts two measures, not one

/*  Structures maintained by SuperJAM! Technology Engine ==============*/

#pragma pack(1)

typedef struct SCTchord     FAR *LPSCTCHORD ;
typedef struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
} SCTchord ;

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
typedef struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
} SCTpersonality ;

typedef struct SCTstyle     FAR *LPSCTSTYLE ;
typedef struct SCTstyle
{
    LPSCTSTYLE   pNext ;           /* Pointer to next SCTstyle.        */
    LPSTR        lpszFileName ;     /* File name of style.              */
    LPSTR        lpszName ;         /* Style name.                      */
    LPVOID       lpDLL1 ;           /*   Reserved for use by score.dll  */
    LPSCTPERSONALITY lpSCTpersonalityList ;  /* Available personalities.*/
    short        nBeatNote ;        /* Note receiving one beat.         */
    short        nBeatsPerMeasure ; /* Beats per measure.               */
    short        nMusicTimePerBeat ;/* Music time per beat.             */
    short        nClicksPerMeasure ;/* Clicks per measure.              */
    short        nMusicTimePerClick;/* Music time per click.            */
    short        nClicksPerBeat ;   /* Clicks per beat.                 */
    short        nDefaultTempo ;    /* Style's default tempo.           */
    void*        pIStyle;           // pointer to interface, used by AA 2.0+
} SCTstyle ;

typedef struct SCTrealtime  FAR *LPSCTREALTIME ;
typedef struct SCTrealtime
{
    short         nSizeofStruct ;   /* sizeof(struct SCTrealtime)       */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by house band       */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality          */
    short         nTempo ;          /* Current tempo                    */
    WORD          wTempoFract ;     /* Current tempo fraction (0-65535) */
    DWORD         dwGroove ;        /* Current groove                   */
    char          chRoot ;          /* Root note of key                 */
    char          chFlat ;          /* Indicates whether key is flat    */
    char          chAutoChord ;     /* 0=Off, 1=On                      */
    char          chAutoChordActivity ;  /* Amount of chord activity    */
} SCTrealtime ;

typedef struct SCTsectionInfo FAR *LPSCTSECTIONINFO ;
typedef struct SCTsectionInfo
{
    short         nSizeofStruct ;   /* sizeof(struct SCTsectionInfo)    */
    char          achName[16] ;     /* Section name.                    */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by the section.     */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality.         */
    short         nTempo ;          /* Section tempo.                   */
    WORD          wTempoFract ;     /* Section tempo fraction (0-65535) */
    short         nNbrMeasures ;    /* Nbr of measures in section.      */
    WORD          nNbrRepeats ;     /* Nbr of times section repeats.    */
    char          chRoot ;          /* Root note of section key.        */
    char          chFlat ;          /* Indicates whether key is flat.   */
} SCTsectionInfo ;

typedef struct SCTperformance FAR *LPSCTPERFORMANCE ;

typedef struct SCTsection     FAR *LPSCTSECTION ;
typedef struct SCTsection
{
    LPSCTSECTION     pNext ;          /* Pointer to next SCTsection      */
    LPSTR            lpszName ;        /* Section name.                   */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll */
    LPSCTPERFORMANCE lpSCTperf ;       /* Section belongs to this perf.   */
    LPSCTSTYLE       lpSCTstyle ;      /* Style played by the section.    */
    LPSCTPERSONALITY lpSCTpersonality ;/* Active personality.             */
    short            nTempo ;          /* Section tempo.                  */
    WORD             wTempoFract ;     /* Section tempo fraction (0-65535)*/
    short            nStartingMeasure ;/* Starting measure of section.    */
    short            nNbrMeasures ;    /* Nbr of measures in section.     */
    WORD             nNbrRepeats ;     /* Nbr of times section repeats.   */
    char             chRoot ;          /* Root note of section key.       */
    char             chFlat ;          /* Indicates whether key is flat   */
    long             lStartTime ;      /* Music start time of section.    */
    void*            pISection;        // pointer to interface, used by AA 2.0+
} SCTsection ;

//DM
typedef struct SCTmotif* LPSCTMOTIF;
typedef struct SCTmotif
{
    LPSCTMOTIF  pNext;
    LPVOID      lpDLL1;
    LPCSTR      lpszName;
    short       nMeasures;
    short       nBeatsPerMeasure;
    short       nClicksPerBeat;
} SCTmotif;
//DM - END

typedef struct SCTperformance
{
    LPSCTPERFORMANCE pNext ;          /* Pointer to next SCTperformance.*/
//    char             achSongName[20] ; /* Name of song.                  */
    LPSCTREALTIME    lpSCTrealtime ;   /* RealTime information.          */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll*/
//    short            nRelVolume ;      /* Relative volume.               */
//    short            nRelTempo ;       /* Relative tempo.                */
//    LPSTR            lpszSongTitle;
//    LPSTR            lpszSongAuthor;
//    LPSTR            lpszSongCopyright;
} SCTperformance ;

typedef struct SCTdata      FAR *LPSCTDATA ;
typedef struct SCTdata
{
    LPSCTSTYLE       lpSCTstyleList ;  /* List of opened styles.       */
    LPSCTPERFORMANCE lpSCTperformanceList ; /* List of performances.   */
//DM
    LPSCTMOTIF  lpSCTmotif;            // pointer to list of motifs
// DM - END
} SCTdata ;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    /* The next command in the list.    */
    long          lDLL1 ;     /*   Reserved for use by score.dll. */
    short         nMeasure ;  /* Measure this command occurs.     */
    DWORD         dwCommand ; /* Command type.                    */
    DWORD         dwChord ;   /* Signpost chord.                  */
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           /* The next template in the list.  */
    char          achName[20] ;      /* Template name.                  */
    char          achType[20] ;      /* Template type.                  */
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; /* Template commands.              */
} SCTtemplate ;

#pragma pack()

/*  Function prototypes ============================================*/

LPSCTDATA WINAPI sctRegisterApplication(HWND,HWND,HINSTANCE,LPCSTR,LPDWORD,short);
void WINAPI sctUnregisterApplication(LPSCTDATA);

LPSCTSECTIONINFO WINAPI sctAllocSectionInfo(LPSCTPERFORMANCE,short);
void WINAPI sctFreeSectionInfo(LPSCTDATA,LPSCTSECTIONINFO);

DWORD WINAPI sctTimeToMeasure(LPSCTDATA,LPSCTSTYLE,DWORD);
DWORD WINAPI sctTimeToMils(LPSCTDATA,DWORD,short,unsigned short);

LPSCTCHORD WINAPI sctAllocChord(LPSCTDATA);
void WINAPI sctFreeChord(LPSCTDATA,LPSCTCHORD);
void WINAPI sctFreeChordList(LPSCTDATA,LPSCTCHORD);

LPSCTCHORD WINAPI sctGetChordListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetChordList(LPSCTDATA,LPSCTSECTION,LPSCTCHORD);

void WINAPI sctFreeCommandList(LPSCTDATA,LPSCTCOMMAND);

LPSCTCOMMAND WINAPI sctGetCommandListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetCommandList(LPSCTDATA,LPSCTSECTION,LPSCTCOMMAND);

LPSCTTEMPLATE WINAPI sctAllocTemplate(LPSCTDATA);
void WINAPI sctFreeTemplate(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateSignPosts(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateEmbellishments(LPSCTDATA,LPSCTTEMPLATE,short);

BOOL WINAPI sctBuildSection(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,short,short,short,DWORD);
BOOL WINAPI sctComposeSection(LPSCTDATA,LPSCTSECTION,LPSCTTEMPLATE,LPSCTPERSONALITY,short);
BOOL WINAPI sctComposeTransition(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,LPSCTCHORD,short,DWORD);
LPSCTSECTION WINAPI sctComposeTransitionEx( LPSCTDATA, LPSCTSECTION, LPSCTSECTION, short, DWORD, DWORD );

LPSCTSECTION WINAPI sctCreateSection(LPSCTPERFORMANCE,LPSCTSECTIONINFO);
void WINAPI sctDeleteSection(LPSCTDATA,LPSCTSECTION, BOOL fStop = TRUE);
LPSCTSECTION WINAPI sctDuplicateSection(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctQueueSectionEx( LPSCTDATA lpSCTdata, LPSCTSECTION lpSCTsection, DWORD dwStartTime );
BOOL WINAPI sctSectionCommand(LPSCTDATA,LPSCTSECTION,WORD,WORD,LONG,LONG);
BOOL WINAPI sctStopCurSectionASAP(LPSCTDATA);
BOOL WINAPI sctStopCurSection(LPSCTDATA,short);

LPSCTPERFORMANCE WINAPI sctCreatePerformance(LPSCTDATA,LPVOID);

//DM
BOOL WINAPI sctFreeMotif( LPSCTDATA, LPSCTMOTIF );

BOOL WINAPI sctSwitchPersonality( LPSCTDATA, LPSCTSECTION, LPSCTPERSONALITY, BOOL );

BOOL WINAPI sctSetQueuePrepareTime( WORD wPrepareTime );
//DM - END

#endif // __SCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\ptrntrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       ptrntrk.h
//
//--------------------------------------------------------------------------

// PtrnTrk.h : Declaration of the Pattern Track info and state structs

#ifndef __PATTERNTRACK_H_
#define __PATTERNTRACK_H_

#include "dmsect.h"
#include "dmstyle.h"

const MUSIC_TIME MAX_END = 2147483647; // max end time for a track

#define DMUS_PATTERN_AUDITION	1
#define DMUS_PATTERN_MOTIF		2
#define DMUS_PATTERN_STYLE		3

#include <time.h>	// to seed random number generator

const long MULTIPLIER = 48271;
const long MODULUS = 2147483647;

class CRandomNumbers
{
public:
	CRandomNumbers(long nSeed = 0)
	{
        nCurrent = (long)(nSeed ? nSeed : time(NULL));
	}

	void Seed(long nSeed)
	{
		nCurrent = nSeed;
	}

	long Next(long nCeiling = 0)
	{
		LONGLONG llProduct = MULTIPLIER * (LONGLONG) nCurrent;
		nCurrent = (long) (llProduct % MODULUS);
		return nCeiling ? nCurrent % nCeiling : nCurrent;
	}

private:
	long nCurrent;
};

struct PatternTrackState;

struct StylePair
{
	StylePair() : m_mtTime(0), m_pStyle(NULL) {}
	~StylePair() { if (m_pStyle) m_pStyle->Release(); }

	MUSIC_TIME	m_mtTime;
	IDMStyle*	m_pStyle;
};

struct StatePair
{
	StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
	StatePair(const StatePair& rPair)
	{
		m_pSegState = rPair.m_pSegState;
		m_pStateData = rPair.m_pStateData;
	}
	StatePair(IDirectMusicSegmentState* pSegState, PatternTrackState* pStateData)
	{
		m_pSegState = pSegState;
		m_pStateData = pStateData;
	}
	StatePair& operator= (const StatePair& rPair)
	{
		if (this != &rPair)
		{
			m_pSegState = rPair.m_pSegState;
			m_pStateData = rPair.m_pStateData;
		}
		return *this;
	}
	~StatePair()
	{
	}
	IDirectMusicSegmentState*	m_pSegState;
	PatternTrackState*			m_pStateData;
};

struct PatternTrackInfo
{
	PatternTrackInfo();
	PatternTrackInfo(const PatternTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	virtual ~PatternTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			) = 0;

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			) = 0;

	HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  PatternTrackState*		pStateData
			);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	PatternTrackState* FindState(IDirectMusicSegmentState* pSegState);

	HRESULT MergePChannels();

	HRESULT InitTrackVariations(CDirectMusicPattern* pPattern);

	TList<StatePair>			m_StateList;	// The track's state information
	TList<StylePair>			m_pISList;	// The track's Style interfaces
	DWORD						m_dwPChannels; // # of PChannels the track knows about
	DWORD*						m_pdwPChannels;	// dynamic array of PChannels
	BOOL						m_fNotifyMeasureBeat;
	BOOL						m_fActive;
//	BOOL						m_fTrackPlay;
#ifdef DXAPI
    BOOL        m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 
#endif
//    BOOL        m_fStatePlaySetBySetParam;  // If TRUE, trackplay flag was set by GUID. Don't override. 
	BOOL		m_fChangeStateMappings;	// If TRUE, state data needs to change m_pMappings
	long		m_lRandomNumberSeed;	// If non-zero, use as a seed for variation selection
	DWORD		m_dwPatternTag;			// replaces need for dynamic casting
	DWORD		m_dwValidate; // used to validate state data
	BYTE*		m_pVariations;		// Track's array of variations (1 per part)
	DWORD*		m_pdwRemoveVariations;	// Track's array of variations already played (1 per part)

};


#define PLAYPARTSF_CLOCKTIME	0x1
#define PLAYPARTSF_FIRST_CALL	0x2
#define PLAYPARTSF_START		0x4
#define PLAYPARTSF_RELOOP		0x8
#define PLAYPARTSF_FLUSH		0x10

struct PatternTrackState
{
	PatternTrackState();
	virtual ~PatternTrackState();
	// methods
	virtual HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime

			) = 0;

	void GetNextChord(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fStart = FALSE, BOOL fSkipVariations = FALSE);

	HRESULT ResetMappings()
	{
		HRESULT hr = S_OK;
		if (m_pMappings) delete [] m_pMappings;
		m_pMappings = new MuteMapping[m_pPatternTrack->m_dwPChannels];
		if (!m_pMappings)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
			{
				m_pMappings[dw].m_mtTime = 0;
				m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
				m_pMappings[dw].m_fMute = FALSE;
			}
		}
		m_pPatternTrack->m_fChangeStateMappings = FALSE;
		return hr;
	}

	void GetNextMute(DWORD dwPart, MUSIC_TIME mtStart, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fClockTime)
	{
		HRESULT hr = S_OK;
		if (m_pPatternTrack->m_fChangeStateMappings)
		{
			hr = ResetMappings();
		}
		if (SUCCEEDED(hr))
		{
			for (DWORD dw = 0; dw < m_pPatternTrack->m_dwPChannels; dw++)
			{
				if ( (m_pPatternTrack->m_pdwPChannels[dw] == dwPart) &&
					 (0 <= m_pMappings[dw].m_mtTime && m_pMappings[dw].m_mtTime <= mtNow) )
				{
					DMUS_MUTE_PARAM MD;
					MUSIC_TIME mtNext = 0;
					MD.dwPChannel = m_pPatternTrack->m_pdwPChannels[dw];
					if (fClockTime)
					{
						MUSIC_TIME mtMusic;
						REFERENCE_TIME rtTime = (mtNow + mtOffset) * 10000;
						pPerformance->ReferenceToMusicTime(rtTime,&mtMusic);
						hr = pPerformance->GetParam(GUID_MuteParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtMusic,
													&mtNext, (void*) &MD);
						if (SUCCEEDED(hr))
						{
							REFERENCE_TIME rtNext;
							// Convert to absolute reference time.
							pPerformance->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
							rtNext -= (mtOffset * 10000);   // Subtract out to get the time from segment start.
							m_pMappings[dw].m_mtTime = (MUSIC_TIME)(rtNext / 10000);  // Convert to milliseconds. Could be problematic if there's a tempo change.
							m_pMappings[dw].m_dwPChannelMap = MD.dwPChannelMap;
							m_pMappings[dw].m_fMute = MD.fMute;
						}
						else
						{
							// If we fail, disable mapping
							m_pMappings[dw].m_mtTime = -1;
							m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
							m_pMappings[dw].m_fMute = FALSE;
						}
					}
					else
					{
						hr = pPerformance->GetParam(GUID_MuteParam, m_dwGroupID, DMUS_SEG_ANYTRACK, mtNow + mtOffset,
													&mtNext, (void*) &MD);
						if (SUCCEEDED(hr))
						{
							m_pMappings[dw].m_mtTime = (mtNext) ? (mtNext + mtNow) : 0;
							m_pMappings[dw].m_dwPChannelMap = MD.dwPChannelMap;
							m_pMappings[dw].m_fMute = MD.fMute;
						}
						else
						{
							// If we fail, disable mapping
							m_pMappings[dw].m_mtTime = -1;
							m_pMappings[dw].m_dwPChannelMap = m_pPatternTrack->m_pdwPChannels[dw];
							m_pMappings[dw].m_fMute = FALSE;
						}
					}
				}
			}
		}
	}

	
	BOOL MapPChannel(DWORD dwPChannel, DWORD& dwMapPChannel);

	HRESULT PlayParts(MUSIC_TIME mtStart, 
					  MUSIC_TIME mtFinish,
					  MUSIC_TIME mtOffset,
					  REFERENCE_TIME rtOffset,
					  MUSIC_TIME mtSection,
					  IDirectMusicPerformance* pPerformance,
					  DWORD dwPartFlags,
					  DWORD dwPlayFlags,
					  bool& rfReloop);

	void PlayPatternEvent(
		MUSIC_TIME mtNow,
		CDirectMusicEventItem* pEventItem, 
		DirectMusicTimeSig& TimeSig,
		MUSIC_TIME mtPartOffset, 
		MUSIC_TIME mtSegmentOffset, 
		REFERENCE_TIME rtOffset, 
		IDirectMusicPerformance* pPerformance,
		short nPart,
		DirectMusicPartRef& rPartRef,
		BOOL fClockTime,
		MUSIC_TIME mtPartStart,
        bool& rfChangedVariation);

	void BumpTime(
		CDirectMusicEventItem* pEvent, 
		DirectMusicTimeSig& TimeSig, 
		MUSIC_TIME mtOffset,
		MUSIC_TIME& mtResult)
	{
		if (pEvent != NULL)
		{
			mtResult = TimeSig.GridToClocks(pEvent->m_nGridStart) + mtOffset;
		}
	}

	virtual DWORD Variations(DirectMusicPartRef& rPartRef, int nPartIndex);

	virtual BOOL PlayAsIs();

	DirectMusicTimeSig& PatternTimeSig()
	{
		return
			(m_pPattern && m_pPattern->m_timeSig.m_bBeat != 0) ? 
				m_pPattern->m_timeSig : 
		(m_pStyle != NULL ? m_pStyle->m_TimeSignature : (::DefaultTimeSig));
	}

	void SendTimeSigMessage(MUSIC_TIME mtNow, MUSIC_TIME mtOffset, MUSIC_TIME mtTime, IDirectMusicPerformance* pPerformance);

	short FindGroup(WORD wID);
	short AddGroup(WORD wID, WORD wCount, short m_nOffset);
	DMStyleStruct* FindStyle(MUSIC_TIME mtTime, MUSIC_TIME& rmtTime);

	MUSIC_TIME NotifyMeasureBeat(
		MUSIC_TIME mtStart, MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, DWORD dwFlags);

	HRESULT InitVariationSeeds(long lBaseSeed);
	HRESULT RemoveVariationSeeds();
	long RandomVariation(MUSIC_TIME mtTime, long lModulus);
	virtual MUSIC_TIME PartOffset(int nPartIndex);
	HRESULT InitPattern(CDirectMusicPattern* pTargetPattern, MUSIC_TIME mtNow, CDirectMusicPattern* pOldPattern = NULL);

	// attributes
	PatternTrackInfo*			m_pPatternTrack;	// This track state's parent track info
	IDirectMusicTrack*			m_pTrack;			// This track state's parent track
	DMStyleStruct*				m_pStyle;		// The style struct for the current style
	IDirectMusicSegmentState*	m_pSegState;	// The segment state for a performance
	DWORD						m_dwVirtualTrackID; // The track's ID
	MUSIC_TIME					m_mtCurrentChordTime; // when the current chord began
	MUSIC_TIME					m_mtNextChordTime;	// when the next chord begins
	MUSIC_TIME					m_mtLaterChordTime;	// when the chord after the next chord begins
	DMUS_CHORD_PARAM			m_CurrentChord;		// current chord
	DMUS_CHORD_PARAM			m_NextChord;		// next chord
	CDirectMusicPattern*		m_pPattern;			// currently playing pattern
	DWORD*						m_pdwPChannels;     // array of PChannels for the pattern (1 per part)
	BYTE*						m_pVariations;		// array of variations (1 per part)
	DWORD*						m_pdwVariationMask;	// array of disabled variations (1 per part)
	DWORD*						m_pdwRemoveVariations;	// array of variations already played (1 per part)
	MUSIC_TIME*					m_pmtPartOffset;	// array of part offsets (1 per part)
    bool*                       m_pfChangedVariation; // array: have this part's variations changed?
	BOOL						m_fNewPattern;		// TRUE if we're starting a new pattern
	BOOL						m_mtPatternStart;	// Time the current pattern started
    BOOL                        m_fStateActive;
//    BOOL                        m_fStatePlay;
	InversionGroup				m_aInversionGroups[INVERSIONGROUPLIMIT];
	short						m_nInversionGroupCount;
	MuteMapping*				m_pMappings;		// dynamic array of PChannel mappings
													// (sized to # of PChannels)
	BYTE						m_abVariationGroups[MAX_VARIATION_LOCKS];
	CDirectMusicEventItem**		m_ppEventSeek;		// dynamic array of event list seek pointers
	DWORD						m_dwGroupID;		// Track's group ID
	CRandomNumbers*				m_plVariationSeeds;	// dynamic array of random # generators (1 per beat)
	int							m_nTotalGenerators; // size of m_plVariationSeeds
	DWORD						m_dwValidate; // used to validate state data
	HRESULT						m_hrPlayCode;  // last HRESULT returned by Play
	IDirectMusicPerformance*	m_pPerformance; // performance used to init the state data
	MUSIC_TIME					m_mtPerformanceOffset; // from track::play
	
};

const int CURVE_TYPES = 258; // one for each CC, one for each PAT, one for PB, one for MAT

class CurveSeek
{
public:
	CurveSeek();
	void AddCurve(CDirectMusicEventItem* pEvent, MUSIC_TIME mtTimeStamp);
	void PlayCurves(
		PatternTrackState* pStateData,
		DirectMusicTimeSig& TimeSig,
		MUSIC_TIME mtPatternOffset, 
		MUSIC_TIME mtOffset, 
		REFERENCE_TIME rtOffset,
		IDirectMusicPerformance* pPerformance,
		short nPart,
		DirectMusicPartRef& rPartRef,
		BOOL fClockTime,
		MUSIC_TIME mtPartStart);
private:
	CDirectMusicEventItem* m_apCurves[CURVE_TYPES];
	MUSIC_TIME m_amtTimeStamps[CURVE_TYPES];
	bool m_fFoundCurve;
};

#endif //__PATTERNTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\common.h ===
// Copyright (c) 1998 Microsoft Corporation
#ifndef _COMMON_H_
#define _COMMON_H_


#if (DBG)
#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_VERBOSE
#endif
#endif

#include <winerror.h>


#include "portcls.h"
#include "ksdebug.h"
#include <dmusicks.h>       // Ks defines
#include <dmerror.h>        // Error codes
#include <dmdls.h>          // DLS definitions

#include "kernhelp.h"
#include "CSynth.h"
#include "synth.h"
#include "float.h"
#include "muldiv32.h"
#include "SysLink.h"

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\styletrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       styletrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// StyleTrack.cpp : Implementation of CStyleTrack
#include "StyleTrk.h"
#include "dmusicc.h"
#include <stdlib.h> // for random number generator
#include <time.h>   // to seed random number generator
#include "debug.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "..\shared\critsec.h"
#include "..\shared\miscutil.h"

/////////////////////////////////////////////////////////////////////////////
// StyleTrackState

StyleTrackState::StyleTrackState() : 
    m_mtSectionOffset(0), m_mtSectionOffsetTemp(0), m_mtOverlap(0),
    m_mtNextCommandTemp(0),
    m_mtNextCommandTime(0),
    m_mtNextStyleTime(0)
{
    ZeroMemory(&m_CommandData , sizeof(m_CommandData));
}

StyleTrackState::~StyleTrackState()
{
    m_PlayedPatterns.CleanUp();
}

HRESULT StyleTrackState::Play(
                          MUSIC_TIME                mtStart, 
                          MUSIC_TIME                mtEnd, 
                          MUSIC_TIME                mtOffset,
                          REFERENCE_TIME rtOffset,
                          IDirectMusicPerformance* pPerformance,
                          DWORD                     dwFlags,
                          BOOL fClockTime
            )
{
    m_mtPerformanceOffset = mtOffset;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
    BOOL fFlush = (dwFlags & DMUS_TRACKF_FLUSH) ? TRUE : FALSE;
    BOOL fDirty = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    HRESULT hr = S_OK;
    TraceI(4, "Play [%d:%d @ %d]\n", mtStart, mtEnd, mtOffset);
    if (m_mtNextCommandTime == 0)
    {
        MUSIC_TIME mtBarLength = m_pStyle ? PatternTimeSig().ClocksPerMeasure() : 0;
        DMUS_COMMAND_PARAM_2 TempCommand;
        HRESULT hrCommand = E_FAIL;
        if (fDirty || fFlush)
        {
            char chGroove;
            HRESULT hrGroove = pPerformance->GetGlobalParam((GUID)GUID_PerfMasterGrooveLevel, &chGroove, 1);
            if (!SUCCEEDED(hrGroove)) chGroove = 0;
            BYTE bActualCommand = m_CommandData.bCommand;
            if (m_pStyle)
            {
                hrCommand = m_pStyle->GetCommand(mtStart, mtOffset, pPerformance, NULL, m_dwGroupID, &TempCommand, bActualCommand);
            }
            if (!fDirty && hrCommand == S_OK)
            {
                // Avoid getting a pattern that's the same as the current one.
                if (TempCommand.bGrooveLevel + chGroove == m_CommandData.bGrooveLevel &&
                    bActualCommand == m_CommandData.bCommand)
                {
                    hrCommand = E_FAIL;
                }
            }
        }
        MUSIC_TIME mtFirstCommand = 0;
        if (fStart || fLoop)
        {
            m_mtNextCommandTime = 0;
        }
        else
        {
            mtFirstCommand = mtStart;
            m_mtNextCommandTime = (mtBarLength) ? ((mtStart / mtBarLength) * mtBarLength) : 0;
        }
        if (fStart || fLoop || mtStart == 0 || hrCommand == S_OK || mtStart >= m_mtNextCommandTemp)
        {
            hr = GetNextPattern(dwFlags, mtFirstCommand, mtOffset, pPerformance, fLoop);
            if ( m_pPattern && mtStart > 0 &&  (fSeek || fDirty) )
            {
                while (SUCCEEDED(hr) && mtStart >= m_mtNextCommandTime)
                {
                    hr = GetNextPattern(dwFlags, m_mtNextCommandTime, mtOffset, pPerformance, fLoop);
                }
            }
            fDirty = fDirty || fLoop; // make sure we get new variations if we skipped them above
        }
        else
        {
            m_mtNextCommandTime = m_mtNextCommandTemp;
            m_mtNextCommandTemp = 0;
            m_mtSectionOffset = m_mtSectionOffsetTemp;
            m_mtSectionOffsetTemp = 0;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (fDirty) // We need to make sure we get chords on beat boundaries
        {
            GetNextChord(mtStart, mtOffset, pPerformance, fStart);
        }
        // for each part, play the events between start and end in the corresponding list
        // get new chords and commands when necessary
        MUSIC_TIME mtLast = m_mtNextCommandTime;
        bool fReLoop = false;
        MUSIC_TIME mtNotify = mtStart ? PatternTimeSig().CeilingBeat(mtStart) : 0;
        if( m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && 
            ( mtNotify < mtEnd ) )
        {
            mtNotify = NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
        }

        DWORD dwPartFlags = PLAYPARTSF_FIRST_CALL;
        if (fStart || fLoop || fSeek) dwPartFlags |= PLAYPARTSF_START;
        if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
        if ( fLoop || (mtStart > 0 &&  (fStart || fSeek || fDirty)) ) dwPartFlags |= PLAYPARTSF_FLUSH;
        MUSIC_TIME mtPartLast = min(mtEnd, mtLast);
        PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);

        // If we need to reloop any parts, do it
        if (fReLoop)
        {
            dwPartFlags = PLAYPARTSF_RELOOP;
            if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
            PlayParts(mtStart, mtPartLast, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
        }

        // If we need to get a new command, we do it after all the events in all the parts
        // have run. And then we need to run all events from command start to mtEnd.
        if (mtStart <= m_mtNextCommandTime && m_mtNextCommandTime < mtEnd)
        {
            hr = GetNextPattern(dwFlags & ~DMUS_TRACKF_START, m_mtNextCommandTime, mtOffset, pPerformance);
            if (SUCCEEDED(hr))
            {
                dwPartFlags = 0;
                if (fClockTime) dwPartFlags |= PLAYPARTSF_CLOCKTIME;
                PlayParts(mtStart, mtEnd, mtOffset, rtOffset, m_mtSectionOffset, pPerformance, dwPartFlags, dwFlags, fReLoop);
            }
        }
        if( SUCCEEDED(hr) &&
            m_fStateActive && m_pPatternTrack->m_fNotifyMeasureBeat && 
            ( mtNotify < mtEnd ) )
        {
            NotifyMeasureBeat( mtNotify, mtEnd, mtOffset, pPerformance, dwFlags );
        }
    }
    m_hrPlayCode = hr;
    return hr;
}


HRESULT StyleTrackState::GetNextPattern(DWORD dwFlags, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fSkipVariations)
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
//    bool fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? TRUE : FALSE;
//    bool fFlush = (dwFlags & DMUS_TRACKF_FLUSH) ? TRUE : FALSE;
    bool fDirty = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    bool fNewMode = fStart || fDirty;
     // It doesn't seem to make sense to use anything other than the style's time signature
    // when looking for a new pattern.
    //TraceI(1, "New pattern at %d\n", mtNow);
    DMStyleStruct* pOldStyle = m_pStyle;
    if (m_mtNextStyleTime && mtNow >= m_mtNextStyleTime)
    {
        //TraceI(0, "New Style (%d) [%d]\n", m_mtNextStyleTime, mtNow);
        DMStyleStruct* pStyle = FindStyle(mtNow, m_mtNextStyleTime);
        if (!pStyle)
        {
            return E_POINTER; 
        }
        else
        {
            m_pStyle = pStyle;
            fNewMode = true;
        }
        if (m_fStateActive) // if timesig events are enabled...
        {
            SendTimeSigMessage(mtNow, mtOffset, m_mtNextStyleTime, pPerformance);
        }
    }
    MUSIC_TIME mtOldMeasureTime = m_pPattern ? m_pPattern->TimeSignature(pOldStyle).ClocksPerMeasure() : m_pStyle->m_TimeSignature.ClocksPerMeasure();
    CDirectMusicPattern* pOldPattern = m_pPattern;
    CDirectMusicPattern* pTargetPattern = NULL;
    MUSIC_TIME mtMeasureTime = 0, mtNextCommand = 0;
    HRESULT hr = m_pStyle->GetPattern(fNewMode, mtNow, mtOffset, this, pPerformance, NULL, pTargetPattern, mtMeasureTime, mtNextCommand);

    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtSectionOffset = (!fDirty || m_mtSectionOffset || fLoop) ? m_mtSectionOffset : m_mtSectionOffsetTemp;
        MUSIC_TIME mtOldPatternEnd = (!fStart && !fLoop && pOldPattern) ? mtSectionOffset + (pOldPattern->m_wNumMeasures *  mtOldMeasureTime) : 0;
        MUSIC_TIME mtNewPatternLength = pTargetPattern->m_wNumMeasures * mtMeasureTime;
        MUSIC_TIME mtOverlap = 0;
        if (m_mtOverlap && fDirty) // assumes 1 controlling segment w/command track at a time
        {
            if (m_pStyle->UsingDX8())
            {
                mtOverlap = mtMeasureTime - (m_mtOverlap % mtMeasureTime);
            }
            m_mtOverlap = 0;
            //TraceI(0, "[1]Overlap: %d\n", mtOverlap);
        }
        else if (mtNow < mtOldPatternEnd && 
                 m_pStyle->UsingDX8() )
        {
            mtOverlap = mtOldPatternEnd - mtNow;
            if (fDirty)
            {
                m_mtOverlap = mtOverlap;
                mtOverlap = 0;
            }
            else
            {
                mtOverlap = (mtMeasureTime - (mtOverlap % mtMeasureTime)) % mtMeasureTime;
            }
            //TraceI(0, "[2]Overlap: %d\n", fDirty ? m_mtOverlap : mtOverlap);
        }

        // Whenever I get a new pattern, I should get a new chord
        GetNextChord(mtNow, mtOffset, pPerformance, fStart, fSkipVariations);
        if (fDirty)
        {
            m_mtSectionOffset = mtNow - mtOverlap;
        }
        else
        {
            m_mtSectionOffset = m_mtNextCommandTime - mtOverlap; // keep the section offset on a measure boundary
        }
        m_mtNextCommandTime = m_mtSectionOffset + mtNewPatternLength;
        // Note: at this point mtNextCommand == m_mtNextStyleTime - mtNow,
        // if that difference is smaller than the original value for mtNextCommand.
        if (mtNextCommand && m_mtNextCommandTime > mtNow + mtNextCommand)
        {
            m_mtNextCommandTime = mtNow + mtNextCommand;
        }
        TraceI(3, "Next Command Time: %d Measures: %d Measure time: %d\n", 
//      TraceI(0, "Next Command Time: %d Measures: %d Measure time: %d\n", 
            m_mtNextCommandTime, m_pPattern->m_wNumMeasures, mtMeasureTime);
        return S_OK;
    }
    else return E_POINTER;
}

MUSIC_TIME StyleTrackState::PartOffset(int nPartIndex)
{
    return m_pmtPartOffset[nPartIndex] + m_mtSectionOffset;
}

/////////////////////////////////////////////////////////////////////////////
// StyleTrackInfo

StyleTrackInfo::StyleTrackInfo() 
{
    m_dwPatternTag = DMUS_PATTERN_STYLE;
}

StyleTrackInfo::~StyleTrackInfo()
{
}

HRESULT StyleTrackInfo::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK;
}

HRESULT StyleTrackInfo::InitPlay(
                /*[in]*/  IDirectMusicTrack*        pParentrack,
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    IDirectMusicSegment* pSegment = NULL;
    StyleTrackState* pStateData = new StyleTrackState;
    if( NULL == pStateData )
    {
        return E_OUTOFMEMORY;
    }
    pStateData->m_dwValidate = m_dwValidate;
    StatePair SP(pSegmentState, pStateData);
    TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
    if (!pPair)
    {
        delete pStateData;
        return E_OUTOFMEMORY;
    }
    m_StateList.AddHead(pPair);
    pStateData->m_pTrack = pParentrack;
    pStateData->m_pPatternTrack = this;
    pStateData->m_dwVirtualTrackID = dwTrackID;
    pStateData->m_mtNextStyleTime = 0;
    pStateData->m_pStyle = pStateData->FindStyle(0, pStateData->m_mtNextStyleTime);
    if (!pStateData->m_pStyle)
    {
        delete pStateData;
        return E_POINTER;
    }
    pStateData->m_pPattern = NULL;
    pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
    pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
    pStateData->m_mtPerformanceOffset = 0;
    pStateData->m_mtCurrentChordTime = 0;
    pStateData->m_mtNextChordTime = 0;
    pStateData->m_mtPatternStart = 0;
    pStateData->m_mtSectionOffset = 0;
    pStateData->m_mtSectionOffsetTemp = 0;
    pStateData->m_mtOverlap = 0;
    HRESULT hr = pStateData->ResetMappings();
    if (FAILED(hr))
    {
        delete pStateData;
        return hr;
    }
#ifdef DXAPI
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fStateActive = m_fActive;
    }
    else
#endif
    {
        pStateData->m_fStateActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
    if (m_lRandomNumberSeed)
    {
        pStateData->InitVariationSeeds(m_lRandomNumberSeed);
    }
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        if (FAILED(pSegment->GetTrackGroup(pStateData->m_pTrack, &pStateData->m_dwGroupID)))
        {
            pStateData->m_dwGroupID = 0xffffffff;
        }
        pSegment->Release();
    }

    *ppStateData = pStateData;
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CStyleTrack

CStyleTrack::CStyleTrack() : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    dm_srand((unsigned int)time(NULL));
    m_pTrackInfo = new StyleTrackInfo;
//  assert (m_pTrackInfo);
}

CStyleTrack::CStyleTrack(const CStyleTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_cRef(1), m_fCSInitialized(FALSE)
{
    IncrementDLLCount();

    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    dm_srand((unsigned int)time(NULL));
    m_pTrackInfo = new StyleTrackInfo((StyleTrackInfo*)rTrack.m_pTrackInfo, mtStart, mtEnd);
}

CStyleTrack::~CStyleTrack()
{
    if (m_pTrackInfo)
    {
        delete m_pTrackInfo;
    }
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    DecrementDLLCount();
}

// CStyleTrack Methods

STDMETHODIMP CStyleTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CStyleTrack::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IStyleTrack)
    {
        *ppv = static_cast<IStyleTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CStyleTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CStyleTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init

HRESULT CStyleTrack::Init( 
    /* [in] */ IDirectMusicSegment __RPC_FAR *pSegment)
{
    V_INAME(CStyleTrack::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    if (m_pTrackInfo == NULL)
        return DMUS_E_NOT_INIT;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    hr = m_pTrackInfo->MergePChannels();
    if (SUCCEEDED(hr))
    {
        pSegment->SetPChannelsUsed(m_pTrackInfo->m_dwPChannels, m_pTrackInfo->m_pdwPChannels);
        hr = m_pTrackInfo->Init(pSegment);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

    return hr;
}

HRESULT CStyleTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    V_INAME(CStyleTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo == NULL)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    hr = m_pTrackInfo->InitPlay(this, pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;

}

HRESULT CStyleTrack::EndPlay(
                /*[in]*/  void*     pStateData
            )
{
    V_INAME(CStyleTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StyleTrackState));

    HRESULT hr = DMUS_E_NOT_INIT;
    StyleTrackState* pSD = (StyleTrackState*)pStateData;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
//  if (pSD->m_pPattern) pSD->m_pPattern->Release();
    if (m_pTrackInfo) hr = m_pTrackInfo->EndPlay(pSD);
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CStyleTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    V_INAME(CStyleTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StyleTrackState));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegState);

    HRESULT hr = DMUS_E_NOT_INIT;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    BOOL fStart = (dwFlags & DMUS_TRACKF_START) ? TRUE : FALSE;
    BOOL fControl = (dwFlags & DMUS_TRACKF_DIRTY) ? TRUE : FALSE;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    StyleTrackState* pSD = (StyleTrackState *)pStateData;
    if (pSD->m_hrPlayCode == E_OUTOFMEMORY)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return pSD->m_hrPlayCode;
    }
    if (pSD->m_dwValidate != m_pTrackInfo->m_dwValidate)
    {
        // new style added to track either via SetParam or Load.  Resync state data.
        pSD->m_pStyle = pSD->FindStyle(mtStart, pSD->m_mtNextStyleTime);
        if (!pSD->m_pStyle)
        {
            hr = E_POINTER;
        }
        pSD->m_dwValidate = m_pTrackInfo->m_dwValidate;
    }
    if ((hr == DMUS_E_NOT_INIT) && pSD && pSD->m_pMappings)
    {
        if (fStart || fSeek || fControl)
        {
            pSD->m_mtSectionOffsetTemp = pSD->m_mtSectionOffset;
            pSD->m_mtSectionOffset = 0;
            pSD->m_mtNextCommandTemp = pSD->m_mtNextCommandTime;
            pSD->m_mtNextCommandTime = 0;
            pSD->m_pStyle = pSD->FindStyle(0, pSD->m_mtNextStyleTime);
            if (!pSD->m_pStyle)
            {
                hr = E_POINTER;
            }
            else
            {
                if (pSD->m_fStateActive) // if timesig events are enabled...
                {
                    pSD->SendTimeSigMessage(mtStart, mtOffset, pSD->m_mtNextStyleTime, pPerf);
                }
                pSD->m_mtCurrentChordTime = 0;
                pSD->m_mtNextChordTime = 0;
                pSD->m_mtLaterChordTime = 0;
//              pSD->m_CurrentChord.bSubChordCount = 0;
                pSD->m_mtPatternStart = 0;
                for (DWORD dw = 0; dw < m_pTrackInfo->m_dwPChannels; dw++)
                {
                    pSD->m_pMappings[dw].m_mtTime = 0;
                    pSD->m_pMappings[dw].m_dwPChannelMap = m_pTrackInfo->m_pdwPChannels[dw];
                    pSD->m_pMappings[dw].m_fMute = FALSE;
                }
            }
        }
        hr = ((StyleTrackState *)pStateData)->Play(mtStart, mtEnd, mtOffset, 0, pPerf, dwFlags, FALSE);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CStyleTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CStyleTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData,
    void* pStateData)
{
    V_INAME(CStyleTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_PTR_WRITE_OPT(pStateData,1);
    V_REFGUID(rCommandGuid);

    HRESULT hr;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    bool fInCritSection = true;
    if (rCommandGuid == GUID_IDirectMusicStyle)
    {
        if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime && rScan.m_pStyle) break;  // ignore if NULL
                    if (rScan.m_pStyle) pStyle = rScan.m_pStyle; // skip if NULL
                }
                IDirectMusicStyle* pDMStyle;
                if (!pStyle) 
                {
                    hr = E_POINTER;
                }
                else
                {
                    pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                    // Note: QI with no Release has the effect of an AddRef
                    *(IDirectMusicStyle**)pData = pDMStyle;
                    if (pmtNext)
                    {
                        *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime - mtTime : 0;
                    }
                    hr = S_OK;
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_TimeSignature)
    {
        // find the style at the given time, and return its time sig.
        if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                MUSIC_TIME mtStyleTime = pScan->GetItemValue().m_mtTime;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                    mtStyleTime = rScan.m_mtTime;
                }
                if (!pStyle)
                {
                    hr = E_POINTER;
                }
                else
                {
                    // Enter the style's CritSec
                    pStyle->CritSec(true);
                    // If I've got state data, use it to get the time signature of the pattern at mtTime
                    if (pStateData)
                    {
                        MUSIC_TIME mtMeasureTime = 0;
                        MUSIC_TIME mtNext = 0;
                        CDirectMusicPattern* pTargetPattern;
                        StyleTrackState* pStyleTrackState = (StyleTrackState*)pStateData;
                        IDirectMusicPerformance* pPerformance = pStyleTrackState->m_pPerformance;
                        MUSIC_TIME mtOffset = pStyleTrackState->m_mtPerformanceOffset;
                        DMStyleStruct* pStyleStruct = NULL;
                        hr = pStyle->GetStyleInfo((void**)&pStyleStruct);
                        if (SUCCEEDED(hr))
                        {
                            // I don't need the Track CritSec any more, and in fact there's an almost 
                            // guaranteed deadlock if I keep it, so get rid of it
                            LEAVE_CRITICAL_SECTION( &m_CriticalSection );
                            fInCritSection = false;
                            hr = pStyleStruct->GetPattern(true, mtTime, mtOffset, NULL,
                                pPerformance, NULL, pTargetPattern, mtMeasureTime, mtNext);
                            if (SUCCEEDED(hr))
                            {
                                DMUS_TIMESIGNATURE* pTimeSig = (DMUS_TIMESIGNATURE*)pData;
                                *pTimeSig = pTargetPattern->TimeSignature(pStyleStruct);
                                pTimeSig->mtTime = mtStyleTime - mtTime;
                                //TraceI(0, "New Time sig from pattern...\n");
                                if (pmtNext)
                                {
                                    *pmtNext = mtNext;
                                }
                            }
                        }
                    }
                    else // Just get the style's time signature
                    {
                        IDirectMusicStyle* pDMStyle;
                        hr = pStyle->QueryInterface(IID_IDirectMusicStyle, (void**)&pDMStyle);
                        if (SUCCEEDED(hr))
                        {
                            hr = pDMStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pData);
                            if (SUCCEEDED(hr))
                            {
                                ((DMUS_TIMESIGNATURE*)pData)->mtTime = mtStyleTime - mtTime;
                                if (pmtNext)
                                {
                                    *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime : 0;
                                }
                            }
                            pDMStyle->Release();
                        }
                    }
                    // Leave the style's CritSec
                    pStyle->CritSec(false);
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_SegmentTimeSig)
    {
        SegmentTimeSig* pTimeSigParam = (SegmentTimeSig*)pData;
        if (!pTimeSigParam->pSegment) hr = E_POINTER;
        // find the style at the given time, and return the time sig currently in effect in the segment.
        else if (m_pTrackInfo)
        {
            TListItem<StylePair>* pScan = m_pTrackInfo->m_pISList.GetHead();
            if (pScan)
            {
                IDMStyle* pStyle = pScan->GetItemValue().m_pStyle;
                MUSIC_TIME mtStyleTime = pScan->GetItemValue().m_mtTime;
                for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
                {
                    StylePair& rScan = pScan->GetItemValue();
                    if (mtTime < rScan.m_mtTime) break;
                    pStyle = rScan.m_pStyle;
                    mtStyleTime = rScan.m_mtTime;
                }
                if (!pStyle)
                {
                    hr = E_POINTER;
                }
                else
                {
                    DMStyleStruct* pStyleStruct = NULL;
                    hr = pStyle->GetStyleInfo((void**)&pStyleStruct);
                    if (SUCCEEDED(hr))
                    {
                        CDirectMusicPattern* pPattern = NULL;
                        MUSIC_TIME mtMeasureTime = 0, mtNextCommand = 0;
                        hr = pStyleStruct->GetPattern(true, mtTime, 0, NULL, NULL, pTimeSigParam->pSegment,
                            pPattern, mtMeasureTime, mtNextCommand);
                        if (SUCCEEDED(hr))
                        {
                            pTimeSigParam->TimeSig = pPattern->m_timeSig;
                            pTimeSigParam->TimeSig.mtTime = mtStyleTime  - mtTime;
                            if (pmtNext)
                            {
                                *pmtNext = (mtNextCommand) ? mtNextCommand - mtTime : 0;
                            }
                        }
                    }
                }
            }
            else hr = DMUS_E_NOT_FOUND;
        }
        else hr = DMUS_E_NOT_INIT;
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    if (fInCritSection) 
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    }
    return hr;

} 

HRESULT CStyleTrack::SetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CStyleTrack::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rCommandGuid);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        hr = DMUS_E_NOT_INIT;
    }
    else if (rCommandGuid == GUID_IDirectMusicStyle)
    {
        if (!pData)
        {
            hr = E_POINTER;
        }
        else
        {
            IDirectMusicStyle* pStyle = (IDirectMusicStyle*)pData;
            IDMStyle* pIS = NULL;
            pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
            TListItem<StylePair>* pNew = new TListItem<StylePair>;
            if (!pNew)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pNew->GetItemValue().m_mtTime = mtTime;
                pNew->GetItemValue().m_pStyle = pIS;
                m_pTrackInfo->m_pISList.AddTail(pNew);
                m_pTrackInfo->m_dwValidate++;

                hr = m_pTrackInfo->MergePChannels();
            }
        }
    }
#ifdef DXAPI
    else if( rCommandGuid == GUID_EnableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rCommandGuid == GUID_DisableTimeSig )
    {
        if( m_pTrackInfo->m_fStateSetBySetParam && !m_pTrackInfo->m_fActive )
        {
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_pTrackInfo->m_fStateSetBySetParam = TRUE;
            m_pTrackInfo->m_fActive = FALSE;
            hr = S_OK;
        }
    }
#endif
    else if ( rCommandGuid == GUID_SeedVariations )
    {
        if (pData)
        {
            m_pTrackInfo->m_lRandomNumberSeed = *((long*) pData);
            hr = S_OK;
        }
        else hr = E_POINTER;
    }
    else
    {
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CStyleTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CStyleTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicStyleTrack;
    return S_OK;
}

HRESULT CStyleTrack::IsParamSupported(
                /*[in]*/ REFGUID    rGuid
            )
{
    V_INAME(CStyleTrack::IsParamSupported);
    V_REFGUID(rGuid);


    if (!m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }

    if (rGuid == GUID_IDirectMusicStyle ||
        rGuid == GUID_SeedVariations ||
        rGuid == GUID_SegmentTimeSig )
    {
        return S_OK;
    }
#ifdef DXAPI
    else if (m_pTrackInfo->m_fStateSetBySetParam)
    {
        if( m_pTrackInfo->m_fActive )
        {
            if( rGuid == GUID_DisableTimeSig ) return S_OK;
            if( rGuid == GUID_TimeSignature ) return S_OK;
            if( rGuid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rGuid == GUID_EnableTimeSig ) return S_OK;
            if( rGuid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
            if( rGuid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if( ( rGuid == GUID_DisableTimeSig ) ||
            ( rGuid == GUID_TimeSignature ) ||
            ( rGuid == GUID_EnableTimeSig )) return S_OK;
    }
#else
    if (rGuid == GUID_TimeSignature) 
    {
        return S_OK;
    }
#endif
    return DMUS_E_TYPE_UNSUPPORTED;

}

// IPersistStream methods
 HRESULT CStyleTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CStyleTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{

    return E_NOTIMPL;
}

HRESULT CStyleTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

BOOL Less(StylePair& SP1, StylePair& SP2)
{ return SP1.m_mtTime < SP2.m_mtTime; }

HRESULT CStyleTrack::Load(LPSTREAM pStream )
{
    V_INAME(CStyleTrack::Load);
    V_INTERFACE(pStream);

    IAARIFFStream*  pIRiffStream;
    //MMCKINFO      ckMain;
    MMCKINFO        ck;
    HRESULT         hr = E_FAIL;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    StyleTrackInfo* pTrackInfo = (StyleTrackInfo*)m_pTrackInfo;
    if (m_pTrackInfo->m_dwPatternTag != DMUS_PATTERN_STYLE)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_FAIL;
    }
    pTrackInfo->m_pISList.CleanUp();

    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        if (pIRiffStream->Descend( &ck, NULL, 0 ) == 0)
        {
            if (ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_STYLE_TRACK_LIST)
            {
                hr = pTrackInfo->LoadStyleRefList(pIRiffStream, &ck);
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Release();
    }
    if (SUCCEEDED(hr))
    {
        pTrackInfo->m_pISList.MergeSort(Less);
        m_pTrackInfo->m_dwValidate++;

        hr = m_pTrackInfo->MergePChannels();
    }
    
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT StyleTrackInfo::LoadStyleRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    HRESULT hrStyle = E_FAIL;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;

    while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
    {
        if ( ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_STYLE_REF_LIST )
        {
            hr = LoadStyleRef(pIRiffStream, &ck);
            if (hr == S_OK)
            {
                hrStyle = hr;
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Ascend( &ck, 0 );
    }

    if (hr != S_OK && hrStyle == S_OK)
    {
        hr = hrStyle;
    }
    return hr;
}

HRESULT StyleTrackInfo::LoadStyleRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    HRESULT hrStyle = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    IDMStyle* pStyle = NULL;
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew) return E_OUTOFMEMORY;
    StylePair& rNew = pNew->GetItemValue();
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case DMUS_FOURCC_TIME_STAMP_CHUNK:
            {
                DWORD dwTime;
                DWORD cb;
                hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
                if (FAILED(hr) || cb != sizeof( dwTime ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rNew.m_mtTime = dwTime;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                hr = LoadReference(pIStream, pIRiffStream, ck, &pStyle);
                if (hr != S_OK)
                {
                    hrStyle = hr;
                }
                if (SUCCEEDED(hr))
                {
                    rNew.m_pStyle = pStyle;
                }
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    if (SUCCEEDED(hr))
    {
        m_pISList.AddTail(pNew);
    }
    else
    {
        delete pNew;
    }
ON_END:
    pIStream->Release();
    if (hr == S_OK && hrStyle != S_OK)
    {
        hr = hrStyle;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// StyleTrackInfo::LoadReference

HRESULT StyleTrackInfo::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         IDMStyle** ppStyle)
{
    if (!pStream || !pIRiffStream || !ppStyle) return E_INVALIDARG;

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader; 
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release(); 
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;
    
    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;
        
    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    
        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDMStyle, (void**)ppStyle);
        if(SUCCEEDED(hr))
        {
            DMStyleStruct* pStyle;
            (*ppStyle)->GetStyleInfo((void **)&pStyle);
            TListItem<DirectMusicPart*>* pPart;
            for(pPart = pStyle->m_PartList.GetHead(); pPart != NULL; pPart = pPart->GetNext())
            {
                DirectMusicPart* pPattern = pPart->GetItemValue();
                DirectMusicTimeSig& TimeSig = 
                    pPattern->m_timeSig.m_bBeat == 0 ? pStyle->m_TimeSignature : pPattern->m_timeSig;
                pPattern->EventList.MergeSort(TimeSig);
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::AddNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CStyleTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->AddNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::RemoveNotificationType(
    /* [in] */  REFGUID rGuidNotify)
{
    V_INAME(CStyleTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (m_pTrackInfo)
        hr = m_pTrackInfo->RemoveNotificationType(rGuidNotify);
    else
        hr = DMUS_E_NOT_INIT;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CStyleTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CStyleTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CStyleTrack *pDM;
    
    try
    {
        pDM = new CStyleTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );

    return hr;
}

STDMETHODIMP  CStyleTrack::SetTrack(IUnknown* pStyle)
{
    if (!pStyle) return E_POINTER;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo) 
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    IDMStyle* pIS = NULL;
    pStyle->QueryInterface(IID_IDMStyle, (void**)&pIS);
    TListItem<StylePair>* pNew = new TListItem<StylePair>;
    if (!pNew)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    pNew->GetItemValue().m_mtTime = 0;
    pNew->GetItemValue().m_pStyle = pIS;
    m_pTrackInfo->m_pISList.AddTail(pNew);
    if (pIS) pIS->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return S_OK;
}

// this gets the first style in the track's list.
STDMETHODIMP CStyleTrack::GetStyle(IUnknown * * ppStyle)
{
    HRESULT hr;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if (!m_pTrackInfo) 
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pHead = m_pTrackInfo->m_pISList.GetHead();
    if (pHead && pHead->GetItemValue().m_pStyle)
    {
        IUnknown* pIDMS = NULL;
        hr = pHead->GetItemValue().m_pStyle->QueryInterface(IID_IUnknown, (void**)&pIDMS);
        if (SUCCEEDED(hr))
        {
            *ppStyle = pIDMS;
            pIDMS->Release();
            hr = S_OK;
        }
    }
    else
        hr = E_FAIL;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

// need this for state data, not clock time
STDMETHODIMP CStyleTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    MUSIC_TIME mtNext = 0;
    HRESULT hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam, pStateData);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// only needed because we needed to pass state data into GetParam
STDMETHODIMP CStyleTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// only needed because we needed to pass state data into GetParam
STDMETHODIMP CStyleTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CStyleTrack::GetParam( 
    REFGUID rCommandGuid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    return GetParam(rCommandGuid, mtTime, pmtNext, pData, NULL);
}

STDMETHODIMP CStyleTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CStyleTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CStyleTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CStyleTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CStyleTrack* pOtherTrack = (CStyleTrack*)pNewTrack;
    if (!m_pTrackInfo || !pOtherTrack->m_pTrackInfo)
    {
        return DMUS_E_NOT_INIT;
    }
    TListItem<StylePair>* pScan = pOtherTrack->m_pTrackInfo->m_pISList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        StylePair& rScan = pScan->GetItemValue();
        TListItem<StylePair>* pNew = new TListItem<StylePair>;
        if (pNew)
        {
            StylePair& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_pStyle = rScan.m_pStyle;
            if (rNew.m_pStyle) rNew.m_pStyle->AddRef();
            m_pTrackInfo->m_pISList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\styletrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       styletrk.h
//
//--------------------------------------------------------------------------

// StyleTrack.h : Declaration of the CStyleTrack

#ifndef __STYLETRACK_H_
#define __STYLETRACK_H_

#include "PtrnTrk.h"
#include "dmusicip.h"
#include "dmstylep.h"

struct StyleTrackInfo : public PatternTrackInfo
{
	StyleTrackInfo();
	StyleTrackInfo(const StyleTrackInfo* pInfo, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
		: PatternTrackInfo(pInfo, mtStart, mtEnd)
	{
		m_dwPatternTag = DMUS_PATTERN_STYLE;
	}
	~StyleTrackInfo();
	virtual HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

	virtual HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicTrack*		pParentrack,
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

	HRESULT LoadStyleRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadStyleRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  IDMStyle** ppStyle);

};


/////////////////////////////////////////////////////////////////////////////
// CStyleTrack
class CStyleTrack : 
	public IDirectMusicTrack8,
	public IStyleTrack,
	public IPersistStream
{
friend struct StyleTrackState;
public:
	CStyleTrack();
	CStyleTrack(const CStyleTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd); 
	~CStyleTrack();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IStyleTrack
public:
// IStyleTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID pCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID	pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID pGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID			pGuid
			);


// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IStyleTrack methods

STDMETHOD(GetStyle)(IUnknown** ppStyle);

STDMETHOD(SetTrack)(IUnknown* pStyle);

// internal methods
protected:
// used by both GetParam and GetParamEx
	HRESULT STDMETHODCALLTYPE GetParam( 
		REFGUID pCommandGuid,
		MUSIC_TIME mtTime,
		MUSIC_TIME* pmtNext,
		void *pData,
		void* pStateData);

	HRESULT JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

// IStyleTrack data members
protected:
	// attributes
    long m_cRef;
    CRITICAL_SECTION			m_CriticalSection; // for load and playback
    BOOL                        m_fCSInitialized;
	PatternTrackInfo*			m_pTrackInfo;
	BYTE						m_bRequiresSave;
};

struct StyleTrackState : public PatternTrackState
{
	StyleTrackState();
	~StyleTrackState();
	// methods
	HRESULT Play(
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  REFERENCE_TIME rtOffset,
						  IDirectMusicPerformance* pPerformance,
						  DWORD						dwFlags,
						  BOOL fClockTime
			);
	HRESULT GetNextPattern(DWORD dwFlags, MUSIC_TIME mtNow, MUSIC_TIME mtOffset, IDirectMusicPerformance* pPerformance, BOOL fSkipVariations = FALSE);

	MUSIC_TIME PartOffset(int nPartIndex);

	//CDirectMusicPattern* SelectPattern(bool fNewMode, TList<CDirectMusicPattern*>& rPatternList);

	// attributes
	MUSIC_TIME					m_mtSectionOffset;	// Elapsed time in the section
	MUSIC_TIME					m_mtSectionOffsetTemp;	// temporary value for m_mtSectionOffset
	MUSIC_TIME					m_mtNextCommandTime;	// when the next command begins
	MUSIC_TIME					m_mtNextCommandTemp;	// temporary values for m_mtNextCommandTime
	MUSIC_TIME					m_mtNextStyleTime;	// when the next style begins
	DMUS_COMMAND_PARAM_2		m_CommandData;		// data about the current command
//	DMUS_RHYTHM_PARAM*			m_pChordRhythm;		// data about the current chord's rhythm
//	short						m_nLongestPattern;	// length of longest pattern in a style
//	DMUS_COMMAND_PARAM_2*		m_pCommands;		// array of commands (for pattern selection)
//	DWORD*						m_pRhythms;			// array of rhythms (for pattern selection)
	MUSIC_TIME					m_mtOverlap;		// section overlap caused by controlling segment
	TList<CDirectMusicPattern*> m_PlayedPatterns;	// list of patterns already played that match current groove level
};

#endif //__STYLETRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\collection.h ===
#ifndef COLLEC_H
#define COLLEC_H

#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "..\shared\xsoundp.h" // For IDirectSoundSource
#include "..\shared\dmstrm.h"


class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject
{
friend class CInstrument;

public:
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream
	STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

private:
    CMemTrack           m_MemTrack;
    CInfo               m_Info;
	long				m_cRef;
//    CInstrumentList                 m_InstList;
    CRITICAL_SECTION    m_CriticalSection;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmstyle\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}


template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}

template <class T>
HRESULT TList<T>::Copy(TList<T>& rList)
{
	HRESULT hr = S_OK;
	TListItem<T>* pScan = m_pHead;
	for (; pScan; pScan = pScan->GetNext())
	{
		T& rScan = pScan->GetItemValue();
		TListItem<T>* pNew = new TListItem<T>(rScan);
		if (pNew)
		{
			rList.AddHead(pNew);
		}
		else
		{
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	if (SUCCEEDED(hr))
	{
		rList.Reverse();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\cclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

//  clock.h
#ifndef __CCLOCK_H__
#define __CCLOCK_H__

class CDSLink;

class CClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
                CClock();
    void        Init(CDSLink *pDSLink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;     // Currently changing configuration.
    CDSLink *	m_pDSLink;      // Pointer to parent DSLink structure.
};

#endif //__CCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\control.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      CControlLogic.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "misc.h"
#include "csynth.h"
#include "debug.h"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Manage the global critical section. #pragma's disable the warning about
// not compiling with -GX when using exception handling, which we don't
// care about.
//
//
// The critical section must be global because it protects global
// data in the CMIDIRecorder class. These functions are called from 
// DllMain().
//

CPart::CPart()

{
    Init(NULL,NULL);
}

VREL CPart::m_svrPanToVREL[128];

void CPart::Init(CControlLogic *pControl, CSynth *pSynth)

{
    m_fSustain = FALSE;
    m_dwProgram = 0;
    m_rtLastTime = 0;
    m_bModWheel = 0;
    m_bPressure = 0;
    m_bVolume = 100;
    m_bPan = 64;
    m_bExpression = 127;
    memset(m_bMixBinVolume,127,8);
    m_nPitchBend = 0;
    m_bReverbSend = 40;
    m_bChorusSend = 0;
    m_bFilter = 64;
    m_pControl = pControl;
    m_pSynth = pSynth;

    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    WORD nI;
    for (nI = 1; nI < 128; nI++)
    {
        double flTemp;
        flTemp = nI;
        flTemp /= 127.0;
        flTemp = log10(flTemp);
        flTemp *= 1000.0;
        m_svrPanToVREL[nI] = (long) flTemp;
    }  
    m_svrPanToVREL[0] = -2500;
}


CRITICAL_SECTION CControlLogic::s_CriticalSection;
DWORD CControlLogic::m_dwCSRefCount = 0;

CControlLogic::CControlLogic()

{
    if (m_dwCSRefCount == 0)
    {
        ::InitializeCriticalSection(&s_CriticalSection);
    } 
    m_dwCSRefCount++;
    m_pSynth = NULL;
    m_pInstruments = NULL;
    DWORD nIndex;
    GMReset();
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
}

CControlLogic::~CControlLogic()
{
    if (m_dwCSRefCount == 1)
    {
        DeleteCriticalSection(&s_CriticalSection);
    }
    m_dwCSRefCount--;
}

void CControlLogic::GMReset()

{
    static int nPartToChannel[16] = { 
        9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 
    };
    int nX;
    for (nX = 0; nX < 16; nX++)
    {
        int nY;
        CPart *pPart = &m_Part[nX];
        pPart->m_nData = 0;
        pPart->m_prFineTune = 0;
        pPart->m_bDrums = 0;
        for (nY = 0; nY < 12; nY++)
        {
            pPart->m_prScaleTune[nY] = 0;
        }
        pPart->m_nCurrentRPN = (short) 0x3FFF;
        pPart->m_prCoarseTune = 0; 
        pPart->m_bPartToChannel = (BYTE)nPartToChannel[nX];
        pPart->m_fMono = FALSE;
        pPart->m_dwPriority = DAUD_STANDARD_VOICE_PRIORITY + 
            ((16 - nX) * DAUD_CHAN15_VOICE_PRIORITY_OFFSET);
        pPart->m_bBankH = 0;
        pPart->m_bBankL = 0;
    }
    m_Part[0].m_bDrums = 1;
    m_vrMasterVolume = 0;
    m_fGSActive = FALSE;
    m_fXGActive = FALSE;
}

HRESULT CControlLogic::Init(CInstManager *pInstruments, CSynth *pSynth)

{
    m_pSynth = pSynth;
    m_pInstruments = pInstruments;
    m_vrGainAdjust = 0;
    DWORD dwX;
    for (dwX = 0; dwX < 16; dwX++)
    {
        m_Part[dwX].Init(this,pSynth);
    }
    CVoice::Init();
    return S_OK;
}

void CControlLogic::SetGainAdjust(VREL vrGainAdjust)
{
    m_vrGainAdjust = vrGainAdjust;
}

static VREL g_vrMIDIToVREL[128] = 
{
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};

VREL VelocityToVolume(WORD nVelocity)

{
    return (g_vrMIDIToVREL[nVelocity]);
}

static VREL g_vrMIDIPercentToVREL[128] = 
{
    -9600, -4207, -3605, -3253, -3003, -2809, -2651, -2517, 
    -2401, -2299, -2207, -2124, -2049, -1979, -1915, -1855, 
    -1799, -1746, -1697, -1650, -1605, -1563, -1522, -1484, 
    -1447, -1411, -1377, -1344, -1313, -1282, -1253, -1224, 
    -1197, -1170, -1144, -1119, -1095, -1071, -1048, -1025, 
    -1003, -982, -961, -940, -920, -901, -882, -863, 
    -845, -827, -809, -792, -775, -759, -742, -726, 
    -711, -695, -680, -665, -651, -636, -622, -608, 
    -595, -581, -568, -555, -542, -529, -517, -505, 
    -492, -480, -469, -457, -445, -434, -423, -412, 
    -401, -390, -379, -369, -359, -348, -338, -328, 
    -318, -308, -299, -289, -280, -270, -261, -252, 
    -243, -234, -225, -216, -207, -198, -190, -181, 
    -173, -165, -156, -148, -140, -132, -124, -116, 
    -109, -101, -93, -86, -78, -71, -63, -56, 
    -49, -42, -34, -27, -20, -13, -6, 0 
};

VREL MIDIToPercent(WORD nMIDI)

{
    return (g_vrMIDIPercentToVREL[nMIDI]);
}


void CPart::AllSoundsOff(REFERENCE_TIME rtTime)

{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_pPart == this)
        {
            pVoice->QuickStopVoice(rtTime);
        }
    }
}

void CPart::SetSustain(REFERENCE_TIME rtTime,BOOL fSustain)

{                
    m_fSustain = fSustain;
    if (!fSustain)
    {
        CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if (pVoice->m_fSustainOn &&
                (pVoice->m_pPart == this))
            {
                pVoice->StopVoice(rtTime);
            }
        }
    } 
}

void CPart::AllNotesOff(REFERENCE_TIME rtTime)
{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
            (pVoice->m_pPart == this))
        {
            if (m_fSustain)
            {
                pVoice->m_fSustainOn = TRUE;
            }
            else
            {
                pVoice->StopVoice(rtTime);
            }
        }
    }
}

void CPart::GetVolume(VREL vrVoice, long lDefaultPan,VREL *pvrVolume,VREL *pvrLeft,VREL *pvrRight,VREL *pvrReverb,VREL *pvrChorus)

{
    VREL vrVolume = VelocityToVolume(m_bVolume) +
        VelocityToVolume(m_bExpression);
    vrVolume += m_pSynth->m_vrGainAdjust;
    vrVolume += m_pControl->m_vrMasterVolume;
    vrVolume += vrVoice;
    if (pvrVolume)
    {
        *pvrVolume = vrVolume;
    }
    if (pvrLeft && pvrRight)
    {
        lDefaultPan += m_bPan;

        if (lDefaultPan < 0) 
            lDefaultPan = 0;

        if (lDefaultPan > 127) 
            lDefaultPan = 127;

        *pvrLeft = m_svrPanToVREL[127 - lDefaultPan] + vrVolume;
        *pvrRight = m_svrPanToVREL[lDefaultPan] + vrVolume;
    } 
    if (pvrReverb)
    {
        *pvrReverb = vrVolume + g_vrMIDIPercentToVREL[m_bReverbSend];
    }
    if (pvrChorus)
    {
        *pvrChorus = vrVolume + g_vrMIDIPercentToVREL[m_bChorusSend];
    }
}

void CPart::GetVolume(VREL vrVolume, BYTE pbControllers[], VREL pvrVolume[])

{
    vrVolume += VelocityToVolume(m_bVolume) +
        VelocityToVolume(m_bExpression);
    vrVolume += m_pSynth->m_vrGainAdjust;
    vrVolume += m_pControl->m_vrMasterVolume;
    DWORD dwMixBin;
    for (dwMixBin = 0; pbControllers[dwMixBin]; dwMixBin++)
    {
        pvrVolume[dwMixBin] = vrVolume + 
            VelocityToVolume(m_bMixBinVolume[pbControllers[dwMixBin]-1]);
    }
}

void CPart::GetModWheel(DWORD *pdwModWheel)

{
    *pdwModWheel = m_bModWheel;
}

void CPart::GetPressure(DWORD *pdwPressure)

{
    *pdwPressure = m_bPressure;
}

void CPart::GetPitch(PREL *prPitch)

{
    *prPitch = m_nPitchBend + m_prFineTune;
}

void CPart::GetFilter(PREL *prFilter)

{
    *prFilter = m_bFilter - 64; 
    *prFilter *= 100; // Convert to pitch cents.
}

void CPart::SendVolume(REFERENCE_TIME rtTime)

{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_pPart == this)
        {
            pVoice->SendVolume(rtTime);
        }
    }
}

void CPart::SendPitch(REFERENCE_TIME rtTime)

{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_pPart == this)
        {
            pVoice->SendPitch(rtTime);
        }
    }
}


void CPart::SendFilter(REFERENCE_TIME rtTime)

{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_pPart == this)
        {
            pVoice->SendFilter(rtTime,FALSE);
        }
    }
}

void CPart::SendLFOs(REFERENCE_TIME rtTime)

{
    CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
    for (;pVoice != NULL; pVoice = pVoice->GetNext())
    {
        if (pVoice->m_pPart == this)
        {
            pVoice->SendLFOs(rtTime);
        }
    }
}

void CPart::PlayNoteOff(REFERENCE_TIME rtTime,BYTE bNote)

{
    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
    DWORD dwNoteID = 0; // Use to track multiple voices on one note.
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
            (pVoice->m_nKey == (WORD) bNote) &&
            (pVoice->m_pPart == this)) 
        {
            if (!dwNoteID || (dwNoteID == pVoice->m_dwNoteID))
            {
                dwNoteID = pVoice->m_dwNoteID;
                if (m_fSustain)
                {
                    pVoice->m_fSustainOn = TRUE;
                }
                else
                {
                    pVoice->StopVoice(rtTime);
                }
            }
        }
    }
}

void CPart::PlayNoteOn(REFERENCE_TIME rtTime,BYTE bNote, BYTE bVelocity)

{
    DWORD dwProgram = m_dwProgram;
    if (m_bDrums)
    {
        dwProgram |= F_INSTRUMENT_DRUMS;
    }
    if (m_fMono)
    {
        CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
        for (;pVoice != NULL;pVoice = pVoice->GetNext())
        {
            if (pVoice->m_fNoteOn && (pVoice->m_pPart == this)) 
            {
                pVoice->StopVoice(rtTime);
            }
        }
    }
    // While we are working with the instrument, including copying
    // the data over from the region, we have to make sure it
    // can not be removed from the instrument list.
    EnterCriticalSection(&m_pControl->m_pInstruments->m_CriticalSection);
    CInstrument * pInstrument = 
        m_pControl->m_pInstruments->GetInstrument(dwProgram,bNote,bVelocity);
    if (!pInstrument) 
    {
        if (dwProgram & F_INSTRUMENT_DRUMS)
        {
            dwProgram = F_INSTRUMENT_DRUMS;
            pInstrument = 
                m_pControl->m_pInstruments->GetInstrument(dwProgram,bNote,bVelocity);
        }
        else if (m_pControl->m_fXGActive)
        {
            if ((dwProgram & 0x7F0000) == 0x7F0000) // Drum?
            {
                dwProgram &= 0x7F007F;              // Enforce 0 LSB
                pInstrument = 
                    m_pControl->m_pInstruments->GetInstrument(dwProgram,bNote,bVelocity);
                if (!pInstrument)
                {
                    dwProgram = 0x7F0000;
                    pInstrument = 
                        m_pControl->m_pInstruments->GetInstrument(dwProgram,bNote,bVelocity);
                }
            }
            else
            {
                dwProgram &= 0x7F;  // Fall back to GM set.
                pInstrument = 
                    m_pControl->m_pInstruments->GetInstrument(dwProgram,bNote,bVelocity);
            }
        }
    }
    if (pInstrument != NULL)
    {
        DWORD dwNotesLost = 1;  // Assume note will be lost, will be decremented if played 
        CSourceRegion * pRegion = NULL;
        static DWORD sdwNoteID = 0; // Generate a unique id that will be placed in all voices that play this note.
        sdwNoteID++;                // This will be used to keep the voices associated so we can stop them all at once later.
        while ( pRegion = pInstrument->ScanForRegion(bNote,bVelocity,pRegion) ) 
        {
            CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
            if (!pRegion->m_bAllowOverlap)
            {
                for (;pVoice != NULL; pVoice = pVoice->GetNext())
                {
                    if ((pVoice->m_pPart == this) &&
                        (pVoice->m_nKey == bNote) &&
                        (pVoice->m_pRegion  == pRegion))
                    {
                        pVoice->QuickStopVoice(rtTime);
                    }
                }    
            }

            if (pRegion->m_bGroup != 0)
            {
                pVoice = m_pSynth->m_VoicesInUse.GetHead();
                for (;pVoice != NULL;pVoice = pVoice->GetNext())
                {
                    if ((pVoice->m_dwGroup == pRegion->m_bGroup) &&
                        (pVoice->m_pPart == this) &&
                        (pVoice->m_dwProgram == dwProgram))
                    {
                        pVoice->QuickStopVoice(rtTime);
                    }
                }
            }
        
            pVoice = m_pSynth->m_VoicesFree.RemoveHead();
            if (pVoice == NULL)
            {
                pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
            }

            if (pVoice == NULL)
            {
                pVoice = m_pSynth->StealVoice(m_dwPriority);
                
                // The voice IDs are used by the VoiceServiceThread in DMusic
                // to refill the streaming wave buffers....
                // Since the voice is stolen this voice could really belong to
                // a streaming wave in which case preserving the voice ID will 
                // break the refill code. (NOTE!! This is different from stealing
                // voices for waves. Waves will ultimately preserve the voice ID as 
                // they pass it to StartWave where it gets assigned to the voice's 
                // m_dwVoiceId member).

                if(pVoice)
                {
                    // Set the voice ID to something unacceptable
                    pVoice->m_dwVoiceId = 0xffffffff;
                }
            }

            if (pVoice != NULL)
            {
                PREL prPitch = m_prScaleTune[bNote % 12];
                if (!m_bDrums) 
                {
                    if (m_pControl->m_fXGActive)
                    {
                        if ((dwProgram & 0x7F0000) != 0x7F0000)
                        {
                            prPitch += m_prCoarseTune;
                        }
                    }
                    else
                    {
                        prPitch += m_prCoarseTune;
                    }
                }

                pVoice->m_pPart = this;
                pVoice->m_nKey = bNote;
                pVoice->m_dwProgram = dwProgram;
                pVoice->m_dwPriority = m_dwPriority;
                pVoice->m_pControl = m_pControl;
                pVoice->m_pRegion = pRegion;
                pVoice->m_dwNoteID = sdwNoteID;
                VREL vrVolume = VelocityToVolume(m_bVolume) +
                    VelocityToVolume(m_bExpression);

                if (pVoice->StartVoice(m_pSynth,
                    pRegion, rtTime, 
                    &m_BusIds,
                    (WORD)bNote,
                    (WORD)bVelocity,
                    m_pControl->m_vrMasterVolume, 
                    vrVolume,
                    prPitch,
                    m_nPitchBend))
                {
                    pVoice->m_fInUse = TRUE;
                    m_pSynth->QueueVoice(pVoice);
                    dwNotesLost = 0;    // Note played remove notelost assumpstion 
                }
                else
                {
                    m_pSynth->m_VoicesFree.AddHead(pVoice);
                }
            } 
        } 
    } 
    else 
    {
        Trace(2,"Warning: No instrument/region was found for patch # %lx, note %ld\n",
            dwProgram, (long) bNote);
    }
    LeaveCriticalSection(&m_pControl->m_pInstruments->m_CriticalSection);
}

void CPart::RecordMIDI(REFERENCE_TIME rtTimeIn, BYTE bStatus, BYTE bData1, BYTE bData2)

{
    REFERENCE_TIME rtTime;
    // We don't allow events to any particular part to be out of order. 
    // This simplifies the implementation of continuous controllers
    // enormously. 
    if (rtTimeIn > m_rtLastTime)
    {
        rtTime = rtTimeIn;
        m_rtLastTime = rtTime;
    }
    else
    {
        rtTime = m_rtLastTime;
    }
    switch (bStatus)
    {
    case MIDI_NOTEOFF :
        PlayNoteOff(rtTime, bData1);
        break;
    case MIDI_NOTEON :
        PlayNoteOn(rtTime, bData1, bData2);
        break;
    case MIDI_CCHANGE :
        switch (bData1)
        {
        case CC_BANKSELECTH :
            m_bBankH = bData2;
            break;
        case CC_MODWHEEL :
            m_bModWheel = bData2;
            SendLFOs(rtTime);
            break;
        case CC_VOLUME :
            m_bVolume = bData2;
            SendVolume(rtTime);
            break;
        case CC_PAN :
            m_bPan = bData2;
            SendVolume(rtTime);
            break;
        case CC_EXPRESSION :
            m_bExpression = bData2;
            SendVolume(rtTime);
            break;
        case CC_BANKSELECTL :
            m_bBankL = bData2;
            break;
        case CC_RESETALL:
            if (bData2)
            {
                m_bVolume = 100;
                m_bPan = 64;
            }
            m_bExpression = 127;
            m_nPitchBend = 0;
            m_bModWheel = 0;  
            m_bPressure = 0;
            m_bPressure = 0;
            m_bReverbSend = 40;
            m_bChorusSend = 0;
            m_bFilter = 64;
            memset(m_bMixBinVolume,127,8);
            bData2 = 0;
            SendVolume(rtTime);
            SendLFOs(rtTime);
            SendFilter(rtTime);
            SendPitch(rtTime);
            // fall through into Sustain Off case....

        case CC_SUSTAIN :
            SetSustain(rtTime,(BOOL)bData2);
            break;
        case CC_ALLSOUNDSOFF:
            AllSoundsOff(rtTime);
            break;
        case CC_ALLNOTESOFF:
            AllNotesOff(rtTime);
            break;
        case CC_DATAENTRYMSB:
            m_nData &= ~(0x7F << 7);
            m_nData |= bData2 << 7;
            switch (m_nCurrentRPN)
            {
            case RPN_PITCHBEND:
                // Special case for a range of 82 semitones, because this must
                // really be an attempt to have the pitch bend map directly to
                // pitch cents.
//                    if (bData == 82)
//                    {
//                        m_PitchBend.m_prRange = 8192;
//                    }
//                    else
//                    {
//                        m_PitchBend.m_prRange = bData * 100;
//                    }
                break;
            case RPN_FINETUNE:
                {
                    long lTemp = m_nData;
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune = lTemp;
                }
                break;
            case RPN_COARSETUNE:
                m_prCoarseTune = 100 * (bData2 - 64);
                break;        
            }
            break;
        case CC_DATAENTRYLSB:
            m_nData &= ~0x7F;
            m_nData |= bData2;
            switch (m_nCurrentRPN)
            {
            case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
                break;
            case RPN_FINETUNE:
                {
                    long lTemp = m_nData;
                    lTemp -= 8192;
                    lTemp *= 100;
                    lTemp /= 8192;
                    m_prFineTune = lTemp;
                }
                break;
            case RPN_COARSETUNE: // Ignore lsb
                break;            
            }
            break;
        case CC_NRPN_LSB :
        case CC_NRPN_MSB :
            m_nCurrentRPN = 0x3FFF;
            break;
        case CC_RPN_LSB:
            m_nCurrentRPN = (m_nCurrentRPN & 0x3f80) + bData2;
            break; 
        case CC_RPN_MSB:
            m_nCurrentRPN = (m_nCurrentRPN & 0x7f) + (bData2 << 7);
            break;
        case CC_MONOMODE :
            m_fMono = TRUE;
            AllSoundsOff(rtTime);
            break;
        case CC_POLYMODE :
            m_fMono = FALSE;
            AllSoundsOff(rtTime);
            break;
        case CC_REVERB :
            m_bReverbSend = bData2;
            SendVolume(rtTime);
            break;
        case CC_CHORUS :
            m_bChorusSend = bData2;
            SendVolume(rtTime);
            break;
        case CC_CUTOFFFREQ:
            m_bFilter = bData2;
            SendFilter(rtTime);
            break;
        case CC_MIXBINVOLUME:
        case CC_MIXBINVOLUME+1:
        case CC_MIXBINVOLUME+2:
        case CC_MIXBINVOLUME+3:
        case CC_MIXBINVOLUME+4:
        case CC_MIXBINVOLUME+5:
        case CC_MIXBINVOLUME+6:
        case CC_MIXBINVOLUME+7:
            m_bMixBinVolume[bData1 - CC_MIXBINVOLUME] = bData2;
            SendVolume(rtTime);
            break;
        default:
            break;
        }
        break;

    case MIDI_PCHANGE :
        m_dwProgram = bData1 | 
            (m_bBankH << 16) | 
            (m_bBankL << 8);
        break;
    case MIDI_PBEND :
        {
            WORD nBend;
            nBend = bData2 << 7;
            nBend |= bData1;
            m_nPitchBend = nBend - 0x2000;
            SendPitch(rtTime);
//            SendFilter(stTime);
        }
        break;

    case MIDI_MTOUCH:
        m_bPressure = bData1;
        SendLFOs(rtTime);
        break;
    }
}


BOOL CControlLogic::RecordMIDI(REFERENCE_TIME rtTimeIn,BYTE bStatus, BYTE bData1, BYTE bData2)

{
    WORD nPreChannel = bStatus & 0xF; 
    bStatus = bStatus & 0xF0;
    DWORD dwPart;

    ::EnterCriticalSection(&s_CriticalSection);

    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        CPart *pPart = &m_Part[dwPart];
        if (nPreChannel == pPart->m_bPartToChannel)
        {
            pPart->RecordMIDI(rtTimeIn,bStatus,bData1,bData2);
        }
    }
    ::LeaveCriticalSection(&s_CriticalSection);

    return TRUE;
}

HRESULT CControlLogic::RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, REFERENCE_TIME rtTime)

{
    HRESULT hSuccess = S_OK;
    int nPart;
    int nTune;
    DWORD dwAddress;
    BOOL fClearAll = FALSE;
    BOOL fResetPatches = FALSE;
    if (dwSysExLength < 6) 
    {
        Trace(4,"Warning: Unknown sysex message sent to synth.\n");
        return E_FAIL;
    }

    EnterCriticalSection(&s_CriticalSection);

    switch (pSysExData[1])  // ID number
    {
    case 0x7E : // General purpose ID
        if (pSysExData[3] == 0x09) 
        {
            GMReset();
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    case 0x7F : // Real time ID
        if (pSysExData[3] == 0x04)
        {
            if (pSysExData[4] == 1) // Master Volume
            {
                m_vrMasterVolume = VelocityToVolume(pSysExData[6]);
            }
        }
        break;
    case 0x41 : // Roland
        if (dwSysExLength < 11) 
        {
            Trace(4,"Warning: Unknown sysex message sent to synth.\n");
            LeaveCriticalSection(&s_CriticalSection);
            return E_FAIL;
        }
        if (pSysExData[3] != 0x42) break;
        if (pSysExData[4] != 0x12) break;
        nPart = pSysExData[6] & 0xF;
        dwAddress = (pSysExData[5] << 16) |
            ((pSysExData[6] & 0xF0) << 8) | pSysExData[7];
        switch (dwAddress)
        {
        case 0x40007F :     // GS Reset.
            GMReset();
            m_fXGActive = FALSE;
            fClearAll = TRUE;
            m_fGSActive = TRUE;
            fResetPatches = TRUE;
            break;
        case 0x401002 :     // Set Receive Channel.
            if (m_fGSActive)
            {
                if (pSysExData[8])
                {
                    m_Part[nPart].m_bPartToChannel = (BYTE) pSysExData[8] - 1;
                }
            }
            break;
        case 0x401015 :     // Use for Rhythm.
            if (m_fGSActive)
            {
                m_Part[nPart].m_bDrums = pSysExData[8];
                fClearAll = TRUE;
            }
            break;
        case 0x401040 :     // Scale Tuning.
            if (m_fGSActive)
            {
                for (nTune = 0;nTune < 12; nTune++)
                {
                    if (pSysExData[9 + nTune] & 0x80) break;
                    m_Part[nPart].m_prScaleTune[nTune] = 
                        (PREL) pSysExData[8 + nTune] - (PREL) 64;
                }
            }
            break;
        }
        break;
    case 0x43 : // Yamaha
        if ((pSysExData[3] == 0x4C) &&
            (pSysExData[4] == 0) &&
            (pSysExData[5] == 0) &&
            (pSysExData[6] == 0x7E) &&
            (pSysExData[7] == 0))
        {   // XG System On
            m_fXGActive = TRUE;
            m_fGSActive = FALSE;
            GMReset();
            m_fXGActive = TRUE;
            m_Part[0].m_bDrums = 0;
            m_Part[0].m_bBankH = 127;
            fClearAll = TRUE;
            fResetPatches = TRUE;
        }
        break;
    }
    if (fClearAll)
    {
        for (nPart = 0;nPart < 16;nPart++)
        {     
            CPart *pPart = &m_Part[nPart];
            pPart->AllSoundsOff(rtTime);
            pPart->SetSustain(rtTime,FALSE);
            pPart->m_bVolume = 100;
            pPart->m_bPan = 64;
            pPart->m_bExpression = 127;
            pPart->m_nPitchBend = 0;
            pPart->m_bModWheel = 0;
            pPart->m_bPressure = 0;
            pPart->m_bReverbSend = 40;
            pPart->m_bChorusSend = 0;
            pPart->m_bFilter = 64;
        }
    }
    if (fResetPatches)
    {
        for (nPart = 0;nPart < 16;nPart++)
        {     
            if ((nPart == 0) && (m_fXGActive))
            {
                m_Part[nPart].m_dwProgram = 0x7F0000;
            }
            else
            {
                m_Part[nPart].m_dwProgram = 0;
            }
        }
    }

    LeaveCriticalSection(&s_CriticalSection);
    return hSuccess;
}

HRESULT CControlLogic::SetChannelPriority(DWORD dwChannel,DWORD dwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_Part[dwPart].m_bPartToChannel == dwChannel)
        {
            m_Part[dwPart].m_dwPriority = dwPriority;
        }
    }
    return S_OK;
}

HRESULT CControlLogic::GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority)

{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_Part[dwPart].m_bPartToChannel == dwChannel)
        {
            *pdwPriority = m_Part[dwPart].m_dwPriority;
            break;
        }
    }
    return S_OK;
}

static DWORD g_dwVoiceID = 1;

BOOL CControlLogic::RecordWaveEvent(
    REFERENCE_TIME rtTime, BYTE bChannel, VREL vrVolume, PREL prPitchIn, 
    SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd,
    IDirectSoundWave *pIWave, DWORD *pdwVoiceID)

{
    WORD nPreChannel = bChannel;
    BOOL bReturn = TRUE;
    DWORD dwPart;

    ::EnterCriticalSection(&s_CriticalSection);


    CSourceWave *pWave;
    if (SUCCEEDED(pIWave->QueryInterface(IID_CSourceWave,(void **) &pWave)))
    {
        *pdwVoiceID = g_dwVoiceID++;
        for (dwPart = 0;dwPart < 16; dwPart++)
        {
            CPart *pPart = &m_Part[dwPart];;
            if (nPreChannel == pPart->m_bPartToChannel)
            {
                EnterCriticalSection(&m_pInstruments->m_CriticalSection);
                CVoice * pVoice = m_pSynth->m_VoicesFree.RemoveHead();

                if (pVoice == NULL)
                {
                    pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
                }

                if (pVoice == NULL)
                {
                    pVoice = m_pSynth->StealVoice(pPart->m_dwPriority);
                }

                if (pVoice != NULL)
                {
                    pVoice->m_nKey = 0xffff;                // set to unused values 
                    pVoice->m_dwProgram = 0xffffffff;       // set to unused values 
                    pVoice->m_pPart = pPart;
                    pVoice->m_dwPriority = pPart->m_dwPriority;
                    pVoice->m_pControl = this;
                    pVoice->m_pRegion  = NULL;
                    BOOL fSuccess;
                    if ( pWave->m_pnWave ) 
                    {
                        fSuccess = pVoice->StartWave(m_pSynth,
                            pWave,
                            *pdwVoiceID, 
                            rtTime, 
                            &pPart->m_BusIds,
                            vrVolume,0,    
                            prPitchIn,0,
                            (DWORD) stVoiceStart,
                            (DWORD) stLoopStart,
                            (DWORD) stLoopEnd);
                    }
                    else
                    {
                        fSuccess = pVoice->StartStreamedWave(m_pSynth,
                            pWave,
                            *pdwVoiceID, 
                            rtTime, 
                            &pPart->m_BusIds,
                            vrVolume,0,    
                            prPitchIn,0,
                            (DWORD) stVoiceStart,
                            (DWORD) stLoopStart,
                            (DWORD) stLoopEnd);
                    }
                    if (fSuccess)
                    {
                        pVoice->m_fInUse = TRUE;
                        m_pSynth->QueueVoice(pVoice);
                    }
                    else
                    {
                        m_pSynth->m_VoicesFree.AddHead(pVoice);
                    }
                } 
                else 
                {
                    Trace(1,"Error: No voice avaible for synt\n");
                }
                LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
            }
        }
        pWave->Release();
    }
    ::LeaveCriticalSection(&s_CriticalSection);

    return bReturn;
}

HRESULT CControlLogic::AssignChannelToOutput(DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE* pbControllers )
{
    DWORD dwPart;
    for (dwPart = 0;dwPart < 16; dwPart++)
    {
        if (m_Part[dwPart].m_bPartToChannel == dwChannel)
        {
            //
            // Assign new mixbins and buffer to this channel 
            //
            m_Part[dwPart].m_BusIds.AssignOutput(pBuffer, dwMixBins, pbControllers);
        }
    }

    return S_OK;
}
/*
/////////////////////////////////////////////////////////////////
CWaveDataList    CWaveIn::m_sFreeList;
DWORD            CWaveIn::m_sUsageCount = 0;

CWaveData::CWaveData() 
{
    m_stTime = 0;
}

CWaveIn::CWaveIn()
{
    m_sUsageCount++;
    m_stCurrentTime = 0;
}

CWaveIn::~CWaveIn()

{
//    ClearWave(0x7FFFFFFF);
    m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CWaveData *pWD;
        while (pWD = m_sFreeList.RemoveHead())
        {
            delete pWD;
        }
    }
}

BOOL CWaveIn::ClearWave(REFERENCE_TIME rtTime)

{
    CWaveData *pWD;

    for (;pWD = m_EventList.GetHead();)
    {
        if (pWD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pWD->m_stTime;
            m_lCurrentData  = pWD->m_WaveEventData;
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}*/

/*BOOL CWaveIn::RemoveWave(DWORD dwID)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}

BOOL CWaveIn::RemoveWaveByStopTime(DWORD dwID, REFERENCE_TIME rtStopTime)

{
    CWaveData *pWD = m_EventList.GetHead();
    CWaveData *pWDNext = NULL;

    for (; pWD; pWD = pWDNext)
    {
        pWDNext = pWD->GetNext();
        if (pWD->m_WaveEventData.m_dwVoiceId == dwID && pWD->m_stTime >= rtStopTime)
        {
            m_EventList.Remove(pWD);
            if (pWD->m_WaveEventData.m_pWaveArt)
            {
                pWD->m_WaveEventData.m_pWaveArt->Release();
                pWD->m_WaveEventData.m_pWaveArt = NULL;
            }
            m_sFreeList.AddHead(pWD);
        }
    }
    return m_EventList.IsEmpty();
}*/

/*BOOL CWaveIn::RecordWave(REFERENCE_TIME rtTime, CWaveEvent* pWave)

{
    CWaveData *pWD = m_sFreeList.RemoveHead();
    if (!pWD)
    {
        pWD = new CWaveData;
    }    
    CWaveData *pScan = m_EventList.GetHead();
    CWaveData *pNext;

    if (pWD)
    {
        pWD->m_stTime        = rtTime;
        pWD->m_WaveEventData = *pWave;
        pWD->m_WaveEventData.m_stTime = rtTime;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pWD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pWD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pWD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pWD->SetNext(pNext);
                            pScan->SetNext(pWD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
    Trace(1,"Error: Wave Event pool empty.\n");

    return (FALSE);
}*/

/*BOOL CWaveIn::GetWave(REFERENCE_TIME rtTime, CWaveEvent *pWave)

{
    CWaveData *pWD = m_EventList.GetHead();

    if (pWD != NULL)
    {
        if (pWD->m_stTime <= stTime)
        {
            *pWave =  pWD->m_WaveEventData;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pWD);
            return (TRUE);
        }
    }
    return (FALSE);
}*/

#ifndef XBOX
/////////////////////////////////////////////////////////////////
CBusIds::CBusIds()
{
    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;
}

CBusIds::~CBusIds()
{
}

HRESULT CBusIds::Initialize()
{
    HRESULT hr = S_OK;

    m_dwBusIds[0] = DSBUSID_LEFT;
    m_dwBusIds[1] = DSBUSID_RIGHT;
    m_dwBusIds[2] = DSBUSID_REVERB_SEND;
    m_dwBusIds[3] = DSBUSID_CHORUS_SEND;
    m_dwBusCount = NUM_DEFAULT_BUSES;

    return hr;
}



HRESULT CBusIds::AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount)
{
    HRESULT hr = S_OK;

    if ( pdwBusIds && dwBusCount > 0 )
    {
        if ( dwBusCount > MAX_DAUD_CHAN )
            dwBusCount = MAX_DAUD_CHAN;

        memcpy(m_dwBusIds,pdwBusIds,sizeof(DWORD)*dwBusCount);
        m_dwBusCount = dwBusCount;
    }

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\collection.cpp ===
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
//#include <objbase.h>
//#include <mmsystem.h>
//#include <dsoundp.h>
//#include <ks.h>

#include "debug.h"
#include "dmusicc.h"
#include "dmusics.h"

STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC )
{
    CCollection *pCollection = new CCollection;
    if (pCollection)
    {
        return pCollection->QueryInterface(iid,ppDMC);
    }
    return E_OUTOFMEMORY;
}

CCollection::CCollection() : m_MemTrack(DMTRACK_COLLECTION)
{
	m_cRef = 1;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
}

CCollection::~CCollection()
{
	DELETE_CRITICAL_SECTION(&m_CrSec);
}

STDMETHODIMP CCollection::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicCollection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicCollection)
	{
		*ppv = static_cast<IDirectMusicCollection*>(this);
	} 
	else if(iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if(iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}


STDMETHODIMP_(ULONG) CCollection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CCollection::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CCollection::GetClassID( CLSID* pClassID )
{
	V_INAME(CCollection::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicCollection;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CCollection::IsDirty()
{
	return S_FALSE;
}

HRESULT CCollection::Load( IStream* pIStream )
{
	V_INAME(IPersistStream::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == FOURCC_DLS))
    {
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing DLS Collection\n");
        hr = DMUS_E_NOTADLSCOL;
    }
    return hr;
}

HRESULT CCollection::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case FOURCC_DLID:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
					break;
				case DMUS_FOURCC_TOOL_LIST:
                    pParser->EnterList(&ckChild);
	                while(pParser->NextChunk(&hr))
	                {
		                if ((ckChild.ckid == FOURCC_RIFF) && 
                            (ckChild.fccType == DMUS_FOURCC_TOOL_FORM))
                        {
			                hr = LoadTool(pParser);
		                } 
	                }
                    pParser->LeaveList();
					break;
			}
			break;
		}
	}
    pParser->LeaveList();

	return hr;
}

HRESULT CCollection::LoadTool(CRiffParser *pParser)
{
	RIFFIO ckNext;
	DWORD cbSize;
	
	DMUS_IO_TOOL_HEADER ioDMToolHdr;
	DWORD *pdwPChannels = NULL;

	HRESULT hr = S_OK; 

    pParser->EnterList(&ckNext);

    if (pParser->NextChunk(&hr))
    {
		if(ckNext.ckid != DMUS_FOURCC_TOOL_CHUNK)
		{
            pParser->LeaveList();
            Trace(1,"Error: Tool header chunk not first in tool list.\n");
			return DMUS_E_TOOL_HDR_NOT_FIRST_CK;
		}	
		
		hr = pParser->Read(&ioDMToolHdr, sizeof(DMUS_IO_TOOL_HEADER));
		
		if(ioDMToolHdr.ckid == 0 && ioDMToolHdr.fccType == NULL)
		{
			pParser->LeaveList();
            Trace(1,"Error: Invalid Tool header.\n");
			return DMUS_E_INVALID_TOOL_HDR;
		}
		
		if(ioDMToolHdr.cPChannels)
		{
			pdwPChannels = new DWORD[ioDMToolHdr.cPChannels];
			// subtract 1 from cPChannels, because 1 element is actually stored
			// in the ioDMToolHdr array.
			cbSize = (ioDMToolHdr.cPChannels - 1) * sizeof(DWORD);
			if(pdwPChannels)
			{
				pdwPChannels[0] = ioDMToolHdr.dwPChannels[0];
				if( cbSize )
				{
					hr = pParser->Read(&pdwPChannels[1], cbSize);
					if(FAILED(hr))
					{
						delete [] pdwPChannels;
						pdwPChannels = NULL;
                        pParser->LeaveList();
                        Trace(1,"Error: File read error loading Tool.\n");
						return DMUS_E_CANNOTREAD;
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}
	else
	{
        pParser->LeaveList();
        Trace(1,"Error reading Tool chunk - not RIFF format.\n");
		hr = DMUS_E_DESCEND_CHUNK_FAIL;
	}
    while (pParser->NextChunk(&hr))
    {
        if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
		    && ckNext.fccType == ioDMToolHdr.fccType) ||
            (ckNext.ckid == ioDMToolHdr.ckid))
		{
            pParser->SeekBack();
			hr = CreateTool(ioDMToolHdr, pParser->GetStream(), pdwPChannels);
            pParser->SeekForward();
		} 
	}

    pParser->LeaveList();

    if( pdwPChannels )
    {
        delete [] pdwPChannels;
        pdwPChannels = NULL;
    }

	return hr;
}

HRESULT CCollection::CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels)
{
	assert(pStream);

	IDirectMusicTool* pDMTool = NULL;
	HRESULT hr = DirectMusicCreateInstance(ioDMToolHdr.guidClassID,
								  NULL,
								  IID_IDirectMusicTool,
								  (void**)&pDMTool);
	IPersistStream *pIPersistStream = NULL;
	
	if(SUCCEEDED(hr))
	{
		hr = pDMTool->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
	}
    else
    {
        Trace(1,"Error creating tool for loading\n");
    }

	if(SUCCEEDED(hr))
	{
		hr = pIPersistStream->Load(pStream);
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1,"Error loading data into tool\n");
        }
#endif
	}

	if(SUCCEEDED(hr))
	{
		hr = InsertTool(pDMTool, pdwPChannels, ioDMToolHdr.cPChannels, ioDMToolHdr.lIndex, &ioDMToolHdr.guidClassID);  
	}

	if(pIPersistStream)
	{
		pIPersistStream->Release();
	}
	
	if(pDMTool)
	{
		pDMTool->Release();
	}

	return hr;
}

HRESULT CCollection::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CCollection::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CCollection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CCollection::GetDescriptor);
	V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusiCCollection);
}

STDMETHODIMP CCollection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CCollection::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CCollection::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CCollection::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_TOOLGRAPH_FORM,CLSID_DirectMusiCCollection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\csynth.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
//      CSynth.cpp
//      Copyright (c) Microsoft Corporation 1996, 1997, 1998
//

#include "simple.h"
#include <mmsystem.h>
#include "dsoundp.h"   
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include "CSynth.h"
#include "debug.h"
#include "..\shared\xsoundp.h" 

CSynth::CSynth() : CMemTrack(DMTRACK_SYNTH)
{
    m_pSynthWorker = NULL;
    m_dssequencer = NULL;
    m_MasterClock.m_pParent = this;
	m_cRef = 0;

    DWORD nIndex;
    CVoice *pVoice;

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_ppControl = NULL;
    m_dwControlCount = 0;
    m_nMaxVoices = 0;
    m_nExtraVoices = 0; 
    m_stLastTime = 0; 
    m_rtLastTime = 0;
    m_dwSampleRate = 48000;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
    SetGainAdjust(m_lGainAdjust);
}

/*HRESULT CSynth::Initialize()
{
    HRESULT hr = DirectSoundCreateSequencer(NULL, 1000, &m_dssequencer);
	return hr;
}*/

CSynth::~CSynth()

{
    CVoice *pVoice;

    if (m_fCSInitialized)
    {
        // If CS never initialized, nothing else will have been set up
        //
        Close();
        while (pVoice = m_VoicesInUse.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesFree.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesExtra.RemoveHead())
        {
            delete pVoice;
        }

        DeleteCriticalSection(&m_CriticalSection);

        if(m_dssequencer)
        {
            m_dssequencer->Release();
        }
//        if(m_pClock){
//            m_pClock->Release();
//        }
    }
}

// CSynth::QueryInterface
//
STDMETHODIMP
CSynth::QueryInterface(const IID &iid,
                                   void **ppv)
{

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynthX) {
        *ppv = static_cast<IDirectMusicSynthX*>(this);
    }
    else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}


// CSynth::AddRef
//
STDMETHODIMP_(ULONG)
CSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CSynth::Release
//
STDMETHODIMP_(ULONG)
CSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSynth::SetMasterVolume(LONG lVolume)

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    m_lVolume =  lVolume;
    m_lGainAdjust = m_lVolume + m_lBoost;

    SetGainAdjust(m_lGainAdjust);
    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSynth::GetMasterClock(
	IReferenceClock **ppClock)	// Pointer to master <i IReferenceClock>, 
								// used by all devices in current instance of DirectMusic.

{
    return m_MasterClock.QueryInterface(IID_IReferenceClock,(void **) ppClock);
}


short CSynth::ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount)

{
    if (nCount > nOld)
    {
        short nNew = nCount - nOld;
        for (;nNew != 0; nNew--)
        {
            CVoice *pVoice = new CVoice;
            if (pVoice != NULL)
            {
                pList->AddHead(pVoice);
            }
        }
    }
    else
    {
        short nNew = nOld - nCount;
        for (;nNew > 0; nNew--)
        {
            CVoice *pVoice = pList->RemoveHead();
            if (pVoice != NULL)
            {
                delete pVoice;
            }
            else 
            {
                nCount += nNew;
                break;
            }
        }
    }
    return nCount;
}

HRESULT CSynth::SetMaxVoices(short nVoices,short nTempVoices)

{
    ::EnterCriticalSection(&m_CriticalSection);

    m_nMaxVoices = ChangeVoiceCount(&m_VoicesFree,m_nMaxVoices,nVoices);
    m_nExtraVoices = ChangeVoiceCount(&m_VoicesExtra,m_nExtraVoices,nTempVoices);

    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSynth::SetNumChannelGroups(DWORD dwCableCount)

{
    HRESULT hr = S_OK;
    CControlLogic **ppControl;
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_dwControlCount != dwCableCount)
    {
        try
        {
            ppControl = new CControlLogic *[dwCableCount];
        }
        catch( ... )
        {
            ppControl = NULL;
        }

        if (ppControl)
        {
            DWORD dwX;
            for (dwX = 0; dwX < dwCableCount; dwX++)
            {
                ppControl[dwX] = NULL;
            }
            if (m_dwControlCount < dwCableCount)
            {
                for (dwX = 0; dwX < m_dwControlCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (;dwX < dwCableCount; dwX++)
                {
                    try
                    {
                        ppControl[dwX] = new CControlLogic;
                    }
                    catch( ... )
                    {
                        ppControl[dwX] = NULL;
                    }

                    if (ppControl[dwX])
                    {
                        hr = ppControl[dwX]->Init(&m_Instruments, this);
                        if (FAILED(hr))
                        {
                            delete ppControl[dwX];
                            ppControl[dwX] = NULL;
                            dwCableCount = dwX;
                            break;
                        }

                        ppControl[dwX]->SetGainAdjust(m_vrGainAdjust);
                    }
                    else
                    {
                        dwCableCount = dwX;
                        break;
                    }
                }
            }
            else
            {
                AllNotesOff();
                for (dwX = 0; dwX < dwCableCount; dwX++)
                {
                    ppControl[dwX] = m_ppControl[dwX];
                }
                for (; dwX < m_dwControlCount; dwX++)
                {
                    if (m_ppControl[dwX])
                    {
                        delete m_ppControl[dwX];
                    }
                }
            }
            if (m_ppControl)
            {
                delete[] m_ppControl;
            }
            m_ppControl = ppControl;
            m_dwControlCount = dwCableCount;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

void CSynth::SetGainAdjust(VREL vrGainAdjust)
{
    DWORD idx;

    m_vrGainAdjust = vrGainAdjust;
    ::EnterCriticalSection(&m_CriticalSection);
    
    for (idx = 0; idx < m_dwControlCount; idx++)
    {
        m_ppControl[idx]->SetGainAdjust(m_vrGainAdjust);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

STDMETHODIMP CSynth::Init(DWORD dwVoicePoolSize)

{
    HRESULT hr;
    ::EnterCriticalSection(&m_CriticalSection);
    hr = DirectSoundCreateSequencer(NULL, 1000, &m_dssequencer);
    if (SUCCEEDED(hr))
    {
        hr = Activate();
    }
    if (SUCCEEDED(hr))
    {   
        hr = SetNumChannelGroups(0);
    }
    if (SUCCEEDED(hr))
    {
        SetMaxVoices((short) dwVoicePoolSize, 8);
    }
//    m_vrGainAdjust = 6 * 100;            // Default 6 dB boost
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSynth::Close()

{
    Deactivate();
    ::EnterCriticalSection(&m_CriticalSection);
    AllNotesOff();
    DWORD dwX;
    for (dwX = 0; dwX < m_dwControlCount; dwX++)
    {
        if (m_ppControl[dwX])
        {
            delete m_ppControl[dwX];
        }
    }
    m_dwControlCount = 0;
    if (m_ppControl)
    {
        delete[] m_ppControl;
        m_ppControl = NULL;
    }
    m_stLastTime = 0;
    m_rtLastTime = 0;
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}
   
static void WINAPI _SynthWorker(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    ((CSynth *)lpParam)->DoWork(prtWakeUp);
}

extern CBossMan g_BossMan;

HRESULT CSynth::Activate()

{
    if (!m_pSynthWorker)
    {
        m_pSynthWorker = g_BossMan.InstallWorker(_SynthWorker,this,5,"DM Worker: Synth (MilsPerSecond)");
    }
    m_stLastTime = 0;
    m_rtLastTime = 0;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_dwDLSVoices = 0;
    m_dwWaveVoices = 0;
    m_dwStreamVoices = 0;
    m_dwFreeVoices = 0;
    DMusicRegisterPerformanceCounter( "DM Synth Active DLS Voices",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_dwDLSVoices );
    DMusicRegisterPerformanceCounter( "DM Synth Active Wave Voices",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_dwWaveVoices );
    DMusicRegisterPerformanceCounter( "DM Synth Active Stream Voices",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_dwStreamVoices );
    DMusicRegisterPerformanceCounter( "DM Synth Free Voices",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_dwFreeVoices );
#endif
    return S_OK;
}

HRESULT CSynth::Deactivate()

{
    if (m_pSynthWorker)
    {
        m_pSynthWorker->PinkSlip();
        m_pSynthWorker = NULL;
    }
    AllNotesOff();
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter( "DM Synth Active DLS Voices");
    DMusicUnregisterPerformanceCounter( "DM Synth Active Wave Voices");
    DMusicUnregisterPerformanceCounter( "DM Synth Active Stream Voices");
    DMusicUnregisterPerformanceCounter( "DM Synth Free Voices");
#endif
    return S_OK;
}

void CSynth::DoWork(REFERENCE_TIME *prtWakeUp)

{
    DirectSoundDoWork();

    CVoice *pVoice;
    CVoice *pNextVoice;

    ::EnterCriticalSection(&m_CriticalSection);

    // There seems to be a 1% drift between the audio time and the hardware time on Xbox.
    // This synchronizes the two clocks

    m_MasterClock.GetTime(&m_rtLastTime);
    m_dssequencer->SetTime(m_rtLastTime);

    pVoice = m_VoicesInUse.GetHead();

    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        pNextVoice = pVoice->GetNext();
        pVoice->DoWork(this);
        if (pVoice->m_fInUse == FALSE) 
        {
            m_VoicesInUse.Remove(pVoice);
            m_VoicesFree.AddHead(pVoice);
        }
    }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DWORD dwDLSVoices = 0;
    DWORD dwWaveVoices = 0;
    DWORD dwStreamVoices = 0;
    DWORD dwFreeVoices = m_VoicesFree.GetCount() + m_VoicesExtra.GetCount();
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_fWave)
        {
            if (pVoice->m_fStreamed)
            {
                dwStreamVoices++;
            }
            else
            {
                dwWaveVoices++;
            }
        }
        else
        {
            dwDLSVoices++;
        }
    }

    m_dwDLSVoices = dwDLSVoices;
    m_dwWaveVoices = dwWaveVoices;
    m_dwStreamVoices = dwStreamVoices;
    m_dwFreeVoices = dwFreeVoices;
#endif
    ::LeaveCriticalSection(&m_CriticalSection);
}

CVoice *CSynth::OldestVoice()

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    if (pBest)
    {
        pVoice = pVoice->GetNext();
        for (;pVoice;pVoice = pVoice->GetNext())
        {
            if (!pVoice->m_fTag)
            {
                if (pBest->m_fTag)
                {
                    pBest = pVoice;
                }
                else
                {
                    if (pVoice->m_dwPriority <= pBest->m_dwPriority)
                    {
                        if (pVoice->m_fNoteOn) 
                        {
                            if (pBest->m_fNoteOn)
                            {
                                if (pBest->m_rtStartTime > pVoice->m_rtStartTime)
                                {
                                    pBest = pVoice;
                                }
                            }
                        }
                        else
                        {
                            if (pBest->m_fNoteOn ||
                                (pBest->m_rtStopTime < pVoice->m_rtStopTime))
                            {
                                pBest = pVoice;
                            }
                        }
                    }
                }
            }
        }
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

CVoice *CSynth::StealVoice(DWORD dwPriority)

{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_dwPriority <= dwPriority)
        {
            if (!pBest)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn == FALSE) 
                {
                    if ((pBest->m_fNoteOn == TRUE) ||
                        (pBest->m_rtStopTime > pVoice->m_rtStopTime))
                    {
                        pBest = pVoice;
                    }
                }
                else
                {
                    if (pBest->m_rtStartTime > pVoice->m_rtStartTime)
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->m_fInUse = FALSE; 
        m_VoicesInUse.Remove(pBest);

        pBest->SetNext(NULL);
    }
    return pBest;
}

void CSynth::QueueVoice(CVoice *pVoice)

/*  This function queues a voice in the list of currently 
    synthesizing voices. It places them in the queue so that
    the higher priority voices are later in the queue. This
    allows the note stealing algorithm to take off the top of
    the queue.
    And, we want older playing notes to be later in the queue
    so the note ons and offs overlap properly. So, the queue is
    sorted in priority order with older notes later within one
    priority level.
*/

{
    CVoice *pScan = m_VoicesInUse.GetHead();
    CVoice *pNext = NULL;
    if (!pScan) // Empty list?
    {
        m_VoicesInUse.AddHead(pVoice);
        return;
    }
    if (pScan->m_dwPriority > pVoice->m_dwPriority)
    {   // Are we lower priority than the head of the list?
        m_VoicesInUse.AddHead(pVoice);
        return;
    }

    pNext = pScan->GetNext();
    for (;pNext;)
    {
        if (pNext->m_dwPriority > pVoice->m_dwPriority)
        {
            // Lower priority than next in the list.
            pScan->SetNext(pVoice);
            pVoice->SetNext(pNext);
            return;
        }
        pScan = pNext;
        pNext = pNext->GetNext();
    }
    // Reached the end of the list.
    pScan->SetNext(pVoice);
    pVoice->SetNext(NULL);
}

void CSynth::StealNotes(REFERENCE_TIME rtTime)

{
    CVoice *pVoice;
    long lToMove = m_nExtraVoices - m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        if (lToMove > 0)
        {
            pVoice = m_VoicesInUse.GetHead();
            for (;pVoice;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fTag) // Voice is already slated to be returned.
                {
                    lToMove--;
                }
            }
            for (;lToMove > 0;lToMove--)
            {
                pVoice = OldestVoice();
                if (pVoice != NULL)
                {
                    pVoice->QuickStopVoice(rtTime);
                }
                else break;
            }
        }
    }
}

STDMETHODIMP CSynth::Unload(HANDLE hDownload,
                       HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),
                       HANDLE hUserData)
{
    return m_Instruments.Unload( hDownload, lpFreeMemory, hUserData);
}

STDMETHODIMP CSynth::Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree) 

{
    return m_Instruments.Download( phDownload, (DWORD *) pdwData,  bpFree);
}

STDMETHODIMP CSynth::SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg)
{
	::EnterCriticalSection(&m_CriticalSection);
    if ( rt == 0 ) // Special case of time == 0.
    {
        rt = m_rtLastTime;
    }

    REFERENCE_TIME rtNow;

    m_MasterClock.GetTime(&rtNow);
    m_dssequencer->SetTime(rtNow);

    if (dwGroup <= m_dwControlCount)
    {
        if (dwGroup == 0) // Play all groups if 0.
        {
            for (; dwGroup < m_dwControlCount; dwGroup++)
            {
                m_ppControl[dwGroup]->RecordMIDI(rt,(BYTE) (dwMsg & 0xFF), 
                    (BYTE)((dwMsg >> 8) & 0x7F),(BYTE)((dwMsg >> 16) & 0x7F));
            }
        }
        else
        {
            m_ppControl[dwGroup - 1]->RecordMIDI(rt,(BYTE) (dwMsg & 0xFF), 
                    (BYTE)((dwMsg >> 8) & 0x7F),(BYTE)((dwMsg >> 16) & 0x7F));
        }
    }
	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}



STDMETHODIMP CSynth::SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength)
{
	::EnterCriticalSection(&m_CriticalSection);
    if ( rt == 0 ) // Special case of time == 0.
    {
        rt = m_rtLastTime;
    }


    REFERENCE_TIME rtNow;

    m_MasterClock.GetTime(&rtNow);
    m_dssequencer->SetTime(rtNow);

    if (dwGroup <= m_dwControlCount)
    {
        if (dwGroup == 0) // Play all groups if 0.
        {
            for (; dwGroup < m_dwControlCount; dwGroup++)
            {
                m_ppControl[dwGroup]->RecordSysEx(dwLength,pbMsg, rt); 
            }
        }
        else
        {
            m_ppControl[dwGroup - 1]->RecordSysEx(dwLength,pbMsg, rt); 
        }
    }
	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}

HRESULT CSynth::AllNotesOff()

{
    CVoice *pVoice;
    ::EnterCriticalSection(&m_CriticalSection);
    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->m_fInUse = FALSE; 
        m_VoicesFree.AddHead(pVoice);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return (S_OK);
}

STDMETHODIMP CSynth::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);
    
    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->SetChannelPriority(dwChannel,dwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CSynth::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to get channel priority on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_ppControl)
        {
            hr = m_ppControl[dwChannelGroup]->GetChannelPriority(dwChannel,pdwPriority);
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


//////////////////////////////////////////////////////////
// Directx8 Methods 

STDMETHODIMP CSynth::PlayWave(
    REFERENCE_TIME rt, 
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    PREL prPitch,
    VREL vrVolume,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectSoundWave *pIWave, 
    DWORD *pdwVoiceID 
    )
{
    HRESULT hr = S_OK;
    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        Trace(1,"Error: Request to set play voice on channel group %ld, channel %ld, is out of range.\n",
            dwChannelGroup,dwChannel);
        hr = E_INVALIDARG;
    }

    if ( rt == 0 ) // Special case of time == 0.
    {
        rt = m_rtLastTime;
    }

    m_ppControl[dwChannelGroup]->RecordWaveEvent(
        rt, 
        (BYTE)(dwChannel & 0xF), 
        vrVolume, 
        prPitch, 
        stVoiceStart,
        stLoopStart,
        stLoopEnd,
        pIWave,
        pdwVoiceID);

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CSynth::StopWave(
    REFERENCE_TIME rt, 
    DWORD dwVoiceId )
{
    HRESULT hr = S_OK;
    STIME stTime;

    ::EnterCriticalSection(&m_CriticalSection);

    if ( rt == 0 ) // Special case of time == 0.
    {
        rt = m_rtLastTime;
    }

    CVoice * pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if ( pVoice->m_dwVoiceId == dwVoiceId )
        {
            pVoice->StopVoice(rt);
            if (pVoice->m_fInUse == FALSE) 
            {
                m_VoicesInUse.Remove(pVoice);
                m_VoicesFree.AddHead(pVoice);
            }
            break;
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CSynth::AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers  )
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
    if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ppControl[dwChannelGroup]->AssignChannelToOutput(dwChannel, pBuffer, dwMixBins, pbControllers);
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
} 

CClock::CClock()

{
    m_pParent = NULL;
    m_dwLastPosition = 0;
    m_llSampleTime = 0;
}


STDMETHODIMP CClock::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CClock::AddRef()
{
    return m_pParent->AddRef();
}

STDMETHODIMP_(ULONG) CClock::Release()
{
    return m_pParent->Release();
}

STDMETHODIMP CClock::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

EXTERN_C DWORD WINAPI DirectSoundGetSampleTime(void);

STDMETHODIMP CClock::GetTime(LPREFERENCE_TIME pTime)
{
    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	EnterCriticalSection( &m_pParent->m_CriticalSection );

    DWORD dwPosition = DirectSoundGetSampleTime();

    // Check to see if we looped around, which happens every 24 hours

    LONGLONG delta;
    if(dwPosition < m_dwLastPosition){
        // This is either a loop, or a dsound bug

        if(dwPosition < 100000 && m_dwLastPosition > (1 << 30) ){
            Trace(-1, "CClock::GetTime sample time wrapped (as it should every 24 hours. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = ((((LONGLONG) 1) << 32) + dwPosition) - m_dwLastPosition;
        }
        else {
            Trace(-1, "CClock::GetTime stream position decreased unexpectedly. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = 0; // Ignore.
            m_dwLastPosition = dwPosition; // Catch up. (Sometimes DSound resets the stream on us.)
        }
    }
    else {
        delta = dwPosition - m_dwLastPosition;
    }

    m_dwLastPosition = dwPosition;
    m_llSampleTime += delta;
    LONGLONG llTemp = m_llSampleTime * 10000;
	llTemp /= 48000;
	llTemp *= 1000;
    *pTime = llTemp;
	LeaveCriticalSection( &m_pParent->m_CriticalSection );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSynthCreate

STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth )
{
    CSynth *pSynth = new CSynth;
    if (pSynth)
    {
        return pSynth->QueryInterface(iid,ppDMSynth);
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dslink.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	DSLink.h

#ifndef __DS_LINK__
#define __DS_LINK__

#include <math.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "clist.h"


class CDSLink;
typedef HRESULT (CDSLink::*SINKPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pvPropertyData, PULONG pcbPropertyData);

#define SINKPROP_F_STATIC                0x00000001
#define SINKPROP_F_FNHANDLER             0x00000002

#include <pshpack4.h>
// Struct for holding a property item supported by the sink
//
struct SINKPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG   	ulId;                   // What item?

    ULONG   	ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // SINKPROP_F_xxx

	LPVOID  	pPropertyData;    
    ULONG   	cbPropertyData;         // and its size

    SINKPROPHANDLER pfnHandler;         // Handler fn if SINKPROP_F_FNHANDLER
};
#include <poppack.h>

class CDSLink : public CListItem, public IDirectMusicSynthSink, public IKsControl
{
friend class CClock;
friend class CDSLinkList;
public:
	CDSLink * GetNext();
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynthSink
public:
    virtual STDMETHODIMP Init(IDirectMusicSynth *pSynth);
	virtual STDMETHODIMP SetMasterClock(IReferenceClock *pClock);
	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
	virtual STDMETHODIMP Activate(BOOL fEnable);
	virtual STDMETHODIMP SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	virtual STDMETHODIMP RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);
    virtual STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual STDMETHODIMP GetDesiredBufferSize(LPDWORD pdwBufferSizeInSamples);

// IKsPropertySet
    virtual STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
						CDSLink();
						~CDSLink();
	void				Clear();
private:
	IDirectMusicSynth *	m_pSynth;		// Reference to synth that uses this.
    CClock				m_Clock;        // Latency clock.
	IReferenceClock *	m_pIMasterClock;	// Master clock from app.
	CSampleClock		m_SampleClock;	// Use to synchronize timing with master clock.
	long				m_cRef;
	WAVEFORMATEX		m_wfSynth;		// Waveform requested by synth.

	LPDIRECTSOUND 		m_pDSound;			
	LPDIRECTSOUNDBUFFER	m_pPrimary;			// Primary buffer.
	LPDIRECTSOUNDBUFFER	m_pBuffer;			// Mix buffer.
	LPDIRECTSOUNDBUFFER	m_pExtBuffer;		// Optional buffer from SetDirectSound.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
    BOOL                m_fCSInitialized;   //  Was CS initialized?
	LONGLONG			m_llAbsPlay;		// Absolute point where play head is.
	DWORD				m_dwLastPlay;		// Point in buffer where play head is.
	LONGLONG			m_llAbsWrite;	    // Absolute point we've written up to.
	DWORD				m_dwLastWrite;	    // Last position we wrote to in buffer.
	DWORD				m_dwBufferSize;		// Size of buffer.
	DWORD				m_dwWriteTo;		// Distance between write head and where we are writing.
	DWORD               m_dwWriteFromMax;   // Max distance observed between play and write head.
	BOOL				m_fActive;			// Currently active.

	HRESULT				Connect();
	HRESULT				Disconnect();
	void				SynthProc();

	static SINKPROPERTY m_aProperty[];
	static const int m_nProperty;
	static SINKPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

    HRESULT HandleLatency(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    // helpers
    LONGLONG SampleToByte(LONGLONG llSamples) {return llSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    DWORD SampleToByte(DWORD dwSamples) {return dwSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    LONGLONG ByteToSample(LONGLONG llBytes)   {return llBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    DWORD ByteToSample(DWORD dwBytes)   {return dwBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    LONGLONG SampleAlign(LONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
    DWORD SampleAlign(DWORD dwBytes)    {return SampleToByte(ByteToSample(dwBytes));}
    
    BOOL IsValidFormat(LPCWAVEFORMATEX pwf)
    {
        return (pwf &&
            pwf->wFormatTag == WAVE_FORMAT_PCM &&
            (pwf->nChannels == 1 || pwf->nChannels == 2) &&
            (pwf->nSamplesPerSec == 44100 || pwf->nSamplesPerSec == 22050 || pwf->nSamplesPerSec == 11025) &&
            pwf->wBitsPerSample == 16 &&
            pwf->nBlockAlign == (pwf->nChannels * (pwf->wBitsPerSample / 8)) &&
            pwf->nAvgBytesPerSec == (pwf->nSamplesPerSec * pwf->nBlockAlign));
    }
};


class CDSLinkList : public CList
{
public:
						CDSLinkList();
	BOOL				OpenUp();
    void				CloseDown();
	CDSLink *			GetHead();
	CDSLink *			RemoveHead();
	void				Remove(CDSLink *pLink);
	void				AddTail(CDSLink *pLink);
	CDSLink *			GetItem(LONG index);
	BOOL				InitThread();
	void				ActivateLink(CDSLink *pLink);
	void				DeactivateLink(CDSLink *pLink);			
	void				SynthProc();
    
    BOOL                m_fOpened;
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
    HANDLE				m_hThread;          // Handle for synth thread.
	BOOL				m_fPleaseDie;		// Triggers exit.
    DWORD				m_dwThread;         // ID for thread.
    HANDLE				m_hEvent;           // Used to signal thread.
	DWORD				m_dwCount;          // Number of sinks
    DWORD               m_dwResolution;     // Synth thread timeout (ms)
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthSinkFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthSinkFactory();

	// Destructor
	~CDirectMusicSynthSinkFactory();

private:
	long m_cRef;
};


#endif // __DS_LINK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\error.h ===
// Copyright (c) 1998 Microsoft Corporation
//      Error.h

#define RA_E_FIRST				(OLE_E_FIRST + 5000)

#define E_BADWAVE		        (RA_E_FIRST + 1)    // Bad wave chunk
#define E_NOTPCM		        (RA_E_FIRST + 2)    // Not PCM data in wave
#define E_NOTMONO		        (RA_E_FIRST + 3)    // Wave not MONO
#define E_BADARTICULATION       (RA_E_FIRST + 4)    // Bad articulation chunk
#define E_BADREGION		        (RA_E_FIRST + 5)    // Bad region chunk
#define E_BADWAVELINK	        (RA_E_FIRST + 6)    // Bad link from region to wave
#define E_BADINSTRUMENT	        (RA_E_FIRST + 7)    // Bad instrument chunk
#define E_NOARTICULATION        (RA_E_FIRST + 8)    // No articulation found in region
#define E_NOWAVE		        (RA_E_FIRST + 9)    // No wave found for region.
#define E_BADCOLLECTION	        (RA_E_FIRST + 10)   // Bad collection chunk.
#define E_NOLOADER   	        (RA_E_FIRST + 11)   // No IRALoader interface 
#define E_NOLOCK		        (RA_E_FIRST + 12)   // Unable to lock a region.
#define E_TOOBUSY		        (RA_E_FIRST + 13)   // RActive to busy to fully follow command.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\float.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include "float.h"
#endif

#ifdef _ALPHA_
#include <math.h>
#endif		// _ALPHA_


#ifndef _ALPHA_

#ifndef DBG
extern "C" int _fltused = 1;
#endif
// asm_fsave(rgbState)
//
// Store the floating point state into <rgbState> and reinitialize the FPU.
//
void __cdecl asm_fsave(char *rgbState)
{
	_asm
	{
		mov		eax, dword ptr rgbState
		fsave	[eax]
	}
}


// asm_frestore(rgbState)
//
// Restore a previously saved floating point state <rgbState>.
//
void __cdecl asm_frestore(const char *rgbState)
{
	_asm
	{
		fwait
		mov		eax, dword ptr rgbState
		frstor	[eax]
	}
}


// FLOATSAFE
//
// Saves floating point state on construction and restores on destruction.
//
struct FLOATSAFE
{
	char m_rgbState[105];
	FLOATSAFE::FLOATSAFE(void)
	{
		asm_fsave(m_rgbState);
	}
	FLOATSAFE::~FLOATSAFE(void)
	{
		asm_frestore(m_rgbState);
	}
};


// asm_fdiv()
//
float __cdecl asm_fdiv(float flNum, float flDenom)
{
	float flResult = (float) 0.0;

	if (flDenom != (float) 0.0)
	{
		_asm
		{									 
			fld       flNum
			fdiv      flDenom
			fstp      flResult
			fnclex				; clear the status word of exceptions
		}
	}

	return(flResult);
}


// asm__fsin()
//
float __cdecl asm_fsin(float flRad)
{
	float flSine;

	_asm
	{
		fld       flRad
		fsin
		fstp      flSine
		fnclex				; clear the status word of exceptions
	}

	return(flSine);
}


// asm__fcos()
//
float __cdecl asm_fcos(float flRad)
{
	float flCosine;

	_asm
	{
		fld       flRad
		fcos
		fstp      flCosine
		fnclex				; clear the status word of exceptions
	}

	return(flCosine);
}


// asm_flog2()
//
float __cdecl asm_flog2(float flX)
{
	float flLog;

	_asm
	{
		fld1
		fld		flX
		fyl2X
		fstp	flLog;
		fnclex				; clear the status word of exceptions
	}
	
	return flLog;
}


// asm_ftol()
//
long __cdecl asm_ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}


// asm_fpow()
//
float __cdecl asm_fpow(float flX, float flY)
{
	float flHalf = (float) 0.5;
	float flOne = (float) 1.0;
	float flResult = (float) 0.0;

	if (flX == (float) 0.0 && flY > (float) 0.0)
	{
		flResult = (float) 0.0;
	}
	else if (flX == (float) 0.0 && flY <= (float) 0.0)
	{
		flResult = (float) 1.0;
	}
	else if (flY == (float) 0.0)
	{
		flResult = (float) 1.0;
	}
	else
	{
		BOOL fNeg = FALSE;
			// Ok, if X is negative the sign is positive if the Y is even
			// and negative if Y is odd.  Fractions can't be done.
		if (flX < (float) 0.0)
		{
			long lY = asm_ftol(flY);

			if ((float) lY == flY)	// Only fix it if we have a integer poer
			{
				flX = -flX;

				if (lY % 2)
				{
					fNeg = TRUE;
				}
			}
		}

		flX = flY * asm_flog2(flX);

		if (max(-flX,flX) < flOne)
			// Is the power is in the range which F2XM1 can handle?
		{
			_asm
			{
				fld		flX				// Put flX in ST[0]			
				f2xm1					// ST := 2^ST - 1
				fadd	flOne			// ST := 2^mantissa
				fstp	flResult		// Store result
				fnclex					// clear the status word of exceptions
			}	
		}
		else					// Nope, we've got to scale first
		{
			_asm
			{
				fld		flX				// Put flX in ST[0]
				fld		ST				// Duplicate ST
				frndint					// Integral value in ST
				fsub	ST(1),ST		// Fractional value in ST(1)
				fxch					// Factional value in ST
				f2xm1					// ST := 2^ST - 1
				fadd	flOne			// ST := 2^frac
				fscale					// ST := 2^frac * 2^integral
				fstp	flResult		// Store result
				fnclex					// clear the status word of exceptions
			}
		}

		if (fNeg)
		{
			flResult = -flResult;
		}
	}

	return flResult;
}

#endif		// _ALPHA_


// fp_ftol()
//
STDAPI_(long) fp_ftol(float flX)
{
#ifdef _ALPHA_
	return (long)flX;
#else
	FLOATSAFE fs;
	return(asm_ftol(flX));
#endif
}


// fp_ltof()
//
STDAPI_(float) fp_ltof(long lx)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(float(lx));
}


// fp_fadd()
//
STDAPI_(float) fp_fadd(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX + flY);
}


// fp_fsub()
//
STDAPI_(float) fp_fsub(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX - flY);
}


// fp_fmul()
//
STDAPI_(float) fp_fmul(float flX, float flY)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(flX * flY);
}


// fp_fdiv()
//
STDAPI_(float) fp_fdiv(float flNum, float flDenom)
{
#ifdef _ALPHA_
	return flNum/flDenom;
#else
	FLOATSAFE fs;
	return(asm_fdiv(flNum,flDenom));
#endif
}


// fp_fabs()
//
STDAPI_(float) fp_fabs(float flX)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return max(-flX,flX);
}


// fp_fsin()
//
STDAPI_(float) fp_fsin(float flRad)
{
#ifdef _ALPHA_
	return sin(flRad);
#else
	FLOATSAFE fs;
	return(asm_fsin(flRad));
#endif
}


// fp_fcos()
//
STDAPI_(float) fp_fcos(float flRad)
{
#ifdef _ALPHA_
	return cos(flRad);
#else
	FLOATSAFE fs;
	return(asm_fcos(flRad));
#endif
}


// fp_fpow()
//
STDAPI_(float) fp_fpow(float flX, float flY)
{
#ifdef _ALPHA_
	return pow(flX, flY);
#else
	FLOATSAFE fs;
	return(asm_fpow(flX,flY));
#endif
}


// fp_flog2()
//
STDAPI_(float) fp_flog2(float flX)
{
#ifdef _ALPHA_
	return log(flX);
#else
	FLOATSAFE fs;
	return(asm_flog2(flX));
#endif
}


// fp_flog10()
//
STDAPI_(float) fp_flog10(float flX)
{
#ifdef _ALPHA_
	return log10(flX);
#else
	FLOATSAFE fs;
	#define LOG2OF10 float(3.321928094887)
	return(asm_fdiv(asm_flog2(flX),LOG2OF10));
#endif
}


// fp_fchs()
//
STDAPI_(float) fp_fchs(float flX)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(-flX);
}


// fp_fcmp()
//
STDAPI_(int) fp_fcmp(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif

	if (flA > flB)
		return(1);
	
	if (flA < flB)
		return(-1);

	return(0);
}


// fp_fmin()
//
STDAPI_(float) fp_fmin(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(min(flA,flB));
}


// fp_fmax()
//
STDAPI_(float) fp_fmax(float flA, float flB)
{
#ifndef _ALPHA_
	FLOATSAFE fs;
#endif
	return(max(flA,flB));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\float.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// float.h
//
// Defines fp_ floating point functions which don't rely on the C runtime.
//
// If you don't want to pull in C runtime floating point support, you
// need to include the following in a .cpp file:
//
//     extern "C" int _fltused = 1;
//

// floating point operations
STDAPI_(long)   fp_ftol     (float flX);
STDAPI_(float)  fp_ltof     (long lX);
STDAPI_(float)  fp_fadd     (float fA, float fB);
STDAPI_(float)  fp_fsub     (float fA, float fB);
STDAPI_(float)  fp_fmul     (float fA, float fB);
STDAPI_(float)  fp_fdiv     (float fNum, float fDenom);
STDAPI_(float)  fp_fabs     (float flX);
STDAPI_(float)  fp_fsin     (float flX);
STDAPI_(float)  fp_fcos     (float flX);
STDAPI_(float)  fp_fpow     (float flX, float flY);
STDAPI_(float)  fp_flog2    (float flX);
STDAPI_(float)  fp_flog10   (float flX);
STDAPI_(float)  fp_fchs     (float flX);
STDAPI_(int)    fp_fcmp     (float flA, float flB);
STDAPI_(float)  fp_fmin     (float flA, float flB);
STDAPI_(float)  fp_fmax     (float flA, float flB);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\csynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//      CSynth.h
//

#ifndef __CSYNTH_H__
#define __CSYNTH_H__

#include "synth.h"
#include "..\shared\dowork.h"
#include "..\shared\dmusiccp.h" // For class ids.
#include "..\shared\debug.h" // For class ids.

extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);

#define MAX_CHANNEL_GROUPS	1000
#define MAX_VOICES			1000

class CClock : public IReferenceClock
{
friend class CSynth;
public:

    CClock();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
private:
    CSynth *    	m_pParent;      // Pointer to parent structure.
    DWORD           m_dwLastPosition;
    LONGLONG        m_llSampleTime;
};



class CSynth : public CMemTrack, public IDirectMusicSynthX
{
friend class CClock;
friend class CControlLogic;
friend class CPart;
public:	
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynthX
public:
	virtual STDMETHODIMP Init(DWORD dwVoicePoolSize);
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
    virtual STDMETHODIMP SetMasterVolume(LONG lVolume);
    virtual STDMETHODIMP SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg);
    virtual STDMETHODIMP SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength);
	virtual STDMETHODIMP GetMasterClock(IReferenceClock **ppClock);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
	virtual STDMETHODIMP PlayWave(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwChannel, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, IDirectSoundWave *pIWave, DWORD *pdwVoiceID );
    virtual STDMETHODIMP StopWave(REFERENCE_TIME rt, DWORD dwVoiceId );
    virtual STDMETHODIMP AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers );
    virtual STDMETHODIMP Download(LPHANDLE phDownload, void *pdwData, LPBOOL bpFree);
    virtual STDMETHODIMP Unload(HANDLE hDownload,HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),HANDLE hUserData);

    CSynth();
					~CSynth();
	HRESULT			Initialize();
	HRESULT			Activate();
	HRESULT			Deactivate();
    void            SetGainAdjust(VREL vrGainAdjust);
	HRESULT			Close();
    HRESULT			AllNotesOff();
    HRESULT			SetMaxVoices(short nMaxVoices,short nTempVoices);
public:
    void            DoWork(REFERENCE_TIME *prtWakeUp);
private:
    void			StealNotes(REFERENCE_TIME rtTime);
	short			ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount);

private:
    CWorker *       m_pSynthWorker;
    CVoice *        OldestVoice();
    void            QueueVoice(CVoice *pVoice);
    CVoice *        StealVoice(DWORD dwPriority);
    STIME           m_stLastTime;       // Sample time of last mix.
    REFERENCE_TIME  m_rtLastTime;       // Reference time of last DoWork().
    CVoiceList      m_VoicesFree;       // List of available voices.
    CVoiceList      m_VoicesExtra;      // Extra voices for temporary overload.
    CVoiceList      m_VoicesInUse;      // List of voices currently in use.
    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;      // Number of voices over the limit that can be used in a pinch.

public:
  
    LPDIRECTSOUNDSEQUENCER GetSequencer() { return m_dssequencer; } // For CVoice
private:
    LPDIRECTSOUNDSEQUENCER m_dssequencer;  // The direct sound sequencer

public:	
    VREL            m_vrGainAdjust;     // Final output gain adjust
	DWORD           m_dwSampleRate;		// Sample rate 
    CInstManager    m_Instruments;      // Instrument manager.
	CControlLogic **m_ppControl;		// Array of open ControlLogics.
	DWORD			m_dwControlCount;	// # of open CLs.
    
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;

    // Stuff brought over from UMSynth:
    CClock          m_MasterClock;  // Master clock for timing, derived from DSound.
	long		    m_cRef;
    LONG            m_lVolume;      // in 1/100 dB
    LONG            m_lBoost;       // in 1/100 dB
    LONG            m_lGainAdjust;  // in 1/100 dB

    // For measuring performance
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DWORD           m_dwDLSVoices;
    DWORD           m_dwWaveVoices;
    DWORD           m_dwStreamVoices;
    DWORD           m_dwFreeVoices;
#endif
};

#endif// __CSYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\guids.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include "initguid.h"
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "synth.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#include "dmusicip.h"
#include "dsoundp.h"
#include "..\shared\dmusiccp.h" // For class ids.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#include <ks.h>
#include "umsynth.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#endif
// @@END_DDKSPLIT
#include "dmksctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\guids_dmsynth.cpp ===
// Allows us to compile the source code in guids.cpp to product an object file guids_dmsynth.obj
// (Which avoids an error when linking dmusic.lib.)

#include "guids.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dls.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation
//      dls.cpp
//

#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#include "..\shared\validate.h"
#include <dmusicf.h>
void MemDump(char * prompt);

STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC )
{
    HRESULT hr = E_OUTOFMEMORY;
    CCollection *pCollection = new CCollection;
    if (pCollection)
    {
        hr = pCollection->QueryInterface(iid,ppDMC);
        // If failed, release the object to free it. If succeeded, bring ref count down to 1.
        pCollection->Release(); 
    }
    return hr;
}

extern CInstManager *g_pInstManager;

CCollection::CCollection() : m_MemTrack(DMTRACK_COLLECTION)
{
	m_cRef = 1;
    if (g_pInstManager)
    {
        g_pInstManager->m_CollectionList.AddHead(this);
    }
//	INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
}

CCollection::~CCollection()
{
//	DELETE_CRITICAL_SECTION(&m_CriticalSection);
    if (g_pInstManager)
    {
        g_pInstManager->m_CollectionList.Remove(this);
    }
    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        while (!m_InstrumentList[dwIndex].IsEmpty())
        {
            CInstrument *pInstrument = m_InstrumentList[dwIndex].RemoveHead();
            delete pInstrument;
        }
    }
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        while (!m_WavePool[dwIndex].IsEmpty()) 
        {
            CWave *pWave = m_WavePool[dwIndex].RemoveHead();
            pWave->Release();
        }
    }
}

STDMETHODIMP CCollection::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicCollection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicCollection)
	{
		*ppv = static_cast<IDirectMusicCollection*>(this);
	} 
	else if(iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if(iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}


STDMETHODIMP_(ULONG) CCollection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CCollection::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CCollection::GetClassID( CLSID* pClassID )
{
	V_INAME(CCollection::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicCollection;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CCollection::IsDirty()
{
	return S_FALSE;
}

HRESULT CCollection::Load( IStream* pIStream )
{
	V_INAME(IPersistStream::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == FOURCC_DLS))
    {
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing DLS Collection\n");
        hr = DMUS_E_NOTADLSCOL;
    }
    return hr;
}

void CCollection::AddInstrument(CInstrument *pInstrument)

{
    if (pInstrument != NULL)
    {
        CSourceRegion *pRegion = pInstrument->m_RegionList.GetHead();
        for (;pRegion;pRegion = pRegion->GetNext())
        {
            CWave *pWave = pRegion->m_Sample.m_pWave;
            if (pWave != NULL)
            {
                m_WavePool->AddTail(pWave);
				pWave->AddRef();
            }
        }
        m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
    }
}

extern DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate);
extern DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate);


HRESULT CCollection::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case FOURCC_DLID:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
					break;
				case FOURCC_WVPL:
                    hr = LoadWaves(pParser);
                    break;
				case FOURCC_LINS :
					hr = LoadInstruments(pParser);
					break;
			}
			break;
//		case FOURCC_COLH:
//			DLSHEADER dlsHeader;
//			hr = pParser->Read(&dlsHeader, sizeof(DLSHEADER));
//            m_dwNumInstruments = dlsHeader.cInstruments;
//			break;
//		case FOURCC_PTBL:
//			hr = BuildWaveOffsetTable(pParser);
//			break;
        }
	}
    pParser->LeaveList();
    ResolveConnections();
	return hr;
}


HRESULT CSourceArticulation::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 
    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case FOURCC_ART2 :
        case FOURCC_ART1 : 
            CONNECTIONLIST ConnectionList;
            hr = pParser->Read(&ConnectionList, sizeof(CONNECTIONLIST));
            for (DWORD dwIndex = 0; SUCCEEDED(hr) && (dwIndex < ConnectionList.cConnections); dwIndex++)
            {
                CONNECTION Connection;
                hr = pParser->Read(&Connection, sizeof(CONNECTION));
                switch (Connection.usSource)
                {
                case CONN_SRC_NONE :
                    switch (Connection.usDestination)
                    {
                    case CONN_DST_LFO_FREQUENCY :
                        m_LFO.m_Registers.dwDelta = PitchCents2PitchFract(
                            Connection.lScale,6000*64); // 48000*64 / 8)
                        break;
                    case CONN_DST_LFO_STARTDELAY :
                        m_LFO.m_Registers.dwDelay = (DWORD) TimeCents2Samples(
                            (TCENT) Connection.lScale,1500); // 48000 / 32
                        break;
                    case CONN_DST_EG1_ATTACKTIME :
                        m_VolumeEG.m_Registers.dwAttack = TimeCents2Samples(
                            (TCENT) Connection.lScale,94); // 48000 / 512
                        break;
                    case CONN_DST_EG1_DECAYTIME :
                        m_VolumeEG.m_Registers.dwDecay = TimeCents2Samples(
                        (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG1_SUSTAINLEVEL :
                        {
                            // The nvidia chip takes the sustain level in 
                            // absolute volume, not dB, so first convert.
                            long lTemp = (Connection.lScale >> 16) - 1000;
                            lTemp *= 9600;
                            lTemp /= 1000;
                            lTemp = CDigitalAudio::VRELToVFRACT(lTemp);
                            m_VolumeEG.m_Registers.dwSustain = lTemp >> 4;
                        }
                        break;
                    case CONN_DST_EG1_RELEASETIME :
                        m_VolumeEG.m_Registers.dwRelease = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG2_ATTACKTIME :
                        m_PitchEG.m_Registers.dwAttack = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG2_DECAYTIME :
                        m_PitchEG.m_Registers.dwDecay = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG2_SUSTAINLEVEL :
                        m_PitchEG.m_Registers.dwSustain =
                            (SPERCENT) ((long) (Connection.lScale / 257003));
                        break;
                    case CONN_DST_EG2_RELEASETIME :
                        m_PitchEG.m_Registers.dwRelease = TimeCents2Samples(
                            (TCENT) Connection.lScale,94); 
                        break;
                    case CONN_DST_PAN :
                        m_sDefaultPan = (short) 
                            ((long) ((long) Connection.lScale >> 12) / 125);
                        break;

                    /* DLS2 */
                    case CONN_DST_EG1_DELAYTIME:
                        m_VolumeEG.m_Registers.dwDelay = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG1_HOLDTIME:
                        m_VolumeEG.m_Registers.dwHold  = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG2_DELAYTIME:
                        m_PitchEG.m_Registers.dwDelay  = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_EG2_HOLDTIME:
                        m_PitchEG.m_Registers.dwHold = TimeCents2Samples(
                            (TCENT) Connection.lScale,94);
                        break;
                    case CONN_DST_VIB_FREQUENCY :
                        m_LFO2.m_Registers.dwDelta = PitchCents2PitchFract(
                            Connection.lScale,6000*64);
                        break;    
                    case CONN_DST_VIB_STARTDELAY :
                        m_LFO2.m_Registers.dwDelay = TimeCents2Samples(
                            (TCENT) Connection.lScale,1500);
                        break;                                
                    case CONN_DST_FILTER_CUTOFF:
                        // First, get the filter cutoff frequency, which is relative to a440.
                        m_Filter.m_prCutoff = (PRELS)
                            (Connection.lScale >> 16);
                        // Then, calculate the resulting prel, taking into consideration
                        // the sample rate and the base of the filter coefficient lookup
                        // table, relative to the sample rate (FILTER_FREQ_RANGE).
                        // This number can then be used directly look up the coefficients in the
                        // filter table. 
     //                   m_Filter.m_prCutoffSRAdjust = (PRELS)
     //                       FILTER_FREQ_RANGE - m_Filter.m_prSampleRate + m_Filter.m_prCutoff; 
                        break;
                    case CONN_DST_FILTER_Q:
                        m_Filter.m_vrQ = (VRELS)
                            (Connection.lScale >> 16); //>>>>>>>> not really VRELS, but 1/10th's
     //                   m_Filter.m_iQIndex = (DWORD)
     //                       ((m_Filter.m_vrQ / 15.0f) + 0.5f);
                        break;
                    }
                    break;
                case CONN_SRC_LFO :
                    switch (Connection.usControl)
                    {
                    case CONN_SRC_NONE :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_ATTENUATION :
                            m_LFO.m_vrVolumeScale = (VRELS)
                                ((long) (Connection.lScale >> 16));
                            m_LFO.m_Registers.lAmplitudeModulation = Connection.lScale / 38400;
                            break;
                        case CONN_DST_PITCH :
                            m_LFO.m_prPitchScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            m_LFO.m_Registers.lPitchModulation = Connection.lScale / 614400;
                            break;
                        case CONN_DST_FILTER_CUTOFF:
                            m_LFO.m_prCutoffScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            m_LFO.m_Registers.lFilterCutOffRange = Connection.lScale / 4915200; 
                            break;
                        }
                        break;
                    case CONN_SRC_CC1 :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_ATTENUATION :
                            m_LFO.m_vrMWVolumeScale = (VRELS)
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        case CONN_DST_PITCH :
                            m_LFO.m_prMWPitchScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_LFO.m_prMWCutoffScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        }
                        break;

                    /* DLS2 */
                    case CONN_SRC_CHANNELPRESSURE :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_ATTENUATION :
                            m_LFO.m_vrCPVolumeScale = (VRELS) 
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        case CONN_DST_PITCH :
                            m_LFO.m_prCPPitchScale  = (PRELS) 
                                ((long) (Connection.lScale >> 16)); 
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_LFO.m_prCPCutoffScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        }
                        break;
                    }
                    break;
                case CONN_SRC_KEYONVELOCITY :
                    switch (Connection.usDestination)
                    {
                    case CONN_DST_EG1_ATTACKTIME :
                        m_VolumeEG.m_trVelAttackScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                        break;
                    case CONN_DST_EG2_ATTACKTIME :
                        m_PitchEG.m_trVelAttackScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                        break;

                    /* DLS2 */
                    case CONN_DST_FILTER_CUTOFF:
                        m_Filter.m_prVelScale = (PRELS)
                            ((long) (Connection.lScale >> 16)); 
                        break;
                    }
                    break;
                case CONN_SRC_KEYNUMBER :
                    switch (Connection.usDestination)
                    {
                    case CONN_DST_EG1_DECAYTIME :
                        m_VolumeEG.m_trKeyDecayScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                        break;
                    case CONN_DST_EG2_DECAYTIME :
                        m_PitchEG.m_trKeyDecayScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                        break;

                    /* DLS2 */
                    case CONN_DST_EG1_HOLDTIME :
                        m_PitchEG.m_trKeyDecayScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                        break;
                    case CONN_DST_EG2_HOLDTIME :
                        m_PitchEG.m_trKeyDecayScale = (TRELS)
                            ((long) (Connection.lScale >> 16));
                    case CONN_DST_FILTER_CUTOFF :
                        m_Filter.m_prKeyScale = (PRELS)
                            ((long) (Connection.lScale >> 16));
                        break;
                    }
                    break;
                case CONN_SRC_EG2 :
                    switch (Connection.usDestination)
                    {
                    case CONN_DST_PITCH :
                        m_PitchEG.m_Registers.lPitchScale = Connection.lScale / 614400;
                        break;

                    /* DLS2 */
                    case CONN_DST_FILTER_CUTOFF:
                        m_PitchEG.m_Registers.lFilterCutOff = Connection.lScale / 4915200; 
                        break;
                    }
                    break;      

                /* DLS2 */
                case CONN_SRC_VIBRATO :
                    switch (Connection.usControl)
                    {
                    case CONN_SRC_NONE :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_LFO2.m_prPitchScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            m_LFO2.m_Registers.lPitchModulation = Connection.lScale / 614400;
                            break;
                        }
                        break;
                    case CONN_SRC_CC1 :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_LFO2.m_prMWPitchScale = (PRELS)
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        }
                        break;
                    case CONN_SRC_CHANNELPRESSURE :
                        switch (Connection.usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_LFO2.m_prCPPitchScale  = (PRELS) 
                                ((long) (Connection.lScale >> 16)); 
                            break;
                        }
                        break;
                    }
                    break;
                }
            }
        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSourceRegion::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 

    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case FOURCC_RGNH :
            RGNHEADER RegionHeader;
            hr = pParser->Read(&RegionHeader, sizeof(RGNHEADER));
            m_bKeyHigh = (BYTE) RegionHeader.RangeKey.usHigh;
            m_bKeyLow  = (BYTE) RegionHeader.RangeKey.usLow;
            m_bVelocityHigh = (BYTE) RegionHeader.RangeVelocity.usHigh;
            m_bVelocityLow  = (BYTE) RegionHeader.RangeVelocity.usLow;
            // Old dls collections can have bad velocities...
            if ( m_bVelocityHigh == 0 && m_bVelocityLow == 0 )
                m_bVelocityHigh = 127;
            if (RegionHeader.fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
            {
                m_bAllowOverlap = TRUE;
            }
            else
            {
                m_bAllowOverlap = FALSE;
            }
            m_bGroup = (BYTE) RegionHeader.usKeyGroup;
            break;
        case FOURCC_WSMP :
            WSMPL WaveSample;
            WLOOP WaveLoop;
			hr = pParser->Read(&WaveSample, sizeof(WSMPL));
            m_vrAttenuation = (VRELS) (long) (((WaveSample.lAttenuation) * 10) >> 16);
            m_Sample.m_prFineTune = WaveSample.sFineTune;
            m_Sample.m_bMIDIRootKey = (BYTE) WaveSample.usUnityNote;
			if(WaveSample.cSampleLoops)
			{
				hr = pParser->Read(&WaveLoop, sizeof(WLOOP));
                m_Sample.m_dwLoopStart = WaveLoop.ulStart;
                m_Sample.m_dwLoopEnd = WaveLoop.ulStart + WaveLoop.ulLength;
                m_Sample.m_bOneShot = FALSE;
                m_Sample.m_dwLoopType = WaveLoop.ulType;
			}
            else
            {
                m_Sample.m_bOneShot = TRUE;
            }
            break;
        case FOURCC_WLNK :
            WAVELINK WaveLink;
			hr = pParser->Read(&WaveLink, sizeof(WAVELINK));
            m_sWaveLinkOptions = WaveLink.fusOptions;
            m_dwChannel = WaveLink.ulChannel;
            m_Sample.m_wID = (WORD) WaveLink.ulTableIndex;
            break;
//    m_Sample.m_dwSampleRate = dwSampleRate;
        case FOURCC_LIST:
			switch(ckNext.fccType)  
            {
                case FOURCC_LART :
                case FOURCC_LAR2 :
                m_pArticulation = new CSourceArticulation;
                if (!m_pArticulation)
                {
                    return E_OUTOFMEMORY;
                }
                m_pArticulation->Init(FALSE);
                m_pArticulation->AddRef(); // Will Release when done.
                hr = m_pArticulation->Load(pParser);
                break;
            }
            break;
        }
    }
    pParser->LeaveList();
    return hr;
}


HRESULT CInstrument::LoadRegions(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 
    CSourceArticulation *pArticulation = NULL;
    BOOL fIsDrum = FALSE;

    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		if ((ckNext.ckid == FOURCC_LIST) && 
            ((ckNext.fccType == FOURCC_RGN) || (ckNext.fccType == FOURCC_RGN2)))
        {
            CSourceRegion *pRegion = NULL;

            pRegion = new CSourceRegion;
            if (!pRegion)
            {
                return E_OUTOFMEMORY;
            }
            hr = pRegion->Load(pParser);
            // If it failed, it's still okay to insert in list, will be cleared later.
            m_RegionList.AddHead(pRegion);
        }
	}
    pParser->LeaveList();

	return hr;
}

HRESULT CInstrument::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 
    CSourceArticulation *pArticulation = NULL;
    BOOL fIsDrum = FALSE;

    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case FOURCC_INSH :
			INSTHEADER instHeader;
			hr = pParser->Read(&instHeader, sizeof(INSTHEADER));
			m_dwProgram = instHeader.Locale.ulInstrument;
			m_dwProgram |= (instHeader.Locale.ulBank) << 8;
			m_dwProgram |= (instHeader.Locale.ulBank & 0x80000000);
            break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
            case FOURCC_LRGN :
                hr = LoadRegions(pParser);
                break;
            case FOURCC_LART :
            case FOURCC_LAR2 :
                if (pArticulation)
                {
                    pArticulation->Release();
                }
                
                pArticulation = new CSourceArticulation;

                if (!pArticulation)
                {
                    return E_OUTOFMEMORY;
                }
                pArticulation->Init(FALSE);
                pArticulation->AddRef(); // Will Release when done.
                hr = pArticulation->Load(pParser);
                break;
            }
        }
    }

    pParser->LeaveList();
    if (pArticulation)
    {
        for (CSourceRegion *pr = m_RegionList.GetHead();
             pr != NULL;
             pr = pr->GetNext())
        {
            if (pr->m_pArticulation == NULL)
            {
				pr->m_pArticulation = pArticulation;
				pArticulation->AddRef();    
			}
        }
        pArticulation->Release();   // Release initial AddRef();
    }
    else
    {
        for (CSourceRegion *pr = m_RegionList.GetHead();
             pr != NULL;
             pr = pr->GetNext())
        {
            if (pr->m_pArticulation == NULL)
            {
                return DMUS_E_BADARTICULATION;
            }
        }
    }
	return hr;
}

void CCollection::ResolveConnections()

{
    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
		for (CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
			 pInstrument != NULL;
			 pInstrument = pInstrument->GetNext())
		{
			CSourceRegion *pRegion = pInstrument->m_RegionList.GetHead();
			for (;pRegion != NULL;pRegion = pRegion->GetNext())
			{
                CWave *pWave = m_WavePool[pRegion->m_Sample.m_wID % WAVE_HASH_SIZE].GetHead();
                for (;pWave;pWave = pWave->GetNext())
                {
				    if (pRegion->m_Sample.m_wID == pWave->m_dwID)
				    {
					    pRegion->m_Sample.m_pWave = pWave;
					    pWave->AddRef(); 
                        break;
				    }
                }
            }
        }
    }
}

#define FOURCC_WAVE mmioFOURCC('W','A','V','E')
#define FOURCC_wave mmioFOURCC('w','a','v','e')

HRESULT CCollection::LoadWaves(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 
    DWORD dwWaveID = 0;

    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		if ((ckNext.ckid == FOURCC_LIST) && 
            ((ckNext.fccType == FOURCC_WAVE) || (ckNext.fccType == FOURCC_wave)))
        {
            CWave *pWave = new CWave;
            if (!pWave)
            {
                return E_OUTOFMEMORY;
            }
            hr = pWave->Load(pParser);
            pWave->AddRef();
            pWave->m_dwID = dwWaveID++;
            // Failure will cause everything to be deleted, so insert in list in interest of efficiency.
            m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        }
    }
    pParser->LeaveList();
	return hr;
}

HRESULT CWave::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 
    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case mmioFOURCC('f','m','t',' ') :
            hr = pParser->Read(&m_WaveFormat, sizeof(XBOXADPCMWAVEFORMAT));
            if ((m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_PCM)
                && (m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_XBOX_ADPCM)) 
            {
                return E_FAIL;
            } 
            if (m_WaveFormat.wfx.wBitsPerSample == 8)
            {
                m_bSampleType = SFORMAT_8;
            }
            else if (m_WaveFormat.wfx.wBitsPerSample == 16)
            {
                m_bSampleType = SFORMAT_16;
            }
            m_dwSampleRate = m_WaveFormat.wfx.nSamplesPerSec;
            break;
        case FOURCC_WSMP :
            WSMPL WaveSample;
            WLOOP WaveLoop;
			hr = pParser->Read(&WaveSample, sizeof(WSMPL));
/*            m_vrAttenuation = (VRELS) (long) (((WaveSample.lAttenuation) * 10) >> 16);
            m_Sample.m_prFineTune = WaveSample.sFineTune;
            m_Sample.m_bMIDIRootKey = (BYTE) WaveSample.usUnityNote;*/
			if(WaveSample.cSampleLoops)
			{
				hr = pParser->Read(&WaveLoop, sizeof(WLOOP));
/*                m_Sample.m_dwLoopStart = WaveLoop.ulStart;
                m_Sample.m_dwLoopEnd = WaveLoop.ulStart + WaveLoop.ulLength;
                m_Sample.m_bOneShot = FALSE;
                m_Sample.m_dwLoopType = WaveLoop.ulType;*/
			}
            else
            {
//                m_Sample.m_bOneShot = TRUE;
            }
            break;
        case mmioFOURCC('d','a','t','a') :
            m_dwSampleDataSize = ckNext.cksize;
            m_pnWave = (short *) new char[m_dwSampleDataSize];
            if (!m_pnWave)
            {
                return E_OUTOFMEMORY;
            }
            hr = pParser->Read(m_pnWave, m_dwSampleDataSize);
            break;
        }
    }
    pParser->LeaveList();

	return hr;
}

HRESULT CCollection::LoadInstruments(CRiffParser *pParser)
{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 

    pParser->EnterList(&ckNext);

    while (pParser->NextChunk(&hr))
    {
		if ((ckNext.ckid == FOURCC_LIST) && 
            (ckNext.fccType == FOURCC_INS))
        {
            CInstrument *pInstrument = new CInstrument;
            if (!pInstrument)
            {
                return E_OUTOFMEMORY;
            }
            hr = pInstrument->Load(pParser);
            // Failure will cause everything to be deleted, so insert in list in interest of efficiency.
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
        }
    }
    pParser->LeaveList();
	return hr;
}

HRESULT CCollection::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CCollection::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CCollection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CCollection::GetDescriptor);
	V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicCollection);
}

STDMETHODIMP CCollection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CCollection::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CCollection::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CCollection::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.ParseDescriptor(pIStream,pDesc,FOURCC_DLS,CLSID_DirectMusicCollection);
}

STDMETHODIMP CCollection::GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument)

{
    return E_NOTIMPL;
}

STDMETHODIMP CCollection::EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName)

{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\idmsynth.h ===
// Copyright (c) 1998 Microsoft Corporation
// IDMSynth.h : Declaration of the CDMSynth

#ifndef __DMSYNTH_H_
#define __DMSYNTH_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDMSynth
class ATL_NO_VTABLE CDMSynth : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDMSynth, &CLSID_DMSynth>,
	public IDirectMusicSynth
{
public:
	CDMSynth()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DMSYNTH)

BEGIN_COM_MAP(CDMSynth)
	COM_INTERFACE_ENTRY(IDirectMusicSynth)
END_COM_MAP()

// IDirectMusicSynth
public:
	STDMETHOD(UnloadInstrument)(DWORD dwInstrumentID);
	STDMETHOD(QueryCompactTime)(DWORD* pdwTime);
	STDMETHOD(Compact)();
	STDMETHOD(DownloadInstrument)(DWORD dwInstrumentID, DWORD * pDMInstrument);
	STDMETHOD(UnloadWave)(DWORD dmWaveID);
	STDMETHOD(DownloadWave)(DWORD dmwaveid, DWORD * pdmwave);
};

#endif //__DMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dsoundsequencer.h ===
// Copyright Microsoft, Inc. All Rights Reserved.

#ifndef __DSOUNDSEQUENCER_INCLUDED__
#define __DSOUNDSEQUENCER_INCLUDED__

#include <dsound.h>

typedef LONGLONG SEQUENCE_NUMBER, *PSEQUENCE_NUMBER, *LPSEQUENCE_NUMBER;

typedef struct IDirectSoundSequencer IDirectSoundSequencer;
typedef IDirectSoundSequencer *LPDIRECTSOUNDSEQUENCER;

typedef struct IDirectSoundSequencerBuffer IDirectSoundSequencerBuffer;
typedef IDirectSoundSequencerBuffer *LPDIRECTSOUNDSEQUENCERBUFFER;

typedef struct IDirectSoundSequencerStream IDirectSoundSequencerStream;
typedef IDirectSoundSequencerStream *LPDIRECTSOUNDSEQUENCERSTREAM;

//
// Buffer status flags
//

#define DSSBSTATUS_PLAYING           0x00000001      // The buffer is playing
#define DSSBSTATUS_LOOPING           0x00000004      // The buffer is playing in a loop
#define DSSBSTATUS_PENDINGPLAYEVENTS 0x80000000      // There are play events waiting to be processed

//
// Stream status flags
//

#define DSSSSTATUS_PENDINGEVENTS     0x80000000      // There are events waiting to be processed

                                                                            
EXTERN_C HRESULT WINAPI DirectSoundCreateSequencer(LPGUID pguidDeviceId, DWORD maxEvents, LPDIRECTSOUNDSEQUENCER *ppSequencer);

#undef INTERFACE
#define INTERFACE IDirectSoundSequencer

DECLARE_INTERFACE(IDirectSoundSequencer)
{
public:
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(GetTime)(THIS_ LPREFERENCE_TIME prtCurrent) PURE;
    STDMETHOD(SetTime)(THIS_ REFERENCE_TIME rtCurrent) PURE;
    STDMETHOD(SetAbsoluteTime)(THIS_ REFERENCE_TIME rtSystemTime, REFERENCE_TIME rtCurrent) PURE;

    STDMETHOD(CreateBuffer)(THIS_ LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDSEQUENCERBUFFER* ppBuffer) PURE;
    STDMETHOD(CreateStream)(THIS_ LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSEQUENCERSTREAM* ppStream) PURE;
};

#define IDirectSoundSequencer_AddRef             IUnknown_AddRef
#define IDirectSoundSequencer_Release            IUnknown_Release

#if defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSoundSequencer_GetTime(p, a)                              p->GetTime(a)
#define IDirectSoundSequencer_SetTime(p, a)                              p->SetTime(a)
#define IDirectSoundSequencer_SetAbsoluteTime(p, a, b)                   p->SetAbsoluteTime(a, b)
#define IDirectSoundSequencer_CreateBuffer(p, a, b)                      p->CreateBuffer(a, b)
#define IDirectSoundSequencer_CreateStream(p, a, b)                      p->CreateStream(a, b)

#else

#define IDirectSoundSequencer_GetTime(p, a)                              p->lpVtbl->GetTime(a)
#define IDirectSoundSequencer_SetTime(p, a)                              p->lpVtbl->SetTime(a)
#define IDirectSoundSequencer_SetAbsoluteTime(p, a, b)                   p->lpVtbl->SetAbsoluteTime(a, b)
#define IDirectSoundSequencer_CreateBuffer(p, a, b)                      p->lpVtbl->CreateBuffer(a, b)
#define IDirectSoundSequencer_CreateStream(p, a, b)                      p->lpVtbl->CreateStream(a, b)

#endif

#undef INTERFACE
#define INTERFACE IDirectSoundSequencerBuffer

DECLARE_INTERFACE(IDirectSoundSequencerBuffer)
{
public:
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(Clear)(THIS); // Clear all pending events
    STDMETHOD(ClearAtOrAfter)(THIS_ REFERENCE_TIME prtClearTime);

    STDMETHOD(GetSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber) PURE; // Associated with next event to be queued
    STDMETHOD(GetStatus)        (THIS_ LPDWORD pdwStatus) PURE;

    // Errors are reported asynchronously. Only one error is recorded at a time for a given buffer.
    // Once an error is recorded, no further errors are recorded for that buffer until ClearError is called.

    STDMETHOD(GetError)(THIS_ HRESULT* pError) PURE; // returns S_OK if no error is recorded
    STDMETHOD(GetErrorSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber) PURE;
    STDMETHOD(GetErrorTime)(THIS_ LPREFERENCE_TIME prtErrorTime) PURE;
    STDMETHOD(ClearError)(THIS) PURE;

    // DirectSoundBuffer methods

    STDMETHOD(Play)                (THIS_ REFERENCE_TIME timeStamp, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags) PURE;
    STDMETHOD(Stop)                (THIS_ REFERENCE_TIME timeStamp) PURE;
    STDMETHOD(StopEx)              (THIS_ REFERENCE_TIME timeStamp, DWORD dwFlags) PURE;
    STDMETHOD(SetPlayRegion)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwPlayStart, DWORD dwPlayLength) PURE;
    STDMETHOD(SetLoopRegion)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwLoopStart, DWORD dwLoopLength) PURE;
    STDMETHOD(SetCurrentPosition)  (THIS_ REFERENCE_TIME timeStamp, DWORD dwPlayCursor) PURE;
    STDMETHOD(SetBufferData)       (THIS_ REFERENCE_TIME timeStamp, LPVOID pvBufferData, DWORD dwBufferBytes) PURE;
    STDMETHOD(SetFrequency)        (THIS_ REFERENCE_TIME timeStamp, DWORD dwFrequency) PURE;
    STDMETHOD(SetPitch)            (THIS_ REFERENCE_TIME timeStamp, LONG lPitch) PURE;
    STDMETHOD(SetVolume)           (THIS_ REFERENCE_TIME timeStamp, LONG lVolume) PURE;
    STDMETHOD(SetLFO)              (THIS_ REFERENCE_TIME timeStamp, LPCDSLFODESC pLFODesc) PURE;
    STDMETHOD(SetEG)               (THIS_ REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc) PURE;
    STDMETHOD(SetFilter)           (THIS_ REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc) PURE;
    STDMETHOD(SetOutputBuffer)     (THIS_ REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer) PURE;
    STDMETHOD(SetMixBins)          (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins) PURE;
    STDMETHOD(SetMixBinVolumes)    (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(SetAllParameters)    (THIS_ REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)  (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume)(THIS_ REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)             (THIS_ REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions)(THIS_ REFERENCE_TIME sampleTime, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies) PURE;
};

#define IDirectSoundSequencerBuffer_AddRef             IUnknown_AddRef
#define IDirectSoundSequencerBuffer_Release            IUnknown_Release

#if defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSoundSequencerBuffer_Clear(p)                             p->Clear()
#define IDirectSoundSequencerBuffer_ClearAtOrAfter(p, a)                 p->ClearAtOrAfter(a)
#define IDirectSoundSequencerBuffer_GetSequenceNumber(p, a)              p->GetSequenceNumber(a)
#define IDirectSoundSequencerBuffer_GetStatus(p, a)                      p->GetStatus(a)
#define IDirectSoundSequencerBuffer_GetError(p, a)                       p->GetError(a)
#define IDirectSoundSequencerBuffer_GetErrorSequenceNumber(p, a)         p->GetErrorSequenceNumber(a)
#define IDirectSoundSequencerBuffer_GetErrorSampleTime(p, a)             p->GetErrorSampleTime(a)
#define IDirectSoundSequencerBuffer_ClearError(p)                        p->ClearError()
#define IDirectSoundSequencerBuffer_Play(p, a, b, c, d)                  p->Play(a, b, c, d)
#define IDirectSoundSequencerBuffer_Stop(p, a)                           p->Stop(a)
#define IDirectSoundSequencerBuffer_StopEx(p, a, b)                      p->StopEx(a, b)
#define IDirectSoundSequencerBuffer_SetPlayRegion(p, a, b, c)            p->SetPlayRegion(a, b, c)
#define IDirectSoundSequencerBuffer_SetLoopRegion(p, a, b, c)            p->SetLoopRegion(a, b, c)
#define IDirectSoundSequencerBuffer_SetCurrentPosition(p, a, b)          p->SetCurrentPosition(a, b)
#define IDirectSoundSequencerBuffer_SetBufferData(p, a, b, c)            p->SetBufferData(a, b, c)
#define IDirectSoundSequencerBuffer_SetFrequency(p, a, b)                p->SetFrequency(a, b)
#define IDirectSoundSequencerBuffer_SetPitch(p, a, b)                    p->SetPitch(a, b)
#define IDirectSoundSequencerBuffer_SetVolume(p, a, b)                   p->SetVolume(a, b)
#define IDirectSoundSequencerBuffer_SetLFO(p, a, b)                      p->SetLFO(a, b)
#define IDirectSoundSequencerBuffer_SetEG(p, a, b)                       p->SetEG(a, b)
#define IDirectSoundSequencerBuffer_SetFilter(p, a, b)                   p->SetFilter(a, b)
#define IDirectSoundSequencerBuffer_SetOutputBuffer(p, a, b)             p->SetOutputBuffer(a, b)
#define IDirectSoundSequencerBuffer_SetMixBins(p, a, b)                  p->SetMixBins(a, b)
#define IDirectSoundSequencerBuffer_SetMixBinVolumes(p, a, b, c)         p->SetMixBinVolumes(a, b, c)
#define IDirectSoundSequencerBuffer_SetAllParameters(p, a, b, c)         p->SetAllParameters(a, b, c)
#define IDirectSoundSequencerBuffer_SetConeAngles(p, a, b, c, d)         p->SetConeAngles(a, b, c, d)
#define IDirectSoundSequencerBuffer_SetConeOrientation(p, a, b, c, d, e) p->SetConeOrientation(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetConeOutsideVolume(p, a, b, c)     p->SetConeOutsideVolume(a, b, c)
#define IDirectSoundSequencerBuffer_SetMaxDistance(p, a, b, c)           p->SetMaxDistance(a, b, c)
#define IDirectSoundSequencerBuffer_SetMinDistance(p, a, b, c)           p->SetMinDistance(a, b, c)
#define IDirectSoundSequencerBuffer_SetMode(p, a, b, c)                  p->SetMode(a, b, c)
#define IDirectSoundSequencerBuffer_SetPosition(p, a, b, c, d, e)        p->SetPosition(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetVelocity(p, a, b, c, d, e)        p->SetVelocity(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetNotificationPositions(p, a, b, c) p->SetNotificationPositions(a, b, c)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSoundSequencerBuffer_Clear(p)                             p->lpVtbl->Clear()
#define IDirectSoundSequencerBuffer_ClearAtOrAfter(p, a)                 p->lpVtbl->ClearAtOrAfter(a)
#define IDirectSoundSequencerBuffer_GetSequenceNumber(p, a)              p->lpVtbl->GetSequenceNumber(a)
#define IDirectSoundSequencerBuffer_GetStatus(p, a)                      p->lpVtbl->GetStatus(a)
#define IDirectSoundSequencerBuffer_GetError(p, a)                       p->lpVtbl->GetError(a)
#define IDirectSoundSequencerBuffer_GetErrorSequenceNumber(p, a)         p->lpVtbl->GetErrorSequenceNumber(a)
#define IDirectSoundSequencerBuffer_GetErrorSampleTime(p, a)             p->lpVtbl->GetErrorSampleTime(a)
#define IDirectSoundSequencerBuffer_ClearError(p)                        p->lpVtbl->ClearError()
#define IDirectSoundSequencerBuffer_Play(p, a, b, c, d)                  p->lpVtbl->Play(a, b, c, d)
#define IDirectSoundSequencerBuffer_Stop(p, a)                           p->lpVtbl->Stop(a)
#define IDirectSoundSequencerBuffer_StopEx(p, a, b)                      p->lpVtbl->StopEx(a, b)
#define IDirectSoundSequencerBuffer_SetPlayRegion(p, a, b, c)            p->lpVtbl->SetPlayRegion(a, b, c)
#define IDirectSoundSequencerBuffer_SetLoopRegion(p, a, b, c)            p->lpVtbl->SetLoopRegion(a, b, c)
#define IDirectSoundSequencerBuffer_SetCurrentPosition(p, a, b)          p->lpVtbl->SetCurrentPosition(a, b)
#define IDirectSoundSequencerBuffer_SetBufferData(p, a, b, c)            p->lpVtbl->SetBufferData(a, b, c)
#define IDirectSoundSequencerBuffer_SetFrequency(p, a, b)                p->lpVtbl->SetFrequency(a, b)
#define IDirectSoundSequencerBuffer_SetPitch(p, a, b)                    p->lpVtbl->SetPitch(a, b)
#define IDirectSoundSequencerBuffer_SetVolume(p, a, b)                   p->lpVtbl->SetVolume(a, b)
#define IDirectSoundSequencerBuffer_SetLFO1(p, a, b)                     p->lpVtbl->SetLFO(a, b)
#define IDirectSoundSequencerBuffer_SetEG(p, a, b)                       p->lpVtbl->SetEG(a, b)
#define IDirectSoundSequencerBuffer_SetFilter(p, a, b)                   p->lpVtbl->SetFilter(a, b)
#define IDirectSoundSequencerBuffer_SetOutputBuffer(p, a, b)             p->lpVtbl->SetOutputBuffer(a, b)
#define IDirectSoundSequencerBuffer_SetMixBins(p, a, b)                  p->lpVtbl->SetMixBins(a, b)
#define IDirectSoundSequencerBuffer_SetMixBinVolumes(p, a, b, c)         p->lpVtbl->SetMixBinVolumes(a, b, c)
#define IDirectSoundSequencerBuffer_SetAllParameters(p, a, b, c)         p->lpVtbl->SetAllParameters(a, b, c)
#define IDirectSoundSequencerBuffer_SetConeAngles(p, a, b, c, d)         p->lpVtbl->SetConeAngles(a, b, c, d)
#define IDirectSoundSequencerBuffer_SetConeOrientation(p, a, b, c, d, e) p->lpVtbl->SetConeOrientation(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetConeOutsideVolume(p, a, b, c)     p->lpVtbl->SetConeOutsideVolume(a, b, c)
#define IDirectSoundSequencerBuffer_SetMaxDistance(p, a, b, c)           p->lpVtbl->SetMaxDistance(a, b, c)
#define IDirectSoundSequencerBuffer_SetMinDistance(p, a, b, c)           p->lpVtbl->SetMinDistance(a, b, c)
#define IDirectSoundSequencerBuffer_SetMode(p, a, b, c)                  p->lpVtbl->SetMode(a, b, c)
#define IDirectSoundSequencerBuffer_SetPosition(p, a, b, c, d, e)        p->lpVtbl->SetPosition(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetVelocity(p, a, b, c, d, e         p->lpVtbl->SetVelocity(a, b, c, d, e)
#define IDirectSoundSequencerBuffer_SetNotificationPositions(p, a, b, c) p->lpVtbl->SetNotificationPositions(a, b, c)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#define XMEDIAPACKET_STATUS_NOT_YET_SUBMITTED 42 // The status of a queued, but not yet submitted, packet

#undef INTERFACE
#define INTERFACE IDirectSoundSequencerStream

DECLARE_INTERFACE(IDirectSoundSequencerStream)
{
public:
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(Clear)(THIS); // Clear all pending events
    STDMETHOD(ClearAtOrAfter)(THIS_ REFERENCE_TIME rtTimeStamp);

    STDMETHOD(GetSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber) PURE; // Associated with next event to be queued
    STDMETHOD(GetStatus)        (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(GetPacketStatus)  (THIS_ DWORD dwPacketIndex, LPDWORD pdwStatus) PURE;

    // Errors are reported asynchronously. Only one error is recorded at a time for a given buffer.
    // Once an error is recorded, no further errors are recorded for that buffer until ClearError is called.

    STDMETHOD(GetError)(THIS_ HRESULT* pError) PURE; // returns S_OK if no error is recorded
    STDMETHOD(GetErrorSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber) PURE;
    STDMETHOD(GetErrorTime)(THIS_ LPREFERENCE_TIME prtErrorTime) PURE;
    STDMETHOD(ClearError)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(Process)(THIS_ REFERENCE_TIME timeStamp, LPCXMEDIAPACKET pInputPacket, LPDWORD pdwPacketIndex) PURE;
    STDMETHOD(Discontinuity)(THIS_ REFERENCE_TIME timeStamp) PURE;
    STDMETHOD(Flush)(THIS_ REFERENCE_TIME timeStamp) PURE;

    // IDirectSoundStream methods

    STDMETHOD(SetFrequency)        (THIS_ REFERENCE_TIME timeStamp, DWORD dwFrequency) PURE;
    STDMETHOD(SetPitch)            (THIS_ REFERENCE_TIME timeStamp, LONG lPitch) PURE;
    STDMETHOD(SetVolume)           (THIS_ REFERENCE_TIME timeStamp, LONG lVolume) PURE;
    STDMETHOD(SetLFO)              (THIS_ REFERENCE_TIME timeStamp, LPCDSLFODESC pLFODesc) PURE;
    STDMETHOD(SetEG)               (THIS_ REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc) PURE;
    STDMETHOD(SetFilter)           (THIS_ REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc) PURE;
    STDMETHOD(SetOutputBuffer)     (THIS_ REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer) PURE;
    STDMETHOD(SetMixBins)          (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins) PURE;
    STDMETHOD(SetMixBinVolumes)    (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins) PURE;
    STDMETHOD(Pause)               (THIS_ REFERENCE_TIME timeStamp, DWORD dwPause) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(SetAllParameters)    (THIS_ REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)  (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume)(THIS_ REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)             (THIS_ REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) PURE;

};

#define IDirectSoundSequencerStream_AddRef             IUnknown_AddRef
#define IDirectSoundSequencerStream_Release            IUnknown_Release

#if defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSoundSequencerStream_Clear(p)                             p->Clear()
#define IDirectSoundSequencerStream_ClearAtOrAfter(p, a)                 p->ClearAtOrAfter(p, a)
#define IDirectSoundSequencerStream_GetSequenceNumber(p, a)              p->GetSequenceNumber(a)
#define IDirectSoundSequencerStream_GetStatus(p, a)                      p->GetStatus(a)
#define IDirectSoundSequencerStream_GetPacketStatus(p, a, b)             p->GetStatus(a, b)
#define IDirectSoundSequencerStream_GetError(p, a)                       p->GetError(a)
#define IDirectSoundSequencerStream_GetErrorSequenceNumber(p, a)         p->GetErrorSequenceNumber(a)
#define IDirectSoundSequencerStream_GetErrorSampleTime(p, a)             p->GetErrorSampleTime(a)
#define IDirectSoundSequencerStream_ClearError(p)                        p->ClearError()
#define IDirectSoundSequencerStream_Process(p, a, b, c)                  p->Process(a, b, c)
#define IDirectSoundSequencerStream_Discontinuity(p)                     p->Discontinuity()
#define IDirectSoundSequencerStream_Flush(p)                             p->Flush()
#define IDirectSoundSequencerStream_SetFrequency(p, a, b)                p->SetFrequency(a, b)
#define IDirectSoundSequencerStream_SetPitch(p, a, b)                    p->SetPitch(a, b)
#define IDirectSoundSequencerStream_SetVolume(p, a, b)                   p->SetVolume(a, b)
#define IDirectSoundSequencerStream_SetLFO(p, a, b)                      p->SetLFO(a, b)
#define IDirectSoundSequencerStream_SetEG(p, a, b)                       p->SetEG(a, b)
#define IDirectSoundSequencerStream_SetFilter(p, a, b)                   p->SetFilter(a, b)
#define IDirectSoundSequencerStream_SetOutputBuffer(p, a, b)             p->SetOutputBuffer(a, b)
#define IDirectSoundSequencerStream_SetMixBins(p, a, b)                  p->SetMixBins(a, b)
#define IDirectSoundSequencerStream_SetMixBinVolumes(p, a, b, c)         p->SetMixBinVolumes(a, b, c)
#define IDirectSoundSequencerStream_Pause(p, a)                          p->Pause(a)
#define IDirectSoundSequencerStream_SetAllParameters(p, a, b, c)         p->SetAllParameters(a, b, c)
#define IDirectSoundSequencerStream_SetConeAngles(p, a, b, c, d)         p->SetConeAngles(a, b, c, d)
#define IDirectSoundSequencerStream_SetConeOrientation(p, a, b, c, d, e) p->SetConeOrientation(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetConeOutsideVolume(p, a, b, c)     p->SetConeOutsideVolume(a, b, c)
#define IDirectSoundSequencerStream_SetMaxDistance(p, a, b, c)           p->SetMaxDistance(a, b, c)
#define IDirectSoundSequencerStream_SetMinDistance(p, a, b, c)           p->SetMinDistance(a, b, c)
#define IDirectSoundSequencerStream_SetMode(p, a, b, c)                  p->SetMode(a, b, c)
#define IDirectSoundSequencerStream_SetPosition(p, a, b, c, d, e)        p->SetPosition(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetVelocity(p, a, b, c, d, e)        p->SetVelocity(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetNotificationPositions(p, a, b, c) p->SetNotificationPositions(a, b, c)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSoundSequencerStream_Clear(p)                             p->lpVtbl->Clear()
#define IDirectSoundSequencerStream_ClearAtOrAfter(p)                    p->lpVtbl->ClearAtOrAfter(p, a)
#define IDirectSoundSequencerStream_GetSequenceNumber(p, a)              p->lpVtbl->GetSequenceNumber(a)
#define IDirectSoundSequencerStream_GetPacketStatus(p, a, b)             p->lpVtbl->GetStatus(a, b)
#define IDirectSoundSequencerStream_GetError(p, a)                       p->lpVtbl->GetError(a)
#define IDirectSoundSequencerStream_GetErrorSequenceNumber(p, a)         p->lpVtbl->GetErrorSequenceNumber(a)
#define IDirectSoundSequencerStream_GetErrorSampleTime(p, a)             p->lpVtbl->GetErrorSampleTime(a)
#define IDirectSoundSequencerStream_ClearError(p)                        p->lpVtbl->ClearError()
#define IDirectSoundSequencerStream_Process(p, a, b, c)                  p->lpVtbl->Process(a, b, c)
#define IDirectSoundSequencerStream_Discontinuity(p)                     p->lpVtbl->Discontinuity()
#define IDirectSoundSequencerStream_Flush(p)                             p->lpVtbl->Flush()
#define IDirectSoundSequencerStream_SetFrequency(p, a, b)                p->lpVtbl->SetFrequency(a, b)
#define IDirectSoundSequencerStream_SetPitch(p, a, b)                    p->lpVtbl->SetPitch(a, b)
#define IDirectSoundSequencerStream_SetVolume(p, a, b)                   p->lpVtbl->SetVolume(a, b)
#define IDirectSoundSequencerStream_SetLFO1(p, a, b)                     p->lpVtbl->SetLFO(a, b)
#define IDirectSoundSequencerStream_SetEG(p, a, b)                       p->lpVtbl->SetEG(a, b)
#define IDirectSoundSequencerStream_SetFilter(p, a, b)                   p->lpVtbl->SetFilter(a, b)
#define IDirectSoundSequencerStream_SetOutputBuffer(p, a, b)             p->lpVtbl->SetOutputBuffer(a, b)
#define IDirectSoundSequencerStream_SetMixBins(p, a, b)                  p->lpVtbl->SetMixBins(a, b)
#define IDirectSoundSequencerStream_SetMixBinVolumes(p, a, b, c)         p->lpVtbl->SetMixBinVolumes(a, b, c)
#define IDirectSoundSequencerStream_Pause(p, a)                          p->lpVtbl->Pause(a)
#define IDirectSoundSequencerStream_SetAllParameters(p, a, b, c)         p->lpVtbl->SetAllParameters(a, b, c)
#define IDirectSoundSequencerStream_SetConeAngles(p, a, b, c, d)         p->lpVtbl->SetConeAngles(a, b, c, d)
#define IDirectSoundSequencerStream_SetConeOrientation(p, a, b, c, d, e) p->lpVtbl->SetConeOrientation(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetConeOutsideVolume(p, a, b, c)     p->lpVtbl->SetConeOutsideVolume(a, b, c)
#define IDirectSoundSequencerStream_SetMaxDistance(p, a, b, c)           p->lpVtbl->SetMaxDistance(a, b, c)
#define IDirectSoundSequencerStream_SetMinDistance(p, a, b, c)           p->lpVtbl->SetMinDistance(a, b, c)
#define IDirectSoundSequencerStream_SetMode(p, a, b, c)                  p->lpVtbl->SetMode(a, b, c)
#define IDirectSoundSequencerStream_SetPosition(p, a, b, c, d, e)        p->lpVtbl->SetPosition(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetVelocity(p, a, b, c, d, e         p->lpVtbl->SetVelocity(a, b, c, d, e)
#define IDirectSoundSequencerStream_SetNotificationPositions(p, a, b, c) p->lpVtbl->SetNotificationPositions(a, b, c)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#endif // __DSOUNDSEQUENCER_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\kernhelp.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// KernHelp.cpp
//
// Wrappers for kernel functions to make synth core cross compilable
//

extern "C" {
#include <ntddk.h>
};

#include "KernHelp.h"

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeInitializeMutex((PKMUTEX)CritSect, 1);
}

VOID EnterCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeWaitForSingleObject((PKMUTEX)CritSect,
                          Executive,
                          KernelMode,
                          FALSE,
                          0);

}

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    KeReleaseMutex((PKMUTEX)CritSect, FALSE);
}

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION CritSect)
{
    // NOP in kernel
    //
}

// GetRegValueDword
//
// Must be called at passive level
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value)
{
    int                             ReturnValue = 0;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    KEY_VALUE_PARTIAL_INFORMATION   *Information;
    ULONG                           InformationSize;
    UNICODE_STRING                  UnicodeRegPath;
    UNICODE_STRING                  UnicodeValueName;

    RtlInitUnicodeString(&UnicodeRegPath, RegPath);
    RtlInitUnicodeString(&UnicodeValueName, ValueName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRegPath,
                               0,           // Flags
                               NULL,        // Root directory
                               NULL);       // Security descriptor

    Status = ZwOpenKey(&KeyHandle,
                       KEY_QUERY_VALUE,
                       &ObjectAttributes);
    if (Status != STATUS_SUCCESS)
    {
        return 0;
    }

    InformationSize = sizeof(Information) + sizeof(ULONG);
    Information = (KEY_VALUE_PARTIAL_INFORMATION*)ExAllocatePool(PagedPool, InformationSize);
    if (Information == NULL)
    {
        return 0;
    }

    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeValueName,
                             KeyValuePartialInformation,
                             Information,
                             sizeof(Information),
                             &InformationSize);
    if (Status == STATUS_SUCCESS)
    {
        if (Information->Type == REG_DWORD && Information->DataLength == sizeof(ULONG))
        {
            RtlCopyMemory(Value, Information->Data, sizeof(ULONG));
            ReturnValue = 1;
        }
    }                                
                                    
    ExFreePool(Information);
    ZwClose(KeyHandle);

    return ReturnValue;                                
}

ULONG GetTheCurrentTime()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    return (ULONG)(Time.QuadPart / (10 * 1000));
}

void DebugInit(void)
{
}

void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dmrand.cpp ===
/***
*dmrand.c - random number generator
* Based on rand.c from C run-time
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*/

// We don't care about multiple threads having independent sequences of random numbers.
// (Because dmusic's use of srand is always called with the current time, so we are never
// looking for a repeatable sequence of numbers.)
//
//
// Note the use of InterlockedExchange and InterlockedCompareExchange to avoid having to take a critical section

#include <xtl.h>

static long holdrand = 1L;

void __cdecl dm_srand (
	unsigned int seed
	)
{
	InterlockedExchange(&holdrand, (long)seed);
}

int __cdecl dm_rand (
	void
	)
{
    for(;;) {
        long oldValue = holdrand; // assume this read is atomic
        long newValue = oldValue * 214013L + 2531011L;
        if(oldValue == InterlockedCompareExchange(&holdrand, newValue, oldValue)){
            return ((newValue >> 16) & 0x7fff);
        }
        Sleep(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\kernhelp.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
//
#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection(
    LPCRITICAL_SECTION);

VOID EnterCriticalSection(
    LPCRITICAL_SECTION);

VOID LeaveCriticalSection(
    LPCRITICAL_SECTION);

VOID DeleteCriticalSection(
    LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(
    LPTSTR RegPath,
    LPTSTR ValueName,
    PULONG Value);

ULONG GetTheCurrentTime();


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline void* __cdecl operator new
(
    unsigned int    iSize
)
{
    PVOID result = ExAllocatePoolWithTag(NonPagedPool, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, 'suMD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    unsigned int    iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Debug trace facility
//
#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
#define Trace DebugTrace
#else
#define Trace
#endif

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\misc.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// Misc.h
//
// functions used in multiple DLL's

#ifndef __MISC_H__
#define __MISC_H__

//LPVOID MemGlobalAllocPtr(UINT uFlags,DWORD dwBytes);
//BOOL MemGlobalFreePtr(LPVOID p);

// memory functions
//HRESULT MemStart();
//void MemEnd();

/*#ifdef _DEBUGMEM
#ifndef new
void* operator new( size_t cb, LPCTSTR pszFileName, WORD wLine );
#define new new( __FILE__, (WORD)__LINE__ )
#endif
#endif*/

#ifdef DBG
#define RELEASE( obj ) ( (obj)->Release(), *((char**)&(obj)) = (char*)0x0bad0bad )
#else
#define RELEASE( obj ) (obj)->Release()
#endif

#ifndef XBOX

BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue);

#endif // ! XBOX

ULONG GetTheCurrentTime();

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dmsynth.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
// dmsynth.cpp
// @@END_DDKSPLIT
//
// Dll entry points and IDirectMusicSynthFactory implementation
//
#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "oledll.h"

#include "dmusicc.h"
#include "dmusics.h"
#include "umsynth.h"
#include "misc.h" 
#include <regstr.h>
#include "synth.h"

#include "..\shared\validate.h"
#include "..\shared\dmusiccp.h"

#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
#include "validate.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT


// Globals
//


// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#ifndef XBOX
extern CDSLinkList g_DSLinkList;
#endif
// @@END_DDKSPLIT


// Version information for our class
//
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
TCHAR g_szMSSynthFriendlyName[]    = TEXT("Microsoft Software Synthesizer");

TCHAR g_szSynthFriendlyName[]    = TEXT("DirectMusicSynth");
TCHAR g_szSynthVerIndProgID[]    = TEXT("Microsoft.DirectMusicSynth");
TCHAR g_szSynthProgID[]          = TEXT("Microsoft.DirectMusicSynth.1");

TCHAR g_szSinkFriendlyName[]    = TEXT("DirectMusicSynthSink");
TCHAR g_szSinkVerIndProgID[]    = TEXT("Microsoft.DirectMusicSynthSink");
TCHAR g_szSinkProgID[]          = TEXT("Microsoft.DirectMusicSynthSink.1");
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT

TCHAR g_szMSSynthFriendlyName[]    = TEXT("Microsoft DDK Software Synthesizer");

TCHAR g_szSynthFriendlyName[]    = TEXT("DDKSynth");
TCHAR g_szSynthVerIndProgID[]    = TEXT("Microsoft.DDKSynth");
TCHAR g_szSynthProgID[]          = TEXT("Microsoft.DDKSynth.1");

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

#ifndef XBOX

// Dll's hModule
//
HMODULE g_hModule = NULL; 

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

#else // XBOX

extern long g_cLock;

#endif // !XBOX

static char const g_szDoEmulation[] = "DoEmulation";

// CDirectMusicSynthFactory::QueryInterface
//
HRESULT __stdcall
CDirectMusicSynthFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicSynthFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectMusicSynthFactory::CDirectMusicSynthFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectMusicSynthFactory::~CDirectMusicSynthFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectMusicSynthFactory::AddRef
//
ULONG __stdcall
CDirectMusicSynthFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicSynthFactory::Release
//
ULONG __stdcall
CDirectMusicSynthFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectMusicSynthFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectMusicSynthFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
//    OSVERSIONINFO osvi;
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CUserModeSynth *pDM;
    
    try
    {
        pDM = new CUserModeSynth;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);
//    pDM->Release();
    
    return hr;
}

// CDirectMusicSynthFactory::LockServer
//
HRESULT __stdcall
CDirectMusicSynthFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

#ifndef XBOX

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
// CDirectMusicSynthSinkFactory::QueryInterface
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicSynthSinkFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectMusicSynthSinkFactory::CDirectMusicSynthSinkFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectMusicSynthSinkFactory::~CDirectMusicSynthSinkFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectMusicSynthSinkFactory::AddRef
//
ULONG __stdcall
CDirectMusicSynthSinkFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicSynthSinkFactory::Release
//
ULONG __stdcall
CDirectMusicSynthSinkFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectMusicSynthSinkFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
//    OSVERSIONINFO osvi;
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDSLink *pDSLink;

    try
    {
        pDSLink = new CDSLink;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDSLink == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDSLink->Init(NULL);
    if (!SUCCEEDED(hr)) {
        delete pDSLink;
        return hr;
    }

    hr = pDSLink->QueryInterface(iid, ppv);
//    pDM->Release();
    
    return hr;
}

// CDirectMusicSynthSinkFactory::LockServer
//
HRESULT __stdcall
CDirectMusicSynthSinkFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
// @@END_DDKSPLIT

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;


// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
        if(clsid == CLSID_DirectMusicSynth)
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
        if(clsid == CLSID_DDKSynth)
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
        {

                pIUnknown = static_cast<IUnknown*> (new CDirectMusicSynthFactory);
                if(!pIUnknown) 
                {
                        return E_OUTOFMEMORY;
                }
        }
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
        else if(clsid == CLSID_DirectMusicSynthSink)
        {

                pIUnknown = static_cast<IUnknown*> (new CDirectMusicSynthSinkFactory);
                if(!pIUnknown) 
                {
                        return E_OUTOFMEMORY;
                }
        }
// @@END_DDKSPLIT
        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

#endif

//////////////////////////////////////////////////////////////////////
// DirectMusicSynthCreate

STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth )
{
    CDirectMusicSynthFactory Factory;
    return Factory.CreateInstance(NULL, iid, (void**) ppDMSynth);
}

#ifndef XBOX

const TCHAR cszSynthRegRoot[] = TEXT(REGSTR_PATH_SOFTWARESYNTHS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

HRESULT RegisterSynth(REFGUID guid,
                      const TCHAR szDescription[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszSynthRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

#endif // ! XBOX

#ifndef XBOX

STDAPI DllUnregisterServer()
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    UnregisterServer(CLSID_DirectMusicSynth,
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    UnregisterServer(CLSID_DDKSynth,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
                     g_szSynthFriendlyName,
                     g_szSynthVerIndProgID,
                     g_szSynthProgID);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    UnregisterServer(CLSID_DirectMusicSynthSink,
					 g_szSinkFriendlyName,
					 g_szSinkVerIndProgID,
					 g_szSinkProgID);
// @@END_DDKSPLIT

    return S_OK;
}


STDAPI DllRegisterServer()
{

    RegisterServer(g_hModule,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
                   CLSID_DirectMusicSynth,
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
                   CLSID_DDKSynth,
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
                   g_szSynthFriendlyName,
                   g_szSynthVerIndProgID,
                   g_szSynthProgID);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSynthSink,
                   g_szSinkFriendlyName,
                   g_szSinkVerIndProgID,
                   g_szSinkProgID);
// @@END_DDKSPLIT

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    RegisterSynth(CLSID_DirectMusicSynth, g_szMSSynthFriendlyName);
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    RegisterSynth(CLSID_DDKSynth, g_szMSSynthFriendlyName);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT


    return S_OK;
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)

{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
		{
            DisableThreadLibraryCalls(hModule);
            g_hModule = hModule;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
            if (!g_DSLinkList.OpenUp())
            {
                return FALSE;
            }
// @@END_DDKSPLIT
#ifdef DBG
			DebugInit();
#endif
#ifdef DBG
//>>>>>>>>> remove these when done 
/*
			_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
			int iFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
			_CrtSetDbgFlag( iFlag | _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_ALWAYS_DF );
*/
#endif 
            if (!CControlLogic::InitCriticalSection())
            {
                TraceI(0, "Failed to initialize global critical section -- failing init\n");
                return FALSE;
            }            
		}
    }
	else if (dwReason == DLL_PROCESS_DETACH) 
	{
		if (--nReferenceCount == 0)
		{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
			g_DSLinkList.CloseDown();
            
            TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
// @@END_DDKSPLIT
		}

#ifdef DBG
//>>>>>>>>> remove these when done 
/*
		if ( !_CrtCheckMemory() )
		    ::MessageBox(NULL,"Synth Heap Corupted","ERROR",MB_OK);

        if ( _CrtDumpMemoryLeaks() )
		    ::MessageBox(NULL,"Memory Leaks Detected","ERROR",MB_OK);
*/
#endif 
        CControlLogic::KillCriticalSection();
	}
    return TRUE;
}

#else

// We're a library, so we initialize ourselves using the C++ language feature that
// initializes statically allocated classes.

class DMSynthInit {
public:
	DMSynthInit()
    {
        CControlLogic::InitCriticalSection();
	}
};

DMSynthInit gDMSynthInit;

#endif // !XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mixc.cpp ===
//      Mixc.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      C version of the Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

#pragma warning(disable : 4101 4102 4146)  

DWORD CDigitalAudio::Mix16(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
		lA *= vfLVolume;
		lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI++;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::Mix16InterLeaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

		dwI += 2;
	}

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\dsoundsequencer.cpp ===
// Copyright Microsoft, Inc. All Rights Reserved.

#ifdef XMIX
#ifndef DPF_LIBRARY
#error DPF_LIBRARY Undefined. Are you compiling with Visual Studio? See dmusic\sources.ini for the correct definition.
#endif
#ifndef POOL_TAG
#error POOL_TAG Undefined. Are you compiling with Visual Studio? See dmusic\sources.ini for the correct definition.
#endif

#if defined(DBG) || defined(PROFILE)
#define IMPLEMENT_PERFORMANCE_COUNTERS
#endif

#define PoolAlloc PoolAlloc_DMusic
#define DSOUND_NO_OVERRIDE_NEW_DELETE

#include "xalloc.h" // DMusic memory allocator

/*
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define NODSOUND
#include <xtl.h>
#include <dsoundp.h>
#include "..\..\dsound\dsound\debug.h"
*/

#include "dsoundi.h"
#include "..\dmime\cmixbins.h"

// DMusic assumes DBG is only defined if debugging is happening.
// But dsoundi.h includes ntos.h which includes ntosdef.h, which defines
// DBG to be 0 when there's no debugging.
// So if DBG is equal to zero, we undefine it for the rest of the file

#ifdef DBG
#if DBG == 0
#undef DBG
#endif
#endif

// Double-check to make sure DBG is undefined during release builds.

#if defined(DBG) && defined(NDEBUG)
#error DBG and NDEBUG symbols are both defined.
#endif

#include "dsoundsequencer.h"

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
#include "dm.h"
#include <xbdm.h>

extern "C" void DMusicRegisterPerformanceCounter(const char* szName, unsigned long dwType, void* pvArg){
    DmTell_RegisterPerformanceCounter(szName, dwType, pvArg);
}

extern "C" void DMusicUnregisterPerformanceCounter(const char* szName){
    DmTell_UnregisterPerformanceCounter(szName);
}

#endif

#ifdef DBG
extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);
#define DEBUGF(A) DbgPrint A
#else
#define DEBUGF(A) (void) 0
#endif

// Start of compile-time options

#ifdef DBG

#define DO_VERIFY_PRIORITYQUEUE
//#define DO_FULL_VERIFY_PRIORITYQUEUE // Warning - the verification takes too long when there are a lot of events released at once in a DPC
//#define PRINT_PRIORITYQUEUE
//#define PRINT_QUEUE_OPS
//#define PRINT_EACH_CALL
//#define TRACK_PLAYING
//#define PRINT_SQUELCHED_PLAYS
//#define PRINT_CALLS_AFTER_EVENT_NUMBER 0x8d50
//#define WARN_IF_IN_PAST
//#define ALWAYS_QUEUE
#define TRACK_BUFFER_STATE
//#define PRINT_EACH_ENQUEUE

#endif // DBG

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
#define GATHER_STATISTICS
#endif

// Options that can be enabled even when not debugging

// #define IGNORE_REDUNDANT_SETMIXBINS // Not needed any more - DSound takes care of this

// End of compile-time options

#define SAFE_RELEASE(p) do { if(p) { (p)->Release(); (p)=NULL; } } while(0)

#ifdef GATHER_STATISTICS
#define NOTES_PER_STAT 400
#endif

#ifdef PRINT_CALLS_AFTER_EVENT_NUMBER
#define EACH_CALL_DEBUGF(A) do { if( m_dwTotalEvents > PRINT_CALLS_AFTER_EVENT_NUMBER) { DEBUGF(A); } } while(0)
#elif defined(PRINT_EACH_CALL)
#define EACH_CALL_DEBUGF(A) DEBUGF(A)
#else
#define EACH_CALL_DEBUGF(A) (void) 0
#endif

#if defined(PRINT_EACH_ENQUEUE)
#define EACH_ENQUEUE_DEBUGF(A) DEBUGF(A)
#else
#define EACH_ENQUEUE_DEBUGF(A) (void) 0
#endif

#ifdef PRINT_QUEUE_OPS
#define DEBUGF_QUEUE_OPS(A) DEBUGF(A)
#else
#define DEBUGF_QUEUE_OPS(A) (void) 0
#endif

#ifdef DO_VERIFY_PRIORITYQUEUE
#define SAFE_VPQ(QUEUE) do { RAISE_DPC_IRQL; QUEUE.Verify(); } while(0)
#else
#define SAFE_VPQ(QUEUE) ((void) 0)
#endif

class CDirectSoundSequencer;
struct Event;
typedef Event* LPEVENT;

class EnterDPCIRQL {
public:
    EnterDPCIRQL(){
        m_oldIRQL = KeRaiseIrqlToDpcLevel();
    }
    ~EnterDPCIRQL(){
        KeLowerIrql(m_oldIRQL);
    }
private:
    KIRQL m_oldIRQL;
};


#define RAISE_DPC_IRQL EnterDPCIRQL __enterDPCIRQL

#ifdef DBG
#define ASSERT_IN_DPC ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL)
#define ASSERT_IN_PASSIVE ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL)
#else
#define ASSERT_IN_DPC ((void) 0)
#define ASSERT_IN_PASSIVE ((void) 0)
#endif

class PriorityQueue {

public:
    PriorityQueue();
    ~PriorityQueue();
    HRESULT Initialize(DWORD maxSize);
    inline bool Initialized() { return m_pEvents != 0; }
    Event* Pop();
    Event* PopIfLessThanOrEqual(const REFERENCE_TIME* pTime);
    bool GetNextEventTime(REFERENCE_TIME* pTime);
    void Remove(Event* pEvent);
    HRESULT Push(Event* pEvent);
    void AdjustEventTimes(REFERENCE_TIME delta);
#ifdef DBG
    void Verify();
    void Print();
    void Print2(bool bPrintEvents);
#endif
    inline DWORD Size() { return m_size; }
private:
    Event* Pop2();
    Event* At(DWORD index); // One based index into priority queue
    void AtPut(DWORD index, Event* event);
    void Swap(DWORD index1, DWORD index2);
    void Move(DWORD dest, DWORD source);
    Event** m_pEvents;
    DWORD m_capacity;
    DWORD m_size;
    __int64 m_pseudoTime;
};

typedef enum EventType {
    eBufferPlay,
    eBufferStop,
    eBufferStopEx,
    eBufferSetPlayRegion,
    eBufferSetLoopRegion,
    eBufferSetCurrentPosition,
    eBufferSetBufferData,
    eBufferSetFrequency,
    eBufferSetPitch,
    eBufferSetVolume,
    eBufferSetLFO,
    eBufferSetEG,
    eBufferSetFilter,
    eBufferSetOutputBuffer,
    eBufferSetMixBins,
    eBufferSetMixBinVolumes,
    eBufferSetAllParameters,
    eBufferSetConeAngles,
    eBufferSetConeOrientation,
    eBufferSetConeOutsideVolume,
    eBufferSetMaxDistance,
    eBufferSetMinDistance,
    eBufferSetMode,
    eBufferSetPosition,
    eBufferSetVelocity,
    eBufferSetNotificationPositions,

    eStreamProcess,
    eStreamDiscontinuity,
    eStreamFlush,
    eStreamSetFrequency,
    eStreamSetPitch,
    eStreamSetVolume,
    eStreamSetLFO,
    eStreamSetEG,
    eStreamSetFilter,
    eStreamSetOutputBuffer,
    eStreamSetMixBins,
    eStreamSetMixBinVolumes,
    eStreamPause,
    eStreamSetAllParameters,
    eStreamSetConeAngles,
    eStreamSetConeOrientation,
    eStreamSetConeOutsideVolume,
    eStreamSetMaxDistance,
    eStreamSetMinDistance,
    eStreamSetMode,
    eStreamSetPosition,
    eStreamSetVelocity,

};

struct Buffer_Play {
    DWORD dwFlags;
};

struct Buffer_Stop {
};

struct Buffer_StopEx {
    DWORD dwFlags;
};

struct Buffer_SetPlayRegion {
    DWORD dwPlayStart;
    DWORD dwPlayLength;
};

struct Buffer_SetLoopRegion {
    DWORD dwLoopStart;
    DWORD dwLoopLength;
};

struct Buffer_SetCurrentPosition {
    DWORD dwPlayCursor;
};

struct Buffer_SetBufferData {
    LPVOID pvBufferData;
    DWORD dwBufferBytes;
};

struct Buffer_SetFrequency {
    DWORD dwFrequency;
};

struct Buffer_SetPitch {
    LONG lPitch;
};

struct Buffer_SetVolume {
    LONG lVolume;
};

struct Buffer_SetLFO {
    DSLFODESC lFODesc;
};

struct Buffer_SetEG {
    DSENVELOPEDESC envelopeDesc;
};

struct Buffer_SetFilter {
    DSFILTERDESC filterDesc;
};

struct Buffer_SetOutputBuffer {
    LPDIRECTSOUNDBUFFER pOutputBuffer;
};

struct Buffer_SetMixBins {
    DSMIXBINS DSMixBins;
    DSMIXBINVOLUMEPAIR VolumePairs[DSMIXBIN_ASSIGNMENT_MAX];

};

struct Buffer_SetMixBinVolumes {
    DSMIXBINS DSMixBins;
    DSMIXBINVOLUMEPAIR VolumePairs[DSMIXBIN_ASSIGNMENT_MAX];
};

struct Buffer_SetAllParameters {
    unsigned char ds3db[sizeof(DS3DBUFFER)]; // avoid constructor problems
    DWORD dwApply;
};

struct Buffer_SetConeAngles {
    DWORD dwInsideConeAngle;
    DWORD dwOutsideConeAngle;
    DWORD dwApply;
};

struct Buffer_SetConeOrientation {
    FLOAT x;
    FLOAT y;
    FLOAT z;
    DWORD dwApply;
};

struct Buffer_SetConeOutsideVolume {
    LONG lConeOutsideVolume;
    DWORD dwApply;
};

struct Buffer_SetMaxDistance {
    FLOAT flMaxDistance;
    DWORD dwApply;
};

struct Buffer_SetMinDistance {
    FLOAT flMinDistance;
    DWORD dwApply;
};

struct Buffer_SetMode {
    DWORD dwMode;
    DWORD dwApply;
};

struct Buffer_SetPosition {
    FLOAT x;
    FLOAT y;
    FLOAT z;
    DWORD dwApply;
};

struct Buffer_SetVelocity {
    FLOAT x;
    FLOAT y;
    FLOAT z;
    DWORD dwApply;
};

struct Buffer_SetNotificationPositions {
    DWORD dwNotifyCount;
    DSBPOSITIONNOTIFY aNotifies[4];
};

struct Stream_Process {
    XMEDIAPACKET inputPacket;
};

struct Stream_Discontinuity {
};

struct Stream_Flush {
};

struct Stream_Pause {
    DWORD dwPause;
};

union EventUnion {
    Buffer_Play bufferPlay;
    Buffer_Stop bufferStop;
    Buffer_StopEx bufferStopEx;
    Buffer_SetPlayRegion bufferSetPlayRegion;
    Buffer_SetLoopRegion bufferSetLoopRegion;
    Buffer_SetCurrentPosition bufferSetCurrentPosition;
    Buffer_SetBufferData bufferSetBufferData;
    Buffer_SetFrequency bufferSetFrequency;
    Buffer_SetPitch bufferSetPitch;
    Buffer_SetVolume bufferSetVolume;
    Buffer_SetLFO bufferSetLFO;        
    Buffer_SetEG bufferSetEG;  
    Buffer_SetFilter bufferSetFilter;
    Buffer_SetOutputBuffer bufferSetOutputBuffer;
    Buffer_SetMixBins bufferSetMixBins;
    Buffer_SetMixBinVolumes bufferSetMixBinVolumes;
    Buffer_SetAllParameters bufferSetAllParameters;
    Buffer_SetConeAngles bufferSetConeAngles;
    Buffer_SetConeOrientation bufferSetConeOrientation;
    Buffer_SetConeOutsideVolume bufferSetConeOutsideVolume;
    Buffer_SetMaxDistance bufferSetMaxDistance;
    Buffer_SetMinDistance bufferSetMinDistance;
    Buffer_SetMode bufferSetMode;
    Buffer_SetPosition bufferSetPosition;
    Buffer_SetVelocity bufferSetVelocity;
    Buffer_SetNotificationPositions bufferSetNotificationPositions;

    Stream_Process streamProcess;
    Stream_Discontinuity streamDiscontinuity;
    Stream_Flush streamFlush;
    Stream_Pause streamPause;
};

struct EventArgs {
    REFERENCE_TIME timeStamp; // When this event should fire
    EventType eventType;
    EventUnion body;
};        

struct ErrorInfo {
    HRESULT error;
    SEQUENCE_NUMBER errorSequenceNumber;
    REFERENCE_TIME errorTime;
};

class Buffer;
class Stream;

union EventTarget {
    Buffer* m_pBuffer;
    Stream* m_pStream;
};

struct Event {
    Event* pPrevSameOwner;   // Previous event same owner
    Event* pNextSameOwner;   // Next event same owner
    DWORD m_priorityQueueIndex; // Makes PriorityQueue::Remove fast
    SEQUENCE_NUMBER sequenceNumber;
    __int64 m_pseudoTime;
    EventTarget m_target;
    EventArgs eventArgs;

    bool IsLessThanOrEqual(const REFERENCE_TIME* time) const;
    bool IsLessThan(const Event* other) const;
    bool IsGreaterThan(const Event* other) const;
    int Compare(const Event* other) const;

    bool IsBufferEvent() const;

    void ReleaseMembers();

};

class Buffer : public IDirectSoundSequencerBuffer {
public:
    Buffer();
    ~Buffer();

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    STDMETHOD(Initialize)(CDirectSoundSequencer* pSequencer, LPCDSBUFFERDESC pdsbd);
    STDMETHOD(Clear)();
    STDMETHOD(ClearAtOrAfter)(THIS_ REFERENCE_TIME timeStamp);
    STDMETHOD(GetSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber); // Associated with next event to be queued
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus);

    STDMETHOD(GetError)(THIS_ HRESULT* pError); // returns S_OK if no error is recorded
    STDMETHOD(GetErrorSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber);
    STDMETHOD(GetErrorTime)(LPREFERENCE_TIME prtErrorTime);
    STDMETHOD(ClearError)();

    // DirectSoundBuffer methods

    STDMETHOD(Play)                (THIS_ REFERENCE_TIME timeStamp, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);
    STDMETHOD(Stop)                (THIS_ REFERENCE_TIME timeStamp);
    STDMETHOD(StopEx)              (THIS_ REFERENCE_TIME timeStamp, DWORD dwFlags);
    STDMETHOD(SetPlayRegion)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwPlayStart, DWORD dwPlayLength);
    STDMETHOD(SetLoopRegion)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwLoopStart, DWORD dwLoopLength);
    STDMETHOD(SetCurrentPosition)  (THIS_ REFERENCE_TIME timeStamp, DWORD dwPlayCursor);
    STDMETHOD(SetBufferData)       (THIS_ REFERENCE_TIME timeStamp, LPVOID pvBufferData, DWORD dwBufferBytes);
    STDMETHOD(SetFrequency)        (THIS_ REFERENCE_TIME timeStamp, DWORD dwFrequency);
    STDMETHOD(SetPitch)            (THIS_ REFERENCE_TIME timeStamp, LONG dwPitch);
    STDMETHOD(SetVolume)           (THIS_ REFERENCE_TIME timeStamp, LONG lVolume);
    STDMETHOD(SetLFO)              (THIS_ REFERENCE_TIME timeStamp, LPCDSLFODESC pLFODesc);
    STDMETHOD(SetEG)               (THIS_ REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc);
    STDMETHOD(SetFilter)           (THIS_ REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc);
    STDMETHOD(SetOutputBuffer)     (THIS_ REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer);
    STDMETHOD(SetMixBins)          (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins);
    STDMETHOD(SetMixBinVolumes)    (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins);

    // IDirectSound3DBuffer methods
    STDMETHOD(SetAllParameters)    (THIS_ REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply);
    STDMETHOD(SetConeAngles)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
    STDMETHOD(SetConeOrientation)  (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    STDMETHOD(SetConeOutsideVolume)(THIS_ REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply);
    STDMETHOD(SetMaxDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply);
    STDMETHOD(SetMinDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply);
    STDMETHOD(SetMode)             (THIS_ REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply);
    STDMETHOD(SetPosition)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    STDMETHOD(SetVelocity)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions)(THIS_ REFERENCE_TIME sampleTime, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies);

    // Dispatcher callback

    STDMETHOD(DispatchEvent)(EventArgs* pEventArgs);

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    static void RegisterPerformanceCounters();
    static void UnregisterPerformanceCounters();
#endif
public:
    // Public member variables -- no other member variables before this because memory layout has to match class Stream

    CDirectSoundSequencer* m_pSequencer;
    DWORD m_dwid;
    Event* m_pHead;
    ErrorInfo m_errorInfo;
    SEQUENCE_NUMBER m_sequenceNumber;

#ifdef TRACK_PLAYING
    bool m_bStopped;
    bool m_bPlaying;
#endif

    LPDIRECTSOUNDBUFFER m_pObject;

private:

    STDMETHOD(Enqueue)(EventArgs* pEventArgs);

    ULONG m_cRef;

#ifdef TRACK_BUFFER_STATE
public:
    void TrackBufferState(const EventArgs* pEventArgs);

private:
    bool m_tbs_bBufferDataValid;
#define NUM_RECORDED_EVENTS 5
    int m_nextEventToRecord;
    EventArgs m_recentEvents[NUM_RECORDED_EVENTS];
#endif

#ifdef IGNORE_REDUNDANT_SETMIXBINS
    CMIXBINS m_MixBins;
#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    static DWORD m_gAllocatedCount;
#endif
};

#define MAX_QUEUED_PACKETS 2

class Stream : public IDirectSoundSequencerStream {
public:
    Stream();
    ~Stream();

    STDMETHODIMP_(ULONG) AddRef() {
        return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
        long l = InterlockedDecrement((long*)&m_cRef);
        if (l == 0)
           delete this;
        return l;
    }

    STDMETHOD(Initialize)(CDirectSoundSequencer* pSequencer, LPCDSSTREAMDESC pdssd);
    STDMETHOD(Clear)();
    STDMETHOD(ClearAtOrAfter)(THIS_ REFERENCE_TIME timeStamp);
    STDMETHOD(GetSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber); // Associated with next event to be queued
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus);
    STDMETHOD(GetPacketStatus)(THIS_ DWORD dwPacketStatus, LPDWORD pdwStatus);

    STDMETHOD(GetError)(THIS_ HRESULT* pError); // returns S_OK if no error is recorded
    STDMETHOD(GetErrorSequenceNumber)(THIS_ LPSEQUENCE_NUMBER pSequenceNumber);
    STDMETHOD(GetErrorTime)(LPREFERENCE_TIME prtErrorTime);
    STDMETHOD(ClearError)();

    // XMediaObject methods
    STDMETHOD(Process)(THIS_ REFERENCE_TIME timeStamp, LPCXMEDIAPACKET pInputPacket, LPDWORD pdwPacketIndex);
    STDMETHOD(Discontinuity)(THIS_ REFERENCE_TIME timeStamp);
    STDMETHOD(Flush)(THIS_ REFERENCE_TIME timeStamp);

    // IDirectSoundStream methods

    STDMETHOD(SetFrequency)        (THIS_ REFERENCE_TIME timeStamp, DWORD dwFrequency);
    STDMETHOD(SetPitch)            (THIS_ REFERENCE_TIME timeStamp, LONG dwPitch);
    STDMETHOD(SetVolume)           (THIS_ REFERENCE_TIME timeStamp, LONG lVolume);
    STDMETHOD(SetLFO)              (THIS_ REFERENCE_TIME timeStamp, LPCDSLFODESC pLFODesc);
    STDMETHOD(SetEG)               (THIS_ REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc);
    STDMETHOD(SetFilter)           (THIS_ REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc);
    STDMETHOD(SetOutputBuffer)     (THIS_ REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer);
    STDMETHOD(SetMixBins)          (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins);
    STDMETHOD(SetMixBinVolumes)    (THIS_ REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins);    
    STDMETHOD(Pause)               (THIS_ REFERENCE_TIME timeStamp, DWORD dwPause);

    // IDirectSound3DBuffer methods
    STDMETHOD(SetAllParameters)    (THIS_ REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply);
    STDMETHOD(SetConeAngles)       (THIS_ REFERENCE_TIME timeStamp, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
    STDMETHOD(SetConeOrientation)  (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    STDMETHOD(SetConeOutsideVolume)(THIS_ REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply);
    STDMETHOD(SetMaxDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply);
    STDMETHOD(SetMinDistance)      (THIS_ REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply);
    STDMETHOD(SetMode)             (THIS_ REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply);
    STDMETHOD(SetPosition)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    STDMETHOD(SetVelocity)         (THIS_ REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);

    // Dispatcher callback

    STDMETHOD(DispatchEvent)(EventArgs* pEventArgs);

    // Public methods

    CDirectSoundSequencer* m_pSequencer;
    DWORD m_dwid;
    Event* m_pHead;
    ErrorInfo m_errorInfo;
    SEQUENCE_NUMBER m_sequenceNumber;
#ifdef TRACK_PLAYING
    bool m_bStopped;
    bool m_bPlaying;
#endif

    LPDIRECTSOUNDSTREAM m_pObject;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    static void RegisterPerformanceCounters();
    static void UnregisterPerformanceCounters();
#endif
private:

    STDMETHOD(Enqueue)(EventArgs* pEventArgs);

    ULONG m_cRef;

    DWORD m_dwNextPacketIndex;
    DWORD m_dwPacketStatus[MAX_QUEUED_PACKETS];

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    static DWORD m_gAllocatedCount;
#endif
};

class EventPool {
public:
    EventPool();
    ~EventPool();
    HRESULT Initialize(DWORD numEvents);

    Event*  Allocate(); // Can be called at DPC level
    void    Free(Event* pEvent); // Can be called at DPC level
    void    RecycleEvents(); // Must be called at Passive level.
private:
    Event*  PopRelease();
    void    PushFree(Event*);

    Event*          m_pEvents;
    Event*          m_pFree;
    Event*          m_pToBeReleased; // Events which are done, but for which we haven't
                                     // called Release yet....
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DWORD   m_pFreeEvents;
    DWORD   m_pAllocatedEvents;
    DWORD   m_pReturnedEvents;
    DWORD   m_pMinFreeEvents;
    DWORD   m_pMaxAllocatedEvents;
    DWORD   m_pMaxReturnedEvents;
#endif
};

EventPool::EventPool(){
    m_pEvents = 0;
    m_pFree = 0;
    m_pToBeReleased = 0;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_pFreeEvents = 0;
    m_pAllocatedEvents = 0;
    m_pReturnedEvents = 0;
    m_pMinFreeEvents = 0;
    m_pMaxAllocatedEvents = 0;
    m_pMaxReturnedEvents = 0;

    DMusicRegisterPerformanceCounter( "DMMS event pool allocated events current",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pAllocatedEvents );
    DMusicRegisterPerformanceCounter( "DMMS event pool allocated events max",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pMaxAllocatedEvents );
    DMusicRegisterPerformanceCounter( "DMMS event pool free events current",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pFreeEvents );
    DMusicRegisterPerformanceCounter( "DMMS event pool free events min",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pMinFreeEvents );
    DMusicRegisterPerformanceCounter( "DMMS event pool returned events current",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pReturnedEvents );
    DMusicRegisterPerformanceCounter( "DMMS event pool returned events max",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_pMaxReturnedEvents );

#endif
}

EventPool::~EventPool(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter( "DMMS event pool allocated events current");
    DMusicUnregisterPerformanceCounter( "DMMS event pool allocated events max");
    DMusicUnregisterPerformanceCounter( "DMMS event pool free events current");
    DMusicUnregisterPerformanceCounter( "DMMS event pool free events min");
    DMusicUnregisterPerformanceCounter( "DMMS event pool returned events current");
    DMusicUnregisterPerformanceCounter( "DMMS event pool returned events max");
#endif

    RecycleEvents();
    delete[] m_pEvents;
}

HRESULT EventPool::Initialize(DWORD numEvents){
    HRESULT hr = S_OK;
    if(SUCCEEDED(hr))
    {
        m_pEvents = new Event[numEvents];
        if(!m_pEvents){
            hr = E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr))
    {
        // Set up the free list
        m_pFree = m_pEvents;
        memset(m_pEvents, 0, sizeof(Event)*numEvents);
        for(DWORD i = 1; i < numEvents; i++){
           m_pEvents[i-1].pNextSameOwner = &m_pEvents[i];
        }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        m_pFreeEvents = numEvents;
        m_pMinFreeEvents = m_pFreeEvents;
#endif
    }
    return hr;
}

Event* EventPool::Allocate(){
    Event* pEvent = NULL;

    RAISE_DPC_IRQL;

    if(m_pFree){
        pEvent = m_pFree;
        m_pFree = pEvent->pNextSameOwner;
        pEvent->pNextSameOwner = 0;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

        if(pEvent) {
            m_pFreeEvents--;
            if(m_pMinFreeEvents > m_pFreeEvents){
                m_pMinFreeEvents = m_pFreeEvents;
            }
            m_pAllocatedEvents++;
            if(m_pMaxAllocatedEvents < m_pAllocatedEvents){
                m_pMaxAllocatedEvents = m_pAllocatedEvents;
            }
        }

#endif

    }

    return pEvent;
}

void EventPool::Free(Event* pEvent){
    ASSERT(pEvent);
    ASSERT(pEvent->m_priorityQueueIndex == 0); // Not in the priority queue

    RAISE_DPC_IRQL;

    Event* pPrevSameOwner = pEvent->pPrevSameOwner;
    Event* pNextSameOwner = pEvent->pNextSameOwner;
    if(pPrevSameOwner){
        ASSERT(pPrevSameOwner->pNextSameOwner == pEvent);
        pPrevSameOwner->pNextSameOwner = pNextSameOwner;
    }
    else {
        // Removing first event owned by an owner, so update the head
        // Assume Buffer and Stream have the same member offsets. They really ought to inherit from
        // a common "Owner" base class
        Buffer* pOwner = pEvent->m_target.m_pBuffer;
        ASSERT(pOwner->m_pHead == pEvent);
        pOwner->m_pHead = pNextSameOwner;
    }
    if(pNextSameOwner){
        ASSERT(pNextSameOwner->pPrevSameOwner == pEvent);
        pNextSameOwner->pPrevSameOwner = pPrevSameOwner;
    }

    pEvent->pPrevSameOwner = 0;
    pEvent->pNextSameOwner = m_pToBeReleased;
    m_pToBeReleased = pEvent;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    if(pEvent) {
        m_pAllocatedEvents--;
        m_pReturnedEvents++;
        if(m_pMaxReturnedEvents < m_pReturnedEvents){
            m_pMaxReturnedEvents = m_pReturnedEvents;
        }
    }
#endif
}

void EventPool::RecycleEvents(){ // Must not be called at DPC level
    // This function can end up deleting objects, so it should
    // never be called at DPC time...

    ASSERT_IN_PASSIVE;

    Event* pEvent;
    while(pEvent = PopRelease()){

        ASSERT(pEvent->m_priorityQueueIndex == 0);

        pEvent->ReleaseMembers();
        PushFree(pEvent);
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        m_pFreeEvents++;
        m_pReturnedEvents--;
#endif

    }
}

Event* EventPool::PopRelease(){
    RAISE_DPC_IRQL;

    Event* pEvent = m_pToBeReleased;
    if(pEvent){
        ASSERT(pEvent->m_priorityQueueIndex == 0);
        m_pToBeReleased = pEvent->pNextSameOwner;
    }

    return pEvent;
}

void EventPool::PushFree(Event* pEvent){
    ASSERT(pEvent);
    ASSERT(pEvent->m_priorityQueueIndex == 0);

    RAISE_DPC_IRQL;

    pEvent->pNextSameOwner = m_pFree;
    m_pFree = pEvent;
}

class CDirectSoundSequencer : public IDirectSoundSequencer
{
public:
    CDirectSoundSequencer();
    ~CDirectSoundSequencer();

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    STDMETHOD(Initialize)(LPGUID pguidDeviceId, DWORD maxEvents);
    STDMETHOD(GetTime)(LPREFERENCE_TIME prtCurrent);
    STDMETHOD(SetTime)(REFERENCE_TIME rtCurrent);
    STDMETHOD(SetAbsoluteTime)(REFERENCE_TIME rtSystemTime, REFERENCE_TIME rtCurrent);

    STDMETHOD(CreateBuffer)(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDSEQUENCERBUFFER *ppBuffer);
    STDMETHOD(CreateStream)(THIS_ LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSEQUENCERSTREAM* ppStream);

    STDMETHOD(Enqueue)(void* pOwner, const EventArgs* pEventArgs);

    LPDIRECTSOUND GetDirectSound() { return m_pDirectSound; }

    
private:
    STDMETHOD(SetTimeOffset)(REFERENCE_TIME rtNewOffset);
    // This method is called at DPC time to dispatch any currently waiting events

    STDMETHOD(Dispatch)();
    STDMETHOD(DispatchEventsUntil)(const REFERENCE_TIME* pTime, const REFERENCE_TIME* pNow);
    STDMETHOD(DispatchEvent)(Event* pEvent);

    STDMETHOD(SetTimer)(bool bDelayOneMS);

    static VOID DPCTimerCallBack(
        PKDPC Dpc,
        PVOID DeferredContext,
        PVOID SystemArgument1,
        PVOID SystemArgument2
        );

    ULONG m_cRef;
    bool            m_bAllowQueueing;
    KTIMER          m_timer;
    KDPC            m_dpc;

    bool            m_bTimerSet;
    REFERENCE_TIME  m_nextEventTime;
    REFERENCE_TIME  m_rtOffset;

    LPDIRECTSOUND   m_pDirectSound;

    PriorityQueue   m_queue;
    EventPool       m_eventPool;


#ifdef GATHER_STATISTICS
    __int64         m_minLatency;
    __int64         m_maxLatency;
    __int64         m_totalLatency;
    __int64         m_averageLatency;
    __int64         m_dispatchCount;
    DWORD           m_currentQueued;
    DWORD           m_maxQueued;
    DWORD           m_notesPlayed;
    __int64         m_bFutureInitialized;
    __int64         m_minFutureQueue;
    __int64         m_maxFutureQueue;
    __int64         m_dwImmediateEvents;
    __int64         m_dwTotalEvents;
    
#endif

    void FreeAllEvents();
    void FreeEvent(Event* pEvent);
    void ReleaseEvents();
    HRESULT GetEvent(Event** ppEvent);

public:
    void FreeEvents(Buffer* pBuffer);
    void FreeEventsAtOrAfter(Buffer* pBuffer, REFERENCE_TIME timeStamp);
};

CDirectSoundSequencer::CDirectSoundSequencer()
{
    m_cRef = 1;
    m_bTimerSet = false;
    KeInitializeTimer(&m_timer);
    KeInitializeDpc(&m_dpc, DPCTimerCallBack, this);
#ifdef GATHER_STATISTICS
    m_minLatency = 0;
    m_maxLatency = 0;
    m_totalLatency = 0;
    m_averageLatency = 0;
    m_dispatchCount = 0;
    m_currentQueued = 0;
    m_maxQueued = 0;
    m_notesPlayed = 0;
    m_bFutureInitialized = false;
    m_minFutureQueue = 0;
    m_maxFutureQueue = 0;
    m_dwImmediateEvents = 0;
    m_dwTotalEvents = 0;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicRegisterPerformanceCounter( "DMMS events immediate",
                                  DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_dwImmediateEvents );
    DMusicRegisterPerformanceCounter( "DMMS events queued",
                                  DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_dispatchCount );
    DMusicRegisterPerformanceCounter( "DMMS events total",
                                  DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_dwTotalEvents );
    DMusicRegisterPerformanceCounter( "DMMS notes played",
                                  DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_notesPlayed );
    DMusicRegisterPerformanceCounter( "DMMS events queued currently",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_currentQueued );
    DMusicRegisterPerformanceCounter( "DMMS events queued max",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_maxQueued );
    DMusicRegisterPerformanceCounter( "DMMS relative enqueue time earliest (100ns)",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_minFutureQueue );
    DMusicRegisterPerformanceCounter( "DMMS relative enqueue time latest (100ns)",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC64,
                                  &m_maxFutureQueue );
    DMusicRegisterPerformanceCounter( "DMMS dispatch latency minimum (100ns)",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_minLatency );
    DMusicRegisterPerformanceCounter( "DMMS dispatch latency average (100ns)",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_averageLatency );
    DMusicRegisterPerformanceCounter( "DMMS dispatch latency maximum (100ns)",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_maxLatency );

    Buffer::RegisterPerformanceCounters();
    Stream::RegisterPerformanceCounters();

#endif

#endif
    m_rtOffset = 0;
    m_bAllowQueueing = false;
}

CDirectSoundSequencer::~CDirectSoundSequencer()
{
#ifdef GATHER_STATISTICS
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter( "DMMS events immediate");
    DMusicUnregisterPerformanceCounter( "DMMS events queued");
    DMusicUnregisterPerformanceCounter( "DMMS events total");
    DMusicUnregisterPerformanceCounter( "DMMS notes played");
    DMusicUnregisterPerformanceCounter( "DMMS events queued currently");
    DMusicUnregisterPerformanceCounter( "DMMS events queued max");
    DMusicUnregisterPerformanceCounter( "DMMS relative enqueue time earliest (100ns)");
    DMusicUnregisterPerformanceCounter( "DMMS relative enqueue time latest (100ns)");
    DMusicUnregisterPerformanceCounter( "DMMS dispatch latency minimum (100ns)");
    DMusicUnregisterPerformanceCounter( "DMMS dispatch latency average (100ns)");
    DMusicUnregisterPerformanceCounter( "DMMS dispatch latency maximum (100ns)");

    Buffer::UnregisterPerformanceCounters();
    Stream::UnregisterPerformanceCounters();

#endif
#endif

    {
        RAISE_DPC_IRQL;
        m_bAllowQueueing = false;
    }

    if(m_bTimerSet){
        KeCancelTimer(&m_timer);
    }
    FreeAllEvents(); // From queue
    ReleaseEvents();
}

HRESULT CDirectSoundSequencer::Initialize(LPGUID pguidDeviceId, DWORD maxEvents){

    HRESULT hr = S_OK;

    {
        if(m_bAllowQueueing){
            // Already initialized
            return E_FAIL;
        }

        m_bAllowQueueing = true;

        if(SUCCEEDED(hr)){
            if(m_bTimerSet){
                KeCancelTimer(&m_timer);
                m_bTimerSet = false;
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_eventPool.Initialize(maxEvents);
        }
        if(SUCCEEDED(hr))
        {
            hr = m_queue.Initialize(maxEvents);
        }
    }

    if(SUCCEEDED(hr)){
        hr = DirectSoundCreate(pguidDeviceId, &m_pDirectSound, 0);
    }
    return hr;
}

HRESULT CDirectSoundSequencer::GetTime(LPREFERENCE_TIME prtCurrent)
{
    HRESULT hr = S_OK;
    if(SUCCEEDED(hr))
    {
        REFERENCE_TIME rtSystem;
        KeQuerySystemTime((PLARGE_INTEGER) &rtSystem);
        *prtCurrent = rtSystem - m_rtOffset;
    }
    return hr;
}

HRESULT CDirectSoundSequencer::SetTime(REFERENCE_TIME rtCurrent)
{
    HRESULT hr = S_OK;
    if(SUCCEEDED(hr))
    {
        REFERENCE_TIME rtSystem;
        KeQuerySystemTime((PLARGE_INTEGER) &rtSystem);
        hr = SetTimeOffset(rtSystem - rtCurrent);
    }
    // EACH_ENQUEUE_DEBUGF(("SetAbsoluteTime m_rtOffset = %I64d\n", m_rtOffset));
    return hr;
}

HRESULT CDirectSoundSequencer::SetAbsoluteTime(REFERENCE_TIME rtSystemTime, REFERENCE_TIME rtCurrent)
{
    HRESULT hr = S_OK;
    if(SUCCEEDED(hr))
    {
        hr = SetTimeOffset(rtSystemTime - rtCurrent);
    }
    // DEBUGF(("SetAbsoluteTime m_rtOffset = %I64d\n", m_rtOffset));
    return hr;
}

HRESULT CDirectSoundSequencer::SetTimeOffset(REFERENCE_TIME rtNewOffset)
{
    HRESULT hr = S_OK;
    REFERENCE_TIME rtDelta = rtNewOffset - m_rtOffset;
    if(rtDelta){
        // Need to adjust the absolute time stamps on any currently queued events.
        {
            RAISE_DPC_IRQL;
            m_queue.AdjustEventTimes(rtDelta);
            hr = Dispatch(); // Because some events may now be due, and anyway, the timer needs to be reset
        }
        m_rtOffset = rtNewOffset;
    }
    return hr;
}

HRESULT CDirectSoundSequencer::CreateBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDSEQUENCERBUFFER *ppBuffer)
{
    HRESULT hr = S_OK;
    Buffer* pBuffer;
    if(SUCCEEDED(hr))
    {
        pBuffer = new Buffer();
        if(!pBuffer){
            hr = E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(this, pdsbd);
        if(FAILED(hr)){
            delete pBuffer;
            pBuffer = 0;
        }
    }
    if(SUCCEEDED(hr)){
        *ppBuffer = pBuffer;
    }
    return hr;
}

HRESULT CDirectSoundSequencer::CreateStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSEQUENCERSTREAM* ppStream)
{
    HRESULT hr = S_OK;
    Stream* pStream;
    if(SUCCEEDED(hr))
    {
        pStream = new Stream();
        if(!pStream){
            hr = E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr))
    {
        hr = pStream->Initialize(this, pdssd);
        if(FAILED(hr)){
            delete pStream;
            pStream = 0;
        }
    }
    if(SUCCEEDED(hr)){
        *ppStream = pStream;
    }
    return hr;
}

HRESULT CDirectSoundSequencer::GetEvent(Event** ppEvent)
{
    ASSERT(ppEvent);
    *ppEvent = m_eventPool.Allocate();
    return (*ppEvent != NULL) ? S_OK : E_OUTOFMEMORY;
}

void CDirectSoundSequencer::FreeAllEvents()
{
    RAISE_DPC_IRQL;
    if(m_queue.Initialized()){
        Event* pEvent;
        while(pEvent = m_queue.Pop()){
            FreeEvent(pEvent);
        }
    }
}

void CDirectSoundSequencer::FreeEvent(Event* pEvent)
{
    ASSERT(pEvent);

    SAFE_VPQ(m_queue);

    m_eventPool.Free(pEvent);

    SAFE_VPQ(m_queue);
}

void CDirectSoundSequencer::ReleaseEvents() {
    ASSERT_IN_PASSIVE;

    SAFE_VPQ(m_queue);

    m_eventPool.RecycleEvents();

    SAFE_VPQ(m_queue);
}

void CDirectSoundSequencer::FreeEvents(Buffer* pBuffer)
{
    RAISE_DPC_IRQL;

    ASSERT(pBuffer);
    Event* pNext;
    for(Event* pEvent = pBuffer->m_pHead; pEvent; pEvent = pNext){
        pNext = pEvent->pNextSameOwner;
        m_queue.Remove(pEvent);
        FreeEvent(pEvent);
    }
    pBuffer->m_pHead = 0;
}

void CDirectSoundSequencer::FreeEventsAtOrAfter(Buffer* pBuffer, REFERENCE_TIME timeStamp)
{
    RAISE_DPC_IRQL;

    ASSERT(pBuffer);
    Event* pNext;
    // Add timing offset. 
    timeStamp += m_rtOffset;
    for(Event* pEvent = pBuffer->m_pHead; pEvent; pEvent = pNext){
        pNext = pEvent->pNextSameOwner;
        if(pEvent->eventArgs.timeStamp >= timeStamp){
            m_queue.Remove(pEvent);
            FreeEvent(pEvent);
        }
    }
}

HRESULT CDirectSoundSequencer::Enqueue(void* pvOwner, const EventArgs* pEventArgs)
{
    HRESULT hr = S_OK;

    ReleaseEvents();

    REFERENCE_TIME now;
    REFERENCE_TIME eventTime = pEventArgs->timeStamp;

    bool bExecuteNow = false;
    bool bProcessQueueUpToEvent = false;


#ifdef ALWAYS_QUEUE

    KeQuerySystemTime((PLARGE_INTEGER) &now);


    if(eventTime <= 0){
        // relative to "now"
        eventTime += now;
    }
    else {
        // convert user time to system time
        eventTime += m_rtOffset;
    }
#ifdef WARN_IF_IN_PAST
            __int64 inPast = now - eventTime;
            if (inPast > 100 * 10000){
                DEBUGF(("DirectSoundSequencer: Trying to queue an event %dms in the past.\n",
                    (long) inPast / 10000));
                _asm int 3;
            }
#endif

#else // ! ALWAYS_QUEUE

    if(eventTime == 0){
        bExecuteNow = true; // Avoid getting time if you want the call done "now".
    }
    else {

        KeQuerySystemTime((PLARGE_INTEGER) &now);

        if(eventTime <= 0){
            // relative to "now"
            eventTime += now;
        }
        else {
            // convert user time to system time
            eventTime += m_rtOffset;
        }

        if(now >= eventTime){
            bExecuteNow = true;
            bProcessQueueUpToEvent = true;
#ifdef WARN_IF_IN_PAST
            __int64 inPast = now - eventTime;
            if (inPast > 100 * 10000){
                DEBUGF(("DirectSoundSequencer: Trying to queue an event %dms in the past.\n",
                    (long) inPast / 10000));
                _asm int 3;
            }
#endif
        }
    }

#endif // ! ALWAYS_QUEUE

#ifdef GATHER_STATISTICS
    InterlockedIncrement((PLONG) &m_dwTotalEvents);
#endif

    // If the event is scheduled for now or earlier, execute it right away.
    if(bExecuteNow){
#ifdef GATHER_STATISTICS
        InterlockedIncrement((PLONG) &m_dwImmediateEvents);
#endif
        if(bProcessQueueUpToEvent){
            RAISE_DPC_IRQL;
            DispatchEventsUntil(&eventTime, &now);
        }

        Event dummy;
        Buffer* pOwner = (Buffer*) pvOwner;
        dummy.m_target.m_pBuffer = pOwner;
        dummy.eventArgs = *pEventArgs;
        dummy.sequenceNumber = InterlockedIncrement((PLONG) &pOwner->m_sequenceNumber); // Sequence number is recorded if there is an error. 

        hr = DispatchEvent(&dummy);

        dummy.m_target.m_pBuffer = 0;

        dummy.ReleaseMembers(); // We want to do this even if DispatchEvent failed.
    }
    else {
        RAISE_DPC_IRQL;

        if(!m_bAllowQueueing){
            return E_FAIL;
        }

        Event* pEvent = 0;
        if(SUCCEEDED(hr)){
            hr = GetEvent(&pEvent);
        }

        if(SUCCEEDED(hr)){
            // Assume Buffer and Stream have the same member offsets. They really ought to inherit from
            // a common "Owner" base class
            Buffer* pOwner = (Buffer*) pvOwner;
            pEvent->m_target.m_pBuffer = pOwner;
            pEvent->pPrevSameOwner = NULL;
            pEvent->pNextSameOwner = pOwner->m_pHead;
            if(pOwner->m_pHead){
                pOwner->m_pHead->pPrevSameOwner = pEvent;
            }
            pOwner->m_pHead = pEvent;
            pEvent->m_priorityQueueIndex = 0; // Filled in when inserted into queue
            pEvent->sequenceNumber = InterlockedIncrement((PLONG) &pOwner->m_sequenceNumber);
            pEvent->eventArgs = *pEventArgs;

            pEvent->eventArgs.timeStamp = eventTime;

            if(pEvent->IsBufferEvent()){
                pEvent->m_target.m_pBuffer->AddRef();
            }
            else {
                pEvent->m_target.m_pStream->AddRef();
            }

#ifdef GATHER_STATISTICS
            {
                __int64 future = pEvent->eventArgs.timeStamp - now;
                if(!m_bFutureInitialized){
                    m_bFutureInitialized = true;
                    m_minFutureQueue = future;
                    m_maxFutureQueue = future;
                }
                else {
                    if(future < m_minFutureQueue){ 
                        m_minFutureQueue = future;
                    }
                    if(future > m_maxFutureQueue){ 
                        m_maxFutureQueue = future;
                    }
                }
            }
#endif

            hr = m_queue.Push(pEvent);

#ifdef GATHER_STATISTICS
            m_currentQueued = m_queue.Size();
            if(m_queue.Size() > m_maxQueued){
                m_maxQueued = m_queue.Size();
            }
#endif

        }
        if(SUCCEEDED(hr)){
            hr = SetTimer(false);
        }
    }

    return hr;
}

HRESULT CDirectSoundSequencer::Dispatch(){
    // Execute everything that's less than or equal to now.
    HRESULT hr = S_OK;
    
    REFERENCE_TIME now;
    KeQuerySystemTime((PLARGE_INTEGER) &now);
    EACH_CALL_DEBUGF(("Dispatch %d\n", *(long*) &now));

    m_bTimerSet = false;

    if(SUCCEEDED(hr)){
        hr = DispatchEventsUntil(&now, &now);
    }
    return hr;
}

HRESULT CDirectSoundSequencer::DispatchEventsUntil(const REFERENCE_TIME* pTime, const REFERENCE_TIME* pNow){
    HRESULT hr = S_OK;

    bool bFirstEvent = true;
    if(SUCCEEDED(hr)){
        Event* pEvent;
        while(pEvent = m_queue.PopIfLessThanOrEqual(pNow)){
#ifdef GATHER_STATISTICS
            m_dispatchCount++;
            REFERENCE_TIME actualTime;
            if(bFirstEvent){
                bFirstEvent = false;
                actualTime = *pNow;
            }
            else {
                KeQuerySystemTime((PLARGE_INTEGER) &actualTime);
            }
            __int64 latency = *(__int64*) &actualTime - *(__int64*) & pEvent->eventArgs.timeStamp;
            if(latency > 0){
                m_totalLatency += latency;
                m_averageLatency = m_totalLatency / m_dispatchCount;
            }

            if(latency < m_minLatency || (m_minLatency == 0 && m_maxLatency == 0)){
                m_minLatency = latency;
            }
            if(latency > m_maxLatency){
                m_maxLatency = latency;
            }
#endif
            hr = DispatchEvent(pEvent);
            FreeEvent(pEvent);
        }
#ifdef GATHER_STATISTICS
        m_currentQueued = m_queue.Size();
#endif
    }
    if(SUCCEEDED(hr)){
        hr = SetTimer(false);
    }
    return hr;
}

#if 0

void CDirectSoundSequencer::PrintStats(){
    if(true){
        DWORD minLat = (DWORD) (m_minLatency / 10);
        DWORD maxLat = (DWORD) (m_maxLatency / 10);
        DWORD avgLat = 0;
        if(m_dispatchCount) {
            avgLat = (DWORD) ((m_totalLatency / 10) / m_dispatchCount);
        }
        DEBUGF(("\ndss: notes: %d events total: %d immediate: %d queued: %d\n",
            m_notesPlayed,
            m_dwTotalEvents,
            m_dwImmediateEvents, m_dwTotalEvents - m_dwImmediateEvents));
        DEBUGF(("     latency avg: %dus min: %dus max: %dus. queue size: current %d max %d queue time: min %dms max %dms\n",
            avgLat, minLat, maxLat,
            m_queue.Size(),
            m_maxQueued,
            (int) (m_minFutureQueue / 10000),
            (int) (m_maxFutureQueue / 10000)
            ));
        m_queue.Print2(false);
        m_bPrintStatsNow = false;
    }
}

#endif

#ifdef DBG
const char* gEventTypeToText[] = {
    "eBufferPlay",
    "eBufferStop",
    "eBufferStopEx",
    "eBufferSetPlayRegion",
    "eBufferSetLoopRegion",
    "eBufferSetCurrentPosition",
    "eBufferSetBufferData",
    "eBufferSetFrequency",
    "eBufferSetPitch",
    "eBufferSetVolume",
    "eBufferSetLFO",
    "eBufferSetEG",
    "eBufferSetFilter",
    "eBufferSetOutputBuffer",
    "eBufferSetMixBins",
    "eBufferSetMixBinVolumes",
    "eBufferSetAllParameters",
    "eBufferSetConeAngles",
    "eBufferSetConeOrientation",
    "eBufferSetConeOutsideVolume",
    "eBufferSetMaxDistance",
    "eBufferSetMinDistance",
    "eBufferSetMode",
    "eBufferSetPosition",
    "eBufferSetVelocity",
    "eBufferSetNotificationPositions",

    "eStreamProcess",
    "eStreamDiscontinuity",
    "eStreamFlush",
    "eStreamSetFrequency",
    "eStreamSetPitch",
    "eStreamSetVolume",
    "eStreamSetLFO",
    "eStreamSetEG",
    "eStreamSetFilter",
    "eStreamSetOutputBuffer",
    "eStreamSetMixBins",
    "eStreamSetMixBinVolumes",
    "eStreamPause",
    "eStreamSetAllParameters",
    "eStreamSetConeAngles",
    "eStreamSetConeOrientation",
    "eStreamSetConeOutsideVolume",
    "eStreamSetMaxDistance",
    "eStreamSetMinDistance",
    "eStreamSetMode",
    "eStreamSetPosition",
    "eStreamSetVelocity"
};
#endif

HRESULT CDirectSoundSequencer::DispatchEvent(Event* pEvent){
    HRESULT hr = S_OK;
    if(pEvent->IsBufferEvent()){
        hr = pEvent->m_target.m_pBuffer->DispatchEvent(&pEvent->eventArgs);
    }
    else {
        hr = pEvent->m_target.m_pStream->DispatchEvent(&pEvent->eventArgs);
    }
    if(FAILED(hr)){
#ifdef DBG
        EventType et = pEvent->eventArgs.eventType;
        const char* pEventType = "Unknown";
        if(et >= eBufferPlay && et <= eStreamSetVelocity){
            pEventType = gEventTypeToText[et];
        }
        DEBUGF(("CDirectSoundSequencer::DispatchEvent: error 0x%08x while executing %s target=0x%x, eventType=%s, sequenceNumber=%d\n",
            hr,
            pEvent->IsBufferEvent() ? "Buffer" : "Stream",
            pEvent->m_target.m_pBuffer,
            pEventType,
            pEvent->sequenceNumber));
#endif
        if(SUCCEEDED(pEvent->m_target.m_pBuffer->m_errorInfo.error)){
            // record error (offsets are the same for both buffers and streams)
            pEvent->m_target.m_pBuffer->m_errorInfo.error = hr;
            pEvent->m_target.m_pBuffer->m_errorInfo.errorSequenceNumber = pEvent->sequenceNumber;
            pEvent->m_target.m_pBuffer->m_errorInfo.errorTime = pEvent->eventArgs.timeStamp;
        }
    }
    return hr;
}

HRESULT CDirectSoundSequencer::SetTimer(bool bDelayOneMS){    
    if(bDelayOneMS){
        REFERENCE_TIME now;
        KeQuerySystemTime((PLARGE_INTEGER) &now);
        m_nextEventTime = now + 10000;
        m_bTimerSet = true;
        KeSetTimer(&m_timer, * (LARGE_INTEGER*) &m_nextEventTime, &m_dpc); 
    }
    else {
        REFERENCE_TIME nextEventTime;
        if(m_queue.GetNextEventTime(&nextEventTime)){
            if(!m_bTimerSet || nextEventTime < m_nextEventTime){
                m_nextEventTime = nextEventTime;
                m_bTimerSet = true;
                EACH_CALL_DEBUGF(("SetTimer(%d)\n", *(long*) & nextEventTime));
                KeSetTimer(&m_timer, * (LARGE_INTEGER*) &nextEventTime, &m_dpc); 
            }
        }
    }
    return S_OK;
}

VOID CDirectSoundSequencer::DPCTimerCallBack(
        PKDPC Dpc,
        PVOID DeferredContext,
        PVOID SystemArgument1,
        PVOID SystemArgument2
        )
{
    ((CDirectSoundSequencer*) DeferredContext)->Dispatch();
}

// ------------ Event methods ------------------

bool Event::IsLessThanOrEqual(const REFERENCE_TIME* time) const{
    return eventArgs.timeStamp <= *time;
}

bool Event::IsLessThan(const Event* other) const{
    return Compare(other) == -1;
}

bool Event::IsGreaterThan(const Event* other) const{
    return Compare(other) == 1;
}

int Event::Compare(const Event* other) const{
    // Check time
    if(this->eventArgs.timeStamp < other->eventArgs.timeStamp){
        return -1;
    }
    if(this->eventArgs.timeStamp > other->eventArgs.timeStamp){
        return 1;
    }
    // check owner m_dwid
    if(this->m_pseudoTime < other->m_pseudoTime){
        return -1;
    }
    if(this->m_pseudoTime > other->m_pseudoTime){
        return 1;
    }
    return 0;
}

bool Event::IsBufferEvent() const {
    return eventArgs.eventType < eStreamProcess;
}

void Event::ReleaseMembers()
{
    // This function can end up deleting objects, so it should
    // never be called at DPC time...

    ASSERT_IN_PASSIVE;

    if(IsBufferEvent()){
        SAFE_RELEASE(m_target.m_pBuffer);
    }
    else {
        SAFE_RELEASE(m_target.m_pStream);
    }

    // A few events have reference counted pointers. Need to dereference them here
    // if they're still referenced. (Can happen if Clear() is called with queued events.

    switch(eventArgs.eventType){
    case eBufferSetOutputBuffer:
        SAFE_RELEASE(eventArgs.body.bufferSetOutputBuffer.pOutputBuffer);
        break;
    case eStreamSetOutputBuffer:
        SAFE_RELEASE(eventArgs.body.bufferSetOutputBuffer.pOutputBuffer);
        break;
    default:
        break;
    }

    #ifdef DBG
        memset(this,0xef, sizeof(Event));
        m_priorityQueueIndex = 0;
    #endif
}

/*
 * A priority queue implementation. This queue has the following
 * properties:
 *
 * Inserting is O(log(n))
 * Removing is O(log(n))
 * Poping is O(log(n))
 *
 * Overhead of 8 bytes per element. 4 for the Element pointer, 4 for
 * the queue index inside the element. The queue index is used to
 * enable Remove to operate in O(log(n)) instead of O(n).
 *
 */

#ifdef DO_VERIFY_PRIORITYQUEUE
#define VERIFY_PRIORITYQUEUE Verify()
#else
#define VERIFY_PRIORITYQUEUE (void) 0
#endif

PriorityQueue::PriorityQueue(){
    m_pEvents = 0;
    m_capacity = 0;
    m_size = 0;
    m_pseudoTime = 0;
}

PriorityQueue::~PriorityQueue(){
    delete [] m_pEvents;
}

HRESULT PriorityQueue::Initialize(DWORD maxSize){
    delete [] m_pEvents;
    m_capacity = 0;
    m_size = 0;
    m_pEvents = new LPEVENT[maxSize];
    memset(m_pEvents, 0, sizeof(Event*)*maxSize);
    if(!m_pEvents){
        return E_OUTOFMEMORY;
    }
    m_capacity = maxSize;
    VERIFY_PRIORITYQUEUE;
    return S_OK;
}

void PriorityQueue::Remove(Event* pEvent){
    DEBUGF_QUEUE_OPS(("Remove{\n"));
    VERIFY_PRIORITYQUEUE;
    // Bubble the event to the top.
    ASSERT(pEvent->m_priorityQueueIndex);

    DWORD test_node = pEvent->m_priorityQueueIndex;
    while(test_node > 1){
        DWORD parent = test_node / 2;
        Swap(test_node, parent);
        test_node = parent;
    }

    // Remove from queue - this balances the queue again

    Pop2();

    VERIFY_PRIORITYQUEUE;
    DEBUGF_QUEUE_OPS(("} // Remove\n"));
}

bool PriorityQueue::GetNextEventTime(REFERENCE_TIME* pTime){
    VERIFY_PRIORITYQUEUE;
    if(!m_size){
        return false;
    }
    *pTime = At(1)->eventArgs.timeStamp;
    return true;
}

Event* PriorityQueue::PopIfLessThanOrEqual(const REFERENCE_TIME* time){
    DEBUGF_QUEUE_OPS(("PopIfLessThanOrEqual{\n"));
    VERIFY_PRIORITYQUEUE;
    Event* pResult = 0;
    if(m_size && At(1)->IsLessThanOrEqual(time)){
        pResult = Pop2();
    }
    DEBUGF_QUEUE_OPS(("} // PopIfLessThanOrEqual\n"));
    return pResult;
}

Event* PriorityQueue::Pop(){
    DEBUGF_QUEUE_OPS(("Pop{\n"));
    VERIFY_PRIORITYQUEUE;
    Event* pResult = Pop2();
    DEBUGF_QUEUE_OPS(("} // Pop\n"));
    return pResult;
}

Event* PriorityQueue::Pop2(){
    DEBUGF_QUEUE_OPS(("Pop2{\n"));
    // Don't verify the queue, because it won't be valid if we're called from Remove
    // (Because Remove has bubbled the item it wants to remove to the top of the heap.)

    if(m_size <= 0){
        return NULL;
    }

    // Return the top of the queue, and
    // adjust the heap 

    Event* pTop = At(1);
    Move(1, m_size); // last element can be moved because it has no children, doesn't leave hole.

    DWORD test_node = 1;
    for(;;){
        DWORD child;
        if ( ( test_node * 2 ) >= m_size )
            break;
        if ( ( test_node * 2 + 1) >= m_size )
            child = test_node * 2;
        else if ( At( test_node * 2)->IsLessThan(At(test_node * 2 + 1)) )
            child = test_node * 2;
        else
            child = test_node * 2 + 1;
        if ( At(test_node)->IsGreaterThan(At(child)) ) {
            Swap(test_node, child);
            test_node = child;
        } else
            break;
    }
    --m_size;
    pTop->m_priorityQueueIndex = 0; // no longer in queue

    VERIFY_PRIORITYQUEUE;
    DEBUGF_QUEUE_OPS(("} // Pop2 returns\n"));
    return pTop;
}

HRESULT PriorityQueue::Push(Event* pEvent){
    VERIFY_PRIORITYQUEUE;
    ASSERT(m_pEvents);
    ASSERT(m_capacity);
    ASSERT(m_capacity >= m_size);
    if(m_capacity <= m_size){
        return E_OUTOFMEMORY;
    }

    pEvent->m_pseudoTime = m_pseudoTime++;

    AtPut(++m_size, pEvent); // At and AtPut are one-based, so pre-increment

    // Bubble into proper position
    DWORD test_node = m_size;
    while ( test_node > 1 ) {
        DWORD parent_node = test_node/2;
        if ( At(parent_node)->IsGreaterThan(At(test_node)) ){
            Swap(parent_node, test_node);
            test_node = parent_node;
        } else
            break;
    }

    VERIFY_PRIORITYQUEUE;
    return S_OK;
}

void PriorityQueue::AdjustEventTimes(REFERENCE_TIME delta){
    for(DWORD i = 1; i <= m_size; i++){
        Event* pEvent = At(i);
        pEvent->eventArgs.timeStamp += delta;
    }
}

void PriorityQueue::AtPut(DWORD index, Event* pEvent){
    ASSERT(1 <= index);
    ASSERT(index <= m_size);
    m_pEvents[index-1] = pEvent;
    pEvent->m_priorityQueueIndex = index;
}

void PriorityQueue::Move(DWORD dest, DWORD source){
    ASSERT(1 <= dest);
    ASSERT(dest <= m_size);
    ASSERT(1 <= source);
    ASSERT(source <= m_size);
    if(source != dest){
        m_pEvents[dest-1] = m_pEvents[source-1];
        m_pEvents[dest-1]->m_priorityQueueIndex = dest;
        m_pEvents[source-1] = 0;
    }
}

Event* PriorityQueue::At(DWORD index){
    ASSERT(1 <= index);
    ASSERT(index <= m_size);
    Event* result = m_pEvents[index-1];
    ASSERT(result);
    return result;
}

void PriorityQueue::Swap(DWORD index1, DWORD index2){
    Event* temp = At(index1);
    AtPut(index1, At(index2));
    AtPut(index2, temp);
}

#ifdef DBG
void PriorityQueue::Print(){
    Print2(true);
}

void PriorityQueue::Print2(bool bPrintEvents){
    REFERENCE_TIME now;
    KeQuerySystemTime((PLARGE_INTEGER) &now);
    __int64 minDelta = 0;
    __int64 maxDelta = 0;
    for(DWORD i = 1; i <= m_size; i++){
        Event* pEvent = At(i);
        __int64 deltams = (pEvent->eventArgs.timeStamp - now) / 10000;
        if(bPrintEvents){
            DEBUGF(("%d: owner: %s[%003d] seq: %I64d eventType: %s time: %I64d (now + %I64d ms) ptime: %I64d\n",
                i,
                pEvent->IsBufferEvent() ? "Buffer" : "Stream",
                pEvent->m_target.m_pBuffer->m_dwid,
                pEvent->sequenceNumber,
                gEventTypeToText[pEvent->eventArgs.eventType],
                pEvent->eventArgs.timeStamp,
                deltams,
                pEvent->m_pseudoTime
                ));
        }
        if(minDelta > deltams || i == 1){
            minDelta = deltams;
        }
        if(maxDelta < deltams || i == 1){
            maxDelta = deltams;
        }
    }
    DEBUGF(("     queued event time range: %d..%d ms\n",
            * (long*) & minDelta,
            * (long*) & maxDelta
        ));
}

void PriorityQueue::Verify(){
#ifdef PRINT_PRIORITYQUEUE
    Print();
#endif
    if(Initialized()){
        ASSERT(m_pEvents);
        ASSERT(m_capacity);
        ASSERT(m_capacity >= m_size);
        DWORD dwMaxSize = m_size;
        if(dwMaxSize > m_capacity){
            dwMaxSize = m_capacity;
        }
#ifndef DO_FULL_VERIFY_PRIORITYQUEUE
        if(dwMaxSize > 20){
            dwMaxSize = 20;
        }
#endif
        for(DWORD i = 1; i <= dwMaxSize; i++){
            Event* pEvent = At(i);
            ASSERT(pEvent->m_priorityQueueIndex == i);
            int parent = i / 2;
            if(parent>0){
                if( !m_pEvents[parent-1]->IsLessThan(m_pEvents[i-1]) ){
                    DEBUGF(("Error: parent: %d is not less than child: %d\n", parent, i));
                    Print();
                    ASSERT(false);
                }
            }
        }
    }
}

#endif // DBG

// Buffer

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
DWORD Buffer::m_gAllocatedCount;

void Buffer::RegisterPerformanceCounters(){
    DMusicRegisterPerformanceCounter( "DMMS allocated Buffers",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_gAllocatedCount );
}

void Buffer::UnregisterPerformanceCounters(){
    DMusicUnregisterPerformanceCounter( "DMMS allocated Buffers");
}

#endif

Buffer::Buffer(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    InterlockedIncrement((long*)&m_gAllocatedCount);
#endif
    m_cRef = 1;
    m_pSequencer = NULL;
    m_pObject = NULL;

    static long gid;

    m_dwid = InterlockedIncrement(&gid)-1;
    m_pHead = NULL;
    memset(&m_errorInfo,0,sizeof(m_errorInfo));
    m_sequenceNumber = 0;
#ifdef TRACK_PLAYING
    m_bStopped = false;
    m_bPlaying = false;
#endif
#ifdef TRACK_BUFFER_STATE
    m_tbs_bBufferDataValid = false;
    m_nextEventToRecord = 0;
#endif
#ifdef IGNORE_REDUNDANT_SETMIXBINS
    CMIXBINS m_MixBins;
#endif

}

Buffer::~Buffer(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    InterlockedDecrement((long*)&m_gAllocatedCount);
#endif
    if(m_pObject){
        m_pObject->Release();
    }
#ifdef DBG
    m_pSequencer = 0;
    m_pObject = 0;
    m_pHead = 0;
    m_sequenceNumber = 0;
#endif

}

HRESULT
Buffer::Initialize(CDirectSoundSequencer* pSequencer, LPCDSBUFFERDESC pdsbd){
    HRESULT hr = S_OK;

    if(m_pObject){
        DEBUGF(("DirectSoundSequencer Buffer::Initialize called twice.\n"));
#ifdef DBG
        _asm int 3;
#endif
        return E_FAIL; // Can't call initialize twice
    }

    m_pSequencer = pSequencer;

    hr = m_pSequencer->GetDirectSound()->CreateSoundBuffer(pdsbd, (LPDIRECTSOUNDBUFFER*) & m_pObject, 0);

    return hr;
}

HRESULT
Buffer::Clear(){
    EACH_ENQUEUE_DEBUGF(("Clear Buffer[%03d]\n", m_dwid));
    m_pSequencer->FreeEvents(this);
    return S_OK;
}

HRESULT
Buffer::ClearAtOrAfter(REFERENCE_TIME timeStamp){
    EACH_ENQUEUE_DEBUGF(("ClearAtOrAfter Buffer[%03d] %I64d\n", m_dwid, timeStamp));
    m_pSequencer->FreeEventsAtOrAfter(this, timeStamp);
    return S_OK;
}

HRESULT
Buffer::GetSequenceNumber(LPSEQUENCE_NUMBER pSequenceNumber){
    RAISE_DPC_IRQL;
    *pSequenceNumber = m_sequenceNumber;
    return S_OK;
}

HRESULT
Buffer::GetStatus(THIS_ LPDWORD pdwStatus){
#ifndef ASSUME_VALID_PARAMETERS
    ASSERT(pdwStatus);
#endif
    DWORD dwStatus = 0;

    {
        RAISE_DPC_IRQL;

        if(m_pObject){
            m_pObject->GetStatus(&dwStatus);
            dwStatus &= (DSSBSTATUS_PLAYING | DSSBSTATUS_LOOPING);
        }
        Event* pEvent = m_pHead;
        while(pEvent){
            if(pEvent->eventArgs.eventType == eBufferPlay){
                dwStatus |= DSSBSTATUS_PENDINGPLAYEVENTS;
                break;
            }
            pEvent = pEvent->pNextSameOwner;
        }
    }

    *pdwStatus = dwStatus;

    return S_OK;
}

HRESULT
Buffer::GetError(HRESULT* pError){
    RAISE_DPC_IRQL;
    *pError = m_errorInfo.error;
    return S_OK;
}

HRESULT
Buffer::GetErrorSequenceNumber(LPSEQUENCE_NUMBER pSequenceNumber){
    RAISE_DPC_IRQL;
    *pSequenceNumber = m_errorInfo.errorSequenceNumber;
    return S_OK;
}

HRESULT
Buffer::GetErrorTime(LPREFERENCE_TIME prtErrorTime){
    RAISE_DPC_IRQL;
    *prtErrorTime = m_errorInfo.errorTime;
    return S_OK;
}

HRESULT
Buffer::ClearError(){
    RAISE_DPC_IRQL;
    memset(&m_errorInfo, 0, sizeof(m_errorInfo));
    return S_OK;
}

HRESULT
Buffer::Play(REFERENCE_TIME timeStamp, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags){
    EACH_ENQUEUE_DEBUGF(("enqueue Buffer[%03d]->Play %I64d\n", m_dwid, timeStamp));
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferPlay;
    eventArgs.body.bufferPlay.dwFlags = dwFlags;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::Stop(REFERENCE_TIME timeStamp){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferStop;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::StopEx(REFERENCE_TIME timeStamp, DWORD dwFlags){
    EACH_ENQUEUE_DEBUGF(("enqueue Buffer[%03d]->StopEx %I64d\n", m_dwid, timeStamp));
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferStopEx;
    eventArgs.body.bufferStopEx.dwFlags = dwFlags;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetPlayRegion(REFERENCE_TIME timeStamp, DWORD dwPlayStart, DWORD dwPlayLength){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetPlayRegion;
    eventArgs.body.bufferSetPlayRegion.dwPlayStart = dwPlayStart;
    eventArgs.body.bufferSetPlayRegion.dwPlayLength = dwPlayLength;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetLoopRegion(REFERENCE_TIME timeStamp, DWORD dwLoopStart, DWORD dwLoopLength){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetLoopRegion;
    eventArgs.body.bufferSetLoopRegion.dwLoopStart = dwLoopStart;
    eventArgs.body.bufferSetLoopRegion.dwLoopLength = dwLoopLength;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetCurrentPosition(REFERENCE_TIME timeStamp, DWORD dwPlayCursor){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetCurrentPosition;
    eventArgs.body.bufferSetCurrentPosition.dwPlayCursor = dwPlayCursor;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetBufferData(REFERENCE_TIME timeStamp, LPVOID pvBufferData, DWORD dwBufferBytes){

#ifndef ASSUME_VALID_PARAMETERS
#ifdef DVTSNOOPBUG

    if(pvBufferData && dwBufferBytes) {
        if(!(MmQueryAddressProtect(pvBufferData) & PAGE_NOCACHE))
        {
            DEBUGF(("The buffer data must be allocated with PAGE_NOCACHE\n"));
            _asm int 3;
        }
    }

#endif // DVTSNOOPBUG
#endif // !ASSUME_VALID_PARAMETERS

#ifdef TRACK_BUFFER_STATE
    // Don't allow a SetBufferData to zero if we have a queued Play event
    if(! dwBufferBytes ){
        RAISE_DPC_IRQL;
        for(Event* pEvent = m_pHead; pEvent; pEvent = pEvent->pNextSameOwner){
            if (pEvent->eventArgs.eventType == eBufferPlay){
                if(timeStamp <= 0 || pEvent->eventArgs.timeStamp < timeStamp){
                    ASSERT(FALSE); // Clearing the buffer data while a play event is queued.
                }
            }
        }
    }
#endif

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetBufferData;
    eventArgs.body.bufferSetBufferData.pvBufferData = pvBufferData;
    eventArgs.body.bufferSetBufferData.dwBufferBytes = dwBufferBytes;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetFrequency(REFERENCE_TIME timeStamp, DWORD dwFrequency){
    // It turns out that you can't perform floating point operations at DPC time
    // so we can't set the Frequency at DPC time. We can, however, set
    // the pitch at DPC time. So convert this into a SetPitch call
#ifdef DPC_OK_TO_CALL_SETFREQUENCY
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetFrequency;
    eventArgs.body.bufferSetFrequency.dwFrequency = dwFrequency;
    return Enqueue(&eventArgs);
#else
    LONG lPitch = XAudioCalculatePitch(dwFrequency);
    return SetPitch(timeStamp, lPitch);
#endif
}

HRESULT
Buffer::SetPitch(REFERENCE_TIME timeStamp, LONG lPitch){
#ifndef ASSUME_VALID_PARAMETERS

    if(lPitch)
    {
        if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
        {
            DPF_ERROR("Invalid pitch value");
        }
    }

#endif // ASSUME_VALID_PARAMETERS

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetPitch;
    eventArgs.body.bufferSetPitch.lPitch = lPitch;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetVolume(REFERENCE_TIME timeStamp, LONG lVolume){

#ifndef ASSUME_VALID_PARAMETERS

    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DEBUGF(("Volume value out-of-bounds: %d\n", lVolume));
        _asm int 3;
    }

#endif // ASSUME_VALID_PARAMETERS

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetVolume;
    eventArgs.body.bufferSetVolume.lVolume = lVolume;
    return Enqueue(&eventArgs);
}

#undef DPF_FNAME
#define DPF_FNAME "Buffer::SetLFO"

HRESULT
Buffer::SetLFO(REFERENCE_TIME timeStamp, LPCDSLFODESC pLfo){
#ifndef ASSUME_VALID_PARAMETERS

    if(!pLfo)
    {
        DPF_ERROR("LFO description not provided");
    }

    if((pLfo->dwLFO < DSLFO_FIRST) && (pLfo->dwLFO > DSLFO_LAST))
    {
        DPF_ERROR("Invalid LFO identifier");
    }

    if(pLfo->dwDelay > 0x7FFF)
    {
        DPF_ERROR("Invalid LFO delay value");
    }

    if(pLfo->dwDelta > 0x3FF)
    {
        DPF_ERROR("Invalid LFO delta value");
    }

    if((pLfo->lPitchModulation < -128) || (pLfo->lPitchModulation > 127))
    {
        DPF_ERROR("Invalid LFO pitch modulation value");
    }

    if((pLfo->lFilterCutOffRange < -128) || (pLfo->lFilterCutOffRange > 127))
    {
        DPF_ERROR("Invalid LFO filter cutoff value");
    }

    if((pLfo->lAmplitudeModulation < -128) || (pLfo->lAmplitudeModulation > 127))
    {
        DPF_ERROR("Invalid LFO amplitude modulation value");
    }

    if(pLfo->dwLFO != DSLFO_MULTI)
    {
        if(pLfo->lFilterCutOffRange || pLfo->lAmplitudeModulation)
        {
            DPF_WARNING("The pitch LFO doesn not support filter cut-off range or amplitude modulation");
        }
    }

#endif // ASSUME_VALID_PARAMETERS

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetLFO;
    eventArgs.body.bufferSetLFO.lFODesc = *pLfo;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetEG(REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetEG;
    eventArgs.body.bufferSetEG.envelopeDesc = *pEnvelopeDesc;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetFilter(REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetFilter;
    eventArgs.body.bufferSetFilter.filterDesc = *pFilterDesc;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetOutputBuffer(REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetOutputBuffer;
    eventArgs.body.bufferSetOutputBuffer.pOutputBuffer = pOutputBuffer;
    if(pOutputBuffer){
        pOutputBuffer->AddRef();
    }
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetMixBins(REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetMixBins;
    ASSERT(pMixBins->dwMixBinCount <= DSMIXBIN_ASSIGNMENT_MAX);
    eventArgs.body.bufferSetMixBins.DSMixBins.dwMixBinCount         = pMixBins->dwMixBinCount;
    eventArgs.body.bufferSetMixBins.DSMixBins.lpMixBinVolumePairs   = NULL;
    memcpy((void *)eventArgs.body.bufferSetMixBins.VolumePairs, (void *)pMixBins->lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * pMixBins->dwMixBinCount);
    
    return Enqueue(&eventArgs);
}


//TODO: There's an assembly language instruction that does this.
//static DWORD CountSetBits(DWORD dwWord){
//    DWORD result = 0;
//    for(int i = 0; i < 32; i++){
//        if((1 << i) & dwWord){
//            result++;
//        }
//    }
//    return result;
//}

HRESULT
Buffer::SetMixBinVolumes(REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins){

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetMixBinVolumes;
    ASSERT(pMixBins->dwMixBinCount <= DSMIXBIN_ASSIGNMENT_MAX);
    eventArgs.body.bufferSetMixBinVolumes.DSMixBins.dwMixBinCount         = pMixBins->dwMixBinCount;
    eventArgs.body.bufferSetMixBinVolumes.DSMixBins.lpMixBinVolumePairs   = NULL;
    memcpy((void *)eventArgs.body.bufferSetMixBinVolumes.VolumePairs, (void *)pMixBins->lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * pMixBins->dwMixBinCount);
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetAllParameters(REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetAllParameters;
    memcpy(eventArgs.body.bufferSetAllParameters.ds3db, pds3db,
        sizeof(eventArgs.body.bufferSetAllParameters.ds3db));
    eventArgs.body.bufferSetAllParameters.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetConeAngles(REFERENCE_TIME timeStamp,
                      DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
{
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetConeAngles;
    eventArgs.body.bufferSetConeAngles.dwInsideConeAngle = dwInsideConeAngle;
    eventArgs.body.bufferSetConeAngles.dwOutsideConeAngle = dwOutsideConeAngle;
    eventArgs.body.bufferSetConeAngles.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetConeOrientation(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetConeOrientation;
    eventArgs.body.bufferSetConeOrientation.x = x;
    eventArgs.body.bufferSetConeOrientation.y = y;
    eventArgs.body.bufferSetConeOrientation.z = z;
    eventArgs.body.bufferSetConeOrientation.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetConeOutsideVolume(REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetConeOutsideVolume;
    eventArgs.body.bufferSetConeOutsideVolume.lConeOutsideVolume = lConeOutsideVolume;
    eventArgs.body.bufferSetConeOutsideVolume.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetMaxDistance(REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetMaxDistance;
    eventArgs.body.bufferSetMaxDistance.flMaxDistance = flMaxDistance;
    eventArgs.body.bufferSetMaxDistance.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetMinDistance(REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetMinDistance;
    eventArgs.body.bufferSetMinDistance.flMinDistance = flMinDistance;
    eventArgs.body.bufferSetMinDistance.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetMode(REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetMode;
    eventArgs.body.bufferSetMode.dwMode = dwMode;
    eventArgs.body.bufferSetMode.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetPosition(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetPosition;
    eventArgs.body.bufferSetPosition.x = x;
    eventArgs.body.bufferSetPosition.y = y;
    eventArgs.body.bufferSetPosition.z = z;
    eventArgs.body.bufferSetPosition.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetVelocity(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetVelocity;
    eventArgs.body.bufferSetVelocity.x = x;
    eventArgs.body.bufferSetVelocity.y = y;
    eventArgs.body.bufferSetVelocity.z = z;
    eventArgs.body.bufferSetVelocity.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Buffer::SetNotificationPositions(REFERENCE_TIME timeStamp, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies){
    const int kMaxNotifyCount = 4;
    if(dwNotifyCount > kMaxNotifyCount){
        dwNotifyCount = kMaxNotifyCount;
    }
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eBufferSetNotificationPositions;
    eventArgs.body.bufferSetNotificationPositions.dwNotifyCount = dwNotifyCount;
    memcpy(eventArgs.body.bufferSetNotificationPositions.aNotifies, paNotifies, dwNotifyCount*sizeof(DSBPOSITIONNOTIFY));
    return Enqueue(&eventArgs);
}



HRESULT
Buffer::DispatchEvent(EventArgs* pEventArgs){
    HRESULT hr = S_OK;
#ifdef TRACK_BUFFER_STATE
    TrackBufferState(pEventArgs);
#endif // TRACK_BUFFER_STATE

    EACH_CALL_DEBUGF(("%d ", (DWORD) pEventArgs->timeStamp));

    switch(pEventArgs->eventType){
    case eBufferPlay:
        EACH_CALL_DEBUGF(("Buffer[%03d]->Play(0,0,0x%x)\n", m_dwid, pEventArgs->body.bufferPlay.dwFlags));
#ifdef TRACK_PLAYING
        if(!m_bStopped){
            m_bPlaying = true;
            hr = m_pObject->Play(
                0,
                0,
                pEventArgs->body.bufferPlay.dwFlags
                );
        }
        else {
#ifdef PRINT_SQUELCHED_PLAYS
            DEBUGF(("...ignoring Play because Buffer[%03d] has already been stopped.\n", m_dwid));
#endif
        }
#else // TRACK_PLAYING
        hr = m_pObject->Play(
            0,
            0,
            pEventArgs->body.bufferPlay.dwFlags
            );
#endif // TRACK_PLAYING

        break;

    case eBufferStop:
        EACH_CALL_DEBUGF(("Buffer[%03d]->Stop()\n", m_dwid));
        hr = m_pObject->Stop();
#ifdef TRACK_PLAYING
        m_bStopped = true;
#endif
        break;

    case eBufferStopEx:
        EACH_CALL_DEBUGF(("Buffer[%03d]->StopEx(%d)\n", m_dwid,
            pEventArgs->body.bufferStopEx.dwFlags
            ));
#ifdef TRACK_PLAYING
#ifdef PRINT_SQUELCHED_PLAYS
        if(!m_bPlaying) {
            DEBUGF(("Buffer[%03d]->StopEx at time %I64d while not playing...\n", m_dwid, pEventArgs->timeStamp));
        }
#endif
        m_bPlaying = false;
#endif
        hr = m_pObject->StopEx(
            0, // Do it now
            pEventArgs->body.bufferStopEx.dwFlags
            );
#ifdef TRACK_PLAYING
        m_bStopped = true;
#endif
        break;

    case eBufferSetPlayRegion:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetPlayRegion(%d, %d)\n", m_dwid,
            pEventArgs->body.bufferSetPlayRegion.dwPlayStart,
            pEventArgs->body.bufferSetPlayRegion.dwPlayLength));
        hr = m_pObject->SetPlayRegion(
            pEventArgs->body.bufferSetPlayRegion.dwPlayStart,
            pEventArgs->body.bufferSetPlayRegion.dwPlayLength
            );
        break;

    case eBufferSetLoopRegion:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetLoopRegion(%d, %d)\n", m_dwid,
            pEventArgs->body.bufferSetLoopRegion.dwLoopStart,
            pEventArgs->body.bufferSetLoopRegion.dwLoopLength));
        hr = m_pObject->SetLoopRegion(
            pEventArgs->body.bufferSetLoopRegion.dwLoopStart,
            pEventArgs->body.bufferSetLoopRegion.dwLoopLength
            );
        break;

    case eBufferSetBufferData:
        {
            EACH_CALL_DEBUGF(("Buffer[%03d]->SetBufferData(0x%x, 0x%x)\n", m_dwid,
                pEventArgs->body.bufferSetBufferData.pvBufferData,
                pEventArgs->body.bufferSetBufferData.dwBufferBytes));
            hr = m_pObject->SetBufferData(
                pEventArgs->body.bufferSetBufferData.pvBufferData,
                pEventArgs->body.bufferSetBufferData.dwBufferBytes
                );
        }
        break;

    case eBufferSetCurrentPosition:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetCurrentPosition(%d)\n", m_dwid,
            pEventArgs->body.bufferSetCurrentPosition.dwPlayCursor));
        hr = m_pObject->SetCurrentPosition(
            pEventArgs->body.bufferSetCurrentPosition.dwPlayCursor
            );
        break;

    case eBufferSetFrequency:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetFrequency(%d)\n", m_dwid,
            pEventArgs->body.bufferSetFrequency.dwFrequency));
        hr = m_pObject->SetFrequency(
            pEventArgs->body.bufferSetFrequency.dwFrequency
            );
        break;

    case eBufferSetPitch:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetPitch(%d)\n", m_dwid,
            pEventArgs->body.bufferSetPitch.lPitch));
        hr = m_pObject->SetPitch(
            pEventArgs->body.bufferSetPitch.lPitch
            );
        break;

    case eBufferSetVolume:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetVolume(%d)\n", m_dwid,
            pEventArgs->body.bufferSetVolume.lVolume));
        hr = m_pObject->SetVolume(
            pEventArgs->body.bufferSetVolume.lVolume
            );
        break;

    case eBufferSetLFO:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetLFO({lfo: %d, delay: %d, delta: %d, pitchMod: %d, filterCutoffRange: %d, ampMod: %d})\n", m_dwid,
            pEventArgs->body.bufferSetLFO.lFODesc.dwLFO,
            pEventArgs->body.bufferSetLFO.lFODesc.dwDelay,
            pEventArgs->body.bufferSetLFO.lFODesc.dwDelta,
            pEventArgs->body.bufferSetLFO.lFODesc.lPitchModulation,
            pEventArgs->body.bufferSetLFO.lFODesc.lFilterCutOffRange,
            pEventArgs->body.bufferSetLFO.lFODesc.lAmplitudeModulation
            ));
        hr = m_pObject->SetLFO(
            &pEventArgs->body.bufferSetLFO.lFODesc
            );
        break;

    case eBufferSetEG:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetEG({eg: %d, mode: %d, delay: %d, attack: %d, hold: %d, decay: %d, release: %d, sustain: %d, pitchScale: %d, filterCutoff: %d})\n", m_dwid,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwEG,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwMode,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwDelay,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwAttack,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwHold,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwDecay,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwRelease,
            pEventArgs->body.bufferSetEG.envelopeDesc.dwSustain,
            pEventArgs->body.bufferSetEG.envelopeDesc.lPitchScale,
            pEventArgs->body.bufferSetEG.envelopeDesc.lFilterCutOff
            ));
        hr = m_pObject->SetEG(
            &pEventArgs->body.bufferSetEG.envelopeDesc
            );
        break;

    case eBufferSetFilter:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetFilter({mode: %d, Q: %d, adw:{%d,%d,%d,%d}})\n", m_dwid,
            pEventArgs->body.bufferSetFilter.filterDesc.dwMode,
            pEventArgs->body.bufferSetFilter.filterDesc.dwQCoefficient,
            pEventArgs->body.bufferSetFilter.filterDesc.adwCoefficients[0],
            pEventArgs->body.bufferSetFilter.filterDesc.adwCoefficients[1],
            pEventArgs->body.bufferSetFilter.filterDesc.adwCoefficients[2],
            pEventArgs->body.bufferSetFilter.filterDesc.adwCoefficients[3]
            ));
        hr = m_pObject->SetFilter(
            &pEventArgs->body.bufferSetFilter.filterDesc
            );
        break;

    case eBufferSetOutputBuffer:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetOutputBuffer(0x%x)\n", m_dwid,
            pEventArgs->body.bufferSetOutputBuffer.pOutputBuffer
            ));
        hr = m_pObject->SetOutputBuffer(
            pEventArgs->body.bufferSetOutputBuffer.pOutputBuffer
            );
        break;

    case eBufferSetMixBins:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetMixBins(...)\n", m_dwid));

        //Must fix up the pointer.
        pEventArgs->body.bufferSetMixBins.DSMixBins.lpMixBinVolumePairs = pEventArgs->body.bufferSetMixBins.VolumePairs;

#ifdef IGNORE_REDUNDANT_SETMIXBINS
        if (m_MixBins != &pEventArgs->body.bufferSetMixBins.DSMixBins) {
#endif

        hr = m_pObject->SetMixBins(
            &pEventArgs->body.bufferSetMixBins.DSMixBins
            );
#ifdef IGNORE_REDUNDANT_SETMIXBINS
        }
#endif
        break;

    case eBufferSetMixBinVolumes:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetMixBinVolumes(...)\n", m_dwid));
        //Must fix up the pointer.
        pEventArgs->body.bufferSetMixBinVolumes.DSMixBins.lpMixBinVolumePairs = pEventArgs->body.bufferSetMixBinVolumes.VolumePairs;
        hr = m_pObject->SetMixBinVolumes(
        &pEventArgs->body.bufferSetMixBinVolumes.DSMixBins
        );
       
        break;

    case eBufferSetAllParameters:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetAllParameters(...)\n", m_dwid
            ));
        hr = m_pObject->SetAllParameters(
            (DS3DBUFFER*) pEventArgs->body.bufferSetAllParameters.ds3db,
            pEventArgs->body.bufferSetAllParameters.dwApply
            );
        break;

    case eBufferSetConeAngles:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetConeAngles(%d,%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeAngles.dwInsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwOutsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwApply
            ));
        hr = m_pObject->SetConeAngles(
            pEventArgs->body.bufferSetConeAngles.dwInsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwOutsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwApply
            );
        break;

    case eBufferSetConeOrientation:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetConeOrientation(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeOrientation.x,
            pEventArgs->body.bufferSetConeOrientation.y,
            pEventArgs->body.bufferSetConeOrientation.z,
            pEventArgs->body.bufferSetConeOrientation.dwApply
            ));
        hr = m_pObject->SetConeOrientation(
            pEventArgs->body.bufferSetConeOrientation.x,
            pEventArgs->body.bufferSetConeOrientation.y,
            pEventArgs->body.bufferSetConeOrientation.z,
            pEventArgs->body.bufferSetConeOrientation.dwApply
            );
        break;

    case eBufferSetConeOutsideVolume:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetConeOutsideVolume(%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeOutsideVolume.lConeOutsideVolume,
            pEventArgs->body.bufferSetConeOutsideVolume.dwApply
            ));
        hr = m_pObject->SetConeOutsideVolume(
            pEventArgs->body.bufferSetConeOutsideVolume.lConeOutsideVolume,
            pEventArgs->body.bufferSetConeOutsideVolume.dwApply
            );
        break;

    case eBufferSetMaxDistance:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetMaxDistance(%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMaxDistance.flMaxDistance,
            pEventArgs->body.bufferSetMaxDistance.dwApply
            ));
        hr = m_pObject->SetMaxDistance(
            pEventArgs->body.bufferSetMaxDistance.flMaxDistance,
            pEventArgs->body.bufferSetMaxDistance.dwApply
            );
        break;

    case eBufferSetMinDistance:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetMaxDistance(%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMinDistance.flMinDistance,
            pEventArgs->body.bufferSetMinDistance.dwApply
            ));
        hr = m_pObject->SetMinDistance(
            pEventArgs->body.bufferSetMinDistance.flMinDistance,
            pEventArgs->body.bufferSetMinDistance.dwApply
            );
        break;

    case eBufferSetMode:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetMode(%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMode.dwMode,
            pEventArgs->body.bufferSetMode.dwApply
            ));
        hr = m_pObject->SetMode(
            pEventArgs->body.bufferSetMode.dwMode,
            pEventArgs->body.bufferSetMode.dwApply
            );
        break;

    case eBufferSetPosition:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetPosition(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetPosition.x,
            pEventArgs->body.bufferSetPosition.y,
            pEventArgs->body.bufferSetPosition.z,
            pEventArgs->body.bufferSetPosition.dwApply
            ));
        hr = m_pObject->SetPosition(
            pEventArgs->body.bufferSetPosition.x,
            pEventArgs->body.bufferSetPosition.y,
            pEventArgs->body.bufferSetPosition.z,
            pEventArgs->body.bufferSetPosition.dwApply
            );
        break;

    case eBufferSetVelocity:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetVelocity(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetVelocity.x,
            pEventArgs->body.bufferSetVelocity.y,
            pEventArgs->body.bufferSetVelocity.z,
            pEventArgs->body.bufferSetVelocity.dwApply
            ));
        hr = m_pObject->SetVelocity(
            pEventArgs->body.bufferSetVelocity.x,
            pEventArgs->body.bufferSetVelocity.y,
            pEventArgs->body.bufferSetVelocity.z,
            pEventArgs->body.bufferSetVelocity.dwApply
            );
        break;

    case eBufferSetNotificationPositions:
        EACH_CALL_DEBUGF(("Buffer[%03d]->SetNotificationPositions(%d,0x%08x)\n", m_dwid,
            pEventArgs->body.bufferSetNotificationPositions.dwNotifyCount,
            &pEventArgs->body.bufferSetNotificationPositions.aNotifies[0]
            ));
        hr = m_pObject->SetNotificationPositions(
            pEventArgs->body.bufferSetNotificationPositions.dwNotifyCount,
            &pEventArgs->body.bufferSetNotificationPositions.aNotifies[0]
            );
        break;
    default:
        hr = E_FAIL;
        break;
    }
    return hr;
}


#ifdef TRACK_BUFFER_STATE

void
Buffer::TrackBufferState(const EventArgs* pEventArgs){
    RAISE_DPC_IRQL;
    m_recentEvents[m_nextEventToRecord] = *pEventArgs;
    m_nextEventToRecord++;
    if (m_nextEventToRecord >= NUM_RECORDED_EVENTS) {
        m_nextEventToRecord = 0;
    }
    switch(pEventArgs->eventType){
    case eBufferPlay:
        ASSERT(m_tbs_bBufferDataValid);
        break;
    case eBufferSetBufferData:
        m_tbs_bBufferDataValid = pEventArgs->body.bufferSetBufferData.dwBufferBytes != 0;
        break;
    default:
        break;
    }
}

#endif // TRACK_BUFFER_STATE

HRESULT
Buffer::Enqueue(EventArgs* pArgs)
{
    return m_pSequencer->Enqueue(this, pArgs);
}

// Stream


#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
DWORD Stream::m_gAllocatedCount;

void Stream::RegisterPerformanceCounters(){
    DMusicRegisterPerformanceCounter( "DMMS allocated Streams",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_gAllocatedCount );
}

void Stream::UnregisterPerformanceCounters(){
    DMusicUnregisterPerformanceCounter( "DMMS allocated Streams");
}

#endif

Stream::Stream(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    InterlockedIncrement((long*)&m_gAllocatedCount);
#endif
    m_cRef = 1;
    static DWORD gid;
    m_pSequencer = NULL;
    m_pObject = NULL;
    m_dwid = InterlockedIncrement((long*)&gid)-1;
    m_pHead = NULL;
    memset(&m_errorInfo,0,sizeof(m_errorInfo));
    m_sequenceNumber = 0;
    m_dwNextPacketIndex = 0;
#ifdef TRACK_PLAYING
    m_bStopped = false;
    m_bPlaying = false;
#endif
}

Stream::~Stream(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    InterlockedDecrement((long*)&m_gAllocatedCount);
#endif
    if(m_pObject){
        m_pObject->Release();
    }
#ifdef DBG
    m_pSequencer = 0;
    m_pObject = 0;
    m_pHead = 0;
    m_sequenceNumber = 0;
#endif

}

HRESULT
Stream::Initialize(CDirectSoundSequencer* pSequencer, LPCDSSTREAMDESC pdssd){
    HRESULT hr = S_OK;

    if(m_pObject){
        DEBUGF(("DirectSoundSequencer Stream::Initialize called twice.\n"));
#ifdef DBG
        _asm int 3;
#endif
        return E_FAIL; // Can't call initialize twice
    }

    m_pSequencer = pSequencer;

    hr = m_pSequencer->GetDirectSound()->CreateSoundStream(pdssd, (LPDIRECTSOUNDSTREAM*) & m_pObject, 0);

    return hr;
}

HRESULT
Stream::Clear(){
    m_pSequencer->FreeEvents((Buffer*) this);
    return S_OK;
}

HRESULT
Stream::ClearAtOrAfter(REFERENCE_TIME timeStamp){
    m_pSequencer->FreeEventsAtOrAfter((Buffer*) this, timeStamp);
    return S_OK;
}

HRESULT
Stream::GetSequenceNumber(LPSEQUENCE_NUMBER pSequenceNumber){
    RAISE_DPC_IRQL;
    *pSequenceNumber = m_sequenceNumber;
    return S_OK;
}


HRESULT
Stream::GetStatus(LPDWORD pdwStatus){
#ifndef ASSUME_VALID_PARAMETERS
    ASSERT(pdwStatus);
#endif
    DWORD dwStatus = 0;

    {
        RAISE_DPC_IRQL;

        if(m_pHead){
            dwStatus |= DSSSSTATUS_PENDINGEVENTS;
        }
    }

    *pdwStatus = dwStatus;

    return S_OK;
}

HRESULT
Stream::GetPacketStatus(DWORD dwPacketIndex, LPDWORD pdwStatus){
#ifndef ASSUME_VALID_PARAMETERS
    ASSERT(pdwStatus);
    ASSERT(dwPacketIndex < MAX_QUEUED_PACKETS);
#endif
    *pdwStatus = m_dwPacketStatus[dwPacketIndex];

    return S_OK;
}

HRESULT
Stream::GetError(HRESULT* pError){
    RAISE_DPC_IRQL;
    *pError = m_errorInfo.error;
    return S_OK;
}

HRESULT
Stream::GetErrorSequenceNumber(LPSEQUENCE_NUMBER pSequenceNumber){
    RAISE_DPC_IRQL;
    *pSequenceNumber = m_errorInfo.errorSequenceNumber;
    return S_OK;
}

HRESULT
Stream::GetErrorTime(LPREFERENCE_TIME prtErrorTime){
    RAISE_DPC_IRQL;
    *prtErrorTime = m_errorInfo.errorTime;
    return S_OK;
}

HRESULT
Stream::ClearError(){
    RAISE_DPC_IRQL;
    memset(&m_errorInfo, 0, sizeof(m_errorInfo));
    return S_OK;
}

HRESULT
Stream::Process(REFERENCE_TIME timeStamp, LPCXMEDIAPACKET pInputPacket, LPDWORD pdwPacketIndex){

#ifndef ASSUME_VALID_PARAMETERS
#ifdef DVTSNOOPBUG

        if(!(MmQueryAddressProtect(pInputPacket->pvBuffer) & PAGE_NOCACHE))
        {
            DEBUGF(("The stream buffer must be allocated with PAGE_NOCACHE\n"));
            _asm int 3;
        }

#endif // DVTSNOOPBUG
#endif // !ASSUME_VALID_PARAMETERS

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamProcess;
    eventArgs.body.streamProcess.inputPacket = *pInputPacket;

    m_dwPacketStatus[m_dwNextPacketIndex] = XMEDIAPACKET_STATUS_NOT_YET_SUBMITTED;
    eventArgs.body.streamProcess.inputPacket.pdwStatus = &m_dwPacketStatus[m_dwNextPacketIndex];

    *pdwPacketIndex = m_dwNextPacketIndex;

    if(++m_dwNextPacketIndex >= MAX_QUEUED_PACKETS){
        m_dwNextPacketIndex = 0;
    }

    return Enqueue(&eventArgs);
}

HRESULT
Stream::Discontinuity(REFERENCE_TIME timeStamp){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamDiscontinuity;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::Flush(REFERENCE_TIME timeStamp){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamFlush;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetFrequency(REFERENCE_TIME timeStamp, DWORD dwFrequency){
    // It turns out that you can't perform floating point operations at DPC time
    // so we can't set the Frequency at DPC time. We can, however, set
    // the pitch at DPC time. So convert this into a SetPitch call
#ifdef DPC_OK_TO_CALL_SETFREQUENCY
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetFrequency;
    eventArgs.body.bufferSetFrequency.dwFrequency = dwFrequency;
    return Enqueue(&eventArgs);
#else
    LONG lPitch = XAudioCalculatePitch(dwFrequency);
    return SetPitch(timeStamp, lPitch);
#endif
}

HRESULT
Stream::SetPitch(REFERENCE_TIME timeStamp, LONG lPitch){
#ifndef ASSUME_VALID_PARAMETERS

    if(lPitch)
    {
        if((lPitch < DSBPITCH_MIN) || (lPitch > DSBPITCH_MAX))
        {
            DPF_ERROR("Invalid pitch value");
        }
    }

#endif // ASSUME_VALID_PARAMETERS

    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetPitch;
    eventArgs.body.bufferSetPitch.lPitch = lPitch;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetVolume(REFERENCE_TIME timeStamp, LONG lVolume){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetVolume;
    eventArgs.body.bufferSetVolume.lVolume = lVolume;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetLFO(REFERENCE_TIME timeStamp, LPCDSLFODESC pLFODesc){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetLFO;
    eventArgs.body.bufferSetLFO.lFODesc = *pLFODesc;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetEG(REFERENCE_TIME timeStamp, LPCDSENVELOPEDESC pEnvelopeDesc){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetEG;
    eventArgs.body.bufferSetEG.envelopeDesc = *pEnvelopeDesc;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetFilter(REFERENCE_TIME timeStamp, LPCDSFILTERDESC pFilterDesc){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetFilter;
    eventArgs.body.bufferSetFilter.filterDesc = *pFilterDesc;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetOutputBuffer(REFERENCE_TIME timeStamp, LPDIRECTSOUNDBUFFER pOutputBuffer){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetOutputBuffer;
    eventArgs.body.bufferSetOutputBuffer.pOutputBuffer = pOutputBuffer;
    if(pOutputBuffer){
        pOutputBuffer->AddRef();
    }
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetMixBins(REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetMixBins;
    ASSERT(pMixBins->dwMixBinCount <= DSMIXBIN_ASSIGNMENT_MAX);
    eventArgs.body.bufferSetMixBins.DSMixBins.dwMixBinCount         = pMixBins->dwMixBinCount;
    eventArgs.body.bufferSetMixBins.DSMixBins.lpMixBinVolumePairs   = NULL;
    memcpy((void *)eventArgs.body.bufferSetMixBins.VolumePairs, (void *)pMixBins->lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * pMixBins->dwMixBinCount);
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetMixBinVolumes(REFERENCE_TIME timeStamp, LPCDSMIXBINS pMixBins){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetMixBinVolumes;
    ASSERT(pMixBins->dwMixBinCount <= DSMIXBIN_ASSIGNMENT_MAX);
    eventArgs.body.bufferSetMixBinVolumes.DSMixBins.dwMixBinCount         = pMixBins->dwMixBinCount;
    eventArgs.body.bufferSetMixBinVolumes.DSMixBins.lpMixBinVolumePairs   = NULL;
    memcpy((void *)eventArgs.body.bufferSetMixBinVolumes.VolumePairs, (void *)pMixBins->lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * pMixBins->dwMixBinCount);
    return Enqueue(&eventArgs);
}

HRESULT
Stream::Pause(REFERENCE_TIME timeStamp, DWORD dwPause){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamPause;
    eventArgs.body.streamPause.dwPause = dwPause;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetAllParameters(REFERENCE_TIME timeStamp, LPCDS3DBUFFER pds3db, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetAllParameters;
    memcpy(eventArgs.body.bufferSetAllParameters.ds3db, pds3db,
        sizeof(eventArgs.body.bufferSetAllParameters.ds3db));
    eventArgs.body.bufferSetAllParameters.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetConeAngles(REFERENCE_TIME timeStamp,
                      DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
{
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetConeAngles;
    eventArgs.body.bufferSetConeAngles.dwInsideConeAngle = dwInsideConeAngle;
    eventArgs.body.bufferSetConeAngles.dwOutsideConeAngle = dwOutsideConeAngle;
    eventArgs.body.bufferSetConeAngles.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetConeOrientation(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetConeOrientation;
    eventArgs.body.bufferSetConeOrientation.x = x;
    eventArgs.body.bufferSetConeOrientation.y = y;
    eventArgs.body.bufferSetConeOrientation.z = z;
    eventArgs.body.bufferSetConeOrientation.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetConeOutsideVolume(REFERENCE_TIME timeStamp, LONG lConeOutsideVolume, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetConeOutsideVolume;
    eventArgs.body.bufferSetConeOutsideVolume.lConeOutsideVolume = lConeOutsideVolume;
    eventArgs.body.bufferSetConeOutsideVolume.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetMaxDistance(REFERENCE_TIME timeStamp, FLOAT flMaxDistance, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetMaxDistance;
    eventArgs.body.bufferSetMaxDistance.flMaxDistance = flMaxDistance;
    eventArgs.body.bufferSetMaxDistance.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetMinDistance(REFERENCE_TIME timeStamp, FLOAT flMinDistance, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetMinDistance;
    eventArgs.body.bufferSetMinDistance.flMinDistance = flMinDistance;
    eventArgs.body.bufferSetMinDistance.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetMode(REFERENCE_TIME timeStamp, DWORD dwMode, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetMode;
    eventArgs.body.bufferSetMode.dwMode = dwMode;
    eventArgs.body.bufferSetMode.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetPosition(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetPosition;
    eventArgs.body.bufferSetPosition.x = x;
    eventArgs.body.bufferSetPosition.y = y;
    eventArgs.body.bufferSetPosition.z = z;
    eventArgs.body.bufferSetPosition.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::SetVelocity(REFERENCE_TIME timeStamp, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply){
    EventArgs eventArgs;
    eventArgs.timeStamp = timeStamp;
    eventArgs.eventType = eStreamSetVelocity;
    eventArgs.body.bufferSetVelocity.x = x;
    eventArgs.body.bufferSetVelocity.y = y;
    eventArgs.body.bufferSetVelocity.z = z;
    eventArgs.body.bufferSetVelocity.dwApply = dwApply;
    return Enqueue(&eventArgs);
}

HRESULT
Stream::DispatchEvent(EventArgs* pEventArgs){
    HRESULT hr = S_OK;
    switch(pEventArgs->eventType){
    case eStreamProcess:
        EACH_CALL_DEBUGF(("Stream[%03d]->Process()\n", m_dwid
            ));
#ifdef TRACK_PLAYING
        if(!m_bStopped){
#endif // TRACK_PLAYING
            hr = m_pObject->Process(
                &pEventArgs->body.streamProcess.inputPacket,
                0
                );
#ifdef TRACK_PLAYING
        }
        else {
            EACH_CALL_DEBUGF(("... Process ignored because Stream[%03d] is stopped.\n", m_dwid));
        }
#endif // TRACK_PLAYING
        break;

    case eStreamDiscontinuity:
        EACH_CALL_DEBUGF(("Stream[%03d]->Discontinuity()\n", m_dwid));
        hr = m_pObject->Discontinuity();
        break;

    case eStreamFlush:
#ifdef TRACK_PLAYING
        m_bStopped = true;
#endif
        EACH_CALL_DEBUGF(("Stream[%03d]->Flush()\n", m_dwid
            ));
        hr = m_pObject->Flush(
            );
        break;

    case eStreamSetFrequency:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetFrequency(%d)\n", m_dwid,
            pEventArgs->body.bufferSetFrequency.dwFrequency));
        hr = m_pObject->SetFrequency(
            pEventArgs->body.bufferSetFrequency.dwFrequency
            );
        break;

    case eStreamSetPitch:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetPitch(%d)\n", m_dwid,
            pEventArgs->body.bufferSetPitch.lPitch));
        hr = m_pObject->SetPitch(
            pEventArgs->body.bufferSetPitch.lPitch
            );
        break;

    case eStreamSetVolume:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetVolume(%d)\n", m_dwid,
            pEventArgs->body.bufferSetVolume.lVolume));
        hr = m_pObject->SetVolume(
            pEventArgs->body.bufferSetVolume.lVolume
            );
        break;

    case eStreamSetLFO:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetLFO(...)\n", m_dwid
            ));
        hr = m_pObject->SetLFO(
            &pEventArgs->body.bufferSetLFO.lFODesc
            );
        break;

    case eStreamSetEG:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetEG(...)\n", m_dwid
            ));
        hr = m_pObject->SetEG(
            &pEventArgs->body.bufferSetEG.envelopeDesc
            );
        break;

    case eStreamSetFilter:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetFilter(...)\n", m_dwid
            ));
        hr = m_pObject->SetFilter(
            &pEventArgs->body.bufferSetFilter.filterDesc
            );
        break;

    case eStreamSetOutputBuffer:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetOutputBuffer(...)\n", m_dwid
            ));
        hr = m_pObject->SetOutputBuffer(
            pEventArgs->body.bufferSetOutputBuffer.pOutputBuffer
            );
        break;

    case eStreamSetMixBins:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetMixBins(...)\n", m_dwid));
        //Must fix up the pointer.
        pEventArgs->body.bufferSetMixBins.DSMixBins.lpMixBinVolumePairs = pEventArgs->body.bufferSetMixBins.VolumePairs;
        hr = m_pObject->SetMixBins(
            &pEventArgs->body.bufferSetMixBins.DSMixBins
            );
        break;

    case eStreamSetMixBinVolumes:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetMixBinVolumes(...)\n", m_dwid));
        //Must fix up the pointer.
        pEventArgs->body.bufferSetMixBinVolumes.DSMixBins.lpMixBinVolumePairs = pEventArgs->body.bufferSetMixBinVolumes.VolumePairs;
        hr = m_pObject->SetMixBinVolumes(
        &pEventArgs->body.bufferSetMixBinVolumes.DSMixBins
        );
        break;

    case eStreamPause:
        EACH_CALL_DEBUGF(("Stream[%03d]->Pause(%d)\n", m_dwid,
            pEventArgs->body.streamPause.dwPause));
        hr = m_pObject->Pause(
            pEventArgs->body.streamPause.dwPause
            );
        break;

    case eStreamSetAllParameters:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetAllParameters(...)\n", m_dwid
            ));
        hr = m_pObject->SetAllParameters(
            (DS3DBUFFER*) pEventArgs->body.bufferSetAllParameters.ds3db,
            pEventArgs->body.bufferSetAllParameters.dwApply
            );
        break;

    case eStreamSetConeAngles:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetConeAngles(%d,%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeAngles.dwInsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwOutsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwApply
            ));
        hr = m_pObject->SetConeAngles(
            pEventArgs->body.bufferSetConeAngles.dwInsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwOutsideConeAngle,
            pEventArgs->body.bufferSetConeAngles.dwApply
            );
        break;

    case eStreamSetConeOrientation:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetConeOrientation(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeOrientation.x,
            pEventArgs->body.bufferSetConeOrientation.y,
            pEventArgs->body.bufferSetConeOrientation.z,
            pEventArgs->body.bufferSetConeOrientation.dwApply
            ));
        hr = m_pObject->SetConeOrientation(
            pEventArgs->body.bufferSetConeOrientation.x,
            pEventArgs->body.bufferSetConeOrientation.y,
            pEventArgs->body.bufferSetConeOrientation.z,
            pEventArgs->body.bufferSetConeOrientation.dwApply
            );
        break;

    case eStreamSetConeOutsideVolume:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetConeOutsideVolume(%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetConeOutsideVolume.lConeOutsideVolume,
            pEventArgs->body.bufferSetConeOutsideVolume.dwApply
            ));
        hr = m_pObject->SetConeOutsideVolume(
            pEventArgs->body.bufferSetConeOutsideVolume.lConeOutsideVolume,
            pEventArgs->body.bufferSetConeOutsideVolume.dwApply
            );
        break;

    case eStreamSetMaxDistance:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetMaxDistance(%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMaxDistance.flMaxDistance,
            pEventArgs->body.bufferSetMaxDistance.dwApply
            ));
        hr = m_pObject->SetMaxDistance(
            pEventArgs->body.bufferSetMaxDistance.flMaxDistance,
            pEventArgs->body.bufferSetMaxDistance.dwApply
            );
        break;

    case eStreamSetMinDistance:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetMaxDistance(%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMinDistance.flMinDistance,
            pEventArgs->body.bufferSetMinDistance.dwApply
            ));
        hr = m_pObject->SetMinDistance(
            pEventArgs->body.bufferSetMinDistance.flMinDistance,
            pEventArgs->body.bufferSetMinDistance.dwApply
            );
        break;

    case eStreamSetMode:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetMode(%d,%d)\n", m_dwid,
            pEventArgs->body.bufferSetMode.dwMode,
            pEventArgs->body.bufferSetMode.dwApply
            ));
        hr = m_pObject->SetMode(
            pEventArgs->body.bufferSetMode.dwMode,
            pEventArgs->body.bufferSetMode.dwApply
            );
        break;

    case eStreamSetPosition:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetPosition(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetPosition.x,
            pEventArgs->body.bufferSetPosition.y,
            pEventArgs->body.bufferSetPosition.z,
            pEventArgs->body.bufferSetPosition.dwApply
            ));
        hr = m_pObject->SetPosition(
            pEventArgs->body.bufferSetPosition.x,
            pEventArgs->body.bufferSetPosition.y,
            pEventArgs->body.bufferSetPosition.z,
            pEventArgs->body.bufferSetPosition.dwApply
            );
        break;

    case eStreamSetVelocity:
        EACH_CALL_DEBUGF(("Stream[%03d]->SetVelocity(%g,%g,%g,%d)\n", m_dwid,
            pEventArgs->body.bufferSetVelocity.x,
            pEventArgs->body.bufferSetVelocity.y,
            pEventArgs->body.bufferSetVelocity.z,
            pEventArgs->body.bufferSetVelocity.dwApply
            ));
        hr = m_pObject->SetVelocity(
            pEventArgs->body.bufferSetVelocity.x,
            pEventArgs->body.bufferSetVelocity.y,
            pEventArgs->body.bufferSetVelocity.z,
            pEventArgs->body.bufferSetVelocity.dwApply
            );
        break;

    default:
        hr = E_FAIL;
        break;
    }
    return hr;
}

HRESULT
Stream::Enqueue(EventArgs* pArgs)
{
    return m_pSequencer->Enqueue(this, pArgs);
}

HRESULT
WINAPI DirectSoundCreateSequencer(LPGUID pguidDeviceId, DWORD dwMaxEvents,
                           LPDIRECTSOUNDSEQUENCER * ppDirectSoundSequencer)
{
    HRESULT hr = DS_OK;

    CDirectSoundSequencer* pDirectSoundSequencer = new CDirectSoundSequencer;
    if(!pDirectSoundSequencer){
        hr = E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr)){
        hr = pDirectSoundSequencer->Initialize(pguidDeviceId, dwMaxEvents);
    }
    if(SUCCEEDED(hr)){
        *ppDirectSoundSequencer = pDirectSoundSequencer;
    }
    else{
        delete pDirectSoundSequencer;
    }

    return hr;
}

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mixf.cpp ===
//      Mixf.cpp
//      Copyright (c) Microsoft Corporation	1996-1999
//      Filtered Mix Engine

#include "simple.h"
#include <mmsystem.h>
#include "synth.h"

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#pragma message ("Programer note: property hack")
//#define DEBUG_DUMP_FILE

#pragma warning(disable : 4101 4102 4146)  

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#ifdef DEBUG_DUMP_FILE
DWORD dmp_bufsize = 4000000;
DWORD dmp_samplesrecorded;
DWORD dmp_buffercount;
short dmp_soundbuffer[4000000];
#endif
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

DWORD CDigitalAudio::Mix16Filtered(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI++;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI);
}


DWORD CDigitalAudio::Mix16FilteredInterleaved(
	short **ppBuffers,
	DWORD *pdwChannels,
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
	VFRACT vfDeltaLVolume, 
	VFRACT vfDeltaRVolume,
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFFDELTA cfdK,
    COEFFDELTA cfdB1,
    COEFFDELTA cfdB2)
{
    DWORD dwI;
	DWORD dwIndex;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  
    VFRACT vfRVFract = vfRVolume << 8; 
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	dwLength <<= 1;
    
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
    		    pfSamplePos -= pfLoopLength;
			}
	        else
	    	    break;
	    }

        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract  += pfDeltaPitch;
            pfPitch    = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume  = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume  = vfRVFract >> 8;
            cfK       += cfdK;
            cfB1      += cfdB1;
            cfB2      += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

		// Interpolate 
        lA = (long)pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

		//
        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// >>>> We store the negative of b1 in the table, so we flip the sign again by
		// >>>> adding here
		// >>>> Lookinto simply using a float here, it may just be faster, save a div 
		//
        lM = MulDiv(lM, cfK, (1 << 30))
           + MulDiv(m_lPrevSample, cfB1, (1 << 30))
           - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

		//
		//
		//
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lM;

		//
		//
		//
		lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;

		dwIndex = 0;
		while ( dwIndex < dwBufferCount )
		{
			short *pBuffer = &ppBuffers[dwIndex][dwI];

			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_LEFT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				*pBuffer += (short) lA;

				_asm{jno no_oflowl}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowl}
				*pBuffer = (short) 0x8000;
			}
no_oflowl:	
			if ( pdwChannels[dwIndex] & WAVELINK_CHANNEL_RIGHT )
			{
				//  Keep this around so we can use it to generate new assembly code (see below...)
				pBuffer++;
				*pBuffer += (short) lM;

				_asm{jno no_oflowr}
				*pBuffer = 0x7fff;
				_asm{js  no_oflowr}
				*pBuffer = (short) 0x8000;
			}
no_oflowr:
			dwIndex++;
		}

#ifdef DEBUG_DUMP_FILE
dmp_soundbuffer[dmp_samplesrecorded] = pBuffer[dwI];
if (dmp_samplesrecorded < dmp_bufsize)
	dmp_samplesrecorded++ ;
#endif

		dwI += 2;
    }

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch   = pfPitch;
    m_pfLastSample  = pfSamplePos;
	m_cfLastK  = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    return (dwI >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\fparms.h ===
// Filter coefficients in 2.30 fixed point
//

// b1 min -1.998977207 max -0.166675302 range  0.083380291
//
// NOTE: b1 is stored as a positive value, and these coefcients are 
//       the negation of b1, which when originally calculated is a 
//       negative number.  Compensation for this is made in the 
//       filter calculation by changing a subtraction to and add.
//
COEFF CVoiceFilter::m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ebb466f, 0x7ea7f78f, 0x7e9382d1, 0x7e7dd6bd, 0x7e66e0d2, 0x7e4e8d7b, 0x7e34c7ef, 0x7e197a33, 0x7dfc8cf8, 0x7ddde792, 0x7dbd6fdd, 0x7d9b0a28, 0x7d76991c, 0x7d4ffdad, 0x7d2716f0, 0x7cfbc20e, 0x7ccdda1e, 0x7c9d380b, 0x7c69b277, 0x7c331d86, 0x7bf94ada, 0x7bbc094e, 0x7b7b24e1, 0x7b366687, 0x7aed93fd, 0x7aa06f93, 0x7a4eb80d, 0x79f82860, 0x799c7781, 0x793b5834, 0x78d478ce, 0x786782f6, 0x77f41b69, 0x7779e1be, 0x76f8701a, 0x766f5af7, 0x75de30d9, 0x75447a04, 0x74a1b83e, 0x73f5667e, 0x733ef8b2, 0x727ddb68, 0x71b17398, 0x70d91e64, 0x6ff430d6, 0x6f01f7a6, 0x6e01b71c, 0x6cf2aadd, 0x6bd405d3, 0x6aa4f217, 0x696490f9, 0x6811fafc, 0x66ac4000, 0x65326754, 0x63a36ffd, 0x61fe50cb, 0x6041f8ab, 0x5e6d4eb5, 0x5c7f3229, 0x5a767a36, 0x5851f538, 0x5610676b, 0x53b08886, 0x5131001c, 0x4e905faf, 0x4bcd1a02, 0x48e5763a, 0x45d77cf6, 0x42a0dcf4, 0x3f3ec32e, 0x3bada059, 0x37e8d1eb, 0x33ea1e16, 0x2fa8e4d8, 0x2b18cea1, 0x262787a8, 0x20b88fa1, 0x1a9cba80, 0x137e89ae, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2, 0x0aaacee2 },
    { 0x7f3a8183, 0x7f3a8183, 0x7f2ead4b, 0x7f222259, 0x7f14d583, 0x7f06bae2, 0x7ef7c5d3, 0x7ee7e8ea, 0x7ed715da, 0x7ec53d71, 0x7eb24f85, 0x7e9e3ae1, 0x7e88ed39, 0x7e72530b, 0x7e5a579e, 0x7e40e4d6, 0x7e25e328, 0x7e093982, 0x7deacd2c, 0x7dca81a3, 0x7da8388e, 0x7d83d181, 0x7d5d29ef, 0x7d341cf8, 0x7d088340, 0x7cda32c0, 0x7ca8fe95, 0x7c74b6d6, 0x7c3d284a, 0x7c021c39, 0x7bc35824, 0x7b809d86, 0x7b39a97d, 0x7aee348f, 0x7a9df23f, 0x7a4890c5, 0x79edb8a4, 0x798d0c45, 0x7926278e, 0x78b89f77, 0x78440187, 0x77c7d362, 0x7743924f, 0x76b6b2a7, 0x76209f5b, 0x7580b96c, 0x74d65768, 0x7420c4e2, 0x735f420b, 0x7291032c, 0x71b53057, 0x70cae514, 0x6fd13038, 0x6ec713cd, 0x6dab8536, 0x6c7d6d73, 0x6b3ba9b9, 0x69e50c2b, 0x68785d07, 0x66f45c16, 0x6557c263, 0x63a14479, 0x61cf94cf, 0x5fe16688, 0x5dd57057, 0x5baa6f6a, 0x595f29ec, 0x56f270e8, 0x546320cc, 0x51b01fee, 0x4ed859b9, 0x4bdab532, 0x48b6048b, 0x4568ea9d, 0x41f1b1a9, 0x3e4e0bdb, 0x3a7ab142, 0x3672c53e, 0x322ed973, 0x2da33782, 0x28bcab08, 0x2359c59e, 0x1d3a3b6e, 0x15c8f78f, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d, 0x0ad59d8d },
    { 0x7f6169cb, 0x7f6169cb, 0x7f57defe, 0x7f4dbf73, 0x7f4301e7, 0x7f379c78, 0x7f2b84a6, 0x7f1eaf3a, 0x7f111048, 0x7f029b14, 0x7ef3420b, 0x7ee2f6b4, 0x7ed1a99a, 0x7ebf4a40, 0x7eabc708, 0x7e970d26, 0x7e81087b, 0x7e69a38d, 0x7e50c75f, 0x7e365b5d, 0x7e1a4537, 0x7dfc68c2, 0x7ddca7d3, 0x7dbae216, 0x7d96f4e2, 0x7d70bb13, 0x7d480cca, 0x7d1cbf41, 0x7ceea488, 0x7cbd8b51, 0x7c893e9b, 0x7c518573, 0x7c1622a4, 0x7bd6d458, 0x7b9353c0, 0x7b4b54ae, 0x7afe8530, 0x7aac8d10, 0x7a550d69, 0x79f7a015, 0x7993d737, 0x79293c91, 0x78b75107, 0x783d8beb, 0x77bb5a68, 0x77301ed6, 0x769b3017, 0x75fbd8eb, 0x75515756, 0x749adc08, 0x73d789d5, 0x7306753c, 0x7226a41d, 0x71370d81, 0x703699a8, 0x6f242241, 0x6dfe72fd, 0x6cc44a73, 0x6b745b74, 0x6a0d4ed7, 0x688dc5cd, 0x66f45cc7, 0x653faef9, 0x636e5a7e, 0x617f04ff, 0x5f7060dd, 0x5d41329c, 0x5af0564c, 0x587cc486, 0x55e59655, 0x532a075b, 0x50497505, 0x4d43595c, 0x4a173fa1, 0x46c4b010, 0x434b0ef8, 0x3fa969d4, 0x3bde2949, 0x37e698f1, 0x33be287e, 0x2f5d2dc3, 0x2ab6aaf1, 0x25b3e5f6, 0x202a5a83, 0x19bf4b09, 0x11701842, 0x11701842, 0x11701842, 0x11701842 },
    { 0x7f7da104, 0x7f7da104, 0x7f75bfb5, 0x7f6d6274, 0x7f648169, 0x7f5b1431, 0x7f5111dd, 0x7f4670e0, 0x7f3b2709, 0x7f2f2971, 0x7f226c75, 0x7f14e3a0, 0x7f0681a3, 0x7ef7383b, 0x7ee6f825, 0x7ed5b10b, 0x7ec35165, 0x7eafc66c, 0x7e9afbfb, 0x7e84dc73, 0x7e6d509c, 0x7e543f86, 0x7e398e64, 0x7e1d2062, 0x7dfed67c, 0x7dde8f51, 0x7dbc26f0, 0x7d97769b, 0x7d705491, 0x7d4693c9, 0x7d1a03b1, 0x7cea6fd5, 0x7cb79f94, 0x7c8155c7, 0x7c475050, 0x7c0947c7, 0x7bc6eeee, 0x7b7ff248, 0x7b33f78a, 0x7ae29d14, 0x7a8b7954, 0x7a2e1a2a, 0x79ca0439, 0x795eb23c, 0x78eb944a, 0x78700f15, 0x77eb7b2c, 0x775d2433, 0x76c4482b, 0x762016ab, 0x756fb043, 0x74b225dc, 0x73e6783b, 0x730b97bd, 0x7220642c, 0x7123acf0, 0x7014317d, 0x6ef0a248, 0x6db7a20d, 0x6c67c7cb, 0x6affa156, 0x697db69c, 0x67e08dc2, 0x6626b01a, 0x644eafdb, 0x62572ece, 0x603ee57b, 0x5e04aafe, 0x5ba77ce1, 0x592686c3, 0x568128db, 0x53b6fcd2, 0x50c7d78f, 0x4db3c6ce, 0x4a7b0894, 0x471dfa79, 0x439cfdbf, 0x3ff84c11, 0x3c2fb6b7, 0x384245be, 0x342da44a, 0x2fed3590, 0x2b7884e6, 0x26c05ba8, 0x21a898a4, 0x1bf8a7e1, 0x15274a9e, 0x15274a9e, 0x15274a9e },
    { 0x7f93a2b0, 0x7f93a2b0, 0x7f8d0dc6, 0x7f86105c, 0x7f7ea3b7, 0x7f76c0a3, 0x7f6e5f6d, 0x7f6577d8, 0x7f5c0115, 0x7f51f1b0, 0x7f473f91, 0x7f3bdfde, 0x7f2fc6fa, 0x7f22e86c, 0x7f1536d3, 0x7f06a3cf, 0x7ef71feb, 0x7ee69a8e, 0x7ed501db, 0x7ec24294, 0x7eae4802, 0x7e98fbd4, 0x7e8245f5, 0x7e6a0c6d, 0x7e503333, 0x7e349bff, 0x7e172613, 0x7df7ae0a, 0x7dd60d9a, 0x7db21b4e, 0x7d8baa41, 0x7d6289c9, 0x7d36852d, 0x7d07633c, 0x7cd4e5eb, 0x7c9ec9e7, 0x7c64c61b, 0x7c268b32, 0x7be3c306, 0x7b9c100f, 0x7b4f0cbd, 0x7afc4ad1, 0x7aa3529d, 0x7a43a250, 0x79dcad21, 0x796dda81, 0x78f68542, 0x7875fabd, 0x77eb79f0, 0x775632b1, 0x76b544d9, 0x7607bf96, 0x754ca0c0, 0x7482d46f, 0x73a934b9, 0x72be89b5, 0x71c189d9, 0x70b0dac8, 0x6f8b129d, 0x6e4eb9e0, 0x6cfa4e2d, 0x6b8c45af, 0x6a03138e, 0x685d2d5a, 0x6699117f, 0x64b54ed3, 0x62b08d14, 0x60899651, 0x5e3f60c6, 0x5bd1190b, 0x593e2bbe, 0x56864e2b, 0x53a984c3, 0x50a82680, 0x4d82db94, 0x4a3a9616, 0x46d0828f, 0x4345ee35, 0x3f9c1fed, 0x3bd41fa2, 0x37ee6513, 0x33ea61f2, 0x2fc5cfda, 0x2b7b9215, 0x2701bf1f, 0x2245c3dc, 0x1d23897b, 0x174c1540, 0x174c1540 },
    { 0x7faa8d3c, 0x7fa55772, 0x7f9fce51, 0x7f99ec65, 0x7f93abdb, 0x7f8d0674, 0x7f85f581, 0x7f7e71d5, 0x7f7673bf, 0x7f6df2ff, 0x7f64e6b8, 0x7f5b4566, 0x7f5104cc, 0x7f4619ea, 0x7f3a78e7, 0x7f2e1502, 0x7f20e07c, 0x7f12cc82, 0x7f03c91b, 0x7ef3c4fe, 0x7ee2ad8a, 0x7ed06e97, 0x7ebcf254, 0x7ea8212a, 0x7e91e189, 0x7e7a17c1, 0x7e60a5c5, 0x7e456b02, 0x7e284416, 0x7e090a91, 0x7de794b2, 0x7dc3b50c, 0x7d9d3a3b, 0x7d73ee7a, 0x7d47973f, 0x7d17f4cc, 0x7ce4c1b2, 0x7cadb243, 0x7c727412, 0x7c32ad42, 0x7bedfbf0, 0x7ba3f56f, 0x7b542590, 0x7afe0dcf, 0x7aa12484, 0x7a3cd3f0, 0x79d07969, 0x795b6453, 0x78dcd541, 0x7853fcf4, 0x77bffb84, 0x771fdf7d, 0x7672a526, 0x75b735ec, 0x74ec67fd, 0x7410fe2d, 0x7323a82d, 0x72230340, 0x710d9b70, 0x6fe1ed6b, 0x6e9e6932, 0x6d41759b, 0x6bc974f2, 0x6a34ca99, 0x6881e1fa, 0x66af36a9, 0x64bb5dbb, 0x62a51048, 0x606b36c1, 0x5e0cf4df, 0x5b89b59a, 0x58e13672, 0x56139154, 0x532143db, 0x500b32ed, 0x4cd2a936, 0x49794f3a, 0x46011b47, 0x426c37aa, 0x3ebcdd2c, 0x3af51eff, 0x3716a3e0, 0x332244c6, 0x2f17828a, 0x2af3b49f, 0x26b0b02c, 0x22424d7d, 0x1d912d1f, 0x1d912d1f },
    { 0x7fb839e1, 0x7fb3d32f, 0x7faf2553, 0x7faa2b92, 0x7fa4e0d5, 0x7f9f3fa8, 0x7f994231, 0x7f92e226, 0x7f8c18c4, 0x7f84dec5, 0x7f7d2c55, 0x7f74f907, 0x7f6c3bc7, 0x7f62eac8, 0x7f58fb7a, 0x7f4e6274, 0x7f431362, 0x7f3700ef, 0x7f2a1cb0, 0x7f1c5708, 0x7f0d9f0b, 0x7efde261, 0x7eed0d25, 0x7edb09bb, 0x7ec7c0ab, 0x7eb31872, 0x7e9cf54d, 0x7e853907, 0x7e6bc2b9, 0x7e506e89, 0x7e33155f, 0x7e138c98, 0x7df1a5a8, 0x7dcd2dc2, 0x7da5ed67, 0x7d7ba7f5, 0x7d4e1b29, 0x7d1cfe97, 0x7ce80313, 0x7caed210, 0x7c710cf1, 0x7c2e4c4f, 0x7be61f2d, 0x7b980a23, 0x7b43867c, 0x7ae80144, 0x7a84da4d, 0x7a196334, 0x79a4de57, 0x79267dd1, 0x789d6277, 0x78089aef, 0x776722ce, 0x76b7e1e5, 0x75f9abbf, 0x752b3f60, 0x744b4761, 0x73585a7e, 0x7250fcab, 0x7133a0e7, 0x6ffeabc6, 0x6eb07703, 0x6d47561a, 0x6bc19c21, 0x6a1da2ec, 0x6859d390, 0x6674b054, 0x646cdff2, 0x624139f9, 0x5ff0d403, 0x5d7b0f50, 0x5adfa61e, 0x581eb7d9, 0x5538d35c, 0x522efddc, 0x4f02b579, 0x4bb5ee15, 0x484b073e, 0x44c4b9d3, 0x4125fc8a, 0x3d71ddef, 0x39ab5281, 0x35d4f4a1, 0x31f0b1e2, 0x2dff5ccf, 0x2a001103, 0x25ef4246, 0x21c51d73, 0x1d725a1a },
    { 0x7fc3854a, 0x7fbfc9c8, 0x7fbbd133, 0x7fb79765, 0x7fb317e7, 0x7fae4def, 0x7fa93451, 0x7fa3c580, 0x7f9dfb7f, 0x7f97cfdb, 0x7f913b9c, 0x7f8a373d, 0x7f82baa1, 0x7f7abcfe, 0x7f7234d6, 0x7f6917e0, 0x7f5f5af8, 0x7f54f208, 0x7f49cff6, 0x7f3de686, 0x7f312643, 0x7f237e5a, 0x7f14dc81, 0x7f052ccd, 0x7ef45987, 0x7ee24b06, 0x7ecee775, 0x7eba12a8, 0x7ea3adcf, 0x7e8b9747, 0x7e71aa3e, 0x7e55be73, 0x7e37a7d3, 0x7e173619, 0x7df4346a, 0x7dce68d6, 0x7da593e2, 0x7d796ff6, 0x7d49b0c7, 0x7d1602b4, 0x7cde0a0e, 0x7ca1625a, 0x7c5f9d83, 0x7c1842f7, 0x7bcacebd, 0x7b76b07e, 0x7b1b4a7b, 0x7ab7f07f, 0x7a4be6cb, 0x79d660fb, 0x795680f7, 0x78cb55e3, 0x7833db38, 0x778ef7e3, 0x76db7daf, 0x761828e6, 0x7543a043, 0x745c7567, 0x736125d1, 0x72501c86, 0x7127b496, 0x6fe63c91, 0x6e89fb28, 0x6d1134ff, 0x6b7a340d, 0x69c35048, 0x67eafa01, 0x65efc5a4, 0x63d078d9, 0x618c18b3, 0x5f21f87c, 0x5c91c885, 0x59dba433, 0x57001e59, 0x54004a9f, 0x50ddc30c, 0x4d9aa823, 0x4a399ab2, 0x46bdae2e, 0x432a52e1, 0x3f83375e, 0x3bcc20ef, 0x3808ba85, 0x343c5962, 0x3069b54f, 0x2c928f48, 0x28b73b99, 0x24d5f78a, 0x20e9d5ff },
    { 0x7fcce827, 0x7fc9bb01, 0x7fc65930, 0x7fc2bf08, 0x7fbee89a, 0x7fbad1a7, 0x7fb67598, 0x7fb1cf7d, 0x7facda00, 0x7fa78f5b, 0x7fa1e950, 0x7f9be11e, 0x7f956f75, 0x7f8e8c66, 0x7f872f58, 0x7f7f4ef4, 0x7f76e114, 0x7f6ddab2, 0x7f642fce, 0x7f59d356, 0x7f4eb70e, 0x7f42cb6f, 0x7f35ff8b, 0x7f2840e0, 0x7f197b38, 0x7f09987b, 0x7ef8807b, 0x7ee618be, 0x7ed24446, 0x7ebce34c, 0x7ea5d2f6, 0x7e8ced09, 0x7e720791, 0x7e54f47b, 0x7e35812f, 0x7e137615, 0x7dee961a, 0x7dc69e1e, 0x7d9b445c, 0x7d6c37bf, 0x7d391f32, 0x7d0198d1, 0x7cc5391e, 0x7c838a17, 0x7c3c0a41, 0x7bee2bac, 0x7b9952dc, 0x7b3cd5b2, 0x7ad7fa4a, 0x7a69f5cf, 0x79f1eb58, 0x796eead1, 0x78dfefe8, 0x7843e126, 0x77998f3a, 0x76dfb477, 0x7614f4ac, 0x7537dd80, 0x7446e739, 0x7340765c, 0x7222de0a, 0x70ec635f, 0x6f9b4209, 0x6e2db21d, 0x6ca1ef73, 0x6af6428f, 0x69290b1f, 0x6738cc30, 0x652439c6, 0x62ea47c0, 0x608a398b, 0x5e03b219, 0x5b56c349, 0x5883fbda, 0x558c72cf, 0x5271cf04, 0x4f3649d9, 0x4bdcabb6, 0x4868417d, 0x44dcca5a, 0x413e5d7f, 0x3d914802, 0x39d9e335, 0x361c63f7, 0x325ca340, 0x2e9ddf39, 0x2ae27242, 0x272b7951, 0x23785afd },
    { 0x7fd4bcff, 0x7fd206b2, 0x7fcf22be, 0x7fcc0de3, 0x7fc8c49f, 0x7fc54329, 0x7fc18569, 0x7fbd86f1, 0x7fb942f5, 0x7fb4b443, 0x7fafd53a, 0x7faa9fbb, 0x7fa50d24, 0x7f9f163e, 0x7f98b330, 0x7f91db6e, 0x7f8a85ab, 0x7f82a7c3, 0x7f7a36a4, 0x7f71263a, 0x7f676950, 0x7f5cf179, 0x7f51aee8, 0x7f459054, 0x7f3882cb, 0x7f2a7187, 0x7f1b45c0, 0x7f0ae674, 0x7ef9382b, 0x7ee61cb8, 0x7ed172ed, 0x7ebb164d, 0x7ea2deb1, 0x7e889fec, 0x7e6c2957, 0x7e4d4560, 0x7e2bb908, 0x7e074354, 0x7ddf9cae, 0x7db4763e, 0x7d857932, 0x7d5245f2, 0x7d1a7349, 0x7cdd8d7a, 0x7c9b1549, 0x7c527ef1, 0x7c033109, 0x7bac835e, 0x7b4dbdd2, 0x7ae61711, 0x7a74b372, 0x79f8a3bd, 0x7970e411, 0x78dc5ae9, 0x7839d842, 0x77881509, 0x76c5b2dd, 0x75f13c3f, 0x7509254d, 0x740bcd34, 0x72f78079, 0x71ca7c44, 0x7082f2db, 0x6f1f1176, 0x6d9d0790, 0x6bfb0fed, 0x6a377b3a, 0x6850bc7d, 0x6645770b, 0x64148df9, 0x61bd3478, 0x5f3efe9a, 0x5c99f1e0, 0x59ce9460, 0x56ddf9a4, 0x53c9cbef, 0x509450bf, 0x4d406758, 0x49d1807a, 0x464b8e94, 0x42b2ee35, 0x3f0c4716, 0x3b5c6658, 0x37a81308, 0x33f3de13, 0x3043eec5, 0x2c9bcbe4, 0x28fe206f, 0x256c77e6 },
    { 0x7fdb4a34, 0x7fd8f760, 0x7fd67cc5, 0x7fd3d77e, 0x7fd10466, 0x7fce0016, 0x7fcac6df, 0x7fc754c3, 0x7fc3a569, 0x7fbfb41c, 0x7fbb7bbd, 0x7fb6f6b7, 0x7fb21efb, 0x7facedea, 0x7fa75c4f, 0x7fa1624b, 0x7f9af745, 0x7f9411d8, 0x7f8ca7bd, 0x7f84adb3, 0x7f7c1767, 0x7f72d756, 0x7f68deae, 0x7f5e1d2a, 0x7f5280ea, 0x7f45f64b, 0x7f3867b3, 0x7f29bd5e, 0x7f19dd22, 0x7f08aa2e, 0x7ef604c0, 0x7ee1c9da, 0x7ecbd2e2, 0x7eb3f544, 0x7e9a020a, 0x7e7dc55b, 0x7e5f0606, 0x7e3d84e5, 0x7e18fc4a, 0x7df11f4e, 0x7dc59917, 0x7d960c0d, 0x7d6210fb, 0x7d29362a, 0x7ceafe57, 0x7ca6dfac, 0x7c5c429f, 0x7c0a80c0, 0x7bb0e38d, 0x7b4ea327, 0x7ae2e512, 0x7a6cbb02, 0x79eb21a7, 0x795cff99, 0x78c12472, 0x7816482c, 0x775b0ab7, 0x768df41f, 0x75ad7523, 0x74b7e894, 0x73ab957d, 0x7286b251, 0x7147695b, 0x6febde78, 0x6e72366f, 0x6cd89fee, 0x6b1d5e49, 0x693ed60a, 0x673b9b3c, 0x6512812b, 0x62c2ab45, 0x604b9e91, 0x5dad5307, 0x5ae843b3, 0x57fd7cbe, 0x54eea5ff, 0x51be08f5, 0x4e6e90dd, 0x4b03c417, 0x4781b613, 0x43ecf1a2, 0x404a5bed, 0x3c9f10f8, 0x38f03acf, 0x3542e51c, 0x319bceae, 0x2dff3a6b, 0x2a70c076, 0x26f31efe },
    { 0x7fe0c7d8, 0x7fdec869, 0x7fdca623, 0x7fda5e6b, 0x7fd7ee6a, 0x7fd5530d, 0x7fd288fc, 0x7fcf8c96, 0x7fcc59e6, 0x7fc8ec9e, 0x7fc5400d, 0x7fc14f13, 0x7fbd141a, 0x7fb88908, 0x7fb3a72e, 0x7fae6740, 0x7fa8c13d, 0x7fa2ac62, 0x7f9c1f11, 0x7f950ebf, 0x7f8d6fd5, 0x7f853598, 0x7f7c5208, 0x7f72b5bd, 0x7f684fc1, 0x7f5d0d66, 0x7f50da12, 0x7f439f10, 0x7f354351, 0x7f25ab2d, 0x7f14b819, 0x7f02485b, 0x7eee36ab, 0x7ed859d7, 0x7ec08458, 0x7ea683d2, 0x7e8a209c, 0x7e6b1d29, 0x7e49356c, 0x7e241e2c, 0x7dfb8443, 0x7dcf0bd6, 0x7d9e4f73, 0x7d68df1f, 0x7d2e3f59, 0x7cede801, 0x7ca74330, 0x7c59ac12, 0x7c046d98, 0x7ba6c134, 0x7b3fcd8f, 0x7acea543, 0x7a524595, 0x79c99560, 0x79336415, 0x788e68f8, 0x77d942bc, 0x7712777a, 0x7638753d, 0x75499341, 0x74441400, 0x73262852, 0x71edf3bd, 0x70999227, 0x6f271f12, 0x6d94bea9, 0x6be0a885, 0x6a093455, 0x680ce85d, 0x65ea896f, 0x63a12c42, 0x6130475f, 0x5e97c51c, 0x5bd8148e, 0x58f23872, 0x55e7d2d8, 0x52bb2c2d, 0x4f6f34a3, 0x4c077ecf, 0x488832f8, 0x44f5faab, 0x4155e518, 0x3dad44df, 0x3a0188d5, 0x3658114f, 0x32b60416, 0x2f2020c5, 0x2b9a9736, 0x2828e0cf },
    { 0x7fe56357, 0x7fe3a9e9, 0x7fe1d1c9, 0x7fdfd89a, 0x7fddbbc9, 0x7fdb7887, 0x7fd90bc8, 0x7fd67237, 0x7fd3a834, 0x7fd0a9c7, 0x7fcd729c, 0x7fc9fdf7, 0x7fc646a7, 0x7fc24700, 0x7fbdf8c9, 0x7fb9552d, 0x7fb454ae, 0x7faeef11, 0x7fa91b48, 0x7fa2cf5e, 0x7f9c005e, 0x7f94a235, 0x7f8ca795, 0x7f8401d2, 0x7f7aa0bb, 0x7f707271, 0x7f656335, 0x7f595d36, 0x7f4c4856, 0x7f3e09e9, 0x7f2e846e, 0x7f1d973b, 0x7f0b1e2e, 0x7ef6f13f, 0x7ee0e41f, 0x7ec8c5ba, 0x7eae5fb9, 0x7e9175e9, 0x7e71c5a5, 0x7e4f0526, 0x7e28e2bf, 0x7dff0415, 0x7dd1053a, 0x7d9e77bb, 0x7d66e199, 0x7d29bc35, 0x7ce67321, 0x7c9c62e9, 0x7c4ad7d1, 0x7bf10c7d, 0x7b8e28a1, 0x7b213fac, 0x7aa94f85, 0x7a253f50, 0x7993de76, 0x78f3e3c7, 0x7843ecfc, 0x77827eaa, 0x76ae04a8, 0x75c4d340, 0x74c52928, 0x73ad3282, 0x727b0d1b, 0x712cce0a, 0x6fc088ea, 0x6e3458ca, 0x6c866b0f, 0x6ab50c19, 0x68beb5ec, 0x66a2205d, 0x645e52ad, 0x61f2b5ea, 0x5f5f2757, 0x5ca40a08, 0x59c25688, 0x56bba74b, 0x539240bc, 0x50491385, 0x4ce3b851, 0x4966640b, 0x45d5d47d, 0x423735a4, 0x3e900064, 0x3ae5d428, 0x373e4d29, 0x339ed976, 0x300c8eda, 0x2c8c038a, 0x29212b03 },
    { 0x7fe941eb, 0x7fe7c34b, 0x7fe62976, 0x7fe47242, 0x7fe29b53, 0x7fe0a218, 0x7fde83c1, 0x7fdc3d3c, 0x7fd9cb2d, 0x7fd729e8, 0x7fd45566, 0x7fd1493e, 0x7fce0096, 0x7fca761f, 0x7fc6a3ff, 0x7fc283cc, 0x7fbe0e72, 0x7fb93c2a, 0x7fb4045f, 0x7fae5d9d, 0x7fa83d75, 0x7fa19865, 0x7f9a61b3, 0x7f928b52, 0x7f8a05b9, 0x7f80bfb7, 0x7f76a646, 0x7f6ba45a, 0x7f5fa29e, 0x7f52873e, 0x7f443597, 0x7f348dec, 0x7f236d0f, 0x7f10abf9, 0x7efc1f67, 0x7ee59758, 0x7eccde96, 0x7eb1ba1b, 0x7e93e873, 0x7e732113, 0x7e4f1394, 0x7e2766e4, 0x7dfbb865, 0x7dcb9af5, 0x7d9695e6, 0x7d5c23e7, 0x7d1bb1d0, 0x7cd49d69, 0x7c86341d, 0x7c2fb1a2, 0x7bd03e9b, 0x7b66ef41, 0x7af2c20d, 0x7a729e7d, 0x79e55403, 0x7949991f, 0x789e0ad1, 0x77e12c75, 0x7711681c, 0x762d0fa7, 0x75325ea2, 0x741f7d44, 0x72f28483, 0x71a983b1, 0x704287a5, 0x6ebba3a0, 0x6d12fc2b, 0x6b46d3ce, 0x695599ca, 0x673dfa72, 0x64fef0f3, 0x6297da11, 0x600886ea, 0x5d514f1c, 0x5a7320f1, 0x576f8e8b, 0x5448d6ab, 0x5101e7ca, 0x4d9e5ca7, 0x4a227160, 0x4692f0d9, 0x42f51abf, 0x3f4e82f1, 0x3ba4eba0, 0x37fe1c20, 0x345fb672, 0x30cf0dcf, 0x2d510037, 0x29e9d4d1 },
    { 0x7fec8253, 0x7feb3520, 0x7fe9cfa6, 0x7fe84fe8, 0x7fe6b3b9, 0x7fe4f8b7, 0x7fe31c49, 0x7fe11b94, 0x7fdef378, 0x7fdca085, 0x7fda1ef6, 0x7fd76aa8, 0x7fd47f0c, 0x7fd1571f, 0x7fcded5b, 0x7fca3baa, 0x7fc63b57, 0x7fc1e4fa, 0x7fbd3065, 0x7fb81491, 0x7fb28782, 0x7fac7e2b, 0x7fa5ec54, 0x7f9ec476, 0x7f96f793, 0x7f8e7511, 0x7f852a86, 0x7f7b0389, 0x7f6fe973, 0x7f63c325, 0x7f5674bb, 0x7f47df40, 0x7f37e054, 0x7f2651cb, 0x7f130945, 0x7efdd7af, 0x7ee688c7, 0x7ecce283, 0x7eb0a47a, 0x7e91872f, 0x7e6f3b4d, 0x7e4968e1, 0x7e1fae6b, 0x7df19fed, 0x7dbec5da, 0x7d869c03, 0x7d48905b, 0x7d0401bd, 0x7cb83e97, 0x7c64838f, 0x7c07fa20, 0x7ba1b737, 0x7b30b9d7, 0x7ab3e9d8, 0x7a2a16c0, 0x7991f6dc, 0x78ea26a1, 0x7831286c, 0x776564e2, 0x76852bdf, 0x758eb65b, 0x7480293a, 0x73579964, 0x7213114a, 0x70b097f7, 0x6f2e3a03, 0x6d8a1454, 0x6bc260f5, 0x69d585c0, 0x67c224eb, 0x65872efa, 0x6323f5a5, 0x60983f09, 0x5de4581b, 0x5b09255a, 0x58083084, 0x54e3b1f0, 0x519e9462, 0x4e3c722f, 0x4ac18b10, 0x4732b221, 0x4395347c, 0x3feeb90e, 0x3c451b2a, 0x389e4194, 0x34fff44d, 0x316fb356, 0x2df2908d, 0x2a8d0e8b },
    { 0x7fef3e18, 0x7fee1a75, 0x7fece101, 0x7feb8fe5, 0x7fea251c, 0x7fe89e6f, 0x7fe6f96e, 0x7fe5336f, 0x7fe34982, 0x7fe1386d, 0x7fdefca2, 0x7fdc9239, 0x7fd9f4e0, 0x7fd71fd5, 0x7fd40dd9, 0x7fd0b91f, 0x7fcd1b3f, 0x7fc92d23, 0x7fc4e6f4, 0x7fc04005, 0x7fbb2ebb, 0x7fb5a870, 0x7fafa156, 0x7fa90c57, 0x7fa1daee, 0x7f99fcfd, 0x7f91609f, 0x7f87f1f5, 0x7f7d9aed, 0x7f724300, 0x7f65ceea, 0x7f582061, 0x7f4915b4, 0x7f388972, 0x7f2651fa, 0x7f124102, 0x7efc2319, 0x7ee3bf10, 0x7ec8d55c, 0x7eab1f63, 0x7e8a4ec5, 0x7e660c7a, 0x7e3df7fd, 0x7e11a645, 0x7de0a0c4, 0x7daa6441, 0x7d6e5fa4, 0x7d2bf2b5, 0x7ce26cc4, 0x7c910b49, 0x7c36f87f, 0x7bd349f2, 0x7b64ff25, 0x7aeb0043, 0x7a641cef, 0x79cf0b56, 0x792a677d, 0x7874b300, 0x77ac5551, 0x76cf9caa, 0x75dcbfd5, 0x74d1e0f2, 0x73ad117e, 0x726c57c6, 0x710db5f1, 0x6f8f32e2, 0x6deee4f8, 0x6c2afee8, 0x6a41de6d, 0x68321cf0, 0x65faa194, 0x639ab459, 0x61121178, 0x5e60fc3d, 0x5b88500f, 0x58898e9b, 0x5566e9ae, 0x5223478d, 0x4ec240ac, 0x4b481609, 0x47b99fb0, 0x441c33c2, 0x407586b6, 0x3ccb861c, 0x39242feb, 0x35856852, 0x31f4d089, 0x2e77a0b4, 0x2b1286d9 }
};

// b2 min  0.043480612 max  0.999116025 range 22.978426231
//
COEFF CVoiceFilter::m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{   
    { 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3ebe7626, 0x3eab8aa1, 0x3e97854f, 0x3e82562c, 0x3e6bec5b, 0x3e54361a, 0x3e3b20ae, 0x3e209866, 0x3e048882, 0x3de6db39, 0x3dc7799c, 0x3da64b93, 0x3d8337cb, 0x3d5e23ba, 0x3d36f379, 0x3d0d89d3, 0x3ce1c827, 0x3cb38e63, 0x3c82baff, 0x3c4f2ae0, 0x3c18b96d, 0x3bdf4064, 0x3ba297ee, 0x3b62968b, 0x3b1f1112, 0x3ad7daa6, 0x3a8cc4c5, 0x3a3d9f3e, 0x39ea3834, 0x39925c32, 0x3935d62d, 0x38d46f98, 0x386df075, 0x38021f72, 0x3790c206, 0x37199c9d, 0x369c72be, 0x36190740, 0x358f1c8b, 0x34fe74dc, 0x3466d294, 0x33c7f88f, 0x3321aa8b, 0x3273ad96, 0x31bdc889, 0x30ffc486, 0x30396d94, 0x2f6a9338, 0x2e930912, 0x2db2a793, 0x2cc94cb2, 0x2bd6dc9f, 0x2adb428b, 0x29d6714e, 0x28c8642a, 0x27b11f57, 0x2690b095, 0x25672f95, 0x2434be20, 0x22f98820, 0x21b5c336, 0x2069ae02, 0x1f158ed7, 0x1db9b1dc, 0x1c566646, 0x1aebfaa1, 0x197ab7ca, 0x1802da28, 0x168488c4, 0x14ffc94a, 0x13746fb3, 0x11e2079e, 0x1047b3cb, 0x0ea3fd72, 0x0cf487dc, 0x0b359075, 0x096107e6, 0x076cc67a, 0x054678ea, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7, 0x02c862e7 },
    { 0x3f3d0b77, 0x3f3d0b77, 0x3f318694, 0x3f2554a1, 0x3f186ba1, 0x3f0ac0fd, 0x3efc498d, 0x3eecf98b, 0x3edcc486, 0x3ecb9d5d, 0x3eb9763c, 0x3ea64087, 0x3e91ecdd, 0x3e7c6b03, 0x3e65a9e6, 0x3e4d9786, 0x3e3420ec, 0x3e193229, 0x3dfcb643, 0x3dde9727, 0x3dbebdab, 0x3d9d116e, 0x3d7978e0, 0x3d53d92f, 0x3d2c1638, 0x3d021282, 0x3cd5af2c, 0x3ca6cbee, 0x3c754707, 0x3c40fd34, 0x3c09c9ad, 0x3bcf861e, 0x3b920a9b, 0x3b512da8, 0x3b0cc42e, 0x3ac4a183, 0x3a78976a, 0x3a28761c, 0x39d40c50, 0x397b2755, 0x391d9313, 0x38bb1a34, 0x38538643, 0x37e69fc4, 0x37742e70, 0x36fbf961, 0x367dc754, 0x35f95eec, 0x356e870c, 0x34dd0725, 0x3444a7aa, 0x33a53278, 0x32fe735e, 0x32503899, 0x319a5376, 0x30dc98e2, 0x3016e21a, 0x2f490d4a, 0x2e72fe3e, 0x2d949f0a, 0x2cade09b, 0x2bbebb4e, 0x2ac72f4d, 0x29c744d0, 0x28bf0c1a, 0x27ae9d24, 0x269616cf, 0x25759d89, 0x244d5931, 0x231d71f8, 0x21e60bff, 0x20a74136, 0x1f6118ec, 0x1e137c22, 0x1cbe252e, 0x1b608854, 0x19f9b13c, 0x18880dc4, 0x17091796, 0x1578bd9c, 0x13d045d2, 0x1203e8e8, 0x0ffcc2a0, 0x0d8481cc, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee, 0x09c35cee },
    { 0x3f63f484, 0x3f63f484, 0x3f5ab931, 0x3f50f2d2, 0x3f46994f, 0x3f3ba41d, 0x3f300a33, 0x3f23c207, 0x3f16c188, 0x3f08fe0f, 0x3efa6c64, 0x3eeb00aa, 0x3edaae5d, 0x3ec9684c, 0x3eb72088, 0x3ea3c864, 0x3e8f5066, 0x3e79a840, 0x3e62bec1, 0x3e4a81d4, 0x3e30de6e, 0x3e15c085, 0x3df91305, 0x3ddabfca, 0x3dbaaf8a, 0x3d98c9d9, 0x3d74f50f, 0x3d4f1648, 0x3d271153, 0x3cfcc8ab, 0x3cd01d6e, 0x3ca0ef4e, 0x3c6f1c95, 0x3c3a820f, 0x3c02fb0f, 0x3bc86166, 0x3b8a8d62, 0x3b4955cd, 0x3b048ff0, 0x3abc0f97, 0x3a6fa71e, 0x3a1f2773, 0x39ca6037, 0x39711fc3, 0x39133352, 0x38b06719, 0x38488678, 0x37db5c24, 0x3768b267, 0x36f0535f, 0x3672094f, 0x35ed9ef4, 0x3562dfe9, 0x34d19916, 0x34399932, 0x339ab13f, 0x32f4b528, 0x32477c54, 0x3192e254, 0x30d6c789, 0x301311d4, 0x2f47ad3e, 0x2e748c93, 0x2d99a9f6, 0x2cb70741, 0x2bccae44, 0x2adab0c2, 0x29e12809, 0x28e0341b, 0x27d7fa34, 0x26c8a27f, 0x25b254c2, 0x24953398, 0x237155db, 0x2246bd71, 0x21154a82, 0x1fdca95d, 0x1e9c3828, 0x1d52df41, 0x1bfed284, 0x1a9d27af, 0x192915dd, 0x179a7055, 0x15e21bce, 0x13dfce54, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0, 0x1135a2b0 },
    { 0x3f802c4d, 0x3f802c4d, 0x3f789a93, 0x3f70969d, 0x3f6819c2, 0x