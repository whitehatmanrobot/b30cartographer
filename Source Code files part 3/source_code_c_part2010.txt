      public void Set (IpMacPair local, IpMacPair remote)
        {
            // Set constants
            Enet.Type = NetConstants.ENET_TYPE_IP;
            Ip.VerHdr = 0x45;
            Ip.Tos = 0x00;
            Ip.Id = 0;
            Ip.FragOff = 0;
            Ip.Ttl = 0x40;
            Ip.Protocol = NetConstants.ICMP_PROTOCOL;
            Ip.Checksum = 0;

            // Set parameters
            Enet.eaSrc = new EnetAddr(local.mac);
            Enet.eaDst = new EnetAddr(remote.mac);
            Ip.Len = NetConstants.HTONS((ushort) (NetConstants.IP_HDR_SIZE + NetConstants.ICMP_HDR_SIZE));
            Ip.ipaSrc = new IpAddr(local.ip);
            Ip.ipaDst = new IpAddr(remote.ip);
            Ip.DoChecksum();

            DoIcmpChecksum();
        }

        public void DoIcmpChecksum ()
        {
            Icmp.Checksum = 0;
            Icmp.Checksum = IpHdr.ComputeIPChecksum((byte[]) Icmp);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class UdpHdr : WireData
    {
        public ushort               portSrc;
        public ushort               portDst;
        public ushort               Len;
        public ushort               Checksum;
    }

    
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class UdpPacket : WireData
    {
        public EnetHdr              Enet = new EnetHdr();
        public IpHdr                Ip = new IpHdr();
        public UdpHdr               Udp = new UdpHdr();
        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[] Payload = null;

        public UdpPacket()
        {
        }

        public void Set(IpMacPair local, IpMacPair remote, byte[] payload, ushort id)
        {
            // Set constants
            Enet.Type = NetConstants.ENET_TYPE_IP;
            Ip.VerHdr = 0x45;
            Ip.Tos = 0x00;
            Ip.Id = 0;
            Ip.FragOff = 0;
            Ip.Ttl = 0x40;
            Ip.Protocol = NetConstants.UDP_PROTOCOL;
            Ip.Checksum = 0;

            // Set parameters
            Enet.eaSrc = new EnetAddr(local.mac);
            Enet.eaDst = new EnetAddr(remote.mac);
            Ip.Len = NetConstants.HTONS((ushort)(NetConstants.IP_HDR_SIZE + NetConstants.UDP_HDR_SIZE + payload.Length));
            Ip.ipaSrc = new IpAddr(local.ip);
            Ip.ipaDst = new IpAddr(remote.ip);
            Ip.DoChecksum();
            Udp.portSrc = NetConstants.HTONS(local.port);
            Udp.portDst = NetConstants.HTONS(remote.port);
            Udp.Len = NetConstants.HTONS((ushort)(NetConstants.UDP_HDR_SIZE + payload.Length));
            DoUdpChecksum(payload);

            Payload = payload;
        }

        public void DoUdpChecksum(byte[] payload)
        {
            // We need an array consisting of:
            //   PseudoHdr
            //   UdpHdr
            //   Payload
            //   [1 byte pad if Payload length is odd]

            PseudoIpHdr pseudo = new PseudoIpHdr();
            pseudo.ipaSrc = Ip.ipaSrc;
            pseudo.ipaDst = Ip.ipaDst;
            pseudo.Zero = 0;
            pseudo.Protocol = NetConstants.UDP_PROTOCOL;
            pseudo.Len = Udp.Len;

            // Construct final array totalBytes on which to compute the checksum
            byte[] pseudoBytes = (byte[])pseudo;
            byte[] udpBytes = (byte[])this.Udp;
            int totalBytesLength = pseudoBytes.Length + udpBytes.Length + payload.Length;
            if ((totalBytesLength % 2) != 0)
                totalBytesLength++;
            byte[] totalBytes = new byte[totalBytesLength];
            pseudoBytes.CopyTo(totalBytes, 0);
            udpBytes.CopyTo(totalBytes, pseudoBytes.Length);
            payload.CopyTo(totalBytes, pseudoBytes.Length + udpBytes.Length);            

            // wChecksum has to be on the stack
            // If we use the member variable, it will change
            // the IP header when the checksum is being evaluated
            // and result in an invalid checksum
            Udp.Checksum = 0;
            ushort tempChecksum = 0;
            ushort prevChecksum = 0;
            ushort Overflow = 0;

            for(int i = 0; i < totalBytes.Length; i += 2)
            {
                ushort s = (ushort)BitConverter.ToInt16(totalBytes, i);
                tempChecksum += NetConstants.HTONS(s);

                if(tempChecksum < prevChecksum)
                    Overflow++;

                prevChecksum = tempChecksum;
            }

            tempChecksum = (ushort)(~tempChecksum);
            tempChecksum = (ushort)(tempChecksum - Overflow);
            if (tempChecksum == 0)
                tempChecksum = 0xFFFF;
            Udp.Checksum = NetConstants.HTONS(tempChecksum);
        }

    }
            
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class ArpPacket : WireData
    {
        public EnetHdr              Enet = new EnetHdr();
        public ushort               Hrd;                        // hardware address space
        public ushort               Pro;                        // protocol address space (ENET_TYPE_IP)
        public byte                 Hln;                        // hardware address length (6)
        public byte                 Pln;                        // protocol address length (4)
        public ushort               Op;                         // opcode
        public EnetAddr             eaSender = new EnetAddr();  // sender's hardware address
        public IpAddr               ipaSender = new IpAddr();   // sender's protocol address
        public EnetAddr             eaTarget = new EnetAddr();  // target's hardware address
        public IpAddr               ipaTarget = new IpAddr();   // target's protocol address

        public void Set(EnetAddr eaSelf, IpAddr ipSelf, IpAddr ipTarget)
        {
            Enet.eaDst = EnetAddr.Broadcast();
            Enet.eaSrc = eaSelf;
            Enet.Type = NetConstants.ENET_TYPE_ARP;
            Hrd = NetConstants.ARP_HWTYPE_ENET;
            Pro = NetConstants.ENET_TYPE_IP;
            Hln = 6;
            Pln = 4;
            Op = NetConstants.ARP_OP_REQUEST;
            eaSender = eaSelf;
            ipaSender = ipSelf;
            eaTarget = EnetAddr.Zero();
            ipaTarget = ipTarget;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Xbox360.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.lfm.xbox360Internal;
using live.server;

namespace live.lfm
{
    public sealed class Xbox360 : IDisposable
    {
        private bool _shutdownDone = false;
        private bool _disposed = false;
        private bool _supressDispose = false;
        private LfmState _lfmState = new LfmState();

        public Xbox360Client Client
        {
            get
            {
                if (_disposed)
                {
                    throw new ObjectDisposedException("This instance has already been disposed.");
                }
                return _lfmState.Client;
            }
        }

        public XblUser ActiveUser
        {
            get
            {
                return _lfmState.ActiveUser;
            }
            set
            {
                XblUser newActiveUser = value;
                if (_lfmState.Client.LoggedOnUsers.IndexOf(newActiveUser) == -1)
                {
                    throw new Exception("User " + newActiveUser.ToString() + 
                        " not found in logged on users list.");
                }
                _lfmState.ActiveUser = value;
            }
        }

        public SignUpInternal SignUp;
        public LiveInternal Live;
        public MarketplaceScene Marketplace;

        public Xbox360() :
            this(new Xbox360Client())
        {
        }

        public Xbox360(Xbox360Client client)
        {
            _lfmState.Client = client;
            //_lfmState.Client.SchemaVersion = live.protocol.WireData.MakeSchemaVersion(3, 0);
            SignUp = new SignUpInternal(_lfmState);
            Live = new LiveInternal(_lfmState);
            Marketplace = new MarketplaceScene(_lfmState);
        }

        ~Xbox360()
        {
            System.Diagnostics.Debug.WriteLineIf(!_disposed && !_supressDispose, 
                "Xbox360:~Xbox360(): Finalizer called without objecting being disposed." +
                "  This may leak Xbox360Client resources.");
            Dispose(false);
        }

        /// <summary>
        /// Supressess disposal of this instance.  After calling this method, subsequent calls to this instance's
        /// IDisposable.Dispose() method will not execute and will return immediately without error.  Primarily used
        /// by instances of this class that are intended to server as proxies for first instances.
        /// </summary>
        public void SupressDispose()
        {
            _supressDispose = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed && !_supressDispose)
            {
                if (disposing)
                {
                    if (_lfmState != null && _lfmState.Client != null)
                    {
                        ShutdownConsole();
                        _lfmState.Client.Dispose();
                    }
                }
                _disposed = true;
            }
        }

        public static void CreateMachineAccount()
        {
        }

        public void ShutdownConsole()
        {
            if (!_shutdownDone)
            {
                while (_lfmState.Client.LoggedOnUsers.Count > 0)
                {
                    Live.Logout(_lfmState.Client.LoggedOnUsers[0]);
                }
                _lfmState.Client.Shutdown();
                _shutdownDone = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\PurchaseScene.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.server;
using live.protocol;
using ServerTestFramework;

namespace live.lfm.xbox360Internal.HUD
{
    public class PurchaseOfferWithCCScene : BasicScene
    {
        private ulong  _offerId;

        public PurchaseOfferWithCCScene(LfmState lfmState, SceneBase previousScene, ulong offer)
            : base(lfmState, previousScene)
        {
            _offerId = offer;
        }

        internal new PurchaseOfferWithCCScene Activate()
        {

            //TODO: Billing.XeContentDetails(_client, _user);


            return this;
        }

        public void Confirm()
        {
            string paymentId;

            PaymentInstrumentBase pib = _user.Settings.BillingInfo.GetActivePaymentInstrument();
            if (pib == null)
            {
                throw new Exception(" Points purchase requires an active payment instrument.\r\n" +
                        "Use Settings.BillingInfo.SetActivePaymentInstrument() to specify one.");
            }
            paymentId = pib.PaymentInstrumentId;

            int retires = 3;

            do
            {

                try
                {
                    Billing.XeOfferPurchase(_client, _user, _offerId, PaymentTypeEnum.CreditCard, paymentId);                   
                    break;
                }
                catch (Exception e)
                {                    
                    Global.RO.Error(e.Message + "\r\n" + e.StackTrace);
                    if (retires < 1) throw e;
                    Global.RO.Warn("Sleep 60 seconds before retry");
                    System.Threading.Thread.Sleep(60 * 1000);
                    retires--;
                }
            } while (true);            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\AddMicrosoftPointsScene.cs ===
using System;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal.HUD
{
    /// <summary>
    ///     X) Add Microsoft Points
    /// 	    [HUD.AddMicrosoftPointsScene]
    ///         /xbos/XeContentEnumerate2.ashx [cached]
    ///
    /// 	    Redeem Code
    ///         "Xbox Live 500 MS Pts $6.25"
    ///         "Xbox Live 1000 MS Pts $12.50"
    ///         "Xbox Live 2000 MS Pts $25.00"
    ///         "Xbox Live 5000 MS Pts $65.50"
    ///
    ///         [If a purchaseable points offer is selected, cached for HUD.AddMicrosoftPointsScene:]
    ///             [HUD.PointsPurchaseScene]
    ///             /xuacs/XeGetPaymentInstruments.ashx
    ///
    ///             Confirm Purchase
    ///             Change Payment Option
    ///             Cancel [to HUD.AddMicrosoftPointsScene]
    /// </summary>
    public class AddMicrosoftPointsScene : BasicScene
    {
        public AddMicrosoftPointsScene(LfmState lfmState, BasicScene prevScene)
            : base(lfmState, prevScene)
        {
        }

        //TODO: Model Add Microsoft Points scene
        internal override BasicScene Activate()
        {
            return base.Activate();
        }

        /// <summary>
        /// Creates a prepaid points redemption scene.
        /// </summary>
        /// <param name="offer">A valid prepaid points offer.</param>
        /// <returns>A Microsoft Points redemption scene.</returns>
        public HUD.RedeemCodeScene RedeemGameToken(string prepaidCode)
        {
            return (HUD.RedeemCodeScene)new RedeemCodeScene(_lfmState, this, prepaidCode).Activate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\DownloadedContentItemScene.cs ===
using System;

using live.client;
using live.common;
using live.server;

namespace live.lfm.xbox360Internal.HUD
{
    public class DownloadedContentItemScene : BasicScene
    {
        private ContentHistoryItem _historyItem;
        private ContentItem _contentItem;

        public DownloadedContentItemScene(LfmState lfmState, BasicScene prevScene, ContentHistoryItem historyItem)
            : base(lfmState, prevScene)
        {
            _historyItem = historyItem;
        }

        /// <summary>
        /// /xuacs/XeGetPointsBalance.ashx
        /// /xbos/XeGetTitleDetails.ashx
        /// /xbos/XeContentDetails.ashx
        /// /stfd/resolvename.ashx
        /// /stfd/readfile.ashx
        /// </summary>
        internal override BasicScene Activate()
        {
            UACS.XeGetPointsBalance(_client, _user);

            // 2007/08/05 12:32:25.872|XeGetTitleDetails|0|16118140998061463543|9030c44aba1b8|584107d8|103|1|6
            TitleDetails titleDetails = Billing.XeGetTitleDetails(_client, _user, _historyItem.TitleId);

            // 2007/08/05 12:32:19.185|XeContentDetails|0|16118140998061463543|9030c44aba1b8|103|1|0|6|63
            // offerId: 0
            // tier: 6
            // rating: 63
            //TODO:  Rating system logic?
            EnumeratedContentItems contentItems = Billing.XeContentDetails(_client, _user, _historyItem.OfferID, 
                PaymentTypeEnum.Any, 63);
            _contentItem = contentItems.Infos[0];

            //TODO: /stfd/resolvename.ashx
            //TODO: /stfd/readfile.ashx
            return this;
        }

        /// <summary>
        /// For each download attempt:
        ///     /xbos/XeContentReferral.ashx
        ///     http://10.198.102.114:3074/content/584107d8/b7c618dc4d87e89b8e8e76af6dc9b050603afe9d.xcp
        /// After successful download:
        ///     /xbos/XeContentRefreshLicense.ashx
        ///     /xbos/XeContentHistoryEnumerate.ashx
        /// </summary>
        public void DownloadAgain()
        {
            // For each download attempt:

            // 2007/08/05 12:45:21.606|XeContentReferral|fa00000000000128|9030c44aba1b8|fa00000000000128|b7c618dc4d87e89b8e8e76af6dc9b050603afe9d|5a62c1|48a|1|0|16118140998061463543
            Billing.XeContentReferral(_client, _user, _contentItem);

            //TODO: /content/4d5307d1/a1655a2c08965395a5640b61e2120c0f0d7538f9.xcp (skip?)

            // After successful download:

            // 2007/08/05 12:45:31.294|XeContentRefreshLicense|0|16118140998061463543|9030c44aba1b8|fa00000000000128
            //TODO: Billing.XeContentRefreshLicense(client, user, _contentItem);

            //2007/08/05 12:45:32.637|XeContentHistoryEnumerate|0|16118140998061463543|9030c44aba1b8|103|1|158434|0|0|1000|1|1
            ContentHistoryEnumerateFilter historyFilter = new ContentHistoryEnumerateFilter();
            historyFilter.OfferType = OfferingTypeEnum.Content | OfferingTypeEnum.GameDemo |
                OfferingTypeEnum.GameTrailer | OfferingTypeEnum.Theme | OfferingTypeEnum.FullGame |
                OfferingTypeEnum.Tile | OfferingTypeEnum.Tile | OfferingTypeEnum.Arcade |
                OfferingTypeEnum.Video | OfferingTypeEnum.SyncCastWMIS;
            historyFilter.MaxResults = 1000;
            Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);
        }

        public HUD.AddMicrosoftPointsScene AddMicrosoftPoints()
        {
            HUD.AddMicrosoftPointsScene scene = new HUD.AddMicrosoftPointsScene(_lfmState, this);
            return (HUD.AddMicrosoftPointsScene)scene.Activate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\EMSContentItemPurchaseScene.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.lfm.xbox360Internal;
using live.common;
using live.server;
using live.protocol;

namespace live.lfm.xbox360Internal.HUD
{
    public class EMSContentItemPurchaseScene : ContentItemPurchaseScene
    {
        OfferItem _offerItem;

        public EMSContentItemPurchaseScene(LfmState lfmState, BasicScene prevScene, OfferItem offerItem)
            : base(lfmState, prevScene, null)
        {
            _offerItem = offerItem;
        }

        internal override BasicScene Activate()
        {
            _currentBalance = UACS.XeGetPointsBalance(_client, _user);
            //TODO: /stfd/resolvename.ashx
            //TODO: /stfd/readfile.ashx
            return this;
        }

        /// <summary>
        /// First: Purchase
        /// "/xbos/PurchaseOffers.ashx"
        /// "/xbos/XeContentHistoryEnumerate.ashx"
        /// Second On each download attempt
        /// "/xsig/AcquireMediaLicenses.ashx"
        /// "/xbos/history.asmx/Query"
        /// "/xuacs/XeGetPointsBalance.ashx"
        ///    If there is subtitles:
        /// "/xbos/FindMediaInstanceUrls.ashx"
        /// "/xbos/FindMediaInstanceUrls.ashx"
        /// "/video/contentroot/253dd7db-4762-41fb-b0a6-5459c9b
        /// </summary>
        public override void ConfirmDownload()
        {

            if (!(_offerItem is PurchaseHistoryItem))
            {

                OfferMediaTypeExpectedPrice [] omp = new OfferMediaTypeExpectedPrice[1];
                omp[0] = new OfferMediaTypeExpectedPrice();
                omp[0].offerId = _offerItem.OfferId;
                omp[0].expectedPriceWhole = (uint)_offerItem.PointsPrice;
                omp[0].expectedPriceFractional = 0;
                omp[0].mediaTypeId = 2;

                Billing.XePurchaseMediaOffers(_client, _user, omp, (uint)PaymentTypeEnum.Points, "", "", 1);
            }

            //Download
            MediaInstanceIdOfferIdPair mioid = new MediaInstanceIdOfferIdPair();
            mioid.oid = _offerItem.OfferId;
            List<Guid> mediaInstances = new List<Guid>();

            live.common.next.PurchaseHistoryFilter filter = new live.common.next.PurchaseHistoryFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = "en-US";
            filter.Store = 1;
            filter.PageSize = 10;
            filter.PageNum = 1;
            filter.DetailView = 5;
            filter.MediaTypes = new List<int>(2);
            filter.MediaTypes.Add(2);
            filter.MediaTypes.Add(8);
            filter.OrderBy = 0; 
            filter.OrderDirection = 1;
            List<KeyValuePair<string, string>> filterlist = filter.ToList();

            foreach (MediaInstanceItem mii in _offerItem.MediaInstances)
            {
                if (mii.RequiresLicense)
                {                    
                    mioid.miid = mii.MediaInstanceId;
                    Signature.AcquireMediaLicenses(_client, _user, new MediaInstanceIdOfferIdPair[] { mioid });
                    
                    live.server.next.WebBilling.GetPurchaseHistory(_client, _user, filterlist);
                    
                    Signature.AcknowledgeLicensesDelivery(_client, _user, new MediaInstanceIdOfferIdPair[] { mioid });
                }
                mediaInstances.Add(mii.MediaInstanceId);
                Billing.FindMediaInstanceUrls(_client, new Guid[] { mii.MediaInstanceId });
            }

            _currentBalance = UACS.XeGetPointsBalance(_client, _user);
           

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\ContentItemPurchaseScene.cs ===
using System;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal.HUD
{
    public class ContentItemPurchaseScene : BasicScene
    {
        internal protected ContentItem _contentItem;

        internal protected uint _currentBalance;
        public uint CurrentBalance
        {
            get
            {
                return _currentBalance;
            }
        }

        private uint _pointsCost = 0;
        public uint PointsCost
        {
            get
            {
                return _pointsCost;
            }
        }

        public ContentItemPurchaseScene(LfmState lfmState, BasicScene prevScene, ContentItem contentItem)
            : base(lfmState, prevScene)
        {
            _contentItem = contentItem;
            //_contentItem.prices[0].paymentType == PaymentTypeEnum.
        }

        /// <summary>
        /// /xuacs/XeGetPointsBalance.ashx
        /// /xbos/XeGetTitleDetails.ashx
        /// /xbos/XeContentDetails.ashx
        /// /stfd/resolvename.ashx
        /// /stfd/readfile.ashx
        /// </summary>
        internal override BasicScene Activate()
        {
            _currentBalance = UACS.XeGetPointsBalance(_client, _user);
            TitleDetails titleDetails = Billing.XeGetTitleDetails(_client, _user, _contentItem.titleID);
            Billing.XeContentDetails(_client, _user, _contentItem.offerID, 
                PaymentTypeEnum.Any, 63);
            //TODO: /stfd/resolvename.ashx
            //TODO: /stfd/readfile.ashx
            return this;
        }

        /// <summary>
        /// First:
        ///     /xbos/XeOfferPurchase.ashx
        ///     /xbos/XeContentHistoryEnumerate.ashx
        ///     /xuacs/XeGetPointsBalance.ashx
        /// For each download attempt:
        ///     /xbos/XeContentReferral.ashx
        ///     /content/4d5307d1/a1655a2c08965395a5640b61e2120c0f0d7538f9.xcp
        /// After successful download:
        ///     /xbos/XeContentRefreshLicense.ashx
        ///     /xbos/XeContentHistoryEnumerate.ashx
        /// </summary>
        public virtual void ConfirmDownload()
        {
            // First:
            Billing.XeOfferPurchase(_client, _user, _contentItem.offerID, PaymentTypeEnum.Points, null);

            ContentHistoryEnumerateFilter historyFilter = new ContentHistoryEnumerateFilter();
            EnumeratedContentHistoryItems items = Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);

            UACS.XeGetPointsBalance(_client, _user);

            // For each download attempt:
            Billing.XeContentReferral(_client, _user, _contentItem);

            //TODO: /content/4d5307d1/a1655a2c08965395a5640b61e2120c0f0d7538f9.xcp (skip?)
            // WRN[XOnline]: Request submitted, URL = "http://10.198.102.114:3074/content/584107d8/b7c618dc4d87e89b8e8e76af6dc9b050603afe9d.xcp".

            // After successful download:
            //TODO: Billing.XeContentRefreshLicense(_client, _user, _contentItem);
            items = Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);
        }

        /// <summary>
        /// Creates a generic code redemption scene.
        /// </summary>
        /// <param name="offer">A valid prepaid code.</param>
        /// <returns>A code redemption scene.</returns>
        public HUD.RedeemCodeScene RedeemCode(string prepaidCode)
        {
            return (HUD.RedeemCodeScene)new RedeemCodeScene(_lfmState, this, prepaidCode).Activate();
        }

        public HUD.AddMicrosoftPointsScene AddMicrosoftPoints()
        {
            HUD.AddMicrosoftPointsScene scene = new HUD.AddMicrosoftPointsScene(_lfmState, this);
            return (HUD.AddMicrosoftPointsScene)scene.Activate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\WireData.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.ComponentModel;
using System.Runtime.InteropServices;
using xonline.common.service;
using xonline.core.wiredata;

namespace live.common.kdc
{

    /// <summary>
    /// Extend this if you want to include a base class's members in the Wiredata serialization. This will
    /// include all public instance variables in base classes, up through the chain to the base Wiredata class.
    /// Fields in base classes will be serialized first.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class WireDataIncludeBase : WireData
    {
        // Remove the BindingFlags.DeclaredOnly so that we include inherited members as well
        public WireDataIncludeBase()
            : base(BindingFlags.Public | BindingFlags.Instance)
        {
        }
    }


    /// <summary>
    /// Provides easy serialization of  structured data into byte streams.
    /// </summary>
    /// <remarks>
    /// The <c>WireData</c> class provides a method of serializing class data into byte streams.  This is especially
    /// useful transfering data over the network.  Using <c>WireData</c> is very simple.  First create a class that derives
    /// from <c>WireData</c>.  Then add public member variables that specify the format of the data that this class targets in
    /// the order it appears in the stream.  For many cases this is enough to start serializing and deserializing with
    /// your <c>WireData</c> class.
    /// <list type="bullet">
    /// <item>
    /// <term>Serialization to a byte[]</term>
    /// <description>Fill out your structure and cast your class to a <c>byte[]</c>.  The resulting <c>byte[]</c> will be your serialization data.  Alternatively you can call WriteStream and pass a <c>Stream</c> for a similar effect.</description>
    /// </item>
    /// <item>
    /// <term>Deserialization from a byte[] or a Stream</term>
    /// <description>Construct a new instance of your class and call ReadStream on your <c>byte[]</c> or <c>Stream</c>.  Your instance will contain the data that was present in the <c>Stream</c>.</description>
    /// </item>
    /// </list>
    ///
    /// WireData derived classes are made up of different data types.  The valid data types for serialization are as follows:
    /// <list type="bullet">
    /// <item>
    /// <term>Supported native types</term>
    /// <description>The types that may make up WireData types are: <c>bool</c>, <c>byte</c>, <c>char</c>, <c>decimal</c>, <c>double</c>, <c>short</c>, <c>int</c>, <c>long</c>, <c>sbyte</c>, <c>float</c>, <c>ushort</c>, <c>uint</c>, <c>ulong</c>, <c>DateTime</c>, <c>string</c>, arrays of any of these types and other <c>WireData</c> derived classes.  <c>DateTime</c> is supported like a native type and is serialized by calling its ToFileTime.</description>
    /// </item>
    /// <item>
    /// <term>Embedded WireData classes</term>
    /// <description><c>WireData</c> classes can also contain other embedded <c>WireData</c> classes as members.</description>
    /// </item>
    /// <item>
    /// <term>Arrays</term>
    /// <description><c>WireData</c> supports arrays of any of the other types of supported data types.  To use an array you must specifiy how many items are in the array.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and "Arrays" section below for details on how to use arrays.</description>
    /// </item>
    /// <item>
    /// <term>Strings</term>
    /// <description>Strings are treated almost identically to arrays.  To use a string you must specifiy how many characters are in the string.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and the "Arrays" section below for more information.  They are UTF8 encoded for serialization.</description>
    /// </item>
    /// </list>
    ///
    /// <b>Arrays</b><br/>
    /// <para>Since Arrays are not always the same size there are special considerations that are nescessary.  For example, a deserializer needs to know how many elements to allocate for the array and how much data to pull in.  A seriailzer needs to know where to serialize the element count for a variable sized array.  For these and other reasons, a <see cref="ServerTestFramework.WireInfoAttribute"/> needs to be specified any time an array is declared.</para>
    /// The size needs to be specified in one of three ways:
    /// <list type="number">
    /// <item>
    /// <term>ArraySize</term>
    /// <description>Specify an <c>ArraySize</c> when the array always has a constant number of elements.  If there are 4 <c>int</c>s (comprising 16 bytes) set <c>SizeParam = 4</c>.  On serialization if the array doesn't have enough elements the stream will be zero-padded.</description>
    /// </item>
    /// <item>
    /// <term>SizeParam</term>
    /// <description>For variable-sized arrays you can tell <c>WireData</c> to look at a different integral (such as <c>int</c>) field to get and set the number of array elements from and to.  Set <c>SizeParam</c> to be the name of the field that represents the element count.  If you set this up then when serializing/deserializing, <c>WireData</c> will take care of setting the linked count so you do not have to.  See the example below for more information.</description>
    /// </item>
    /// <item>
    /// <term>&lt;field&gt;Len</term>
    /// <description>For coveniance you don't usually have to specify the attribute for variable sized arrays at all.  Just take the field that you want to link as if you were using <c>SizeParam</c> above and name it the same as the array but append "Len" to the end.  See the example below for more information.</description>
    /// </item>
    /// </list>
    /// <para><b>Overloaded ReadStream/WriteStream</b></para>
    /// <para>There are situations where the above features don't make up enough functionality to match your protocol.  In these cases you will need to override <c>ReadStream</c> and <c>WriteStream</c> in your <c>WireData</c> derived class.  See <see cref="ServerTestFramework.WireData.ReadStream(Stream)"/> for more information.</para>
    /// </remarks>
    ///
    /// <example>
    /// This sample shows how to call use the main features of WireData.
    /// <code>
    ///    public class ExampleWireData : WireData
    ///    {
    ///        public byte JustAByte = 0;
    ///        [WireInfo(ArraySize=10)] public string ConstString;
    ///        public int SizeForVarString;
    ///        [WireInfo(SizeParam="SizeForVarString")] public string VarString;
    ///        public uint VarByteArrayLen;
    ///        public int[] VarByteArray;
    ///
    ///        [STAThread]
    ///        static void Main(string[] args)
    ///        {
    ///            // Create and fill out the ExampleWireData structure
    ///            ExampleWireData wd1 = new ExampleWireData();
    ///            wd1.JustAByte = 4;
    ///            wd1.ConstString = "hello";
    ///            wd1.VarString = "goodbye";
    ///            wd1.VarByteArray = new int[3] {5, 6, 7};
    ///
    ///            // Serialize ExampleWireData to byte array
    ///            byte[] data = (byte[])wd1;
    ///            Debug.Assert(data.Length == 38);
    ///
    ///            // Create, deserialize and verify that it was converted correctly
    ///            ExampleWireData wd2 = new ExampleWireData();
    ///            wd2.ReadBytes(data);
    ///            Debug.Assert(wd2.JustAByte == 4);
    ///            Debug.Assert(wd2.ConstString == "hello");
    ///            Debug.Assert(wd2.VarString == "goodbye");
    ///            Debug.Assert(wd2.VarByteArray[0] == 5);
    ///            Debug.Assert(wd2.VarByteArray[1] == 6);
    ///            Debug.Assert(wd2.VarByteArray[2] == 7);
    ///        }
    ///    }
    /// </code>
    /// </example>
    ///
    [StructLayout(LayoutKind.Sequential)]
    public class WireData
    {
        [WireInfo(Serialize = false)]
        protected static UTF8Encoding utf8 = new UTF8Encoding();
        [WireInfo(Serialize = false)]
        protected static UnicodeEncoding unicodeEnc = new UnicodeEncoding();

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // Fuzzing flag. If true, the data will be fuzzed if it has the [FuzzData()]
        // attribute. If false, all fuzzing will be skipped.
        [WireInfo(Serialize = false)]
        public static bool Fuzz = false;

        // This is the version number of the latest schema. Must be the same as
        // XLIVE_SCHEMA_VERSION in xonline.xd in the client tree.
        [WireInfo(Serialize = false)]
        private static readonly uint CurrentSchemaVersion = MakeSchemaVersion(6, 0);

        // Version of the schema to use for serializing/deserializing this object.
        [WireInfo(Serialize = false)]
        public uint SchemaVersion = CurrentSchemaVersion;

        /// <summary>
        /// If set, you will need to manually provide array sizes when writing WireDatas
        /// </summary>
        [WireInfo(Serialize = false)]
        public bool ManualArraySize = false;

        /// <summary>
        /// Setting this to true will dump WireData info as it's being written to a stream
        /// </summary>
        [WireInfo(Serialize = false)]
        public static bool DumpDiagnosticInfo = false;

        /// <summary>
        /// If set, overrides NullTerminated attribute. That is things that are supposed to be
        ///  null terminated, won't be.
        /// </summary>
        [WireInfo(Serialize = false)]
        public bool NullTermOverRide = false;

        private class SizeParamIndex
        {
            public int[] forward = null;
            public int[] reverse = null;

            public SizeParamIndex(int size)
            {
                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        [WireInfo(Serialize = false)]
        private static Hashtable sizeParamIndicies = new Hashtable();
        [WireInfo(Serialize = false)]
        private static Hashtable fieldCache = new Hashtable();

        [WireInfo(Serialize = false)]
        protected static BindingFlags defaultBindingFlags = (BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        public WireData()
            : this(defaultBindingFlags)
        {
        }

        protected static void InitFieldCache(Type type)
        {
            InitFieldCache(type, defaultBindingFlags);
        }

        protected static void InitFieldCache(Type type, BindingFlags bindingFlags)
        {
            // Grab the lock to make sure we get this done in the right order.  We would like to do a early out for
            // this in the common case but because of some .NET out of order processing magic, execution might not occur in
            // the expected order.
            // We lock on the hashtable, which is a more restrictive lock than we might be able to use (GetType())
            // might be better but then we have to lock sizeParamIndicies at exactly the right places, which is even
            // more confusing.
            lock (sizeParamIndicies)
            {
                // Check to see if this WireData has already been initialized.
                if (sizeParamIndicies[type] != null)
                    return;

                // Index this WireData derivative.
                // If not DeclaredOnly (which means we are including inherited members), then we
                // need to sort by the hierarchy.  Within a given class, the order of fields
                // is correct, but the order of classes is reversed.
                FieldCache fc;
                if ((bindingFlags & BindingFlags.DeclaredOnly) == 0)
                {
                    fc = new FieldCache(type.GetFields(bindingFlags), true);
                    fc.AddForcedFields(type.GetFields(BindingFlags.Instance | BindingFlags.Public |
                        BindingFlags.NonPublic), true);
                }
                else
                {
                    fc = new FieldCache(type.GetFields(bindingFlags), false);
                    fc.AddForcedFields(type.GetFields(BindingFlags.Instance | BindingFlags.Public |
                        BindingFlags.NonPublic | BindingFlags.DeclaredOnly), false);
                }
                SizeParamIndex index = new SizeParamIndex(fc.Fields.Length);

                for (int i = 0; i < fc.Fields.Length; i++)
                {
                    FieldInfo field = fc.Fields[i];
                    WireInfoAttribute wireInfo = fc.WireInfo[i];

                    // ignore if we are not serializing or we were forced to serialize
                    if (!wireInfo.Serialize || wireInfo.ForceSerialize)
                        continue; // ignore this field

                    if (field.FieldType.IsArray || field.FieldType == typeof(string))
                    {
                        if (wireInfo.ArraySize == -1)
                        {
                            if (!wireInfo.WriteOnlyVarLenString)
                            {
                                string sizeParamName = fc.WireInfo[i].SizeParam;
                                if (sizeParamName == null)
                                    sizeParamName = field.Name + "Len";

                                int j;
                                for (j = 0; j < i; j++)
                                    if (fc.Fields[j].Name == sizeParamName)
                                        break;

                                if (j == i)
                                    throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");

                                index.forward[i] = j;
                                index.reverse[j] = i;
                            }
                        }
                        else
                        {
                            if (wireInfo.SizeParam != null)
                                throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                        }
                    }
                }
                sizeParamIndicies.Add(type, index);
                fieldCache.Add(type, fc);
            }
        }

        /// <summary>
        /// Gets the static entry in the WireData field cache that
        /// corresponds to the type passed in. If one does not exist,
        /// InitFieldCache will create one.
        /// </summary>
        /// <param name="type">Type to get the field cache line for.</param>
        /// <returns>The FieldCache object for the given type, or null if one cannot be constructed.</returns>
        public static WireData.FieldCache GetFieldCacheLine(Type type)
        {
            try
            {
                if (!fieldCache.Contains(type))
                {
                    WireData.InitFieldCache(type);
                }
            }
            catch (Exception ex)
            {
                Logging.WriteLine(ex.Message, "ERROR");
                return null;
            }
            return (WireData.FieldCache)fieldCache[type];
        }

        public WireData(BindingFlags bindingFlags)
        {
            InitFieldCache(this.GetType(), bindingFlags);
        }

        /// <summary>
        /// This serializes a <c>WireData</c> class to a byte[].
        /// </summary>
        public static explicit operator byte[](WireData wiredata)
        {
            if (wiredata == null)
                return null;
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);
            return stream.ToArray();
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        public WireData ReadBytes(byte[] bytes)
        {
            if (bytes == null)
                return null;
            return ReadStream(new BinaryReader(new MemoryStream(bytes)));
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        /// <param name="bytes">Byte array of data, may be larger than necessary</param>
        /// <param name="bytesSize">The number of bytes of data to use. Must be less than or equal to bytes.Length.</param>
        /// <returns></returns>
        public WireData ReadBytes(byte[] bytes, int bytesSize)
        {
            return ReadStream(new BinaryReader(new MemoryStream(bytes, 0, bytesSize)));
        }

        #region Reader
        /// <summary>
        /// ReadStream deserializes a stream to fill this <c>WireData</c> class.
        /// </summary>
        /// <param name="stream">The source stream to deserialize from.</param>
        /// <returns>Returns a copy of itself.  This is just a convenience for constructing and deserializing at once.</returns>
        /// <example>
        /// <b>Overloaded ReadStream/WriteStream</b>
        /// <para>When implementing a complex protocol you may run into situations where the built in functionality is not sufficient.  An common example of this is when a header precedes a section that's structure depends on a value in the header.  For example, a IP packet has a byte 24 bytes in which if it equals 17 then the rest of the packet after the header should be interpreted as UDP and if it's 6, TCP.  This affects the following structure of the packet.</para>
        /// <para>The example below is a trivialized version of making TCP/UDP/IP packets.  For simplicity I am leaving out portions of the protocol and not actually handling the body of the packets.  This implementation is completely self-contained.  All you have to do is create a <c>Packet</c> object and call ReadStream on it to pull in a UDP or TCP packet.</para>
        /// <code>
        ///    public class Packet : WireData
        ///    {
        ///        public IPHeader IPHeader;
        ///        public ProtocolHeader ProtocolHeader;
        ///
        ///        public override WireData ReadStream(Stream stream)
        ///        {
        ///            IPHeader.ReadStream(stream);
        ///            Debug.Assert(IPHeader.Type == 0x11 || IPHeader.Type == 0x6);
        ///            if (IPHeader.Type == 0x11)
        ///                ProtocolHeader = (ProtocolHeader)new UDPHeader().ReadStream(stream);
        ///            else
        ///                ProtocolHeader = (ProtocolHeader)new TCPHeader().ReadStream(stream);
        ///
        ///            return this;
        ///        }
        ///
        ///        public override void WriteStream(Stream stream)
        ///        {
        ///            if (ProtocolHeader is UDPHeader)
        ///                IPHeader.Type = 0x11;
        ///            else
        ///                IPHeader.Type = 0x6;
        ///
        ///            IPHeader.WriteStream(stream);
        ///            ProtocolHeader.WriteStream(stream);
        ///        }
        ///    }
        ///
        ///    public class IPHeader : WireData
        ///    {
        ///        public byte Version;
        ///        public byte TOS;
        ///        public ushort TotalSize;
        ///        [WireInfo(ArraySize=5)] public byte[] Other1;
        ///        public byte Type;
        ///        [WireInfo(ArraySize=10)] public byte[] Other2;
        ///    }
        ///
        ///    public class ProtocolHeader : WireData
        ///    {
        ///    }
        ///
        ///    public class UDPHeader : ProtocolHeader
        ///    {
        ///        public short SourcePort;
        ///        public short DestPort;
        ///        public short DataLen;
        ///        public short Checksum;
        ///        [WireInfo(ArraySize=0)] public byte[] Data;
        ///    }
        ///
        ///    public class TCPHeader : ProtocolHeader
        ///    {
        ///        public short SourcePort;
        ///        public short DestPort;
        ///        public uint SequenceNumber;
        ///        [WireInfo(ArraySize=12)] public byte[] Other2;
        ///        [WireInfo(ArraySize=0)] public byte[] Data;
        ///    }
        ///    </code>
        /// </example>
        public WireData ReadStream(Stream stream)
        // DO NOT MAKE THIS VIRTUAL! If you need to override it, override ReadStream(BinaryReader) instead - reljam
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo = fc.WireInfo[i];

                if (!wireInfo.Serialize ||
                        this.SchemaVersion < wireInfo.MinSchemaVersionVal ||
                        this.SchemaVersion > wireInfo.MaxSchemaVersionVal)
                    continue;

                object o = null;
                // Handle arrays
                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    int size = wireInfo.ArraySize;
                    if (size == -1)
                    {
                        try
                        {
                            size = Convert.ToInt32(fc.Fields[index.forward[i]].GetValue(this));
                        }
                        catch (InvalidCastException e)
                        {
                            throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                        }
                    }

                    if (field.FieldType == typeof(string))
                    {
                        byte[] rawBytes = binaryReader.ReadBytes(size);
                        string s;
                        if (wireInfo.UnicodeEncoded)
                        {
                            s = unicodeEnc.GetString(rawBytes);
                        }
                        else
                        {
                            s = utf8.GetString(rawBytes);
                        }
                        int termPos = s.IndexOf((char)0);
                        if (termPos > 0)
                            o = s.Substring(0, s.IndexOf((char)0));
                        else if (termPos == -1)
                            o = s;
                        else
                            o = "";
                    }
                    else
                    {
                        o = field.GetValue(this);
                        if (o == null)
                        {
                            Type[] types = { typeof(int) };
                            object[] param = { size };
                            o = field.FieldType.GetConstructor(types).Invoke(param);
                            for (int j = 0; j < size; j++)
                                (o as Array).SetValue(ReadValue(binaryReader, field.FieldType.GetElementType(), null), j);
                        }
                        else
                        {
                            // Use type info from the actual data passed in.
                            for (int k = 0; k < (o as Array).Length; ++k)
                            {
                                object val = (o as Array).GetValue(k);
                                (o as Array).SetValue(ReadValue(binaryReader, val.GetType(), val), k);
                            }
                        }
                    }
                }
                else
                    o = ReadValue(binaryReader, field.FieldType, null);
                field.SetValue(this, o);
            }

            return this;
        }
        #endregion

        #region Writer
        /// <summary>
        /// ReadStream serializes this <c>WireData</c> class into a stream.
        /// </summary>
        /// <remarks>
        /// See <see cref="ServerTestFramework.WireData.ReadStream(Stream)"/> for more information and an example.
        /// </remarks>
        /// <param name="stream">The destination stream to serialize to.</param>
        public void WriteStream(Stream stream)
        // DO NOT MAKE THIS VIRTUAL! If you need to override it, override WriteStream(BinaryWriter) instead - reljam
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }

        // NOTE: the use of the xonline.common.service.WireData type here is just to make this match up with the expected function signature for the 
        // WireDataSerializerCache WriteDelegate. Since this is a non-static member function on this class, and we don't actually need the passed data
        // to do the work, there should be no problems with the functionality, but it's a bit ugly.
        public void WriteDelegate(xonline.common.service.WireData ignored, BinaryWriter binaryWriter)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo = fc.WireInfo[i];

                if (!wireInfo.Serialize ||
                            this.SchemaVersion < wireInfo.MinSchemaVersionVal ||
                            this.SchemaVersion > wireInfo.MaxSchemaVersionVal)
                    continue;

                if (WireData.DumpDiagnosticInfo)
                    Console.WriteLine(field.DeclaringType.ToString() + "::" + field.Name);

                object o = field.GetValue(this);

                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    long startPos = binaryWriter.BaseStream.Position;
                    int actualArraySize = 0;

                    if (o != null)
                    {
                        actualArraySize = field.FieldType.IsArray ? (o as Array).Length : (o as string).Length;

                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (wireInfo.ArraySize != -1 && actualArraySize > wireInfo.ArraySize)
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                        }

                        if (field.FieldType.IsArray)
                        {
                            if (wireInfo.UnicodeEncoded &&
                                (actualArraySize > 0) &&
                                ((o as Array).GetValue(0).GetType() == typeof(char)))
                            {
                                char[] sz = (char[])o;
                                byte[] bytes = new byte[sz.Length * 2];
                                unicodeEnc.GetBytes(sz, 0, sz.Length, bytes, 0);
                                binaryWriter.Write(bytes);

                                if ((wireInfo.NullTerminated) && !NullTermOverRide)
                                {
                                    binaryWriter.Write((ushort)0);
                                }
                            }
                            else
                            {
                                for (int j = 0; j < actualArraySize; j++)
                                {
                                    object val = (o as Array).GetValue(j);
                                    WriteValue(binaryWriter, val);
                                }
                            }
                        }
                        else // This is a string
                        {
                            string s = (string)o;

                            if (wireInfo.UnicodeEncoded)
                            {
                                binaryWriter.Write(unicodeEnc.GetBytes(s));
                            }
                            else
                            {
                                binaryWriter.Write(utf8.GetBytes(s));
                            }

                            if ((wireInfo.NullTerminated) && !NullTermOverRide)
                            {
                                if (wireInfo.UnicodeEncoded)
                                {
                                    binaryWriter.Write((ushort)0);
                                }
                                else
                                {
                                    binaryWriter.Write((byte)0);
                                }
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if (wireInfo.ArraySize != -1)
                        {
                            if (field.FieldType.IsArray)
                            {
                                if (field.FieldType.GetElementType().IsSubclassOf(typeof(WireData)))
                                {
                                    ConstructorInfo ci = field.FieldType.GetElementType().GetConstructor(Type.EmptyTypes);
                                    if (ci == null)
                                        throw new Exception("WireData(): for type " + GetType().Name + "::" + field.FieldType.GetElementType().Name + " -- If the number of elements in the array is less than the ArraySize, the class must have a default constructor to use for padding the end of the array with empty structures.");

                                    int size = (ci.Invoke(null) as WireData).Size() * (wireInfo.ArraySize - actualArraySize);

                                    for (int j = 0; j < size; j++)
                                        binaryWriter.Write((byte)0);
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < wireInfo.ArraySize; j++)
                                        WriteValue(binaryWriter, 0, field.FieldType.GetElementType());
                                }
                            }
                            else
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[wireInfo.ArraySize - (binaryWriter.BaseStream.Position - startPos)]);
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            object oT = fc.Fields[index.reverse[i]].GetValue(this);
                            if (oT == null)
                                o = 0;
                            else
                            {
                                // Determining the size of an array is not as simple as string.Length
                                // we need to convert the string to UTF-8 and get the size of that
                                // it would be great if we could cache this....
                                if (oT is Array)
                                    o = ((Array)oT).Length;
                                else
                                {
                                    if (fc.WireInfo[index.reverse[i]].UnicodeEncoded)
                                    {
                                        if ((fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide)
                                            o = unicodeEnc.GetByteCount((string)oT) + 2;
                                        else
                                            o = unicodeEnc.GetByteCount((string)oT);
                                    }
                                    else
                                    {
                                        if ((fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide)
                                            o = utf8.GetByteCount((string)oT) + 1;
                                        else
                                            o = utf8.GetByteCount((string)oT);
                                    }
                                }
                            }
                        }
                    }
                    if (wireInfo.OnlySerializeIfNotEmpty && (int)o == 0)
                        return;

                    WriteValue(binaryWriter, o, field.FieldType);
                }
            }
        }

        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            WireDataWriteDelegate writeDelegate = this.WriteDelegate;
                //WireDataSerializerCache.GetWriteSerializerFor(this.GetType());

            if (this.EncryptionRequired)
            {
                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WireDataEncrypt.Write(new xonline.common.service.WireData(), writeDelegate, binaryWriter);
            }
            else
            {
                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WriteDelegate(new xonline.common.service.WireData(), binaryWriter);
            }
        }
        #endregion

        /// <summary>
        /// Returns the size of this WireData class as currently configured.
        /// </summary>
        /// <remarks>
        /// This is expensive because it requires actually serializing the structure and getting the length of the resulting data.
        /// </remarks>
        public int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);
            return (int)stream.Length;
        }

        #region Read/Write Converters

        private object ReadValue(BinaryReader reader, Type type, object obj)
        {
            if (type == typeof(bool))
                return reader.ReadBoolean();
            else if (type == typeof(byte))
                return reader.ReadByte();
            else if (type == typeof(char))
                return reader.ReadChar();
            else if (type == typeof(decimal))
                return reader.ReadDecimal();
            else if (type == typeof(double))
                return reader.ReadDouble();
            else if (type == typeof(short))
                return reader.ReadInt16();
            else if (type == typeof(int))
                return reader.ReadInt32();
            else if (type == typeof(long))
                return reader.ReadInt64();
            else if (type == typeof(sbyte))
                return reader.ReadSByte();
            else if (type == typeof(float))
                return reader.ReadSingle();
            else if (type == typeof(ushort))
                return reader.ReadUInt16();
            else if (type == typeof(uint))
                return reader.ReadUInt32();
            else if (type == typeof(ulong))
                return reader.ReadUInt64();
            else if (type == typeof(DateTime))
                return DateTime.FromFileTimeUtc(reader.ReadInt64());
            else if (type == typeof(Guid))
                return new Guid(reader.ReadBytes(16));
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if (obj == null)
                {
                    obj = (type.GetConstructor(Type.EmptyTypes).Invoke(null));
                }

                WireData wd = (WireData)obj;
                wd.SchemaVersion = this.SchemaVersion;
                return wd.ReadStream(reader);
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }

        private void WriteValue(BinaryWriter writer, object o)
        {
            BinaryWriteValue(writer, o, null, this);
        }
        private void WriteValue(BinaryWriter writer, object o, Type type)
        {
            BinaryWriteValue(writer, o, type, this);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        public static void BinaryWriteValue(BinaryWriter writer, object o)
        {
            BinaryWriteValue(writer, o, null, null);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        /// <param name="type">The type to write the object as.</param>
        public static void BinaryWriteValue(BinaryWriter writer, object o, Type type)
        {
            BinaryWriteValue(writer, o, type, null);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        /// <param name="type">The type to write the object as.</param>
        /// <param name="wiredata">The WireDate to inherit schema version from.</param>
        private static void BinaryWriteValue(BinaryWriter writer, object o, Type type, WireData wiredata)
        {
            if (type == null)
                type = o.GetType();

            if (type == typeof(bool))
                writer.Write(Convert.ToBoolean(o));
            else if (type == typeof(byte))
                writer.Write(Convert.ToByte(o));
            else if (type == typeof(char))
                writer.Write(Convert.ToChar(o));
            else if (type == typeof(decimal))
                writer.Write(Convert.ToDecimal(o));
            else if (type == typeof(double))
                writer.Write(Convert.ToDouble(o));
            else if (type == typeof(short))
                writer.Write(Convert.ToInt16(o));
            else if (type == typeof(int))
                writer.Write(Convert.ToInt32(o));
            else if (type == typeof(long))
                writer.Write(Convert.ToInt64(o));
            else if (type == typeof(sbyte))
                writer.Write(Convert.ToSByte(o));
            else if (type == typeof(float))
                writer.Write(Convert.ToSingle(o));
            else if (type == typeof(ushort))
                writer.Write(Convert.ToUInt16(o));
            else if (type == typeof(uint))
                writer.Write(Convert.ToUInt32(o));
            else if (type == typeof(ulong))
                writer.Write(Convert.ToUInt64(o));
            else if (type == typeof(DateTime))
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
            else if (type == typeof(Guid))
            {
                Guid g = (Guid)o;
                writer.Write(g.ToByteArray());
            }
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if (o != null)  // If the WireData is null then assume a 0 size and don't output anything
                {
                    WireData wd = (WireData)o;
                    if (wiredata != null)
                    {
                        wd.SchemaVersion = wiredata.SchemaVersion;
                    }
                    wd.WriteStream(writer);
                }
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }

        #endregion

        // Returns the field cache that containes information on all the fields and the
        // related / important attributes.
        public static Hashtable GetFieldCache()
        {
            return fieldCache;
        }

        private bool EncryptionRequired
        {
            get
            {
                object[] attributes = this.GetType().GetCustomAttributes(typeof(WireDataEncryptionAttribute), true);
                if ((attributes == null) || (attributes.Length == 0)) return false;

                WireDataEncryptionAttribute attribute = (WireDataEncryptionAttribute)attributes[0];
                return this.SchemaVersion >= WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion);
            }
        }

        public class FieldCache
        {
            public FieldInfo[] Fields;
            public WireInfoAttribute[] WireInfo;

            public FieldCache(FieldInfo[] fields, bool bSortedByClass)
            {
                if (bSortedByClass)
                {
                    this.Fields = SortFields(fields);
                }
                else
                {
                    this.Fields = fields;
                }

                WireInfo = new WireInfoAttribute[this.Fields.Length];
                for (int i = 0; i < this.Fields.Length; i++)
                {
                    WireInfo[i] = GetWireInfo(this.Fields[i]);
                }

            }

            /// <summary>
            /// Adds the fields that have WireData.ForceSerialize set to true.
            /// </summary>
            /// <param name="fields">The fields to check.</param>
            /// <param name="bSortedByClass">True to sort the fields, false if not.</param>
            public void AddForcedFields(FieldInfo[] fields, bool bSortedByClass)
            {
                // we'll use this to short-circuit if no forced fields found
                bool parity_safety = true;

                LinkedList<FieldInfo> ll_fields =
                    new LinkedList<FieldInfo>(bSortedByClass ? SortFields(fields) : fields);

                LinkedList<WireInfoAttribute> ll_wire_info = new LinkedList<WireInfoAttribute>();

                foreach (FieldInfo node in ll_fields)
                {
                    ll_wire_info.AddLast(GetWireInfo(node));
                }

                LinkedListNode<FieldInfo> field_ptr = ll_fields.First;
                LinkedListNode<WireInfoAttribute> info_ptr = ll_wire_info.First;
                int i = 0;

                while (field_ptr != null)
                {
                    LinkedListNode<FieldInfo> ftemp = field_ptr;
                    LinkedListNode<WireInfoAttribute> itemp = info_ptr;
                    field_ptr = field_ptr.Next;
                    info_ptr = info_ptr.Next;

                    // this is a field picked up in the default way
                    if (i < Fields.Length && ftemp.Value == Fields[i])
                    {
                        ++i;
                    }
                    // if it is forced, we keep it, otherwise, remove it here
                    else if (!itemp.Value.ForceSerialize)
                    {
                        parity_safety = false;
                        ll_fields.Remove(ftemp);
                        ll_wire_info.Remove(itemp);
                    }
                }

                if (i != Fields.Length)
                {
                    throw new Exception("We should have gotten a superset of fields passed in, so how did we " +
                        "not see every field that we already had?");
                }

                if (parity_safety)
                {
                    return;
                }

                // now we have the final list, convert to arrays
                Fields = new FieldInfo[ll_fields.Count];
                ll_fields.CopyTo(Fields, 0);
                WireInfo = new WireInfoAttribute[Fields.Length];
                ll_wire_info.CopyTo(WireInfo, 0);
            }

            private static WireInfoAttribute GetWireInfo(FieldInfo field)
            {
                int len = field.GetCustomAttributes(typeof(WireInfoAttribute), false).Length;
                Debug.Assert(len == 0 || len == 1);
                if (len == 1)
                    return (WireInfoAttribute)field.GetCustomAttributes(typeof(WireInfoAttribute), false)[0];
                else
                    return WireInfoAttribute.None;
            }


            // Sorts the field list by base member class.  This is only a problem when we include
            // fields from base classes as well, which is not a default behavior.  The fields for
            // a given class are sorted correctly, but the order of the classes is reversed.  That
            // is, the first fields are from the child class, followed by its parent, and so on.
            // We need to reverse this, as I would expect the deepest inherited members should be
            // the first ones serialized.
            private FieldInfo[] SortFields(FieldInfo[] fields)
            {
                if (fields == null || fields.Length == 0)
                    return fields;

                ArrayList list = new ArrayList(fields.Length);
                int insertIdx = 0;
                System.Type lastType = fields[fields.Length - 1].DeclaringType;

                // Bump this to the end of the array every time we find a new class
                for (int i = fields.Length - 1; i >= 0; i--)
                {
                    System.Type thisType = fields[i].DeclaringType;
                    if (thisType != lastType)
                    {
                        lastType = thisType;
                        insertIdx = list.Count;
                    }
                    list.Insert(insertIdx, fields[i]);
                }

                return (FieldInfo[])list.ToArray(typeof(FieldInfo));
            }

            /// <summary>
            /// Determines the index of the field with the given name.
            /// </summary>
            /// <param name="fieldName">The name of the field to find.</param>
            /// <returns>The index of the field with the given name.</returns>
            /// <exception cref="ArgumentOutOfRangeException">
            /// Thrown if no field can be found whose name matches the value passed in fieldName.
            /// </exception>
            public uint GetFieldIndex(string fieldName)
            {
                for (int i = 0; i < Fields.Length; ++i)
                {
                    if (Fields[i].Name == fieldName)
                    {
                        return (uint)i;
                    }
                }

                throw new ArgumentOutOfRangeException("fieldName", fieldName,
                    "This type does not contain a FieldInfo entry with the given name.");
            }
        }
    }

    /// <summary>
    /// Attribute placed on fields of a class derived from WireData to add context to the field in order to serialze it
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        /// <summary>
        /// Used to specify a constant size for an array.
        /// </summary>
        public int ArraySize = -1;

        /// <summary>
        /// Used to specify which other field in a <c>WireData</c> class specifies the size of the array or string this attribute is put on.
        /// </summary>
        public string SizeParam = null;

        /// <summary>
        /// Include the Null in a varible length string and add 1 to it's length variable (if there is one)
        /// </summary>
        public bool NullTerminated = false;

        /// <summary>
        /// Use unicode Encoding instead of the default (UTF8)
        /// </summary>
        public bool UnicodeEncoded = false;

        public bool WriteOnlyVarLenString = false;
        public bool Serialize = true;
        public bool OnlySerializeIfNotEmpty = false;

        /// <summary>If true, forces this field to be picked up for serialization.</summary>
        public bool ForceSerialize = false;

        public String MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint MinSchemaVersionVal = 0;
        public uint MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", (version & 0xFFFF0000) >> 16, version & 0xFFFF);
        }

        /// <summary>
        /// An static instance of <c>WireInfoAttribute</c> with all values set to defaults.
        /// </summary>
        public static WireInfoAttribute None = new WireInfoAttribute();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\HUD\RedeemCodeScene.cs ===
using System;
using System.Threading;

using live.common;
using live.server;
using live.protocol;
using ServerTestFramework;

namespace live.lfm.xbox360Internal.HUD
{
    /// <summary>
    /// This scene is not cacheable
    /// </summary>
    public class RedeemCodeScene : BasicScene
    {
        private string _prepaidCode;
        private ulong _offerId;
        private uint StoreId;

        public RedeemCodeScene(LfmState lfmState, SceneBase previousScene, string prepaidCode, uint storeId)
            : base(lfmState, previousScene)
        {
            _prepaidCode = prepaidCode;
            StoreId = storeId;
        }

        public RedeemCodeScene(LfmState lfmState, SceneBase previousScene, string prepaidCode)
            : base(lfmState, previousScene)
        {
            _prepaidCode = prepaidCode;
            StoreId = 1;
        }


        /// <summary>
        /// /xbos/XeVerifyToken.ashx
        /// /xbos/XeContentDetails.ashx`
		/// /xuacs/XeGetPointsBalance.ashx
        /// </summary>
        /// <returns></returns>
        internal override BasicScene Activate()
        {
            int retries = 2;
            //Wait 30 seconds before retrying
            const int retyWaitTime = 30000;

            while (retries > 0)
            {
                try
                {

                    XeVerifyTokenResponse response = Billing.XeVerifyToken(_client, _user, _prepaidCode, StoreId);
                    OfferingTypeEnum offerType = (OfferingTypeEnum)response.xboxOfferInfo.offerTypeId;

                    _offerId = response.xboxOfferInfo.offerId;
                    if (offerType == OfferingTypeEnum.Subscription)
                    {
                        Billing.XeSubscriptionDetails(_client, _user, _offerId);
                        break;
                    }
                    else if (offerType == OfferingTypeEnum.PointsBundle)
                    {
                        break;
                    }
                    else
                    {
                        throw new Exception("Don't know how to handle Offer Type " + offerType);
                    }
                }
                catch (Exception e)
                {
                    --retries;
                    Global.RO.Warn(e.Message);
                    Global.RO.Warn("verify token failed, retrying...");
                    Thread.Sleep(retyWaitTime);
                }
            }

            if (retries <= 0)
            {
                //ran out of retries and the error threw again
                throw new UnexpectedTestResultException("Ran out of retries.");
            }

            UACS.XeGetPointsBalance(_client, _user);
            return this;
        }


        /// <summary>
        /// /xbos/XeOfferPurchase.ashx
        /// /xbos/XeContentHistoryEnumerate.ashx
        /// /xuacs/XeGetPointsBalance.ashx
        /// </summary>
        public void RedeemNow()
        {
            int retries = 2;

            while (retries > 0)
            {
                try
                {
                    Billing.XeOfferPurchase(_client, _user, _offerId,
                                PaymentTypeEnum.Token, _prepaidCode);
                    break;
                }
                catch (Exception e)
                {
                    --retries;
                    Global.RO.Warn(e.ToString());
                    Global.RO.Warn("purchase using token failed, retrying...");
                    System.Threading.Thread.Sleep(30000); //sleep 30 seconds
                }
            }
            
            if (retries <= 0)
            {//ran out of retries and the error threw again
                throw new UnexpectedTestResultException("Ran out of retries.");
            }

            if (Offers.IsGoldSubscription(_offerId))
            {
                _lfmState.ActiveUser.Settings.UserType = XblUserTier.Gold;
                // client.UserLoggingOff(user);
                ((live.client.Xbox360Client)_client).UserLoggingOn(_user);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\sgPackets.cs ===
using System;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;


namespace live.common.kdc
{

    public class SGException : Exception
    {
        public SGException(string message)
            : base(message)
        {
            Logging.WriteLine(message, "ERROR");
        }
        public SGException(string format, params object[] args)
            : base(String.Format(format, args))
        {
            Logging.WriteLine("ERROR", format, args);
        }
    }


    /// <summary>
    /// Kerb Constants
    /// </summary>
    public class KC
    {
        //public const uint   TEST_SPI_INIT       = 0x8D111100;
        public const int k_MaxUDPPayload = 1472;
        public const int k_MaxXSPPayload = 1472 - (4 + 12);  // spihdr + tail (+ padding room?)
        public const int k_dwDHKeySize = 96;
        public const int k_APRequestSize = 735;      // was 732; was 718;   // no bigger than 1300
        public const int k_APResponseSize = 115;      // was 800;   // no bigger than 800
        public const int k_QuickTimeout = 2000;     // in milliseconds
        public const int k_LongTimeout = 5000;     // in milliseconds
    }

    /// <summary>
    /// SG Constants
    /// </summary>
    public class SGC
    {
        public const uint sg_MinXbToSGInitPacketSize = 1332; //the initial keyex packet size to the sg has to be at least this length
    }

#if false
    public abstract class SgPacket 
    {
        public SgPacket()
        {
        }

        public abstract void WriteStream(BinaryWriter);
        public abstract void ReadStream(BinaryReader);

        public void GetBytes(byte[] buffer, int index, int count)
        {
            MemoryStream ms = new MemoryStream(buffer, index, count);
            BinaryWriter bw = new BinaryWriter(ms);
            WriteStream(bw);
        }

        public void SetBytes(byte[] buffer, int index, int count)
        {
            MemoryStream ms = new MemoryStream(buffer, index, count);
            BinaryReader br = new BinaryReader(ms);
            ReadStream(br);
        }
    }
#endif



    #region SendablePacket and SGPacket





    /// <summary>
    /// Extend this class if your packet can be sent and received via a UDP socket.
    /// </summary>
    public class SendablePacket : WireDataIncludeBase
    {
        [WireInfo(Serialize = false)]
        protected int recvSize = 0;

        [WireInfo(Serialize = false)]
        protected byte[] recvBuf = null;

        [WireInfo(Serialize = false)]
        public SimpleUdpSG simpleUdp = null;

        /// <summary>
        /// Called just after receiving the bytes but before sending them to Wiredata. Override
        /// this as necessary to verify the received bytes are the expected ones. Generally, this
        /// can be done by looking at the first few bytes of the stream, if the packet specifies its
        /// type, or by looking at the stream length.
        /// </summary>
        /// <returns>true is this is the correct packet, false if we should try the Recv() again.</returns>
        public virtual bool Check()
        {
            return true;
        }

        /// <summary>
        /// Send this packet on its way.
        /// </summary>
        /// <param name="remoteHost"></param>
        public virtual void Send(IPEndPoint remoteHost, SimpleUdpSG udp)
        {
            simpleUdp = udp;
            if (remoteHost == null)
            {
                throw new Exception("remoteHost is null, unable to send packet");
            }
            byte[] packet = (byte[])this;
            simpleUdp.Send(packet, remoteHost);
        }

        public virtual void Send(IPEndPoint remoteHost)
        {
            if (simpleUdp == null)
                throw new Exception("Unable to use shortcut Send() since the UDP socket is null");
            Send(remoteHost, simpleUdp);
        }

        /// <summary>
        /// Used internally for recursive receives, in order to throw away unexpected packets and 
        /// try again.
        /// </summary>
        /// <param name="timeoutInMs"></param>
        /// <param name="recvAttempts"></param>
        /// <returns></returns>
        protected virtual byte[] RecvHelp(int timeoutInMs, SimpleUdpSG udp, int recvAttempts)
        {
            if (recvAttempts <= 0)
            {
                return null;
            }
            recvBuf = udp.RecvFast(timeoutInMs, out recvSize);
            if (recvBuf != null && recvSize > 0)
            {
                // Make sure this is the type of reply we're expecting before we go blindly filling
                // the WireData structure
                if (!Check())
                {
                    return RecvHelp(timeoutInMs, udp, recvAttempts - 1);
                }
                ReadBytes(recvBuf, recvSize);
            }
            return recvBuf;
        }

        /// <summary>
        /// Wait for data to come in on this socket, then serialize the received bytes to this Wiredata
        /// object. It is assumed we are expecting exactly 1 type of packet to come back, so we'll retry
        /// up to a finite number of times if we get an unexpected packet type, as verified by Check().
        /// </summary>
        /// <param name="timeoutInMs"></param>
        /// <returns></returns>
        public virtual byte[] Recv(int timeoutInMs, SimpleUdpSG udp)
        {
            return RecvHelp(timeoutInMs, udp, 8);
        }

        public virtual byte[] Recv(int timeoutInMs)
        {
            if (simpleUdp == null)
                throw new Exception("Unable to use shortcut Recv() since the UDP socket is null");
            return RecvHelp(timeoutInMs, simpleUdp, 8);
        }

    }

    /// <summary>
    /// All SG based packets will likely extend this, such as SECMSG*, SGMSG*, and KEYEX* messages.
    /// Of course, any packet that has Type and cbEnt fields at the beginning may extend it. Be sure
    /// to set these two fields before serializing into this class, since Check() will use these
    /// fields to verify the incoming byte stream.
    /// </summary>
    public class SGPacket : SendablePacket
    {
        public short Type = 0;                //    See    KEYEX_TYPE_* and SECMSG_TYPE_*
        public short cbEnt = 0;                //    Size of    this entry (including header)

        public const int SIZE = 4;

        public SGPacket()
        {
            cbEnt = SIZE;
        }

        public SGPacket(short type, short cbent)
        {
            Type = type;
            cbEnt = cbent;
        }

        public SGPacket(int type, int cbent)
        {
            Type = (short)type;
            cbEnt = (short)cbent;
        }

        public override bool Check()
        {
            if (this.recvSize < 4)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short size = (short)(recvBuf[2] + (recvBuf[3] << 8));

            if (type != this.Type || size != this.cbEnt)
                return false;

            return true;
        }

    }

    #endregion

    #region XspPacket and header

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class XspHeader : WireData
    {
        public const uint XSP_TYPE_SEC = 0; // Packet is in SecMsg format
        public const uint XSP_TYPE_TCP_0 = 1; // packet is in TCP format (0 byte ports)
        public const uint XSP_TYPE_TCP_1 = 2; // Packet is in TCP format (1 byte ports)
        public const uint XSP_TYPE_TCP_2 = 3; // Packet is in TCP format (2 byte ports)
        public const uint XSP_TYPE_UDP_0 = 4; // packet is in UDP format (0 byte ports)
        public const uint XSP_TYPE_UDP_1 = 5; // Packet is in UDP format (1 byte ports)
        public const uint XSP_TYPE_UDP_2 = 6; // Packet is in UDP format (2 byte ports)
        public const uint XSP_TYPE_VDP_0 = 7; // Packet is in VDP format (0 byte ports)
        public const uint XSP_TYPE_VDP_1 = 8; // Packet is in VDP format (1 byte ports)
        public const uint XSP_TYPE_VDP_2 = 9; // Packet is in VDP format (2 byte ports)
        public const uint XSP_TYPE_VDP_VO_0 = 10; // Packet is in VDP voice-only format (0 byte ports)
        public const uint XSP_TYPE_VDP_VO_1 = 11; // Packet is in VDP voice-only format (1 byte ports)
        public const uint XSP_TYPE_VDP_VO_2 = 12; // Packet is in VDP voice-only format (2 byte ports)
        public const uint XSP_TYPE_VDP_DO_0 = 13; // Packet is in VDP data-only format (0 byte ports)
        public const uint XSP_TYPE_VDP_DO_1 = 14; // Packet is in VDP data-only format (1 byte ports)
        public const uint XSP_TYPE_VDP_DO_2 = 15; // Packet is in VDP data-only format (2 byte ports)
        public const uint XSP_TYPE_MAX = 15; // Highest packet type defined
        public const uint XSP_TYPE_MASK = 0x0F; // Packet type mask
        public const uint XSP_DATPAD_MASK = 0xE0; // Payload padding in bytes
        public const byte XSP_DATPAD_SHIFT = 5;    // How far left to shift payload padding
        public const uint XSP_DATPADEX_MASK = 0x10; // Payload padding (high bit of 16 byte blocks)
        public const byte XSP_DATPADEX_SHIFT = 1;    // How far left to shift payload padding

        public const uint XSP_SPI_MASK = 0xFFFFFF00; // SPI occupies the top 24 bits
        public const uint XSP_FLAGS_MASK = 0x000000FF; // Flags occupies the low 8 bits

        //[FuzzData(Probability=1.0, RandomBytes=true)]
        public uint SpiAndFlags = 0;

        public XspHeader(int spi)
        {
            SpiAndFlags = (uint)spi;
        }

        public XspHeader(uint spi)
        {
            SpiAndFlags = (uint)spi;
        }

        public XspHeader(byte[] data)
        {
            // data.Length should be >= 4
            SpiAndFlags = (uint)(data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24));
        }

        public uint GetSpi()
        {
            return (SpiAndFlags & XSP_SPI_MASK);
        }

        public uint GetFlags()
        {
            return (SpiAndFlags & XSP_FLAGS_MASK);
        }

        public uint GetPadding()
        {
            return
                ((SpiAndFlags & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT) |
                ((SpiAndFlags & XSP_DATPADEX_MASK) >> XSP_DATPADEX_SHIFT);
        }

        public uint GetXspType()
        {
            return (SpiAndFlags & XSP_TYPE_MASK);
        }

        public void SetPadding(uint bytesOfPadding)
        {
            // Clear out existing pad
            SpiAndFlags &= ~(XSP_DATPAD_MASK | XSP_DATPADEX_MASK);

            // Set padding
            SpiAndFlags |=
                (bytesOfPadding << XSP_DATPAD_SHIFT) & XSP_DATPAD_MASK |
                (bytesOfPadding << XSP_DATPADEX_SHIFT) & XSP_DATPADEX_MASK;

        }

        public void SetType(uint type)
        {
            // Clear out existing type
            SpiAndFlags &= ~XSP_TYPE_MASK;

            // Set it
            SpiAndFlags |= (type & XSP_TYPE_MASK);
        }
    }

    public class XspPacket : SendablePacket
    {
        // Packet layout:
        //   -- nethdrs, skip for simple packet (this one) --
        //   EnetHdr            (14 bytes)
        //   IpHdr              (20 bytes)
        //   UdpHdr             (8 bytes)
        //   -- begin data --
        //   SpiRecv            (4 bytes)
        //   -- encrypted message --
        //   message            (<= 1464 bytes)
        //   -- tail, encrypted and hashed --
        //   loword(SeqXmit)    (2 bytes)
        //   hiword(SeqXmit)    (2 bytes)
        //   SpiRecv            (4 bytes)
        //   dwZero             (4 bytes, set to 0)

        protected XspHeader SpiRecv = new XspHeader(0);

        // Either this is set...
        protected SecMsgHeader secmsg = null;

        // Or this is set (for other, non-SecMsg, XSP packets)
        protected byte[] datamessage = null;
        protected int datamessageLength = 0;

        // This is optionally set for non-SecMsg messages.  It will be a UDP or TCP header.
        [WireInfo(ForceSerialize = true)]
        //[FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[] extraBytes = null;
        protected ushort sourcePort = 0;
        protected ushort destPort = 0;

        // Holds either the encrypted or decrypted XSP packet payload
        [WireInfo(ForceSerialize = true)]
        //[FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[] payload;
        protected bool bIsEncrypted = false;

        protected uint Sequence;
        [WireInfo(ForceSerialize = true)]
        //[FuzzData(Fuzz=true, Probability=0.25, RandomBytes=true)]
        protected ushort SeqLo;
        protected ushort SeqHi;
        protected BinaryWriter preTail = null;
        [WireInfo(ForceSerialize = true)]
        //[FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[] hashedTail = null;

        protected SecReg keys;

        public XspHeader SpiHeader
        {
            get { return SpiRecv; }
        }

        public SecMsgHeader SecMsg
        {
            get { return secmsg; }
            set { secmsg = value; }
        }

        public byte[] Message
        {
            get { return datamessage; }
        }

        public int MessageLength
        {
            get { return datamessageLength; }
        }

        public uint XspType
        {
            get { return SpiRecv.GetXspType(); }
        }

        public uint Padding
        {
            get { return SpiRecv.GetPadding(); }
        }

        public uint SequenceNumber
        {
            get { return Sequence; }
            set
            {
                Sequence = value;
                this.SeqLo = (ushort)(Sequence & 0x0000FFFF);
                this.SeqHi = (ushort)((Sequence >> 16) & 0x0000FFFF);
            }
        }

        public ushort SourcePort
        {
            get { return sourcePort; }
        }

        public ushort DestPort
        {
            get { return destPort; }
        }

        public byte[] Payload
        {
            get { return payload; }
        }

        public byte[] HashedTail
        {
            get { return hashedTail; }
        }

        public void SetSecKeys(SecReg keys)
        {
            this.keys = keys;
            this.SpiHeader.SpiAndFlags = (keys.SpiRecv & XspHeader.XSP_SPI_MASK) | this.XspType;
        }

        /// <summary>
        /// Use this constructor for receiving Xsp packets
        /// </summary>
        /// <param name="keys"></param>
        public XspPacket(SecReg keys)
        {
            this.keys = keys;
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(SecMsgHeader msg, SecReg keys, uint SeqXmit)
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(XspHeader.XSP_TYPE_SEC);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = msg;
            this.extraBytes = null;
            byte[] msgbytes = (byte[])msg;
            //this.dataPayloadSize = msgbytes.Length;
            Encrypt(msgbytes);
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message. Use for funky messages.
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(byte[] msgBytes, SecReg keys, uint SeqXmit)
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(XspHeader.XSP_TYPE_SEC);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = null;
            this.extraBytes = null;
            //this.dataPayloadSize = msgBytes == null ? 0 : msgBytes.Length;
            Encrypt((byte[])msgBytes);
        }


        /// <summary>
        /// Use this constructor for sending any non-SecMsg type message. This will automatically build
        /// the extra bytes needed for the UDP_1, UDP_2, etc, header.
        /// </summary>
        /// <param name="msgBytes"></param>
        /// <param name="xspType"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(byte[] msgBytes, uint xspType, int srcPort, int dstPort, SecReg keys, uint SeqXmit)
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(xspType);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = null;
            //this.dataPayloadSize = msgBytes == null ? 0 : msgBytes.Length;
            BuildInsideHeaderBytes((ushort)srcPort, (ushort)dstPort);
            Encrypt(msgBytes);
        }

        public void Clear()
        {
            secmsg = null;
            datamessage = null;
            datamessageLength = 0;
            extraBytes = null;
            sourcePort = 0;
            destPort = 0;
        }

        /// <summary>
        /// Set payload and hashedTail members
        /// </summary>
        /// <param name="message"></param>
        public void Encrypt(byte[] message)
        {
            // Optimistic no-padding situation
            payload = message;

            // Pad up to blocksize byte boundary, required for encryption
            int pad = 0;
            int totalMessageLength = message.Length;
            uint blockSize = keys.BlockSize;
            if (blockSize > 0)
            {
                pad = (int)(blockSize - (totalMessageLength % blockSize));
                if (pad == blockSize)
                    pad = 0;

                if (pad > 0)
                {
                    // @@@ omg, we should really make this more efficient
                    totalMessageLength += pad;
                    payload = new byte[totalMessageLength];
                    message.CopyTo(payload, 0);
                }

                // If we have extra bytes to add to this message, and there's padding room available,
                // we need to copy the bytes over.
                if (pad > 0 && extraBytes != null && extraBytes.Length > 0)
                {
                    int bytesToCopy = (extraBytes.Length > pad) ? pad : extraBytes.Length;
                    Array.Copy(extraBytes, 0, payload, message.Length, bytesToCopy);
                }

                // Calculate the IV
                byte[] abIv = keys.CalcIvAtSeq(keys.IvXmit, Sequence);

                // Encrypt payload
                keys.Crypt(true, abIv, payload, payload.Length);
                bIsEncrypted = true;
            }

            // Set padding in SPI header even if 0
            SpiRecv.SetPadding((uint)pad);

            // Encrypt and hash the tail
            //
            // First build the weird half-tail array
            if (hashedTail == null || preTail == null)
            {
                hashedTail = new byte[10];  // hiword(SeqXmit) [2 bytes] + SPI [4 bytes] + zero [4 bytes]
                preTail = new BinaryWriter(new MemoryStream(8));
            }
            else
            {
                preTail.Seek(0, SeekOrigin.Begin);
            }

            // preTail always includes the SeqLo, SeqHi, and Spi fields
            // It optionally includes the "extra" bytes (tcp, udp headers that don't fit 
            // in the padding)
            if (extraBytes != null && extraBytes.Length > 0)
            {
                int bytesToHash = extraBytes.Length - pad;
                if (bytesToHash > 0)
                {
                    // Only hash the stuff that didn't fit into the padding
                    preTail.Write(extraBytes, pad, bytesToHash);
                }
            }
            preTail.Write(SeqLo);
            preTail.Write(SeqHi);
            preTail.Write(SpiRecv.SpiAndFlags);
            byte[] pb1 = (preTail.BaseStream as MemoryStream).ToArray();
            AuthClientBase.XcHmac4(
                keys.KeyShaXmit,
                keys.KeyShaXmit.Length,
                pb1,
                pb1.Length,
                payload,
                payload.Length,
                null,
                0,
                null,
                0,
                hashedTail,
                hashedTail.Length);

        }


        /// <summary>
        /// Sets secmsg and Sequence members
        /// </summary>
        public void Decrypt()
        {
            // Verify SPI is what we expect
            if (SpiRecv.GetSpi() != (this.keys.SpiXmit & XspHeader.XSP_SPI_MASK))
            {
                throw new SGException("Got SECMSG with wrong SPI, expected 0x{0:X}, got 0x{1:X}", keys.SpiXmit, SpiRecv.SpiAndFlags);
            }

            if (keys.Cipher != SecReg.CipherType.NULL)
            {
                // Calculate IV
                byte[] abIv = keys.CalcIvAtSeq(keys.IvRecv, SequenceNumber);

                // Decrypt the data goodness
                this.keys.Crypt(false, abIv, this.payload, this.payload.Length);
            }

            // payload now holds the decrypted message
            bIsEncrypted = false;

            // Trim off padding
            //            if (SpiRecv.GetPadding() > 0)
            //            {
            //                decryptedMessage = new byte[payload.Length - SpiRecv.GetPadding()];
            //                Array.Copy(payload, 0, decryptedMessage, 0, decryptedMessage.Length);
            //            }

            // Is this a SECMSG*?
            if ((SpiRecv.GetFlags() & XspHeader.XSP_TYPE_MASK) == XspHeader.XSP_TYPE_SEC)
            {
                secmsg = SecMsgHeader.CreatePacket(payload);
            }
            // If not, then it's a UDP*, TCP*, VDP* message
            else
            {
                this.datamessageLength = (int)(payload.Length - SpiRecv.GetPadding());
                this.datamessage = payload;
            }

            // I don't really care about the tail 
        }

        public static int GetInsideHeaderLength(uint xsptype)
        {
            switch (xsptype)
            {
                case XspHeader.XSP_TYPE_SEC:
                    return 0;
                case XspHeader.XSP_TYPE_UDP_0:
                    return 0;
                case XspHeader.XSP_TYPE_UDP_1:
                    return 2;
                case XspHeader.XSP_TYPE_UDP_2:
                    return 4;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in BuildInsideHeader", xsptype);
            }
        }


        public void BuildInsideHeaderBytes(ushort srcPort, ushort dstPort)
        {
            this.extraBytes = BuildInsideHeader(srcPort, dstPort);
        }

        public byte[] BuildInsideHeader(ushort srcPort, ushort dstPort)
        {
            BinaryWriter bwExtra;

            // Save ports
            this.sourcePort = srcPort;
            this.destPort = dstPort;

            int insideHeaderLength = GetInsideHeaderLength(this.XspType);
            switch (this.XspType)
            {
                case XspHeader.XSP_TYPE_SEC:
                    return null;
                case XspHeader.XSP_TYPE_UDP_0:
                    return null;
                case XspHeader.XSP_TYPE_UDP_1:
                    bwExtra = new BinaryWriter(new MemoryStream(insideHeaderLength));
                    bwExtra.Write((byte)sourcePort);
                    bwExtra.Write((byte)destPort);
                    break;
                case XspHeader.XSP_TYPE_UDP_2:
                    bwExtra = new BinaryWriter(new MemoryStream(insideHeaderLength));
                    bwExtra.Write((ushort)NetConstants.HTONS((ushort)sourcePort));  // src
                    bwExtra.Write((ushort)NetConstants.HTONS((ushort)destPort));  // dst
                    break;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in BuildInsideHeader", this.XspType);
            }

            return ((MemoryStream)bwExtra.BaseStream).ToArray();
        }

        public void DeconstructInsideHeader(byte[] header)
        {
            int insideHeaderLength = GetInsideHeaderLength(this.XspType);
            System.Diagnostics.Debug.Assert(header.Length >= insideHeaderLength, "Header length");

            BinaryReader br = new BinaryReader(new MemoryStream(header));
            switch (this.XspType)
            {
                case XspHeader.XSP_TYPE_SEC:
                    break;
                case XspHeader.XSP_TYPE_UDP_0:
                    sourcePort = 1000;
                    destPort = 1000;
                    break;
                case XspHeader.XSP_TYPE_UDP_1:
                    sourcePort = (ushort)(1000 + br.ReadByte());
                    destPort = (ushort)(1000 + br.ReadByte());
                    break;
                case XspHeader.XSP_TYPE_UDP_2:
                    sourcePort = (ushort)br.ReadInt16();
                    destPort = (ushort)br.ReadInt16();
                    break;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in DeconstructInsideHeader", this.XspType);
            }

            sourcePort = NetConstants.HTONS(sourcePort);
            destPort = NetConstants.HTONS(destPort);

        }

        public override void WriteStream(BinaryWriter bw)
        {


            bw.Write(this.SpiRecv.SpiAndFlags);
            bw.Write(this.payload);
            // Have extra byte to include between encrypted message and tail?
            if (extraBytes != null)
            {
                // It's possible the extra bytes fit into the padding.  If not, write it out here.
                // If so, it's already included in the encrypted message portion.
                if (Padding < extraBytes.Length)
                {
                    bw.Write(this.extraBytes, (int)Padding, (int)(extraBytes.Length - Padding));
                }
            }
            bw.Write(this.SeqLo);
            bw.Write(this.hashedTail);
        }


        public override WireData ReadStream(BinaryReader br)
        {
            uint seq;
            int totalLength = 0;
            int encryptedMessageLength = 0;
            int insideHeaderLength = 0;
            int unencryptedLength = 0;
            byte[] unencryptedBytes = null;

            // Read spi so we can determine padding, type, etc
            this.SpiRecv.SpiAndFlags = (uint)br.ReadInt32();

            // Determine lengths
            totalLength = (int)br.BaseStream.Length;
            insideHeaderLength = GetInsideHeaderLength(XspType);
            encryptedMessageLength = totalLength - 4 /* SPI */ - 12 /* tail */;
            if (insideHeaderLength > Padding)
            {
                unencryptedLength = (int)(insideHeaderLength - Padding);
                encryptedMessageLength -= unencryptedLength;
            }
            System.Diagnostics.Debug.Assert((encryptedMessageLength % 8) == 0, "Encrypted message must be a multiple of 8");

            // Read encrypted part            
            this.payload = br.ReadBytes(encryptedMessageLength);

            // Read extra bytes, if present
            if (unencryptedLength > 0)
            {
                unencryptedBytes = br.ReadBytes(unencryptedLength);
            }

            // Read tail
            seq = (ushort)br.ReadUInt16();  // loword(SequenceRecv)
            this.hashedTail = br.ReadBytes(10 /* tail */);

            // Build Sequence number and check for wrappage
            // We very likely may reqeive things out of sequence, so be careful
            // when detecting wrappage.
            // Within 0x100 of the border
            if (seq < this.SeqLo && seq < 0x0100 && this.SeqLo > 0xFF00)
            {
                // We've wrapped
                seq += 0x10000;
            }
            // Curse the compiler! It uses ushort by default when adding 2 ushorts,
            // thus we were losing our hi word. And we have to shift. Curses!
            SequenceNumber = (uint)(((uint)this.SeqHi << 16) + (uint)seq);

            Decrypt();

            // Set the inside header, if necessary
            if (insideHeaderLength > 0)
            {
                if (unencryptedLength == 0)
                {
                    // Everything was inside the encrypted packet
                    this.extraBytes = new byte[insideHeaderLength];
                    Array.Copy(
                        this.payload, this.payload.Length - insideHeaderLength,
                        extraBytes, 0,
                        insideHeaderLength);
                }
                else if (unencryptedLength == insideHeaderLength)
                {
                    // Everything was outside the encrypted packet
                    this.extraBytes = unencryptedBytes;
                }
                else
                {
                    // There's a mix :(
                    int cb1 = insideHeaderLength - unencryptedLength;
                    this.extraBytes = new byte[insideHeaderLength];
                    Array.Copy(
                        this.payload, this.payload.Length - cb1,
                        extraBytes, 0,
                        cb1);
                    Array.Copy(
                        unencryptedBytes, 0,
                        extraBytes, cb1,
                        unencryptedLength);
                }

                // Extract useful information from the inside header / extra bytes
                DeconstructInsideHeader(extraBytes);
            }

            return this;
        }


    }

    #endregion

    #region AuthData packets
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class XUserID : WireData     // aka XUID
    {
        public ulong qwUserID;
        public uint dwUserFlags;
    }

    public class Authdata_Base : WireDataIncludeBase
    {
        public ushort wAuthDataVersion;
        public ushort wAuthDataSize;
    }

    public class Authdata_Xbox2 : Authdata_Base
    {
        // XBOX_LIBRARY_VERSION         clientVersion;
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;
        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;

        public ulong qwXboxID;
        [WireInfo(ArraySize = 4)]
        public XUserID[] users;// = new XUserID[4];
        public uint dwNumServices;
        [WireInfo(ArraySize = 12)]
        public uint[] dwServiceID = new uint[12];
        [WireInfo(ArraySize = 4)]
        public float[] afltTrustFactor = new float[4];
        [WireInfo(ArraySize = 4)]
        public uint[] dwAltTitleID = new uint[4];
        [WireInfo(ArraySize = 16)]
        public byte[] abKey = new byte[16];

        public const int SIZE = 180;

        public override string ToString()
        {
            int i;
            System.Text.StringBuilder sb = new StringBuilder(500);
            sb.Append("Authdata_Xbox2:\n");
            sb.Append("       Version: " + base.wAuthDataVersion + ", " + base.wAuthDataSize + " bytes\n");
            sb.Append("     ClientVer: " + wMajorVersion + "." + wMinorVersion + "." + wBuildNumber + "." + wQFENumber + "\n");
            sb.Append("         Title: id 0x" + dwTitleID.ToString("X8") + ", ver 0x" + dwTitleVersion.ToString("X8") + ", region " + dwTitleRegion + "\n");
            sb.Append("  Machine PUID: 0x" + qwXboxID.ToString("X16") + "\n");
            for (i = 0; i < 4; i++)
            {
                sb.Append("       User[" + i + "]: 0x" + users[i].qwUserID.ToString("X16") + ", flags 0x" + users[i].dwUserFlags.ToString("X8") + "\n");
            }
            sb.Append("      Services: [" + dwNumServices + "]");
            for (i = 0; i < dwNumServices; i++)
            {
                sb.Append(" " + dwServiceID[i]);
            }
            sb.Append("\n");
            sb.Append("         Trust: 0:" + afltTrustFactor[0] + " 1:" + afltTrustFactor[1] + " 2:" + afltTrustFactor[2] + " 3:" + afltTrustFactor[3] + "\n");
            sb.Append("    AltTitleId: 0:0x" + dwAltTitleID[0].ToString("X8") + " 1:0x" + dwAltTitleID[1].ToString("X8") + " 2:0x" + dwAltTitleID[2].ToString("X8") + " 3:0x" + dwAltTitleID[3].ToString("X8") + "\n");
            sb.Append("           Key: " + ServerTestFramework.Utilities.Hexer.tohex(abKey) + "\n");
            return sb.ToString();
        }

    }

    public class Authdata_Xenon : Authdata_Base
    {
        public const uint FLAGS_ISXENON = 0x01;
        public const uint FLAGS_ISXENONBACKCOMPAT = 0x02;
        public const uint FLAGS_ISDEVKIT = 0x04;
        public const uint FLAGS_ISTESTKIT = 0x08;
        public const uint FLAGS_ISBETAMACHINE = 0x10;
        public const uint FLAGS_ISLIMITEDMACHINE = 0x20;


        // XBOX_LIBRARY_VERSION         clientVersion;
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;
        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;

        public uint dwConsoleRegion;
        public uint dwMediaID;
        public ushort wLanguageID;
        public uint dwAuthDataFlags;
        public ushort wNumPrivileges;
        [WireInfo(ArraySize = 8)]
        public uint[] dwPrivileges = new uint[8];
        public ulong qwXboxID;
        [WireInfo(ArraySize = 4)]
        public XUserID[] users;// = new XUserID[4];
        [WireInfo(ArraySize = 4)]
        public float[] afltTrustFactor = new float[4];
        public ushort wNumDwordServices;
        [WireInfo(ArraySize = 4)]
        public uint[] dwServiceID = new uint[4];
        [WireInfo(ArraySize = 4)]
        public uint[] dwAltTitleID = new uint[4];
        [WireInfo(ArraySize = 16)]
        public byte[] abKey = new byte[16];

        public const int SIZE = 194;

        public override string ToString()
        {
            int i;
            System.Text.StringBuilder sb = new StringBuilder(500);
            sb.Append("Authdata_Xenon:\n");
            sb.Append("       Version: " + base.wAuthDataVersion + ", " + base.wAuthDataSize + " bytes\n");
            sb.Append("     ClientVer: " + wMajorVersion + "." + wMinorVersion + "." + wBuildNumber + "." + wQFENumber + "\n");
            sb.Append("         Title: id 0x" + dwTitleID.ToString("X8") + ", ver 0x" + dwTitleVersion.ToString("X8") + ", region " + dwTitleRegion + "\n");
            sb.Append("       Console: ConsoleRegion " + dwConsoleRegion + ", MediaID " + dwMediaID + ", LanguageID " + wLanguageID + "\n");
            sb.Append(" AuthDataFlags: " + dwAuthDataFlags + "\n");
            sb.Append(" NumPrivileges: " + wNumPrivileges + "\n");
            sb.Append(" Privileges[0]: 0x" + dwPrivileges[0].ToString("X8") + "\n");
            sb.Append(" Privileges[7]: 0x" + dwPrivileges[7].ToString("X8") + "\n");
            sb.Append("  Machine PUID: 0x" + qwXboxID.ToString("X16") + "\n");
            for (i = 0; i < 4; i++)
            {
                sb.Append("       User[" + i + "]: 0x" + users[i].qwUserID.ToString("X16") + ", flags 0x" + users[i].dwUserFlags.ToString("X8") + "\n");
            }
            sb.Append("         Trust: 0:" + afltTrustFactor[0] + " 1:" + afltTrustFactor[1] + " 2:" + afltTrustFactor[2] + " 3:" + afltTrustFactor[3] + "\n");
            sb.Append(" DwordServices: [" + wNumDwordServices + "] 0x" + dwServiceID[0].ToString("X8") + ", 0x" + dwServiceID[1].ToString("X8") + ", 0x" + dwServiceID[2].ToString("X8") + ", 0x" + dwServiceID[3].ToString("X8") + "\n");
            sb.Append("    AltTitleId: 0:0x" + dwAltTitleID[0].ToString("X8") + " 1:0x" + dwAltTitleID[1].ToString("X8") + " 2:0x" + dwAltTitleID[2].ToString("X8") + " 3:0x" + dwAltTitleID[3].ToString("X8") + "\n");
            sb.Append("           Key: " + ServerTestFramework.Utilities.Hexer.tohex(abKey) + "\n");
            return sb.ToString();
        }
    }

    #endregion

    #region KeyExchange packets

    public class SGAddress : WireData
    {
        public const int XPLT_XBOX1 = 0;
        public const int XPLT_XBOX360 = 1;
        public const int XPLT_PC = 2;

        public IpAddr SgIP = new IpAddr();         // IP address of the SG for the client
        public int SpiSg = 0;                    // Pseudo-random identifier assigned by the SG
        public ulong XboxID = 0;                    // Unique identifier of client machine account
        public byte Platform = 0;                    // See XPLT_* above
        [WireInfo(ArraySize = 3)]
        public byte[] Reserved = new byte[3];          // Reserved (must be zero)

        public const int SIZE = 20;

        public override string ToString()
        {
            return String.Format("IP:{0}, SPI:0x{1:X}, XboxID:0x{2:X}, Platform:0x{3:X}", SgIP.ToString(), SpiSg, XboxID, Platform);
        }

        public override bool Equals(object obj)
        {
            return this == (obj as SGAddress);
        }

        public override int GetHashCode()
        {
            return this.SgIP.S_addr.GetHashCode() ^ this.SpiSg.GetHashCode() ^ this.XboxID.GetHashCode() ^ this.Platform.GetHashCode();
        }

        public static bool operator ==(SGAddress a, SGAddress b)
        {
            if (System.Object.ReferenceEquals(a, b))
                return true;
            if ((Object)a == null || (Object)b == null)
                return false;
            return
                (a.SgIP.S_addr == b.SgIP.S_addr) &&
                (a.SpiSg == b.SpiSg) &&
                (a.XboxID == b.XboxID) &&
                (a.Platform == b.Platform);
        }

        public static bool operator !=(SGAddress a, SGAddress b)
        {
            return !(a == b);
        }
    }

    public class KeyExchangeHeader : SGPacket
    {
        // Definitions (0x58 is    'X') ---------------------------------------------------------
        public const int KEYEX_VERSION = 0x0000;   //  Current KeyExchange version
        public const int KEYEX_TYPE_XBTOXB_INIT = 0x5800;   //  CKeyExchangeXbToXb | DH_GX | HMAC_SHA
        public const int KEYEX_TYPE_XBTOXB_RESP = 0x5801;   //  CKeyExchangeXbToXb | DH_GX | HMAC_SHA
        public const int KEYEX_TYPE_XBTOSG_INIT = 0x5802;   //  CKeyExchangeXbToSgInit | DH_GX | APREQ
        public const int KEYEX_TYPE_SGTOXB_RESP = 0x5803;   //  CKeyExchangeSgToXbResp | DH_GX | APREP
        public const int KEYEX_TYPE_NATOPEN_INIT = 0x5804;   //  CKeyExchangeNatOpen
        public const int KEYEX_TYPE_NATOPEN_RESP = 0x5805;   //  CKeyExchangeNatOpen
        public const int KEYEX_TYPE_QOS_INIT = 0x5806;   //  CKeyExchangeQosInit
        public const int KEYEX_TYPE_QOS_RESP = 0x5807;   //  CKeyExchangeQosResp
        public const int KEYEX_TYPE_XBTOTS_INIT = 0x5808;   //  CKeyExchangeXbToTs | APREQ
        public const int KEYEX_TYPE_TSTOXB_RESP = 0x5809;   //  CKeyExchangeTsToXb | APREP
        public const int KEYEX_TYPE_DH_GX = 0x5880;   //  diffie-hellman g^X (or g^Y)
        public const int KEYEX_TYPE_HMAC_SHA = 0x5881;   //  HMAC-SHA-1 digest (XbToXb)
        public const int KEYEX_TYPE_KERB_APREQ = 0x5882;   //  CKeyExchangeKerbApReq (XbToSg)
        public const int KEYEX_TYPE_KERB_APREP = 0x5883;   //  CKeyExchangeKerbApRep (SgToXb)
        public const int KEYEX_TYPE_NULL_APREP = 0x5885;   //  CKeyExchangeNullApRep (SgToXb; insecure; test only)
        public const int KEYEX_TYPE_PADDING = 0x5886;   //  random padding to make packet larger
        public const int KEYEX_TYPE_SGTOXB_CHAL = 0x5887;   //  CKeyExchangeSgToXbChal
        public const int KEYEX_TYPE_NULL_APREQ2 = 0x5888;   //  CKeyExchangeNullApReq2 (XbToSg; insecure; test only)

        public KeyExchangeHeader(int type, int cbent)
            : base(type, cbent)
        {
        }

        public static KeyExchangeHeader CreatePacket(byte[] data)
        {
            int type = 0;
            KeyExchangeHeader packet = null;

            if (data == null || data.Length < 4)
            {
                throw new SGException("CreatePacket failed, data is too short or null");
            }
            type = (int)(data[0] + (data[1] << 8));

            switch (type)
            {
                case KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP:
                    packet = new KeyExchangeInitResponse();
                    break;
                case KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL:
                    packet = new KeyExchangeSgToXbChallenge();
                    break;
                default:
                    throw new SGException("Don't know how to create packet of type 0x{0:X}, data.Length={1}", type, data.Length);
            }

            packet.ReadBytes(data);
            return packet;
        }

    }

    public class KeyExchangeSgToXbChallenge : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL;
        //public short                    cbEnt           = (short)SIZE;
        public uint DvdBlock = 0;        // DVD block to read
        public short DvdHashOffset = 0;        // Offset in block to start hashing
        public short DvdCopyOffset = 0;        // Offset in block to start copying
        [WireInfo(ArraySize = 16)]
        public byte[] Params = new byte[16];     // Challenge parameters
        [WireInfo(ArraySize = 256)]
        public byte[] PkSig = new byte[256];    // Digest of the rest of this entry

        // The rest of this entry is filled with challenge code that needs to be run
        // on the challenged xbox.  The result of running the code will be to modify
        // the 256 bytes immediately preceeding it (where the _abPkSig is above).
        // The size of the entry must be a multiple of 8 bytes because it is encrypted
        // during transport.

        [WireInfo(ArraySize = 0)]
        public byte[] ChalCode = null;

        public new const int SIZE = KeyExchangeHeader.SIZE + 280;
        public KeyExchangeSgToXbChallenge()
            : base(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            this.DvdBlock = (uint)br.ReadInt32();
            this.DvdHashOffset = (short)br.ReadInt16();
            this.DvdCopyOffset = (short)br.ReadInt16();
            this.Params = (byte[])br.ReadBytes(16);
            this.PkSig = (byte[])br.ReadBytes(256);

            int remaining = this.cbEnt - SIZE;
            if (remaining > 0)
            {
                this.ChalCode = (byte[])br.ReadBytes(remaining);
            }

            return this;
        }

        public void Decrypt(SecReg keys)
        {
            // Everything but the Type and cbEnt fields are encrypted
            int blobsize = cbEnt - 4;
            byte[] blob = new byte[blobsize];
            BinaryWriter bw = new BinaryWriter(new MemoryStream(blob));
            bw.Write(DvdBlock);
            bw.Write(DvdHashOffset);
            bw.Write(DvdCopyOffset);
            bw.Write(Params);
            bw.Write(PkSig);
            if (ChalCode != null)
                bw.Write(ChalCode);

            // Decrypt the data goodness
            // If connection is using DES or DES3, this will be encrypted with DES3.  
            // Otherwise, it will be AES.
            if (keys.Cipher == SecReg.CipherType.DES ||
                keys.Cipher == SecReg.CipherType.DES3)
            {
                keys.CryptWithCipher(false, SecReg.CipherType.DES3, keys.NonceResp, blob, (uint)blobsize, null, 0);
            }
            else
            {
                keys.CryptWithCipher(false, SecReg.CipherType.AES, keys.NonceResp, blob, (uint)blobsize, null, 0);
            }

            // blob is now unencrypted, put decrypted data back in place
            BinaryReader br = new BinaryReader(new MemoryStream(blob));
            this.DvdBlock = (uint)br.ReadInt32();
            this.DvdHashOffset = (short)br.ReadInt16();
            this.DvdCopyOffset = (short)br.ReadInt16();
            this.Params = (byte[])br.ReadBytes(16);
            this.PkSig = (byte[])br.ReadBytes(256);
            if (this.ChalCode != null)
                this.ChalCode = (byte[])br.ReadBytes(ChalCode.Length);
        }

        public override string ToString()
        {
            return String.Format("Type=0x{0:X4}, Size={1}, Params={2}, PkSig={3}, ChalCode={4}",
                                 Type,
                                 cbEnt,
                                 Hexer.tohex(Params),
                                 Hexer.tohex(PkSig),
                                 Hexer.tohex(ChalCode));
        }


    }

    public class KeyExchangeInit : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int XSIF_CONNECTION_SERVICE = 0x0001;   // Initiator requests    connection service
        public const int KEYEX_USER_GUEST_MASK = 0x1F;
        public const int KEYEX_USER_PERMUTE_MASK = 0x20;
        public const int KEYEX_USER_PERMUTATION_SHIFT = 6;

        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT;
        //public short                    cbEnt           = (short)SIZE;
        public short Version = KeyExchangeHeader.KEYEX_VERSION;                     //    KEYEX_VERSION
        public short wFlags = 0;                            // See XSIF_* above
        public uint SpiInit = 0;                            // SPI of the initiator
        [WireInfo(ArraySize = 8)]
        public byte[] NonceInit = null;                         // Nonce of the initiator (8 bytes)
        public int UserPerm = 0;                            // Permutation and guest bits    for    all    4 users

        public new const int SIZE = KeyExchangeHeader.SIZE + 20;
        public KeyExchangeInit()
            : base(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, SIZE)
        {
            Reset();

            // If we don't set the UserPerm bits, the SG will always zero out our users (as specified
            // in the ticket).  See SgKeyExPermute() in sgrecv.cpp for all the details.  We'll set
            // the default value here so that our users never get permuted (i.e., 1:1, 2:2, 3:3, and 4:4)
            // The dword is 4 bytes, 1 per user; see KEYEX_USER_PERMUTE_MASK and KEYEX_USER_PERMUTATION_SHIFT
            // above for how to set each byte.
            // Actually - bits 6 and 7 (2 highest) specify the user, bit 5 must be 1.
            UserPerm = 0;
            for (int user = 0; user < 4; user++)
            {
                // U1       U2       U3       U4
                // uup00000 uup00000 uup00000 uup00000
                int destUser = user;
                UserPerm |= ((user << KEYEX_USER_PERMUTATION_SHIFT) + KEYEX_USER_PERMUTE_MASK) << (destUser * 8);
            }
        }

        public void Reset()
        {
            wFlags = 0;
            SpiInit = AuthUtils.GetNewSpi();
            NonceInit = AuthUtils.GetNewNonce();
        }

    }

    public class KeyExchangeInitResponse : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int SXRF_ENCRYPT_DES = 0x00000001;     // SG wants DES encryption
        public const int SXRF_ENCRYPT_3DES = 0x00000002;     // SG wants 3DES encryption
        public const int SXRF_ENCRYPT_AES = 0x00000004;     // SG wants AES encryption
        public const int SXRF_ENCRYPT_NULL = 0x00000008;     // SG wants NULL encryption

        // This is a response, let's not initialize the fields to correct values. Instead, let's 
        // see what gets returned and verify that it is correct.
        // Data ------------------------------------------------------------------------------
        //public short                    Type            = 0;  //KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP;
        //public short                    cbEnt           = 0;  //(short)SIZE;
        public short Version = 0;  //KeyExchangeHeader.KEYEX_VERSION;  // KEYEX_VERSION
        public short Flags = 0;  // See SXRF_* above
        public uint SpiInit = 0;  //KC.TEST_SPI_INIT;        // SPI of the initiator
        public uint SpiResp = 0;  // SPI of the responder
        [WireInfo(ArraySize = 8)]
        public byte[] NonceInit = new byte[8];   // Nonce of the initiator (8 bytes)
        [WireInfo(ArraySize = 8)]
        public byte[] NonceResp = new byte[8];   // Nonce of the responder (8 bytes)

        // Note that everything from here down must be a multiple of 8 bytes and is encrypted
        // using the negotiated 3DES key and NonceResp as the IV.

        public SGAddress SGAddressInit = new SGAddress();      // SGADDR assigned to the initiator
        public IpAddr IPInit = new IpAddr();         // IP address of initiator (as seen by SG)
        public short PortInit = 0;                    // IP port of initiator (as seen by SG)
        public short XbToSgTimeoutInSecs = 0;                    // Secs of no inbound data/pulse before disconnecting
        public short XbToSgPulseTimeoutInSecs = 0;                    // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE
        public short PadZero = 0;                    // To make the encrypted area a multiple of 8 bytes

        public new const int SIZE = KeyExchangeHeader.SIZE + 60;
        public KeyExchangeInitResponse()
            : base(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP, SIZE)
        {
        }

        public void Decrypt(SecReg keys)
        {
            // Sigh.. we're doing this in place, since WireData is fussy. Marshall encrypted
            // blob into an array.... thanks C#!
            int blobsize = SGAddress.SIZE + 4 + 2 + 2 + 2 + 2;  // 32 bytes
            byte[] blob = new byte[blobsize];
            BinaryWriter bw = new BinaryWriter(new MemoryStream(blob));
            bw.Write((byte[])SGAddressInit);
            bw.Write((byte[])IPInit);
            bw.Write(PortInit);
            bw.Write(XbToSgTimeoutInSecs);
            bw.Write(XbToSgPulseTimeoutInSecs);
            bw.Write(PadZero);

            // Decrypt the data goodness
            // If connection is using DES or DES3, this will be encrypted with DES3.  
            // Otherwise, it will be AES.
            if (keys.Cipher == SecReg.CipherType.DES ||
                keys.Cipher == SecReg.CipherType.DES3)
            {
                keys.CryptWithCipher(false, SecReg.CipherType.DES3, NonceResp, blob, (uint)blobsize, null, 0);
            }
            else
            {
                keys.CryptWithCipher(false, SecReg.CipherType.AES, NonceResp, blob, (uint)blobsize, null, 0);
            }

            // blob is now unencrypted
            BinaryReader br = new BinaryReader(new MemoryStream(blob));
            SGAddressInit.ReadStream(br);
            IPInit.ReadStream(br);
            PortInit = br.ReadInt16();
            XbToSgTimeoutInSecs = br.ReadInt16();
            XbToSgPulseTimeoutInSecs = br.ReadInt16();
            PadZero = br.ReadInt16();
        }

    }


    public class KeyExchangeTsInit : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int KEYEX_USER_GUEST_MASK = 0x1F;
        public const int KEYEX_USER_PERMUTE_MASK = 0x20;
        public const int KEYEX_USER_PERMUTATION_SHIFT = 6;

        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_XBTOTS_INIT;
        //public short                    cbEnt           = (short)SIZE;
        public short Version = KeyExchangeHeader.KEYEX_VERSION;                     //    KEYEX_VERSION
        public short wFlags = 0;                            // See XSIF_* above
        [WireInfo(ArraySize = 8)]
        public byte[] Xnkid = null;
        public uint SpiInit = 0;                            // SPI of the initiator
        [WireInfo(ArraySize = 8)]
        public byte[] NonceInit = null;                         // Nonce of the initiator (8 bytes)
        public int UserPerm = 0;                            // Permutation and guest bits    for    all    4 users

        public new const int SIZE = KeyExchangeHeader.SIZE + 28;
        public KeyExchangeTsInit()
            : base(KeyExchangeHeader.KEYEX_TYPE_XBTOTS_INIT, SIZE)
        {
            Reset();
        }

        public void Reset()
        {
            wFlags = 0;
            SpiInit = AuthUtils.GetNewSpi();
            NonceInit = AuthUtils.GetNewNonce();

            // If we don't set the UserPerm bits, the SG will always zero out our users (as specified
            // in the ticket).  See SgKeyExPermute() in sgrecv.cpp for all the details.  We'll set
            // the default value here so that our users never get permuted (i.e., 1:1, 2:2, 3:3, and 4:4)
            // The dword is 4 bytes, 1 per user; see KEYEX_USER_PERMUTE_MASK and KEYEX_USER_PERMUTATION_SHIFT
            // above for how to set each byte.
            // Actually - bits 6 and 7 (2 highest) specify the user, bit 5 must be 1.
            for (int user = 0; user < 4; user++)
            {
                // U1       U2       U3       U4
                // uup00000 uup00000 uup00000 uup00000
                UserPerm |= ((user << KEYEX_USER_PERMUTATION_SHIFT) + KEYEX_USER_PERMUTE_MASK) << (user * 8);
            }
        }

    }

    public class KeyExchangeTsInitResponse : KeyExchangeHeader
    {
        // This is a response, let's not initialize the fields to correct values. Instead, 
        // let's see what gets returned and verify that it is correct.
        // Data ------------------------------------------------------------------------------
        //public short                    Type            = 0;  //KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP;
        //public short                    cbEnt           = 0;  //(short)SIZE;
        public short Version = 0;  //KeyExchangeHeader.KEYEX_VERSION;  // KEYEX_VERSION
        public short Flags = 0;  // See SXRF_* above
        public uint SpiInit = 0;  // SPI of the initiator
        public uint SpiResp = 0;  // SPI of the responder
        [WireInfo(ArraySize = 8)]
        public byte[] NonceInit = new byte[8];   // Nonce of the initiator (8 bytes)
        [WireInfo(ArraySize = 8)]
        public byte[] NonceResp = new byte[8];   // Nonce of the responder (8 bytes)
        public short XbToSgTimeoutInSecs = 0;                    // Secs of no inbound data/pulse before disconnecting
        public short XbToSgPulseTimeoutInSecs = 0;                    // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE

        // No encrypted section in the TS key exchange response

        public new const int SIZE = KeyExchangeHeader.SIZE + 32;
        public KeyExchangeTsInitResponse()
            : base(KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP, SIZE)
        {
        }
    }

    public class KeyExchangeDHGx : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_DH_GX;
        //public short                    cbEnt           = (short)SIZE; 
        [WireInfo(ArraySize = (int)KC.k_dwDHKeySize)]
        public byte[] DHGx = new byte[KC.k_dwDHKeySize];

        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_dwDHKeySize;

        // Constructor -----------------------------------------------------------------------
        public KeyExchangeDHGx()
            : base(KeyExchangeHeader.KEYEX_TYPE_DH_GX, SIZE)
        {
            //our X would be 0x01010101....
            byte[] DHx = new byte[KC.k_dwDHKeySize];
            for (int i = 0; i < DHx.Length; i++)
            {
                DHx[i] = 1;
            }
            AuthClientBase.ComputeDHGX(DHGx, DHx);
        }
    }

    public class KeyExchangeDHGy : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_DH_GX;  // multi-tasking
        //public short                    cbEnt           = (short)SIZE; 
        [WireInfo(ArraySize = (int)KC.k_dwDHKeySize)]
        public byte[] DHGy = new byte[KC.k_dwDHKeySize];

        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_dwDHKeySize;
        public KeyExchangeDHGy()
            : base(KeyExchangeHeader.KEYEX_TYPE_DH_GX, SIZE)
        {
        }
    }

    public class KeyExchangeAPReq : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString = true)]
        public byte[] Data = new byte[0];    // Kerberos    AP request

        public int CURRENT_SIZE
        {
            get
            {
                return KeyExchangeHeader.SIZE + Data.Length;
            }
        }

        public KeyExchangeAPReq()
            : base(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, KeyExchangeHeader.SIZE)
        {
        }

        //we override these so we can fix the packet length to the correct field just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbEnt = (short)(CURRENT_SIZE);
            base.WriteStream(binaryWriter);
        }
    }

    public class KeyExchangeAPRep : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_KERB_APREP;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize = (int)KC.k_APResponseSize)]
        public byte[] Data = null;  //new byte[KC.k_APResponseSize];    // Kerberos    AP response

        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_APResponseSize;
        public KeyExchangeAPRep()
            : base(KeyExchangeHeader.KEYEX_TYPE_KERB_APREP, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            base.Type = br.ReadInt16();
            base.cbEnt = br.ReadInt16();

            int bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            Data = br.ReadBytes(bytesRemaining);
            return this;
        }

    }

    public class KeyExchangePadding : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_PADDING;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString = true)]
        public byte[] Padding = new byte[0];

        public KeyExchangePadding(int paddingBytes)
            : base(KeyExchangeHeader.KEYEX_TYPE_PADDING, paddingBytes + SGPacket.SIZE)
        {
            Padding = new byte[paddingBytes];
        }
    }

    public class KeyExchangeTsPadding : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_PADDING;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString = true)]
        public byte[] Padding = new byte[0];

        public KeyExchangeTsPadding(int paddingBytes)
            : base(KeyExchangeHeader.KEYEX_TYPE_PADDING, paddingBytes + SGPacket.SIZE)
        {
            Padding = new byte[paddingBytes];
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // sent to the SG.
    public class KeyExchangeRequestPacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint SPI = 0;                                // Should be 0, otherwise SG won't recognize it
        public KeyExchangeInit keyexInit = new KeyExchangeInit();
        public KeyExchangeDHGx keyexDhgx = new KeyExchangeDHGx();
        public KeyExchangeAPReq keyexAPReq = new KeyExchangeAPReq();
        public KeyExchangePadding keyexPadding = new KeyExchangePadding(0);

        public void Reset()
        {
            keyexInit.Reset();
        }

        //we need to pad up to at least sg_MinXbToSGInitPacketSize size total
        //we override these so we can fix the packet length field to the correct size just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            FixPadding();
            base.WriteStream(binaryWriter);
        }
        private void FixPadding()
        {
            int padAmount = (int)(SGC.sg_MinXbToSGInitPacketSize - (KeyExchangeInit.SIZE + KeyExchangeDHGx.SIZE + keyexAPReq.CURRENT_SIZE));
            if (padAmount < 0) padAmount = 0;

            keyexPadding = new KeyExchangePadding(padAmount);
        }

        /// <summary>
        /// Build the Kerberos AP portion of the key exchange request packet.
        /// </summary>
        /// <param name="context">The context to use when building the AP.</param>
        /// <returns>A byte array containing the Kerberos AP portion of the key exchange request packet.</returns>
        byte[] BuildAP(AuthContext context)
        {
            long APTime;
            byte[] pb = new byte[1500];
            int cb = (int)pb.Length;

            // Build byte array of pre-AP data
            // Consists of:
            //     KeyexInit
            //     KeyexDhgx
            byte[] d1 = (byte[])keyexInit;
            byte[] d2 = (byte[])keyexDhgx;
            byte[] preAPData = new byte[d1.Length + d2.Length];
            Array.Copy(d1, 0, preAPData, 0, d1.Length);
            Array.Copy(d2, 0, preAPData, d1.Length, d2.Length);

            // Compute SHA of pre-AP data
            byte[] sha = new byte[AuthClientBase.k_Sha_Digest_Len];
            byte[] key;
            byte[] bytesServiceCtx;

            if (context.IsXenonTitle || context.IsPanorama)
            {
                key = context.ServiceCtxXe.SessionKey;
                bytesServiceCtx = (byte[])context.ServiceCtxXe;
            }
            else
            {
                key = context.ServiceCtxXbox.SessionKey;
                bytesServiceCtx = (byte[])context.ServiceCtxXbox;
            }

            AuthClientBase.XcHmac4(
                key,
                key.Length,
                preAPData,
                preAPData.Length,
                null, 0,
                null, 0,
                null, 0,
                sha,
                sha.Length);

            AuthClientBase.DLL_BuildAp(
                bytesServiceCtx,
                out APTime,
                sha,
                AuthClientBase.k_Sha_Digest_Len,
                pb,
                out cb);

            byte[] returnPacket = new byte[cb];
            Array.Copy(pb, returnPacket, cb);

            return returnPacket;
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the SG.
    public class KeyExchangeResponsePacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint SPI = 0;                                // 4 bytes
        public KeyExchangeInitResponse keyexResp = new KeyExchangeInitResponse();    // 64 bytes
        public KeyExchangeDHGy keyexDhgy = new KeyExchangeDHGy();            // 100 bytes
        public KeyExchangeSgToXbChallenge keyexChal = null;                             // 284+codesize bytes (optional)
        public KeyExchangeAPRep keyexAPRep = new KeyExchangeAPRep();           // 119-ish bytes

        public const int SIZE = (4 + KeyExchangeInitResponse.SIZE + KeyExchangeDHGy.SIZE + KeyExchangeAPRep.SIZE);

        protected uint ExpectedSPI = 0;
        public int totalLength = 0;

        public KeyExchangeResponsePacket(uint expectedSPI)
        {
            this.ExpectedSPI = expectedSPI;
        }

        public override bool Check()
        {
            // Sometimes this returns a packet 1 byte short.  I don't know why but it doesn't seem
            // to hurt anything.
            if (recvSize < SIZE - 1)
                return false;

            uint spi = (uint)(recvBuf[0] + (recvBuf[1] << 8) + (recvBuf[2] << 16) + (recvBuf[3] << 24));
            if (spi != ExpectedSPI)
                return false;

            return base.Check();
        }


        public override WireData ReadStream(BinaryReader br)
        {
            totalLength = (int)br.BaseStream.Length;
            int bytesRemaining;

            this.SPI = (uint)br.ReadInt32();
            this.keyexResp.ReadStream(br);
            this.keyexDhgy.ReadStream(br);

            // Peek at type and size
            // Read Challenge if it is available. It may not be.
            short type = br.ReadInt16();
            short size = br.ReadInt16();
            br.BaseStream.Seek(-4, SeekOrigin.Current);
            if (type == KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL)
            {
                bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
                if (bytesRemaining < KeyExchangeSgToXbChallenge.SIZE)
                {
                    // Since we read them, may as well set them, handy for debugging
                    //this.keyexChal.Type = type;
                    //this.keyexChal.cbEnt = size;
                    throw new SGException("{0} bytes available in stream, need at least {1} for SgToXb Challenge (plus APRep) (keyexresp size={2}, chal.cbEnt={3})", bytesRemaining, KeyExchangeSgToXbChallenge.SIZE, totalLength, size);
                }
                this.keyexChal = new KeyExchangeSgToXbChallenge();
                this.keyexChal.ReadStream(br);
            }

            // Read APReply
            //            bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            //            // sometimes it is 1 byte short
            //            if (bytesRemaining < KeyExchangeAPRep.SIZE-1)
            //            {
            //                throw new SGException("{0} bytes available in stream, need at least {1} for APReply structure", bytesRemaining, KeyExchangeAPRep.SIZE);
            //            }
            this.keyexAPRep.ReadStream(br);
            return this;
        }

    }


    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // sent to the LSP (TS) server.
    public class KeyExchangeTsRequestPacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint SPI = 0;                                // Should be 0, otherwise SG won't recognize it
        public KeyExchangeTsInit keyexInit = new KeyExchangeTsInit();
        public KeyExchangeAPReq keyexAPReq = new KeyExchangeAPReq();
        public KeyExchangeTsPadding keyexPadding = new KeyExchangeTsPadding(0);

        public void Reset()
        {
            keyexInit.Reset();
        }

        //we need to pad up to at least sg_MinXbToSGInitPacketSize size total
        //we override these so we can fix the packet length field to the correct size just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            FixPadding();
            base.WriteStream(binaryWriter);
        }
        private void FixPadding()
        {
            int padAmount = (int)(SGC.sg_MinXbToSGInitPacketSize - (KeyExchangeInit.SIZE + keyexAPReq.CURRENT_SIZE));
            if (padAmount < 0) padAmount = 0;

            keyexPadding = new KeyExchangeTsPadding(padAmount);
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the LSP (TS) server.
    public class KeyExchangeTsResponsePacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint SPI = 0;                                // 4 bytes
        public KeyExchangeTsInitResponse keyexResp = new KeyExchangeTsInitResponse();  // 36 bytes
        public KeyExchangeAPRep keyexAPRep = new KeyExchangeAPRep();           // 119-ish bytes

        public const int SIZE = (4 + KeyExchangeTsInitResponse.SIZE + KeyExchangeAPRep.SIZE);

        [WireInfo(Serialize = false)]
        protected uint ExpectedSPI = 0;

        [WireInfo(Serialize = false)]
        public int totalLength = 0;

        public KeyExchangeTsResponsePacket(uint expectedSPI)
        {
            this.ExpectedSPI = expectedSPI;
        }

        public override bool Check()
        {
            // Sometimes this returns a packet 1 byte short.  I don't know why but it doesn't seem
            // to hurt anything.
            if (recvSize < SIZE - 1)
                return false;

            uint spi = (uint)(recvBuf[0] + (recvBuf[1] << 8) + (recvBuf[2] << 16) + (recvBuf[3] << 24));
            if (spi != ExpectedSPI)
                return false;

            return base.Check();
        }
    }

    #endregion

    #region SGMSG packets (SGInfo / SPIDATA)

    public class SgMsgHeader : SGPacket
    {
        public const int SGMSG_TYPE_SPIDATA_REQ = 0x4710;  // CSgMsgSpiReq
        public const int SGMSG_TYPE_SPIDATA_REP = 0x4711;  // CSgMsgSpiRep
        public const int SGMSG_TYPE_SPIDATA = 0x4782;  // CSgMsgSpiData in the payload
        public const int SGMSG_TYPE_AUTHDATA = 0x4783;  // CAuthData3 in the payload

        public SgMsgHeader(int type, int cbent)
            : base(type, cbent)
        {
        }
    }

    public class SgMsgSpiData : SgMsgHeader
    {
        public ushort ClientPort = 0;                // IP port of the client on the Internet
        public IpAddr ClientAddr = new IpAddr();     // IP address of the client on the Internet
        public SGAddress ClientSGAddr = new SGAddress();  // SGADDR of the client
        public ushort VersionKeyEx = 0;                // KeyEx version of the client
        public ushort FlagsKeyEx = 0;                // Flags sent in KeyEx initiator
        [WireInfo(ArraySize = 8)]
        public byte[] Nonce = new byte[8];
        public long TimeInit = 0;                // FILETIME marking session initiation
        public int fCs = 0;                // TRUE if SG is providing connection services

        public new const int SIZE = SgMsgHeader.SIZE + 50;
        public SgMsgSpiData()
            : base(SgMsgHeader.SGMSG_TYPE_SPIDATA, SIZE)
        {
        }

        public override string ToString()
        {
            return String.Format("SpiData: Ip={0}, Port=0x{1:X4}, KeyexVersion={2}, KeyexFlags={3}, Nonce={4}, TimeInit=0x{5:X16}, fCs={6}",
                ClientAddr.ToString(),
                ClientPort,
                VersionKeyEx,
                FlagsKeyEx,
                ServerTestFramework.Utilities.Hexer.tohex(Nonce),
                TimeInit,
                fCs);
        }

    }

    public class SgMsgSpiReq : SgMsgHeader
    {
        public uint ReqNum = 0;                // Request number from requester
        public IpAddr ClientAddr = new IpAddr();     // IP address of the client on the DMZ
        public ushort ClientPort = 0;                // IP port of the client on the DMZ

        public new const int SIZE = SgMsgHeader.SIZE + 10;
        public SgMsgSpiReq()
            : base(SgMsgHeader.SGMSG_TYPE_SPIDATA_REQ, SIZE)
        {
        }
    }

    public class SgMsgSpiRep : SgMsgHeader
    {
        //#define CBSGSPIREPMSG  (sizeof(CSgMsgSpiRep)+sizeof(CSgMsgSpiData)+sizeof(CSgMsgHdr)+sizeof(CAuthData3))

        public uint ReqNum = 0;                // Copy of _dwReqNum from request
        public IpAddr ClientAddr = new IpAddr();     // IP address of the client on the DMZ
        public ushort ClientPort = 0;                // IP port of the client on the DMZ
        public byte fNotFound = 0;                // TRUE if client not found (no auth-data enclosed)

        public new const int SIZE = SgMsgHeader.SIZE + 11;
        public SgMsgSpiRep()
            : base(SgMsgHeader.SGMSG_TYPE_SPIDATA_REP, SIZE)
        {
        }

        public override string ToString()
        {
            string s = String.Format("SpiRep: ReqNum=0x{0:X8}, fNotFound={1}, Ip={2}, Port=0x{3:X4}",
                ReqNum,
                fNotFound,
                ClientAddr.ToString(),
                ClientPort);
            return s;
        }

    }

    public class SgMsgAuthData : SgMsgHeader
    {
        public Authdata_Base AuthData = new Authdata_Base();

#if false
        public override bool Check()
        {
            if (recvSize < 8)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short cbent = (short)(recvBuf[2] + (recvBuf[3] << 8));
            short version = (short)(recvBuf[4] + (recvBuf[5] << 8));
            short size = (short)(recvBuf[6] + (recvBuf[7] << 8));
            
            if (type != SgMsgHeader.SGMSG_TYPE_AUTHDATA || cbEnt < 8)
                return false;

            authdataVersion = (int)version;

            return true;
        }
#endif

        public override WireData ReadStream(BinaryReader br)
        {
            // Check the size
            if (br.BaseStream.Length < 8)
            {
                throw new SGException("Stream length is less than 4, the minimum required for an Authdata packet");
            }

            // Read base header info
            this.Type = br.ReadInt16();
            this.cbEnt = br.ReadInt16();

            // Now peek at authdata fields
            short authdataVersion = br.ReadInt16();
            short size = br.ReadInt16();

            // Rewind to beginning of authdata section
            br.BaseStream.Seek(-4, SeekOrigin.Current);

            if (authdataVersion == 2)
            {
                Authdata_Xbox2 ad = new Authdata_Xbox2();
                ad.ReadStream(br);
                AuthData = ad;
            }
            else if (authdataVersion == 3)
            {
                Authdata_Xenon ad = new Authdata_Xenon();
                ad.ReadStream(br);
                AuthData = ad;
            }
            else
            {
                throw new SGException("Unknown authdata version {0}", authdataVersion);
            }
            return this;
        }

        public SgMsgAuthData()
            : base(SgMsgHeader.SGMSG_TYPE_AUTHDATA, 4)
        {
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the SG.
    //
    // The reply is actually of the form:
    // {
    //   CSgMsgSpiRep
    //   CSgMsgSpiData2
    //   CSgMsgHdr+CAuthData[2,3]
    // }
    //
    // where the last 2 structures are optional, depending on whether the user was found.
    //
    public class SgMsgSpiDataRepPacket : SendablePacket
    {
        public SgMsgSpiRep SpiRep = new SgMsgSpiRep();
        public SgMsgSpiData SpiData = null;
        public SgMsgAuthData SpiAuth = null;

        public override bool Check()
        {
            if (recvSize < SgMsgSpiRep.SIZE)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short cbent = (short)(recvBuf[2] + (recvBuf[3] << 8));

            if (type != SgMsgHeader.SGMSG_TYPE_SPIDATA_REP || cbent != SgMsgSpiRep.SIZE)
                return false;

            return true;
        }

        public override WireData ReadStream(BinaryReader br)
        {
            // Read #1
            SpiRep.ReadStream(br);

            // If user wasn't found, there will be no more data in the stream, otherwise we
            /// should read it.
            if (SpiRep.fNotFound == 0)
            {
                // Read the rest
                SpiData = new SgMsgSpiData();
                SpiData.ReadStream(br);

                SpiAuth = new SgMsgAuthData();
                SpiAuth.ReadStream(br);
            }

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            SpiRep.WriteStream(bw);
            if (SpiData != null)
                SpiData.WriteStream(bw);
            if (SpiAuth != null)
                SpiAuth.WriteStream(bw);
        }

#if false
            // Check the size
            if (br.BaseStream.Length < SgMsgSpiRep.SIZE)
            {
                throw new SGException("Stream length is less than {0}, the minimum required for an SgMsgSpiRep packet", SgMsgSpiRep.SIZE);
            }

            int length = (int)br.BaseStream.Length;

            // Read #1
            SpiRep.ReadStream(br);
            length -= SpiRep.cbEnt;

            // If user wasn't found, there will be no more data in the stream
            if (SpiRep.fNotFound != 0)
            {
                throw new SGException("User (ip=0x{0:X}, port=0x{1:X}) not found in SpiData request",
                    SpiRep.ClientAddr.S_addr, SpiRep.ClientPort);
            }

            if (length <= SgMsgSpiData.SIZE + SGPacket.SIZE)
            {
                throw new SGException("Returned stream is too short, only have {0} bytes", br.BaseStream.Length);
            }

            // Read #2
            SpiData.ReadStream(br);
            length -= SpiData.cbEnt;

            // Read #3
            SpiAuth.ReadStream(br);
            
            return this;
        }
#endif

        public override string ToString()
        {
            string s = SpiRep.ToString();
            if (SpiData != null)
                s += "\n" + SpiData.ToString();
            if (SpiAuth != null)
                s += "\n" + SpiAuth.AuthData.ToString();
            return s;
        }
    }

    #endregion

    #region SECMSG packets

    //[StructLayout(LayoutKind.Sequential, Pack=1)]
    public class SecMsgHeader : SGPacket
    {
        // Definitions (0x53 is 'S') ---------------------------------------------------------
        public const int SECMSG_TYPE_DELETE = 0x5300;  // CSecMsgDelete
        public const int SECMSG_TYPE_PULSE = 0x5301;  // CSecMsgPulse
        public const int SECMSG_TYPE_XBTOSG_PULSE = 0x5302;  // CSecMsgXbToSgPulse
        public const int SECMSG_TYPE_SGTOXB_PULSE = 0x5303;  // CSecMsgSgToXbPulse (Obsolete)
        public const int SECMSG_TYPE_XBTOXB_FORWARD = 0x5304;  // CSecMsgXbToXbForward
        public const int SECMSG_TYPE_CHANGE_USERS_REQ = 0x5305;  // CSecMsgChangeUsersReq
        public const int SECMSG_TYPE_CHANGE_USERS_REP = 0x5306;  // CSecMsgChangeUsersRep
        public const int SECMSG_TYPE_XBTOSG_QOS_INIT = 0x5307;  // CSecMsgXbToSgQosInit
        public const int SECMSG_TYPE_SGTOXB_QOS_RESP = 0x5308;  // CSecMsgSgToXbQosResp
        public const int SECMSG_TYPE_SGTOXB_PULSE_2 = 0x5309;  // CSecMsgSgToXbPulse
        public const int SECMSG_TYPE_XBTOSG_CHALRESP = 0x530A;  // CSecMsgXbToSgChalResp
        public const int SECMSG_TYPE_XBTOSG_NATDET_REQ = 0x530B;  // No payload
        public const int SECMSG_TYPE_SGTOXB_NATDET_REP = 0x530C;  // No payload
        public const int SECMSG_TYPE_CHANGE_USERS_NULL = 0x530D;  // CSecMsgChangeUsersReq; insecure; test only
        public const int SECMSG_TYPE_SGTOXB_CHAL = 0x530E;  // New async challenge
        public const int SECMSG_TYPE_XBTOSG_CHALRESP_2 = 0x530F;  // New async challenge response
        public const int SECMSG_TYPE_XBTOSG_CHAL_ACK = 0x5310;  // Ack sent by client to confirm SGTOXB_CHAL
        public const int SECMSG_TYPE_SGTOXB_CHALRESP_ACK = 0x5311;  // Ack sent by SG to confirm XBTOSG_CHALRESP_2
        public const int SECMSG_TYPE_XBTOXB_FORWARD2 = 0x5312;  // CSecMsgXbToXbForward2

        // These used to be defined separately
        public const int QPF_PAIR_TWO = 0x01;    // This is the second packet of the pair
        public const int QPF_DATA_REQ = 0x02;    // This is a Qos data request only
        public const int QPF_DATA_REP = 0x04;    // This ia a Qos data reply only
        public const int QPF_DATA_NONE = 0x08;    // The host has no Qos data (sent in probe response)
        public const int QPF_DISABLED = 0x10;    // This host has disabled its Qos listener

        public SecMsgHeader(int type, int cbent)
            : base(type, cbent)
        {
        }

        public static SecMsgHeader CreatePacket(byte[] data)
        {
            int type = 0;
            int size = 0;
            SecMsgHeader packet = null;

            if (data == null || data.Length < 4)
            {
                throw new SGException("CreatePacket failed, data is too short or null");
            }
            type = (int)(data[0] + (data[1] << 8));
            size = (int)(data[2] + (data[3] << 8));

            switch (type)
            {
                case SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP:
                    packet = new SecMsgChangeUsersRep();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP:
                    packet = new SecMsgQosResp();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2:
                    packet = new SecMsgDataPulseResp();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP:
                    packet = new SecMsgNatDetRep();
                    break;
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD:
                    packet = new SecMsgXbToXbForward();
                    break;
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2:
                    packet = new SecMsgXbToXbForward2();
                    break;
                case SecMsgHeader.SECMSG_TYPE_DELETE:
                    packet = new SecMsgDelete();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL:
                    packet = new SecMsgSgToXbChal();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK:
                    packet = new SecMsgSgToXbChalRespAck();
                    break;
                default:
                    throw new SGException("Don't know how to create packet of type 0x{0:X}, data.Length={1}", type, data.Length);
            }

            packet.ReadBytes(data);
            return packet;
        }

    }

    public class SecMsgSgToXbChal : SecMsgHeader
    {
        public const int ChallengeFlagBitType = 0x00000001;   // 0=>HV, 1=>SV
        public const int ChallengeFlagBitSize = 0x00000002;   // 0=>Small, 1=>Large

        /// <summary>
        /// Returns whether or not the flags indicate that the challenge can be used
        /// for the key exchange challenge or not
        /// </summary>
        public static bool ChallengeFlagKeyexSafe(uint ChallengeFlags)
        {
            return (ChallengeFlags & 0x3) == 0 ? true : false;
        }

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL;
        //public short                    cbEnt           = (short)SIZE;
        public uint ChallengeNonce = 0;
        public uint ChallengeFlags = 0;
        [WireInfo(ArraySize = 16)]
        public byte[] Params = new byte[16];     // Challenge parameters
        [WireInfo(ArraySize = 256)]
        public byte[] PkSig = new byte[256];    // Digest of the rest of this entry

        // The rest of this entry is filled with challenge code that needs to be run
        // on the challenged xbox.  The challenge consists of the PkSig field above plus 
        // whatever spills into this section.  It may be 0.
        // Thus PkSig + ChalCode will either be a SupervisorChallenge or a HypervisorChallenge.

        [WireInfo(ArraySize = 0)]
        public byte[] ChalCode = null;

        public new const int SIZE = SecMsgHeader.SIZE + 280;
        public SecMsgSgToXbChal()
            : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL, SIZE)
        {
        }

        public override string ToString()
        {
            return String.Format("[SgToXbChal] Nonce=0x{0:X8}, Flags=0x{1:X}, Params=0x{2}, ChalSize={3} ({4} extra)",
                ChallengeNonce,
                ChallengeFlags,
                Hexer.tohex(Params),
                cbEnt - 28,
                cbEnt - SIZE);
        }

        public bool IsLargeSupervisorChallenge()
        {
            return (ChallengeFlags & 0x3) == 0x3;
        }

        public LargeSupervisorChallenge GetLargeSupervisorChallenge()
        {
            if (!IsLargeSupervisorChallenge())
                return null;
            return new LargeSupervisorChallenge(PkSig, ChalCode);
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            this.ChallengeNonce = (uint)br.ReadInt32();
            this.ChallengeFlags = (uint)br.ReadInt32();
            this.Params = (byte[])br.ReadBytes(16);
            this.PkSig = (byte[])br.ReadBytes(256);

            int remaining = this.cbEnt - SIZE;
            if (remaining > 0)
            {
                this.ChalCode = (byte[])br.ReadBytes(remaining);
            }

            return this;
        }
    }

    public class LargeSupervisorChallenge
    {
        public byte[] PkSig;              // 256 bytes
        public short Version;
        public short Size;
        public short ChalId;
        public short ChalVer;
        public int ChalSize;
        public int Context;

        public const int SIZE = 272;

        /// <summary>
        /// Allows for easy conversion from the way the challenge is stored in the input
        /// packet to a handy SupervisorChallenge structure.
        /// </summary>
        public LargeSupervisorChallenge(byte[] PkSig, byte[] ChalCode)
        {
            //System.Diagnostics.Debug.Assert(PkSig.Length == 256, "PkSig should be 256 bytes long");
            System.Diagnostics.Debug.Assert(ChalCode.Length >= 16, "ChalCode should be >= 16 bytes long");

            this.PkSig = PkSig;

            BinaryReader br = new BinaryReader(new MemoryStream(ChalCode));
            this.Version = br.ReadInt16();
            this.Size = br.ReadInt16();
            this.ChalId = br.ReadInt16();
            this.ChalVer = br.ReadInt16();
            this.ChalSize = br.ReadInt32();
            this.Context = br.ReadInt32();
        }

        public override string ToString()
        {
            return String.Format("[LargeSupervisorChal] Version={0}, Size={1}, ChalId=0x{2:X8}, ChalVer=0x{3:X}, ChalSize={4}, Context={5}",
                Version,
                Size,
                ChalId,
                ChalVer,
                ChalSize,
                Context);
        }
    }

    public class SecMsgXbToSgChalResp2 : SecMsgHeader
    {
        // The number of valid bytes in the packet can be determined by looking for the 
        // first non-zero byte from the end of the array.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP_2 ;
        //public short                    cbEnt           = (short)SIZE;
        public uint ChallengeNonce = 0;
        [WireInfo(ArraySize = 1024)]
        public byte[] Execute = null;    // 1024 byte answer from the client

        public new const int SIZE = SecMsgHeader.SIZE + 1028;
        public SecMsgXbToSgChalResp2()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP_2, SIZE)
        {
            ManualArraySize = true;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            if (Execute == null)
                Execute = new byte[1024];
            base.WriteStream(bw);
        }
    }

    public class SecMsgXbToSgChalAck : SecMsgHeader
    {
        // This packet is sent from the client to the server in order to acknowledge that a 
        // challenge with _dwSeqAck sequence number has been received. If the server does not 
        // receive this message in a timely fashion, it will resend the challenge.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHAL_ACK ;
        //public short                    cbEnt           = (short)SIZE;
        public uint ChallengeNonce = 0;

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgXbToSgChalAck()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHAL_ACK, SIZE)
        {
        }
    }

    public class SecMsgSgToXbChalRespAck : SecMsgHeader
    {
        // This packet is sent from the server to the client in oder to acknowledge that a 
        // challenge response with _dwSeqAck sequence number has been received. If the client 
        // does not receive this message in a timely fashion, it will resend the challenge response.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK;
        //public short                    cbEnt           = (short)SIZE;
        public uint ChallengeNonce = 0;

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgSgToXbChalRespAck()
            : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK, SIZE)
        {
        }
    }

    //[StructLayout(LayoutKind.Sequential, Pack=1)]
    public class SecMsgQosInit : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize = 8)]
        public byte[] Nonce = new byte[8]; //AuthUtils.GetNewNonce(); // Nonce assigned by the initiator (8 bytes)
        public ushort QosIdx = 0;            // Index assigned by the initiator
        public byte PktIdx = 0;            // Packet sequence number
        public byte Flags = 0;            // See QPF_* above

        public new const int SIZE = SecMsgHeader.SIZE + 12;
        public SecMsgQosInit()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT, SIZE)
        {
        }

        public override void WriteStream(BinaryWriter bw)
        {
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            bw.Write(Nonce);
            bw.Write(QosIdx);
            bw.Write(PktIdx);
            bw.Write(Flags);

            byte[] arr = new byte[16] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            for (int i = SIZE, j = (int)cbEnt; i < j; i += 16)
            {
                bw.Write(arr, 0, (j > i + 16 ? 16 : j - i));
            }
        }
    }

    public class SecMsgQosResp : SecMsgHeader
    {
        // This is a response packet, let's not assign the correct values; instead, verify what gets returned.
        //public short                    Type            = 0;            // SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT;
        //public short                    cbEnt           = 0;            // (short)SIZE;
        [WireInfo(ArraySize = 8)]
        public byte[] Nonce = new byte[8];  // Nonce assigned by the initiator (8 bytes)
        public ushort QosIdx = 0;            // Index assigned by the initiator
        public byte PktIdx = 0;            // Packet sequence number
        public byte Flags = 0;            // See QPF_* above
        public uint Rtt = 0;            // Time between recv of xmit of corresponding pkt in pair
        public uint Gap = 0;            // Time between recv of pkt1 and pkt2 (less traffic)

        public new const int SIZE = SecMsgHeader.SIZE + 20;
        public SecMsgQosResp()
            : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP, SIZE)
        {
        }

        // The rest of this entry contains the Qos data (if QPF_DATA_REP)

        public override string ToString()
        {
            return String.Format("QosResponse: nonce={0:X}, qosidx={1}, pktidx={2}, rtt={3}, gap={4}, flags={5:X}",
                                 Hexer.tohex(Nonce),
                                 QosIdx,
                                 PktIdx,
                                 Rtt,
                                 Gap,
                                 Flags);
        }
    }

    public class SecMsgPulse : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_PULSE;
        //public short                    cbEnt           = (short)SIZE;

        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgPulse()
            : base(SecMsgHeader.SECMSG_TYPE_PULSE, SIZE)
        {
        }
    }

    public class SecMsgDataPulse : SecMsgHeader
    {
        // Definitions -----------------------------------------------------------------------

        public const int XBPULSE_STATE_CHANGE = 0x01;         // dwUserState changed
        public const int XBPULSE_XNKID_CHANGE = 0x02;         // xnkidSession changed
        public const int XBPULSE_TDATA_CHANGE = 0x04;         // abTitleData changed
        public const int XBPULSE_TITLE_CHANGE = 0x08;         // dwTitleId changed

        // Data ------------------------------------------------------------------------------
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_PULSE;
        //public short                    cbEnt           = (short)SIZE;
        public uint SeqAck = 0;            // Acknowledgement sequence number

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDataPulse()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_PULSE, SIZE)
        {
        }

        // The rest of this entry is filled with a padded series of changes.
        //
        // Byte 0    - change type
        // Byte 1-8  - user PUID
        //
        // Type XBPULSE_STATE_CHANGE:
        // Byte 9-12 - new state
        //
        // Type XBPULSE_XNKID_CHANGE:
        // Byte 9-16 - new XNKID
        //
        // Type XBPULSE_TDATA_CHANGE:
        // Byte 9    - size in bytes of title data
        // Byte 10-x - new title data
        //
        // Type XBPULSE_TITLE_CHANGE:
        // Byte 9-12 - new title ID
    }

    public class SecMsgDataPulse_TitleChange : SecMsgDataPulse
    {
        public byte ChangeType = SecMsgDataPulse.XBPULSE_TITLE_CHANGE;
        public ulong UserPuid = 0;
        public uint TitleId = 0;

        public new const int SIZE = SecMsgDataPulse.SIZE + 9 + 4;
        public SecMsgDataPulse_TitleChange()
        {
            this.cbEnt = SIZE;
        }
    }

    public class SecMsgDataPulse_StateChange : SecMsgDataPulse
    {
        public byte ChangeType = SecMsgDataPulse.XBPULSE_STATE_CHANGE;
        public ulong UserPuid = 0;
        public uint State = 0;

        public new const int SIZE = SecMsgDataPulse.SIZE + 9 + 4;
        public SecMsgDataPulse_StateChange()
        {
            this.cbEnt = SIZE;
        }
    }

    public class SecMsgDataPulseResp : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2;
        //public short                    cbEnt           = (short)SIZE;
        public uint SeqAck = 0;            // Acknowledgement sequence number

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDataPulseResp()
            : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2, SIZE)
        {
        }

        // The rest of this entry contains a series of _qwUserId / CQVal-list pairs.
        // The end of the CQVal list specified by a zero DWORD or the end of this
        // entry, whichever comes first.
    }

    public class SecMsgDelete : SecMsgHeader
    {
        // Reasons for Delete
        public const int SHUTDOWN = 0x0000;   // Client is shutting down or logging off 
        public const int UNREGISTER = 0x0001;   // Client unregistered key
        public const int KICK = 0x0002;   // Client has been kicked for duplicate logon
        public const int QOS = 0x0003;   // Client finished Qos lookup
        public const int KILL = 0x0004;   // Server is terminating the session

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_DELETE;
        //public short                    cbEnt           = (short)SIZE;
        public uint Reason = 0;

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDelete()
            : base(SecMsgHeader.SECMSG_TYPE_DELETE, SIZE)
        {
        }
    }

    public class SecMsgChangeUsersReq : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REQ;
        //public short                    cbEnt           = (short)SIZE;
        public uint UserPerm = 0;            // Permutation and guest bits for all 4 users
        public long Time = 0;            // Kerberos time of AP request

        // The rest of this entry contains the Kerberos AP request.

        [WireInfo(WriteOnlyVarLenString = true)]
        public byte[] APReqData = new byte[0];  // Kerberos AP request

        public int CURRENT_SIZE
        {
            get
            {
                return SecMsgHeader.SIZE + 12 + APReqData.Length;
            }
        }

        public SecMsgChangeUsersReq()
            : base(SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REQ, SIZE)
        {
        }

        //we override these so we can fix the packet length to the correct field just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbEnt = (short)(CURRENT_SIZE);
            base.WriteStream(binaryWriter);
        }
    }

    public class SecMsgChangeUsersRep : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP;
        //public short                    cbEnt           = (short)SIZE;
        public long Time = 0;            // Kerberos time of AP request

        public new const int SIZE = SecMsgHeader.SIZE + 8;
        public SecMsgChangeUsersRep()
            : base(SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP, SIZE)
        {
        }
    }

    public class SecMsgXbToSgChalResp : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize = 20)]
        public byte[] DvdHash = new byte[20];     // Hash of part of DVD block
        [WireInfo(ArraySize = 20)]
        public byte[] DvdCopy = new byte[20];     // Copy of part of DVD block
        [WireInfo(ArraySize = 256)]
        public byte[] Execute = new byte[256];     // Result of executing the challenge code

        public new const int SIZE = SecMsgHeader.SIZE + 296;
        public SecMsgXbToSgChalResp()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP, SIZE)
        {
            ManualArraySize = true;
        }
    }

    public class SecMsgNatDetReq : SecMsgHeader
    {
        // no payload
        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgNatDetReq()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_NATDET_REQ, SIZE)
        {
        }
    }

    public class SecMsgNatDetRep : SecMsgHeader
    {
        // no payload
        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgNatDetRep()
            : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP, SIZE)
        {
        }
    }

    public class SecMsgXbToXbForward : SecMsgHeader
    {
        public SGAddress sgaddr = new SGAddress();

        // The rest of this entry contains the actual message being forwarded
        [WireInfo(ArraySize = 0)]
        public byte[] message = null;

        public new const int SIZE = SecMsgHeader.SIZE + SGAddress.SIZE;
        public SecMsgXbToXbForward()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            sgaddr.ReadStream(br);

            int remaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            int messageLength = cbEnt - 4 - 20;  // the header + the SGADDR
            System.Diagnostics.Debug.Assert(messageLength <= remaining);
            message = br.ReadBytes(messageLength);

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            base.cbEnt = (short)(SIZE + (message != null ? message.Length : 0));
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            sgaddr.WriteStream(bw);

            if (message != null && message.Length > 0)
            {
                bw.Write(message);
            }

        }
    }

    public class SecMsgXbToXbForward2 : SecMsgHeader
    {
        public SGAddress sgaSender = new SGAddress();
        public SGAddress sgaTarget = new SGAddress();

        // The rest of this entry contains the actual message being forwarded
        [WireInfo(ArraySize = 0)]
        public byte[] message = null;

        public new const int SIZE = SecMsgHeader.SIZE + (SGAddress.SIZE * 2);
        public SecMsgXbToXbForward2()
            : base(SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2, SIZE)
        {
        }

        public void SetMessage(byte[] payload)
        {
            message = payload;
            if (message != null)
            {
                this.cbEnt = (short)(SIZE + message.Length);
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            sgaSender.ReadStream(br);
            sgaTarget.ReadStream(br);

            int remaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            int messageLength = cbEnt - 4 - 40;  // the header + the 2*SGADDR
            System.Diagnostics.Debug.Assert(messageLength <= remaining);
            message = br.ReadBytes(messageLength);

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            //base.cbEnt = (short)(SIZE + (message != null ? message.Length : 0));
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            sgaSender.WriteStream(bw);
            sgaTarget.WriteStream(bw);

            if (message != null && message.Length > 0)
            {
                bw.Write(message);
            }
        }
    }






    #endregion


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\DownloadHistoryScene.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class DownloadHistoryScene : BasicScene
    {
        private EnumeratedContentHistoryItems _historyItems;
        public List<ContentHistoryItem> DownloadedItems
        {
            get
            {
                return _historyItems.ContentHistoryItems;
            }
        }

        public DownloadHistoryScene(LfmState lfmState, BasicScene prevScene)
            : base(lfmState, prevScene)
        {
        }

        /// <summary>
        /// /xbos/XeContentHistoryEnumerate.ashx
        /// /xbos/XeContentHistoryEnumerate.ashx
        /// </summary>
        internal override BasicScene Activate()
        {
            ContentHistoryEnumerateFilter historyFilter = new ContentHistoryEnumerateFilter();
            historyFilter.OfferType = OfferingTypeEnum.Content | OfferingTypeEnum.GameDemo | 
                OfferingTypeEnum.GameTrailer | OfferingTypeEnum.Theme | OfferingTypeEnum.FullGame | 
                OfferingTypeEnum.Tile | OfferingTypeEnum.Tile | OfferingTypeEnum.Arcade | 
                OfferingTypeEnum.Video | OfferingTypeEnum.SyncCastWMIS;
            historyFilter.MaxResults = 1000;
            _historyItems = Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);

            // Spring 07 makes this call twice, first for 1000 max results and then again for 10.
            // RequestFlags was confirmed 0 in both cases.  We'll just keep the results of the first call
            // and disregard the results of this one
            historyFilter.MaxResults = 10;
            Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);

            return this;
        }

        public HUD.DownloadedContentItemScene SelectDownloadedItem(ContentHistoryItem contentItem)
        {
            HUD.DownloadedContentItemScene scene = new HUD.DownloadedContentItemScene(_lfmState, this, contentItem);
            return (HUD.DownloadedContentItemScene)scene.Activate();
        }

        public HUD.DownloadedContentItemScene SelectRandomItem()
        {
            if (_historyItems.TotalCount == 0)
            {
                throw new Exception("There are no history content items to select from.");
            }
            int itemIndex = Randomizer.Random.Next((int)_historyItems.TotalCount);
            ContentHistoryItem contentItem = _historyItems.ContentHistoryItems[itemIndex];
            HUD.DownloadedContentItemScene scene = new HUD.DownloadedContentItemScene(_lfmState, this, contentItem);
            return (HUD.DownloadedContentItemScene)scene.Activate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\GenreScene.cs ===
using System;
using System.Collections.Generic;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class GenreScene : BasicScene
    {
        private Genre _genre;

        public Genre Details
        {
            get
            {
                return _genre;
            }
        }

        public GenreScene(LfmState lfmState, SceneBase previousScene, Genre genre)
            : base(lfmState, previousScene)
        {
            _genre = genre;
        }

        /// <summary>
        /// /xbos/XeEnumerateTitlesByFilter.ashx
        /// For each item (and cache):
        ///     /stfd/resolvename.ashx
        ///     /stfd/readfile.ashx
        /// and (possibly out of order with above 2 calls):
        ///     /xbos/XeGetTitleDetails.ashx
        /// </summary>
        internal override BasicScene Activate()
        {
            TitleEnumerateFilter filter = new TitleEnumerateFilter(_lfmState.ActiveUser);
            filter.genreId = _genre.Id;
            _titles = live.server.Billing.XeEnumerateTitlesByFilter(_client, _user, filter);
            foreach (TitleInfo titleInfo in _titles.Titles)
            {
                //TODO: /stfd/resolvename.ashx
                //TODO: /stfd/readfile.ashx
                TitleDetails details = Billing.XeGetTitleDetails(_client, _user, titleInfo.titleId);
            }
            return this;
        }

        private EnumeratedTitles _titles;
        public List<TitleInfo> AvailableTitles
        {
            get
            {
                return _titles.Titles;
            }
        }

        public TitleContentsScene SelectTitle(TitleInfo titleInfo)
        {
            TitleContentsScene scene = new TitleContentsScene(_lfmState, this, titleInfo);
            return (TitleContentsScene)scene.Activate();
        }

        public TitleContentsScene SelectRandomTitle()
        {
            int randVal = Randomizer.Random.Next((int)_titles.ReturnedCount);
            TitleInfo randTitle = _titles.Titles[randVal];
            return SelectTitle(randTitle);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\GenresScene.cs ===
using System;
using System.Collections.Generic;

using live.common;

namespace live.lfm.xbox360Internal
{
    public class GenresScene : DynamicScene
    {
        private EnumeratedGenres _results;

        public GenresScene(LfmState lfmState, BasicScene previousScene)
            : base(lfmState, previousScene)
        {
        }

        public GenreScene CreateScene(Genre genre)
        {
            return new GenreScene(_lfmState, this, genre);
        }

        public GenreSceneSelector Genre
        {
            get
            {
                return new GenreSceneSelector(this);
            }
        }

        public List<Genre> AvailableGenres
        {
            get
            {
                return _results.Genres;
            }
        }

        public GenreScene RandomGenre
        {
            get
            {
                int i = Randomizer.Random.Next((int)_results.ReturnedCount);
                return new GenreSceneSelector(this)[_results.Genres[i]];
            }
        }

        /// <summary>
        /// /xbos/XeEnumerateGenres.ashx
        /// </summary>
        internal override BasicScene Activate()
        {
            //BUGBUG: This code is horribly flawed, overwriting results and tracking max count wrong
            // if there is more than 1 maxCount worth of Genres
            GenreEnumerateFilter filter = new GenreEnumerateFilter(_lfmState.ActiveUser);
            do
            {
                _results = live.server.Billing.XeEnumerateGenres(_client, _user, filter);
            } while (_results.Genres.Count == filter.maxCount);
            return this;
        }
    }

    public class GenreSceneSelector : SceneSelector<Genre, GenreScene>
    {
        private GenresScene _genresScene;

        internal GenreSceneSelector(GenresScene genresScene)
        {
            _genresScene = genresScene;
        }

        public override GenreScene CreateScene(Genre genre)
        {
            return _genresScene.CreateScene(genre);
        }

        public override GenreScene this[Genre genre]
        {
            get
            {
                // Verify the genre is available
                if (_genresScene.AvailableGenres.FindIndex(delegate(Genre knownGenre)
                { return knownGenre.Id == genre.Id; }) == -1)
                {
                    throw new Exception("Genre " + genre.GenreName +
                        " was not found in the list of available genres.");
                }

                GenreScene scene = base.GetScene(genre);
                return (GenreScene)scene.Activate();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\TitleContentsScene.cs ===
using System;
using System.Collections.Generic;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class TitleContentsScene : BasicScene
    {
        private TitleInfo _titleInfo;

        private EnumeratedContentItems _contentItems;
        public List<ContentItem> AvailableContent
        {
            get
            {
                return _contentItems.Infos;
            }
        }

        public TitleContentsScene(LfmState lfmState, BasicScene prevScene, TitleInfo titleInfo)
            : base(lfmState, prevScene)
        {
            _titleInfo = titleInfo;
        }

        /// <summary>
        /// /xbos/XeContentHistoryEnumerate.ashx
        /// /xbos/XeContentEnumerate2.ashx
        /// /xbos/XeContentUpdateAccessTimes.ashx [Once per title, no matter how many genres it appears in]
        ///
        /// [Automatically on first piece of content]
        /// /stfd/resolvename.ashx [cached until logout]
        /// /stfd/readfile.ashx [cached until logout]
        /// </summary>
        internal override BasicScene Activate()
        {
            //2007/08/06 21:58:30.123|XeContentHistoryEnumerate|0|15380454279432707254|9030c44aba1b8|103|1|158434|0|0|1000|1|1
            ContentHistoryEnumerateFilter historyFilter = new ContentHistoryEnumerateFilter();
            historyFilter.OfferType = OfferingTypeEnum.Content | OfferingTypeEnum.GameDemo |
                OfferingTypeEnum.GameTrailer | OfferingTypeEnum.Theme | OfferingTypeEnum.FullGame |
                OfferingTypeEnum.Tile | OfferingTypeEnum.Trial | OfferingTypeEnum.Arcade |
                OfferingTypeEnum.Video | OfferingTypeEnum.SyncCastWMIS;
            historyFilter.MaxResults = 1000;
            EnumeratedContentHistoryItems items = Billing.XeContentHistoryEnumerate(_client, _user, historyFilter);

            ContentEnumerateFilter filter = new ContentEnumerateFilter();
            filter.OfferType = OfferingTypeEnum.Content | OfferingTypeEnum.GameDemo |
                OfferingTypeEnum.GameTrailer | OfferingTypeEnum.Theme | OfferingTypeEnum.FullGame |
                OfferingTypeEnum.Tile | OfferingTypeEnum.Trial | OfferingTypeEnum.Arcade;
            filter.TitleID = _titleInfo.titleId;
            filter.MaxResults = 30;
            //TODO: Loop reading content until all read
            _contentItems = Billing.XeContentEnumerate2(_client, _user, filter);

            //TODO: Once ever per title per session, no matter where else it may appear
            Billing.XeContentUpdateAccessTimes(_client, _user, _titleInfo.titleId, 0xFFFFFFFF);

            // Automatically on first piece of content
            if (_contentItems.Infos.Count > 0)
            {
                DisplayContentItem(_contentItems.Infos[0]);
            }
            return this;
        }

        /// <summary>
        /// /stfd/resolvename.ashx [cached until logout]
        /// /stfd/readfile.ashx [cached until logout]
        /// </summary>
        private void DisplayContentItem(ContentItem contentItem)
        {
            if (!_lfmState.ContentItemsDisplayed.Contains(contentItem.offerID))
            {
                //TODO: /stfd/resolvename.ashx
                //TODO: /stfd/readfile.ashx
                _lfmState.ContentItemsDisplayed.Add(contentItem.offerID);
            }
        }

        /// <summary>
        /// "Scrolls" down past and displays each content item until the desired content item is reached
        /// and returns a content purchasing scene for that item
        /// </summary>
        public HUD.ContentItemPurchaseScene SelectContentItem(ContentItem contentItem)
        {
            foreach (ContentItem compareItem in _contentItems.Infos)
            {
                DisplayContentItem(compareItem);
                if (compareItem == contentItem)
                {
                    HUD.ContentItemPurchaseScene scene = new HUD.ContentItemPurchaseScene(_lfmState, this, contentItem);
                    return (HUD.ContentItemPurchaseScene)scene.Activate();
                }
            }
            throw new Exception("Unknown content item with ID " + contentItem.offerID);
        }

        public HUD.ContentItemPurchaseScene SelectRandomContentItem()
        {
            ContentItem randomItem;
            do
            {
                int randomIndex = Randomizer.Random.Next((int)_contentItems.Infos.Count);
                randomItem = _contentItems.Infos[randomIndex];
            } while (randomItem.tierRequired > (byte)_lfmState.ActiveUser.Settings.UserType);
            
            Logging.WriteLine("Randomly selected: " + randomItem.ToString());
            return SelectContentItem(randomItem);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\MarketplaceInternal.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.lfm;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class MarketplaceGlobals
    {
        public AccountMgmtGlobals accMgmtGlobals = new AccountMgmtGlobals();
    }

    public class MarketplaceScene : BladeScene
    {
        public AccountMgmtScene AccountMgmt;

        public GamesInternal Games;

        public VideoStore VidStore;

        public MarketplaceScene(LfmState lfmState)
            : base(lfmState)
        {
            AccountMgmt = new AccountMgmtScene(lfmState);
            Games = new GamesInternal(lfmState, this);
            VidStore = new VideoStore(lfmState, this);
        }

        /// <summary>
        /// This is a stub and needs to be rewritten.
        /// </summary>
        public void Browse()
        {
            METHOD.ENTER();
            //Billing.Browse(_client, user);
            Billing.GetRevocationList(_lfmState.Client, _lfmState.ActiveUser);
            METHOD.EXIT();
        }

        /// <summary>
        /// Creates a prepaid points redemption scene.
        /// </summary>
        /// <param name="offer">A valid prepaid points offer.</param>
        /// <returns>A Prepaid redemption scene.</returns>
        public HUD.RedeemCodeScene RedeemMSPointsCode(Offers.PointsOffers offer, string voucher)
        {
            if (Offers.IsCreditCardRequired(offer))
            {
                throw new Exception("RedeemCode can only be called with prepaid offers.  Offer " + offer +
                    " requires a credit card.");
            }

            HUD.RedeemCodeScene scene = new HUD.RedeemCodeScene(_lfmState, this, voucher);
            return (HUD.RedeemCodeScene)scene.Activate();
        }

        /// <summary>
        /// Creates a prepaid Subscription redemption scene.
        /// </summary>
        /// <param name="offer">A valid prepaid Subscription offer.</param>
        /// <returns>A Prepaid redemption scene.</returns>
        public HUD.RedeemCodeScene RedeemSubscriptionCode(Offers.BaseOffers offer, string voucher)
        {
            if (!Offers.IsPrepaidOffer(offer))
            {
                throw new Exception("RedeemSubscriptionCode can only be called with prepaid offers.  Offer " + offer +
                    " requires a credit card.");
            }

            HUD.RedeemCodeScene scene = new HUD.RedeemCodeScene(_lfmState, this, voucher);
            return (HUD.RedeemCodeScene)scene.Activate();
        }

        /// <summary>
        /// Creates a prepaid Subscription redemption scene.
        /// </summary>
        /// <param name="offer">A valid prepaid Subscription offer.</param>
        /// <returns>A Prepaid redemption scene.</returns>
        public HUD.PurchaseOfferWithCCScene PurchasePoints(Offers.PointsOffers offer)
        {
            if (!Offers.IsCreditCardRequired(offer))
            {
                throw new Exception("PurchasePoints can only be called with Creditcard offers.  Offer " + offer +
                    " requires a Prepaid  token.");
            }

            HUD.PurchaseOfferWithCCScene scene = new HUD.PurchaseOfferWithCCScene(_lfmState, this, Offers.GetOfferId(offer));
            return (HUD.PurchaseOfferWithCCScene)scene.Activate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\AccountMgmtInternal.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.common;
using live.server;
using live.protocol;

using ServerTestFramework;


namespace live.lfm.xbox360Internal
{

    public class AccountMgmtGlobals
    {
        public CurrentSubscriptionsScene currentSubs = null;
        public CurrentSubscriptionScene currentSubDetail = null;
        public  SubscriptionsScene  newSubcriptions= null;
        public SubscriptionScene selectedSubscription = null;
        public PaymentOptionsScene paymentOptions = null;
        public PaymentInstrumentScene selectedPaymentInstrument = null;

        public void Clear()
        {
            currentSubs = null;
            currentSubDetail = null;
            newSubcriptions= null;
            selectedSubscription = null;
            paymentOptions = null;
            selectedPaymentInstrument = null;
        }
    }

    public class AccountMgmtScene : BasicScene
    {
        private readonly UpdatePersonalInfoScene _updatePersonalInfoScene;
        private readonly CurrentSubscriptionsScene __currentsubscriptionsScene;
        private readonly SubscriptionsScene _subscriptionsScene;
        private readonly PaymentOptionsScene _paymentOptions;
        private readonly DownloadHistoryScene _downloadHistoryScene;
        private readonly VerifyDefaultPrivilegesScene _verifyDefaultPrivilegesScene;

        public UpdatePersonalInfoScene PersonalInfoScene
        {
            get
            {
                return _updatePersonalInfoScene.Activate();
            }
        }

        public VerifyDefaultPrivilegesScene DefaultPrivilegesScene
        {
            get
            {
                return _verifyDefaultPrivilegesScene.Activate();
            }
        }

        public CurrentSubscriptionsScene ViewCurrentSubscriptionsScene
        {
            get
            {
                return __currentsubscriptionsScene.Activate();
            }
        }

        public SubscriptionsScene ViewSubscriptionsScene
        {
            get
            {
                return _subscriptionsScene.Activate();
            }
        }

        public PaymentOptionsScene ViewPaymentOptionsScene
        {
            get
            {
                return _paymentOptions.Activate();
            }
        }

        public DownloadHistoryScene DownloadHistory
        {
            get
            {
                return (DownloadHistoryScene)_downloadHistoryScene.Activate();
            }
        }

        public AccountMgmtScene(LfmState lfmState)
            : base(lfmState, null)
        {
            _updatePersonalInfoScene = new UpdatePersonalInfoScene(_lfmState);
            _subscriptionsScene = new SubscriptionsScene(_lfmState);
            __currentsubscriptionsScene = new CurrentSubscriptionsScene(_lfmState);
            _paymentOptions = new PaymentOptionsScene(_lfmState);
            _downloadHistoryScene = new DownloadHistoryScene(_lfmState, this);
            _verifyDefaultPrivilegesScene = new VerifyDefaultPrivilegesScene(_lfmState);
        }
    }

    public class PaymentOptionsScene : BasicScene
    {
        public PaymentInstrumentSelector PISelector = null;
         public PaymentOptionsScene(LfmState lfmState)
            : base(lfmState,null)
        {
        }

        internal new PaymentOptionsScene Activate()
        {
            PaymentInstrumentInfoEx[] PaymentInstruments = UACS.XeGetPaymentInstruments2(_lfmState.Client, _lfmState.ActiveUser, 5);
            PISelector = new PaymentInstrumentSelector(_lfmState, PaymentInstruments);
            return this;
        }

        public void AddPaymentInstrument(CreditCardInfo cc)
        {
             int retires = 4;

            do
            {
                try
                {
                    METHOD.ENTER();
                    UACS.XeAddPaymentInstrument(_client, _user, cc);                   
                    METHOD.EXIT();                    
                    break;
                }
                catch (Exception e)
                {
                    Global.RO.Error(e.Message + "\r\n" + e.StackTrace);

                    if (e is XErrFailedException)
                    {
                        //if we get exception when trying to add PI and the exception returned is XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT,
                        //need to get the active PI by calling services because this info is not stored anywhere except on billing one box.
                        //Live lib also requires to link the PI to user account in order to pass the PI to xeofferpurchase call.  
                        if (e != null && ((XErrFailedException)e).HResult == HResult.XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT)
                        {
                            Global.RO.Warn("Assuming PI is already added on onebox, try to get the PI");

                            string[] PIs = UACS.XeGetPaymentInstruments(_client, _user, 1);
                            if (PIs.Length > 0)
                            {
                                Global.RO.Warn("Get PI: " + PIs[0]);
                                _user.Settings.BillingInfo.AddCreditCard(cc);
                                cc.PaymentInstrumentId = PIs[0];
                                break;
                            }                                          
                        }
                    }

                    if (retires < 1) throw e;
                    Global.RO.Warn("Sleep 60 seconds before retry");
                    System.Threading.Thread.Sleep(60 * 1000);
                    retires--;
                }
            } while (true);     
        }

        public void AddPaymentInstrument(DirectDebitInfo dd)
        {
            METHOD.ENTER();
            UACS.XeAddPaymentInstrument(_client, _user, dd);
            METHOD.EXIT();
        }
    }

    public class PaymentInstrumentSelector
    {
        private LfmState _lfmState;
        private Dictionary<int, PaymentInstrumentScene> PaymentInstrumentsCache = new Dictionary<int, PaymentInstrumentScene>();

        public PaymentInstrumentSelector(LfmState lfmState, PaymentInstrumentInfoEx[] PaymentInstruments)
        {
            _lfmState = lfmState;
            int i = 0;
            if (PaymentInstruments != null)
            {
                foreach (PaymentInstrumentInfoEx PI in PaymentInstruments)
                {
                    PaymentInstrumentsCache.Add(i++, new PaymentInstrumentScene(_lfmState, PI));
                }
            }
        }

        public int Count()
        {
            return PaymentInstrumentsCache.Count;
        }
        public PaymentInstrumentScene this[int Index]
        {
            get
            {
               
                return PaymentInstrumentsCache[Index].Activate();
            }
        }
    }

    public class PaymentInstrumentScene : BasicScene
    {
        private PaymentInstrumentInfoEx _paymentInstrument;

        public PaymentInstrumentInfoEx PaymentInstrument
        {
            get { return _paymentInstrument; }
        }

        public PaymentInstrumentScene(LfmState lfmState, PaymentInstrumentInfoEx PI)
            :base(lfmState,null)
        {
            _paymentInstrument = PI;
        }

        internal new PaymentInstrumentScene Activate()
        {
            return this;
        }

        public void Update(CreditCardInfo cc)
        {
            cc.PaymentInstrumentId = _paymentInstrument.paymentInstrumentId;
            UACS.XeUpdatePaymentInstrument(_client, _user, cc);
        }

        public void Remove()
        {
            UACS.XeRemovePaymentInstrument(_client, _user, _paymentInstrument.paymentInstrumentId);
        }
    }


    public class UpdatePersonalInfoScene : BasicScene
    {
        public UpdatePersonalInfoScene(LfmState lfmState)
            : base(lfmState,null)
        {
        }

        internal new UpdatePersonalInfoScene Activate()
        {
            uint publicKeyPublicExponent;
            byte[] publicKeyModulus;
            byte[] publicKeyDigest;
            string loginTokenRequest;

            string Membername = UACS.XePassportGetMemberName(_client, _user.Puid);
            UACS.XePassportGetEncryptedProxyParameters(_lfmState.Client, out publicKeyPublicExponent, out publicKeyModulus, out publicKeyDigest, out loginTokenRequest);
            _lfmState.ActiveUser.Settings.UserPassportInfo.SessionToken = UACS.XePassportLogin(_lfmState.Client, _lfmState.ActiveUser.Settings.UserPassportInfo);
           return this;
        }

        public void UpdateInfo(PersonalInfo PInfo)
        {
            UACS.XeGetAccountInfo(_client, _user.Puid);
            PInfo.Gamertag = _lfmState.ActiveUser.Settings.PersonalInfo.Gamertag;
            UACS.XeSetAccountInfo(_client, _user, PInfo);
            _lfmState.ActiveUser.Settings.PersonalInfo = PInfo;
        }
    }

    public class VerifyDefaultPrivilegesScene : BasicScene
    {
        private UserWebInfo _webInfo;
                
        public VerifyDefaultPrivilegesScene(LfmState lfmState)
            : base(lfmState, null)
        {
        }

        internal new VerifyDefaultPrivilegesScene Activate()
        {
            //PersonalInfo pi = UACS.XeGetAccountInfo(_client, _user.Puid);
            _client.TitleId = XOn.WEB_TITLE_ID;
            _webInfo = UACS.XeGetUserWebInfo(_client, _user);
            return this;
        }

        public void VerifyPrivileges()
        {
            Privileges privs = _webInfo.Privileges;
            Privileges defaultPrivs = Privileges.GetGoldDefaults();

            for (int i = XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if (privs.Get((Privilege)i) != defaultPrivs.Get((Privilege)i))
                {
                    throw new Exception(String.Format("Verify Privilege {0} Failed! Expected: {1}, Actual: {2}"
                        , i, defaultPrivs.Get((Privilege)i), privs.Get((Privilege)i)));
                }
            }
        }
    }

    public class CurrentSubscriptionsScene : BasicScene
    {
        public CurrentSubscriptionSelector CurrentSubscriptions = null;

        public CurrentSubscriptionsScene(LfmState lfmState)
            : base(lfmState,null)
        {
        }

        internal new CurrentSubscriptionsScene Activate()
        {
            //TODO: /xuacs/XeGetUserSubscriptionDetails.ashx
           
            SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
            filter.OfferType = OfferingTypeEnum.Subscription;
            filter.QueryForCurrent= true;

            EnumeratedSubscriptions Subscriptions = Billing.XeSubscriptionEnumerate(_lfmState.Client, _lfmState.ActiveUser, filter);
            CurrentSubscriptions = new CurrentSubscriptionSelector(_lfmState, Subscriptions);
            
             return this;
        }
    }

    public class CurrentSubscriptionSelector
    {
        private LfmState _lfmState;
        private Dictionary<int, CurrentSubscriptionScene> SubscriptionCache = new Dictionary<int, CurrentSubscriptionScene>();

        public CurrentSubscriptionSelector(LfmState lfmState, EnumeratedSubscriptions Subscriptions)
        {
            _lfmState = lfmState;
            int i = 0;
            foreach (SubscriptionItem sitem in Subscriptions.Subscriptions)
            {
                SubscriptionCache.Add(i++, new CurrentSubscriptionScene(_lfmState, sitem));
            }
        }

        /// <summary>
        /// /xbos/XeSubscriptionEnumerate.ashx
        /// </summary>
        public int Count()
        {
            return SubscriptionCache.Count;
        }

        public CurrentSubscriptionScene this[int Index]
        {
            get
            {
               
                return SubscriptionCache[Index].Activate();
            }
        }
    }

    public class CurrentSubscriptionScene : BasicScene
    {
        private SubscriptionItem _subscription;
        public SubscriptionItem Subscription
        {
            get
            {
                return _subscription;
            }
        }

        private UserSubscriptionDetails _userSubdetails;
        public UserSubscriptionDetails UserSubscription
        {
            get
            {
                return _userSubdetails;
            }
        }

        public CurrentSubscriptionScene(LfmState lfmState, SubscriptionItem subscription)
            :base(lfmState,null)
        {
            
            _subscription = subscription;

        }

        internal new CurrentSubscriptionScene Activate()
        {
            ///xbos/XeSubscriptionDetails.ashx
            _subscription = Billing.XeSubscriptionDetails(_lfmState.Client, _lfmState.ActiveUser, _subscription.offerID);
            ///xuacs/XeGetUserSubscriptionDetails.ashx
            _userSubdetails = UACS.XeGetUserSubscriptionDetails(_lfmState.Client, _lfmState.ActiveUser, _subscription.offerID);
            return this;
        }
    }

    public class SubscriptionsScene : BasicScene
    {
        public SubscriptionSelector availableSubscription = null;

        public SubscriptionsScene(LfmState lfmState)
            : base(lfmState,null)
        {
            _lfmState = lfmState;
        }

        internal new SubscriptionsScene Activate()
        {
            //TODO: /xbos/XeSubscriptionEnumerate.ashx
            SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
            filter.OfferType = OfferingTypeEnum.Subscription;
            filter.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            filter.QueryForNew = true;
            filter.QueryForRenewals = true;
            filter.TierRequired = (byte)_lfmState.ActiveUser.Settings.UserType;
            filter.TitleID = 0xfffe07d1;
            
            EnumeratedSubscriptions Subscriptions = Billing.XeSubscriptionEnumerate(_lfmState.Client, _lfmState.ActiveUser, filter);
            availableSubscription = new SubscriptionSelector(_lfmState, Subscriptions);
            
            return this;
        }

    }

    public class SubscriptionSelector
    {
         private LfmState _lfmState;

         private Dictionary <int, SubscriptionScene> SubscriptionCache = new Dictionary<int, SubscriptionScene>();


        public SubscriptionSelector(LfmState lfmState, EnumeratedSubscriptions Subscriptions)
        {
            _lfmState = lfmState;
            int i = 0;
            foreach (SubscriptionItem sitem in Subscriptions.Subscriptions)
            {
                SubscriptionCache.Add(i++, new SubscriptionScene(_lfmState, sitem));
            }
        }

        /// <summary>
        /// /xbos/XeSubscriptionEnumerate.ashx
        /// </summary>

        public int Count()
        {
            return SubscriptionCache.Count;
        }
        public SubscriptionScene this[int Index]
        {
            get
            {
                return SubscriptionCache[Index].Activate();
            }
        }
    }

    public class SubscriptionScene : BasicScene
    {
       
        private SubscriptionItem _subscription;
        public SubscriptionItem Subscription
        {
            get
            {
                return _subscription;
            }
        }

        public SubscriptionScene(LfmState lfmState, SubscriptionItem subscription)
            :base(lfmState,null)
        {
            _subscription= subscription;
        }

        internal new SubscriptionScene Activate()
        {
            ///xbos/XeSubscriptionDetails.ashx
            _subscription = Billing.XeSubscriptionDetails(_lfmState.Client, _lfmState.ActiveUser, _subscription.offerID);
           
            return this;
        }

        public void ConfirmPurchase()
        {

            int retries = 2;

            METHOD.ENTER();
            XblUser user = _lfmState.ActiveUser;
            ulong offerId = _subscription.offerID;
            string paymentId;
                        
            while (retries > 0)
            {
                try
                {                      
                    PaymentInstrumentBase pib = user.Settings.BillingInfo.GetActivePaymentInstrument();
                    if (pib == null)
                    {
                        throw new Exception(" subscription purchase requires an active payment instrument.\r\n" +
                                "Use Settings.BillingInfo.SetActivePaymentInstrument() to specify one.");
                    }
                    paymentId  = pib.PaymentInstrumentId;
                                 
                    Billing.XeOfferPurchase(_lfmState.Client, user, offerId, PaymentTypeEnum.CreditCard, paymentId);
                   
                    user.Settings.UserType = XblUserTier.Gold;                       
                    ((live.client.Xbox360Client)_lfmState.Client).UserLoggingOn(user);
                    
                    break;
                }
                catch (Exception e)
                {
                    --retries;
                    Global.RO.Warn(e.ToString());       
                    Global.RO.Warn("purchase failed, retrying...");
                    System.Threading.Thread.Sleep(30000); //sleep 30 seconds
                }
            }

            METHOD.EXIT();

            if (retries <= 0)
            {//ran out of retries and the error threw again
                throw new UnexpectedTestResultException("Ran out of retries.");
            }
            else
            {
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\Games.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.common;
using live.lfm;
using System.Xml;
using live.server;

using live.protocol;

using ServerTestFramework;

namespace live.lfm.xbox360Internal
{
    public class GamesInternal : BasicScene
    {
        private readonly GenresScene _genresScene;
        Guid purchasedGameMediaId;

        Guid offerId;
        uint priceFractional;
        uint priceWhole;
        List<MediaInstanceItem> mediaInstances = new List<MediaInstanceItem>();
        internal protected uint _currentBalance;
        public uint CurrentBalance
        {
            get
            {
                return _currentBalance;
            }
        }


        public GamesInternal(LfmState lfmState, SceneBase previousScene)
            : base(lfmState, previousScene)
        {
            _genresScene = new GenresScene(_lfmState, this);
        }

        internal override BasicScene Activate()
        {
            return this;
        }

        protected GamesInternal BackToHere()
        {
            //Activate();
            return this;
        }

        public void NewArrivals() { }
        public void XboxLiveArcade() { }
        public void PlayedGames() { }

        public GenresScene Genres
        {
            get
            {
                return (GenresScene)_genresScene.Activate();
            }
        }

        public void AllGames() { }

        public bool  SelectPaidOffer(Guid gameMediaId)
        {
            offerId = new Guid();
            priceWhole = 0;
            priceFractional = 0;

            purchasedGameMediaId = gameMediaId;
            string query = "methodName=FindGameOffers&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=1&Names=PageSize&Values=5&Names=PageNum&Values=1&Names=DetailView&Values=5&Names=MediaIds&Values=" + purchasedGameMediaId + "&Names=UserTypes&Values=2&Names=MediaTypes&Values=1&Names=MediaTypes&Values=5&Names=MediaTypes&Values=18&Names=MediaTypes&Values=19&Names=MediaTypes&Values=20&Names=MediaTypes&Values=21&Names=MediaTypes&Values=22&Names=MediaTypes&Values=23&Names=MediaTypes&Values=30&Names=MediaTypes&Values=34&Names=MediaTypes&Values=37&Names=ImageFormats&Values=4&Names=ImageFormats&Values=5&Names=ImageSizes&Values=15&Names=Relations&Values=2&Names=OrderBy&Values=5&Names=OrderDirection&Values=2";
            live.protocol.next.GenericQueryRequest req = new live.protocol.next.GenericQueryRequest(query);
            live.protocol.next.CatalogResponse resp = live.server.next.Catalog.SendRequest(this._client, req);

            XmlDocument responseXml = new XmlDocument();
            responseXml.LoadXml(resp.Response);
            int itemReturned = int.Parse(responseXml.GetElementsByTagName("live:totalItems")[0].InnerText);
            
            if (itemReturned == 0)
                return false;

            for (int i = 0; i < itemReturned; i++)
            {
                priceWhole = (uint)(float.Parse(responseXml.GetElementsByTagName("live:price")[i].InnerText));
                priceFractional = 0;
                //select paid offer
                if (priceWhole == 0) continue;
                offerId = new Guid(responseXml.GetElementsByTagName("id")[i].InnerText.Substring(9));
                

                XmlNodeList mediaInstanceNodes = responseXml.GetElementsByTagName("live:mediaInstances");

                this.mediaInstances.Add(new MediaInstanceItem(mediaInstanceNodes[i]));
                return true;
            }
            return false;
        }

        public void PurchaseGame()
        {
      
            OfferMediaTypeExpectedPrice[] omp = new OfferMediaTypeExpectedPrice[1];
            omp[0] = new OfferMediaTypeExpectedPrice();
            omp[0].offerId = offerId;
            omp[0].expectedPriceWhole = priceWhole;
            omp[0].expectedPriceFractional = priceFractional;
            omp[0].mediaTypeId = 23;

            int retires = 3;
            do
            {
               try {
                   Billing.XePurchaseMediaOffers(_client, _user, omp, (uint)PaymentTypeEnum.Points, "", "", 1);            
                   break;                   
               }
               catch (Exception e)
               {
                   Global.RO.Error(e.Message + "\r\n" + e.StackTrace);
                   if (retires < 1) throw e;
                   Global.RO.Warn("Sleep 60 seconds before retry");
                   System.Threading.Thread.Sleep(60 * 1000);
                   retires--;
               }              
            } while (true);
            
            //Download
            MediaInstanceIdOfferIdPair mioid = new MediaInstanceIdOfferIdPair();
            mioid.oid = offerId;
            List<Guid> mediaInstanceIds = new List<Guid>();

            live.common.next.PurchaseHistoryFilter filter = new live.common.next.PurchaseHistoryFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = "en-US";
            filter.Store = 1;
            filter.PageSize = 10;
            filter.PageNum = 1;
            filter.DetailView = 5;
            filter.MediaTypes = new List<Int32>();
            filter.MediaTypes.Add(23);
            filter.OrderBy = 0;
            filter.OrderDirection = 1;
            List<KeyValuePair<string, string>> filterlist = filter.ToList();

            foreach (MediaInstanceItem mii in mediaInstances)
            {
                if (mii.RequiresLicense)
                {
                    mioid.miid = mii.MediaInstanceId;                    

                    live.server.next.WebBilling.GetPurchaseHistory(_client, _user, filterlist);
                }
                mediaInstanceIds.Add(mii.MediaInstanceId);
                Billing.FindMediaInstanceUrls(_client, new Guid[] { mii.MediaInstanceId });
            }

            _currentBalance = UACS.XeGetPointsBalance(_client, _user);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\VideoCategoriesScene.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.common.next;
using live.server;
using live.server.next;

namespace live.lfm.xbox360Internal
{
    public class VideoCategoriesScene : BasicScene
    {
        private int [] _mediaType;
        private readonly VideoMediaOfferScene _videoOfferScene;
        private live.common.EnumeratedEMSVideoMediaItem mediaItems;

        public VideoCategoriesScene(LfmState lfmState, BasicScene prevScene)
            : base(lfmState, prevScene)
        {
            _videoOfferScene = new VideoMediaOfferScene(_lfmState, this);
        }

        public int [] MediaType
        {
            set
            {
                _mediaType = value;
            }
            get
            {
                return _mediaType;
            }
        }

        public VideoMediaOfferScene VideoOfferScene
        {
            get
            {
                return (VideoMediaOfferScene)_videoOfferScene.Activate();
            }
        }

        internal override BasicScene Activate()
        {
            //based on the mediatype make the specific FindVideos call 
            FindVideosFilter filter = new FindVideosFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = "en-US";
            filter.Store = (int)Store.Xbox360;
            filter.PageSize = 50;
            filter.PageNum = 1;
            filter.DetailView = (int)DetailView.Full;
            filter.MediaTypes = ListEx.NewList(MediaType);
            filter.OfferFilterLevel = (int) OfferFilterLevel.WithOffers;
            filter.VideoFilter = 1;
            filter.UserTypes = ListEx.NewList(new int[] { (int) CatalogUserTypeEnum.XboxLiveGoldUser });
            filter.OrderBy = (int) OrderMediaBy.Name;
            filter.OrderDirection = (int)OrderDirection.Ascending;

            live.protocol.next.CatalogResponse resp = Catalog.FindVideos(_client, filter);
            mediaItems = new EnumeratedEMSVideoMediaItem(resp);
            return this;
        }

        public VideoMediaOfferScene SelectSingleMedia(int itemNum)
        {            
            //search for the itemNumber in the mediaItems list
            foreach (EMSVideoMediaItem mediaItem in mediaItems.videoMediaList)
            {
                if( mediaItem.itemNum == itemNum)
                {                    
                    _videoOfferScene.MediaTypes = MediaType;
                    _videoOfferScene.MediaId = mediaItem.MediaId;
                    return VideoOfferScene;
                }
            }
            throw new Exception("Unknown content item num " + itemNum.ToString());
        }

        public VideoMediaOfferScene SelectRandomMedia()
        {
            int randomItemNum = Randomizer.Random.Next(1, mediaItems.numItems);
            return SelectSingleMedia(randomItemNum);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\VideoStore.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.common.next;

namespace live.lfm.xbox360Internal
{
    public class VideoStore : BasicScene
    {
        private readonly VideoCategoriesScene _vidCategoriesScene;

        public VideoStore(LfmState lfmState, SceneBase previousScene)
            : base(lfmState, previousScene)
        {
            _vidCategoriesScene = new VideoCategoriesScene(lfmState, this);
        }

        internal override BasicScene Activate()
        {
            return this;
        }

        public VideoCategoriesScene VideoCategory
        {
            get
            {
                return (VideoCategoriesScene) _vidCategoriesScene.Activate();
            }
        }
        
        public VideoCategoriesScene SelectCategory(MediaTypeEnum mediatype)
        {
            int[] mTypes;
            switch(mediatype)
            {
                case MediaTypeEnum.Movie:
                    {
                        mTypes = new int[1];
                        mTypes[0] = (int)MediaTypeEnum.Movie;
                        break;
                    }
                case MediaTypeEnum.TVShow:
                    {
                        mTypes = new int[1];
                        mTypes[0] = (int)MediaTypeEnum.TVShow;
                        break;
                    }
                case MediaTypeEnum.MusicVideo:
                    {
                        mTypes = new int[1];
                        mTypes[0] = (int)MediaTypeEnum.MusicVideo;
                        break;
                    }
                case MediaTypeEnum.GameVideo:
                    {
                        mTypes = new int[2];
                        mTypes[0] = (int)MediaTypeEnum.GameVideo;
                        mTypes[1] = (int)MediaTypeEnum.GameTrailer;
                        break;
                    }
                case MediaTypeEnum.VideoShort:
                    {
                        mTypes = new int[1];
                        mTypes[0] = (int)MediaTypeEnum.VideoShort;
                        break;
                    }
                default:
                    {
                        mTypes = new int[1];
                        mTypes[0] = (int)MediaTypeEnum.Movie;
                        break;
                    }
            }
            _vidCategoriesScene.MediaType = mTypes;
            return VideoCategory;
        }

        //select random video category from - videos, tv shows, game videos, music videos
        public VideoCategoriesScene SelectRandomCategory()
        {
            Random rand = new Random();
            int randomPercent = rand.Next(0, 100); //2,3,4,30,35
            if (randomPercent >= 0 && randomPercent < 20)
                return SelectCategory(MediaTypeEnum.Movie);
            else if (randomPercent >= 20 && randomPercent < 40)
                return SelectCategory(MediaTypeEnum.TVShow);
            else if (randomPercent >= 40 && randomPercent < 60)
                return SelectCategory(MediaTypeEnum.MusicVideo);
            else if (randomPercent >= 60 && randomPercent < 80)
                return SelectCategory(MediaTypeEnum.GameVideo);
            else
                return SelectCategory(MediaTypeEnum.VideoShort);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Marketplace\VideoMediaOfferScene.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.common.next;
using live.server;
using live.server.next;

namespace live.lfm.xbox360Internal
{
    public class VideoMediaOfferScene : BasicScene
    {
        private EnumeratedVideoOfferItem _videoOffers;
        //private List<MediaInstanceItem> _mediaInstances;
        private EnumeratedPurchaseHistoryItem _historyItems;
        private int[] _mediaTypes;
        private Guid _mediaId;

        public int[] MediaTypes
        {
            set
            {
                _mediaTypes = value;
            }
            get
            {
                return _mediaTypes;
            }
        }

        public Guid MediaId
        {
            set
            {
                _mediaId = value;
            }
            get
            {
                return _mediaId;
            }
        }

        public VideoMediaOfferScene(LfmState lfmState, BasicScene prevScene)
            :base(lfmState, prevScene)
        {
        }

        internal override BasicScene Activate()
        {
            //call purchasehistory
            live.common.next.PurchaseHistoryFilter filter = new live.common.next.PurchaseHistoryFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = "en-US";
            filter.Store = 1;
            filter.PageSize = 10;
            filter.PageNum = 1;
            filter.DetailView = (int) DetailView.Full;
            filter.MediaTypes = new List<int>(2); //TODO: Add all the mediatypes
            filter.MediaTypes.Add(2);
            filter.MediaTypes.Add(8);
            filter.OrderBy = 0;
            filter.OrderDirection = 1;
            List<KeyValuePair<string, string>> filterlist = filter.ToList();

            _historyItems = new EnumeratedPurchaseHistoryItem(live.server.next.WebBilling.GetPurchaseHistory(_client, _user, filterlist));

            //TODO: call FindContributors
            //http://131.107.28.200:80/Catalog/Catalog.asmx/Query?methodName=FindContributors&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-
            //US&Names=Store&Values=1&Names=PageSize&Values=100&Names=PageNum&Values=1&Names=DetailView&Values=1&Names=MediaIds&Values=CEB14275-0F9A-4846-A687-
            //9307BCB8AC8D&Names=ContributorLimit&Values=1&Names=OrderBy&Values=16&Names=OrderDirection&Values=1

            //call findvideooffers
            FindVideoOffersFilter filterOffer = new FindVideoOffersFilter();
            filterOffer.Locale = "en-US";
            filterOffer.LegalLocale = "en-US";
            filterOffer.Store = (int)Store.Xbox360;
            filterOffer.PageSize = 100;
            filterOffer.PageNum = 1;
            filterOffer.DetailView = 5;
            filterOffer.MediaTypes = ListEx.NewList(MediaTypes);
            filterOffer.MediaIds = ListEx.NewList(new Guid[] { MediaId });
            filterOffer.UserTypes = ListEx.NewList(new int[] { (int)CatalogUserTypeEnum.XboxLiveGoldUser });
            filterOffer.OrderBy = (int)OrderMediaOffersBy.Name;
            filterOffer.OrderDirection = (int)OrderDirection.Ascending;

            live.protocol.next.CatalogResponse resp = Catalog.FindVideoOffers(_client, filterOffer);

            _videoOffers = new EnumeratedVideoOfferItem(resp);

            //TODO: call FindVideos            
            return this;
        }

        public HUD.EMSContentItemPurchaseScene SelectSingleOffer(int itemNum)
        {
            //search for the itemNumber in the offerItems list
            foreach (VideoOfferItem offerItem in _videoOffers.videoOfferList)
            {                
                if (offerItem.itemNum == itemNum)
                {
                    HUD.EMSContentItemPurchaseScene scene = new live.lfm.xbox360Internal.HUD.EMSContentItemPurchaseScene(_lfmState, this, offerItem);                    
                    return (HUD.EMSContentItemPurchaseScene) scene.Activate();
                }
            }
            throw new Exception("Unknown content item num " + itemNum.ToString());
        }
        public HUD.EMSContentItemPurchaseScene SelectRandomOffer()
        {
            int randomItemNum = Randomizer.Random.Next(1, _videoOffers.numItems);
            return SelectSingleOffer(randomItemNum);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\Friends.cs ===
using System;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class FriendsInternal
    {
        private readonly LfmState _lfmState;

        public FriendsInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public void AddFriend(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            Presence.AddFriend(_lfmState.Client, user, friend);
            METHOD.EXIT();
        }

        public void AcceptFriendRequest(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            Presence.AcceptFriend(_lfmState.Client, user, friend);
            METHOD.EXIT();
        }

        public void WaitForFriendStatusOK(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            Notification.WaitForBuddyStatusOK(_lfmState.Client, user, friend);
            METHOD.EXIT();
        }

        public void WaitForFriendStatusPending(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            Notification.WaitForBuddyStatusPending(_lfmState.Client, user, friend);
            METHOD.EXIT();
        }

        public void WaitForFriendStatusRequested(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            Notification.WaitForBuddyStatusRequested(_lfmState.Client, user, friend);
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\Messages.cs ===
using System;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class MessagesInternal
    {
        private readonly LfmState _lfmState;

        public MessagesInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public void SendTitleCustomMessage(XblUser user, XblUser target, string message)
        {
            METHOD.ENTER();
            Messaging.SendTextMessage(_lfmState.Client, user, target, message, live.protocol.Presence.XonPresNoti.MSG_TYPE_TITLE_CUSTOM);
            METHOD.EXIT();
        }

        public void SendPersonalMessage(XblUser user, XblUser target, string message)
        {
            METHOD.ENTER();
            Messaging.SendTextMessage(_lfmState.Client, user, target, message, live.protocol.Presence.XonPresNoti.MSG_TYPE_PERSONAL_MESSAGE);
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\feedbackinternal.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using System.Threading;

namespace live.lfm.xbox360Internal
{
    public class FeedbackInternal
    {
        private readonly LfmState _lfmState;
        private static int idx = 0;

        public FeedbackInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public void SubmitPlayerReview(ulong targetPUID, live.protocol.FeedbackDefs.PlayerReview type)
        {
            METHOD.ENTER();
            live.server.Feedback.SendReview(_lfmState.Client, _lfmState.ActiveUser, targetPUID, _lfmState.Client.TitleId, type, GetContext());
            METHOD.EXIT();
        }

        public void FileComplaint(ulong targetPUID, live.protocol.FeedbackDefs.ComplaintType type)
        {
            METHOD.ENTER();
            live.server.Feedback.SendComplaint(_lfmState.Client, _lfmState.ActiveUser, targetPUID, _lfmState.Client.TitleId, type, GetContext());
            METHOD.EXIT();
        }


        public static ulong GetContext()
        {
            return (ulong)(0xFF000 + Interlocked.Increment(ref idx));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\StatsInternal.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.server;

using live.protocol;

namespace live.lfm.xbox360Internal
{
    public class StatsInternal
    {
        public LfmState _lfmState;


        public StatsInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public void PostStats(live.common.StatsBundle bundle)
        {
            METHOD.ENTER();
            live.server.Stats.PostStatsBundle(_lfmState.Client, _lfmState.ActiveUser, bundle);
            METHOD.EXIT();
        }

        public StatsReadResponse ReadStats(ulong[] targetUsers, StatsSpec[] messages)
        {
            METHOD.ENTER();
            // Consider: Should we make a protocol-independent version of this?
            StatsReadResponse response = live.server.Stats.ReadStats(_lfmState.Client, _lfmState.ActiveUser, _lfmState.Client.TitleId, targetUsers, messages);
            METHOD.EXIT();
            return response;
        }

        public StatsEnumResponse StatsEnumByUser(StatsSpec[] messages, ulong userId)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = Stats.StatsEnumByUser(_lfmState.Client, _lfmState.ActiveUser, userId, messages);
            METHOD.EXIT();
            return resp;
        }

        public StatsEnumResponse StatsEnumByRank(StatsSpec[] messages, ulong rank)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = Stats.StatsEnumByRank(_lfmState.Client, _lfmState.ActiveUser, rank, messages);
            METHOD.EXIT();
            return resp;
        }

        public StatsEnumResponse StatsEnumByRating(StatsSpec[] messages, ulong rating)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = Stats.StatsEnumByRating(_lfmState.Client, _lfmState.ActiveUser, rating, messages);
            METHOD.EXIT();
            return resp;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\XboxLive.cs ===
using System;

using live.common;
using live.server;

namespace live.lfm.xbox360Internal
{
    public class LiveInternal
    {
        private readonly LfmState _lfmState;

        public FriendsInternal Friends;
        public MessagesInternal Messages;
        public FeedbackInternal Feedback;
        public ProfileInternal Profile;
        public MatchmakingInternal Matchmaking;
        public StatsInternal Stats;


        public LiveInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
            Friends = new FriendsInternal(lfmState);
            Messages = new MessagesInternal(lfmState);
            Feedback = new FeedbackInternal(lfmState);
            Profile = new ProfileInternal(lfmState);
            Matchmaking = new MatchmakingInternal(_lfmState);
            Stats = new StatsInternal(_lfmState);

        }

        public void Logon(XblUser user, uint titleId)
        {
            _lfmState.Client.TitleId = titleId;
            Logon(user);
        }

        public void Logon(XblUser user, TitleBase titleObject)
        {
            _lfmState.Client.TitleObject = titleObject;
            Logon(user);
        }

        public void Logon(XblUser user)
        {
            Logon(_lfmState, user);
        }

        public static void Logon(LfmState lfmState, XblUser user)
        {
            METHOD.ENTER();
            if (!lfmState.Client.LoggedOnUsers.Contains(user))
            {
                lfmState.Client.UserLoggingOn(user);
                try
                {
                    Presence.Alive2(lfmState.Client, user);
                    Presence.SetState(lfmState.Client, user, live.protocol.Presence.XonPresNoti.P_STATE_MASK_ONLINE);
                    //Notification.GetMessageCount();
                    //Banners.Download();
                    if (lfmState.ActiveUser == null)
                    {
                        lfmState.ActiveUser = user;
                    }
                }
                catch (Exception)
                {
                    lfmState.Client.UserLoggingOff(user);
                    throw;
                }
            }
            METHOD.EXIT();
        }

        public void Logout(XblUser user)
        {
            METHOD.ENTER();
            if (_lfmState.Client.LoggedOnUsers.Contains(user))
            {
                _lfmState.Client.UserLoggingOff(user);
                Presence.LogOut(_lfmState.Client, user);
            }
            METHOD.EXIT();
        }

        public void Play(TitleBase titleObject)
        {
            _lfmState.Client.TitleObject = titleObject;
            Play(titleObject.TitleId);
        }

        public void Play(uint titleId)
        {
            METHOD.ENTER();
            _lfmState.Client.TitleId = titleId;
            foreach (XblUser user in _lfmState.Client.LoggedOnUsers)
            {
                Presence.ChangeTitle(_lfmState.Client, user);
            }
            METHOD.EXIT();
        }

        public void SetTitleData(XblUser user, byte[] titleData)
        {
            METHOD.ENTER();
            Presence.SetTitleData(_lfmState.Client, user, titleData);
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\MatchmakingInternal.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.protocol;

namespace live.lfm.xbox360Internal
{

    public class MatchmakingInternal
    {
        // CONSIDER: When do we need to update presence as sessions change?
        private readonly LfmState _lfmState;

        public MatchmakingInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public Session CreateSession(XblUser user)
        {
            return CreateSession(user, 4, 0);
        }


        public Session CreateSession(XblUser user, uint publicSlots, uint privateSlots)
        {
            return CreateSession(user, publicSlots, privateSlots, false);
        }

        public Session CreateSession(XblUser user, uint publicSlots, uint privateSlots, bool isArbitrated)
        {
            METHOD.ENTER();
            // How do we handle flags and public/private slots?
            MatchSessionReply response =
                live.server.Matchmaking.CreateSession(_lfmState.Client, user, publicSlots, privateSlots);

            Session session = new Session(_lfmState.Client);

            session.SessionId = response.qwSessionId;
            session.KeyExchangeKey = response.rgbKeyExchangeKey;
            session.OpenPublicSlots = publicSlots;
            session.OpenPrivateSlots = privateSlots;
            session.IsArbitrated = isArbitrated;

            uint trust = 0;
            uint teamId = 0;

            if (isArbitrated)
            {
                live.server.Arbitration.RegisterArbitrationSession(_lfmState.Client, _lfmState.ActiveUser, teamId, trust, session.SessionId, session.SessionId);
                live.server.Arbitration.TimeExtend(_lfmState.Client, _lfmState.ActiveUser, trust, session.SessionId, session.SessionId);
                
            }

            METHOD.EXIT();
            return session;

        }

        public bool JoinSession(Session session)
        {
            METHOD.ENTER();
            // This should be encapsulated later on
            if (!(session.InvolvedClientList.Contains(_lfmState.Client)))
            {
                session.InvolvedClientList.Add(_lfmState.Client);
            }
            if (session.OpenPublicSlots > 0)
            {
                // modify open/private slots
                live.server.Matchmaking.UpdateSession(_lfmState.Client, _lfmState.ActiveUser, session.SessionId, (session.OpenPublicSlots -1), (session.FilledPublicSlots + 1));
                // update the object if successful.
                session.OpenPublicSlots--;
                session.FilledPublicSlots++;

                uint trust = 0;
                uint teamId = 0;

                if (session.IsArbitrated)
                {
                    live.server.Arbitration.RegisterArbitrationSession(_lfmState.Client, _lfmState.ActiveUser, teamId, trust, session.SessionId, session.SessionId);
                    live.server.Arbitration.TimeExtend(_lfmState.Client, _lfmState.ActiveUser, trust, session.SessionId, session.SessionId);
                }

                METHOD.EXIT();
                return true;
            }
            else
            {
                METHOD.EXIT();
                return false;
            }
        }

        public void StartSession(Session session)
        {
            METHOD.ENTER();
            // Iterate through each client and tell the service
            // (if necessary)

            // In the single player case, this is just an internal
            // state change
            session.Start();
            // update the open slots to 0 so no more can join.
            session.OpenPublicSlots = 0;
            live.server.Matchmaking.UpdateSession(_lfmState.Client, _lfmState.ActiveUser, session.SessionId, session.OpenPublicSlots, session.FilledPublicSlots);
            METHOD.EXIT();
            
        }

        public void EndSession(Session session, live.common.StatsBundle stats)
        {
            METHOD.ENTER();
            // This will become more complicated once I implement the 
            // multiplayer case

            session.End();

            uint trust = 0;
            if (session.IsArbitrated)
            {
                live.server.Arbitration.ReportArbitrationResults(_lfmState.Client, _lfmState.ActiveUser, trust, session.SessionId, session.SessionId);
            }

            // Post the stats.
            live.server.Stats.PostStatsBundle(_lfmState.Client, _lfmState.ActiveUser, stats);
            
            METHOD.EXIT();
        }

        public void LeaveSession(Session session)
        {
            METHOD.ENTER();
            session.InvolvedClientList.Remove(_lfmState.Client);

            // modify open/private slots
            live.server.Matchmaking.UpdateSession(_lfmState.Client, _lfmState.ActiveUser, session.SessionId, (session.OpenPublicSlots+1), (session.FilledPublicSlots-1));
            session.OpenPublicSlots++;
            session.FilledPublicSlots--;
            METHOD.EXIT();
        }


        public void DeleteSession(Session session)
        {
            METHOD.ENTER();
            live.server.Matchmaking.DeleteSession(_lfmState.Client, _lfmState.ActiveUser, session.SessionId);
            METHOD.EXIT();
        }

        public MatchSearchReply FindSession(XblUser user)
        {
            METHOD.ENTER();
            MatchSearchReply reply = live.server.Matchmaking.SearchSession(_lfmState.Client, user);
            METHOD.EXIT();
            return reply;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\XboxLive\ProfileInternal.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.lfm.xbox360Internal;
using live.protocol;
using live.server;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

namespace live.lfm.xbox360Internal
{




    #region Scenes



    /// <summary>
    /// Edit Gamer Profile Scene
    /// </summary>
    public class EditGamerProfileScene : BasicScene
    {
        private UserSetting[] _userSettings;

        public UserSetting[] UserSettings
        {
            get { return _userSettings; }
        }

        public EditGamerProfileScene(LfmState lfmState)
            : base(lfmState, null)
        {

        }


        internal new EditGamerProfileScene Activate()
        {
            _userSettings = GamerProfileScene.GetUserSettingsForGamercard(_lfmState, _lfmState.ActiveUser.Puid);
            return this;
        }


        public void EditMotto(string motto)
        {
            UserSetting[] userSettings = new UserSetting[1];
            byte[] value = System.Text.UnicodeEncoding.Unicode.GetBytes(motto);          
            userSettings[0] = new UserSetting(_lfmState.ActiveUser.Puid, (uint)live.server.UserSettings.SettingSource.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_MOTTO, value);
            live.server.UserSettings.SyncSettings(_lfmState.Client, _lfmState.ActiveUser, _lfmState.Client.TitleId, userSettings, DateTime.UtcNow);
        }

        public void EditGamerZone(int gamerZone)
        {
            UserSetting[] userSettings = new UserSetting[1];
            byte[] value = BitConverter.GetBytes(gamerZone); // Could not find an enum so just using 1. 
            userSettings[0] = new UserSetting(_lfmState.ActiveUser.Puid, (uint)live.server.UserSettings.SettingSource.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_ZONE, value);
            live.server.UserSettings.SyncSettings(_lfmState.Client, _lfmState.ActiveUser, _lfmState.Client.TitleId, userSettings, DateTime.UtcNow);

        }

        public void EditGamerPicture(string personalPicture)
        {
            UserSetting[] Usettings = new UserSetting[2];
            byte[] val0 = System.Text.UnicodeEncoding.Unicode.GetBytes((_lfmState.Client.TitleId.ToString("X8") + "BBBBBBBBSSSSSSSS"));
            Usettings[0] = new UserSetting(_lfmState.ActiveUser.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY, val0);

            val0 = System.Text.UnicodeEncoding.Unicode.GetBytes(personalPicture);
            Usettings[1] = new UserSetting(_lfmState.ActiveUser.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE, val0);

            live.server.UserSettings.SyncSettings(_lfmState.Client, _lfmState.ActiveUser, _lfmState.Client.TitleId, Usettings, DateTime.UtcNow);
        }
         


    }




    /// <summary>
    /// Gamer Profile Scene
    /// </summary>
    public class GamerProfileScene : BasicScene
    {
        private CompareGamesScene _compareGamesScene;
        private SubmitPlayerReviewScene _submitPlayerReviewScene;
        private FileComplaintScene _fileComplaintScene;
        private EditGamerProfileScene _editGamerProfileScene;

        private UserSetting[] _userSettings;

        private ulong _gamerPuid = 0;

        public ulong GamerPuid
        {
            get { return _gamerPuid; }
        }

        public UserSetting[] UserSettings
        {
            get { return _userSettings; }
        }

        public static UserSetting[] GetUserSettingsForGamercard(LfmState _lfmState, ulong userPuid)
        {
            uint[] settings = new uint[17];
            settings[0] = ProfileDefs.XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED;
            settings[1] = ProfileDefs.XPROFILE_GAMERCARD_CRED;
            settings[2] = ProfileDefs.XPROFILE_GAMERCARD_HAS_VISION;
            settings[3] = ProfileDefs.XPROFILE_GAMERCARD_MOTTO;
            settings[4] = ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE;
            settings[5] = ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY;
            settings[6] = ProfileDefs.XPROFILE_GAMERCARD_REGION;
            settings[7] = ProfileDefs.XPROFILE_GAMERCARD_REP;
            settings[8] = ProfileDefs.XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS;
            settings[9] = ProfileDefs.XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED;
            settings[10] = ProfileDefs.XPROFILE_GAMERCARD_TITLE_CRED_EARNED;
            settings[11] = ProfileDefs.XPROFILE_GAMERCARD_TITLES_PLAYED;
            settings[12] = ProfileDefs.XPROFILE_GAMERCARD_USER_BIO;
            settings[13] = ProfileDefs.XPROFILE_GAMERCARD_USER_LOCATION;
            settings[14] = ProfileDefs.XPROFILE_GAMERCARD_USER_NAME;
            settings[15] = ProfileDefs.XPROFILE_GAMERCARD_USER_URL;
            settings[16] = ProfileDefs.XPROFILE_GAMERCARD_ZONE;

            ReadSettingsResponse resp = live.server.UserSettings.ReadSettings(_lfmState.Client, _lfmState.ActiveUser, _lfmState.Client.TitleId, new ulong[] { userPuid }, settings);
            return resp.Settings;
        }


        public void InitGamercard(ulong gamerPuid)
        {
            _gamerPuid = gamerPuid;
            _compareGamesScene = new CompareGamesScene(_lfmState, _gamerPuid);
            _fileComplaintScene = new FileComplaintScene(_lfmState, _gamerPuid);
            _submitPlayerReviewScene = new SubmitPlayerReviewScene(_lfmState, _gamerPuid);
            _editGamerProfileScene = new EditGamerProfileScene(_lfmState);
            _userSettings = GetUserSettingsForGamercard(_lfmState, gamerPuid);
        }

        public CompareGamesScene ViewCompareGamesScene
        {
            get
            {
                if (_gamerPuid == 0)
                    throw new ApplicationException("Call InitGamercard before using this scene.");
                return _compareGamesScene.Activate();
            }
        }
        public SubmitPlayerReviewScene ViewSubmitPlayerReviewScene
        {
            get
            {
                return _submitPlayerReviewScene.Activate();
            }
        }
        public FileComplaintScene ViewFileComplaintScene
        {
            get
            {
                return _fileComplaintScene.Activate();
            }
        }
        public EditGamerProfileScene EditGamerProfileScene
        {
            get
            {
                return _editGamerProfileScene.Activate();
            }
        }


        public GamerProfileScene(LfmState lfmState)
            : base(lfmState, null)
        {

        }

    }




    /// <summary>
    /// Compare Games Scene
    /// </summary>
    public class CompareGamesScene : BasicScene
    {
        public GameSelector GameSelector = null;
        private UserTitle[] _userTitles = new UserTitle[32];
        private ulong _gamerPuid;

        public UserTitle[] UserTitles
        {
            get { return _userTitles; }
            set { _userTitles = value; }
        }

        public CompareGamesScene(LfmState lfmState, ulong gamerPuid)
            : base(lfmState, null)
        {
            _gamerPuid = gamerPuid;
        }

        internal new CompareGamesScene Activate()
        {
            EnumTitlesResponse resp = live.server.UserSettings.EnumTitles(_lfmState.Client, _lfmState.ActiveUser, _gamerPuid, 0, 32);
            _userTitles = resp.Titles;
            GameSelector = new GameSelector(_lfmState, _gamerPuid, _userTitles);
            return this;
        }
    }

    /// <summary>
    /// Game Selector
    /// </summary>
    public class GameSelector
    {
        private LfmState _lfmState;
        private ulong _gamerPuid;
        private Dictionary<int, GameAchievementsScene> GamesCache = new Dictionary<int, GameAchievementsScene>();

        public GameSelector(LfmState lfmState, ulong gamerPuid, UserTitle[] userTitles)
        {
            _lfmState = lfmState;
            _gamerPuid = gamerPuid;
            int i = 0;
            if (userTitles != null)
            {
                foreach (UserTitle title in userTitles)
                {
                    GamesCache.Add(i++, new GameAchievementsScene(_lfmState, gamerPuid, title));
                }
            }
        }

        public int Count()
        {
            return GamesCache.Count;
        }

        public GameAchievementsScene this[int Index]
        {
            get
            {
                return GamesCache[Index].Activate();
            }
        }
    }


    /// <summary>
    /// Game Achievements Scene
    /// </summary>
    public class GameAchievementsScene : BasicScene
    {
        private Achievement[] _achievements = new Achievement[32];
        private ulong _gamerPuid;
        private UserTitle _title;

        public UserTitle title
        {
            get { return _title; }
        }

        public Achievement[] Achievements
        {
            get { return _achievements; }
        }

        public GameAchievementsScene(LfmState lfmState, ulong gamerPuid, UserTitle title)
            : base(lfmState, null)
        {
            _gamerPuid = gamerPuid;
            _title = title;
        }

        internal new GameAchievementsScene Activate()
        {
            // we need to get acheivements for the title?
            AchievementEnumResponse resp = live.server.Achievements.EnumAchievement(_lfmState.Client, _lfmState.ActiveUser, _title.TitleId, _gamerPuid, 0, 0, 32);
            _achievements = resp.Achievements;
            return this;
        }
    }

    public class FileComplaintScene : BasicScene
    {
        private ulong _gamerPuid;

        public FileComplaintScene(LfmState lfmState, ulong gamerPuid)
            : base(lfmState, null)
        {
            _gamerPuid = gamerPuid;
        }

        internal new FileComplaintScene Activate()
        {
            return this;
        }

        public void FileComplaint(live.protocol.FeedbackDefs.ComplaintType complaintType)
        {
            FeedbackInternal feedback = new FeedbackInternal(_lfmState);
            feedback.FileComplaint(_gamerPuid, complaintType);
        }
    }

    public class SubmitPlayerReviewScene : BasicScene
    {
        private ulong _gamerPuid;

        public SubmitPlayerReviewScene(LfmState lfmState, ulong gamerPuid)
            : base(lfmState, null)
        {
            _gamerPuid = gamerPuid;
        }

        internal new SubmitPlayerReviewScene Activate()
        {
            return this;
        }

        public void SubmitPlayerReview(live.protocol.FeedbackDefs.PlayerReview playerReview)
        {
            FeedbackInternal feedback = new FeedbackInternal(_lfmState);
            feedback.SubmitPlayerReview(_gamerPuid, playerReview);
        }
    }
    #endregion





    public class ProfileInternal
    {
        private readonly LfmState _lfmState;
        public GamerProfileScene GamerProfileScene;

        public ProfileInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
            GamerProfileScene = new GamerProfileScene(_lfmState);

        }

        public SyncAchievementsResponse SyncAchievements(uint titleId, Achievement[] aList)
        {
            METHOD.ENTER();
            SyncAchievementsResponse resp = live.server.Achievements.SyncAchievements(_lfmState.Client, _lfmState.ActiveUser, titleId, aList);
            METHOD.EXIT();
            return resp;
        }

        public AchievementEnumResponse EnumAchievement(uint titleId, ulong friendPuid, ushort locale, ushort start, ushort count)
        {
            METHOD.ENTER();
            AchievementEnumResponse resp = live.server.Achievements.EnumAchievement(_lfmState.Client, _lfmState.ActiveUser,titleId,  friendPuid, locale, start, count);
            METHOD.EXIT();
            return resp;
        }

        public SyncTitlesResponse SyncTitles(DateTime version, UserTitle[] titles)
        {
            METHOD.ENTER();
            SyncTitlesResponse resp = live.server.UserSettings.SyncTitles(_lfmState.Client, _lfmState.ActiveUser, version, titles);
            METHOD.EXIT();
            return resp;
        }

        public EnumTitlesResponse EnumTitle(ulong forUserId, ushort startingIndex, ushort maxTitles)
        {
            METHOD.ENTER();
            EnumTitlesResponse resp = live.server.UserSettings.EnumTitles(_lfmState.Client, _lfmState.ActiveUser, forUserId, startingIndex, maxTitles);
            METHOD.EXIT();
            return resp;
        }

        public ReadSettingsResponse ReadSettings(ulong[] friends, uint titleId, uint[] settingIds)
        {
            METHOD.ENTER();
            ReadSettingsResponse resp = live.server.UserSettings.ReadSettings(_lfmState.Client, _lfmState.ActiveUser, titleId, friends, settingIds);
            METHOD.EXIT();
            return resp;
        }

        public SyncSettingsResponse SyncSettings(UserSetting[] userSettings, uint titleId, DateTime version)
        {
            METHOD.ENTER();
            SyncSettingsResponse resp = live.server.UserSettings.SyncSettings(_lfmState.Client, _lfmState.ActiveUser, titleId, userSettings, version);
            METHOD.EXIT();
            return resp;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\AAInfo.cs ===
//
// AAInfo.cs aka ActiveAuthInfo
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is a class that exposes the ActiveAuth related client data from the 
// ActiveAuthModule / ActiveAuthGateway.  This is only the base class, which holds all the 
// data and has handy accessors.  There are 2 child classes that actually implement the 
// functionality to populate this class. They live in different namespaces: 
// xonline.common.service for middle-tier services, and xonline.server.activeauth for 
// internet-tier services.
//
// To use this class directly:
//  
//   #using xonline.common.service;
//   ...
//   AAInfo aainfo = AAInfoMiddleTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ... 
//
//   or, if your component lives on the internet tier:
//
//   #using xonline.common.service;
//   ...
//   AAInfo aainfo = AAInfoInternetTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ...
// 
// To use it indirectly via SGInfo (sorry for the extra step):
//
//   SGInfo sginfo = SGInfo.Current;
//   if (sginfo.IsActiveAuth)
//   {
//       AAInfo aainfo = AAInfoMiddleTier.Current;
//       ...
//   }
//
// Author: kgoodier 6/2007
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Diagnostics;


namespace live.protocol
{

    abstract public class AAInfo
    {

        // -------------------------------------------------------------------------
        //
        // Public properties and accessors
        //
        // -------------------------------------------------------------------------

        public ulong PassportPuid
        {
            get { return _passportPuid; }
        }

        public string IpAddressInternet
        {
            get { return _ipAddressInternet; }
        }

        public ulong LiveXuid
        {
            get
            {
                if (_liveXuid == null)
                    PopulateLiveXuid();
                return (ulong)_liveXuid;
            }
        }

        public byte CountryId
        {
            get
            {
                if (_countryId == null)
                    PopulateUserInfo();
                return (byte)_countryId;
            }
        }

        public BitArray UserPrivileges
        {
            get
            {
                if (_userPrivileges == null)
                    PopulateUserPrivileges();
                return _userPrivileges;
            }
        }

        public bool HasPrivilege(int privilege)
        {
            return UserPrivileges[privilege];
        }

        public bool IsUserValid
        {
            get { return LiveXuid != 0; }
        }

        public static bool IsActiveAuthAvailable
        {
            get
            {
                if (HttpContext.Current == null)
                {
                    return false;
                }

                // In context?
                if (HttpContext.Current.Items[c_CtxKey_PassportPuid] != null &&
                    HttpContext.Current.Items[c_CtxKey_IpAddressInternet] != null)
                {
                    return true;
                }

                // In headers?
                if (HttpContext.Current.Request.Headers[c_HdrKey] != null)
                {
                    return true;
                }

                return false;
            }
        }

        // -------------------------------------------------------------------------
        //
        // Private members below here, nothing to see, move along.
        //
        // -------------------------------------------------------------------------


        protected UInt32 ProtocolVersion
        {
            // Increment when wire protocol changes!
            get { return WireData.MakeSchemaVersion(1, 0); }
        }


        // -------------------------------------------------------------------------
        // MarshallToHeaders
        //
        // Input for 'headers' should come from WebClient.Headers or HttpRequest.Headers 
        // (HttpContext.Current.Request.Headers). Only used by ActiveAuthGateway.
        // -------------------------------------------------------------------------
        internal static void MarshallToHeaders(
            WebHeaderCollection headers,
            AAInfo aa)
        {
            string base64string = aa.ConvertToBase64String();
            headers[c_HdrKey] = base64string;
        }

        // -------------------------------------------------------------------------
        // TryMarshallFromContext
        // -------------------------------------------------------------------------
        internal static bool TryMarshallFromContext(
            HttpContext ctx,
            ref AAInfo aa)
        {
            ulong? passportPuid;
            string ipAddressInternet;

            passportPuid = (ulong?)(ctx.Items[c_CtxKey_PassportPuid]);
            ipAddressInternet = (string)(ctx.Items[c_CtxKey_IpAddressInternet]);

            // It's all or nothing - if any field is invalid, then we return an error
            if (passportPuid == null ||
                ipAddressInternet == null)
            {
                return false;
            }

            aa._passportPuid = (ulong)passportPuid;
            aa._ipAddressInternet = ipAddressInternet;

            return true;
        }

        // -------------------------------------------------------------------------
        // TryMarshallFromHeaders
        // -------------------------------------------------------------------------
        internal static bool TryMarshallFromHeaders(
            NameValueCollection headers,
            ref AAInfo aa)
        {
            string base64string = headers[c_HdrKey];
            if (base64string == null)
            {
                return false;
            }

            aa.ReadFromBase64String(base64string);
            return true;
        }


        // -------------------------------------------------------------------------
        // AAInfo default constructor 
        // 
        // Doesn't do much, unlike SGInfo.  
        // -------------------------------------------------------------------------
        protected AAInfo()
        {
            _passportPuid = 0;
            _ipAddressInternet = null;
            _liveXuid = null;
            _countryId = null;
            _userPrivileges = null;

        }

        // -------------------------------------------------------------------------
        // AAInfo marshalling constructor
        //
        // Used by the marshalling code
        // -------------------------------------------------------------------------
        protected AAInfo(ulong passportPuid, string ipAddressInternet)
            : this()
        {
            _passportPuid = passportPuid;
            _ipAddressInternet = ipAddressInternet;
        }


        // -------------------------------------------------------------------------
        // ConvertToByteArray - serializes object into a byte array
        // -------------------------------------------------------------------------
        protected byte[] ConvertToByteArray()
        {
            MemoryStream ms = new MemoryStream(100);
            BinaryWriter bw = new BinaryWriter(ms);

            bw.Write(FullQualifiedName);
            bw.Write(ProtocolVersion);
            bw.Write(_passportPuid);
            bw.Write(_ipAddressInternet);

            // we don't write the extra fields. at the moment, the only time we need to 
            // serialize this object is for the authsg to send it to a front door, and in that 
            // case, only the passportPuid and ipAddressInternet are available to the authsg.

            return ms.ToArray();
        }

        // -------------------------------------------------------------------------
        // ConvertToBase64String - serializes object into a base64 encoded string
        // -------------------------------------------------------------------------
        protected string ConvertToBase64String()
        {
            return Convert.ToBase64String(ConvertToByteArray());  // .net call
        }

        // -------------------------------------------------------------------------
        // ReadFromByteArray - populates object from a byte array
        // -------------------------------------------------------------------------
        protected void ReadFromByteArray(byte[] bytes)
        {
            MemoryStream ms = new MemoryStream(bytes);
            BinaryReader br = new BinaryReader(ms);

            string fullQualifiedName = br.ReadString();  // interesting, but ignored for now
            uint protocolVersion = br.ReadUInt32();
            if (protocolVersion != ProtocolVersion)
            {
                throw new Exception(String.Format(
                    "Version mismatch: Expected name {0}, ver {1}. Got name {2}, ver {3}.",
                    FullQualifiedName,
                    ProtocolVersion,
                    fullQualifiedName,
                    protocolVersion));
            }

            _passportPuid = br.ReadUInt64();
            _ipAddressInternet = br.ReadString();
        }

        // -------------------------------------------------------------------------
        // ReadFromBase64String - populates object from base64 encoded string
        // -------------------------------------------------------------------------
        protected void ReadFromBase64String(string base64string)
        {
            ReadFromByteArray(Convert.FromBase64String(base64string));
        }



        // -------------------------------------------------------------------------
        //
        // Constants used internally. Don't reference them unless your name is 
        // ActiveAuthModule.
        //
        // -------------------------------------------------------------------------

        internal const string c_HdrKey = "Authz";
        internal const string c_CtxKey_PassportPuid = "AAInfo_PassportPuid";
        internal const string c_CtxKey_IpAddressInternet = "AAInfo_IpAddressInternet";

        protected string FullQualifiedName
        {
            get { return this.GetType().AssemblyQualifiedName; }
        }


        // -------------------------------------------------------------------------
        //
        // Private members for holding state
        //
        // -------------------------------------------------------------------------

        // Native properties
        //
        // These come from ActiveAuthModule

        protected ulong _passportPuid;
        protected string _ipAddressInternet;

        // Extended properties
        //
        // We have to look these up. We do it on-demand.

        protected ulong? _liveXuid;
        protected byte? _countryId;
        protected BitArray _userPrivileges;

        // -------------------------------------------------------------------------
        //
        // Abstract methods, to be implemented by the children.
        //
        // -------------------------------------------------------------------------

        abstract protected void PopulateLiveXuid();

        abstract protected void PopulateUserInfo();

        abstract protected void PopulateUserPrivileges();

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\ArbitrationProt.cs ===
/*==========================================================================
 *
 *  ArbitrationProt.cs -- This module defines the wire protocol for Arbitration service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Caching;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using live.protocol;
using live.common;
using live.protocol.Presence;


namespace live.protocol 
{
    public enum ArbitrationSessionOutcome { Undetermined, Successful, Minority, Failed, Problematic }

    sealed public class ArbitrationFlags
    {
        public const ushort IsTournament = 0x0001;
        public const ushort TimeExtendable = 0x0002;
        public const ushort HostForwardsPackets = 0x0004;
        public const ushort TeamMembershipInfoIncluded = 0x0008;
        public const ushort SessionIsFreeForAll = 0x0010;
        public const ushort PublisherBasedTournament = 0x0020;

        public const ushort flagMask = IsTournament | TimeExtendable | HostForwardsPackets | TeamMembershipInfoIncluded | SessionIsFreeForAll | PublisherBasedTournament;
    }
    /// <summary>
    /// Arbitration Register request
    /// TODO: WOrk in Progress.
    /// </summary>
    public class XRLRegisterRequest : XRLObject2
    {

        //public ushort protocolVersion = 1;
        //public ushort flags = 0;
        //public uint titleId = XOn.DASH_TITLE_ID;
        //public ulong sessionId = 0UL;
        //public ulong sessionNonce = 0UL;
        //public ushort maxSessionSeconds = 120;
        //public TeamTickets teamTickets = null;

        //public ulong userPuid;
        //public uint userFlag = 0x00000000;
        //public float userTrust = 0.0f;
      
        public ulong xboxId;
        public XUIDAndTrust[] users;
        public ulong teamId;
        public ushort flags;
        public ulong sessionId;
        public ulong sessionNonce;
        public ulong titleId;
        public int usersLen;


        public XRLRegisterRequest()
        {

        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            MemoryStream postStream = new MemoryStream(200);
            BinaryWriter writer = new BinaryWriter(postStream);

            writer.Write((ushort)1);
            writer.Write(flags);
            writer.Write(titleId);
            writer.Write(sessionId);
            writer.Write(sessionNonce);
            writer.Write((ushort)400);

            //if (teamId != 0)
            //{
            //    TeamTicket[] teamTicket = new TeamTicket[1];
            //    teamTicket[0] = new TeamTicket(users[0].qwUserID, teamId);
            //    teamTicket[0].SignTicket(new HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, xboxId, users, TITLE_ID, (uint)XOService.Arbitration, 0));
            //    TeamTickets teamTickets = new TeamTickets(teamTicket);
            //    teamTickets.WriteStream(writer);
            //}

            base.WriteStream(writer);
        }


        public string GetXRL()
        {
            return "/xarb/Register.ashx";
        }

        public XOService GetServiceId()
        {
            return XOService.Arbitration;
        }



    }

    /// <summary>
    /// Arbitration Register response wiredata
    /// </summary>
    public class XRLRegisterResponse : XRLObject2
    {
        public ushort registeredXboxLen = 0;
        public RegisteredXbox[] registeredXbox = null;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            registeredXboxLen = binaryReader.ReadUInt16();
            registeredXbox = new RegisteredXbox[registeredXboxLen];
            for (int i = 0; i < registeredXboxLen; i++)
            {
                registeredXbox[i] = new RegisteredXbox();
                registeredXbox[i].ReadStream(binaryReader);
            }
            return (this);
        }
    }

    /// <summary>
    /// Arbitration Register response RegisteredXbox wiredata 
    /// </summary>
    public class RegisteredXbox : XRLObject2
    {
        public ulong puid = 0UL;
        public byte trustworthyness = 0;
        public byte registeredUserLen = 0;
        public RegisteredUser[] registeredUser = null;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            puid = binaryReader.ReadUInt64();
            trustworthyness = binaryReader.ReadByte();
            registeredUserLen = binaryReader.ReadByte();
            registeredUser = new RegisteredUser[registeredUserLen];
            for (int i = 0; i < registeredUserLen; i++)
            {
                registeredUser[i] = new RegisteredUser();
                registeredUser[i].ReadStream(binaryReader);
            }
            return (this);
        }
    }

    /// <summary>
    /// Arbitration Register repsonse RegisteredUser wiredata 
    /// </summary>
    public class RegisteredUser : XRLObject2
    {
        //XUID
        public ulong userId = 0UL;
        public uint flags = 0;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            userId = binaryReader.ReadUInt64();
            flags = binaryReader.ReadUInt32();
            return (this);
        }
    }





    public class ArbitrationXUIDAndTrust : WireData
    {
        [WireInfo(HexString=true)]
        public ulong qwUserID;
        [WireInfo(HexString=true)]
        public uint dwUserFlags;
        public float userTrust;
    }
    
    public class ArbitrationBundle : WireData
    {
        public int index;
        public uint count;
        public double totalTrust;
    }
    
    public class ArbitrationXboxInfo : WireData
    {
        public byte timeExtendCount;
        public byte reportCount;
        [WireInfo(HexString=true)]
        public ushort reportFlags;
        [WireInfo(HexString=true)]
        public ulong xboxID;
        public int userCount;
        [WireInfo(SizeParam="userCount")]        
        public ArbitrationXUIDAndTrust[] users;
        public double trust;
        public byte normalizedTrust;
        public int bundleIndex;
        public int diconnectedXboxCount;
        [WireInfo(SizeParam="diconnectedXboxCount", HexString=true)]        
        public ulong[] diconnectedXboxes;
    }

    public class ArbitrationSuspiciousInfo : WireData
    {
        public int type; // 1, 2, or 3
        public int messageLen;
        public string message;
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount", HexString=true)]        
        public ulong[] xboxes;
        public int userCount;
        [WireInfo(SizeParam="userCount", HexString=true)]        
        public ulong[] users;
    }

    public class ArbitrationTitleParameters : WireData
    {
        public double BaseTrust; // Base trust rewarded per Xbox
        public double MinorityQuorum;
        public double UserTournamentAmplification;
        public double PublisherTournamentAmplification;
        public uint BaseSessionTime;
        public double FermiK; // Constant in Fermi function
    }

    //
    // Request for DebugResult
    //
    public class ArbitrationDebugResultRequest : XRLObject2
    {
        public ushort version;
        [WireInfo(HexString=true)]
        public ushort flags;
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;

        public byte[] sessionKey
        {
            get
            {
                MemoryStream titleIDSessionIDAndNonceMemStream = new MemoryStream(20);
                BinaryWriter writer = new BinaryWriter(titleIDSessionIDAndNonceMemStream);
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                return (byte[])titleIDSessionIDAndNonceMemStream.ToArray();
            }
        }
    }
    
    //
    // Response from DebugResult request
    //
    public class ArbitrationDebugResultResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;
        public ArbitrationTitleParameters titleParameters;
        [WireInfo(HexString=true)]
        public ushort flags;
        public ushort maxSessionSeconds;
        public ushort secondsLeftTillTimeout;
        public DateTime startTime;
        public double sessionSeconds;
        
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount")]        
        public ArbitrationXboxInfo[] xboxes;

        public int teamTicketCount;
        
        public double totalTrust;
        public uint reportCount;
        public bool arbitrated;
        
        public int result; // ArbitrationSessionOutcome
        public int nonProblematicResult; // ArbitrationSessionOutcome
        public float trustModificationScale;

        public int bundleCount;
        [WireInfo(SizeParam="bundleCount")]        
        public ArbitrationBundle[] bundles;
        public int submittedBundleIndex;
        
        public int suspiciousInfoCount;
        [WireInfo(SizeParam="suspiciousInfoCount")]        
        public ArbitrationSuspiciousInfo[] suspiciousInfo;
    }
    
    
    // 
    // Request for ReportResult
    //
    public class ArbitrationReportResultRequest : XRLObject2
	{
		public class Flags
		{
			public const ushort VoluntarilyQuit=0x8000;
			public const ushort SessionHost=0x4000;
			public const ushort LostConnectivity=0x2000;
			public const ushort LostConnectivityInfoSubmit=0x1000;
			public const ushort SuspiciousInfo1Submit=0x0800;
			public const ushort SuspiciousInfo2Submit=0x0400;
			public const ushort SuspiciousInfo3Submit=0x0200;
			public const ushort StatsBundleInfoSubmit=0x0100;
			public const ushort TournamentBundleInfoSubmit=0x0080;

			public const ushort flagMask=VoluntarilyQuit|SessionHost|LostConnectivity|LostConnectivityInfoSubmit|SuspiciousInfo1Submit|SuspiciousInfo2Submit|SuspiciousInfo3Submit|StatsBundleInfoSubmit|TournamentBundleInfoSubmit;

		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public LostConnectivityInfo lostConnectivityInfo=null;
		public SuspiciousInfo type1SuspiciousInfo= null;
		public SuspiciousInfo type2SuspiciousInfo= null;
		public SuspiciousInfo type3SuspiciousInfo= null;
		public StatsBundle statsBundle= null;
		public TournamentBundle tournamentBundle=null;
        

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(protocolVersion);
            binaryWriter.Write(flags);
            binaryWriter.Write(titleId);
            binaryWriter.Write(sessionId);
            binaryWriter.Write(sessionNonce);
            if (lostConnectivityInfo != null) lostConnectivityInfo.WriteStream(binaryWriter);
    		if (type1SuspiciousInfo != null) type1SuspiciousInfo.WriteStream(binaryWriter);
    		if (type2SuspiciousInfo!= null) type2SuspiciousInfo.WriteStream(binaryWriter);
    		if (type3SuspiciousInfo!= null) type3SuspiciousInfo.WriteStream(binaryWriter);
    		if (statsBundle!= null) statsBundle.WriteStream(binaryWriter);
    		if (tournamentBundle!= null) tournamentBundle.WriteStream(binaryWriter);;
            
        }
            
        

    }
    
	/// <summary>
	/// Arbitration ReportResult request LostConnectivityInfo wiredata
	/// </summary>
	public class LostConnectivityInfo : WireData
	{
		public byte xboxPuidLen=0;
		public ulong[] xboxPuid=null;
	}
	
	/// <summary>
	/// Arbitration ReportResult request SuspiciousInfo wiredata
	/// </summary>
	public class SuspiciousInfo : WireData
	{
		public byte messageLen=0;
		public byte[] message=null;
		public byte relatedXboxLen=0;
		public ulong[] relatedXbox=null;
		public byte relatedUserLen=0;
		public ulong[] relatedUser=null;
	}

	/// <summary>
	/// Arbitration ReportResult request StatsBundle wiredata
	/// </summary>
	public class StatsBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}

	/// <summary>
	/// Arbitration ReportResult request TournamentBundle wiredata
	/// </summary>
	public class TournamentBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\AATransaction.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;

using System.IO;
using System.Net;
using System.Web;
using System.Threading;


namespace live.protocol
{
    public class AATransaction : HttpTransaction
    {
        public override uint SendRequest(
           IClient client,
           XblUser activeUser,
           XOService service,
           string relativeUrl,
           string httpMethod,
           WebHeaderCollection webHeaders,
           XRLObject2 reqOb,
           XRLObject2 respOb)
        {

            if (reqOb is live.protocol.next.WebRequestBase)
            {
                this.UseSSL = ((live.protocol.next.WebRequestBase)reqOb).UseSSL;
            }
            else if (reqOb is PayloadRequest)
            {
                this.UseSSL = ((PayloadRequest)reqOb).UseSSL;
            }

            uint hr;
            try
            {
                hr = base.SendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, respOb);
            }
            catch (XrlRequestException xre)
            {
                hr = ParseXmlError(xre.RespData);
                if (hr == 0)
                {
                    throw;
                }
            }

            return hr;

        }

        private uint ParseXmlError(string xmlError)
        {
            if (String.IsNullOrEmpty(xmlError))
            {
                return 0;
            }
            xmlError = xmlError.ToLower();
            const string HRTAG = "<hresult>";
            const string HRENDTAG = "</hresult>";
            int i = xmlError.IndexOf(HRTAG);
            if (i == -1)
            {
                return 0;
            }
            i += HRTAG.Length;
            int size = xmlError.IndexOf(HRENDTAG) - i;
            if (size < 0)
            {
                return 0;
            }
            uint hr;
            if (uint.TryParse(xmlError.Substring(i, size).Replace("0x",""),System.Globalization.NumberStyles.HexNumber, null, out hr))
            {
                return hr;
            }
            return 0;
        }

        override public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if (activeUser != null)
            {
                if (webHeaders["Authorization"] == null)
                {
                    string ticket;

                    ticket = PassportAuth.GetAAPassportTicket(activeUser.Settings.UserPassportInfo.MemberName, activeUser.Settings.UserPassportInfo.Password, "hbi");

                    webHeaders.Add("Authorization: WLID1.0 t=" +
                      ticket);

                    Logging.WriteLine("Ticket: " + ticket);
                }
            }
            uint hr;
            response = null;
            try
            {

                hr = base.SendRequest(client, activeUser, XOService.ActiveAuthSg, relativeUrl, httpMethod, webHeaders, request, out response);
            }
            catch (XrlRequestException xre)
            {
                hr = ParseXmlError(xre.RespData);
                if (hr == 0)
                {
                    throw;
                }
            }

            return hr;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveLib")]
#if INTERNALTEST
[assembly: AssemblyDescription("Internal Use to the Xbox Live Server team. Not supported for use by internal or external partners")]
#else
[assembly: AssemblyDescription("Allows For easy access into the Xboxlive environment for Microsoft partners")]
#endif
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("XBoxOnline")]
[assembly: AssemblyProduct("LiveLib")]
[assembly: AssemblyCopyright("Copyright © XBoxOnline 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9d2d7113-8b5d-40e7-b5e7-3530f5114935")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\AccessToken.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Net;
using System.Security.Cryptography;
using System.Text;

using live.common;

//[assembly: XomAreaDefinition(XomAreaName.atTrace)]

namespace live.protocol
{

    public class AccessToken : WireData
    {
        public ushort _operation;
        public ushort _version = accessTokenVersion;
        public uint   _serviceId;
        public uint   _flags;
        public ulong  _userPuid;
        public ulong  _xboxPuid;
        public ushort _pathNameSize;
        [WireInfo(SizeParam = "_pathNameSize")]
        public string _pathName;
        public ushort _signatureSize;
        [WireInfo(SizeParam = "_signatureSize")]
        public byte[] _signature;
        
        // Alternative SignOnBehalf URL
        protected string _altSignUrl = null;
    
        public const ushort baseTokenSize = 32;
        public const ushort accessTokenVersion = 1;

//         string _verifyUrl
//         {
//             get
//             {
//                 IVirtualInterfaceInfo info = GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
//                 return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/VerifySignature.ashx";
//             }
//         }
// 
//         string _signUrl
//         {
//             get
//             {
//                 if(_altSignUrl == null)
//                 {
//                     IVirtualInterfaceInfo info = GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
//                     return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/SignOnBehalf.ashx";
//                 }
//                 else
//                 {
//                     return _altSignUrl;
//                 }
//             }
//         }
// 
//         int _xsigTimeout
//         {
//             get
//             {
//                 IVirtualInterfaceInfo info = GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
//                 return info.Timeout;
//             }
//         }

        public virtual void ReadFrom(BinaryReader r)
        {
            // read common data
            _operation    = r.ReadUInt16();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: operation="+_operation.ToString("d"));
            _version      = r.ReadUInt16();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: version="+_version.ToString("d"));
            _serviceId    = r.ReadUInt32();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: serviceId="+_serviceId.ToString("X"));
            _flags        = r.ReadUInt32();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: flags="+_flags.ToString("X"));
            _userPuid     = r.ReadUInt64();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: userPuid="+_userPuid.ToString("X"));
            _xboxPuid     = r.ReadUInt64();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: xboxPuid="+_xboxPuid.ToString("X"));
            _pathNameSize = r.ReadUInt16();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathNameSize="+_pathNameSize.ToString("d"));
            if ( _pathNameSize > 0 )
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
                // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathName="+_pathName);
            }

            // read data specific to request token
            ReadFromInternal(r);

            // read signature data if present
            _signatureSize = r.ReadUInt16();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: signatureSize="+_signatureSize.ToString("d"));
            if ( _signatureSize > 0 )
            {
                _signature = r.ReadBytes(_signatureSize);
            }
        }
        
        public virtual void WriteTo(BinaryWriter w)
        {
            // write everything but the signature
            WriteToSign(w);
            
            // write the signature
            _signatureSize = (ushort) ((_signature == null ? 0 : ProtocolConstants.sizeSignature));

            w.Write(_signatureSize);
            if ( _signatureSize > 0 )
            {
                w.Write(_signature);
            }
        }
        
        // WriteToSign
        // Write all data excluding signature field.  Used to create byte array
        // to sign or validate using signature server.
        public virtual void WriteToSign(BinaryWriter w)
        {
            byte[] encodedName = null;
            
            _pathNameSize = 0;
            if ( _pathName != null )
            {
                encodedName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort) encodedName.Length;
            }
            
            w.Write(_operation);
            w.Write(_version);
            w.Write(_serviceId);
            w.Write(_flags);
            w.Write(_userPuid);
            w.Write(_xboxPuid);
            w.Write(_pathNameSize);
            if ( _pathNameSize > 0 )
            {
                w.Write(encodedName);
            }

            // write data specific to request token
            WriteToInternal(w);
        }
    
        protected virtual void ReadFromInternal(BinaryReader r)
        {
        }
        
        protected virtual void WriteToInternal(BinaryWriter w)
        {
        }

        protected virtual ushort SizeInternal()
        {
            return 0;
        }

        // Size
        // Return the size of the AccessToken in bytes
        public override int Size()
        {
            return (ushort)(baseTokenSize + _pathNameSize + _signatureSize + SizeInternal());
        }

        public virtual void Validate()
        {
            if (_version != AccessToken.accessTokenVersion)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid version: " + _version);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_147,
                    "Validate: invalid version: " + _version);
            }
            if (_pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_148,
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if (_pathNameSize != _pathName.Length)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_149,
                    "Validate: pathNameSize mismatch.");
            }
            if (_signatureSize != 0 && _signatureSize != ProtocolConstants.sizeSignature)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid signature size: " + _signatureSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_150,
                    "Validate: invalid signature size: " + _signatureSize);
            }

            // This check needs to be removed if we ever make use of the
            // flags field in the protocol.
            if (_flags != 0 && _flags != 1)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid flags: " + _flags);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_151,
                    "Validate: invalid flags: " + _flags);
            }
        }

//         // this version of SignOnBehalf will take the authData from SGInfo
//         public virtual void SignOnBehalf(XOService serviceId)
//         {
//             SGInfo sgInfo = SGInfo.Current;
//             
//             XSigAuthData authData = new XSigAuthData();
//             authData._titleID = sgInfo.TitleId;
//             authData._titleVersion = sgInfo.TitleVersion;
//             authData._userID1 = sgInfo.LogonUsers[0].qwUserID;
//             authData._userID2 = sgInfo.LogonUsers[1].qwUserID;
//             authData._userID3 = sgInfo.LogonUsers[2].qwUserID;
//             authData._userID4 = sgInfo.LogonUsers[3].qwUserID;
//             authData._XboxID = sgInfo.MachineId;
//             
//             SignOnBehalf(serviceId, authData);
//         }
// 
//         public virtual void SignOnBehalf(XOService serviceId, XSigAuthData authData)
//         {
//             XSigSignOnBehalfRequest signRequest = new XSigSignOnBehalfRequest();
//             signRequest._serviceId = (uint) serviceId;
//             signRequest._authData = authData;            
//             
//             MemoryStream m = new MemoryStream();
//             BinaryWriter w = new BinaryWriter(m);
//             WriteToSign(w);
//             byte[] b = m.ToArray();
//             SHA1 sha1 = new SHA1CryptoServiceProvider();
//             signRequest._digest = sha1.ComputeHash(b);
// 
//             // Make a single byte array with all of the required data needed
//             // for the signature server request.  Making just 1 Write call
//             // to send the request data instead of 3 separate Write calls for
//             // the individual components makes the thread less likely to get
//             // interrupted in midstream and thus less susceptable to timeouts.
//             byte[] requestData = (byte[]) signRequest;
//             
//             uint hr = HResult.S_OK;
//             
//             try
//             {
//                 WebRequest req = WebRequest.Create( _signUrl);
//                 req.Timeout = _xsigTimeout;
//                 req.Method = "POST";
//                 req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
//                 req.ContentLength = requestData.Length;
//                 
//                 Stream reqStream = req.GetRequestStream();
//                 w = new BinaryWriter(reqStream);
//                 w.Write(requestData);
//                 reqStream.Close();
// 
//                 WebResponse resp = req.GetResponse();
//                 Stream respStream = resp.GetResponseStream();
//                 BinaryReader r = new BinaryReader(respStream);
//                 hr = r.ReadUInt32();
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: hr = 0x" + hr.ToString("X"));
//                 _signature = r.ReadBytes(ProtocolConstants.sizeSignature); //TODO: fix this
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: XSig returned signature: " + ByteConvert.ToString(_signature));
//             }
//             catch (Exception e)
//             {
//                 if ( e is WebException )
//                 {
//                     WebException we = ((WebException) e);
//                     string xerr = "";
//                     string responseText = "";
//                     
//                     if ( we.Response != null )
//                     {
//                         StreamReader sr = new StreamReader(we.Response.GetResponseStream());
//                         responseText = sr.ReadToEnd();
//                         
//                         if ( we.Response.Headers != null )
//                         {
//                             xerr = we.Response.Headers["X-Err"];
//                         }
//                     }
//                     
//                     // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + we + ", response: " + responseText);
// 
//                     if ( xerr != null && xerr != "" )
//                     {
//                         // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: X-Err: " + xerr);
//                         hr = HResult.Parse(xerr);
//                     }
//                     else
//                     {
//                         // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: No X-Err header found.");
//                         hr = HResult.XONLINE_E_SERVER_ERROR;
//                     }
//                 }
//                 else
//                 {
//                     // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + e);
//                     hr = HResult.XONLINE_E_SERVER_ERROR;
//                 }
//             }
//             
//             if ( HResult.Failed(hr) )
//             {
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: failed with hr: 0x" + hr.ToString("X"));
//                 throw new XRLException(hr, XEvent.Id.COMMON_CODE_152, "SignOnBehalf: failed with hr: 0x" + hr.ToString("X"));
//             }
//         }
// 
//         public virtual uint SigningService
//         {
//             get
//             {
//                 uint serviceId = BitConverter.ToUInt32(_signature, 4);
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SigningService.get: signed on behalf of service: " + serviceId.ToString("x"));
//                 return serviceId;
//             }
//         }
//     
//         public virtual void VerifySignature()
//         {
//             VerifySignature((XOService)Int32.MinValue);
//         }
// 
//         public virtual void VerifySignature(XOService serviceId)
//         {
//             MemoryStream m = new MemoryStream();
//             BinaryWriter w = new BinaryWriter(m);
//             WriteToSign(w);
//             byte[] b = m.ToArray();
//             SHA1 sha1 = new SHA1CryptoServiceProvider();
//             byte[] digest = sha1.ComputeHash(b);
//             
//             uint hr = HResult.E_FAIL;
//             int expectedServiceId = (int) serviceId;
//             
//             try
//             {
//                 // If serviceId == Int32.MinValue, then we don't care about
//                 // what service created the signature.
//                 if ( expectedServiceId != Int32.MinValue )
//                 {
//                     // the service id that created the signature is stored as
//                     // bytes 5-8 of the signature blob
//                     uint actualServiceId = BitConverter.ToUInt32(_signature, 4);
//                     // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, String.Format("VerifySignature: expected service id: {0}, actual service id: {1}", expectedServiceId, actualServiceId));
// 
//                     // Check the service id that was included in the
//                     // signature.
//                     if ( actualServiceId != expectedServiceId )
//                     {
//                         throw new
//                             XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_153,
//                                 String.Format("VerifySignature: expected service id: {0}, found service id: {1}", expectedServiceId, actualServiceId));
//                     }
// 
//                     // Also check the service id that was included in the
//                     // protocol request.
//                     if ( _serviceId != expectedServiceId )
//                     {
//                         throw new
//                             XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_154,
//                                 String.Format("VerifySignature: expected service id: {0}, protocol service id: {1}", expectedServiceId, _serviceId));
//                     }
//                 }
// 
//                 // Make a single byte array with all of the required data
//                 // needed for the signature server request.  Making just 1
//                 // Write call to send the request data instead of 2 separate
//                 // Write calls for the digest and signature makes the thread
//                 // less likely to get interrupted in midstream and thus less
//                 // susceptable to timeouts.
//                 byte[] requestData = new byte[digest.Length + _signature.Length];
//                 Array.Copy(digest, 0, requestData, 0, digest.Length);
//                 Array.Copy(_signature, 0, requestData, digest.Length, _signature.Length);
// 
//                 WebRequest req = WebRequest.Create(_verifyUrl);
//                 req.Timeout = _xsigTimeout;
//                 req.Method = "POST";
//                 req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
//                 req.ContentLength = digest.Length + _signature.Length;
//                 
//                 Stream reqStream = req.GetRequestStream();
//                 w = new BinaryWriter(reqStream);
//                 w.Write(requestData);
//                 reqStream.Close();
// 
//                 WebResponse resp = req.GetResponse();
//                 Stream respStream = resp.GetResponseStream();
//                 BinaryReader r = new BinaryReader(respStream);
//                 hr = r.ReadUInt32();
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: hr = 0x" + hr.ToString("X"));
//             }
//             catch (Exception e)
//             {
//                 if ( e is WebException )
//                 {
//                     WebException we = ((WebException) e);
//                     string xerr = "";
//                     string responseText = "";
// 
//                     if ( we.Response != null )
//                     {
//                         StreamReader sr = new StreamReader(we.Response.GetResponseStream());
//                         responseText = sr.ReadToEnd();
// 
//                         if ( we.Response.Headers != null )
//                         {
//                             xerr = we.Response.Headers["X-Err"];
//                         }
//                     }
//                     
//                     // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + we + ", response: " + responseText);
//                     
//                     if ( xerr != null && xerr != "" )
//                     {
//                         // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: X-Err: " + xerr);
//                         hr = HResult.Parse(xerr);
// 
//                         // We will log a security error event that contains the
//                         // specific xerr from the signature server and all of
//                         // the SGInfo associated with the request.
// //                       Xom.NtEvent(XEvent.Id.COMMON_HACK_7,
// //                             "AccessToken.VerifySignature: signature server returned hr: 0x" + xerr +
// //                             "\r\nWebException: " + we +        
// //                             "\r\nSGInfo: " + SGInfo.ToStr());
//                         
//                     }
//                     else
//                     {
//                         // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: No X-Err header found.");
//                         if ( we.Status == WebExceptionStatus.Timeout )
//                         {
// //                           Xom.NtEvent(XEvent.Id.COMMON_COMM_12,
// //                                "AccessToken.VerifySignature: signature server timeout error; current timeout is " + _xsigTimeout + " ms.  " +
// //                                "Verify that the signature server is running and there is connectivity to STFD." +
// //                                 "\r\nWebException: " + we);
//                         }
//                         else
//                         {
// //                           Xom.NtEvent(XEvent.Id.COMMON_COMM_13,
// //                                 "AccessToken.VerifySignature: failed to receive response from signature server." +
// //                                 "\r\nWebException: " + we);
//                         }
//                         hr = HResult.XONLINE_E_SERVER_ERROR;
//                     }
//                 }
//                 else
//                 {
//                     // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + e);
//                     hr = HResult.XONLINE_E_SERVER_ERROR;
//                 }
//             }
//             
//             if ( HResult.Failed(hr) )
//             {
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: failed with hr: 0x" + hr.ToString("X"));
//                 throw new XRLException(hr, XEvent.Id.COMMON_CODE_155, "VerifySignature: failed with hr: 0x" + hr.ToString("X"));
//             }
//         }
//     
        public override string ToString()
        {
            return
                " _operation:"+((ushort)_operation)+
                " _version:"+_version+
                " _serviceId:0x"+_serviceId.ToString("X")+
                " _flags:"+_flags+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _pathNameSize:"+_pathNameSize+
                " _pathName:"+_pathName+
                " _signatureSize:"+_signatureSize+
                " _signature:"+(_signature!=null ? "(binary)" : "null");
        }
        
        public void SetAltSignUrl(
            string altSignUrl
        )
        {
            _altSignUrl = altSignUrl;
        }
    }

    public class ReadFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public ReadFileToken()
        {
        }

        public ReadFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }

        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }
        public override void Validate()
        {
            base.Validate();

            // TODO: there should be base class that ReadFileToken and EnumerateFilesToken derive from.  For now, let enumerate use ReadFileToken class
            if (_operation != (ushort)Operation.FileRead && _operation != (ushort)Operation.FileEnumerate)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_156,
                    "Validate: invalid operation: " + _operation);
            }

            if (_tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime())
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_157,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }

    public class WriteFileToken : AccessToken
    {
        public long _tokenExpirationDate;
        public long _fileExpirationDate;
        public uint _maxFileSize;

        public WriteFileToken()
        {
        }
        
         public WriteFileToken(BinaryReader r)
         {
             this.ReadFrom(r);
         }
         
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: tokenExpirationDate="+_tokenExpirationDate.ToString());
            _fileExpirationDate = r.ReadInt64();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: fileExpirationDate="+_fileExpirationDate.ToString());
            _maxFileSize = r.ReadUInt32();
            // Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: maxFileSize="+_maxFileSize.ToString());
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
            w.Write(_fileExpirationDate);
            w.Write(_maxFileSize);
        }

        protected override ushort SizeInternal()
        {
            return 20;
        }

//         public override void Validate()
//         {
//             base.Validate();
//             
//             if ( _operation != (ushort) Operation.FileWrite )
//             {
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
//                 throw new XRLException(
//                     HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_158, 
//                     "Validate: invalid operation: " + _operation);
//             }
// 
//             // DateTime.Now gives us localtime; calling ToFileTime() adds
//             // UTC offset giving us a result that is the current time in UTC
//             long now = DateTime.Now.ToFileTime();
//             
//             if ( _fileExpirationDate != 0 && _fileExpirationDate < now )
//             {
//                 // Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: fileExpirationDate is in the past.");
//                 throw new XRLException(
//                     HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_159,
//                     "Validate: fileExpirationDate is in the past: " + _fileExpirationDate);
//             }
//             if ( _tokenExpirationDate != 0 && _tokenExpirationDate < now )
//             {
//                 throw new XRLException(
//                     HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_160,
//                     "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
//             }
//         }

        public override string ToString()
        {
            string baseString = base.ToString();
            return baseString +
                " _fileExpirationDate:" + 
                " _maxFileSize:"+_maxFileSize;
        }
    }

    public class RemoveFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public RemoveFileToken()
        {
        }

        public RemoveFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }

        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }

        public override void Validate()
        {
            base.Validate();

            if (_operation != (ushort)Operation.FileRemove)
            {
                //Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_161,
                    "Validate: invalid operation: " + _operation);
            }
            if (_tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime())
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_162,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace live.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.198.102.221/WebClientProxy.asmx")]
        public string LiveLib_WebClientProxyWebReference_WebClientProxy {
            get {
                return ((string)(this["LiveLib_WebClientProxyWebReference_WebClientProxy"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.198.102.221/FakeSGProxy.asmx")]
        public string LiveLib_FakeSGProxyWebReference_FakeSGProxy {
            get {
                return ((string)(this["LiveLib_FakeSGProxyWebReference_FakeSGProxy"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.198.102.221/FakeSGProxy.asmx")]
        public string LiveLib_FakeSGProxyWebReference1_FakeSGProxy {
            get {
                return ((string)(this["LiveLib_FakeSGProxyWebReference1_FakeSGProxy"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.198.102.221/WebClientProxy.asmx")]
        public string LiveLib_WebReference_WebClientProxy {
            get {
                return ((string)(this["LiveLib_WebReference_WebClientProxy"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\FakeAAInfo.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;

using live.common;


namespace live.protocol
{
    public class FakeAAInfo : AAInfo
    {

        public FakeAAInfo() : base() {}

        public FakeAAInfo(XblUser user) : base(user.Settings.UserPassportInfo.PassportPuid, GetIPv4Address().ToString())
 { }

        public FakeAAInfo(XblUser user, IPAddress ip) : base(user.Settings.UserPassportInfo.PassportPuid, ip.ToString()) { }

        public FakeAAInfo(ulong passportPuid)
            : base(passportPuid, GetIPv4Address().ToString())
        {
        }

        public FakeAAInfo(ulong passportPuid, string ipAddressInternet)
            : base(passportPuid, ipAddressInternet)
        {
        }

        protected override void PopulateLiveXuid()
        {

        }

        protected override void PopulateUserInfo()
        {

        }

        protected override void PopulateUserPrivileges()
        {

        }

        public static IPAddress GetIPv4Address()
        {
            return GetIPv4Address(Dns.GetHostEntry(Dns.GetHostName()).AddressList);
        }

        public static IPAddress GetIPv4Address(IPAddress[] addrList)
        {
            foreach (IPAddress ipAddr in addrList)
            {
                if ( ipAddr.AddressFamily == AddressFamily.InterNetwork )
                {
                    return ipAddr;
                }
            }

            return null;
        }

        public static string HeaderKey
        {
            get
            {
                return FakeAAInfo.c_HdrKey;
            }
        }

        public string ConvertoToBase64String()
        {
            return base.ConvertToBase64String();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\AccountsProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.InteropServices;

using live.common;
using live.client;
using xonline.common.mgmt;
//using xonline.common.service;
using xonline.core.wiredata;

namespace live.protocol
{
    public enum ServiceTypeEnum : uint
    {
        None = 0,
        XboxLive    = 1,
        Zune        = 2,
    }

    public enum ClientTypeEnum : uint
    {
        Unknown      = 0,
        Xbox1        = 1,
        Xenon        = 2,
        Panorama     = 4,
        Web          = 8,   // xbox.com or zune.net 
        ZuneDorado   = 16,
        WindowsPhone = 32
    }

    public enum SubscriptionTypeEnum : uint
    {
        XboxLive = 1,
        ZunePass = 2,
        PhantasyStarUniverse = 3,
    }

    public enum PaymentInstrumentTypeEnum
    {
        None        = 0,
        CreditCard  = 1,
        DirectDebit = 2,
        Wholesale = 3,
    }
    
    public class AddressInfoData : WireData
    {
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1 = "1 Microsoft Way";

        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2 = "";

        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city = "Redmond";

        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district = "";

        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state = "WA";

        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = "98052";

        public AddressInfoData()
        {
            cityLength = (ushort)city.Length;
            districtLength = (ushort)district.Length;
            postalCodeLength = (ushort)postalCode.Length;
            stateLength = (ushort)state.Length;
            street1Length = (ushort)street1.Length;
            street2Length = (ushort)street2.Length;
        }
    }

    public class PhoneInfoData : WireData
    {
        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension = "";
    }

    public class CreditCardInfoData : WireData
    {
        public byte     cardType = (byte)CreditCardType.Visa;

        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        [WireInfo(Min=0, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        public ushort   ccvNumberLength = 0;

        [WireInfo(SizeParam="ccvNumberLength")]
        public string   ccvNumber = "";

        public DateTime expirationDate = new DateTime(2001,11,15);
    }

    public class DirectDebitInfoData : WireData
    {
        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits = "";
    }

    public class WholesaleInfoData : WireData
    {
        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort ExternalReferenceIdLength = 0;
        [WireInfo(SizeParam = "ExternalReferenceIdLength")]
        public string ExternalReferenceId = "";

        public ushort wholesalePartnerLength = 0;

        [WireInfo(SizeParam = "wholesalePartnerLength", MaskString = true)]
        public string wholesalePartner = "";

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam = "encryptedPasswordLength", MaskString = true)]
        public string encryptedPassword = "";
    }

    public class BillingAgreementDetails  : WireData
    {
        public ushort payerEmailLength;

        [WireInfo(SizeParam = "payerEmailLength")]
        public string payerEmail;

        public ushort billingAgreementIdLength;

        [WireInfo(SizeParam = "billingAgreementIdLength")]
        public string billingAgreementId;

        public ushort firstNameLength;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public ushort middleNameLength;

        [WireInfo(SizeParam = "middleNameLength")]
        public string middleName;

        public ushort payerBusinessLength;

        [WireInfo(SizeParam = "payerBusinessLength")]
        public string payerBusiness;

        public ushort payerCountryLength;

        [WireInfo(SizeParam = "payerCountryLength")]
        public string payerCountry;

        public ushort billingAgreementDescriptionLength;

        [WireInfo(SizeParam = "billingAgreementDescriptionLength")]
        public string billingAgreementDescription;
    }

    public class PayPalPayinInfoData : WireData
    {
        public PayPalPayinInfoData()
        {
            billingAgreementDetails = new BillingAgreementDetails();
        }

        public BillingAgreementDetails billingAgreementDetails;
    }

    // requests that contain account creation information should
    // implement this so the common utilities can be created
    public interface ICreateAccountRequest
    {
        string FirstName { get; }
        string LastName { get; }
        string Gamertag { get; }
        string Email { get; }
        PhoneInfoData PhoneInfo { get; }
        AddressInfoData AddressInfo { get; }
        byte PaymentInstrumentType { get; }
        CreditCardInfoData CreditCardInfo { get ; }
        DirectDebitInfoData DirectDebitInfo { get; }
        WholesaleInfoData WholesaleInfo { get; }
        byte CountryId { get; }
        ushort LanguageId { get; }
        string CountryCode { get; }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateLiveAccountRequest : XRLRequestObject2, ICreateAccountRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateLiveAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
    }

    public class CreateLiveAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    public class CreateLiveAccountExtra : XRLObject2
    {
        public bool createArgoProfile;
    }

    public class CreateLiveAccountEntryPoint : XRLObject2
    {
        public uint serviceType;
        public uint clientType;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateWholesaleAccountRequest : XRLRequestObject2, ICreateAccountRequest
    {

        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString = true)]
        public uint wholesalePartnerId = 0;

        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public DateTime birthdate;

        [WireInfo(Min = 1, Max = XOn.MAX_EMAIL_SIZE * XOn.UTF8_MULT)]
        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public WholesaleInfoData wholesaleInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam = "reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize = false)]
        public string countryCode;

        override public string Xrl
        {
            get { return "/xuacs/CreateWholesaleAccount.ashx"; }
        }

        // ICreateWholesaleAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return new CreditCardInfoData(); }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return wholesaleInfo; }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
    }

    public class CreateWholesaleAccountResponse : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid = 0;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "GetPaymentInstruments", "urn:shemas-xbox-com:user_account-data")]
    public class GetPaymentInstrumentsRequest : PayloadRequestWithSSL
    {
        [WireInfo(HexString=true)]
        [PayloadParam]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [PayloadParam]
        public ushort maxResults;
        [WireInfo(MinSchemaVersion="5.4")]
        public bool includePayPalPayin = false;

        [WireInfo(MinSchemaVersion="5.4")]
        public bool includeExpiredCreditCards = true;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetPaymentInstruments.ashx"; }
        }
    }

    public class PaymentInstrumentInfo : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public byte creditCardType = 0;

        public ushort accountNumberLastFourLength = 0;

        [WireInfo(SizeParam="accountNumberLastFourLength")]
        public string accountNumberLastFour;
    }

    public class PaymentInstrumentInfoEx : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(MinSchemaVersion = "3.3")]
        public WholesaleInfoData wholesaleInfo;

        [WireInfo(MinSchemaVersion = "5.4")]
        public PayPalPayinInfoData paypalPayinInfo;
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "GetPaymentInstruments")]
    public class GetPaymentInstrumentsResponse : PayloadResponse
    {
        public ushort count;

        [WireInfo(SizeParam="count")]
        [PayloadParam]
        public PaymentInstrumentInfoEx[] paymentInstrumentInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateXboxComAccountRequest : XRLRequestObject2, ICreateAccountRequest
    {
        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong userPassportPuid = 0;

        [WireInfo(HexString=true)]
        public ulong ownerPassportPuid = 0;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateXboxComAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
    }

    public class CreateXboxComAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;
    }

    public class PassportGetUserDataRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetUserData.ashx"; }
        }
    }

    public class PassportGetUserDataResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte countryId;

        [WireInfo(Min=0, Max=XOn.MAX_EMAIL_SIZE*XOn.UTF8_MULT)]
        public ushort emailLength = 0;

        [WireInfo(SizeParam="emailLength")]
        public string email;
    }

    public class XePassportGetMemberNameRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetMemberName.ashx"; }
        }
    }

    public class XePassportGetMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort userPmnLength = 0;

        [WireInfo(SizeParam="userPmnLength")]
        public string userPmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPmnLength = 0;

        [WireInfo(SizeParam="parentPmnLength")]
        public string parentPmn;
        [WireInfo(Min=0, Max=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN, MinSchemaVersion="3.1")]
        public ushort cidLength = 0;

        [WireInfo(SizeParam="cidLength", MinSchemaVersion="3.1")]
        public string userCid;
    }

    public class XePassportGetFriendMemberNameRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;


        [WireInfo(HexString=true)]
        public ulong friendPuid;


        public override string Xrl
        {
            get { return "/xuacs/XePassportGetFriendMemberName.ashx"; }
        }
    }

    public class XePassportGetFriendMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort friendPmnLength = 0;

        [WireInfo(SizeParam="friendPmnLength")]
        public string friendPmn;
    }

    public class XePassportGetBuddyGamertagRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort buddyPmnLength = 0;

        [WireInfo(SizeParam="buddyPmnLength")]
        public string buddyPmn;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetBuddyGamertag.ashx"; }
        }
    }

    public class XePassportGetBuddyGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong buddyPuid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort buddyGamertagLength = 0;

        [WireInfo(SizeParam="buddyGamertagLength")]
        public string buddyGamertag;
    }

    public class XeABCHGetContactlistGamertagsRequest : XRLRequestObject2WithFlags
    {
        static ushort QueryAtSignupForUsersInABCHandXBL         = 0x0001;
        static ushort QueryAtLoginForUsersInABCHandXBL          = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ushort requestFlags;

        public override string Xrl
        {
            get { return "/xuacs/XeABCHGetContactlistGamertags.ashx"; }
        }

        public bool queryAtSignupForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtSignupForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtSignupForUsersInABCHandXBL, value, ref requestFlags);
            }
        }

        public bool queryAtLoginForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtLoginForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtLoginForUsersInABCHandXBL, value, ref requestFlags);
            }
        }
    }

    public class XeABCHGetContactlistGamertagsResponse : XRLObject2
    {
        public ushort ABCHGetContactlistItemCount;

        [WireInfo(SizeParam="ABCHGetContactlistItemCount")]
        public ABCHGetContactlistItem [] items;
    }

    public class ABCHGetContactlistItem : XRLObject2WithFlags
    {
        static ushort UserInABCH            = 0x0001;
        static ushort UserInXBL             = 0x0002;

        public ABCHGetContactlistItem()
        {
            responseFlags = 0;
        }

        [WireInfo(HexString=true)]
        public ulong puid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort pmnLength = 0;

        [WireInfo(SizeParam="pmnLength")]
        public string pmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort displayNameLength = 0;

        [WireInfo(SizeParam="displayNameLength")]
        public string displayName;

        public ushort responseFlags;

        public bool userInABCH
        {
            get
            {
                return IsFlagSet(UserInABCH, responseFlags);
            }
            set
            {
                SetFlag(UserInABCH, value, ref responseFlags);
            }
        }

        public bool userInXBL
        {
            get
            {
                return IsFlagSet(UserInXBL, responseFlags);
            }
            set
            {
                SetFlag(UserInXBL, value, ref responseFlags);
            }
        }
    }

    public class XeUpsGetProfileRequest : XRLRequestObject2
    {
        public ulong  puid;

        public ushort attributesLength = 0;

        [WireInfo(SizeParam="attributesLength")]
        public string attributes;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsGetProfile.ashx"; }
        }
    }

    public class XeUpsGetProfileResponse : XRLObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;
    }

    public class XeUpsUpdateProfileRequest : XRLRequestObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsUpdateProfile.ashx"; }
        }
    }

    public class ReadProfileSettingsRequest : XRLRequestObject2
    {
        public override string Xrl
        {
            get { return "/xuacs/XeReadProfileSettings.ashx"; }
        }
    }

    public class ReadProfileSettingsResponse : XRLObject2
    {
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "AddPaymentInstrument", "urn:shemas-xbox-com:user_account-data")]
    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class AddPaymentInstrumentRequest : PayloadRequestWithSSL
    {
        [WireInfo(HexString=true)]
        [PayloadParam]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [PayloadParam]
        public AddressInfoData addressInfo;

        [PayloadParam]
        public PhoneInfoData phoneInfo;

        [PayloadParam]
        public byte paymentInstrumentType = 0;

        [PayloadParam]
        public CreditCardInfoData creditCardInfo;

        [PayloadParam]
        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeAddPaymentInstrument.ashx"; }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:user_account-data", "AddPayemntInstrumentResults")]
    public class AddPaymentInstrumentResponse : PayloadResponse
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        [PayloadParam]
        public string paymentInstrumentId;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "AddCreditCard", "")]
    public class AddCreditCardRequest : PayloadRequestWithSSL
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public ulong machinePuid;

        [PayloadParam]
        public string addressStreet1;

        [PayloadParam]
        public string addressStreet2;

        [PayloadParam]
        public string addressCity;

        [PayloadParam]
        public string addressDistrict;

        [PayloadParam]
        public string addressState;

        [PayloadParam]
        public string addressPostalCode;

        [PayloadParam]
        public string phonePrefix;

        [PayloadParam]
        public string phoneNumber;

        [PayloadParam]
        public string phoneExtension;

        [PayloadParam]
        public byte cardType;

        [PayloadParam]
        public string accountHolderName;

        [PayloadParam]
        public string accountNumber;

        [PayloadParam]
        public string cardVerificationNumber;

        [PayloadParam]
        public string expirationDate;

        public override string Xrl
        {
            get { return "/xuacs/*.ashx"; }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "AddCreditCardResults")]
    public class AddCreditCardResponse : PayloadResponse
    {
        [PayloadParam]
        public string PaymentInstrumentId;
    }

    public class RemovePaymentInstrumentRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public override string Xrl
        {
            get { return "/xuacs/XeRemovePaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class UpdatePaymentInstrumentRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeUpdatePaymentInstrument.ashx"; }
        }
    }

    public class GetUserInfoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeGetUserInfo.ashx"; }
        }
    }

    public class GetUserInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        public byte age;
    }

    public class GetLinkedGamertagRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetLinkedGamertag.ashx"; }
        }
    }

    public class GetLinkedGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class LinkXbox1AccountRequest : XRLRequestObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phoneInfo == null ? "" : phoneInfo.phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeLinkXbox1Account.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersRequest : XRLRequestObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;   // EPLServiceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetEncryptedProxyParameters.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort loginTokenRequestLength = 0;

        [WireInfo(SizeParam="loginTokenRequestLength")]
        public string loginTokenRequest;

        public uint publicKeyPublicExponent;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN, Max=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN)]
        public ushort publicKeyModulusLength;

        [WireInfo(SizeParam="publicKeyModulusLength")]
        public byte[] publicKeyModulus;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN)]
        public byte[] publicKeyDigest;
    }

    public class XePassportCreateRequest : XRLRequestObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength = 0;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(MinSchemaVersion = "4.0")]
        public byte countryId = 0;

        [WireInfo(MinSchemaVersion = "4.0")]
        public DateTime birthdate = DateTime.FromFileTimeUtc(0);

        public override string Xrl
        {
            get { return "/xuacs/XePassportCreate.ashx"; }
        }
    }

    public class XePassportCreateResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;
    }

    public class XePassportLoginRequest : XRLRequestObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort encryptedSessionKeyLength = 0;

        [WireInfo(SizeParam="encryptedSessionKeyLength")]
        public byte[] encryptedSessionKey;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort encryptedTokenRequestLength = 0;

        [WireInfo(SizeParam="encryptedTokenRequestLength")]
        public byte[] encryptedTokenRequest;

        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportLogin.ashx"; }
        }
    }

    public class XePassportLoginResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MIN_LEN, Max=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort nonceLength;

        [WireInfo(SizeParam="nonceLength", MinSchemaVersion="3.0")]
        public byte[] nonce;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort cipherValueLength;

        [WireInfo(SizeParam="cipherValueLength", MinSchemaVersion="3.0")]
        public byte[] cipherValue;
    }

    public class XePassportChangePasswordRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        public override string Xrl
        {
            get { return "/xuacs/XePassportChangePassword.ashx"; }
        }
    }

    public class XePassportGetSecretQuestionsRequest : XRLRequestObject2
    {
        public ushort countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetSecretQuestions.ashx"; }
        }
    }

    public class PassportSecretQuestion : XRLObject2
    {
        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;
    }

    public class XePassportGetSecretQuestionsResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT)]
        public ushort secretQuestionsCount;

        [WireInfo(SizeParam="secretQuestionsCount")]
        public PassportSecretQuestion[] secretQuestions;
    }

    public class XeRecoverAccountRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeRecoverAccount.ashx"; }
        }
    }

    public class XeRecoverAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public ushort domainLength;

        [WireInfo(SizeParam="domainLength")]
        public string domain;

        [WireInfo(Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public ushort realmLength;

        [WireInfo(SizeParam="realmLength")]
        public string realm;
    }

    public class MigrateXbox1UserRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        public ushort userPassportMemberNameLength;

        [WireInfo(SizeParam="userPassportMemberNameLength")]
        public string userPassportMemberName;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXbox1User.ashx"; }
        }
    }

    public class MigrateXbox1UserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class XeSetAccountInfoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte msftOptIn;

        public byte partnerOptIn;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeSetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        [WireInfo(MinSchemaVersion = "3.2")]
        public byte isLightweight;
    }

    public class XeUserGetAccountInfoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public xonline.common.service.Puid userPuid;

        [WireInfo(HexString=true)]
        public xonline.common.service.Puid machinePuid;

        [WireInfo(HexString=true)]
        public xonline.common.service.TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAccountInfo.ashx"; }
        }
    }

    public class XeUserGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte age;
    }


    public class GetUserTenureRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public xonline.common.service.Puid userPuid;

        [WireInfo(HexString=true)]
        public xonline.common.service.TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetUserTenure.ashx"; }
        }
    }

    public class GetUserTenureResponse : XRLObject2
    {
        public int      tenureLevel;

        public int      tenureMilestone;

        public DateTime nextMilestoneDate;
    }
    public class XeGetAccountInfoFromPassportRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfoFromPassport.ashx"; }
        }
    }

    public class XeGetUserTypeRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserType.ashx"; }
        }
    }

    public class XeGetUserTypeResponse : XRLObject2
    {
        public byte userType;

        // the UserType property is a value within the range of the UserTypeEnum
        public byte UserType
        {
            get { return (byte)(userType & 0x7f); }
        }

        // the HasGamerProfile property is true if the high bit is set
        public bool HasGamerProfile
        {
            get { return (userType & 0x80) == 0x80; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class MigrateXboxComUserRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        public ushort languageId;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXboxComUser.ashx"; }
        }
    }

    public class MigrateXboxComUserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class ChangeSubscriptionPaymentInstrumentRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeChangeSubscriptionPaymentInstrument.ashx"; }
        }
    }

    public class VerifyBillingInfoRequest : XRLRequestObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyBillingInfo.ashx"; }
        }
    }

    public class VerifyBillingInfoResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class VerifyParentCreditCardRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPassportMemberNameLength = 0;

        [WireInfo(SizeParam="parentPassportMemberNameLength")]
        public string parentPassportMemberName;

        [WireInfo(Min=0, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyParentCreditCard.ashx"; }
        }
    }

    public class XeGetUserWebInfoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint)ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserWebInfo.ashx"; }
        }
    }

    public class XeGetUserWebInfoResponse : XRLObject2
    {
        [WireInfo(Serialize=false)]
        public static DateTime dummyMinDate = new DateTime(1900, 1, 1);

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[] userPrivileges;

        public uint tier;

        public DateTime lastWebActivity;

        public int parentalControlGroupId;

        [WireInfo(MinSchemaVersion="2.0")]
        public byte userType;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool billingUnavailable;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool isLightweight;

        [WireInfo(MinSchemaVersion="5.5")]
        public ushort billingAccountIdLength;

        [WireInfo(MinSchemaVersion="5.5", SizeParam="billingAccountIdLength")]
        public string billingAccountId;

        [WireInfo(MinSchemaVersion="6.1")]
        public bool isFreeGamertagChangeEligible;

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime lastMigratedDate;   

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime migrationEligibilityDate;    

        [WireInfo(MinSchemaVersion="6.6")]
        public bool isMigrationEligible;    

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( dummyMinDate == lastWebActivity )
            {
                lastWebActivity = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == lastMigratedDate)
            {
                lastMigratedDate = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == migrationEligibilityDate)
            {
                migrationEligibilityDate = DateTime.FromFileTimeUtc(0);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            if( DateTime.MinValue == lastWebActivity )
            {
                lastWebActivity = dummyMinDate;
            }

            if( DateTime.MinValue == lastMigratedDate)
            {
                lastMigratedDate= dummyMinDate;
            }

            if( DateTime.MinValue == migrationEligibilityDate)
            {
                migrationEligibilityDate = dummyMinDate;
            }

            base.WriteStream( binaryWriter );
        }
    }

    public class XeUpdateXboxComActivityRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint)ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUpdateXboxComActivity.ashx"; }
        }
    }

    public class XeReserveGamertagRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get { return "/xuacs/XeReserveGamertag.ashx"; }
        }
    }

    public class XeReserveGamertagSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class XeReserveGamertagResponse : XRLObject2
    {
        public uint hr;

        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public XeReserveGamertagSuggestedName[] names;
    }

    public class XeTroubleshootAccountRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeTroubleshootAccount.ashx"; }
        }
    }

    public class XeTroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public int downgraded;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public uint billingHR;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int userPassportInvalid;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int ownerPassportInvalid;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;
    }

    public class XeAcknowledgeDowngradeRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userId;

        public override string Xrl
        {
            get { return "/xuacs/XeAcknowledgeDowngrade.ashx"; }
        }
    }

    public class XeAccountQueryRequest : XRLRequestObject2
    {
        public uint requestType;

        [WireInfo(Max=2048)]
        public ushort requestBytesLength;

        [WireInfo(SizeParam="requestBytesLength")]
        public byte[] requestBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeAccountQuery.ashx"; }
        }
    }

    public class XeAccountQueryResponse : XRLObject2
    {
        [WireInfo(Max=2048)]
        public ushort responseBytesLength;

        [WireInfo(SizeParam="responseBytesLength")]
        public byte[] responseBytes;
    }

    public class DisableSubscriptionRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public bool addViolation;

        public override string Xrl
        {
            get { return "/xuacs/DisableSubscription.ashx"; }
        }
    }

    public class GetNoAgeOutRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetNoAgeOut.ashx"; }
        }
    }

    public class GetNoAgeOutResponse : XRLObject2
    {
        public bool noAgeOut;
    }

    public class ArgoAuthenticateAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        [WireInfo(Min=0, Max=32)]
        public ushort clientDataLength;

        [WireInfo(SizeParam="clientDataLength")]
        public byte[] clientData;
    }

    public class ArgoAuthenticateAccountRequest : XRLRequestObject2
    {
        public ushort passportTicketLength = 0;

        [WireInfo(SizeParam="passportTicketLength")]
        public string passportTicket;

        public override string Xrl
        {
            get { return "/xuacs/ArgoAuthenticateAccount.ashx"; }
        }
    }

    public class ArgoGetAccountStatusResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint userBillingAccountStatus;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId = 0;
    }

    public class ArgoGetAccountStatusRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/ArgoGetAccountStatus.ashx"; }
        }
    }

    public class ArgoTestCreateAccountResponse : XRLObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong xboxLivePuid;

        [WireInfo(HexString=true)]
        public ulong passportPuid;

        public ushort passportMemberNameLength;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort passportPasswordLength;

        [WireInfo(SizeParam="passportPasswordLength")]
        public string passportPassword;

        public uint pointsBalance;
    }

    public class ArgoTestCreateAccountRequest : XRLRequestObject2
    {
        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoTestCreateAccountExRequest : XRLRequestObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public bool isChildAccount;

        public bool hasPurchaseContentPrivilege;

        public bool hasExplicitContentPrivilege;

        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoSignInSubscriptionInfo : XRLObject2
    {
        [XmlElement("XboxOfferId")]
        public ulong offerId;

        public ushort billingInstanceIdLength;

        [XmlElement("BillingInstanceId")]
        [WireInfo(SizeParam="billingInstanceIdLength")]
        public string billingInstanceId;

        public ushort subscriptionStatusLength;

        [XmlElement("SubscriptionStatus")]
        [WireInfo(SizeParam = "subscriptionStatusLength")]
        public string subscriptionStatus;

        [XmlElement("HasBillingViolation")]
        public bool hasViolations;

        [XmlElement("HasPendingCancel")]
        public bool hasPendingCancel;

        public ushort musicNetSkuLength;

        [XmlElement("MusicNetSku")]
        [WireInfo(SizeParam = "musicNetSkuLength")]
        public string musicNetSku;

        [XmlElement("StartDate")]
        public DateTime startDate;

        [XmlElement("EndDate")]
        public DateTime endDate;
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "SignInResults")]
    public class ArgoSignInResponse : PayloadResponse
    {
        [PayloadParam("AccountInfo/XboxPuid")]
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [PayloadParam("ErrorInfo/TagChangeRequired")]
        public bool nameChangeRequired;

        [PayloadParam("ErrorInfo/AcceptedTermsOfService")]
        public bool acceptedTermsOfService;

        [PayloadParam("ErrorInfo/AccountSuspended")]
        public bool accountSuspended;

        [PayloadParam("ErrorInfo/SubscriptionLapsed")]
        public bool subscriptionLapsed;

        [PayloadParam("ErrorInfo/BillingUnavailable")]
        public bool billingUnavailable;

        public ushort gamertagLength;

        [PayloadParam("AccountInfo/Tag")]
        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public ushort geoCountryCodeLength;

        [PayloadParam("SessionInfo/GeoCountryCode")]
        [WireInfo(SizeParam = "geoCountryCodeLength")]
        public string geoCountryCode;

        [PayloadParam("AccountInfo/ParentallyControlled")]
        public bool parentallyControlled;

        [PayloadParam("AccountInfo/Privileges")]
        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        [PayloadParam("AccountInfo/PointsBalance")]
        public uint pointsBalance;

        [PayloadParam("SubscriptionInfo")]
        public ArgoSignInSubscriptionInfo subInfo;

        [PayloadParam("ErrorInfo/HResult")]
        [WireInfo(Serialize = false)]
        public uint hr = 0;

        [PayloadParam("AccountInfo/CountryCode")]
        public string CountryCode
        {
            get { return ((CountryId)this.countryId).ToString(); }
            set { this.countryId = (byte)Enum.Parse(typeof(CountryId), value, true); }
        }

        [PayloadParam("SessionInfo/SessionKey")]
        [WireInfo(Serialize = false)]
        public byte[] SessionKey;

        [PayloadParam("SessionInfo/MusicNetAuthToken")]
        [WireInfo(Serialize = false)]
        public string MusicNetAuthToken;

        [PayloadParam("AccountInfo/IsLightweight")]
        [WireInfo(Serialize = false)]
        public bool IsLightweight;

        [PayloadParam("AccountInfo/LivePuid")]
        [WireInfo(Serialize = false)]
        public ulong LivePuid;


    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "SignIn", "")]
    public class ArgoSignInRequest : PayloadRequestWithSSL
    {
        public ulong userPuid;

        public ushort clientVersionLength = 0;

        [WireInfo(SizeParam="clientVersionLength")]
        public string clientVersion;

        public override string Xrl
        {
            get { return "/xuacs/ArgoSignIn.ashx"; }
        }
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "GetPaymentInstruments", "")]
    public class WSGetPaymentInstrumentsRequest : PayloadRequestWithSSL
    {
        [PayloadParam("userPuid")]
        public ulong UserPuid;

        [PayloadParam("machinePuid")]
        public ulong MachinePuid;
/*
        [PayloadParam("maxResults")]
        public short MaxResults;
*/
        public override string Xrl
        {
            get
            {
                return string.Empty;
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "GetPaymentInstrumentResults")]
    public class WSGetPaymentInstrumentResponse : PayloadResponse
    {
        [PayloadParam]
        public live.common.ws.PaymentInstrumentInfo[] PaymentInstrumentInfos;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "GetUserAuthorization", "")]
    public class GetUserAuthorizationRequest : PayloadRequestWithSSL
    {

        [PayloadParam]
        public ServiceTypeEnum serviceType;

        [PayloadParam]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/GetUserAuthorization.ashx"; }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "GetUserAuthorizationInfo")]
    public class GetUserAuthorizationResponse : PayloadResponse
    {
        [PayloadParam]
        public SigninErrorInfo ErrorInfo;

         [PayloadParam]
        public SigninAccountInfo AccountInfo;

         [PayloadParam]
         public Subscription[] SubscriptionInfo;

        [PayloadParam]
        public SigninSessionInfo SessionInfo;
    }

    public class AcceptTermsOfServiceRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        public uint titleId = 0;

        public uint serviceType = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/AcceptTermsOfService.ashx"; }
        }
    }

    public class XeReplaceOwnerPassportRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceOwnerPassport.ashx"; }
        }
    }

    public class XeReplaceUserPassportRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceUserPassport.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameRequest : XRLRequestObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam="memberNameLength")]
        public string memberName;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetPuidFromMemberName.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong passportPuid;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class GraduateUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;
    }
    
    public class SwitchUserPassportRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldUserPassportPuid;

        public ushort oldUserPassportMemberNameLength;

        [WireInfo(SizeParam="oldUserPassportMemberNameLength")]
        public string oldUserPassportMemberName;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeSwitchUserPassport.ashx"; }
        }
    }


    [PayloadAction("/xuacs/TransferPoints.asmx", "TransferPointsBalance", "urn:schemas-xbox-com:transfer-points-data")]
    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    public class WSTransferPointsBalance : PayloadRequestWithSSL
    {
        [PayloadParam]
        public ulong primaryUserPuid;

        [PayloadParam]
        public ulong dependentUserPuid;

        [PayloadParam]
        public int pointstoTransfer;
        /*
                [PayloadParam("maxResults")]
                public short MaxResults;
        */
        public override string Xrl
        {
            get { return string.Empty; }
        }
    }
    
    
    
}

namespace live.protocol.next
{
    public class GetUserInfoResponse : XRLObject2
    {
        [WireInfo(Min = 0, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        [WireInfo(Min = 0, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        public byte age;
    }

    public class XePassportGetPuidFromMemberNameRequest : XRLObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam = "memberNameLength")]
        public string memberName;

        public string Xrl
        {
            get { return "/xuacs/XePassportGetPuidFromMemberName.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameResponse : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong passportPuid;
    }

    public class SwitchUserPassportRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldUserPassportPuid;

        public ushort oldUserPassportMemberNameLength;

        [WireInfo(SizeParam="oldUserPassportMemberNameLength")]
        public string oldUserPassportMemberName;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeSwitchUserPassport.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class GraduateUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public string Xrl
        {
            get { return "/xuacs/XeGraduateUser.ashx"; }
        }

    }

    public class WSGetDependentPointsBalanceRequest : WebRequestBase
    {
        [WebRequestParam("primaryUserPuid", WebRequestParamType.StandAlone)]
        public ulong primaryUserPuid;

        [WebRequestParam("dependentUserPuid", WebRequestParamType.StandAlone)]
        public ulong dependentUserPuid;

        public WSGetDependentPointsBalanceRequest()
            : base("/xuacs/TransferPoints.asmx/", "GetDependentPointsBalance")
        {
	        this.UseSSL = true;
        }
    }

    public class WSGetDependentPointsBalanceResponse : UacsWebResponse
    {
        public uint pointsBalance;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\CatalogProtocol.cs ===
using System;
using System.Net;
using System.Text;
using System.Collections.Generic;
using System.Reflection;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using live.common;
using live.common.next;

namespace live.protocol.next
{
    /// <summary>
    /// Base class for a Catalog API web request.  Base classes representing specific
    /// operations should derive from this class.
    /// </summary>
    public abstract class CatalogRequest : WebRequestBase
    {
        public static class CatalogOperation
        {
            public const string TestConnection = "TestConnection";
            public const string Query = "Query";
        }

        public const string CATALOG_BASE_URL = "/Catalog/catalog.asmx";

        public List<StringPair> FilterPairs = null;

        protected CatalogRequest(string operation)
            : base(CATALOG_BASE_URL, operation)
        {
        }

        protected CatalogRequest(string operation, FilterBase filter)
            : base(CATALOG_BASE_URL, operation)
        {
            FilterPairs = WebRequestBase.WebRequestToList(filter);
        }

        protected override string BuildHttpRequest(string seperator)
        {
            string request = base.BuildHttpRequest(seperator);
            if (FilterPairs != null)
            {
                foreach (StringPair pair in FilterPairs)
                {
                    request += seperator + pair.Key + "=" + pair.Value;
                }
            }
            return request;
        }
    }

    public class CatalogResponse : WebResponseBase
    {
    }

    //
    // TESTCONNECTION
    //

    public class TestConnectionRequest : CatalogRequest
    {
        public TestConnectionRequest(FilterBase filter)
            : base(CatalogOperation.TestConnection, filter)
        {
        }
    }

    //
    // QUERY
    //

    /// <summary>
    /// Base class for a Query operation web request.  Base classes representing specific
    /// Query methods should derive from this class.
    /// </summary>
    public abstract class QueryRequestBase : CatalogRequest
    {
        public static class QueryMethod
        {
            public const string FindCategories = "FindCategories";
            public const string FindCategoriesZune = "FindCategoriesZune";
            public const string FindContributors = "FindContributors";
            public const string FindFeaturedPodcasts = "FindFeaturedPodcasts";
            public const string FindGameOffers = "FindGameOffers";
            public const string FindGames = "FindGames";
            public const string FindGamesFTS = "FindGamesFTS";
            public const string FindImages = "FindImages";
            public const string FindMedia = "FindMedia";
            public const string FindMediaFTS = "FindMediaFTS";
            public const string FindMediaOffers = "FindMediaOffers";
            public const string FindPodcasts = "FindPodcasts";
            public const string FindPodcastsFTS = "FindPodcastsFTS";
            public const string FindRelatedMedia = "FindRelatedMedia";
            public const string FindVideoOffers = "FindVideoOffers";
            public const string FindVideos = "FindVideos";
            public const string FindVideosFTS = "FindVideosFTS";
            public const string ReportConcern = "ReportConcern";
            public const string SubmitPodcast = "SubmitPodcast";
        }

        //[WebRequestParam("clientType", WebRequestParamType.StandAlone)]
        //public string ClientType = "fakeClientType";
        //[WebRequestParam("clientVersion", WebRequestParamType.StandAlone)]
        //public string ClientVersion = "unrealClientVersion";
        //[WebRequestParam("localeId", WebRequestParamType.StandAlone)]
        //public string LocaleId = "noPlaceSpecial";
        [WebRequestParam("methodName", WebRequestParamType.StandAlone)]
        public string MethodName;

        /// <summary>
        /// Generic constructor to support GenericQueryRequest.
        /// Be careful when calling this one as it assumes the
        /// filter being passed in already includes a methodName value.
        /// </summary>
        /// <param name="filter"></param>
        protected QueryRequestBase()
            : base(CatalogOperation.Query)
        {
        }

        protected QueryRequestBase(string methodName, FilterBase filter)
            : base(CatalogOperation.Query, filter)
        {
            MethodName = methodName;
        }
        /*
                public void BuildFilter(System.Collections.Hashtable valueTable)
                {
                    Type thisType = this.GetType();
                    System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                        System.Reflection.BindingFlags.Instance |
                        System.Reflection.BindingFlags.Public
                        );

                    foreach (System.Reflection.FieldInfo field in fieldInfos)
                    {
                        System.Collections.ArrayList tmpList = (System.Collections.ArrayList)valueTable[field.Name];
                        if (tmpList != null)
                        {
                            string[] tmpStr = (string[])tmpList.ToArray(typeof(string));
                            if (field.FieldType.IsArray)
                            {
                                field.SetValue(this, tmpStr);
                            }
                            else
                            {
                                field.SetValue(this, tmpStr[0]);
                            }
                        }
                    }
                }

                public string[] GetInputParamNames()
                {
                    Type thisType = this.GetType();
                    System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                        System.Reflection.BindingFlags.Instance |
                        System.Reflection.BindingFlags.Public
                        );

                    List<string> inputNames = new List<string>();

                    foreach (System.Reflection.FieldInfo field in fieldInfos)
                    {
                        object[] attrs = field.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                        if (attrs.Length != 0)
                        {
                            inputNames.Add(((WebRequestParamAttribute)attrs[0]).WireName);
                        }
                    }
                    return inputNames.ToArray();
                }
            }
        */
    }

    public class GenericQueryRequest : QueryRequestBase
    {
        private string _customRequest = null;
        public string CustomRequest
        {
            get
            {
                return _customRequest;
            }
            set
            {
                _customRequest = value;
            }
        }

        public GenericQueryRequest(string customRequest)
        {
            _customRequest = customRequest;
        }

        public GenericQueryRequest(FilterBase filter)
        {
            FilterPairs = filter.ToList();
            _customRequest = base.BuildHttpRequest("&");
        }

        public GenericQueryRequest(string methodName, List<StringPair> filterList)
            : base()
        {
            MethodName = methodName;
            FilterPairs = filterList;
            _customRequest = base.BuildHttpRequest("&");
        }

        protected override string BuildHttpRequest(string seperator)
        {
            METHOD.ENTER();
            METHOD.EXIT();
            return CustomRequest;
        }
    }

    public class FindCategoriesRequest : QueryRequestBase
    {
        public FindCategoriesRequest(FindCategoriesFilter filter)
            : base(QueryMethod.FindCategories, filter)
        {
        }
    }

    public class FindContributorsRequest : QueryRequestBase
    {
        public FindContributorsRequest(FindContributorsFilter filter)
            : base(QueryMethod.FindContributors, filter)
        {
        }
    }

    public class FindFeaturedPodcastsRequest : QueryRequestBase
    {
        public FindFeaturedPodcastsRequest(FindFeaturedPodcastsFilter filter)
            : base(QueryMethod.FindFeaturedPodcasts, filter)
        {
        }
    }

    public class FindGameOffersRequest : QueryRequestBase
    {
        public FindGameOffersRequest(FindGameOffersFilter filter)
            : base(QueryMethod.FindGameOffers, filter)
        {
        }
    }

    public class FindGamesRequest : QueryRequestBase
    {
        public FindGamesRequest(FindGamesFilter filter)
            : base(QueryMethod.FindGames, filter)
        {
        }
    }

    public class FindGamesFTSRequest : QueryRequestBase
    {
        public FindGamesFTSRequest(FindGamesFTSFilter filter)
            : base(QueryMethod.FindGamesFTS, filter)
        {
        }
    }

    public class FindImagesRequest : QueryRequestBase
    {
        public FindImagesRequest(FindImagesFilter filter)
            : base(QueryMethod.FindImages, filter)
        {
        }
    }

    public class FindMediaRequest : QueryRequestBase
    {
        public FindMediaRequest(FindMediaFilter filter)
            : base(QueryMethod.FindMedia, filter)
        {
        }
    }

    public class FindMediaFTSRequest : QueryRequestBase
    {
        public FindMediaFTSRequest(FindMediaFTSFilter filter)
            : base(QueryMethod.FindMediaFTS, filter)
        {
        }
    }

    public class FindMediaOffersRequest : QueryRequestBase
    {
        public FindMediaOffersRequest(FindMediaOffersFilter filter)
            : base(QueryMethod.FindMediaOffers, filter)
        {
        }
    }

    public class FindPodcastsRequest : QueryRequestBase
    {
        public FindPodcastsRequest(FindPodcastsFilter filter)
            : base(QueryMethod.FindPodcasts, filter)
        {
        }
    }

    public class FindPodcastsFTSRequest : QueryRequestBase
    {
        public FindPodcastsFTSRequest(FindPodcastsFTSFilter filter)
            : base(QueryMethod.FindPodcastsFTS, filter)
        {
        }
    }

    public class FindRelatedMediaRequest : QueryRequestBase
    {
        public FindRelatedMediaRequest(FindRelatedMediaFilter filter)
            : base(QueryMethod.FindRelatedMedia, filter)
        {
        }
    }

    public class FindVideoOffersRequest : QueryRequestBase
    {
        public FindVideoOffersRequest(FindVideoOffersFilter filter)
            : base(QueryMethod.FindVideoOffers, filter)
        {
        }
    }

    public class FindVideosRequest : QueryRequestBase
    {
        public FindVideosRequest(FindVideosFilter filter)
            : base(QueryMethod.FindVideos, filter)
        {
        }
    }

    public class FindVideosFTSRequest : QueryRequestBase
    {
        public FindVideosFTSRequest(FindVideosFTSFilter filter)
            : base(QueryMethod.FindVideosFTS, filter)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\FakeAATGTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using live.common;

namespace live.protocol
{
    public class FakeAATGTransaction : HttpTGTransaction
    {
        override public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if (activeUser != null)
            {
                if (webHeaders[AAInfo.c_HdrKey] == null)
                {
                    FakeAAInfo aainfo;
                    if (client.IPAddress == null)
                    {
                        aainfo = new FakeAAInfo(activeUser);
                    }
                    else
                    {
                        aainfo = new FakeAAInfo(activeUser, client.IPAddress);
                    }
                    webHeaders.Add(AAInfo.c_HdrKey, aainfo.ConvertoToBase64String());
                }
            }


            return base.SendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, request, out response);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\FakeAATransaction.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using System.Net;
using System.IO;

namespace live.protocol
{
    public class FakeAATransaction : HttpTransaction
    {
        override public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if (activeUser != null)
            {
                if (webHeaders[AAInfo.c_HdrKey] == null)
                {
                    FakeAAInfo aainfo;
                    if (client.IPAddress == null)
                    {
                        aainfo = new FakeAAInfo(activeUser);
                    }
                    else
                    {
                        aainfo = new FakeAAInfo(activeUser, client.IPAddress);
                    }
                    webHeaders.Add(AAInfo.c_HdrKey, aainfo.ConvertoToBase64String());
                }
            }
            return base.SendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, request, out response);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Convert.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;

namespace live.protocol
{

[ComVisible(false)]
public class ByteArray
{
    byte[] _bytes;
    int _hashCode;

    public ByteArray(byte[] bytes)
    {
        if (bytes == null || bytes.Length < 1)
        {
            throw new Exception("ByteArray: must have at least 1 byte in array");
        }
        _bytes = bytes;
        UpdateHashCode();
    }

    public void UpdateHashCode()
    {
        _hashCode = _bytes[0];
        for(int i = 1; i < _bytes.Length; i++)
        {
            // 1718205583 is prime
            _hashCode = _hashCode * 1718205583 + _bytes[i];
        }
    }

    override public int GetHashCode()
    {
        return _hashCode;
    }

    override public bool Equals(object o)
    {
        ByteArray ba = (ByteArray)o;

        return Equals( _bytes, ba._bytes );
    }

    public static bool Equals( byte[] ba1, byte[] ba2 )
    {
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    public static bool EqualOrBothNull( byte[] ba1, byte[] ba2 )
    {
        if (ba1 == null && ba2 == null)
        {
            return true;
        }
        if (ba1 == null || ba2 == null)
        {
            return false;
        }
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    override public string ToString()
    {
        return ByteConvert.ToString(_bytes);
    }

    public byte[] Bytes
    {
        get { return _bytes; }
    }
}

[ComVisible(false)]
public class ByteConvert
{
    //
    // turns a byte array into a hex string
    //
    public static string ToString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = 0; i < ba.Length; i++)
        {
            strb.Append(ba[i].ToString("x2"));
        }

        return strb.ToString();
    }


    //
    // turns a byte array into a hex string reversed (for little endian stuff)
    //
    public static string ToReverseString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = ba.Length-1; i >= 0; i--)
        {
            strb.Append(ba[i].ToString("X2"));
        }

        return strb.ToString();
    }


    public static string[] ToFormattedStrings(byte[] ba)
    {
        StringBuilder hexBytes = new StringBuilder(50);
        StringBuilder strBytes = new StringBuilder(16);

        string[] lines = new string[ba.Length / 16 + (ba.Length % 16 == 0 ? 0 : 1)];

        for (int i = 0; i < lines.Length; i++)
        {
            for (int j = 0; j < 16; j++)
            {
                int index = (i * 16) + j;
                if (index < ba.Length)
                {
                    byte b = ba[index];
                    hexBytes.Append(b.ToString("x2") + (j == 7 ? "-" : " "));
                    strBytes.Append(b >= 0x20 && b < 0x7f ? (char)b : '.');
                }
            }

            lines[i] = hexBytes.ToString().PadRight(48) + strBytes.ToString().PadRight(17);
            hexBytes.Length = 0;
            strBytes.Length = 0;
        }

        return lines;
    }

    //
    // turns a hex string into a byte array
    //
    public static byte[] FromString(string str)
    {
        byte[] ba = new byte[str.Length / 2];
        for (int i = 0; i < ba.Length; i++)
        {
            ba[i] = Convert.ToByte(str.Substring(i*2, 2), 16);
        }
        return ba;
    }
}

[ComVisible(false)]
public class CharConvert
{
    public static string ToString(char[] ca)
    {
        return CharConvert.ToString(ca, new UTF8Encoding());
    }


    public static string ToString(char[] ca, UTF8Encoding enc)
    {
        int c;

        // find the first null char
        for (c = 0; c < ca.Length && ca[c] != 0; c++)
            ;

        // only use the first first c non-null characters
        // to create the string.
        return enc.GetString(enc.GetBytes(ca, 0, c));
    }

    public static char[] FromString(string str)
    {
        return CharConvert.FromString(str, new UTF8Encoding());
    }

    public static char[] FromString(string str, UTF8Encoding enc)
    {
        return enc.GetChars(enc.GetBytes(str));
    }
}


[ComVisible(false)]
public class Int64Convert
{
    public static long FromIntPair(int highPart, int lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static long FromUintPair(uint highPart, uint lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static void ToIntPair(long val, out int highPart, out int lowPart)
    {
        highPart = (int)(val >> 32);
        lowPart = (int)(val & 0xffffffff);
    }

    public static void ToUintPair(long val, out uint highPart, out uint lowPart)
    {
        highPart = (uint)(val >> 32);
        lowPart = (uint)(val & 0xffffffff);
    }
}

/// <summary>
/// Provides methods for conversion, with a defualt if the value is null or an empty string
/// </summary>
[ComVisible(false)]
public class XmlSafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt16(str));
    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt32(str));
    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToUInt64(str));
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        return (str == String.Empty ? bDefault : XmlConvert.ToBoolean(str));
    }
}



[ComVisible(false)]
public class SafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            return (str == String.Empty ? nDefault : Convert.ToInt16(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }


            return (str == String.Empty ? nDefault : Convert.ToInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static uint ToUInt32(string str)
    {
        return ToUInt32(str, 0);
    }
    public static uint ToUInt32(string str, uint nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((uint)Convert.ToInt32(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((ulong)Convert.ToInt64(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt64(str, fromBase));
        }
        catch
        {
            return nDefault;
        }
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        try
        {
            return (str == String.Empty ? bDefault : Convert.ToBoolean(str));
        }
        catch
        {
            return bDefault;
        }
    }

    public static bool IsHex(string str)
    {
        return (str.StartsWith("0x") ||
            str.ToLower().IndexOfAny( new char[] { 'a', 'b', 'c', 'd', 'e', 'f' }) != -1);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\DownloadQueueProtocol.cs ===
using System;
using System.Net;
using System.Text;
using System.Collections.Generic;
using System.Reflection;

using live.common;
using live.common.next;
using live.client;

namespace live.protocol
{
    public class CreateDownloadQueueRequest : PayloadRequest
    {
        public ulong userPuid;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/CreateDownloadQueue.ashx";
            }
        }
    }


    public class CreateDownloadQueueResponse : PayloadResponse
    {
        public int listId;
        public DateTime lastModified;
    }


    public class ModifyDownloadQueueRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyDownloadQueue.ashx";
            }
        }
    }


    public class ModifyDownloadQueueResponse : PayloadResponse
    {
        public DateTime lastModified;
    }


    public class QueryDownloadQueuesRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;
        public int pageSize;
        public int pageNum;
        public int orderDir;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryDownloadQueues.ashx";
            }
        }
    }

    public class QueryDownloadQueuesResponse : PayloadResponse
    {
        public ushort totalDownloadQueues = 0;
        public ushort numDownloadQueues = 0;

        [WireInfo( SizeParam = "numDownloadQueues" )]
        public ListInfo[] resultDownloadQueues = null;
    }


    public class GrantDownloadQueueAccessRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public ulong machinePuid;

        public override string Xrl
        {
            get { return "/Lists/GrantDownloadQueueAccess.ashx"; }  
        }
    }


    public class GrantDownloadQueueAccessResponse : PayloadResponse
    {        
    }


    public class RevokeDownloadQueueAccessRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public ulong machinePuid;

        public override string Xrl
        {
            get { return "/Lists/RevokeDownloadQueueAccess.ashx"; }
        }
    }


    public class RevokeDownloadQueueAccessResponse : PayloadResponse
    {
    }
    

    public class InsertDownloadItemsRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;
        public ushort numDownloadItems;

        [WireInfo( SizeParam = "numDownloadItems" )]
        public ListItem[] items;


        public override string Xrl
        {
            get
            {
                return "/Lists/InsertDownloadItems.ashx";
            }
        }
    }


    public class InsertDownloadItemsResponse : PayloadResponse
    {
        public DateTime lastModified;        
    }


    public class DeleteDownloadItemsRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;        
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;


        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteDownloadItems.ashx";
            }
        }
    }


    public class DeleteDownloadItemsResponse : PayloadResponse
    {
        public DateTime lastModified;
    }


    public class ModifyDownloadItemsRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;
        public ushort numDownloadItems;

        [WireInfo( SizeParam = "numDownloadItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyDownloadItems.ashx";
            }
        }
    }


    public class ModifyDownloadItemsResponse : PayloadResponse
    {
        public DateTime lastModified;
    }


    public class QueryDownloadItemsRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public int pageSize;
        public int pageNum;
        public int orderDir;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryDownloadItems.ashx";
            }
        }
    }


    public class QueryDownloadItemsResponse : PayloadResponse
    {
        public ushort totalDownloadItems = 0;
        public DateTime lastModified = DateTime.MinValue;
        public ushort numDownloadItems = 0;

        [WireInfo( SizeParam = "numDownloadItems" )]
        public ListItem[] resultDownloadItems = null;
    }


    public class MoveDownloadItemsRequest : PayloadRequest
    {
        public ulong userPuid;
        public int listId;
        public DateTime lastModified;
        public ushort numIndices;

        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get
            {
                return "/Lists/MoveDownloadItems.ashx";
            }
        }
    }


    public class MoveDownloadItemsResponse : PayloadResponse
    {
        public DateTime lastModified;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\CustProtocol.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by xsd.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using System.Runtime.Serialization;
//using System.Runtime.Serialization.Formatters.Soap;
using System.Xml;
using System.Security.Permissions;

using live.protocol.next;
using live.client;
using System;
using live.common;

namespace live.protocol
{
    [System.Serializable]
    public abstract class CustRequestObject2 : live.protocol.next.WebRequestBase, System.Runtime.Serialization.ISerializable
    {
        public CustRequestObject2()
            : base("/xsuppapi/cxsuppapi.asmx", "")
        {
            RequestType = WebRequestType.Soap1_2;
        }

        public override string GetHttpMethod()
        {
            return HttpMethod.Post;
        }

        public override string GetRelativeUrl()
        {
            return "/xsuppapi/cxsuppapi.asmx";
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public abstract void GetObjectData(SerializationInfo info, StreamingContext context);
        /*
                public override void WriteStream(System.IO.BinaryWriter binaryWriter)
                {
                    //SoapFormatter soapForm = new SoapFormatter(null,);
                    SoapFormatter soapForm = new SoapFormatter();
                    soapForm.Serialize(binaryWriter.BaseStream, this);
                    //base.WriteStream(binaryWriter);
                }
         */
    }

    public abstract class CustResponseObject2 : WebResponseBase
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.Serializable]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    [WebRequestMethodNameAttribute("getPuidFromXName")]
    [XmlNamespace("http://xbox.com/xsuppapi/")]
    public class getPuidFromXName : CustRequestObject2
    {
        [WebRequestParam("XName", WebRequestParamType.StandAlone)]
        public string xNameField;

        /// <remarks/>
        public string XName
        {
            get
            {
                return this.xNameField;
            }
            set
            {
                this.xNameField = value;
            }
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("XName", xNameField);
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getPuidFromXNameResponse : CustResponseObject2
    {
        private uint getPuidFromXNameResultField;

        private string errorStringField;

        public uint getPuidFromXNameResult
        {
            get
            {
                return this.getPuidFromXNameResultField;
            }
            set
            {
                this.getPuidFromXNameResultField = value;
            }
        }

        [WebResponseParam("//cust:puid", "cust", "http://xbox.com/xsuppapi/")]
        private ulong _puid;
        public ulong Puid
        {
            get
            {
                return this._puid;
            }
            set
            {
                this._puid = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
        /*
                public override void ReadFromRequest(System.IO.BinaryReader reader, System.Text.UTF8Encoding enc, 
                    long len, System.Collections.Specialized.NameValueCollection queryString)
                {
                    XmlDocument xmlDoc = new XmlDocument();
                    xmlDoc.Load(reader.BaseStream);
                    XmlNamespaceManager nsMgr = new XmlNamespaceManager(xmlDoc.NameTable);
                    nsMgr.AddNamespace("cust", "http://xbox.com/xsuppapi/");
                    XmlNode puidNode = xmlDoc.SelectSingleNode("//cust:getPuidFromXNameResponse/cust:puid", nsMgr);
                    puidField = ulong.Parse(puidNode.InnerText);
                }
         */
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    [WebRequestMethodNameAttribute("getAccount")]
    [XmlNamespace("http://xbox.com/xsuppapi/")]
    public class getAccount : CustRequestObject2
    {
        [WebRequestParam("puid", WebRequestParamType.StandAlone)]
        public ulong puidField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("puid", puidField);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getAccountResponse : CustResponseObject2
    {
        [WebResponseParam("//cust:getAccountResult", "cust", "http://xbox.com/xsuppapi/")]
        private uint getAccountResultField;

        [WebResponseParam("//cust:isAccountOwner", "cust", "http://xbox.com/xsuppapi/")]
        private bool isAccountOwnerField;

        [WebResponseParam("//cust:isActive", "cust", "http://xbox.com/xsuppapi/")]
        private bool isActiveField;

        [WebResponseParam("//cust:isLockedOut", "cust", "http://xbox.com/xsuppapi/")]
        private bool isLockedOutField;

        [WebResponseParam("//cust:isVoiceBanned", "cust", "http://xbox.com/xsuppapi/")]
        private bool isVoiceBannedField;

        [WebResponseParam("//cust:isNicknameBanned", "cust", "http://xbox.com/xsuppapi/")]
        private bool isNicknameBannedField;

        [WebResponseParam("//cust:mustChangeXName", "cust", "http://xbox.com/xsuppapi/")]
        private bool mustChangeXNameField;

        [WebResponseParam("//cust:isGeofenceExempt", "cust", "http://xbox.com/xsuppapi/")]
        private bool isGeofenceExemptField;

        [WebResponseParam("//cust:errorString", "cust", "http://xbox.com/xsuppapi/")]
        private string errorStringField;

        /// <remarks/>
        public uint getAccountResult
        {
            get
            {
                return this.getAccountResultField;
            }
            set
            {
                this.getAccountResultField = value;
            }
        }

        /// <remarks/>
        public bool isAccountOwner
        {
            get
            {
                return this.isAccountOwnerField;
            }
            set
            {
                this.isAccountOwnerField = value;
            }
        }

        /// <remarks/>
        public bool isActive
        {
            get
            {
                return this.isActiveField;
            }
            set
            {
                this.isActiveField = value;
            }
        }

        /// <remarks/>
        public bool isLockedOut
        {
            get
            {
                return this.isLockedOutField;
            }
            set
            {
                this.isLockedOutField = value;
            }
        }

        /// <remarks/>
        public bool isVoiceBanned
        {
            get
            {
                return this.isVoiceBannedField;
            }
            set
            {
                this.isVoiceBannedField = value;
            }
        }

        /// <remarks/>
        public bool isNicknameBanned
        {
            get
            {
                return this.isNicknameBannedField;
            }
            set
            {
                this.isNicknameBannedField = value;
            }
        }

        /// <remarks/>
        public bool mustChangeXName
        {
            get
            {
                return this.mustChangeXNameField;
            }
            set
            {
                this.mustChangeXNameField = value;
            }
        }

        /// <remarks/>
        public bool isGeofenceExempt
        {
            get
            {
                return this.isGeofenceExemptField;
            }
            set
            {
                this.isGeofenceExemptField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    [PayloadClient(typeof(Xbox360Client), PayloadType.Soap12)]
    public class CustPayloadRequest : PayloadRequest
    {
        public CustPayloadRequest()
            : base()
        {
            this.SetPayloadType(PayloadType.Soap12);
        }


        public override string Xrl
        {
            get { return "/xsupaip/test"; }
        }
    }

    public abstract class CustPayloadResponse : PayloadResponse
    {
        public CustPayloadResponse()
        {
            this.SetPayloadType(PayloadType.Soap12);
        }
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "getAccountEx", "http://xbox.com/xsuppapi/")]
    public class CustGetAccountExRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "getAccountExResponse")]
    public class CustGetAccountExResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint getAccountExResult;

        [PayloadParam]
        public ulong biOwnerPuid;

        [PayloadParam]
        public DateTime dtAccountResumeDate;

        [PayloadParam]
        public int iSuspensionLength;

        [PayloadParam]
        public System.DateTime dtVoiceResumeDate;

        [PayloadParam]
        public int iVoiceBanLength;

        [PayloadParam]
        public bool bMustChangeXName;

        [PayloadParam]
        public System.DateTime dtAcceptedTOS;

        [PayloadParam]
        public byte tiCountryID;

        [PayloadParam]
        public bool isGeoFenceExempt;

        [PayloadParam]
        public string errorString;

    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "getMachineAccountByConsoleId", "http://xbox.com/xsuppapi/")]
    public class CustGetMachineAccountByConsoleIdRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

        [PayloadParam]
        public string consoleId;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "getMachineAccountByConsoleIdResponse")]
    public class CustGetMachineAccountByConsoleIdResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint getMachineAccountByConsoleIdResult;

        [PayloadParam]
        public bool isLockedOut;

        [PayloadParam]
        public string errorString;
    }


    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "getPassportMemberName", "http://xbox.com/xsuppapi/")]
    public class CustGetPassportMemberNameReuest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "getPassportMemberNameResponse")]
    public class CustGetPassportMemberNameResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint getPassportMemberNameResult;

        [PayloadParam]
        public string userPmn;

        [PayloadParam]
        public string parentPmn;

        [PayloadParam]
        public string errorString;
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "modifyAccount", "http://xbox.com/xsuppapi/")]
    public class CustModifyAccountRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

        [PayloadParam]
        public bool isLockedOut;

        [PayloadParam]
        public bool isVoiceBanned;

        [PayloadParam]
        public bool isNicknameBanned;

        [PayloadParam]
        public bool mustChangeXName;

        [PayloadParam]
        public bool isGeoFenceExempt;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "modifyAccountResponse")]
    public class CustModifyAccountResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint modifyAccountResult;

        [PayloadParam]
        public string errorString;
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "banAccount", "http://xbox.com/xsuppapi/")]
    public class CustBanAccountRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

        [PayloadParam]
        public bool isLockedOut;


    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "banAccountResponse")]
    public class CustBanAccountResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint banAccountResult;

        [PayloadParam]
        public string errorString;
    }


    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "SetUserMotto", "http://xbox.com/xsuppapi/")]
    public class CustSetUserMottoRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

        [PayloadParam]
        public string newMotto;


    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "SetUserMottoResponse")]
    public class CustSetUserMottoResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint SetUserMottoResult;

        [PayloadParam]
        public string errorString;
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "SetUserProfileItems", "http://xbox.com/xsuppapi/")]
    public class CustSetUserProfileItemsRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

        [PayloadParam]
        public ProfileItem[] profileItems;


    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "SetUserProfileItemsResponse")]
    public class CustSetUserProfileItemsResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint SetUserProfileItemsResult;

        [PayloadParam]
        public string errorString;
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "RemoveGamerPicture", "http://xbox.com/xsuppapi/")]
    public class CustRemoveGamerPictureRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "RemoveGamerPictureResponse")]
    public class CustRemoveGamerPictureResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint RemoveGamerPictureResult;

        [PayloadParam]
        public string errorString;
    }


    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "getRelatedAccounts", "http://xbox.com/xsuppapi/")]
    public class CustGetRelatedAccountsRequest : CustPayloadRequest
    {
        [PayloadParam]
        public ulong puid;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "getRelatedAccountsResponse")]
    public class CustGetRelatedAccountsResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint getRelatedAccountsResult;

        [PayloadParam]
        public string errorString;

        [PayloadParam]
        public ulong[] relatedAccounts;

        [PayloadParam]
        public string[] relatedAccountNames;
    }

    [PayloadAction("/xsuppapi/cxsuppapi.asmx", "getSubscriptionCodeStatus", "http://xbox.com/xsuppapi/")]
    public class CustGetSubscriptionCodeStatusRequest : CustPayloadRequest
    {
        [PayloadParam]
        public string SubscriptionCode;

    }

    [PayloadResponse("http://xbox.com/xsuppapi/", "getSubscriptionCodeStatusResponse")]
    public class CustGetSubscriptionCodeStatusResponse : CustPayloadResponse
    {
        [PayloadParam]
        public uint getSubscriptionCodeStatusResult;

        [PayloadParam]
        public string errorString;
        
        [PayloadParam]
        public bool bValidSubscriptionCode;

        [PayloadParam]
        public bool bUsed;

        [PayloadParam]
        public bool bUsedMaxTimes;

        [PayloadParam]
        public ulong ulLastUser;

        [PayloadParam]
        public string szLastUser;

        [PayloadParam]
        public System.DateTime ftLastUsage;

        [PayloadParam]
        public ulong ulOfferID;

        [PayloadParam]
        public string szOffer;
    }


    //This stuff, as it's machine genrated then edited, is too tough to read and maintain. Switching to the New Payload Classes
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getMachineAccountByConsoleId
    {

        private ulong puidField;

        private string consoleIdField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public string consoleId
        {
            get
            {
                return this.consoleIdField;
            }
            set
            {
                this.consoleIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getMachineAccountByConsoleIdResponse
    {

        private uint getMachineAccountByConsoleIdResultField;

        private bool isLockedOutField;

        private string errorStringField;

        /// <remarks/>
        public uint getMachineAccountByConsoleIdResult
        {
            get
            {
                return this.getMachineAccountByConsoleIdResultField;
            }
            set
            {
                this.getMachineAccountByConsoleIdResultField = value;
            }
        }

        /// <remarks/>
        public bool isLockedOut
        {
            get
            {
                return this.isLockedOutField;
            }
            set
            {
                this.isLockedOutField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class modifyAccount
    {

        private ulong puidField;

        private bool isLockedOutField;

        private bool isVoiceBannedField;

        private bool isNicknameBannedField;

        private bool mustChangeXNameField;

        private bool isGeoFenceExemptField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public bool isLockedOut
        {
            get
            {
                return this.isLockedOutField;
            }
            set
            {
                this.isLockedOutField = value;
            }
        }

        /// <remarks/>
        public bool isVoiceBanned
        {
            get
            {
                return this.isVoiceBannedField;
            }
            set
            {
                this.isVoiceBannedField = value;
            }
        }

        /// <remarks/>
        public bool isNicknameBanned
        {
            get
            {
                return this.isNicknameBannedField;
            }
            set
            {
                this.isNicknameBannedField = value;
            }
        }

        /// <remarks/>
        public bool mustChangeXName
        {
            get
            {
                return this.mustChangeXNameField;
            }
            set
            {
                this.mustChangeXNameField = value;
            }
        }

        /// <remarks/>
        public bool isGeoFenceExempt
        {
            get
            {
                return this.isGeoFenceExemptField;
            }
            set
            {
                this.isGeoFenceExemptField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class modifyAccountResponse
    {

        private uint modifyAccountResultField;

        private string errorStringField;

        /// <remarks/>
        public uint modifyAccountResult
        {
            get
            {
                return this.modifyAccountResultField;
            }
            set
            {
                this.modifyAccountResultField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class banAccount
    {

        private ulong puidField;

        private bool isLockedOutField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public bool isLockedOut
        {
            get
            {
                return this.isLockedOutField;
            }
            set
            {
                this.isLockedOutField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class banAccountResponse
    {

        private uint banAccountResultField;

        private string errorStringField;

        /// <remarks/>
        public uint banAccountResult
        {
            get
            {
                return this.banAccountResultField;
            }
            set
            {
                this.banAccountResultField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getRelatedAccounts
    {

        private ulong puidField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getRelatedAccountsResponse
    {

        private uint getRelatedAccountsResultField;

        private ulong[] relatedAccountsField;

        private string[] relatedAccountNamesField;

        private string errorStringField;

        /// <remarks/>
        public uint getRelatedAccountsResult
        {
            get
            {
                return this.getRelatedAccountsResultField;
            }
            set
            {
                this.getRelatedAccountsResultField = value;
            }
        }

        /// <remarks/>
        public ulong[] relatedAccounts
        {
            get
            {
                return this.relatedAccountsField;
            }
            set
            {
                this.relatedAccountsField = value;
            }
        }

        /// <remarks/>
        public string[] relatedAccountNames
        {
            get
            {
                return this.relatedAccountNamesField;
            }
            set
            {
                this.relatedAccountNamesField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getSubscriptionCodeStatus
    {

        private string subscriptionCodeField;

        /// <remarks/>
        public string SubscriptionCode
        {
            get
            {
                return this.subscriptionCodeField;
            }
            set
            {
                this.subscriptionCodeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getSubscriptionCodeStatusResponse
    {

        private uint getSubscriptionCodeStatusResultField;

        private bool bValidSubscriptionCodeField;

        private bool bUsedField;

        private bool bUsedMaxTimesField;

        private ulong ulLastUserField;

        private string szLastUserField;

        private System.DateTime ftLastUsageField;

        private ulong ulOfferIDField;

        private string szOfferField;

        private string errorStringField;

        /// <remarks/>
        public uint getSubscriptionCodeStatusResult
        {
            get
            {
                return this.getSubscriptionCodeStatusResultField;
            }
            set
            {
                this.getSubscriptionCodeStatusResultField = value;
            }
        }

        /// <remarks/>
        public bool bValidSubscriptionCode
        {
            get
            {
                return this.bValidSubscriptionCodeField;
            }
            set
            {
                this.bValidSubscriptionCodeField = value;
            }
        }

        /// <remarks/>
        public bool bUsed
        {
            get
            {
                return this.bUsedField;
            }
            set
            {
                this.bUsedField = value;
            }
        }

        /// <remarks/>
        public bool bUsedMaxTimes
        {
            get
            {
                return this.bUsedMaxTimesField;
            }
            set
            {
                this.bUsedMaxTimesField = value;
            }
        }

        /// <remarks/>
        public ulong ulLastUser
        {
            get
            {
                return this.ulLastUserField;
            }
            set
            {
                this.ulLastUserField = value;
            }
        }

        /// <remarks/>
        public string szLastUser
        {
            get
            {
                return this.szLastUserField;
            }
            set
            {
                this.szLastUserField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ftLastUsage
        {
            get
            {
                return this.ftLastUsageField;
            }
            set
            {
                this.ftLastUsageField = value;
            }
        }

        /// <remarks/>
        public ulong ulOfferID
        {
            get
            {
                return this.ulOfferIDField;
            }
            set
            {
                this.ulOfferIDField = value;
            }
        }

        /// <remarks/>
        public string szOffer
        {
            get
            {
                return this.szOfferField;
            }
            set
            {
                this.szOfferField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getAccountEx
    {

        private ulong puidField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getAccountExResponse
    {

        private uint getAccountExResultField;

        private ulong biOwnerPuidField;

        private System.DateTime dtAccountResumeDateField;

        private int iSuspensionLengthField;

        private System.DateTime dtVoiceResumeDateField;

        private int iVoiceBanLengthField;

        private bool bMustChangeXNameField;

        private System.DateTime dtAcceptedTOSField;

        private byte tiCountryIDField;

        private bool isGeoFenceExemptField;

        private string errorStringField;

        /// <remarks/>
        public uint getAccountExResult
        {
            get
            {
                return this.getAccountExResultField;
            }
            set
            {
                this.getAccountExResultField = value;
            }
        }

        /// <remarks/>
        public ulong biOwnerPuid
        {
            get
            {
                return this.biOwnerPuidField;
            }
            set
            {
                this.biOwnerPuidField = value;
            }
        }

        /// <remarks/>
        public System.DateTime dtAccountResumeDate
        {
            get
            {
                return this.dtAccountResumeDateField;
            }
            set
            {
                this.dtAccountResumeDateField = value;
            }
        }

        /// <remarks/>
        public int iSuspensionLength
        {
            get
            {
                return this.iSuspensionLengthField;
            }
            set
            {
                this.iSuspensionLengthField = value;
            }
        }

        /// <remarks/>
        public System.DateTime dtVoiceResumeDate
        {
            get
            {
                return this.dtVoiceResumeDateField;
            }
            set
            {
                this.dtVoiceResumeDateField = value;
            }
        }

        /// <remarks/>
        public int iVoiceBanLength
        {
            get
            {
                return this.iVoiceBanLengthField;
            }
            set
            {
                this.iVoiceBanLengthField = value;
            }
        }

        /// <remarks/>
        public bool bMustChangeXName
        {
            get
            {
                return this.bMustChangeXNameField;
            }
            set
            {
                this.bMustChangeXNameField = value;
            }
        }

        /// <remarks/>
        public System.DateTime dtAcceptedTOS
        {
            get
            {
                return this.dtAcceptedTOSField;
            }
            set
            {
                this.dtAcceptedTOSField = value;
            }
        }

        /// <remarks/>
        public byte tiCountryID
        {
            get
            {
                return this.tiCountryIDField;
            }
            set
            {
                this.tiCountryIDField = value;
            }
        }

        /// <remarks/>
        public bool isGeoFenceExempt
        {
            get
            {
                return this.isGeoFenceExemptField;
            }
            set
            {
                this.isGeoFenceExemptField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getPassportMemberName
    {

        private ulong puidField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class getPassportMemberNameResponse
    {

        private uint getPassportMemberNameResultField;

        private string userPmnField;

        private string parentPmnField;

        private string errorStringField;

        /// <remarks/>
        public uint getPassportMemberNameResult
        {
            get
            {
                return this.getPassportMemberNameResultField;
            }
            set
            {
                this.getPassportMemberNameResultField = value;
            }
        }

        /// <remarks/>
        public string userPmn
        {
            get
            {
                return this.userPmnField;
            }
            set
            {
                this.userPmnField = value;
            }
        }

        /// <remarks/>
        public string parentPmn
        {
            get
            {
                return this.parentPmnField;
            }
            set
            {
                this.parentPmnField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class RemoveGamerPicture
    {

        private ulong puidField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class RemoveGamerPictureResponse
    {

        private uint removeGamerPictureResultField;

        private string errorStringField;

        /// <remarks/>
        public uint RemoveGamerPictureResult
        {
            get
            {
                return this.removeGamerPictureResultField;
            }
            set
            {
                this.removeGamerPictureResultField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class SetUserMotto
    {

        private ulong puidField;

        private string newMottoField;

        /// <remarks/>
        public ulong puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public string newMotto
        {
            get
            {
                return this.newMottoField;
            }
            set
            {
                this.newMottoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class SetUserMottoResponse
    {

        private uint setUserMottoResultField;

        private string errorStringField;

        /// <remarks/>
        public uint SetUserMottoResult
        {
            get
            {
                return this.setUserMottoResultField;
            }
            set
            {
                this.setUserMottoResultField = value;
            }
        }

        /// <remarks/>
        public string errorString
        {
            get
            {
                return this.errorStringField;
            }
            set
            {
                this.errorStringField = value;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\IGContext.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Web;

using live.common;

namespace live.protocol
{
    public class IGContext : IAsyncResult
    {
        public uint frontdoorSeqNum = 0;
        private ManualResetEvent callCompletedEvent = null;
        private bool isCompleted = false;
        public byte[] rgbRequest = null;
        public uint dwBytesLeft = 0;
        public bool fWaitForResponse;
        public IGMessageData Response;

        public DateTime waitTableAdded = DateTime.Now;

        public Exception excep = null;

        private static int _seqNum;
        
        static IGContext()
        {
            // we want each server to start with a random sequence number,
            // so they are not likely to use the same sequence number at the
            // same time. While nothing bad will happen if two front doors
            // use the same sequence number at the same time, it makes it
            // much easier to analyze xmgmt traces if each request has a
            // unique sequence number.
            RandomEx random = new RandomEx();
            _seqNum = random.Next();
        }

        public IGContext(IGMessage Request, bool _fWaitForResponse)
        {
            frontdoorSeqNum = NewSeqNum();
            Request._Header.dwSeqNum = frontdoorSeqNum;
            rgbRequest = (byte[])Request;
            dwBytesLeft = 0;
            isCompleted = false;
            excep = null;
            callCompletedEvent = null;
            fWaitForResponse = _fWaitForResponse;
            Response = null;
        }

        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
                {
                    return null;
                }
        }

        public bool CompletedSynchronously
        {
            get
                {
                    return(false);
                }
        }

        public bool IsCompleted
        {
            get
                {
                    return(isCompleted);
                }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
                { 
                    if (callCompletedEvent == null)
                    {
                        callCompletedEvent = new ManualResetEvent(false);
                    }
                    
                    return callCompletedEvent;
                }
        }


        // This does the work required to tell ASP.Net that an async call
        // is complete.
        public void CompleteRequest()
        {
            isCompleted = true;

            if (callCompletedEvent != null)
            {
                callCompletedEvent.Set();
            }
        }

        private static uint NewSeqNum()
        {
            uint seqNum = unchecked((uint)Interlocked.Increment(ref _seqNum));
            if (seqNum == 0)
            {
                // we never want to use 0 as a seqNum because it is not considered
                // a valid sequence number. So get a different one until it is not zero.
                // Note recursion.
                seqNum = NewSeqNum();
            }
            return seqNum;
        }
    }
} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\giprot.cs ===
// 
// GIProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Game Instrumentation Service Integration
// Xbox Online Service
// 

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using live.common;

namespace live.protocol 
{
    public class GITypes
    {
        public const uint XONLINE_STAT_DATATYPE_MASK     = 0xF0000000;
        
        public const uint XONLINE_STAT_NULL              = 0x00000000;
        public const uint XONLINE_STAT_LONG              = 0x10000000;
        public const uint XONLINE_STAT_LONGLONG          = 0x20000000;
        public const uint XONLINE_STAT_DOUBLE            = 0x30000000;
        public const uint XONLINE_STAT_LPCWSTR           = 0x40000000;
        public const uint XONLINE_STAT_FLOAT             = 0x50000000;
        public const uint XONLINE_STAT_BINARY            = 0x60000000;
        public const uint XONLINE_STAT_DATETIME          = 0x70000000;
    }

    public class GIDefs
    {
        public const uint X_CONTEXT_PRESENCE            = 0x00008001;
        public const uint X_CONTEXT_GAME_TYPE           = 0x0000800A;
        public const uint X_CONTEXT_GAME_MODE           = 0x0000800B;
    }
    
    //
    // Basic Context name value pair. The value always corresponds to a localized label for display purposes
    //
    public class GIContext : WireData
    {
        public uint           Id;
        public uint           Value;

        public GIContext() { }
        public GIContext(uint id)
        {
            Id = id;
        }    
        public GIContext(uint id, uint value)
        {
            Id = id;
            Value = value;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                Id = binaryReader.ReadUInt32();
                Value = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_8, 
                    "Reached end of stream trying to read GIContext", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Id);
            binaryWriter.Write(Value);
        }

    }


    //
    // Property data for Game Instrumentation. This is the meat of how data is represented via instrumentation
    //
    public class GIProperty: WireData
    {
        public GIProperty() { }
        public GIProperty(uint id)
        {
            Id = id;

            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = (float)0.0;
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = (DateTime)DateTime.UtcNow;
                break;
                
            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = (double)0.0;
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = (int)0;
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = (long)0;
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                strValue = "";
                break;
            }            
        }    
        
        public GIProperty(uint id, float f)
        {
            Id = id;
            fValue = f;
            
            if ( (id & GITypes.XONLINE_STAT_FLOAT) != GITypes.XONLINE_STAT_FLOAT)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, DateTime dt)
        {
            Id = id;
            dtValue = dt;
            
            if ((id & GITypes.XONLINE_STAT_DATETIME) != GITypes.XONLINE_STAT_DATETIME)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, double d)
        {
            Id = id;
            dValue = d;

            if ( (id & GITypes.XONLINE_STAT_DOUBLE) != GITypes.XONLINE_STAT_DOUBLE)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, int n)
        {
            Id = id;
            nValue = n;

            if ( (id & GITypes.XONLINE_STAT_LONG) != GITypes.XONLINE_STAT_LONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, long l)
        {
            Id = id;
            lValue = l;

            if ( (id & GITypes.XONLINE_STAT_LONGLONG) != GITypes.XONLINE_STAT_LONGLONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, string str)
        {
            Id = id;
            strValue = str;

            if ( (id & GITypes.XONLINE_STAT_LPCWSTR) != GITypes.XONLINE_STAT_LPCWSTR)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, byte[] bin)
        {
            Id = id;
            binValue = bin;

            if ( (id & GITypes.XONLINE_STAT_BINARY) != GITypes.XONLINE_STAT_BINARY)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }            
        
        
        //
        // Data exposed to SOAP for web services
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors (these aren't serialized)
        //
        [XmlIgnore]
        public float fValue
        {
            get { return (float)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public DateTime dtValue
        {
            get { return (DateTime)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public double dValue
        {
            get { return (double)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public int nValue
        {
            get { return (int)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = binaryReader.ReadSingle();
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = DateTime.FromFileTimeUtc(binaryReader.ReadInt64());
                break;

            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = binaryReader.ReadDouble();
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = binaryReader.ReadInt32();
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = binaryReader.ReadInt64();
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                len = binaryReader.ReadUInt16();
                strValue = Encoding.Unicode.GetString(binaryReader.ReadBytes(len));
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                len = binaryReader.ReadUInt16();
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_42, 
                    "Unrecgonized datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                binaryWriter.Write(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                binaryWriter.Write(Convert.ToDateTime(dtValue).ToFileTimeUtc());
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                binaryWriter.Write(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                binaryWriter.Write(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                binaryWriter.Write(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                {
                byte[] buf;
                
                buf = Encoding.Unicode.GetBytes(strValue);
                binaryWriter.Write((ushort)buf.Length);
                binaryWriter.Write(buf);
                }
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                binaryWriter.Write((ushort)binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEvent.Id.COMMON_CODE_43, 
                    "Unexpected datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }
        }

        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                str.Append(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                str.Append(dtValue);
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                str.Append(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                str.Append(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                str.Append(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                str.Append(strValue);
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                str.Append(ByteConvert.ToString(binValue));
                break;

            default:
                str.Append("null");
                break;
            }
            
            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\feedbackprot.cs ===
// 
// FeedbackProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Feedback Service Integration
// Xbox Online Service
// 
// Author: masonb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;


//[assembly: XomAreaDefinition(XomAreaName.FeedbackProxy)]


namespace live.protocol 
{    
    //
    // Feedback definitions
    //
    public class FeedbackDefs
    {
        // Header name for redirecting presence requests for stress testing. 
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";
        
        // 
        // Enumeration of feedback types
        //  Maps to XONLINE_FEEDBACK_TYPE in xonline.x
        //
        public enum FeedbackType : byte
        {
            NegNickname = 0,
            NegGameplay = 1,
            NegScreaming = 2,
            NegHarassment = 3,
            NegLewdness = 4,
            PosAttitude = 5,
            PosSession = 6,
            PosStatsAttachment = 7,
            NegStatsAttachment = 8,
            NegStatsAttachmentCheating = 9,
            NegMessageInappropriate = 10,
            NegMessageSpam = 11,
            NegTeamName = 12,
            NegTeamMotto = 13,
            NegTeamContent = 14,
            NegTeamDescription = 15,
            NegTeamURL = 16,
            NegCompetitionName = 17,
            NegCompetitionMotto = 18,
            NegCompetitionContent = 19,

            // Add new public types here
  
            NumTypes,

            MinServiceType = 254,

            // Add new private service types here and decrement MinServiceType

            ServiceDataMachine = 255,

        }

        // 
        // Enumeration of player review types
        //  Maps to ??? in xonline.x
        //
        public enum PlayerReview : uint
        {
            Prefer = 0,
            AvoidTrashTalk = 1,
            AvoidLanguage = 2,
            AvoidDisruptive = 3,
            AvoidAggressive = 4,
            AvoidUnsporting = 5,
            AvoidDisconnect = 6,
            AvoidUnskilled = 7,
            AvoidTooGood = 8,
            AvoidUnfamiliar = 9,


            // Add new review types here
        }
        
        // 
        // Enumeration of player review types
        //  Maps to ??? in xonline.x
        //
        public enum ComplaintType : uint
        {
            OffensiveGamertag = 0,
            OffensiveMotto = 1,
            OffensiveTextMessage = 2,
            OffensiveVoiceMail = 3,
            OffensiveVoiceChat = 4,
            OffensiveInGame = 5,
            TamperingFeedback = 6,
            TamperingSystem = 7,
            TamperingCheating = 8,
            OffensiveUserContent = 9,
            OffensiveVideoMessage = 10,
            OffensiveVideoChat = 11,
            OffensiveGamerPicture = 12,
            OffensiveInGameVideo = 13,
            OffensivePhotoMessage  = 14,
            OffensiveUrl = 15,
            ChildAbuse = 16,
            
            // Add new complaint types here
  
        }
        
    } // end definitions

    //
    // Structure Representing a Feedback request.
    //  Maps to XONFEEDBACK_SEND_REQUEST in xonline.x
    //  
    public class FeedbackRequest : XRLObject2
    {
        public ulong   ulSendPUID;
        public ulong   ulTargetPUID;
        public uint    uiTitleID;
        public byte    bFeedbackType;
        public byte    bTextSize;

        [WireInfo(SizeParam="bTextSize")]
        public string  szText;

        public string GetXRL()
        {
            return "/fbserver/fbserver.ashx";
        }
    }

    //
    // Structure Representing a Player Review request.
    //  Maps to ??? in xonline.x
    //  
    public class SubmitReviewRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;

        public string GetXRL()
        {
            return "/fbserver/submitreview.ashx"; 
        }
    }


    //
    // Structure Representing an enumeration of Player Reviews sent by a particular user.
    //  Maps to ??? in xonline.x
    //  
    public class EnumerateSentReviewsRequest : XRLObject2
    {
        public ulong   senderPUID;
        public uint    page;
        public uint    resultsPerPage;

        public string GetXRL()
        {
            return "/fbserver/enumsentreview.ashx";
        }
    }

    //
    // Structure Representing an enumeration of Player Reviews received by a particular user.
    //  Maps to ??? in xonline.x
    //  
    public class EnumerateRecdReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;
        public uint    page;
        public uint    resultsPerPage;

        public string GetXRL()
        {
            return "/fbserver/enumrecdreview.ashx";
        }
    }

    //
    // A single PlayerReview result
    //  
    public class PlayerReview : WireData
    {
        public ulong       senderPUID;
        public ulong       targetPUID;
        public uint        titleID;
        public uint        type;
        public ulong       context;
        public DateTime    dtSubmitted;
    }

    //
    // A reply to either a EnumerateSentReviewsRequest or EnumerateRecdReviewsRequest message
    //  
    public class EnumerateReviewsReply : XRLObject2
    {
        public uint        hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public PlayerReview [] reviews;
    }


    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in xonline.x
    //  
    public class GetAggregateReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;

        public string GetXRL()
        {
            return "/fbserver/getaggreview.ashx";
        }
    }

    //
    // A single AggregateReview result
    //  
    public class AggregateReview : WireData
    {
        public ulong       targetPUID;
        public uint        count;
        public uint        type;
    }

    //
    // A reply to a GetAggregateReviewsRequest message
    //  
    public class GetAggregateReviewsReply : XRLObject2
    {
        public uint        hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public AggregateReview [] aggReviews;
    }

    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in xonline.x
    //  
    public class SubmitComplaintRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;
	
        public string GetXRL()
        {
            return "/fbserver/submitcomplaint.ashx";
        }
    }

    //
    // Structures for the XeSchemaUnitTest component.
    //

    public class XeSchemaUnitTestComplexType : XRLObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]        
        public ushort  v3_ushort_field = '\0';
        [WireInfo(MinSchemaVersion="4.0")]        
        public int     v4_int_field = 0;
    }
    
    public class XeSchemaUnitTestRequest : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field;

        public string GetXRL()
        {
            return "/fbserver/XeSchemaUnitTest.ashx";
        }
    }

    public class XeSchemaUnitTestResponse : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field = new XeSchemaUnitTestComplexType();
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\IGConnection.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Timers;
using System.Net;
using System.Net.Sockets;

namespace live.protocol
{
    public class IGConnection
    {
        private volatile bool _shutdown;
        private ReaderWriterLock _rwlShutdown;
        private bool _socketHealthy;
        private ReaderWriterLock _rwlSocketHealthy;
        private Socket _socket;
        private IPEndPoint _endPoint;
        private string _serverName;
        private Queue _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private Thread _sendThread;
        private ManualResetEvent _sendThreadStarted;
        private Thread _receiveThread;
        private ManualResetEvent _receiveThreadStarted;
        private System.Timers.Timer _timeoutTimer;

        private string InstanceId = Guid.NewGuid().ToString();

        private const int LOCK_TIMEOUT = 30000;
        private const int THREAD_START_TIMEOUT = 30000;
        private const int SEND_QUEUE_TIMEOUT = 1000;
        private const int REPLY_TIMEOUT = 60000;
        private const int SEND_TIMEOUT = 60000;

        // Initializes a Connection to the Test Gateway server
        // indicated in the provided interfaceInfo. After this call
        // completes, the caller can safely begin to queue IGContext
        // objects using Enqueue()
        public IGConnection(IPEndPoint endPoint, string serverName)
        {
            // This contains the IP:port info we need to connect to
            _endPoint = endPoint;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Any send or receive action has to be prepared to deal with 
            // socket failures, and re-establish communications automatically.
            // This flag (and correponding lock) allow the send and receive
            // threads to communicate to each other when the socket goes
            // bad.
            _socketHealthy = false;
            _rwlSocketHealthy = new ReaderWriterLock();

            // Used to signal that the class should close the socket and
            // end the threads.
            _shutdown = false;
            _rwlShutdown = new ReaderWriterLock();

            // We call GetSocket() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails
            // and leaves an exception in the PresenceFDContext.
            try
            {
                GetSocket();
            }
            catch (SocketException e)
            {
                System.Diagnostics.Debug.WriteLine(e);
                // dont puke here if the server isnt up yet.
                //XomNtEvent(XEvent.Id.PRESENCE_COMM_45, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.\r\n" + e.ToString());
            }

            // This is a queue of IGContexts that contains requests
            // to be sent to the Test Gateway server. It is syncronized because it is
            // shared between the request threads (which calls Init)
            // and the SendThread.
            _sendQueue = Queue.Synchronized(new Queue());

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of PresenceFDContexts (indexed by the
            // frontdoorSeqNum member) which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            _sendThreadStarted = new ManualResetEvent(false);
            _sendThread = new Thread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            _receiveThreadStarted = new ManualResetEvent(false);
            _receiveThread = new Thread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            // Kick off the timeout timer, set the interval to one half the context timeout. This should
            // mean we'll expire the context within 150% of the specified timeout, but we won't be
            // spending an inordinate amount of time looking for expired contexts.
            // The value of REPLY_TIMEOUT/2 is long compared to the amount of time we expect
            // TimeoutExpiredContext to take, so we set AutoReset to true and don't worry about
            // overlapping calls to the method.
            int interval = REPLY_TIMEOUT / 2;

            _timeoutTimer = new System.Timers.Timer(interval);
             _timeoutTimer.Elapsed += new ElapsedEventHandler(this.TimeoutExpiredContexts);
             _timeoutTimer.AutoReset = true;
             _timeoutTimer.Start();
        }

        public void Shutdown()
        {
            _rwlShutdown.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlShutdown.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // set the shutdown flag, which will tell the send and receive
                    // threads to begin shutting down
                    _shutdown = true;
                    _sendQueueEvent.Set();
                }
                finally
                {
                    _rwlShutdown.DowngradeFromWriterLock(ref lc);
                }

                // stop the timer
                _timeoutTimer.Stop();

                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
            }
            finally
            {
                _rwlShutdown.ReleaseReaderLock();
            }
        }

        public bool ShuttingDown()
        {
            _rwlShutdown.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                return _shutdown;
            }
            finally
            {
                _rwlShutdown.ReleaseReaderLock();
            }
        }

        public IGMessageData IssueRequest(IGMessage Request, bool WaitForResponse)
        {
            IGContext fdctx = IssueRequestInternal(Request, WaitForResponse);
            if (WaitForResponse)
            {
                fdctx.AsyncWaitHandle.WaitOne();
                if (fdctx.excep != null)
                {
                    throw fdctx.excep;
                }
                return fdctx.Response;
            }
            return null;
        }

        // Places a IGContext on the queue to be sent to
        // the connected INH server by SendThread, and signals the SendThread
        // to wake up. 
        // 
        // If ctx.fWaitForResponse is true then the context will be placed in
        // the hashtable of contexts waiting for a response from the INH server,
        // and when a response is received, ctx.event will be signaled. The caller
        // should call ctx.event.WaitOne with an appropriate timeout. If the event
        // is signaled, then the caller can complete the call. 
        
        private IGContext IssueRequestInternal(IGMessage Request, bool WaitForResponse)
        {            
            if (ShuttingDown())
            {
                throw new Exception("Enqueue called while Connection was shutting down");
            }

            IGContext fdctx = new IGContext(Request, WaitForResponse);
            lock (_sendQueue.SyncRoot)
            {
                _sendQueue.Enqueue(fdctx);
            }
            _sendQueueEvent.Set();

            return fdctx;
        }

        public void SendThread()
        {
            // signal the constructor that the thread is up and running
            _sendThreadStarted.Set();

            // keep processing work items on the queue until we break out of
            // this loop because the _shutdown flag is set
            while (true)
            {
                try
                {
                    if (!ShuttingDown())
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    else
                    {
                        // need to protect the break statement at the bottom of this block, or else errors can prevent this thread from exiting.
                        try
                        {
                            // kill the socket. If we don't do this, the receive
                            // thread will never exit.
                            _socket.Shutdown(SocketShutdown.Send);
                            byte[] recvBuffer = new byte[1024];

                            // drain the receive buffer
                            while (_socket.Receive(recvBuffer) > 0);

                            // now close it
                            _socket.Close();
                        }
                        catch (Exception e)
                        {
                            System.Diagnostics.Debug.WriteLine(e);
                            //XomNtEvent(XEvent.Id.PRESENCE_COMM_46,
                            //    "Unexpected Exception thrown while shutting down SendThread for connection to INH at "
                            //    + _interfaceInfo.IPAddressString
                            //    + " Exception.Type: "
                            //    + e.GetType().ToString()
                            //    + " Exception.Message:"
                            //    + e.Message
                            //    + " Exception.StackTrace:"
                            //    + e.StackTrace);
                        }
                        
                        // we're shutting down, so break out of the loop
                        break;
                    }
                }
                catch (Exception e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_0,
                    //    "Unexpected Exception thrown in SendThread for connection to INH at "
                    //   + _interfaceInfo.IPAddressString
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        public void ReceiveThread()
        {
            // signal the constructor that the thread is up and running
            _receiveThreadStarted.Set();

            // keep receiving messages from the INH server until we break out of
            // this loop because the _shutdown flag is set
            while (true)
            {
                try
                {
                    if (!ShuttingDown())
                    {
                        // dont try to receive if the socket is dead.
                        if (IsSocketHealthy())
                        {
                            ReceiveMessage();
                        }
                        else
                        {
                            Thread.Sleep(1000);
                        }
                    }
                    else
                    {
                        // we're shutting down, so break out of the loop
                        break;
                    }
                }
                catch (Exception e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_1,
                    //    "Unexpected Exception thrown in ReceiveThread for InhConnection to "
                    //    + _interfaceInfo.IPAddressString
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                IGContext fdctx = null;
                lock (_sendQueue.SyncRoot)
                {
                    if (_sendQueue.Count > 0)
                    {
                        fdctx = (IGContext)_sendQueue.Dequeue();
                    }
                }
                if (fdctx != null)
                {
                    // queue is syncronized
                    try
                    {
                        if (fdctx.fWaitForResponse)
                        {
                            // store the current time in the context
                            fdctx.waitTableAdded = DateTime.Now;

                            // wait table inherits this reference.
                            _waitTable.Add(fdctx.frontdoorSeqNum, fdctx);
                        }
                        // now do the send
                        Socket s = GetSocket();
                        s.Send(fdctx.rgbRequest);
                        if (!fdctx.fWaitForResponse)
                        {
                            fdctx.CompleteRequest();
                        }
                    }
                    catch (Exception e)
                    {
                        // record the exception in the context object
                        fdctx.excep = e;

                        // removes the item from the wait table, regardless of if it's there or not.
                        _waitTable.Remove(fdctx.frontdoorSeqNum);

                        fdctx.CompleteRequest();

                        if (e is SocketException)
                        {
                            // record the exception in the event log
                            //XomNtEvent(XEvent.Id.PRESENCE_COMM_2,
                            //    "SocketException thrown calling Socket.Send() to "
                            //    + _interfaceInfo.IPAddressString + ":" + 
                            //    + _interfaceInfo.Port
                            //    + ". The front door will attempt to re-connect to the Presence INH server."
                            //    + " The health of the Presence INH server and the network should be checked."
                            //    + " SocketException.Message:"
                            //    + e.Message
                            //    + " SocketException.StackTrace:"
                            //    + e.StackTrace);

                             // invalidate the socket so the next call to 
                             // GetSocket reconnects it.
                             InvalidateSocket();
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go
                    // back to sleep.
                    break;
                }
            }
        }

        public void TimeoutExpiredContexts(object sender, ElapsedEventArgs eventArgs)
        {
            // make sure this event hasn't fired after the timer has been
            if (!_timeoutTimer.Enabled)
            {
                return;
            }

            // make sure we're not already shutting down
            if (ShuttingDown())
            {
                return;
            }

            try
            {
                ArrayList alRemoves = new ArrayList();;

                // iteration is not threadsafe even on a synchronized hashtable, so we need to lock
                // the sync root
                lock (_waitTable.SyncRoot) 
                {                    
                    foreach (DictionaryEntry de in _waitTable)
                    {
                        IGContext fdctx = (IGContext)de.Value;
                        if ((DateTime.Now - fdctx.waitTableAdded) > new TimeSpan(0,0,0,0,REPLY_TIMEOUT))
                        {
                            alRemoves.Add(fdctx);
                        }
                    }

                    System.Collections.IEnumerator enumRemoves = alRemoves.GetEnumerator();
                    while (enumRemoves.MoveNext())
                    {
                        IGContext fdctx = (IGContext)enumRemoves.Current;
                        
                        _waitTable.Remove(fdctx.frontdoorSeqNum);
                        fdctx.excep = new TimeoutException("Request timed out waiting for response");
                        fdctx.CompleteRequest();
                    }
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine(e);
                // log this exception to the event log - not much more we can do with it.
                //XomNtEvent(XEvent.Id.PRESENCE_COMM_4,
                //    "Unexpected Exception thrown in InhConnection.TimeoutExpiredContexts"
                //    + " Exception.Type: "
                //    + e.GetType().ToString()
                //    + " Exception.Message:"
                //    + e.Message
                //    + " Exception.StackTrace:"
                //    + e.StackTrace);
            }
        }

        public void ReceiveMessage()
        {
            try
            {
                Socket sock = GetSocket();
                IGMessageHeader header = new IGMessageHeader();
                int cBytes;
                int cTotalBytes;

                // Get the next header
                byte[] headerBuf = new byte[header.Size()];
                cTotalBytes = 0;
                while (cTotalBytes < header.Size())
                {
                    cBytes = sock.Receive(headerBuf, cTotalBytes, (int) header.Size() - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XPNFD.InhConnection.ReceiveMessage: Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                header.ReadBytes(headerBuf);

                IGMessageData Data = IGMessageData.GetInstance(header);

                // Get the body
                byte[] bodyBuf = new byte[header.dwMsgLen];
                cTotalBytes = 0;
                while (cTotalBytes < header.dwMsgLen)
                {
                    cBytes = sock.Receive(bodyBuf, cTotalBytes, (int) header.dwMsgLen - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XPNFD.InhConnection.ReceiveMessage: Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }
                Data.ReadBytes(bodyBuf);

                if (Data is IGNotificationData)
                {
                    IGNotificationData notification = Data as IGNotificationData;
                    // this is out of band
                    live.protocol.Presence.PNState user = live.protocol.Presence.PNState.Find(notification.userId);
                    if (user != null)
                    {
                        user.EnqueueQVals(notification.bIsPush, notification.qvalData);
                    }
                }
                else
                {
                    // this data was requested
                    // find the matching IGContext in the wait table
                    // the hashtable class may store null references, but we never add one
                    // to the table, so we can skip calling Contains()
                    // this hashtable is synchronized, but we need to check for and
                    // remove the context from the hashtable as an atomic operation
                    IGContext fdctx;
                    lock (_waitTable.SyncRoot)
                    {
                        fdctx = (IGContext)_waitTable[header.dwSeqNum];
                        _waitTable.Remove(header.dwSeqNum);
                    }

                    if (fdctx != null)
                    {
                        fdctx.Response = Data;
                        fdctx.CompleteRequest();
                    }
                }
            }
            catch (Exception e)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular PresenceFDContext, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!ShuttingDown())
                {
                    InvalidateSocket();
                    System.Diagnostics.Debug.WriteLine(e);
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_5,
                    //    "Unexpected Exception thrown in ReceiveMessage"
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        // returns the server name associated with this connection.
        public string GetServerName()
        {
            return _serverName;
        }

        public bool IsSocketHealthy()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                return _socketHealthy;
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }
        
        // Gets the current socket connection, verifying the health of the socket
        // and (re)connecting it if required
        public Socket GetSocket()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                if (_socketHealthy == false)
                {
                    LockCookie lc = _rwlSocketHealthy.UpgradeToWriterLock(LOCK_TIMEOUT);
                    try
                    {
                        // create a new socket
                        _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                            ProtocolType.Tcp);

                        // connect to the specified INH server
                        _socket.Connect(_endPoint);

                        // Send a HELLO message
                        IGHelloMsg msg = new IGHelloMsg(InstanceId);
                        if (msg == null)
                        {
                            throw new ApplicationException("IGClient.IGConnection.GetSocket: new IGHelloMsg() returned null.");
                        }

                        _socket.Send((byte[])msg);

                        // the socket is now healthy and ready to go
                        _socketHealthy = true;
                    }
                    finally
                    {
                        _rwlSocketHealthy.DowngradeFromWriterLock(ref lc);
                    }
                }
                return _socket;
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }

        // Marks the socket as unhealthy, so it will get re-created the next time it
        // is needed. It attempts to shut the socket down gracefully, which may or
        // may not succeed.
        public void InvalidateSocket()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                if (_socketHealthy == true)
                {
                    LockCookie lc = _rwlSocketHealthy.UpgradeToWriterLock(LOCK_TIMEOUT);
                    try
                    {
                        // the socket is no longer healthy
                        _socketHealthy = false;

                        // try to shut the socket down gracefully, which may or may
                        // not work... Regardless, the next time send or receive
                        // needs the socket, it will call GetSocket() again which
                        // will create a new socket and re-connect to the INH server
                        _socket.Shutdown(SocketShutdown.Send);
                        byte[] recvBuffer = new byte[1024];

                        // drain the receive buffer
                        while (_socket.Receive(recvBuffer) > 0);

                        _socket.Close();
                    }
                    finally
                    {
                        _rwlSocketHealthy.DowngradeFromWriterLock(ref lc);
                    }
                }
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\FDTransaction.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

using live.common;

namespace live.protocol
{
    public class FDTransaction : ITransaction
    {
        private IXOnSecurityProvider _securityProvider = new live.client.FakeSGSecurityProvider();
        public IXOnSecurityProvider SecurityProvider
        {
            get
            {
                return _securityProvider;
            }
            set
            {
                _securityProvider = value;
            }
        }

        //-----------------------------------------------------
        // GetServiceAddress
        //
        //      Returns an address from the service configuration
        //      that can be used to contact the given service id.
        //
        private static string GetServiceAddress(IClient client, XOService service)
        {
            System.Net.IPEndPoint ipEndPoint = Config.Current.GetIPEndPoint(client, service);
            return ipEndPoint.Address.ToString() + ":" + ipEndPoint.Port.ToString();
        }

        public static void GetServiceInfo(IClient client, XOService service, out string serviceAddress)
        {
            serviceAddress = GetServiceAddress(client, service);
        }

        //-----------------------------------------------------
        // SendRequest
        //
        //      Sends an http POST request to the given service
        //      id,  with xrl-compliant header information.
        //
        //      NOTE: error hresults returned in the X-Err header
        //      of the response are returned without exception.
        //      If no x-err is found, and the status is not 200,
        //      then an exception is thrown.
        //
        private uint SendRequest(
            IClient client,
            XOService service,
            string url,
            string httpMethod,
            byte[] sendData,
            WebHeaderCollection headers,
            out byte[] responseData)
        {
            METHOD.ENTER();
//            Version ver = Assembly.GetExecutingAssembly().GetName().Version;
            uint hr;
            string xErr;

            FDWebClient myWebClient = new FDWebClient();
            myWebClient.ReceiveTimeout = (int)client.Timeout;
            if (headers != null)
            {
                myWebClient.Headers.Add(headers);
            }

            if ((headers == null) || headers["Content-Type"] == null)
            {
                myWebClient.Headers.Add("Content-Type", "xon/" + ((int)service).ToString("x"));
            }
            // TODO: Ensure the assembly is versioned and use the right version
            if ((headers == null) || headers["User-Agent"] == null)
            {
                myWebClient.Headers.Add("User-Agent", ((int)service).ToString("x") + "/1.0.4325");
            }
            if ((headers == null) || (headers["X-Schema-Ver"] == null))
            {
                myWebClient.Headers.Add("X-Schema-Ver", 
                    WireInfoAttribute.VersionToString(WireData.CurrentSchemaVersion));
            }

            try
            {
//                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "POSTing " + sendData.Length + " bytes to " + url + "...");
                if (httpMethod.ToUpper() == HttpMethod.Post)
                {
                    responseData = myWebClient.UploadData(SecurityProvider, service, url, httpMethod, sendData);
                }
                else if (httpMethod.ToUpper() == HttpMethod.Get)
                {
                    responseData = myWebClient.DownloadData(SecurityProvider, service, url);
                }
                else
                {
                    throw new Exception("Unsupport HTTP method: " + httpMethod);
                }
                hr = HResult.S_OK;

                xErr = myWebClient.ResponseHeaders["X-Err"];
                if (xErr != null)
                {
                    hr = HResult.Parse(xErr);
                }

//                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, url + " returned 0x" + hr.ToString("x8"));

            }
            catch (WebException e)
            {
                xErr = null;
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available.
                    HttpStatusCode status = (e.Response == null ? HttpStatusCode.BadRequest : ((HttpWebResponse)e.Response).StatusCode);

                    throw new XrlRequestException(url, e.Message, status, sendData, e);
                }

                hr = HResult.Parse(xErr);
                responseData = null;

                //*                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, url + " returned 0x" + hr.ToString("x8"));
            }

            METHOD.EXIT();
            return hr;
        }

        //-----------------------------------------------------
        // SendRequestToAlternate
        //
        // This version allows the caller to specify an url directly, bypassing
        // interface lookups from npdb. This shouldn't be allowed in production,
        // but is useful in test environments so we can point our front doors
        // at emulators during stress runs.
        //
        // If the setting xrlutil_allowAlternateUrl is false, then calling this
        // method will throw an exception with an event id of XEvent.Id.COMMON_HACK_78.
        // Presuming the service is not misconfigured, this means that a hacker
        // may be trying to mess with a production environment by sending alternate
        // destination headers.
        //
        private uint SendRequestToAlternate(
            IClient client,
            XOService service,
            string url,
            string HttpMethod,
            XRLObject2 reqOb,
            WebHeaderCollection headers,
            XRLObject2 respOb)
        {
            uint hr;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            byte[] respData;

            reqOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            if (headers == null)
            {
                headers = new WebHeaderCollection();
            }

            if ((headers["X-Schema-Ver"] == null))
            {
                headers.Add("X-Schema-Ver",
                    WireInfoAttribute.VersionToString(reqOb.SchemaVersion));
            }


            hr = SendRequest(client, service, url, HttpMethod, stream.ToArray(), headers, out respData);

            if (HResult.Succeeded(hr) && respOb != null && respData != null && respData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(respData));
                respOb.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respData.Length, null);
            }

            return hr;
        }

        public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            XRLObject2 respOb)
        {
            string serviceAddress;
            GetServiceInfo(client, service, out serviceAddress);
            string finalUrl = "http://" + serviceAddress + relativeUrl;

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            return SendRequestToAlternate(client, service, finalUrl, httpMethod, reqOb, webHeaders, respOb);
        }

        public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            string serviceAddress;
            GetServiceInfo(client, service, out serviceAddress);
            string finalUrl = "http://" + serviceAddress + relativeUrl;

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }
            uint hr;
            hr = SendRequest(client, service, finalUrl, httpMethod, request, webHeaders, out response);
            return hr;
        }

        // Asynchronous methods
        private IAsyncResult BeginSendRequestInternal(
            IClient client,
            XblUser activeUser,
            XOService service,
            string url,
            string httpMethod,
            WebHeaderCollection headers,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {            
            FDWebClient myWebClient = new FDWebClient();
            myWebClient.ReceiveTimeout = (int)client.Timeout;
            if (headers != null)
            {
                myWebClient.Headers.Add(headers);
            }

            if ((headers == null) || headers["Content-Type"] == null)
            {
                myWebClient.Headers.Add("Content-Type", "xon/" + 
                                        ((int)service).ToString("x"));
            }
            // TODO: Ensure the assembly is versioned and use the right version
            if ((headers == null) || headers["User-Agent"] == null)
            {
                myWebClient.Headers.Add(
                    "User-Agent", 
                    ((int)service).ToString("x") + "/1.0.4325");
            }

            if ((headers == null) || (headers["X-Schema-Ver"] == null))
            {
                myWebClient.Headers.Add(
                    "X-Schema-Ver", 
                    WireInfoAttribute.VersionToString(
                        WireData.CurrentSchemaVersion));
            }

            IAsyncResult baseResult = null;
            TransactionAsyncContext context = 
                new TransactionAsyncContext(this,
                                            callback,
                                            state);

            if (httpMethod.ToUpper() == HttpMethod.Post)
            {
                baseResult = myWebClient.BeginTransmit(
                    SecurityProvider,
                    service,
                    url,
                    httpMethod,
                    request,
                    new AsyncCallback(context.HandleCallback),
                    null);
            }
            else if (httpMethod.ToUpper() == HttpMethod.Get)
            {
                baseResult = myWebClient.BeginTransmit(
                    SecurityProvider,
                    service,
                    url,
                    httpMethod,
                    new byte[0],
                    new AsyncCallback(context.HandleCallback),
                    null);
            }
            else
            {
                throw new Exception("Unsupport HTTP method: " + httpMethod);
            }

            context.BaseResult = baseResult;
            return context;
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            string serviceAddress;
            GetServiceInfo(client, service, out serviceAddress);
            string finalUrl = "http://" + serviceAddress + relativeUrl;
            
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }
            
            if (webHeaders["X-Schema-Ver"] == null)
            {
                webHeaders.Add(
                    "X-Schema-Ver",
                    WireInfoAttribute.VersionToString(reqOb.SchemaVersion));
            }

            // Convert reqOb to a byte stream
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            
            reqOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();            

            return BeginSendRequestInternal(client, 
                                            activeUser,
                                            service, 
                                            finalUrl, 
                                            httpMethod, 
                                            webHeaders,
                                            stream.ToArray(),
                                            callback,
                                            state);
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   XRLObject2 respOb)
        {
            byte[] respData = null;

            uint hr = this.EndSendRequest(asyncResult,
                                          out respData);
            
            if (HResult.Succeeded(hr) && respOb != null && 
                respData != null && respData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(
                    new MemoryStream(respData));
                
                respOb.ReadFromRequest(
                    reader, 
                    (UTF8Encoding)Encoding.UTF8, 
                    respData.Length, 
                    null);
            }

            return hr;
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {
            string serviceAddress;
            GetServiceInfo(client, service, out serviceAddress);
            string finalUrl = "http://" + serviceAddress + relativeUrl;

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            return BeginSendRequestInternal(client,
                                            activeUser,
                                            service, 
                                            finalUrl, 
                                            httpMethod, 
                                            webHeaders,
                                            request,
                                            callback,
                                            state);
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            uint hr = 0;
            string xErr;
            
            TransactionAsyncContext txContext = 
                (TransactionAsyncContext)asyncResult;

            FDTransmitContext context = 
                (FDTransmitContext)txContext.BaseResult;
            FDWebClient webClient = context.WebClient;

            try
            {
                response = webClient.EndTransmit(context);

                hr = HResult.S_OK;

                xErr = webClient.ResponseHeaders["X-Err"];
                if (xErr != null)
                {
                    hr = HResult.Parse(xErr);
                }
            }
            catch (WebException e)
            {
                xErr = null;
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available.
                    HttpStatusCode status = 
                        (e.Response == null ? HttpStatusCode.BadRequest : 
                         ((HttpWebResponse)e.Response).StatusCode);

                    throw new XrlRequestException(context.Uri.ToString(), 
                                                  e.Message, 
                                                  status, 
                                                  context.RequestData, 
                                                  e);
                }

                hr = HResult.Parse(xErr);
                response = null;                
            }
            
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\HttpTGTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.client;
using live.common;
using System.Net;

namespace live.protocol
{
    public class HttpTGTransaction : HttpTransaction
    {
        private IGConnection _connection;
        private TGSecurityProvider _securityProvider;
        public override IXOnSecurityProvider SecurityProvider
        {
            get
            {
                return _securityProvider;
            }
            set
            {
                _securityProvider = (TGSecurityProvider)value;
            }
        }

        public HttpTGTransaction()
        {
            _connection = TGTransaction.Connection;
            _securityProvider = new TGSecurityProvider(_connection);
        }

        override public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {


            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            response = null;
            uint hr;
            string xErr;

            _securityProvider.SetAuthentication(service, null, null, webHeaders);


            try
            {
                byte[] httpData = TransactFD(client.MachinePuid, (uint)service, relativeUrl,
                    httpMethod, webHeaders.ToByteArray(), request);

                if (httpData.Length == 0)
                {
                    throw new Exception("TransactFD() returned 0 byte response from server.  Expected at least HTTP 200 response.");
                }

                hr = HResult.S_OK;

                Dictionary<string, string> respHeaders = HttpHelper.GetHeaders(httpData);
                if (httpData.Length > 0)
                    response = HttpHelper.GetReponseBody(httpData, httpData.Length);

                if (respHeaders.TryGetValue("X-Err", out xErr))
                {
                    hr = HResult.Parse(xErr);
                }
            }
            catch (WebException e)
            {
                xErr = null;
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available.
                    HttpStatusCode status = (e.Response == null ? HttpStatusCode.BadRequest : ((HttpWebResponse)e.Response).StatusCode);

                    throw new XrlRequestException(relativeUrl, e.Message, status, request, e);
                }

                hr = HResult.Parse(xErr);
                response = null;
            }

            return hr;

            
        }

        private byte[] TransactFD(ulong xboxId, uint serviceId, string url, string RequestType, byte[] HttpHeader, byte[] Request)
        {

            IGFDRequest req = new IGFDRequest(xboxId, serviceId, url, RequestType, HttpHeader, Request);
            IGFDResponseData res = _connection.IssueRequest(req, true) as IGFDResponseData;
            return res._rgbResponse;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\HttpTransaction.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;

using live.common;

namespace live.protocol
{
    public class HttpTransaction : ITransaction
    {
        IXOnSecurityProvider _securityProvider = new live.client.EmptySecurityProvider();
        protected bool UseSSL = false;
        public virtual IXOnSecurityProvider SecurityProvider
        {
            get
            {
                return _securityProvider;
            }
            set
            {
                _securityProvider = value;
            }
        }

        public virtual uint SendRequest(
            IClient client,
            XOService service,
            string url,
            string httpMethod,
            byte[] sendData,
            WebHeaderCollection headers,
            out byte[] responseData)
        {
            Logging.WriteLine("SendRequest(1) entered");
            uint hr = HResult.S_OK;
            string xErr;

            System.Net.ServicePointManager.ServerCertificateValidationCallback += 
                new System.Net.Security.RemoteCertificateValidationCallback(RemoteCertValidate);

            //string serviceAddress;
            //FDTransaction.GetServiceInfo(client, service, out serviceAddress);
            //string finalUrl = "http://" + serviceAddress + url;
            
            WebClient myWebClient = new WebClient();
            //FDWebClient myWebClient = new FDWebClient();
            //WebProxy webProxy = new WebProxy("10.198.102.212", 13010);
            //myWebClient.Proxy = webProxy;

            // Add any caller provided headers
            if (headers != null)
            {
                myWebClient.Headers.Add(headers);
            }

            if (myWebClient.Headers["User-Agent"] == null)
            {
                myWebClient.Headers.Add("User-Agent", "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)");
            }

            try
            {
                if (httpMethod.ToUpper() == HttpMethod.Post)
                {
                    responseData = myWebClient.UploadData(url,httpMethod,sendData);
                    //responseData = myWebClient.UploadData(_securityProvider, service, url, httpMethod, sendData);
                }
                else if (httpMethod.ToUpper() == HttpMethod.Get)
                {
                    responseData = myWebClient.DownloadData(url);
                    //responseData = myWebClient.DownloadData(_securityProvider, service, url);
                }
                else
                {
                    throw new Exception("Unsupport HTTP method: " + httpMethod);
                }

                xErr = myWebClient.ResponseHeaders["X-Err"];
                if (xErr != null)
                {
                    hr = HResult.Parse(xErr);
                }
            }
            catch (WebException e)
            {
                // not a normal failure, so throw
                // default to BadRequest if no response is available.
                hr = HResult.E_FAIL;
                HttpWebResponse httpResp = (HttpWebResponse)e.Response;
                HttpStatusCode status = HttpStatusCode.BadRequest;
                string respData = "SendRequest failed. But no response data is available.";
                if (httpResp != null)
                {
                    status = httpResp.StatusCode;
                    respData = httpResp.StatusDescription;

                    // get the X-Err header from response
                    xErr = httpResp.Headers["X-Err"];
                    if (xErr != null)
                    {
                         hr = HResult.Parse(xErr);
                    }

                    if (httpResp.ContentLength > 0)
                    {
                        long contentLen = httpResp.ContentLength;
                        Stream stream = httpResp.GetResponseStream();
                        Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                        // Pipes the stream to a higher level stream reader with the required encoding format. 
                        StreamReader readStream = new StreamReader(stream, encode);
                        char[] read = new char[contentLen];
                        int count = readStream.Read(read, 0, read.Length);
                        //respData = Encoding.UTF8.GetString(read);
                        String str = new String(read, 0, count);
                        respData = str;
                    }
                }

                throw new XrlRequestException(url, e.Message, status, sendData, respData, hr, e);
            }
            return hr;
        }

        public virtual uint SendRequest(
           IClient client,
           XblUser activeUser,
           XOService service,
           string relativeUrl,
           string httpMethod,
           WebHeaderCollection webHeaders,
           XRLObject2 reqOb,
           XRLObject2 respOb)
        {
            Logging.WriteLine("SendRequest(2) entered");
            uint hr;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            byte[] respData;

            reqOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if (webHeaders["Content-Type"] == null && reqOb is live.protocol.next.WebRequestBase)
            {
                ((live.protocol.next.WebRequestBase)reqOb).SetWebHeaders(webHeaders);
            }
            else if (webHeaders["Content-Type"] == null && reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetWebHeaders(webHeaders);
            }

            hr = SendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, stream.ToArray(), out respData);


            if (respOb != null && respData != null && respData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(respData));
                respOb.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respData.Length, null);
            }

            return hr;
        }

        public virtual uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            Logging.WriteLine("SendRequest(3) entered");
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            string serviceAddress;
            FDTransaction.GetServiceInfo(client, service, out serviceAddress);
            string finalUrl;
            if (this.UseSSL)
            {
                // If it's set to the default port 80 but we were told to use SSL, switch to the default SSL port
                int index = serviceAddress.IndexOf(":80");
                Logging.WriteLine("Found serviceAddress: " + serviceAddress);
                if (index != -1)
                {
                    serviceAddress = serviceAddress.Remove(index) + ":443";
                }
                finalUrl = "https://" + serviceAddress + relativeUrl;
                Logging.WriteLine("Using finalUrl: " + finalUrl);
            }
            else
            {
                finalUrl = "http://" + serviceAddress + relativeUrl;
            }

            return SendRequest(client, service, finalUrl, httpMethod, request, webHeaders, out response);
        }

        static bool RemoteCertValidate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate cert, System.Security.Cryptography.X509Certificates.X509Chain chain,
            System.Net.Security.SslPolicyErrors error)
        {
            live.common.Logging.WriteLine(string.Format("WARNING: Got server certificate error: {0}", error.ToString()));
            return true;
        }

        // Asynchronous methods
        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   XRLObject2 respOb)
        {
            throw new Exception("Async method not implemented");
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            throw new Exception("Async method not implemented");        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\IGProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using live.common;

namespace live.protocol
{
    public class IGDefs
    {
        public const uint IG_PROTOCOL_VERSION_CURRENT = 1;
        public const uint IG_MESSAGE_HEADER_SIZE = 16;
    }

    public enum IG_MSG_TYPES
    {
        // request types:
        IGMSG_MIN_REQ                    = 1000,
        IGMSG_HELLO                      = 1000,
        IGMSG_ADD_XBOX_REQ               = 1001,
        IGMSG_REMOVE_XBOX_REQ            = 1002,
        IGMSG_DEAD_XBOX_REQ              = 1003,
        IGMSG_CLEAR_XBOX_REQ             = 1004,
        IGMSG_ADD_USER_REQ               = 1005,
        IGMSG_REMOVE_USER_REQ            = 1006,
        IGMSG_SET_TITLE_REQ              = 1007,
        IGMSG_SET_ALT_TITLES_REQ         = 1008,
        IGMSG_SET_KEY_REQ                = 1009,
        IGMSG_SET_USER_STATE_REQ         = 1010,
        IGMSG_FD_REQ                     = 1011,
        IGMSG_LOAD_SLOT_REQ              = 1012,
        IGMSG_PUT_SLOT_REQ               = 1013,
        IGMSG_MAX_REQ                    = 1013,

        // response types:
        IGMSG_MIN_RESP                   = 1100,
        IGMSG_ADD_XBOX_RES               = 1100,
        IGMSG_FD_RES                     = 1101,
        IGMSG_NOTIFICATION               = 1102,
        IGMSG_LOAD_SLOT_RES              = 1103,
        IGMSG_MAX_RESP                   = 1103,
    };

    public class IGMessage : WireData
    {
        public IGMessageHeader _Header;
        public IGMessageData   _Data;

        public IGMessage()
        {
        }

        public IGMessage(IG_MSG_TYPES eType, IGMessageData Data)
        {
            _Header = new IGMessageHeader(eType);
            _Data = Data;
            _Header.dwMsgLen = (uint)(_Data.Size());
        }

        public override int Size()
        {
            return (_Header != null ? _Header.Size() : 0) + (_Data != null ? _Data.Size() : 0);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            _Header.WriteStream(binaryWriter);
            _Data.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _Header = new IGMessageHeader();
            _Header.ReadStream(binaryReader);

            _Data = IGMessageData.GetInstance(_Header);
            _Data.ReadStream(binaryReader);
            return this;
        }
    }

    public class IGMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public IGMessageHeader()
        {
        }

        public IGMessageHeader(IG_MSG_TYPES eType)
        {
            dwProtocolVersion = IGDefs.IG_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)IGDefs.IG_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - IGMessageHeader::WriteStream binaryWriter is null");
            }

            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            dwProtocolVersion = binaryReader.ReadUInt32();
            dwMsgType = binaryReader.ReadUInt32();
            dwMsgLen = binaryReader.ReadUInt32();
            dwSeqNum = binaryReader.ReadUInt32();
           
            return this;
        }
    } 

    public class IGMessageData : WireData
    {
        public static IGMessageData GetInstance(IGMessageHeader Header)
        {
            IGMessageData data = null;
            switch (Header.dwMsgType)
            {
                case (uint)IG_MSG_TYPES.IGMSG_HELLO:
                    data = new IGHelloMsgData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_ADD_XBOX_REQ:
                    data = new IGAddXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_ADD_XBOX_RES:
                    data = new IGAddXboxResponseData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_REMOVE_XBOX_REQ:
                    data = new IGRemoveXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_DEAD_XBOX_REQ:
                    data = new IGDeadXboxRequestData();
                    break;
                case (uint) IG_MSG_TYPES.IGMSG_CLEAR_XBOX_REQ:
                    data = new IGRemoveXboxRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_ADD_USER_REQ:
                    data = new IGAddUserRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_REMOVE_USER_REQ:
                    data = new IGRemoveUserRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_TITLE_REQ:
                    data = new IGSetTitleRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_ALT_TITLES_REQ:
                    data = new IGSetAltTitlesRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_KEY_REQ:
                    data = new IGSetKeyRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_SET_USER_STATE_REQ:
                    data = new IGSetUserStateRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_FD_REQ:
                    data = new IGFDRequestData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_FD_RES:
                    data = new IGFDResponseData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_NOTIFICATION:
                    data = new IGNotificationData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_LOAD_SLOT_REQ:
                    data = new IGLoadSlotData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_LOAD_SLOT_RES:
                    data = new IGLoadSlotResponseData();
                    break;
                case (uint)IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ:
                    data = new IGPutSlotData();
                    break;
            }

            return data;
        }
    }

    public class IGHelloMsg : IGMessage
    {
        public IGHelloMsg(string Description) : base(IG_MSG_TYPES.IGMSG_HELLO, new IGHelloMsgData(Description))
        {
        }
    }

    public class IGHelloMsgData : IGMessageData
    {
        [WireInfo(NullTerminate = true, ArraySize = 79)]
        public string szDescription;

        public IGHelloMsgData()
        {
        }

        public IGHelloMsgData(string Description)
        {
            szDescription = Description;
        }

        public override int Size()
        {
            return 80;
        }
    }

    public class IGAddXboxRequest : IGMessage
    {
        public IGAddXboxRequest(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, uint clientType, uint languageId)
            : base(IG_MSG_TYPES.IGMSG_ADD_XBOX_REQ, new IGAddXboxRequestData(xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId))
        {}
    }

    public class IGAddXboxRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _titleId;
        public uint _titleVer;
        public uint _titleRegion;

        public uint _dwKeySize;
        [WireInfo(SizeParam = "_dwKeySize")]
        public byte[] _rgbKey;
        public ulong _clientVersion;
        public uint _clientType;
        public uint _languageId;

        public IGAddXboxRequestData()
        { }

        public IGAddXboxRequestData(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, uint clientType, uint languageId)
        {
            _xboxId = xboxId;
            _titleId = titleId;
            _titleVer = titleVer;
            _titleRegion = titleRegion;
            _dwKeySize = (uint)key.Length;
            _rgbKey = key;
            _clientVersion = clientVersion;
            _clientType = clientType;
            _languageId = languageId;
        }

        public override int Size()
        {
            return sizeof(ulong) 
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint)
                + ((_rgbKey == null) ? 0 : _rgbKey.Length)
                + sizeof(ulong)
                + sizeof(uint)
                + sizeof(uint);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            _dwKeySize = (_rgbKey == null) ? 0 : (uint)_rgbKey.Length;
            
            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_titleId);
            binaryWriter.Write(_titleVer);
            binaryWriter.Write(_titleRegion);
            binaryWriter.Write(_dwKeySize);

            if (_rgbKey != null)
            {
                binaryWriter.Write(_rgbKey);
            }

            binaryWriter.Write(_clientVersion);
            binaryWriter.Write((uint)_clientType);
            binaryWriter.Write(_languageId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _titleId = binaryReader.ReadUInt32();
            _titleVer = binaryReader.ReadUInt32();
            _titleRegion = binaryReader.ReadUInt32();
            _dwKeySize = binaryReader.ReadUInt32();
            _rgbKey = new byte[_dwKeySize];
            if (_dwKeySize > 0)
            {
                _rgbKey = binaryReader.ReadBytes((int)_dwKeySize);
            }
            _clientVersion = binaryReader.ReadUInt64();
            _clientType = binaryReader.ReadUInt32();
            _languageId = binaryReader.ReadUInt32();

            return this;
        }


    }

    public class IGAddXboxResponse : IGMessage
    {
        public IGAddXboxResponse(SGADDR sgaddr)
            : base(IG_MSG_TYPES.IGMSG_ADD_XBOX_RES, new IGAddXboxResponseData(sgaddr))
        { }
    }

    public class IGAddXboxResponseData : IGMessageData
    {
        public SGADDR _sgaddr;

        public IGAddXboxResponseData()
        {
            _sgaddr = new SGADDR();
        }

        public IGAddXboxResponseData(SGADDR sgaddr)
        {
            _sgaddr = sgaddr;
        }

        public override int Size()
        {
            return _sgaddr.Size();
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            _sgaddr.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _sgaddr.ReadStream(binaryReader);
            return this;
        }
    }

    public class IGClearXboxRequest : IGMessage
    {
        public IGClearXboxRequest()
            : base(IG_MSG_TYPES.IGMSG_CLEAR_XBOX_REQ, new IGRemoveXboxRequestData(0))
        { }
    }

    public class IGRemoveXboxRequest : IGMessage
    {
        public IGRemoveXboxRequest(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_REMOVE_XBOX_REQ, new IGRemoveXboxRequestData(xboxId))
        { }
    }

    public class IGRemoveXboxRequestData : IGMessageData
    {
        public ulong _xboxId;

        public IGRemoveXboxRequestData()
        { }

        public IGRemoveXboxRequestData(ulong xboxId)
        {
            _xboxId = xboxId;
        }

        public override int Size()
        {
            return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            return this;
        }


    }

    public class IGDeadXboxRequest : IGMessage
    {
        public IGDeadXboxRequest(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_DEAD_XBOX_REQ, new IGDeadXboxRequestData(xboxId))
        { }
    }

    public class IGDeadXboxRequestData : IGMessageData
    {
        public ulong _xboxId;

        public IGDeadXboxRequestData()
        { }

        public IGDeadXboxRequestData(ulong xboxId)
        {
            _xboxId = xboxId;
        }

        public override int Size()
        {
            return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            return this;
        }
    }

    public class IGAddUserRequest : IGMessage
    {
        public IGAddUserRequest(ulong xboxId, ulong userId, uint userFlags)
            : base(IG_MSG_TYPES.IGMSG_ADD_USER_REQ, new IGAddUserRequestData(xboxId, userId, userFlags))
        { }
    }

    public class IGAddUserRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;
        public uint _userFlags;

        public IGAddUserRequestData()
        { }

        public IGAddUserRequestData(ulong xboxId, ulong userId, uint userFlags)
        {
            _xboxId = xboxId;
            _userId = userId;
            _userFlags = userFlags;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong)
                + sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
            binaryWriter.Write(_userFlags);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();
            _userFlags = binaryReader.ReadUInt32();

            return this;
        }
    }

    public class IGRemoveUserRequest : IGMessage
    {
        public IGRemoveUserRequest(ulong xboxId, ulong userId)
            : base(IG_MSG_TYPES.IGMSG_REMOVE_USER_REQ, new IGRemoveUserRequestData(xboxId, userId))
        { }
    }

    public class IGRemoveUserRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;

        public IGRemoveUserRequestData()
        { }

        public IGRemoveUserRequestData(ulong xboxId, ulong userId)
        {
            _xboxId = xboxId;
            _userId = userId;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();

            return this;
        }
    }

    public class IGSetTitleRequest : IGMessage
    {
        public IGSetTitleRequest(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
            : base(IG_MSG_TYPES.IGMSG_SET_TITLE_REQ, new IGSetTitleRequestData(xboxId, titleId, titleVer, titleRegion))
        { }
    }

    public class IGSetTitleRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _titleId;
        public uint _titleVer;
        public uint _titleRegion;

        public IGSetTitleRequestData()
        { }

        public IGSetTitleRequestData(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            _xboxId = xboxId;
            _titleId = titleId;
            _titleVer = titleVer;
            _titleRegion = titleRegion;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + sizeof(uint)
                + sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_titleId);
            binaryWriter.Write(_titleVer);
            binaryWriter.Write(_titleRegion);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _titleId = binaryReader.ReadUInt32();
            _titleVer = binaryReader.ReadUInt32();
            _titleRegion = binaryReader.ReadUInt32();

            return this;
        }
    }

    public class IGSetAltTitlesRequest : IGMessage
    {
        public IGSetAltTitlesRequest(ulong xboxId, uint[] altTitleIds)
            : base(IG_MSG_TYPES.IGMSG_SET_ALT_TITLES_REQ, new IGSetAltTitlesRequestData(xboxId, altTitleIds))
        { }
    }

    public class IGSetAltTitlesRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _dwAltTitles;
        [WireInfo(SizeParam = "_dwAltTitles")]
        public uint[] _altTitleIds;

        public IGSetAltTitlesRequestData()
        { }

        public IGSetAltTitlesRequestData(ulong xboxId, uint[] altTitleIds)
        {
            _xboxId = xboxId;
            _dwAltTitles = (uint)altTitleIds.Length;
            _altTitleIds = altTitleIds;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + ((_altTitleIds == null) ? 0 : _altTitleIds.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_dwAltTitles);
            if (_altTitleIds != null)
            {
                for (int iTitle = 0; iTitle < _dwAltTitles; iTitle++)
                {
                    binaryWriter.Write(_altTitleIds[iTitle]);
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _dwAltTitles = binaryReader.ReadUInt32();
            _altTitleIds = new uint[_dwAltTitles];
            for (int iTitle = 0; iTitle < _dwAltTitles; iTitle++)
            {
                _altTitleIds[iTitle] = binaryReader.ReadUInt32();
            }

            return this;
        }
    }

    public class IGSetKeyRequest : IGMessage
    {
        public IGSetKeyRequest(ulong xboxId, byte[] key)
            : base(IG_MSG_TYPES.IGMSG_SET_KEY_REQ, new IGSetKeyRequestData(xboxId, key))
        { }
    }

    public class IGSetKeyRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _dwKeySize;
        [WireInfo(SizeParam = "_dwKeySize")]
        public byte[] _rgbKey;

        public IGSetKeyRequestData()
        { }

        public IGSetKeyRequestData(ulong xboxId, byte[] key)
        {
            _xboxId = xboxId;
            _dwKeySize = (uint)key.Length;
            _rgbKey = key;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)
                + ((_rgbKey == null) ? 0 : _rgbKey.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_dwKeySize);

            if (_rgbKey != null)
            {
                binaryWriter.Write(_rgbKey);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _dwKeySize = binaryReader.ReadUInt32();
            _rgbKey = new byte[_dwKeySize];
            if (_dwKeySize > 0)
            {
                _rgbKey = binaryReader.ReadBytes((int)_dwKeySize);
            }

            return this;
        }
    }

    public class IGSetUserStateRequest : IGMessage
    {
        public IGSetUserStateRequest(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData)
            : base(IG_MSG_TYPES.IGMSG_SET_USER_STATE_REQ, new IGSetUserStateRequestData(xboxId, userId, matchSessionId, state, titleData))
        { }
    }

    public class IGSetUserStateRequestData : IGMessageData
    {
        public ulong _xboxId;
        public ulong _userId;
        public ulong _matchSessionId;
        public uint _state;
        public ushort _titleDataLen;
        public byte[] _titleData;

        public IGSetUserStateRequestData()
        { }

        public IGSetUserStateRequestData(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData)
        {
            _xboxId = xboxId;
            _userId = userId;
            _matchSessionId = matchSessionId;
            _state = state;
            _titleDataLen = (ushort)titleData.Length;
            _titleData = titleData;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(ulong)
                + sizeof(ulong)
                + sizeof(uint)
                + sizeof(ushort)
                + ((_titleData == null) ? 0 : _titleData.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_userId);
            binaryWriter.Write(_matchSessionId);
            binaryWriter.Write(_state);
            binaryWriter.Write(_titleDataLen);
            if (_titleData != null)
            {
                binaryWriter.Write(_titleData);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            _userId = binaryReader.ReadUInt64();
            _matchSessionId = binaryReader.ReadUInt64();
            _state = binaryReader.ReadUInt32();
            _titleDataLen = binaryReader.ReadUInt16();
            _titleData = new byte[_titleDataLen];
            if (_titleDataLen > 0)
            {
                _titleData = binaryReader.ReadBytes((int)_titleDataLen);
            }

            return this;
        }
    }

    public class IGFDRequest : IGMessage
    {
        public IGFDRequest(ulong xboxId, uint serviceId, string url, string RequestType, byte[] HttpHeader, byte[] Request)
            : base(IG_MSG_TYPES.IGMSG_FD_REQ, new IGFDRequestData(xboxId, serviceId, url, RequestType, HttpHeader,  Request))
        { }
    }

    public class IGFDRequestData : IGMessageData
    {
        public ulong _xboxId;
        public uint _serviceId;

        public ushort _cbUrlLen; // Includes the '\0'
        [WireInfo(SizeParam = "_cbUrlLen", NullTerminate = true)]
        public string _szUrl; // ASCII Null terminated

        public ushort _cbRequestType; // Includes the '\0'
        [WireInfo(SizeParam = "_cbRequestType", NullTerminate = true)]
        public string _szRequestType; // ASCII Null terminated
        
        public uint _dwHttpHeaderSize;
        [WireInfo(SizeParam = "_dwHttpHeaderSize")]
        public byte[] _rgbHttpHeader;

        public uint _dwRequestSize;
        [WireInfo(SizeParam = "_dwRequestSize")]
        public byte[] _rgbRequest;


        public IGFDRequestData()
        { }

        public IGFDRequestData(ulong xboxId, uint serviceId, string url, string RequestType, byte[]HttpHeader,  byte[] Request)
        {
            _xboxId = xboxId;
            _serviceId = serviceId;

            _cbUrlLen = (ushort)url.Length;
            _szUrl = url;

            _cbRequestType = (ushort)RequestType.Length;
            _szRequestType = RequestType;

            _rgbHttpHeader = HttpHeader;
            _dwHttpHeaderSize = (uint)_rgbHttpHeader.Length;

            _rgbRequest = Request;
            _dwRequestSize = (uint)_rgbRequest.Length;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(uint)

                + sizeof(ushort)
                + ((_szUrl == null) ? 0 : _szUrl.Length)

                + sizeof(ushort)
                + ((_szRequestType == null) ? 0 : _szRequestType.Length)

                +sizeof(uint)
                + ((_rgbHttpHeader == null) ? 0 : _rgbHttpHeader.Length)

                +sizeof(uint)
                + ((_rgbRequest == null) ? 0 : _rgbRequest.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_xboxId);
            binaryWriter.Write(_serviceId);


            binaryWriter.Write(_cbUrlLen);

            if (_szUrl != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_szUrl));
            }

            binaryWriter.Write(_cbRequestType);

            if (_szRequestType != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_szRequestType));
            }

            binaryWriter.Write(_dwHttpHeaderSize);

            if (_rgbHttpHeader != null)
            {
                binaryWriter.Write(_rgbHttpHeader);
            }
            binaryWriter.Write(_dwRequestSize);

            if (_rgbRequest != null)
            {
                binaryWriter.Write(_rgbRequest);
            }

            
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64(); ;
            _serviceId = binaryReader.ReadUInt32();

            _cbUrlLen = binaryReader.ReadUInt16();
            if (_cbUrlLen > 0)
            {
                _szUrl = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_cbUrlLen));
            }

            _cbRequestType = binaryReader.ReadUInt16();
            if (_cbRequestType > 0)
            {
                _szRequestType = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_cbRequestType));
            }

            _dwHttpHeaderSize = binaryReader.ReadUInt32();
            _rgbHttpHeader = new byte[_dwHttpHeaderSize];
            if (_dwHttpHeaderSize > 0)
            {
                _rgbHttpHeader = binaryReader.ReadBytes((int)_dwHttpHeaderSize);
            }
            _dwRequestSize = binaryReader.ReadUInt32();
            _rgbRequest = new byte[_dwRequestSize];
            if (_dwRequestSize > 0)
            {
                _rgbRequest = binaryReader.ReadBytes((int)_dwRequestSize);
            }

            return this;
        }
    }

    public class IGFDResponse : IGMessage
    {
        public IGFDResponse(byte[] HttpResonse)
            : base(IG_MSG_TYPES.IGMSG_FD_RES, new IGFDResponseData(HttpResonse))
        { }
    }

    public class IGFDResponseData : IGMessageData
    {
        public uint _dwHttpResponseSize;
        [WireInfo(SizeParam = "_dwHttpResponseSize")]
        public byte[] _rgbResponse;

        public IGFDResponseData()
        { }

        public IGFDResponseData(byte[] HttpResponse)
        {
            _rgbResponse = HttpResponse;
            _dwHttpResponseSize = (uint)_rgbResponse.Length;
        }

        public override int Size()
        {
            return sizeof(uint)
                + ((_rgbResponse == null) ? 0 : _rgbResponse.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_dwHttpResponseSize);

            if (_rgbResponse != null)
            {
                binaryWriter.Write(_rgbResponse);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _dwHttpResponseSize = binaryReader.ReadUInt32();
            _rgbResponse = new byte[_dwHttpResponseSize];
            if (_dwHttpResponseSize > 0)
            {
                _rgbResponse = binaryReader.ReadBytes((int)_dwHttpResponseSize);
            }

            return this;
        }
    }

    public class IGNotification : IGMessage
    {
        public IGNotification(ulong userId, bool bIsPush, uint[] qvalData)
            : base(IG_MSG_TYPES.IGMSG_NOTIFICATION, new IGNotificationData(userId, bIsPush, qvalData))
        { }
    }

    public class IGNotificationData : IGMessageData
    {
        public ulong userId;
        public bool bIsPush;
        [WireInfo(ArraySize = 15)]
        public uint[] qvalData;

        public IGNotificationData(){}

        public IGNotificationData(ulong userId, bool bIsPush, uint[] qvalData)
        {
            this.userId = userId;
            this.bIsPush = bIsPush;
            this.qvalData = qvalData;
        }

        public override int Size()
        {
            return sizeof(ulong)
                + sizeof(bool)
                + 15 * sizeof(uint);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            if(qvalData.Length < 15)
            {
                throw new Exception("Invalid QVal Data");
            }

            binaryWriter.Write(userId);
            binaryWriter.Write(bIsPush);

            for (int i = 0; i < 15; i++)
            {
                binaryWriter.Write(qvalData[i]);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            userId = binaryReader.ReadUInt64();
            bIsPush = binaryReader.ReadBoolean();
            qvalData = new uint[15];
            for (int i = 0; i < 15; i++)
            {
                qvalData[i] = binaryReader.ReadUInt32();
            }

            return this;
        }
    }

    public class IGPutSlot : IGMessage
    {
        public IGPutSlot(CSGInfo sgInfo)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGPutSlotData(sgInfo)) { }
    }

    public class IGPutSlotData : IGMessageData
    {
        public CSGInfo _sgInfo;

        public IGPutSlotData() { }

        public IGPutSlotData(CSGInfo sgInfo)
        {
            this._sgInfo = sgInfo;
        }

        public override int Size()
        {
            unsafe
            {
                return sizeof(CSGInfo);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    for (int curByte = 0; curByte < sizeof(CSGInfo); curByte++)
                    {
                        binaryWriter.Write(*pbSGInfo);
                        pbSGInfo++;
                    }
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    byte[] baSGInfo = binaryReader.ReadBytes(sizeof(CSGInfo));
                    if (baSGInfo.Length != sizeof(CSGInfo))
                    {
                        throw new Exception("Incorrect Length read");
                    }

                    foreach (byte curByte in baSGInfo)
                    {
                        *pbSGInfo = curByte;
                        pbSGInfo++;
                    }
                }
            }
            return this;
        }
    }

    public class IGLoadSlot : IGMessage
    {
        public IGLoadSlot(ulong xboxId)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGLoadSlotData(xboxId)) { }
    }

    public class IGLoadSlotData : IGMessageData
    {
        public ulong _xboxId;

        public IGLoadSlotData() { }

        public IGLoadSlotData(ulong xboxId)
        {
            this._xboxId = xboxId;
        }

        public override int Size()
        {
           return sizeof(ulong);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            binaryWriter.Write(_xboxId);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _xboxId = binaryReader.ReadUInt64();
            return this;
        }
    }

    public class IGLoadSlotResponse : IGMessage
    {
        public IGLoadSlotResponse(CSGInfo sgInfo)
            : base(IG_MSG_TYPES.IGMSG_PUT_SLOT_REQ, new IGLoadSlotResponseData(sgInfo)) { }
    }

    public class IGLoadSlotResponseData : IGMessageData
    {
        public CSGInfo _sgInfo;

        public IGLoadSlotResponseData() { }

        public IGLoadSlotResponseData(CSGInfo sgInfo)
        {
            this._sgInfo = sgInfo;
        }

        public override int Size()
        {
            unsafe
            {
                return sizeof(CSGInfo);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    for (int curByte = 0; curByte < sizeof(CSGInfo); curByte++)
                    {
                        binaryWriter.Write(*pbSGInfo);
                        pbSGInfo++;
                    }
                }
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            unsafe
            {
                fixed (CSGInfo* pSGInfo = &_sgInfo)
                {
                    byte* pbSGInfo = (byte*)pSGInfo;
                    byte[] baSGInfo = binaryReader.ReadBytes(sizeof(CSGInfo));
                    if (baSGInfo.Length != sizeof(CSGInfo))
                    {
                        throw new Exception("Incorrect Length read");
                    }

                    foreach (byte curByte in baSGInfo)
                    {
                        *pbSGInfo = curByte;
                        pbSGInfo++;
                    }
                }
            }
            return this;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\LiveInfoProtocol.cs ===
/*==========================================================================
 *
 *  LiveInfoProtocol.cs -- This module defines the wire protocol for Storage 
 *                          server.
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Caching;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

using live.common;
using live.client;
using System.Net;

namespace live.protocol
{
    /// <summary>
    /// Calls into live to get the LIVE HIVE data which stores
    /// many setting/timings/configurations.
    /// 
    /// [configname] is the name relating to the configuration settings
    /// that you are looking to retrieve. In most cases it will be the 
    /// client type (xenon, pc, zune) vc_config in the database will
    /// hold the value and the backend will do all the gathering
    /// of related settings for you.
    ///
    /// </summary>
    public class GetLiveConfigRequest : XRLRequestObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        public override string Xrl
        {
            get { return "/liveinfo/getliveconfig.ashx"; }
        }
    }

    /// <summary>
    /// Response from GetLiveConfig that contains a string with
    /// all of the settings requested, each on a new line. INI format.
    /// </summary>
    public class GetLiveConfigResponse : XRLObject2
    {
        
        public const int CONFIG_BLOCK_MAX_COUNT = 10;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT * XeGenericBlock.BLOCK_MAX_LEN)]
        public uint configLen;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT)]
        public ushort configBlockCount;

        [WireInfo(SizeParam="configBlockCount")]
        public XeGenericBlock[] configBlocks;

        [WireInfo(Serialize = false)]
        public string config;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\PartyUserSetting.cs ===
using System;
using System.Collections.Generic;
using System.IO;

using live.client;
using live.common;
using live.protocol.Presence;

namespace live.protocol
{
    public enum PartyFlags : byte
    {
        // Party profile setting flags
        XPARTY_PROFILE_FLAG_NAT_OPEN = 0x1,
        XPARTY_PROFILE_FLAG_NO_PRESENCE = 0x2,
        XPARTY_PROFILE_FLAG_FRIENDS_ONLY_PRESENCE = 0x4,
        XPARTY_PROFILE_FLAG_SESSION_JOINABLE = 0x8
    }

    // This is the structure that's stored in the party's profile setting. It's queried by 
    // other users to join the party via presence. It's also used by the community channel in 
    // Epix to render the party formation. Every member in the party has it's own setting, 
    // but only the leader of the party has the entire party formation. Everybody else only 
    // has the leader. The leader is always the first member in the struct. 
    public class PartyUserSetting : UserSetting
    {
        public const byte XPARTY_PROFILE_SETTING_VERSION = 0x10;
        public const int XPARTY_MAX_ACTUAL_USERS = 8;

        // Information about one member of the party
        public class XPARTY_PROFILE_MEMBER_INFO
        {
            public ulong Xuid;                                   // Xuid of the party member
            //public fixed char GamerTag[XOn.XONLINE_NAME_MAX_SIZE];
            public string GamerTag;                              // Gamertag of the party member

            public byte[] ToArray()
            {
                MemoryStream stream = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(stream);
                byte[] beXuid = ArrayEx.Reverse(BitConverter.GetBytes(Xuid));
                writer.Write(beXuid);
                char[] gamertag = new char[XOn.XONLINE_NAME_MAX_SIZE];
                System.Text.UTF8Encoding.UTF8.GetBytes(GamerTag).CopyTo(gamertag, 0);
                writer.Write(gamertag);

                return stream.ToArray();
            }
        }

        // Information about the host of the party
        public class XPARTY_INFO
        {
            public XNKID sessionID = new XNKID();
            public XNADDR hostAddress = new XNADDR();
            public XNKEY keyExchangeKey = new XNKEY();
            public UInt16 port;

            public byte[] ToArray()
            {
                MemoryStream stream = new MemoryStream();

                sessionID.WriteStream(stream);
                hostAddress.WriteStream(stream);
                keyExchangeKey.WriteStream(stream);
                stream.Write(BitConverter.GetBytes(port), 0, 2);

                return stream.ToArray();
            }
        }

        [WireInfo(Serialize = false)]
        public byte bVersion = XPARTY_PROFILE_SETTING_VERSION;
        [WireInfo(Serialize = false)]
        public XPARTY_INFO PartyInfo = new XPARTY_INFO();
        [WireInfo(Serialize = false)]
        public UInt32 dwPartyFlags;
        [WireInfo(Serialize = false)]
        public UInt32 dwLeaderTitleId;
        [WireInfo(Serialize = false)]
        public XPARTY_PROFILE_MEMBER_INFO[] Members = new XPARTY_PROFILE_MEMBER_INFO[XPARTY_MAX_ACTUAL_USERS];

        // We had to add a lot of stuff to XPARTY_PROFILE_SETTING very late in the 
        // game - late enought that we couldn't get a new setting set up on the 
        // service (changing the maximum size also changes the setting). So we had to 
        // pack all the party member flags into a single DWORD (dwPartyFlags), one 
        // nibble per party member. Nibble 0 is the leader and so on.
        public static byte XPartyProfileConvertFromPartyToMemberFlags(byte PartyFlags, byte MemberNum)
        {
            return (byte)(((PartyFlags) >> ((MemberNum) * 4)) & 0xF);
        }

        public static byte XPartyProfileConvertFromMemberToPartyFlags(byte MemberFlags, byte MemberNum)
        {
            return (byte)(((MemberFlags) & 0xF) << ((MemberNum) * 4));
        }

        public PartyUserSetting(Xbox360Client hostClient, XblUser hostUser, PartyFlags flags)
        {
            this.dwLeaderTitleId = hostClient.TitleId;
            this.dwPartyFlags = (uint)flags;
            this.Members[0] = new XPARTY_PROFILE_MEMBER_INFO();
            this.Members[0].GamerTag = hostUser.Gamertag;
            this.Members[0].Xuid = hostUser.Puid;
            //this.Members[0].Xuid.dwUserFlags;
            //this.PartyInfo.hostAddress.abEnet;
            //this.PartyInfo.hostAddress.ina;
            //this.PartyInfo.hostAddress.inaOnline;
            //this.PartyInfo.hostAddress.sgaddr;
            //this.PartyInfo.hostAddress.wPortOnline;
            this.PartyInfo.keyExchangeKey.ab1 = BitConverter.ToUInt64(hostClient.Key, 0);
            this.PartyInfo.port = 0;
            byte[] sessionIdBytes = new byte[8];
            RandomEx.GlobalRandGen.NextBytes(sessionIdBytes);
            this.PartyInfo.sessionID.ab = BitConverter.ToUInt64(sessionIdBytes, 0); this.SettingId = ProfileDefs.XPROFILE_GAMERCARD_PARTY_INFO;
            this.Source = XOn.XSOURCE_DEFAULT;
            this.UserId = hostUser.Puid;
            //this.Value;
            //this.ValueLen;
        }

        private byte GetMemberNum(XblUser user)
        {
            for (byte i = 0; i < XPARTY_MAX_ACTUAL_USERS; i++)
            {
                if (Members[i].Xuid == user.Puid)
                {
                    return i;
                }
            }
            throw new Exception("User puid " + user.Puid + " not found in party.");
        }

        private byte GetNextAvailMemberNum(XblUser user)
        {
            for (byte i = 0; i < XPARTY_MAX_ACTUAL_USERS; i++)
            {
                if (Members[i] != null && Members[i].Xuid == 0)
                {
                    return i;
                }
                if (Members[i] == null)
                {
                    Members[i] = new XPARTY_PROFILE_MEMBER_INFO();
                    return i;
                }
            }
            throw new Exception("Party is full.  No member number is available.");
        }

        public void AddPartyMember(XblUser user, PartyFlags memberFlags)
        {
            byte memberNum = GetNextAvailMemberNum(user);
            Members[memberNum].GamerTag = user.Gamertag;
            //Members[memberNum].Xuid.dwUserFlags;
            Members[memberNum].Xuid = user.Puid;
            dwPartyFlags |= XPartyProfileConvertFromMemberToPartyFlags((byte)memberFlags, memberNum);
        }

        private static ushort BYTESWAP16(ushort us)
        {
            return (ushort)(((us >> 8) & 0x00FF) | ((us << 8) & 0xFF00));
        }

        private static uint BYTESWAP32(uint ui)
        {
            return (uint)(
                ((ui >> 24) & 0x000000FF) |
                ((ui >> 8) & 0x0000FF00) |
                ((ui << 8) & 0x00FF0000) |
                ((ui << 24) & 0xFF000000));
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            List<byte> value = new List<byte>();
            value.Add(bVersion);
            value.AddRange(PartyInfo.ToArray());
            value.AddRange(BitConverter.GetBytes(BYTESWAP32(dwPartyFlags)));
            value.AddRange(BitConverter.GetBytes(BYTESWAP32(dwLeaderTitleId)));
            foreach (XPARTY_PROFILE_MEMBER_INFO member in Members)
            {
                if (member != null)
                {
                    value.AddRange(member.ToArray());
                }
            }
            this.Value = value.ToArray();
            this.ValueLen = (ushort)value.Count;
            base.WriteStream(binaryWriter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\messageprot.cs ===
// 
// MessageProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Messaging Service Integration
// Xbox Online Service
// 
// Author: phansen, masonb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

using live.common;

//[assembly: XomAreaDefinition(XomAreaName.MessageProxy)]


namespace live.protocol 
{    
    //
    // Messaging definitions
    //
    public class MsgDefs
    {
        public const uint XONLINE_MAX_NUM_MESSAGES                    = 125;
        public const uint XONLINE_MAX_MESSAGE_RECIPIENTS              = 100;
        public const uint XONLINE_MAX_MESSAGE_DETAILS                 = 4096;

        //
        // Message Flags
        //
        public const uint XONLINE_MSG_FLAG_REQUIRED                   = 0x00000001; // The user is required to read this message
        public const uint XONLINE_MSG_FLAG_RECOMMENDED                = 0x00000002; // The user has a system recommended message
        public const uint XONLINE_MSG_FLAG_HAS_VOICE                  = 0x00000004; // This message contains a voice attachment
        public const uint XONLINE_MSG_FLAG_HAS_TEXT                   = 0x00000008; // This message contains a text body
        public const uint XONLINE_MSG_FLAG_READ                       = 0x00000010; // This message has been read
        public const uint XONLINE_MSG_FLAG_NON_EXPORTABLE             = 0x00000020; // This message should only be displayed on Xbox consoles, not the web
        public const uint XONLINE_MSG_FLAG_TEAM_CONTEXT               = 0x00000040; // This message's sender context refers to a team ID
        public const uint XONLINE_MSG_FLAG_COMP_CONTEXT               = 0x00000080; // This message's sender context refers to a competition event ID
        public const uint XONLINE_MSG_FLAG_ALTERNATE_TITLE            = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint XONLINE_MSG_FLAG_MARKETING                  = 0x00000200; // Used on title-wide messages to indicate the message is marketing related and opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_MS_MARKETING               = 0x00000400; // Used on title-wide messages to indicate the message is Microsoft marketing related and ms opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_HAS_PHOTO                  = 0x00000800; // This message has a photo attachment
        public const uint XONLINE_MSG_FLAG_XENON_COMPATIBLE           = 0x00001000; // This message is xenon only
        public const uint XONLINE_MSG_FLAGS_TITLE_RESERVED            = 0xFF000000; // Flags reserved for title custom messages
        public const uint XONLINE_MSG_FLAG_SENDER_IS_FRIEND           = 0x00800000; // Used by Notification to detect invites that should go to V1 clients
        public const uint XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED        = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint XONLINE_MSG_FLAG_SEND_MSG_OWNED             = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint XONLINE_MSG_FLAGS_RESERVED                  = 0x005FF000; // Flags reserved for future use
        public const uint XONLINE_MSG_FLAGS_VALID_SEND_MASK           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED | 
                                                                          XONLINE_MSG_FLAG_NON_EXPORTABLE |
                                                                          XONLINE_MSG_FLAG_REQUIRED |
                                                                          XONLINE_MSG_FLAG_RECOMMENDED |
                                                                          XONLINE_MSG_FLAG_HAS_VOICE |
                                                                          XONLINE_MSG_FLAG_HAS_TEXT |
                                                                          XONLINE_MSG_FLAG_TEAM_CONTEXT |
                                                                          XONLINE_MSG_FLAG_COMP_CONTEXT |
                                                                          XONLINE_MSG_FLAG_MARKETING |
                                                                          XONLINE_MSG_FLAG_MS_MARKETING |
                                                                          XONLINE_MSG_FLAG_HAS_PHOTO | 
                                                                          XONLINE_MSG_FLAG_XENON_COMPATIBLE); // Flags valid in a call to send a message
        public const uint XONLINE_MSG_FLAGS_TITLE_SETABLE             = ( XONLINE_MSG_FLAG_READ |
                                                                          XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to set on an already sent message
        public const uint XONLINE_MSG_FLAGS_TITLE_CLEARABLE           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to clear on an already sent message

        //
        // Message Property Types
        //
        public const byte XONLINE_MSG_PROP_TYPE_NULL                  = 1;   // The property contains no data
        public const byte XONLINE_MSG_PROP_TYPE_I1                    = 2;   // The property value points to 8-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I2                    = 3;   // The property value points to 16-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I4                    = 4;   // The property value points to 32-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I8                    = 5;   // The property value points to 64-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_STRING                = 6;   // The property value points to a NULL-terminated wide character string
        public const byte XONLINE_MSG_PROP_TYPE_FILETIME              = 7;   // The property value points to a time value
        public const byte XONLINE_MSG_PROP_TYPE_BINARY                = 8;   // The property value points to a binary blob that fits in the message details
        public const byte XONLINE_MSG_PROP_TYPE_ATTACHMENT            = 9;   // The property value points to a binary blob (or directory path, depending on attachment flags) that will be uploaded to storage during XOnlineMessageSend
        public const byte XONLINE_MSG_PROP_TYPE_BOOL                  = 10;  // The property value points to a boolean value (1=TRUE, 0=FALSE)
        public const byte XONLINE_MSG_PROP_TYPE_STRING_ID             = 11;  // The property value contains a string ID whose text can be requested from the string service

        //
        // Attachment Flags
        //
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_NON_EXPORTABLE  = 0x00000001; // This attachment should not be visible when the message is displayed on the web
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY       = 0x00000002; // The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED       = 0xFFFFFFFC; // Flags reserved for future use

        //
        // Message Property Tags
        // Property tags occupy a word where the upper byte indicates the property's data type, and 
        // the lower byte indicates a unique identifier for the property.  Property identifiers only
        // need to be unique within a given message type.
        //
        public static ushort XONLINE_MSG_PROP_TAG( byte type, byte id ) { return (ushort)( type << 8 | id ); }
        public static byte XOnlineMessageGetPropId( ushort tag )      { return (byte)( tag & 0xFF ); }
        public static byte XOnlineMessageGetPropType( ushort tag )    { return (byte)( tag >> 8 ); }

        //
        // Message Property IDs 
        // Property IDs should adhere to the following ranges:
        //
        // Range           Purpose
        // 0x00-0x7F       Reserved for use by titles
        // 0x80-0xBF       Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF       Reserved for use by Microsoft for properties that span all message types
        public const byte XONLINE_MSG_PROP_ID_BUILTIN                 = 0x80; // Used for properties defined by Microsoft
        public const byte XONLINE_MSG_PROP_ID_GLOBAL                  = 0x40; // Used for properties that can span all message types

        //
        // Message IDs
        //
        public const uint XONLINE_MSG_ID_SEND_FAILED                  = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint XONLINE_MSG_ID_SYSTEM_MESSAGE               = 0x40000000; // A message sent by the Live service or a publisher
        public const uint XONLINE_MSG_ID_TRANSIENT_MESSAGE            = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint XONLINE_MSG_ID_BASE_MASK                    = 0x00FFFFFF;
        public const uint XONLINE_MSG_ID_RESERVED_MASK                = 0x1F000000;

        public static bool IsMsgTransient( uint msgid )               { return 0 != ( msgid & XONLINE_MSG_ID_TRANSIENT_MESSAGE ); }

        //
        // Message Types
        //
        // A message type establishes the purpose of the message and the properties that 
        // are required for a message of that type.
        // NOTE: xpnconfig expects these to stay fairly sequential.
        //
        public const byte XONLINE_MSG_TYPE_TITLE_CUSTOM               = 1;  // context: title defined;    required props: title defined
        public const byte XONLINE_MSG_TYPE_FRIEND_REQUEST             = 2;  // context: 0;                required props: none
        public const byte XONLINE_MSG_TYPE_GAME_INVITE                = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte XONLINE_MSG_TYPE_TEAM_RECRUIT               = 4;  // context: inviting team ID; required props: none
        public const byte XONLINE_MSG_TYPE_COMP_REMINDER              = 5;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_EVENT_START
        public const byte XONLINE_MSG_TYPE_COMP_REQUEST               = 6;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_START, XONLINE_MSG_PROP_COMP_REG_CLOSE
        public const byte XONLINE_MSG_TYPE_LIVE_MESSAGE               = 7;  // context: 0                 required props: XONLINE_MSG_PROP_SYSTEM_TEXT
        public const byte XONLINE_MSG_TYPE_PERSONAL_MESSAGE           = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte XONLINE_MSG_TYPE_VIDEO_MESSAGE              = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte XONLINE_MSG_TYPE_QUICK_CHAT_INVITE          = 10; // context: 0
        public const byte XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE          = 11; // context: 0
        public const byte XONLINE_MSG_TYPE_PARTY_CHAT_INVITE          = 12; // context: 0

        public static bool IsNotifyMsgType( byte type )               { return ( type == XONLINE_MSG_TYPE_GAME_INVITE ); }

        //
        // Global property tags, allowed in any message type
        //
        public const ushort XONLINE_MSG_PROP_VOICE_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 2 ); 
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 3 ); 
        public const ushort XONLINE_MSG_PROP_TEXT                     = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_TEXT_LANGUAGE            = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 5 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 6 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 7 ); 
        public const ushort XONLINE_MAX_SUBJECT_SIZE                  = 20;

        //
        //Video Message Properties
        //
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_DATA         = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_CODEC        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );          //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 5 );

        //
        // Invite message properties
        //
        public const ushort XONLINE_MSG_PROP_SESSION_ID               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_SESSION_DESCRIPTION      = ( XONLINE_MSG_PROP_TYPE_STRING<< 8 )      | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_XNADDR      = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_KEY         = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Custom message properties
        //
        public const ushort XONLINE_MSG_PROP_GAME_MESSAGE             = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_PLAYER_MESSAGE           = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_ACTIONS           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_PAYLOAD           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Live system message properties
        //
        public const ushort XONLINE_MSG_PROP_SYSTEM_TEXT              = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_LINK_TO                  = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );

        //
        // Competitions message properties
        //
        public const ushort XONLINE_MSG_PROP_COMP_DATASET             = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        public const ushort XONLINE_MSG_PROP_COMP_NAME                = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x2 );
        public const ushort XONLINE_MSG_PROP_COMP_START               = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x3 );
        public const ushort XONLINE_MSG_PROP_COMP_ROUND               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x4 );
        public const ushort XONLINE_MSG_PROP_COMP_OPPONENT            = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x5 );
        public const ushort XONLINE_MSG_PROP_COMP_ADMIN               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x6 );
        public const ushort XONLINE_MSG_PROP_COMP_REG_CLOSE           = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x7 );
        public const ushort XONLINE_MSG_PROP_COMP_PRIVATE_SLOTS       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x8 );
        public const ushort XONLINE_MSG_PROP_COMP_PUBLIC_SLOTS        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x9 );
        public const ushort XONLINE_MSG_PROP_COMP_UNITS               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xA );
        public const ushort XONLINE_MSG_PROP_COMP_INTERVAL            = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xB );
        public const ushort XONLINE_MSG_PROP_COMP_DAYMASK             = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xC );
        public const ushort XONLINE_MSG_PROP_COMP_DESCRIPTION         = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xD );
        public const ushort XONLINE_MSG_PROP_COMP_URL                 = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xE );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_ID            = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x10 );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_START         = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x11 );
        //
        // Client Types
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE may use the qwSenderContext
        //  to specify specific clients that should suppress the message 
        //  or refer the user to xbox.com to consume the message
        //
        public const byte XONLINE_MSG_CLIENT_XBOXCOM                  = 0x0000000000000001;
        public const byte XONLINE_MSG_CLIENT_XBOX360                  = 0x0000000000000002;
        public const byte XONLINE_MSG_CLIENT_ZUNE                     = 0x0000000000000004;
        public const byte XONLINE_MSG_CLIENT_PANORAMA                 = 0x0000000000000008;

        //
        // LinkTo Destinations
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE has an optional property
        //  to specify a link to an abstract platform client destination that will allow
        //  the user to take action on the message. 
        //
        public const byte XONLINE_MSG_LINKTO_ACCOUNT_MANAGEMENT       = 0x00000001;

        //
        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_WMAVOICE_V90      = 1;
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_SASE3200          = 2;

        //
        // Photo Encoding types (values for XONLINE_MSG_PROP_PHOTO_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_PHOTO_DATA_CODEC_PNG      = 1;
        
        //
        //Personal Message Properties
        //None beyond the text and voice stuff above:
        //
         
        //
        //Quick Chat Invite Properties.
        //
        public const ushort XONLINE_HUD_MSG_PROP_VOICECHAT_PORT       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )           | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        
         
        //
        // Definitions that are internal only, in MSINTERNAL sections of xonline.x
        //

        public const uint XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN         = 64;

        // Valid values that can be passed in the dwFlags member of DeleteMessageMsg
        public const uint XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER       = 0x00000001;

        // Valid values that can be found in the dwFlags member of UserTitleData
        public const uint XMSG_USER_TITLE_FLAG_ACCEPT_MARKETING       = 0x00000001;

        // Valid values that can be passed in the dwFlags member of DeleteSystemMessageMsg
        public const uint XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL  = 0x00000001;

        // Utility functions for converting message time values
        public static DateTime MsgTimeToDateTime( uint mt )
        {
            return DateTime.FromFileTimeUtc( (long)( ( (ulong) mt * 10000000 ) + 0x01C2B128BA2B4000 ) );
        }
        public static uint DateTimeToMsgTime( DateTime dt )
        {
            return (uint)( ( dt.ToFileTimeUtc() - 0x01C2B128BA2B4000 ) / 10000000 );
        }

        // RevokeMessageEx flags
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER    = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID          = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER      = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT     = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP        = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE        = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED       = 0xFFFFFFC0;
        
    }; // end definitions


    public class MessagingXrlObject : XRLRequestObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xmessaging.srf";
            }
        }
    }
    //
    // Structure Representing a single message property. 
    //  Maps to XMSG_PROPERTY in xonline.x
    //  
    public class MessageProperty : WireData
    {
        public ushort           wPropTag;           // This property's unique identifier

        // The following 3 fields are part of the unnamed union
        //  in _XMSG_PROPERTY
        public ushort           wPropOffset;        // The offset from the start of rgbData of this property's data
        // public ushort        wData;              // For type XONLINE_MSG_PROP_TYPE_I2 this contains the actual data
        // public byte          bData;              // For type XONLINE_MSG_PROP_TYPE_I1 and XONLINE_MSG_PROP_TYPE_BOOL this contains the actual data

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wPropTag);
            binaryWriter.Write(wPropOffset);
        }
    };

    
    //
    // Structure Representing the entire message details. 
    //  Maps to XMSG_DETAILS in xonline.x
    //  
    public class MessageDetails : WireData
    {
        public ushort           wPropCount;
        public ushort           cbData;
              
        [WireInfo(SizeParam="wPropCount")]
        public MessageProperty[]  rgProperties;     // Property descriptors
        
        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data

        public override int Size()
        {
            // pDetails->cbData + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) )
            return cbData + 4 + ( wPropCount * 4 );
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the array sizes
            wPropCount = rgProperties == null ? (ushort)0 : (ushort)rgProperties.Length;
            cbData = rgbData == null ? (ushort)0 : (ushort)rgbData.Length;

            binaryWriter.Write(wPropCount);
            binaryWriter.Write(cbData);
            for (int i = 0; i < wPropCount; ++i)
            {
                rgProperties[i].WriteStream(binaryWriter);
            }
            if (rgbData != null)
            {
                binaryWriter.Write(rgbData);
            }
        }
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_BINARY in xonline.x
    //  
    public class MessageBinaryProperty : WireData
    {
        public ushort           cbData;

        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_STRING in xonline.x
    //  
    public class MessageStringProperty : WireData
    {
        public ushort           cbString;

        [WireInfo(SizeParam="cbString", NullTerminate=true)]
        public string           szString;           // Property data
    };


    //
    // Structure Representing an attachment property. 
    //  Maps to XMSG_PROPERTY_ATTACHMENT in xonline.x
    //  
    public class MessageAttachmentProperty : WireData
    {
        public uint             cbAttach;
        public uint             dwAttachFlags;
        public uint             cbAttachUrl;
        
        [WireInfo(SizeParam="cbAttachUrl", NullTerminate=true)]
        public string           szAttachUrl;     
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY in xonline.x
    //  
    public class MessageSummary : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52;
        }
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY_2 in xonline.x
    //  
    public class MessageSummary2 : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2)]
        public byte[]           rgbSubject;

        public string szSubject
        {
            get
            {
                int iMaxIndex = 0;
                for (int i = 0; i < rgbSubject.Length; i += 2)
                {
                    if (rgbSubject[i] == 0 && rgbSubject[i+1] == 0)
                    {
                        iMaxIndex = i;
                        break;
                    }
                }

                return new System.Text.UnicodeEncoding().GetString(rgbSubject, 0, iMaxIndex);
            }

            set
            { 
                string szText = value;
                if (szText.Length >= MsgDefs.XONLINE_MAX_SUBJECT_SIZE)
                {
                    szText = szText.Substring(0, MsgDefs.XONLINE_MAX_SUBJECT_SIZE - 1);
                }

                byte[] rgbData = (new System.Text.UnicodeEncoding()).GetBytes(szText);

                rgbSubject = new byte[MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2];
                for (int i = 0; i < rgbSubject.Length; i++)
                {
                    if (i < rgbData.Length)
                    {
                        rgbSubject[i] = rgbData[i];
                    }
                    else
                    {
                        rgbSubject[i] = 0;
                    }
                }
            }
        }

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52 + (MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2);
        }
    };


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_MSG in xonline.x
    //  
    public class EnumerateMessagesMsg : MessagingXrlObject
    {
        public EnumerateMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateMessagesReply : XRLObject2
    {
        public EnumerateMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_MESSAGE_SUMMARY )
            return 38 + ( cMessages * MessageSummary.StaticSize() );
        }        
    }


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_2_MSG in xonline.x
    //  
    public class EnumerateMessages2Msg : MessagingXrlObject
    {
        public EnumerateMessages2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateMessages2Reply : XRLObject2
    {
        public EnumerateMessages2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary2[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_REPLY_MSG ) + cMessages * sizeof( Q_ENUM_MESSAGE_2_REPLY )
            return 38 + ( cMessages * MessageSummary2.StaticSize() );
        }        
    }


    //
    // Structure Representing the reply for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_MSG in xonline.x
    //  
    public class MessageSummaryMsg : XRLObject2
    {
        public MessageSummaryMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in xonline.x
    //  
    public class MessageSummaryReply : XRLObject2
    {
        public MessageSummaryReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );
            if( HResult.Succeeded( hr ) )
            {
                summary = new MessageSummary();
                summary.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            ushort cbSummary = 0;
            if( HResult.Succeeded( hr ) )
            {
                cbSummary = (ushort) MessageSummary.StaticSize();
            }

            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY )
            return 36 + cbSummary;
        }        
    };


    //
    // Structure Representing the reply for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_2_MSG in xonline.x
    //  
    public class MessageSummary2Msg : XRLObject2
    {
        public MessageSummary2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_2_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in xonline.x
    //  
    public class MessageSummary2Reply : XRLObject2
    {
        public MessageSummary2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        [WireInfo(Serialize=false)]
        public MessageSummary2  summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );
            if( HResult.Succeeded( hr ) )
            {
                summary = new MessageSummary2();
                summary.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            ushort cbSummary = 0;
            if( HResult.Succeeded( hr ) )
            {
                cbSummary = (ushort) MessageSummary2.StaticSize();
            }

            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_2_MSG ) + sizeof( Q_MESSAGE_SUMMARY_2 )
            return 36 + cbSummary;
        }        
    };


    //
    // Structure Representing a request for the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_MSG in xonline.x
    //  
    public class MessageDetailsMsg : MessagingXrlObject
    {
        public MessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_DETAILS_MSG )
            return 52;
        }
    };

    //
    // Structure Representing the reply or the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_REPLY_MSG in xonline.x
    //  
    public class MessageDetailsReply : XRLObject2
    {
        public MessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( HResult.Succeeded( hr ) )
            {
                summary = new MessageSummary();
                summary.ReadStream( binaryReader );

                if( 0 != summary.cbDetails )
                {
                    details = new MessageDetails();
                    details.ReadStream( binaryReader );
                }
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );

                if( 0 != summary.cbDetails )
                {
                    details.WriteStream( binaryWriter );
                }
            }
        }

        public override int Size()
        {
            ushort cbSummary = 0;
            ushort cbDetails = 0;
            if( HResult.Succeeded( hr ) )
            {
                cbSummary = (ushort) MessageSummary.StaticSize();
                cbDetails = summary.cbDetails;
            }

            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY ) + cbDetails
            return 36 + cbSummary + cbDetails;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_MESSAGE_MSG in xonline.x
    //  
    public class DeleteMessageMsg : XRLObject2
    {
        public DeleteMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_MSG )
            return 48;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class DeleteMessageReply : XRLObject2
    {
        public DeleteMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing the result of a message send to a specific PUID
    //  maps to Q_RECIPIENT_RESULT in xonline.x
    //  
    public class RecipientResult: WireData
    {
        public ulong            qwUserID;
        public uint             dwMessageID; // If the send failed, this is the error code, if it succeeded this is the message ID

        public static int StaticSize()
        {
            // sizeof( Q_RECIPIENT_RESULT )
            return 12;
        }        
    };  


    //
    // Structure Representing a request to send a message in the messaging service
    //  maps to Q_SEND_MESSAGE_MSG in xonline.x
    //  
    public class SendMessageMsg: XRLObject2
    {
        public SendMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public ushort           cRecipients;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(SizeParam="cRecipients")]
        public ulong []         qwRecipientIDs;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_MSG ) + ( cRecipients * sizeof( ULONGLONG ) ) + cbDetails
            return 78 + ( cRecipients * 8 ) + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendMessage response message
    //  maps to Q_SEND_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class SendMessageReply: XRLObject2
    {   
        public SendMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public ushort           cRecipients;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult [] recipients;            

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_REPLY_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 38 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    }    


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_MSG in xonline.x
    //  
    public class RevokeMessageMsg : XRLObject2
    {
        public RevokeMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public ushort           cRecipients;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 51 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    };


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_EX_MSG in xonline.x
    //  
    public class RevokeMessageExMsg : XRLObject2
    {
        public RevokeMessageExMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwFlags;
        public ushort           wPropTag;
        public ushort           cRecipients;
        public ushort           cbProp;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        [WireInfo(SizeParam="cbProp")]
        public byte[]           rgbProp;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_EX_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT ) + cbProp
            return 59 + ( cRecipients * RecipientResult.StaticSize() ) + cbProp;
        }        
    };


    //
    // Structure Representing the reply to a RevokeMessage message
    //  maps to Q_REVOKE_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class RevokeMessageReply : XRLObject2
    {
        public RevokeMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_TITLE_MSG in xonline.x
    //  
    public class DeleteTitleMsg : XRLObject2
    {
        public DeleteTitleMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;    

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_TITLE_REPLY_MSG in xonline.x
    //  
    public class DeleteTitleReply : XRLObject2
    {
        public DeleteTitleReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to enumerate titles for a user
    //  maps to Q_ENUM_TITLES_MSG in xonline.x
    //  
    public class EnumerateTitlesMsg : XRLObject2
    {
        public EnumerateTitlesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_MSG )
            return 40;
        }        
    };

    //
    // Structure Representing a user-owned title
    //  maps to Q_USER_TITLE in xonline.x
    //  
    public class UserTitleData : WireData
    {
        public uint             dwTitleID;
        public DateTime         dtLastLogon;
        public uint             dwFlags;

        public static int StaticSize()
        {
            // sizeof( Q_USER_TITLE )
            return 16;
        }   
    };

    //
    // Structure Representing the reply to an EnumerateTitles message
    //  maps to Q_ENUM_TITLES_REPLY_MSG in xonline.x
    //  
    public class EnumerateTitlesReply : XRLObject2
    {
        public EnumerateTitlesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public ushort           cTitles;    
    
        [WireInfo(SizeParam="cTitles")]
        public UserTitleData[]  rgTitles;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_REPLY_MSG ) + cTitles * sizeof( Q_USER_TITLE )
            return 38 + ( cTitles + UserTitleData.StaticSize() );
        }   
    };


    //
    // Structure Representing a request to set/unset flags on a particular message
    //  maps to Q_MESSAGE_FLAGS_MSG in xonline.x
    //  
    public class MessageFlagsMsg : XRLObject2
    {
        public MessageFlagsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_MSG )
            return 52;
        }   
    };

    //
    // Structure Representing the reply to a MessageFlags message
    //  maps to Q_MESSAGE_FLAGS_REPLY_MSG in xonline.x
    //  
    public class MessageFlagsReply : XRLObject2
    {
        public MessageFlagsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing summary system message data
    //  maps to Q_SYSTEM_MESSAGE_SUMMARY in xonline.x
    //  
    public class SystemMessageSummary : WireData
    {
        public uint             dwTitleID;

        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        public static int StaticSize()
        {
            // sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 116;
        }   
    };


    //
    // Structure Representing a request to enumerate system messages on behalf of a title
    //  maps to Q_ENUM_SYSTEM_MESSAGES_MSG in xonline.x
    //  
    public class EnumerateSystemMessagesMsg : XRLObject2
    {
        public EnumerateSystemMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_MSG )
            return 36;
        }   
    }

    //
    // Structure Representing the reply to an EnumerateSystemMessages message
    //  maps to Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateSystemMessagesReply : XRLObject2
    {
        public EnumerateSystemMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public SystemMessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 38 + ( cMessages * SystemMessageSummary.StaticSize() );
        }   
    }


    //
    // Structure Representing a request for the message details of a system message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_MSG in xonline.x
    //  
    public class SystemMessageDetailsMsg : XRLObject2
    {
        public SystemMessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SYSTEM_MESSAGE_DETAILS_MSG )
            return 40;
        }   
    };

    //
    // Structure Representing the reply to a SystemMessageDetails message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG in xonline.x
    //  
    public class SystemMessageDetailsReply : XRLObject2
    {
        public SystemMessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public SystemMessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override int Size()
        {
            // sizeof( part of Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ) + sizeof( Q_SYSTEM_MESSAGE_SUMMARY ) + cbDetails
            return 36 + SystemMessageSummary.StaticSize() + summary.cbDetails;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != summary.cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != summary.cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };


    // 
    // Structure Representing a request to delete a particular system message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_MSG in xonline.x
    //  
    public class DeleteSystemMessageMsg : XRLObject2
    {
        public DeleteSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_MSG )
            return 44;
        }   
    };

    //
    // Structure Representing the reply to a DeleteSystemMessage message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class DeleteSystemMessageReply : XRLObject2
    {
        public DeleteSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing a request to send a system message in the messaging service
    //  maps to Q_SEND_SYSTEM_MESSAGE_MSG in xonline.x
    //  
    public class SendSystemMessageMsg: XRLObject2
    {
        public SendSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ) + cbDetails
            return 144 + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendSystemMessage response message
    //  maps to Q_SEND_SYSTEM_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class SendSystemMessageReply: XRLObject2
    {   
        public SendSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public uint             hr;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG )
            return 40;
        }   
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\ListsProtocol.cs ===
using System;
using System.Net;
using System.Text;
using System.Collections.Generic;
using System.Reflection;

using live.common;
using live.common.next;
using live.client;

namespace live.protocol
{
    public class ListInfo : WireData
    {
        public int listType;
        public int listId;
        public DateTime lastModified;
        public int totalItems;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;
    }


    public class ListItem : WireData
    {
        public Guid itemId;
        public short priority;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemMod : WireData
    {
        public Guid itemId;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemIndex : WireData
    {
        public Guid itemId;
        public short priority;
        public int index;
    }
        
    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "CreateList", 
                   "urn:schemas-xbox-com:lists-data")]
    public class CreateListRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;
        
        [PayloadParam]
        public int listType;
        
        public byte nameLength;
        
        public ushort xmlLength;
        
        [PayloadParam]
        [WireInfo(SizeParam = "nameLength")]
        public string name;
        
        [PayloadParam]
        [WireInfo(SizeParam = "xmlLength")]
        public string xmlProperties;        

        public override string Xrl
        {
            get
            {
                return "/Lists/CreateList.ashx";
            }
        }
    }


    [PayloadResponse("urn:schemas-xbox-com:lists-data", "CreateListResult")]
    public class CreateListResponse : PayloadResponse
    {
        [PayloadParam]
        public int listId = Int32.MinValue;

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "DeleteList", 
                   "urn:schemas-xbox-com:lists-data")]    
    public class DeleteListRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteList.ashx";
            }
        }   
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "DeleteListResult")]
    public class DeleteListResponse : PayloadResponse
    {
        [PayloadParam]
        [WireInfo(Serialize = false)]
        public uint status = HResult.S_OK;
    }

    
    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "ModifyList", 
                   "urn:schemas-xbox-com:lists-data")]    
    public class ModifyListRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;
        
        [PayloadParam]
        public DateTime lastModified;

        public ushort xmlLength;

        [PayloadParam]
        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyList.ashx";
            }
        }   
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "ModifyListResult")]
    public class ModifyListResponse : PayloadResponse
    {

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "QueryLists", 
                   "urn:schemas-xbox-com:lists-data")]
    public class QueryListsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public DateTime lastModified;

        [PayloadParam]
        public int pageSize;

        [PayloadParam]
        public int pageNum;

        [PayloadParam]
        public int orderDir;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryLists.ashx";
            }
        }            

    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "QueryListsResult")]
    public class QueryListsResponse : PayloadResponse
    {
        
        [PayloadParam]
        public ushort totalLists = 0;

        public ushort numLists = 0;

        [PayloadParam]
        [WireInfo( SizeParam = "numLists" )]
        public ListInfo[] resultLists = null;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "GrantListAccess", 
                   "urn:schemas-xbox-com:lists-data")]
    public class GrantListAccessRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/Lists/GrantListAccess.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", 
                     "GrantListAccessResult")]
    public class GrantListAccessResponse : PayloadResponse    
    {
        [PayloadParam]
        [WireInfo(Serialize = false)]
        public uint status = HResult.S_OK;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "RevokeListAccess", 
                   "urn:schemas-xbox-com:lists-data")]
    public class RevokeListAccessRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/Lists/RevokeListAccess.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", 
                     "RevokeListAccessResult")]
    public class RevokeListAccessResponse : PayloadResponse    
    {
        [PayloadParam]
        [WireInfo(Serialize = false)]
        public uint status = HResult.S_OK;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "InsertItems", 
                   "urn:schemas-xbox-com:lists-data")]
    public class InsertItemsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public DateTime lastModified;

        public ushort numItems;

        [PayloadParam]
        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/InsertItems.ashx";
            }
        }
    }

    
    [PayloadResponse("urn:schemas-xbox-com:lists-data", "InsertItemsResult")]
    public class InsertItemsResponse : PayloadResponse    
    {

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "DeleteItems", 
                   "urn:schemas-xbox-com:lists-data")]
    public class DeleteItemsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;
        
        [PayloadParam]
        public DateTime lastModified;

        public ushort numIds;

        [PayloadParam]
        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteItems.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "DeleteItemsResult")]
    public class DeleteItemsResponse : PayloadResponse
    {

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "ModifyItems", 
                   "urn:schemas-xbox-com:lists-data")]
    public class ModifyItemsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;
        
        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;
        
        [PayloadParam]
        public DateTime lastModified;

        public ushort numItems;

        [PayloadParam]
        [WireInfo( SizeParam = "numItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyItems.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "ModifyItemsResult")]
    public class ModifyItemsResponse : PayloadResponse
    {

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "QueryItems", 
                   "urn:schemas-xbox-com:lists-data")]
    public class QueryItemsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public int pageSize;

        [PayloadParam]
        public int pageNum;
        
        [PayloadParam]
        public int orderDir;

        [PayloadParam]
        public ushort numIds;

        [PayloadParam]
        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryItems.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "QueryItemsResult")]
    public class QueryItemsResponse : PayloadResponse
    {

        [PayloadParam]
        public ushort totalItems = 0;

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;

        public ushort numItems = 0;

        [PayloadParam]
        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] resultItems = null;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.Soap12)]
    [PayloadAction("/Lists/Lists.asmx", "MoveItems", 
                   "urn:schemas-xbox-com:lists-data")]
    public class MoveItemsRequest : PayloadRequest
    {
        [PayloadParam]
        public ulong userPuid;
        
        [PayloadParam]
        public int listType;

        [PayloadParam]
        public int listId;

        [PayloadParam]
        public DateTime lastModified;

        public ushort numIndices;

        [PayloadParam]
        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get
            {
                return "/Lists/MoveItems.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:lists-data", "MoveItemsResult")]
    public class MoveItemsResponse : PayloadResponse
    {

        [PayloadParam]
        public DateTime lastModified = DateTime.MinValue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\PayloadResponse.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using System.Reflection;
using live.common;

namespace live.protocol
{

    public enum PayloadParamType
    {
        StandAlone,
        NameValuePair
    }

    public class PayloadResponseAttribute : Attribute
    {
        private bool _inDevelopment;

        public bool InDevelopment
        {
            get { return _inDevelopment; }
            set { _inDevelopment = value; }
        }

        public string XRoot;
        public string XmlNamespace;


        public PayloadResponseAttribute(string xmlNamespace, string xRoot)
        {
            XmlNamespace = xmlNamespace;
            XRoot = xRoot;
        }
    }


    public class PayloadParamAttribute : Attribute
    {
        public string XPath = "";
        public PayloadParamType ParamType = PayloadParamType.StandAlone;

        public PayloadParamAttribute() { }

        public PayloadParamAttribute(string xPath)
        {
            XPath = xPath;
        }
    }


    public abstract class PayloadResponse : XRLObject2
    {
        private PayloadType _payloadType = PayloadType.Binary;
        private static Dictionary<String, XmlSerializer> _serializers = new Dictionary<string, XmlSerializer>();
        private static Dictionary<String, PayloadParamAttribute> _payloadParams = new Dictionary<string, PayloadParamAttribute>();
        private static Dictionary<Type, PayloadResponseAttribute> _payloadResponses = new Dictionary<Type, PayloadResponseAttribute>();

        public void SetPayloadType(PayloadType type)
        {
            _payloadType = type;
        }


        private static PayloadParamAttribute GetPayloadParam(PayloadResponse req, MemberInfo minfo)
        {
            string key = req.GetType() + "::" + minfo.Name;
            PayloadParamAttribute param;

            lock (_payloadParams)
            {

                if (!_payloadParams.TryGetValue(key, out param))
                {
                    object[] attrs = minfo.GetCustomAttributes(typeof(PayloadParamAttribute), true);
                    if (attrs.Length > 0)
                    {
                        param = attrs[0] as PayloadParamAttribute;
                    }
                    else
                    {
                        param = null;
                    }
                    _payloadParams.Add(key, param);               
                }
            }
            return param;
        }

        private static PayloadResponseAttribute GetPayloadResponse(PayloadResponse req)
        {
            Type key = req.GetType();
            PayloadResponseAttribute param;

            lock (_payloadResponses)
            {
                if (!_payloadResponses.TryGetValue(key, out param))
                {
                    object[] attrs = key.GetCustomAttributes(typeof(PayloadResponseAttribute), true);
                    if (attrs.Length > 0)
                    {
                        param = attrs[0] as PayloadResponseAttribute;
                    }
                    else
                    {
                        param = null;
                    }
                    _payloadResponses.Add(key, param);
                }
            }
            
            return param;
        }


        public void ReadXmlFromRequest(string response)
        {
            XmlDocument xmlDoc = new XmlDocument();
            try
            {
                xmlDoc.LoadXml(response);
            }
            catch (XmlException xe)
            {
                throw new XmlException(string.Format("Could not parse the following as xml:\n\t\t\t{0}", response), xe);
            }

            Type thisType = this.GetType();
            PayloadResponseAttribute respAttr = GetPayloadResponse(this);
            if (respAttr == null)
            {
                throw new NotSupportedException("This class needs PayloadResponseAttribute");
            }


            XmlNamespaceManager nsMgr = new XmlNamespaceManager(xmlDoc.NameTable);
            nsMgr.AddNamespace("prefix", respAttr.XmlNamespace);

            XmlNode xmlRoot = xmlDoc.SelectSingleNode("descendant::prefix:" + respAttr.XRoot, nsMgr);

            if (xmlRoot == null)
            {
                xmlRoot = xmlDoc.SelectSingleNode("descendant::HResult", nsMgr);
                if (xmlRoot == null)
                {
                    throw new XmlException(string.Format("Could not Find RootNode {0} in:\n{1}", respAttr.XRoot, response));
                }
                else
                {
                    uint hr;
                    if (uint.TryParse(xmlRoot.InnerXml.Replace("0x", ""), System.Globalization.NumberStyles.HexNumber, null, out hr))
                    {
                        Throw.IfXErrFailed(hr);
                    }
                    else
                    {
                        throw new XmlException(string.Format("Could not Parse error on:\n{0}", response));
                    }

                }
            }

            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo fieldInfo in fieldInfos)
            {
                // Get the WebResponseParamAttribute (if any)
                PayloadParamAttribute respParam = GetPayloadParam(this, fieldInfo);
                if (respParam == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }

                string xpath = GetXpath(respParam, fieldInfo.Name);

                XmlNode targetNode = (xpath == "/") ? xmlRoot : xmlRoot.SelectSingleNode(xpath, nsMgr);
                if (targetNode == null && !respAttr.InDevelopment)
                {
                    //No results returned continue if not working out the attributes.
                    continue;
                }
                //object val = Convert.ChangeType(targetNode.InnerText, fieldInfo.FieldType);
                object val = DeserializeType(fieldInfo.FieldType, targetNode, respAttr.XmlNamespace);
                fieldInfo.SetValue(this, val);
            }

            System.Reflection.PropertyInfo[] propInfos = thisType.GetProperties(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
            );

            foreach (System.Reflection.PropertyInfo propInfo in propInfos)
            {
                // Get the WebResponseParamAttribute (if any)
                PayloadParamAttribute respParam = GetPayloadParam(this, propInfo);
                if (respParam == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }

                string xpath = GetXpath(respParam, propInfo.Name);

                XmlNode targetNode = (xpath == "/") ? xmlRoot : xmlRoot.SelectSingleNode(xpath, nsMgr);
                if (targetNode == null && !respAttr.InDevelopment)
                {
                    //No results returned continue if not working out the attributes.
                    continue;
                }

                object val = DeserializeType(propInfo.PropertyType, targetNode, respAttr.XmlNamespace);
                propInfo.SetValue(this, val, null);
            }
        }

        private static string GetXpath(PayloadParamAttribute respParam, String name)
        {
            if (String.IsNullOrEmpty(respParam.XPath))
            {
                respParam.XPath = name;
            }

            string xpath = respParam.XPath.Replace("/", "/prefix:");
            if (!xpath.StartsWith("/"))
            {
                xpath = "prefix:" + xpath;
            }
            if (xpath.EndsWith("/prefix:"))
            {
                xpath = xpath.Remove(xpath.Length - 7);
            }
            return xpath;
        }

        private static XmlSerializer GetSerializer(Type type, string name, string nameSpace)
        {
            string key = type.FullName + "::" + name + "::" + nameSpace;
            XmlSerializer serializer;

            lock (_serializers)
            {
                if (!_serializers.TryGetValue(key, out serializer))
                {
                    XmlReflectionImporter xri = new XmlReflectionImporter();
                    XmlTypeMapping map = xri.ImportTypeMapping(type, new XmlRootAttribute(name), nameSpace);
                    serializer = new XmlSerializer(map);
                    _serializers.Add(key, serializer);
                }
            }
            return serializer;
        }


        private object DeserializeType(Type type, XmlNode node, string ns)
        {
            object value;


            if (type.IsValueType)
            {
                value = Convert.ChangeType(node.InnerText, type);
            }
            else if (type == typeof(string))
            {
                value = node.InnerText;
            }
            else if (type.IsEnum)
            {
                value = Enum.Parse(type, node.InnerText);
            }
            else if (type.GetInterface("IConvertible") != null)
            {
                value = Convert.ChangeType(node.InnerText, type);
            }
            else
            {
                String xml = node.OuterXml;
                XmlSerializer serializer = GetSerializer(type, node.LocalName, ns);
                value = serializer.Deserialize(new StringReader(xml));
            }

            return value;
        }


        public override void ReadFromRequest(System.IO.BinaryReader reader, UTF8Encoding enc, long len, System.Collections.Specialized.NameValueCollection queryString)
        {

            switch (_payloadType)
            {
                case PayloadType.Binary:
                    base.ReadFromRequest(reader, enc, len, queryString);
                    break;
                case PayloadType.Soap12:
                case PayloadType.HttpPOST:
                    byte[] resp = reader.ReadBytes((int)len);
                    string response = enc.GetString(resp);
                    ReadXmlFromRequest(response);
                    break;
                default:
                    throw new Exception("Can not covert payload of type " + _payloadType);
            }

        }


        #region XRLObject2WithFlags functions
        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort)(value | flag);
            else
                value = (ushort)(value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\matchprot.cs ===
//
// MatchProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Service Integration
// Xbox Online Service
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Net;

using live.common;

//[assembly: XomAreaDefinition(XomAreaName.MatchProxy)]

namespace live.protocol 
{
    //
    // Matchmaking definitions
    //
    public class MatchDefs
    {
        // this http header is used by stress to direct the match front door at a presence
        // emulator instead of the presence vip.
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";

        public const uint X_MAX_STRING_ATTRIBUTE_LEN                  = 400;
        public const uint X_MAX_BLOB_ATTRIBUTE_LEN                    = 800;

        public const uint X_ATTRIBUTE_SCOPE_MASK                      = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_GLOBAL                    = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC            = 0x00000000;

        // These are the datatypes that were supported in Xbox 1 matchmaking.
        // In Xenon, the match Attributes sent on the wire are actually Xenon
        // Properties and Contexts. Xenon Property and Context ids use the 
        // X_ATTRIBUTE_XENON_DATATYPE_XXX definitions in the next section, not
        // these definitions.
        //
        // We've chosen to extend this Xbox 1 wiredata object instead of
        // creating a similar but new wiredata object for Xenon. To retain
        // compatibility with both Xbox and Xenon clients, Xenon clients
        // will encode the integer, float, datetime, and context attributes as
        // X_ATTRIBUTE_DATATYPE_INTEGER, and use 64 bits on the wire for
        // all of them. The Xenon client will flag String properties with
        // X_ATTRIBUTE_DATATYPE_STRING before putting them on the wire, so
        // they are processed correctly by these wiredata classes.
        // X_ATTRIBUTE_DATATYPE_BLOB properties are not supported in Xenon.
        //
        // The attribute and parameter names in the generated sql code for Xenon
        // titles will not have this xbox 1 "match" datatype information, so the
        // names in the database match the ids in the xlast file. Therefore the front
        // door will mask out these bits before generating attribute or parameter names
        // for xenon titles.
        public const uint X_ATTRIBUTE_DATATYPE_MASK                   = 0x00F00000;
        public const uint X_ATTRIBUTE_DATATYPE_INTEGER                = 0x00000000;
        public const uint X_ATTRIBUTE_DATATYPE_STRING                 = 0x00100000;
        public const uint X_ATTRIBUTE_DATATYPE_BLOB                   = 0x00200000;
        public const uint X_ATTRIBUTE_DATATYPE_NULL                   = 0x00F00000;

        // see comment above on the usage of these datatypes by xenon titles
        public const uint X_ATTRIBUTE_XENON_DATATYPE_MASK                = 0x70000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_CONTEXT             = 0x00000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT32              = 0x10000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT64              = 0x20000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT64             = 0x30000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UNICODE             = 0x40000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT32             = 0x50000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_BINARY              = 0x60000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_DATETIME            = 0x70000000;

        public const uint X_ATTRIBUTE_ID_MASK                         = 0x0000FFFF;

        // These are not used in the wire protocol. They were defined for use
        // by xmltosql, and are now deprecated.
        public const uint X_ATTRIBUTE_TYPE_MASK                       = 0x0F000000;
        public const uint X_ATTRIBUTE_TYPE_SESSION                    = 0x00000000;
        public const uint X_ATTRIBUTE_TYPE_PARAM                      = 0x02000000;
        public const uint X_ATTRIBUTE_TYPE_BUILTIN                    = 0x03000000;
        public const uint X_ATTRIBUTE_TYPE_CONSTANT                   = 0x05000000;

        public const uint X_ATTRIBUTE_RESERVED                        = ~( X_ATTRIBUTE_SCOPE_MASK       |
                                                                           X_ATTRIBUTE_DATATYPE_MASK    |
                                                                           X_ATTRIBUTE_XENON_DATATYPE_MASK |
                                                                           X_ATTRIBUTE_TYPE_MASK        |
                                                                           X_ATTRIBUTE_ID_MASK );
        // Xbox 1 global attributes
        public const uint X_ATTRIBUTE_XBOX1_SESSION_ID = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000001;
        public const uint X_ATTRIBUTE_XBOX1_PUB_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000002;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000003;
        public const uint X_ATTRIBUTE_XBOX1_PUB_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000004;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000005;
        public const uint X_ATTRIBUTE_XBOX1_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000006;
        public const uint X_ATTRIBUTE_XBOX1_APPROX_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000007;
        public const uint X_ATTRIBUTE_XBOX1_NUM_ATTRS = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000011;
        public const uint X_ATTRIBUTE_XBOX1_HOST_ADDR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000012;
        public const uint X_ATTRIBUTE_XBOX1_SESSION_KEY = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000013;

        //
        // These are special, system defined attributes ids used for non-title
        // specific contexts and properties, and/or special query parameters
        //
        // All of these ids contain this flag, so they will not conflict with
        // title defined contexts and properties generated by xlast.
        //
        // These are also used by the 360 console.
        //
        public const uint X_ATTRIBUTE_SYSTEM_FLAG = 0x00008000;

        //
        // Game type context is either ranked or standard
        //
        public const uint X_ATTRIBUTE_GAME_TYPE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        //
        // Game mode context is defined by the game
        //
        public const uint X_ATTRIBUTE_GAME_MODE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;


        //
        // The attribute id used to pass the session id to the system FindById stored proc
        //
        public const uint X_ATTRIBUTE_SESSION_ID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x3;

        //
        // Imported from client tree:
        //
        // Several XLAST files have these defines, and XLAST's gameconfig.h defines
        // them.  They seem to be unused now but the should not be reused lest we
        // risk breaking existing titles.
        //
        public const uint X_ATTRIBUTE_MAX_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x4;
        public const uint X_ATTRIBUTE_MAX_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x5;
        public const uint X_ATTRIBUTE_OPEN_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x6;
        public const uint X_ATTRIBUTE_OPEN_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x7;
        public const uint X_ATTRIBUTE_FILLED_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x8;
        public const uint X_ATTRIBUTE_FILLED_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x9;

        //
        // Client properties used to write to skill leaderboards 
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_RELATIVE_SCORE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        public const uint X_ATTRIBUTE_SESSION_TEAM = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;

 

        //
        // Client properties written at the session level to override TrueSkill parameters
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_PLAYER_PARTIAL_PLAY_PERCENTAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xC;
        public const uint X_ATTRIBUTE_PLAYER_SKILL_UPDATE_WEIGHTING_FACTOR = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xD;
        public const uint X_ATTRIBUTE_SESSION_SKILL_BETA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xE;
        public const uint X_ATTRIBUTE_SESSION_SKILL_TAU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xF;
        public const uint X_ATTRIBUTE_SESSION_SKILL_DRAW_PROBABILITY =  X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10;

        //
        // Attachment size is written to a leaderboard when the entry qualifies for
        // a gamerclip.  The rating can be retrieved via XUserEstimateRankForRating.
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_ATTACHMENT_SIZE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x11;

        //
        // Attribute passed as parameter to session findbyid list
        //
        public const uint X_ATTRIBUTE_SESSION_ID_LIST = X_ATTRIBUTE_XENON_DATATYPE_BINARY
                                                 | X_ATTRIBUTE_DATATYPE_BLOB
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x12;

        // 
        // Gamer properties
        //
        public const uint X_ATTRIBUTE_GAMER_ZONE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x101;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x102;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x103;
        public const uint X_ATTRIBUTE_GAMER_RATING = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x104;
        public const uint X_ATTRIBUTE_GAMER_MU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x105;
        public const uint X_ATTRIBUTE_GAMER_SIGMA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x106;
        public const uint X_ATTRIBUTE_GAMER_PUID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x107;
        public const uint X_ATTRIBUTE_AFFILIATE_VALUE = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x108;
        public const uint X_ATTRIBUTE_GAMER_HOSTNAME = X_ATTRIBUTE_XENON_DATATYPE_UNICODE
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x109;
        public const uint X_ATTRIBUTE_SESSION_SCORE = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10A;
        
        // why did platform type/lock start over at 0x201?  We don't know.  Maybe these aren't "gamer properties"?
        public const uint X_ATTRIBUTE_PLATFORM_TYPE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x201;
        public const uint X_ATTRIBUTE_PLATFORM_LOCK = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x202;


        // list of system attributes that may have weights associated with them, when used 
        // as parameters to a weighted search query.  
        public static uint[] rgWeightablePlatformAttrs = 
        {
            X_ATTRIBUTE_GAMER_ZONE,
            X_ATTRIBUTE_GAMER_COUNTRY,
            X_ATTRIBUTE_GAMER_LANGUAGE,
            X_ATTRIBUTE_GAMER_RATING,
            X_ATTRIBUTE_GAMER_MU,
            X_ATTRIBUTE_GAMER_SIGMA
        };

        // Game type context values
        public const uint X_ATTRIBUTE_GAME_TYPE_RANKED = 0;
        public const uint X_ATTRIBUTE_GAME_TYPE_STANDARD = 1;

        // maximum and default values for legacy xbox 1 titles
        public const uint XMATCH_SCHEMA_MAX_TITLE_QUERIES           = 30;
        public const uint XMATCH_SCHEMA_MAX_CONSTS                  = 50;
        public const uint XMATCH_SCHEMA_MAX_QUERY_NAME_LEN          = 32;
        public const uint XMATCH_SCHEMA_MAX_ATTR_NAME_LEN           = 28;
        public const uint XMATCH_SCHEMA_MAX_CONST_NAME_LEN          = 28;
        public const uint XMATCH_SCHEMA_MAX_PARAM_NAME_LEN          = 24;
        public const uint XMATCH_SCHEMA_MAX_QUERY_FILTERS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_SORTOPS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_RETURNS           = 40;

        public const uint XMATCH_SCHEMA_DEFAULT_SESSION_EXPIRATION  = 86400;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_QUERY_RESULTS   = 25;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_CONSTS          = 50;

        // default values for the social match attributes
        public const uint X_ATTRIBUTE_GAMER_ZONE_DEFAULT            = 1;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT         = 103;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT        = 1;
        public const float X_ATTRIBUTE_GAMER_RATING_DEFAULT         = 58.72f;
        public const double X_ATTRIBUTE_GAMER_MU_DEFAULT            = 3.0d;
        public const double X_ATTRIBUTE_GAMER_SIGMA_DEFAULT         = 1.0d;

        // NOTE: Changing these values impacts both the client and the server.

        // Built-in attributes should not account against X_MATCH_MAX_TITLE_SCHEMA_ATTRS
        // this constant should be adjusted when adding new built-in schema attributes
        public const uint X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS            = 12;
        public const uint X_MATCH_MAX_TITLE_SCHEMA_ATTRS              = 50;
        public const uint X_MATCH_MAX_TOTAL_SCHEMA_ATTRS              = X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS + X_MATCH_MAX_TITLE_SCHEMA_ATTRS;

        public const uint X_MATCH_MAX_QUERY_PARAMS                    = X_MATCH_MAX_TOTAL_SCHEMA_ATTRS;
        public const uint X_MATCH_MAX_WEIGHTED_QUERY_PARAMS_PER_REQ   = 20; 
        public const uint X_MATCH_MAX_QUERY_RESULTS                   = 50;
        public const uint X_MATCH_MAX_ATTRIBUTE_DATA                  = 4096;
        public const uint X_MATCH_MAX_SESSION_LIST_IDS                = 100;

        // NOTES ON PARAMS:

        // X_MATCH_MAX_QUERY_PARAMS is used to express both the max number of params you can declare 
        // for a matchmaking query (in XLAST) and the max number you can pass in one request for that query

        // X_MATCH_MAX_WEIGHTED_PARAMS_PER_REQUEST is the max number of weighted params that can be passed 
        // in a single request for a single query.  This plus the number of non-weighted params will need 
        // to add up to <= X_MATCH_MAX_QUERY_PARAMS

        // both of the above constants have the complication that they include system-defined params and
        // title-defined params.  Right now, there are 12 system-defined params (NUM_BUILTIN_SCHEMA_ATTRS)
        // which we have to assume are always used.  The practical max # of title defined params is 50, 
        // because that's how many attributes they can declare (MAX_TITLE_SCHEMA_ATTRS) and you can't have 
        // a param without a corresponding attr.  12+50 = 62... we have a 

        // Values for MatchSearch.wFlags
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK    = 0x0003; // Contains the NAT type of the calling client, one of XONLINE_NAT_xxx
        public const ushort XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT     = 0x4000; // Indicates that the client wants weighted sort semantics for match search results.
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NO_CACHE         = 0x8000; // Don't use the session cache for this search
        public const ushort XONLINE_MATCH_SEARCH_FLAGS_RESERVED        = unchecked((ushort)
                                                                         ~(XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK |
                                                                          XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT |
                                                                          XONLINE_MATCH_SEARCH_FLAG_NO_CACHE));

        // Lengths of byte arrays used by Match protocols
        public const uint X_MATCH_KEY_EXCHANGE_KEY_LEN                = 16;
        public const uint X_MATCH_HOST_ADDRESS_LEN                    = 36;

        // XNKID definitions
        public const byte XNET_XNKID_MASK                             = 0xF0;    // Mask of flag bits in first byte of XNKID
        public const byte XNET_XNKID_NAT_MASK                         = 0x30;    // Mask of NAT bits for Match create in first byte of XNKID
        public const byte XNET_XNKID_DBINDEX_MASK                     = 0x0F;    // Mask of DB index the session is on for Match-created XNKIDs
        public const byte XNET_XNKID_SYSTEM_LINK                      = 0x00;    // Peer to peer system link session
        public const byte XNET_XNKID_ONLINE_PEER                      = 0x80;    // Peer to peer online session
        public const byte XNET_XNKID_ONLINE_SERVER                    = 0xC0;    // Client to server online session
        public const byte XNET_XNKID_ONLINE_TITLESERVER               = 0xE0;    // Client to title server online session

        // XNKID helper functions
        //
        //  The high four bits of xnkid are flags:
        //
        //  |0|0|x|x| = system link XNKID, xbox hosted
        //  |1|0|x|x| = online XNKID, xbox hosted
        //  |1|1|0|x| = online XNKID, pc server hosted
        //  |1|1|1|x| = online XNKID, title server (note: we should never get this as they should look like xbox hosted)
        //
        // NOTE: In a Matchmaking create call, the lower 2 bits of the high nibble are the NAT type for xbox hosted games
        // (which due to a legacy bug often get sent up looking like system link).
        //
        public static bool XNetXnKidIsSystemLink( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_SYSTEM_LINK; }
        public static bool XNetXnKidIsOnlinePeer( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_PEER; }
        public static bool XNetXnKidIsOnlineServer( ulong xnkid )      { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_SERVER; }
        public static bool XNetXnKidIsOnlineTitleServer( ulong xnkid ) { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_TITLESERVER; }
        public static byte XNetXnKidGetServerType( ulong xnkid )       
        { 
            if( ( xnkid & 0xC0 ) == 0xC0 )
            {
                return (byte)( xnkid & 0xE0 );
            }
            return (byte)( xnkid & 0xC0 );
        }
        public static byte XNetXnKidGetNatType( ulong xnkid ) 
        { 
            if( XNetXnKidIsSystemLink( xnkid ) ||
                XNetXnKidIsOnlinePeer( xnkid ) )
            {
                return (byte)( ( xnkid & XNET_XNKID_NAT_MASK ) >> 4 );
            }
            return 0;
        }
        public static byte XNetXnKidGetDatabaseIndex( ulong xnkid )    { return (byte)( xnkid & XNET_XNKID_DBINDEX_MASK ); }

        // NAT types
        public const byte XONLINE_NAT_UNKNOWN                         = 0;
        public const byte XONLINE_NAT_OPEN                            = 1;
        public const byte XONLINE_NAT_MODERATE                        = 2;
        public const byte XONLINE_NAT_STRICT                          = 3;

        // Default proc Ids used by legacy xbox 1 title config
        public const uint XMATCH_QUERY_TYPE_NORMAL                    = 0;
        public const uint XMATCH_QUERY_TYPE_FINDFROMID                = 1;
        public const uint XMATCH_QUERY_TYPE_AGGREGATE                 = 2;
        public const uint XMATCH_QUERY_TYPE_INVALID                   = 0xffffffff;

        // Filter operations Ids for legacy xbox 1 title config
        public const uint XMATCH_FILTEROP_EQUALS                      = 0;
        public const uint XMATCH_FILTEROP_NOTEQUALS                   = 1;
        public const uint XMATCH_FILTEROP_LESSEQUAL                   = 2;
        public const uint XMATCH_FILTEROP_GREATEREQUAL                = 3;
        public const uint XMATCH_FILTEROP_LESS                        = 4;
        public const uint XMATCH_FILTEROP_GREATER                     = 5;
        public const uint XMATCH_FILTEROP_INVALID                     = 0xffffffff;

        // Sort types for legacy xbox 1 title config
        public const uint XMATCH_SORTOP_ASCENDING                     = 0;
        public const uint XMATCH_SORTOP_DESCENDING                    = 1;
        public const uint XMATCH_SORTOP_NEAR                          = 2;
        public const uint XMATCH_SORTOP_FAR                           = 3;
        public const uint XMATCH_SORTOP_INVALID                       = 0xffffffff;

        // Return types for legacy xbox 1 title config 
        public const uint XMATCH_RETURN_TYPE_NORMAL                   = 0;
        public const uint XMATCH_RETURN_TYPE_AVERAGE                  = 1;
        public const uint XMATCH_RETURN_TYPE_SUM                      = 2;
        public const uint XMATCH_RETURN_TYPE_MINIMUM                  = 3;
        public const uint XMATCH_RETURN_TYPE_MAXIMUM                  = 4;
        public const uint XMATCH_RETURN_TYPE_COUNT                    = 5;
        public const uint XMATCH_RETURN_TYPE_INVALID                  = 0xffffffff;
        
        // Reserved title search sproc indices
        public const uint X_SSINDEX_GET_SESSION                       = 0xFFFFFFFF; // special sproc to retrieve session by session id
        public const uint X_SSINDEX_GET_SESSION_ATTRIBUTES            = 0xFFFFFFFE; // special sproc to retrieve session by session id with attributes
        public const uint X_SSINDEX_GET_SESSION_LIST                  = 0xFFFFFFFD; // special sproc to retrieve a list of sessions by id
        public const uint XMATCH_QUERYID_FLAG_SUMMARY_QUERY           = 0x80000000; // special flag on summary queries so front door can recognize them for caching
        public const uint XMATCH_QUERYID_FLAG_RESERVED                = 0x7FFF0000;

        // Some limitations on game type and mode
        public const uint XMATCH_MAX_GAMETYPE                         = 0x02;
        public const uint XMATCH_MAX_GAMEMODE                         = 0x3e;

        // Some helper functions to make code using the flags defined
        // above more readable.
        public static bool IsAttributeGlobal(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_GLOBAL;
        }

        public static bool IsAttributeTitleSpecific(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC;
        }

        public static bool IsAttributeIdValid(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_RESERVED) == 0;
        }

        public static bool IsAttributeTypeConst(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_TYPE_CONSTANT) 
                == X_ATTRIBUTE_TYPE_CONSTANT;
        }

        public static bool IsSystemAttribute(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SYSTEM_FLAG) 
                == X_ATTRIBUTE_SYSTEM_FLAG;
        }
        
        public static uint AttributeDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_DATATYPE_MASK;
        }

        public static uint AttributeXenonDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_XENON_DATATYPE_MASK;
        }

        public static uint AttributeType(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_TYPE_MASK;
        }

        public static bool IsAttributeTypeSession(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_SESSION;
        }

        public static bool IsAttributeTypeParam(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_PARAM;
        }

        // this is only used by xbox 1.  360 "builtin" attributes are called "system" attributes,  
        // and you should use IsSystemAttribute() to determine if your attr is one of those.
        public static bool IsAttributeTypeBuiltin(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_BUILTIN;
        }

        public static bool IsAttributeDatatypeInt(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_INTEGER;
        }

        public static bool IsAttributeDatatypeString(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_STRING;
        }

        public static bool IsAttributeDatatypeBlob(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_BLOB;
        }

        public static bool IsAttributeDatatypeNull(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_NULL;
        }

        public static bool IsSearchSystemFindByIdQuery(uint procedureIndex)
        {
            return (procedureIndex == X_SSINDEX_GET_SESSION) || (procedureIndex == X_SSINDEX_GET_SESSION_ATTRIBUTES) || (procedureIndex == X_SSINDEX_GET_SESSION_LIST);
        }

        public static bool IsSearchSummaryQuery(uint procedureIndex)
        {
            if (IsSearchSystemFindByIdQuery(procedureIndex))
            {
                // This is a system FindById query, therefore it is not a
                // summary query
                return false;
            }
            if ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0)
            {
                // the XMATCH_QUERYID_FLAG_SUMMARY_QUERY flag is set,
                // so this is a summary query
                return true;
            }
            return false;
        }

        public static bool IsSummaryQuery(uint procedureIndex)
        {
            return ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0);
        }

        public static bool IsValidQueryProcId(uint procedureIndex)
        {
            return (0 == (XMATCH_QUERYID_FLAG_RESERVED & procedureIndex));
        }

        public static byte SearchFlagsNatType(ushort flags)
        {
            return (byte)(flags & XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK);
        }

        public static bool AreSearchFlagsValid(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAGS_RESERVED & flags) == 0;
        }

        public static bool IsSearchFlagNoCacheSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE & flags) != 0;
        }

        public static bool IsWeightedSortFlagSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT & flags) != 0;
        }

        public static uint GetQueryTypeFromString(string strQueryType)
        {
            uint uiQueryType;
            switch(strQueryType.ToUpper())
            {
                default:
                    uiQueryType = XMATCH_QUERY_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiQueryType = XMATCH_QUERY_TYPE_NORMAL;
                    break;
                case "FINDFROMID":
                    uiQueryType = XMATCH_QUERY_TYPE_FINDFROMID;
                    break;
                case "AGGREGATE":
                    uiQueryType = XMATCH_QUERY_TYPE_AGGREGATE;
                    break;
            }

            return uiQueryType;
        }

        public static uint GetFilterOpFromString(string strFilterOp)
        {
            uint uiFilterOp;

            switch(strFilterOp)
            {
                default:
                    uiFilterOp = XMATCH_FILTEROP_INVALID;
                    break;
                case "==":
                    uiFilterOp = XMATCH_FILTEROP_EQUALS;
                    break;
                case "!=":
                    uiFilterOp = XMATCH_FILTEROP_NOTEQUALS;
                    break;
                case "<=":
                    uiFilterOp = XMATCH_FILTEROP_LESSEQUAL;
                    break;
                case ">=":
                    uiFilterOp = XMATCH_FILTEROP_GREATEREQUAL;
                    break;
                case "<":
                    uiFilterOp = XMATCH_FILTEROP_LESS;
                    break;
                case ">":
                    uiFilterOp = XMATCH_FILTEROP_GREATER;
                    break;
            }

            return uiFilterOp;
        }

        public static uint GetSortOpFromString(string strSortType)
        {
            uint uiSortType;

            switch(strSortType.ToUpper())
            {
                default:
                    uiSortType = XMATCH_SORTOP_INVALID;
                    break;
                case "ASCENDING":
                    uiSortType = XMATCH_SORTOP_ASCENDING;
                    break;
                case "DESCENDING":
                    uiSortType = XMATCH_SORTOP_DESCENDING;
                    break;
                case "NEAR":
                    uiSortType = XMATCH_SORTOP_NEAR;
                    break;
                case "FAR":
                    uiSortType = XMATCH_SORTOP_FAR;
                    break;
            }

            return uiSortType;
        }

        public static uint GetReturnTypeFromString(string strReturnType)
        {
            uint uiReturnType;

            switch(strReturnType.ToUpper())
            {
                default:
                    uiReturnType = XMATCH_RETURN_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiReturnType = XMATCH_RETURN_TYPE_NORMAL;
                    break;
                case "AVERAGE":
                    uiReturnType = XMATCH_RETURN_TYPE_AVERAGE;
                    break;
                case "SUM":
                    uiReturnType = XMATCH_RETURN_TYPE_SUM;
                    break;
                case "MINIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MINIMUM;
                    break;
                case "MAXIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MAXIMUM;
                    break;
                case "COUNT":
                    uiReturnType = XMATCH_RETURN_TYPE_COUNT;
                    break;
            }

            return uiReturnType;
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds)
        {
            return SessionIdListToBytes(rgqwSessionIds, false);
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds, bool swapBytes)
        {
            byte[] rgbSessionIds = new byte[rgqwSessionIds.Length * 8];
            BinaryWriter writer = new BinaryWriter(new MemoryStream(rgbSessionIds));

            // This is when creating the varbinary on SQL server so the conversion operators work
            // correctly
            if(swapBytes)
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    long l = IPAddress.HostToNetworkOrder((long)qwSessionId);
                    writer.Write(l);
                }
            }
            else
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    writer.Write((ulong)qwSessionId);
                }
            }

            return rgbSessionIds;
        }

        public static ulong[] SessionIdListFromBytes(byte []rgbSessionIds)
        {
            if(0 != (rgbSessionIds.Length & 0x3))
            {
                throw new ArgumentException("MatchDefs.SessionIdListFromBytes: Binary data was not a multiple of 8 bytes");
            }

            BinaryReader reader = new BinaryReader(new MemoryStream(rgbSessionIds));

            int cIds = rgbSessionIds.Length >> 3;
            ulong []rgqwSessionIds = new ulong[cIds];

            for(int i = 0; i < cIds; ++i)
            {
                rgqwSessionIds[i] = reader.ReadUInt64();
            }

            return rgqwSessionIds;
        }

        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameTypeFromSessionId(ulong sessionId)
        {
            // the GameType is the lowest 2 bits of the third nibble from the bottom.
            // TODOTHEOM: modify either this function or GetGameType(from attributes) so that
            // they handle the fact that Xbox1 titles current set FF in the type/mode nibbles
            // of the sessionid.  (also applies to GetGameMode)
            // (xbox 1 titles don't have type/mode, so they should return 0 and 0.
            return (byte)((sessionId & 0x0300) >> 8);
        }


        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameModeFromSessionId(ulong sessionId)
        {
            // the game mode is the 4th nibble from the bottom, plus the highest 2 bits
            // of the third nibble from the bottom.  (6 bits total)
            return (byte)((sessionId & 0xFF00) >> 10);
        }

        public static uint GetBucketIdFromSessionId(ulong qwSessionId)
        {
            byte bType = GetGameTypeFromSessionId(qwSessionId);
            byte bMode = GetGameModeFromSessionId(qwSessionId);
            byte bRRId = XNetXnKidGetDatabaseIndex(qwSessionId);
            return (uint)((bType << 16) | (bMode << 8) | bRRId);
        }
        
    }

    public class XNADDR : WireData
    {
        [WireInfo(HexString=true)]
        public uint                 ina;
        [WireInfo(HexString=true)]
        public uint                 inaOnline;
        public ushort               wPortOnline;
        [WireInfo(ArraySize=6)]
        public byte[]               abEnet;
        public SGADDR               sgaddr; // defined in sgprot.cs

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // Allocate members the user has not set explicitly
            if( null == abEnet )
            {
                abEnet = new byte[ 6 ];
            }
            if( null == sgaddr )
            {
                sgaddr = new SGADDR();
            }

            binaryWriter.Write(ina);
            binaryWriter.Write(inaOnline);
            binaryWriter.Write(wPortOnline);
            binaryWriter.Write(abEnet);
            sgaddr.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                ina = (uint)binaryReader.ReadInt32();
                inaOnline = (uint)binaryReader.ReadInt32();
                wPortOnline = (ushort)binaryReader.ReadInt16();
                abEnet = new byte[6];
                binaryReader.Read(abEnet, 0, 6);
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_9, 
                    "Reached end of stream trying to read XNADDR", e);
            }
            return this;
        }

        public XNADDR Copy()
        {
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina                  = ina;
            xnaddr.inaOnline            = inaOnline;
            xnaddr.wPortOnline          = wPortOnline;
            xnaddr.abEnet               = new byte[6];
            Array.Copy(abEnet, xnaddr.abEnet, 6);

            xnaddr.sgaddr = new SGADDR();
            xnaddr.sgaddr.inaSg         = sgaddr.inaSg;
            xnaddr.sgaddr.dwSpiSg       = sgaddr.dwSpiSg;
            xnaddr.sgaddr.qwXboxId      = sgaddr.qwXboxId; 
            xnaddr.sgaddr.abReserved    = sgaddr.abReserved;

            return xnaddr;
        }
    }

    // Structure representing a Matchmaking attribute
    //
    public class MatchAttribute : WireData
    {
        [WireInfo(HexString=true)]
        public uint             dwAttributeId;

        // Only one of the next 3 will be present, depending on the type of dwAttributeId

        [WireInfo(Serialize=false, HexString=true)]
        public ulong            qwValue;

        [WireInfo(Serialize=false)]
        public string           strValue;

        [WireInfo(Serialize=false)]
        public byte[]           rgbValue;


        public MatchAttribute()
        {
        }

        public MatchAttribute(uint dwAttributeId, ulong qwValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
        }

        public MatchAttribute(uint dwAttributeId, double d)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
        }

        public MatchAttribute(uint dwAttributeId, float f)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
        }

        public MatchAttribute(uint dwAttributeId, string strValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
        }

        public MatchAttribute(uint dwAttributeId, byte []rgbValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
        }

        public virtual uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1; // Add a null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, //XEvent.Id.XMATCHFD_WARN_GEN, 
                    "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                dwAttributeId = (uint)binaryReader.ReadInt32();

                switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
                {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    qwValue = binaryReader.ReadUInt64();
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    ushort cbString = binaryReader.ReadUInt16();
                    if( 0 == cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, //XEvent.Id.XMATCHFD_WARN_GEN_1,
                            "MatchAttribute: String attribute size is zero" );
                    }
                    else
                    if( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 < cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_STRING_TOO_LONG, //XEvent.Id.COMMON_CODE_46, 
                            "MatchAttribute: String attribute exceeds max length (" + cbString.ToString() + " > " + ( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 ).ToString() + ")" );
                    }
                    strValue = Encoding.UTF8.GetString( binaryReader.ReadBytes( cbString - 1 ) ); // Remove the null terminator
                    if( 0 != binaryReader.ReadByte() ) // Consume the null terminator
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, //XEvent.Id.XMATCHFD_WARN_GEN_2, 
                            "MatchAttribute: String attribute is not null terminated" );
                    }
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    ushort cb = binaryReader.ReadUInt16();
                    if( MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN < cb )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_BLOB_TOO_LONG, //XEvent.Id.COMMON_CODE_48, 
                            "MatchAttribute: Blob attribute exceeds max length (" + cb.ToString() + " > " + MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN.ToString() + ")" );
                    }
                    rgbValue = binaryReader.ReadBytes( cb );
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                    break;
                default:
                    throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, //XEvent.Id.XMATCHFD_WARN_GEN_3, 
                        "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttribute", e);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            binaryWriter.Write(dwAttributeId);

            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                binaryWriter.Write( qwValue );
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                byte[] rgbString = Encoding.UTF8.GetBytes( strValue );
                binaryWriter.Write( (ushort)( rgbString.Length + 1 ) ); // Add a null terminator to the length
                if(rgbString.Length > 0)
                {
                    binaryWriter.Write( rgbString );
                }
                binaryWriter.Write( (byte) 0 ); // Add a null terminator
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                binaryWriter.Write( (ushort) rgbValue.Length );
                if(rgbValue.Length > 0)
                {
                    binaryWriter.Write( rgbValue );
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                break;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, //XEvent.Id.XMATCHFD_WARN_GEN_4, 
                    "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public double ToDouble()
        {
            double d = BitConverter.Int64BitsToDouble((long)qwValue);
            return d;
        }

        public float ToSingle()
        {
            float f = BitConverter.ToSingle(BitConverter.GetBytes(qwValue), 0);
            return f;
        }

        public void FromDouble(double d)
        {
           qwValue = (ulong)BitConverter.DoubleToInt64Bits(d);
        }

        public void FromSingle(float f)
        {
            qwValue = (ulong)(uint)BitConverter.ToInt32(BitConverter.GetBytes(f), 0);
        }
    }
    public class MatchAttributeWeighted : MatchAttribute
    {
        // has all the standard attribute fields, plus a weight
        // the weight should come first off the wire -- readstream controls this ordering
        public float             fltWeight = 0;

        public MatchAttributeWeighted()
        {
        }

        public MatchAttributeWeighted(uint dwAttributeId, ulong qwValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, double d, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, float f, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, string strValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, byte []rgbValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
            this.fltWeight = fltWeight;
        }

        public override uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8 + 4; // ID + VALUE + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1 + 4; // +1 is for null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length; // ID + 2? + byte array + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4 + 4; // ID + WEIGHT
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, //XEvent.Id.XMATCHFD_WARN_GEN, 
                                        "MatchAttributeWeighted: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                this.fltWeight = binaryReader.ReadSingle();
                base.ReadStream(binaryReader);
                return this;
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,// XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttributeWeighted", e);
            }
        }
        
        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // noone should ever writestream on a weighted attribute
            System.Diagnostics.Debug.Assert(false,"WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
            throw new NotSupportedException("WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
        }

        public float GetWeight()
        {
            return fltWeight;
        }
    }


    // Structure representing a Matchmaking search result
    //  maps to XMATCH_SEARCHRESULT in xonline.x
    //
    // NOTE: SearchResult's are padded to a 4-byte boundary
    //
    public class SearchResult : WireData
    {
        public uint             dwResultLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        public XNADDR           HostAddress;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        [WireInfo(Serialize=false)]
        public uint             rgbPaddingLen;
        public byte[]           rgbPadding;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfAffiliateValue = -1;

        [WireInfo(Serialize=false)]
        public int           attributeIndexOfScore = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfMu = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfSigma = -1;

        [WireInfo(Serialize=false)]
        public double           drawProbability = -1;

        public void SetDrawProbability(double searcherMu, double searcherSigma)
        {
            if (-1 != attributeIndexOfMu && -1 != attributeIndexOfSigma)
            {
                double resultMu = rgAttributes[attributeIndexOfMu].ToDouble();
                double resultSimga = rgAttributes[attributeIndexOfSigma].ToDouble();

                drawProbability = Math.Exp(
                    -( 
                        ((resultMu - searcherMu) * (resultMu - searcherMu)) +
                        (resultSimga * resultSimga) +
                        (searcherSigma * searcherSigma)
                    ));
            }
        }

        public uint GetBaseSize() { return 84; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwResultLength);
            binaryWriter.Write(qwSessionId);
            HostAddress.WriteStream(binaryWriter);
            binaryWriter.Write(rgbKeyExchangeKey);
            binaryWriter.Write(dwPublicOpen);
            binaryWriter.Write(dwPrivateOpen);
            binaryWriter.Write(dwPublicFilled);
            binaryWriter.Write(dwPrivateFilled);
            binaryWriter.Write(dwNumAttributes);
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                binaryWriter.Write(rgdwAttrOffsets[i]);
            }
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                rgAttributes[i].WriteStream(binaryWriter);
            }
            if (rgbPadding != null)
            {
                binaryWriter.Write(rgbPadding);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int padding;
            int start = (int)binaryReader.BaseStream.Position;

            // Invoke WireData functionality
            base.ReadStream(binaryReader);

            // Spool any padding bytes
            padding = (int)dwResultLength - ((int)binaryReader.BaseStream.Position - start);
            binaryReader.ReadBytes(padding);

            return this;
        }
    }

    internal class SearchResultDrawProbabilityComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultDrawProbabilityComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered descending so reverse the usual semantics
            double compare = rhsSearchResult.drawProbability - lhsSearchResult.drawProbability;
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultDrawProbabilityComparer

    internal class SearchResultScoreComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultScoreComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered ascending (lower score is better)
            float compare = lhsSearchResult.rgAttributes[lhsSearchResult.attributeIndexOfScore].ToSingle() - rhsSearchResult.rgAttributes[rhsSearchResult.attributeIndexOfScore].ToSingle();
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultScoreComparer

    // Structure representing a request to create or update a session
    //  maps to XMATCH_SESSION in xonline.x
    //
    public class MatchSessionMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public string GetXrl() { return "/xmatch/xmatchhost.srf"; }
        public uint GetBaseSize() { return 72; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwPublicOpen        = binaryReader.ReadUInt32();
                dwPrivateOpen       = binaryReader.ReadUInt32();
                dwPublicFilled      = binaryReader.ReadUInt32();
                dwPrivateFilled     = binaryReader.ReadUInt32();
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            //XEvent.Id.MATCH_HACK_SESSION_NUM_ATTR,
                            String.Format("MatchSessionMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.MATCH_HACK_SESSION_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSessionMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a session creation request
    //  maps to XMATCH_SESSION_INFO in xonline.x
    //
    public class MatchSessionReply : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwSessionId);
            binaryWriter.Write(rgbKeyExchangeKey);
        }
    }

    // Structure representing a request to delete a session
    //  maps to XMATCH_SESSION_DELETE in xonline.x
    // 
    public class MatchDeleteMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;

        public string GetXrl() { return "/xmatch/xmatchhostdelete.srf"; }
        public uint GetBaseSize() { return 16; }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // Log the input buffer
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength = (uint)binaryReader.ReadInt32();
                qwSessionId = (ulong)binaryReader.ReadInt64();
                dwTitleId = (uint)binaryReader.ReadInt32();

                // Log text representation
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_12, 
                    "Reached end of stream trying to read MatchDeleteMsg", e);
            }
            return this;
        }
    }

    // Structure representing a search request
    //  maps to XMATCH_SEARCH in xonline.x
    //
    public class MatchSearchMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        [WireInfo(HexString=true)]
        public uint             dwProcedureIndex;
        public XNADDR           ClientAddress;
        public ushort           wNumUsers;
        [WireInfo(HexString=true)]
        public ushort           wFlags;
        public uint             dwNumParameters;

        [WireInfo(SizeParam="dwNumParameters")]
        public uint[]           rgdwParamOffsets;

        [WireInfo(SizeParam="dwNumParameters")]
        public MatchAttribute[] rgParameters;

        // Spring09 introduces the notion of per-parameter weighting, to allow titles
        // more control over search result ordering.
        [WireInfo(MinSchemaVersion="5.3")]
        public uint             dwNumWeightedParameters = 0;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public uint[]           rgdwWeightedParamOffsets;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public MatchAttributeWeighted[] rgWeightedParameters;

        public string Xrl { get { return "/xmatch/xmatchclient.srf"; } }
        public uint GetBaseSize() { return 56; } //this does not include the 4 bytes required with
                                                 //the weighted parameters--Methods that create
                                                 //these requests must add this separately.

        // MatchSearchMsg uses the default WireData readstream implementation.
    }

    // Structure representing a search reply
    //  maps to XMATCH_SEARCHRESULT_HEADER in xonline.x
    //
    public class MatchSearchReply : XRLObject2
    {
        public uint             dwMessageLength;
        public ushort           wNumSearchResults;
        [WireInfo(HexString=true)]
        public ushort           wFlags;             // Unused, always zero
        [WireInfo(HexString=true)]
        public uint             dwLoggingThreshold; // Unused, always zero

        [WireInfo(SizeParam="wNumSearchResults")]
        public SearchResult[]   rgResults;
        public uint GetBaseSize() { return 12; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwMessageLength);
            binaryWriter.Write(wNumSearchResults);
            binaryWriter.Write(wFlags);
            binaryWriter.Write(dwLoggingThreshold);
            for (int i = 0; i < wNumSearchResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }

    }

    // Structure representing a request to split an existing session
    //  maps to XMATCH_SPLIT in xonline.x
    //
    public class MatchSplitMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public ulong            qwSplitSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public string GetXrl() { return "/xmatch/xmatchsplit.ashx"; }
        public uint GetBaseSize() { return 64; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                qwSplitSessionId    = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            //XEvent.Id.MATCH_HACK_SPLIT_NUM_ATTR,
                            String.Format("MatchSplitMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.MATCH_HACK_SPLIT_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSplitMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a split a session
    //  maps to a single XMATCH_SEARCHSESSION in xonline.x
    //
    //  We need to work with XRLObject2 but don't want 
    //  SearchResult to extend XRLObject2. On the wire
    //  this is just a search result object.
    //
    public class MatchSplitReply : XRLObject2
    {
        public SearchResult     Session;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // Don't write the padding in a split reply since there is only
            // one result and the client doesn't want padding if there's only
            // one and not an array.
            Session.rgbPadding = null;

            Session.WriteStream(binaryWriter);
        }
    }
} // namespace xonline.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\SGInfo.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Net;

namespace live.common
{
    public enum ClientType : uint
    {
        Xbox,
        Xenon,
        XenonBackCompat,
        Panorama,
        Zune,
        XboxCom,
        WebBrowser
    }

    [Serializable()]
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct CSGInfo
    {
        private static RandomEx randGen = new RandomEx();

        public uint inaSg;
        public uint SpiSg;

        public uint   ipaI;
        public ushort ipportI;
        public long   liNonce;

        public ulong machinePuid;

        public uint titleId;
        public uint titleVersion;
        public uint titleRegion;

        public uint consoleRegion; // v3
        public uint mediaID;  // v3
        public ushort languageID;  // v3
        public uint authDataFlags;  // v3

        // clientVersion
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;

        // backwards compatibility
        public ulong clientVersion
        {
            get { return (ulong)wMajorVersion; }
            set { wMajorVersion = (ushort)value; }
        }

        public ulong userPuid0;
        public ulong userPuid1;
        public ulong userPuid2;
        public ulong userPuid3;

        // dwUserFlags - bit layout
        //
        //Byte 0:
        //Bits 0-1: guest number                        { as calculated by XKDC }
        //Bits 2-4: no show rating                      { as calculated by XKDC }
        //Bits 5-7: disconnect rating                   { as calculated by XKDC }
        //
        //Byte 1:
        //Bits 8-15: country id                         { from country field in t_users }
        //
        //Byte 2:
        //Bit 16: user voice not allowed flag           { as calculated by XKDC }
        //Bit 17: user purchase not allowed flag        { from si_ticket_flags in t_users }
        //Bit 18: user nickname not allowed flag        { from si_ticket_flags in t_users }
        //Bit 19: user shared content not allowed flag  { from si_ticket_flags in t_users }
        //Bits 20-23: user's tier id	                { as calculated by XKDC, this is new }
        //
        //Byte 3:
        //Bit 24: Account has parent-child relationship { calculated by XKDC, owner puid different in t_users }
        //Bits 25-31: unknown                           { from si_ticket_flags in t_users }
        //
        public uint userFlag0;
        public uint userFlag1;
        public uint userFlag2;
        public uint userFlag3;

        //AuthdataV3 only - privileges are shared by all users
        // The way services are implemented is very different from AuthData v2. 
        // dwPrivileges[8] is a 256 bit array.  Bits 0-127 are for services, and the bits
        // counting down from 256 are for privileges.  Overflow services, ones that have a
        // value outside the 0-127 range, are stored in the dwServiceID[4] array, which can 
        // only hold 4 of these.  Things like PSO and LSP sites use this, I suppose.
        public ushort wNumPrivileges;
        public uint dwPrivileges4;
        public uint dwPrivileges5;
        public uint dwPrivileges6;
        public uint dwPrivileges7;

        //AuthdataV4 only - 96 privileges are per-user, 32 privileges are for machines
        public uint dwPrivileges5User0;
        public uint dwPrivileges6User0;
        public uint dwPrivileges7User0;
        public uint dwPrivileges5User1;
        public uint dwPrivileges6User1;
        public uint dwPrivileges7User1;
        public uint dwPrivileges5User2;
        public uint dwPrivileges6User2;
        public uint dwPrivileges7User2;
        public uint dwPrivileges5User3;
        public uint dwPrivileges6User3;
        public uint dwPrivileges7User3;

        //services (upper 128 bits of the shared privilege blocks hold services here)
        public uint dwPrivileges0;
        public uint dwPrivileges1;
        public uint dwPrivileges2;
        public uint dwPrivileges3;
        public ushort wNumDwordServices;
        public uint dwServiceID0;
        public uint dwServiceID1;
        public uint dwServiceID2;
        public uint dwServiceID3;

        public float userTrust0;
        public float userTrust1;
        public float userTrust2;
        public float userTrust3;

        public uint altTitleId0;
        public uint altTitleId1;
        public uint altTitleId2;
        public uint altTitleId3;

        public byte key00;
        public byte key01;
        public byte key02;
        public byte key03;
        public byte key04;
        public byte key05;
        public byte key06;
        public byte key07;
        public byte key08;
        public byte key09;
        public byte key10;
        public byte key11;
        public byte key12;
        public byte key13;
        public byte key14;
        public byte key15;

        // Not part of wiredata
        //

        // Our initial array of slots is set to all zeroes.  This field used to be "UserNotFound", which when 
        // set to 0, means the user WAS found.  This is incorrect.  By default, I want the user to not
        // be found, until the slot gets populated.  Changing name to "UserExists".
        public byte UserExists;
        public ushort port;

        public static class ClientInfo
        {
            public const UInt64 Mask                = 0xFFFF000000000000;

            public const UInt64 UserBase            = 0x0009000000000000;
            public const UInt64 XboxMachineBase     = 0x0009000000000000;
            public const UInt64 XenonConsoleBase    = 0xF000000000000000;
            public const UInt64 XenonMachineBase    = 0xFA00000000000000;
            public const UInt64 PcMachineBase       = 0xFB00000000000000;

            public static ulong ToMachineBase(ClientType clientType)
            {
                switch (clientType)
                {
                    case ClientType.Xbox:
                        return XboxMachineBase;
                    case ClientType.Xenon:
                    case ClientType.XenonBackCompat:
                        return XenonMachineBase;
                    case ClientType.Panorama:
                        return PcMachineBase;
                    default:
                        throw new Exception("Unknown client type: " + clientType.ToString());
                }
            }

            public static bool IsUserPuid(ulong id) { return (id & Mask) == UserBase; }
            public static bool IsXboxMachinePuid(ulong id) { return (id & Mask) == XboxMachineBase; }
            public static bool IsXenonMachinePuid(ulong id) { return (id & Mask) == XenonMachineBase; }
            public static bool IsPcMachinePuid(ulong id) { return (id & Mask) == PcMachineBase; }
        }

        public const uint AUTHDATA_FLAGS_ISXENON            = 0x01;  // Legacy
        public const uint AUTHDATA_FLAGS_ISXENONBACKCOMPAT  = 0x02;  // Fusion
        public const uint AUTHDATA_FLAGS_ISDEVKIT           = 0x04;  // Devkit Xenon console
        public const uint AUTHDATA_FLAGS_ISTESTKIT          = 0x08;  // Testkit Xenon console
        public const uint AUTHDATA_FLAGS_ISBETAMACHINE      = 0x10;  // Machine marked for betas (t_machines.i_beta_title_id != 0)

        public const ulong DefaultMachineId = 0x0009FFFFFFFFFFFF;

        public void SetClientType(ClientType type)
        {
            // dwAuthDataFlags is no longer the main indicator of platform type. It used 
            // to be.  See XkdcPolicy.cpp and xonline.x to see how thigns are really done.  
            // It's only really used to differentiate fusion from Xbox360 (same machine 
            // puid), and to identify devkits and testkits from retail boxes. It is also 
            // used in a legacy manner to indicate regular Xbox360(Xenon) boxes, but this 
            // may go away soon.
            authDataFlags = 0;
            switch (type)
            {
                case ClientType.Xenon:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENON;
                    break;
                case ClientType.XenonBackCompat:
                    authDataFlags |= AUTHDATA_FLAGS_ISXENONBACKCOMPAT;
                    break;
            }

            // If the machine puid is still the default one, we'll generate a new random 
            // one that is correct for your client type.  Otherwise, you're on your own 
            // and are expected to get it right.
            if (machinePuid == DefaultMachineId)
            {
                machinePuid = randGen.GenerateRandomMachineId(type);
            }

            // Here's the check. Let's not do it.
//             UInt64 machineBase = ClientInfo.ToMachineBase(type);
//             if ((machineBase & machinePuid) != machineBase)
//             {
//                 throw new Exception("machine puid doesn't match your client type");
//             }
            
        }

        public bool IsClientXbox
        {
            get
            {
                return ClientInfo.IsXboxMachinePuid(machinePuid);
            }
        }
        public bool IsClientXenon
        {
            get
            {
                return ClientInfo.IsXenonMachinePuid(machinePuid) 
                    && ((authDataFlags & AUTHDATA_FLAGS_ISXENON) == AUTHDATA_FLAGS_ISXENON);
            }
        }
        public bool IsClientXenonBackcompat
        {
            get
            {
                return ClientInfo.IsXenonMachinePuid(machinePuid) 
                    && ((authDataFlags & AUTHDATA_FLAGS_ISXENONBACKCOMPAT) == AUTHDATA_FLAGS_ISXENONBACKCOMPAT);
            }
        }
        public bool IsClientPC
        {
            get
            {
                return ClientInfo.IsPcMachinePuid(machinePuid);
            }
        }
        public bool IsClientDevkit
        {
            get
            {
                return ((authDataFlags & AUTHDATA_FLAGS_ISDEVKIT) == AUTHDATA_FLAGS_ISDEVKIT);
            }
        }
        public bool IsClientTestkit
        {
            get
            {
                return ((authDataFlags & AUTHDATA_FLAGS_ISTESTKIT) == AUTHDATA_FLAGS_ISTESTKIT);
            }
        }


        public void Initialize()
        {
            machinePuid = DefaultMachineId;
            titleId = 0xFFFE0000;
            titleVersion = 1;

            clientVersion = 0;

            userFlag0 = 0x00006700;
            userFlag1 = 0x00006700;
            userFlag2 = 0x00006700;
            userFlag3 = 0x00006700;

            ClearServices();

            AddService(XOService.Base_Subscription);
            AddService(XOService.User_Account);
            AddService(XOService.Billing_Offering);
            AddService(XOService.Signature_Server);
            AddService(XOService.Stats);
            AddService(XOService.Storage);
            AddService(XOService.PresNotification);
            AddService(XOService.DRM);
            AddService(XOService.Crypto);
            AddService(XOService.Lists);
            AddService(XOService.liveinfo);

            // set up defaults
            SetPrivilege(XOn.XPRIVILEGE_ADD_FRIEND);
            SetPrivilege(XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
            SetPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS);
            SetPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            SetPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            SetPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_PURCHASE_CONTENT);
            SetPrivilege(XOn.XPRIVILEGE_PRESENCE);
            SetPrivilege(XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
            SetPrivilege(XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
            SetPrivilege(XOn.XPRIVILEGE_BILLING_SWITCHING);
            SetPrivilege(XOn.XPRIVILEGE_PASSPORT_SWITCHING);
            SetPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
            SetPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);



            UserExists = 1;
        }

        private const uint USER_TIERID_MASK = 0x00F00000;
        private const byte USER_TIERID_SHIFT = 20;

        public void SetTier(int userSlot, uint tier)
        {
            uint tierbits = (uint)((tier << USER_TIERID_SHIFT) & USER_TIERID_MASK);
            switch (userSlot)
            {
                case 0:
                    userFlag0 = (userFlag0 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 1:
                    userFlag1 = (userFlag1 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 2:
                    userFlag2 = (userFlag2 & ~USER_TIERID_MASK) | tierbits;
                    break;
                case 3:
                    userFlag3 = (userFlag3 & ~USER_TIERID_MASK) | tierbits;
                    break;
            }
        }

        public uint GetTier(int userSlot)
        {
            switch (userSlot)
            {
                case 0:
                    return ((userFlag0 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 1:
                    return ((userFlag1 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 2:
                    return ((userFlag2 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
                case 3:
                    return ((userFlag3 & USER_TIERID_MASK) >> USER_TIERID_SHIFT);
            }
            return 0;
        }


        public byte[] Key
        {
            get
            {
                byte[] k = new byte[16];
                k[0] = this.key00;
                k[1] = this.key01;
                k[2] = this.key02;
                k[3] = this.key03;
                k[4] = this.key04;
                k[5] = this.key05;
                k[6] = this.key06;
                k[7] = this.key07;
                k[8] = this.key08;
                k[9] = this.key09;
                k[10] = this.key10;
                k[11] = this.key11;
                k[12] = this.key12;
                k[13] = this.key13;
                k[14] = this.key14;
                k[15] = this.key15;
                return k;
            }
        }

        public bool SetKey(byte[] key)
        {
            if (key.GetLength(0) != 16)
            {
                Debug.Assert(true, "key must be 16 bytes!", "");
                return false;
            }
            this.key00 = key[0];
            this.key01 = key[1];
            this.key02 = key[2];
            this.key03 = key[3];
            this.key04 = key[4];
            this.key05 = key[5];
            this.key06 = key[6];
            this.key07 = key[7];
            this.key08 = key[8];
            this.key09 = key[9];
            this.key10 = key[10];
            this.key11 = key[11];
            this.key12 = key[12];
            this.key13 = key[13];
            this.key14 = key[14];
            this.key15 = key[15];

            return true;
        }

        //note that this also clears priviliges
        public void ClearServices()
        {
            this.wNumPrivileges = 0;
            this.wNumDwordServices = 0;
            this.dwPrivileges0 = 0;
            this.dwPrivileges1 = 0;
            this.dwPrivileges2 = 0;
            this.dwPrivileges3 = 0;
            this.dwPrivileges4 = 0;
            this.dwPrivileges5 = 0;
            this.dwPrivileges6 = 0;
            this.dwPrivileges7 = 0;
            this.dwServiceID0 = 0;
            this.dwServiceID1 = 0;
            this.dwServiceID2 = 0;
            this.dwServiceID3 = 0;

            dwPrivileges5User0=0;
            dwPrivileges6User0=0;
            dwPrivileges7User0=0;
            dwPrivileges5User1=0;
            dwPrivileges6User1=0;
            dwPrivileges7User1=0;
            dwPrivileges5User2=0;
            dwPrivileges6User2=0;
            dwPrivileges7User2=0;
            dwPrivileges5User3=0;
            dwPrivileges6User3=0;
            dwPrivileges7User3=0;
        }

        unsafe public bool ClearService(XOService service) { return ClearService((int)service); }
        unsafe public bool ClearService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.ClearValue);
        }

        unsafe public bool GetService(XOService service) { return GetService((int)service); }
        unsafe public bool GetService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.GetValue);
        }

        unsafe public bool AddService(XOService service) { return AddService((int)service); }
        unsafe public bool AddService(int svcId)
        {
            return ServiceActionHelper(svcId, ServiceAction.SetValue);
        }

        //this should be avoided going forward - sets the privilege for all users
        public void SetPrivilege(uint priv)
        {
            if (priv<128 || priv>255) //privileges as a whole are in the range 128-255
            {
                throw new ArgumentException(priv+" is not a valid privilege number.");
            }

            if (priv>=160)
            {
                SetUserPrivilege(0, priv);
                SetUserPrivilege(1, priv);
                SetUserPrivilege(2, priv);
                SetUserPrivilege(3, priv);
            }
            else
            {
                SetMachinePrivilege(priv);
            }
        }

        //sets the privilege for a specific user in the v4 authdata, or all users in the v3 authdata
        public unsafe void SetUserPrivilege(int userIndex, uint priv)
        {
            if (priv<160 || priv>255) //per-user privileges are in the range 160-255
            {
                throw new ArgumentException(priv+" is not a valid user privilege number.");
            }

            uint dwordIndex=priv/32;    // 5...7
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, true);
            }

            //per-user
            uint userDwordIndex=(uint)userIndex*3;
            dwordIndex-=5; //0..2
            fixed (uint* pSpecificPriv=&dwPrivileges5User0)
            {
                SetDwordBlockBit(pSpecificPriv, userDwordIndex+dwordIndex, bitIndex, true);
            }

            CountSharedPrivileges();
        }

        //this should be avoided going forward - clears the privilege for all users
        public unsafe void UnsetPrivilege(uint priv)
        {
            if (priv<128 || priv>255) //privileges as a whole are in the range 128-255
            {
                throw new ArgumentException(priv+" is not a valid privilege number.");
            }

            if (priv>=160)
            {
                UnsetUserPrivilege(0, priv);
                UnsetUserPrivilege(1, priv);
                UnsetUserPrivilege(2, priv);
                UnsetUserPrivilege(3, priv);
            }
            else
            {
                UnsetMachinePrivilege(priv);
            }
        }

        //sets the privilege for a specific user in the v4 authdata, or all users in the v3 authdata
        public unsafe void UnsetUserPrivilege(int userIndex, uint priv)
        {
            if (priv<160 || priv>255) //per-user privileges are in the range 160-255
            {
                throw new ArgumentException(priv+" is not a valid user privilege number.");
            }

            uint dwordIndex=priv/32;    // 5...7
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, false);
            }

            //per-user
            uint userDwordIndex=(uint)userIndex*3;
            dwordIndex-=5; //0..2
            fixed (uint* pSpecificPriv=&dwPrivileges5User0)
            {
                SetDwordBlockBit(pSpecificPriv, userDwordIndex+dwordIndex, bitIndex, false);
            }

            CountSharedPrivileges();
        }

        public unsafe void SetMachinePrivilege(uint priv)
        {
            if (priv<128 || priv>=160) //machine privileges in the range 128-159
            {
                throw new ArgumentException(priv+" is not a valid machine privilege number.");
            }

            uint dwordIndex=priv/32;    // 4 always
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, true);
            }

            CountSharedPrivileges();
        }

        public unsafe void UnsetMachinePrivilege(uint priv)
        {
            if (priv<128 || priv>=160) //machine privileges in the range 128-159
            {
                throw new ArgumentException(priv+" is not a valid machine privilege number.");
            }

            uint dwordIndex=priv/32;    // 4 always
            uint bitIndex=priv%32;      // 0...31

            //shared
            fixed (uint* pSharedPriv=&dwPrivileges4)
            {
                SetDwordBlockBit(pSharedPriv, dwordIndex-4, bitIndex, false);
            }

            CountSharedPrivileges();
        }

        private void CountSharedPrivileges()
        {
            wNumPrivileges=0;
            for (int i=0; i<32; ++i)
            {
                wNumPrivileges+=(ushort)(0!=(dwPrivileges4&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges5&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges6&(1<<i))?1:0);
                wNumPrivileges+=(ushort)(0!=(dwPrivileges7&(1<<i))?1:0);
            }
        }

        unsafe private void SetDwordBlockBit(uint *dwordBase, uint dwordOffset, uint bit, bool set)
        {
            if (set)
            {
                dwordBase[dwordOffset]|=(uint)(1<<(int)bit);
            }
            else
            {
                dwordBase[dwordOffset]&=~(uint)(1<<(int)bit);
            }
        }

        private enum ServiceAction
        {
            SetValue,
            ClearValue,
            GetValue
        };

// Consolidate the logic into one place, should help with debugging any bugs in the bit shifting junk
        unsafe private bool ServiceActionHelper(int svcId, ServiceAction action)
        {
            //this should never be passed privileges anymore as it doesn't handle them right after AuthDataV4
            if (svcId>=128 && svcId<=255)
            {
                throw new ArgumentException(svcId+" is not a valid service number.");
            }

            // I'm basing this off \private\common\service\SGInfo.cs
            // and also xonlinep.h (see CAuthData3).  If svcId > 0 and < 256, then
            // it is set as a bit in the dwPrivileges array.  Otherwise, it goes in 
            // the dwServiceID array, which is used for abnormal service IDs like PSO
            // and LSP stuff.
            bool exists = false;
            // This is a privilege or base service
            if (svcId > 0 && svcId < 256)
            {
                int dwordIndex = svcId / 32;    // 0...7
                int bitIndex = svcId % 32;      // 0...31
                uint mask = ((uint)1) << bitIndex;
                //uint notMask = ((uint)0xFFFFFFFF) ^ mask;
                fixed (uint* pPriv = &dwPrivileges0)
                {
                    exists = (pPriv[dwordIndex] & mask) == mask;
                    if (ServiceAction.SetValue == action)
                    {
                        // Only add if it doesn't exist already to keep counts in check
                        if (!exists)
                        {
                            pPriv[dwordIndex] |= mask;
                        }
                    }
                    else if (ServiceAction.ClearValue == action)
                    {
                        // Only clear if it does exist to keep counts in check
                        if (exists)
                        {
                            pPriv[dwordIndex] ^= mask;
                        }
                    }
                    else if (ServiceAction.GetValue == action)
                    {
                    }
                }
            }
            // Not in dwPrivileges array, this is in the dwServiceID array
            else
            {
                int i;
                fixed (uint* pService = &dwServiceID0)
                {
                    // Does it exist?
                    for (i = 0; i < 4; i++)
                    {
                        if (pService[i] == svcId)
                        {
                            exists = true;
                            break;
                        }
                    }

                    if (ServiceAction.SetValue == action && !exists)
                    {
                        // Find empty slot.  If full, do nothing.
                        for (i = 0; i < 4; i++)
                        {
                            if (pService[i] == 0)
                            {
                                pService[i] = (uint)svcId;
                                wNumDwordServices++;
                                break;
                            }
                        }
                    }
                    else if (ServiceAction.ClearValue == action && exists)
                    {
                        // hmm.. have to find it again
                        for (i = 0; i < 4; i++)
                        {
                            if (pService[i] == (uint)svcId)
                            {
                                pService[i] = 0;
                                wNumDwordServices--;
                                break;
                            }
                        }
                    }
                    else if (ServiceAction.GetValue == action)
                    {
                    }
                }
            }
            return exists;
        }

        public CSGInfo ShallowClone()
        {
            return ((CSGInfo)this.MemberwiseClone());
        }

        private const ushort XONLINE_XENON_AUTHDATA_VERSION = 0x03;
        private const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        public byte[] GetHttpAuthHeaderBytes(IPEndPoint ep)
        {
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);

            w.Write(HTTP_HEADER_AUTH_DATA_VERSION);

            // Receiving port and address 
            w.Write((ushort)ep.Port);
            byte[] addrBytes = ep.Address.GetAddressBytes();
            uint addr =
                ((uint)addrBytes[3] << 24) |
                ((uint)addrBytes[2] << 16) |
                ((uint)addrBytes[1] << 8) |
                ((uint)addrBytes[0] << 0);
            w.Write(addr);

            // Nonce - supposed to be random value identifying session. Seems to work fine as 0 for HTTPAuth
            w.Write((ulong)0);

            w.Write(XONLINE_XENON_AUTHDATA_VERSION);
            // wAuthData size - 0 works fine here as well for all the cases 
            w.Write((ushort)0);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(titleId);
            w.Write(titleVersion);
            w.Write(titleRegion);
            w.Write(consoleRegion);
            w.Write(mediaID);
            w.Write(languageID);
            w.Write(authDataFlags);

            w.Write(wNumPrivileges);
            w.Write(dwPrivileges0);
            w.Write(dwPrivileges1);
            w.Write(dwPrivileges2);
            w.Write(dwPrivileges3);
            w.Write(dwPrivileges4);
            w.Write(dwPrivileges5);
            w.Write(dwPrivileges6);
            w.Write(dwPrivileges7);

            w.Write(machinePuid);

            w.Write(userPuid0);
            w.Write(userFlag0);
            w.Write(userPuid1);
            w.Write(userFlag1);
            w.Write(userPuid2);
            w.Write(userFlag2);
            w.Write(userPuid3);
            w.Write(userFlag3);


            w.Write(userTrust0);
            w.Write(userTrust1);
            w.Write(userTrust2);
            w.Write(userTrust3);

            w.Write(wNumDwordServices);
            w.Write(dwServiceID0);
            w.Write(dwServiceID1);
            w.Write(dwServiceID2);
            w.Write(dwServiceID3);

            w.Write(altTitleId0);
            w.Write(altTitleId1);
            w.Write(altTitleId2);
            w.Write(altTitleId3);

            w.Write(key00);
            w.Write(key01);
            w.Write(key02);
            w.Write(key03);
            w.Write(key04);
            w.Write(key05);
            w.Write(key06);
            w.Write(key07);
            w.Write(key08);
            w.Write(key09);
            w.Write(key10);
            w.Write(key11);
            w.Write(key12);
            w.Write(key13);
            w.Write(key14);
            w.Write(key15);

            string header = "HTTPAuthData:" + Convert.ToBase64String(m.ToArray()) + "\r\n";
            return System.Text.Encoding.ASCII.GetBytes(header);
        }

        static public explicit operator ServerTestFramework.LiveService.FakeSG.CSGInfo(CSGInfo llSgInfo)
        {
            ServerTestFramework.LiveService.FakeSG.CSGInfo stfSgInfo = new ServerTestFramework.LiveService.FakeSG.CSGInfo(); ;

            stfSgInfo.altTitleId0 = llSgInfo.altTitleId0;
            stfSgInfo.altTitleId1 = llSgInfo.altTitleId1;
            stfSgInfo.altTitleId2 = llSgInfo.altTitleId2;
            stfSgInfo.altTitleId3 = llSgInfo.altTitleId3;
            stfSgInfo.authDataFlags = llSgInfo.authDataFlags;
            stfSgInfo.consoleRegion = llSgInfo.consoleRegion;
            stfSgInfo.dwPrivileges0 = llSgInfo.dwPrivileges0;
            stfSgInfo.dwPrivileges1 = llSgInfo.dwPrivileges1;
            stfSgInfo.dwPrivileges2 = llSgInfo.dwPrivileges2;
            stfSgInfo.dwPrivileges3 = llSgInfo.dwPrivileges3;
            stfSgInfo.dwPrivileges4 = llSgInfo.dwPrivileges4;
            stfSgInfo.dwPrivileges5 = llSgInfo.dwPrivileges5;
            stfSgInfo.dwPrivileges6 = llSgInfo.dwPrivileges6;
            stfSgInfo.dwPrivileges7 = llSgInfo.dwPrivileges7;
            stfSgInfo.dwServiceID0 = llSgInfo.dwServiceID0;
            stfSgInfo.dwServiceID1 = llSgInfo.dwServiceID1;
            stfSgInfo.dwServiceID2 = llSgInfo.dwServiceID2;
            stfSgInfo.dwServiceID3 = llSgInfo.dwServiceID3;
            stfSgInfo.inaSg = llSgInfo.inaSg;
            stfSgInfo.ipaI = llSgInfo.ipaI;
            stfSgInfo.ipportI = llSgInfo.ipportI;
            stfSgInfo.key00 = llSgInfo.key00;
            stfSgInfo.key01 = llSgInfo.key01;
            stfSgInfo.key02 = llSgInfo.key02;
            stfSgInfo.key03 = llSgInfo.key03;
            stfSgInfo.key04 = llSgInfo.key04;
            stfSgInfo.key05 = llSgInfo.key05;
            stfSgInfo.key06 = llSgInfo.key06;
            stfSgInfo.key07 = llSgInfo.key07;
            stfSgInfo.key08 = llSgInfo.key08;
            stfSgInfo.key09 = llSgInfo.key09;
            stfSgInfo.key10 = llSgInfo.key10;
            stfSgInfo.key11 = llSgInfo.key11;
            stfSgInfo.key12 = llSgInfo.key12;
            stfSgInfo.key13 = llSgInfo.key13;
            stfSgInfo.key14 = llSgInfo.key14;
            stfSgInfo.key15 = llSgInfo.key15;
            stfSgInfo.languageID = llSgInfo.languageID;
            stfSgInfo.liNonce = llSgInfo.liNonce;
            stfSgInfo.machinePuid = llSgInfo.machinePuid;
            stfSgInfo.mediaID = llSgInfo.mediaID;
            stfSgInfo.port = llSgInfo.port;
            stfSgInfo.SpiSg = llSgInfo.SpiSg;
            stfSgInfo.titleId = llSgInfo.titleId;
            stfSgInfo.titleRegion = llSgInfo.titleRegion;
            stfSgInfo.titleVersion = llSgInfo.titleVersion;
            stfSgInfo.UserExists = llSgInfo.UserExists;
            stfSgInfo.userFlag0 = llSgInfo.userFlag0;
            stfSgInfo.userFlag1 = llSgInfo.userFlag1;
            stfSgInfo.userFlag2 = llSgInfo.userFlag2;
            stfSgInfo.userFlag3 = llSgInfo.userFlag3;
            stfSgInfo.userPuid0 = llSgInfo.userPuid0;
            stfSgInfo.userPuid1 = llSgInfo.userPuid1;
            stfSgInfo.userPuid2 = llSgInfo.userPuid2;
            stfSgInfo.userPuid3 = llSgInfo.userPuid3;
            stfSgInfo.userTrust0 = llSgInfo.userTrust0;
            stfSgInfo.userTrust1 = llSgInfo.userTrust1;
            stfSgInfo.userTrust2 = llSgInfo.userTrust2;
            stfSgInfo.userTrust3 = llSgInfo.userTrust3;
            stfSgInfo.wBuildNumber = llSgInfo.wBuildNumber;
            stfSgInfo.wMajorVersion = llSgInfo.wMajorVersion;
            stfSgInfo.wMinorVersion = llSgInfo.wMinorVersion;
            stfSgInfo.wNumDwordServices = llSgInfo.wNumDwordServices;
            stfSgInfo.wNumPrivileges = llSgInfo.wNumPrivileges;
            stfSgInfo.wQFENumber = llSgInfo.wQFENumber;

            return stfSgInfo;
        }

        static public explicit operator live.protocol.proxy.CSGInfo(CSGInfo llSgInfo)
        {
            live.protocol.proxy.CSGInfo pSgInfo = new live.protocol.proxy.CSGInfo();

            pSgInfo.altTitleId0 = llSgInfo.altTitleId0;
            pSgInfo.altTitleId1 = llSgInfo.altTitleId1;
            pSgInfo.altTitleId2 = llSgInfo.altTitleId2;
            pSgInfo.altTitleId3 = llSgInfo.altTitleId3;
            pSgInfo.authDataFlags = llSgInfo.authDataFlags;
            pSgInfo.consoleRegion = llSgInfo.consoleRegion;
            pSgInfo.dwPrivileges0 = llSgInfo.dwPrivileges0;
            pSgInfo.dwPrivileges1 = llSgInfo.dwPrivileges1;
            pSgInfo.dwPrivileges2 = llSgInfo.dwPrivileges2;
            pSgInfo.dwPrivileges3 = llSgInfo.dwPrivileges3;
            pSgInfo.dwPrivileges4 = llSgInfo.dwPrivileges4;
            pSgInfo.dwPrivileges5 = llSgInfo.dwPrivileges5;
            pSgInfo.dwPrivileges6 = llSgInfo.dwPrivileges6;
            pSgInfo.dwPrivileges7 = llSgInfo.dwPrivileges7;
            pSgInfo.dwServiceID0 = llSgInfo.dwServiceID0;
            pSgInfo.dwServiceID1 = llSgInfo.dwServiceID1;
            pSgInfo.dwServiceID2 = llSgInfo.dwServiceID2;
            pSgInfo.dwServiceID3 = llSgInfo.dwServiceID3;
            pSgInfo.inaSg = llSgInfo.inaSg;
            pSgInfo.ipaI = llSgInfo.ipaI;
            pSgInfo.ipportI = llSgInfo.ipportI;
            pSgInfo.key00 = llSgInfo.key00;
            pSgInfo.key01 = llSgInfo.key01;
            pSgInfo.key02 = llSgInfo.key02;
            pSgInfo.key03 = llSgInfo.key03;
            pSgInfo.key04 = llSgInfo.key04;
            pSgInfo.key05 = llSgInfo.key05;
            pSgInfo.key06 = llSgInfo.key06;
            pSgInfo.key07 = llSgInfo.key07;
            pSgInfo.key08 = llSgInfo.key08;
            pSgInfo.key09 = llSgInfo.key09;
            pSgInfo.key10 = llSgInfo.key10;
            pSgInfo.key11 = llSgInfo.key11;
            pSgInfo.key12 = llSgInfo.key12;
            pSgInfo.key13 = llSgInfo.key13;
            pSgInfo.key14 = llSgInfo.key14;
            pSgInfo.key15 = llSgInfo.key15;
            pSgInfo.languageID = llSgInfo.languageID;
            pSgInfo.liNonce = llSgInfo.liNonce;
            pSgInfo.machinePuid = llSgInfo.machinePuid;
            pSgInfo.mediaID = llSgInfo.mediaID;
            pSgInfo.port = llSgInfo.port;
            pSgInfo.SpiSg = llSgInfo.SpiSg;
            pSgInfo.titleId = llSgInfo.titleId;
            pSgInfo.titleRegion = llSgInfo.titleRegion;
            pSgInfo.titleVersion = llSgInfo.titleVersion;
            pSgInfo.UserExists = llSgInfo.UserExists;
            pSgInfo.userFlag0 = llSgInfo.userFlag0;
            pSgInfo.userFlag1 = llSgInfo.userFlag1;
            pSgInfo.userFlag2 = llSgInfo.userFlag2;
            pSgInfo.userFlag3 = llSgInfo.userFlag3;
            pSgInfo.userPuid0 = llSgInfo.userPuid0;
            pSgInfo.userPuid1 = llSgInfo.userPuid1;
            pSgInfo.userPuid2 = llSgInfo.userPuid2;
            pSgInfo.userPuid3 = llSgInfo.userPuid3;
            pSgInfo.userTrust0 = llSgInfo.userTrust0;
            pSgInfo.userTrust1 = llSgInfo.userTrust1;
            pSgInfo.userTrust2 = llSgInfo.userTrust2;
            pSgInfo.userTrust3 = llSgInfo.userTrust3;
            pSgInfo.wBuildNumber = llSgInfo.wBuildNumber;
            pSgInfo.wMajorVersion = llSgInfo.wMajorVersion;
            pSgInfo.wMinorVersion = llSgInfo.wMinorVersion;
            pSgInfo.wNumDwordServices = llSgInfo.wNumDwordServices;
            pSgInfo.wNumPrivileges = llSgInfo.wNumPrivileges;
            pSgInfo.wQFENumber = llSgInfo.wQFENumber;

            return pSgInfo;
        }

        static public explicit operator CSGInfo(live.protocol.proxy.CSGInfo llSgInfo)
        {
            CSGInfo pSgInfo = new CSGInfo();

            pSgInfo.altTitleId0 = llSgInfo.altTitleId0;
            pSgInfo.altTitleId1 = llSgInfo.altTitleId1;
            pSgInfo.altTitleId2 = llSgInfo.altTitleId2;
            pSgInfo.altTitleId3 = llSgInfo.altTitleId3;
            pSgInfo.authDataFlags = llSgInfo.authDataFlags;
            pSgInfo.consoleRegion = llSgInfo.consoleRegion;
            pSgInfo.dwPrivileges0 = llSgInfo.dwPrivileges0;
            pSgInfo.dwPrivileges1 = llSgInfo.dwPrivileges1;
            pSgInfo.dwPrivileges2 = llSgInfo.dwPrivileges2;
            pSgInfo.dwPrivileges3 = llSgInfo.dwPrivileges3;
            pSgInfo.dwPrivileges4 = llSgInfo.dwPrivileges4;
            pSgInfo.dwPrivileges5 = llSgInfo.dwPrivileges5;
            pSgInfo.dwPrivileges6 = llSgInfo.dwPrivileges6;
            pSgInfo.dwPrivileges7 = llSgInfo.dwPrivileges7;
            pSgInfo.dwServiceID0 = llSgInfo.dwServiceID0;
            pSgInfo.dwServiceID1 = llSgInfo.dwServiceID1;
            pSgInfo.dwServiceID2 = llSgInfo.dwServiceID2;
            pSgInfo.dwServiceID3 = llSgInfo.dwServiceID3;
            pSgInfo.inaSg = llSgInfo.inaSg;
            pSgInfo.ipaI = llSgInfo.ipaI;
            pSgInfo.ipportI = llSgInfo.ipportI;
            pSgInfo.key00 = llSgInfo.key00;
            pSgInfo.key01 = llSgInfo.key01;
            pSgInfo.key02 = llSgInfo.key02;
            pSgInfo.key03 = llSgInfo.key03;
            pSgInfo.key04 = llSgInfo.key04;
            pSgInfo.key05 = llSgInfo.key05;
            pSgInfo.key06 = llSgInfo.key06;
            pSgInfo.key07 = llSgInfo.key07;
            pSgInfo.key08 = llSgInfo.key08;
            pSgInfo.key09 = llSgInfo.key09;
            pSgInfo.key10 = llSgInfo.key10;
            pSgInfo.key11 = llSgInfo.key11;
            pSgInfo.key12 = llSgInfo.key12;
            pSgInfo.key13 = llSgInfo.key13;
            pSgInfo.key14 = llSgInfo.key14;
            pSgInfo.key15 = llSgInfo.key15;
            pSgInfo.languageID = llSgInfo.languageID;
            pSgInfo.liNonce = llSgInfo.liNonce;
            pSgInfo.machinePuid = llSgInfo.machinePuid;
            pSgInfo.mediaID = llSgInfo.mediaID;
            pSgInfo.port = llSgInfo.port;
            pSgInfo.SpiSg = llSgInfo.SpiSg;
            pSgInfo.titleId = llSgInfo.titleId;
            pSgInfo.titleRegion = llSgInfo.titleRegion;
            pSgInfo.titleVersion = llSgInfo.titleVersion;
            pSgInfo.UserExists = llSgInfo.UserExists;
            pSgInfo.userFlag0 = llSgInfo.userFlag0;
            pSgInfo.userFlag1 = llSgInfo.userFlag1;
            pSgInfo.userFlag2 = llSgInfo.userFlag2;
            pSgInfo.userFlag3 = llSgInfo.userFlag3;
            pSgInfo.userPuid0 = llSgInfo.userPuid0;
            pSgInfo.userPuid1 = llSgInfo.userPuid1;
            pSgInfo.userPuid2 = llSgInfo.userPuid2;
            pSgInfo.userPuid3 = llSgInfo.userPuid3;
            pSgInfo.userTrust0 = llSgInfo.userTrust0;
            pSgInfo.userTrust1 = llSgInfo.userTrust1;
            pSgInfo.userTrust2 = llSgInfo.userTrust2;
            pSgInfo.userTrust3 = llSgInfo.userTrust3;
            pSgInfo.wBuildNumber = llSgInfo.wBuildNumber;
            pSgInfo.wMajorVersion = llSgInfo.wMajorVersion;
            pSgInfo.wMinorVersion = llSgInfo.wMinorVersion;
            pSgInfo.wNumDwordServices = llSgInfo.wNumDwordServices;
            pSgInfo.wNumPrivileges = llSgInfo.wNumPrivileges;
            pSgInfo.wQFENumber = llSgInfo.wQFENumber;

            return pSgInfo;
        }

        public bool IsUserPresent(ulong xuid)
        {
            if (xuid != 0)
            {
                if (xuid == userPuid0) return true;
                if (xuid == userPuid1) return true;
                if (xuid == userPuid2) return true;
                if (xuid == userPuid3) return true;
            }

            return false;
        }

        public byte[] SignWithKey(byte[] data, int offset, int count)
        {
            System.Security.Cryptography.HMACSHA1 shaM = new System.Security.Cryptography.HMACSHA1(Key);

            shaM.ComputeHash(data, offset, count);

            return shaM.Hash;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\PayloadRequest.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.IO;
using System.Net;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;
using System.Reflection;
using live.common;

namespace live.protocol
{
    public enum PayloadType
    {
        Binary,
        Soap12,
        HttpPOST
    }

    public class PayloadClientAttribute : Attribute
    {
        private Type _clientType;

        public Type ClientType
        {
            get { return _clientType; }
            set { _clientType = value; }
        }

        private PayloadType _payloadType;

        public PayloadType PayloadType
        {
            get { return _payloadType; }
            set { _payloadType = value; }
        }

        public PayloadClientAttribute(Type clientType, PayloadType payloadType)
        {
            _clientType = clientType;
            _payloadType = payloadType;
        }

    }

    public class PayloadActionAttribute : Attribute
    {
        private string _namespace;
        private string _action;
        private string _baseURI;

        public string BaseURI
        {
            get { return _baseURI; }
            set { _baseURI = value; }
        }


        public string Action
        {
            get { return _action; }
            set { _action = value; }
        }


        public string Namespace
        {
            get { return _namespace; }
            set { _namespace = value; }
        }

        public PayloadActionAttribute(string baseURI, string action, string nameSpace)
        {
            _baseURI = baseURI;
            _action = action;
            _namespace = nameSpace;
        }

        /// <summary>
        /// This isn't valid for Soap 1.2
        /// </summary>
        /// <param name="baseURI"></param>
        /// <param name="action"></param>
        public PayloadActionAttribute(string baseURI, string action) : this(baseURI, action, String.Empty)
        {
        }


        internal PayloadActionAttribute()
        {
        }

    }

    // Added to support an extra Node in the SOAP body 
    public class PayloadRequestNameAttribute : Attribute
    {
        public string Name = "";

        public PayloadRequestNameAttribute() { }

        public PayloadRequestNameAttribute(string name)
        {
            Name = name;
        }
    }


    public abstract class PayloadRequest : XRLRequestObject2
    {
        private PayloadType _payloadType = PayloadType.Binary;
        private PayloadActionAttribute _payloadAction = null;
        private PayloadRequestNameAttribute _payloadRequestName = null;

        //Reflection Caches
        private static Dictionary<String, XmlSerializer> _serializers = new Dictionary<string, XmlSerializer>();
        private static Dictionary<Type, Dictionary<Type, PayloadType>> _clientpayloads = new Dictionary<Type, Dictionary<Type, PayloadType>>();
        private static Dictionary<Type, PayloadActionAttribute> _payloadActions = new Dictionary<Type, PayloadActionAttribute>();
        private static Dictionary<String, PayloadParamAttribute> _payloadParams = new Dictionary<string, PayloadParamAttribute>();

        [WireInfo(Serialize = false)]
        public bool UseSSL = false;




        public void SetPayloadType(PayloadType type)
        {
            _payloadType = type;
        }

        public void SetPayloadTypeFor(IClient client, PayloadResponse resp)
        {
            Type clientType = client.GetType();
            Dictionary<Type, PayloadType> payloadTypes;

            lock (_clientpayloads)
            {
                if (!_clientpayloads.TryGetValue(this.GetType(), out payloadTypes))
                {
                    payloadTypes = new Dictionary<Type, PayloadType>();
                    foreach (object attr in this.GetType().GetCustomAttributes(typeof(PayloadClientAttribute), true))
                    {
                        payloadTypes.Add(((PayloadClientAttribute)attr).ClientType, ((PayloadClientAttribute)attr).PayloadType);
                    }

                    _clientpayloads.Add(this.GetType(), payloadTypes);
                }                
            }
            
            PayloadType pType;
            if (payloadTypes.TryGetValue(clientType, out pType))
            {
                this.SetPayloadType(pType);
                if (resp != null)
                {
                    resp.SetPayloadType(pType);
                }
            }
        }

        public void SetWebHeaders(WebHeaderCollection headers)
        {
            switch (_payloadType)
            {
                case PayloadType.Binary:
                    break;
                case PayloadType.Soap12:
                    //Content-Type: application/soap+xml; charset=utf-8; action="urn:schemas-xbox-com:billing-data/FindMediaInstanceUrls"
                    headers.Add("Content-Type", "application/soap+xml; charset=utf-8; action=\"" + _payloadAction.Namespace + "/" + _payloadAction.Action + "\"");
                    break;
                case PayloadType.HttpPOST:
                    headers.Add("Content-Type", "application/x-www-form-urlencoded");
                    break;
                default: throw new Exception("Unknown PayloadType: " + _payloadType);

            }
        }


        public override void WriteStream(System.IO.BinaryWriter binaryWriter)
        {

            switch (_payloadType)
            {
                case PayloadType.Binary:
                    base.WriteStream(binaryWriter);
                    break;
                case PayloadType.HttpPOST:
                    binaryWriter.Write(Encoding.UTF8.GetBytes(BuildHttpRequest("&")));
                    break;
                case PayloadType.Soap12:
                    binaryWriter.Write(Encoding.UTF8.GetBytes(ToSoap12Body()));
                    break;
                default:
                    throw new Exception("Can not covert payload of type " + _payloadType);

            }

        }

        private void LoadPayloadAction()
        {
            if (_payloadAction == null)
            {
                _payloadAction = GetPayloadAction(this);
            }
        }

        private void LoadPayloadRequestName()
        {
            if (_payloadRequestName == null)
            {
                object[] classAttrs = 
                    this.GetType().GetCustomAttributes(
                        typeof(PayloadRequestNameAttribute),
                        true);
                if (classAttrs.Length > 0)
                {
                    _payloadRequestName = 
                        (PayloadRequestNameAttribute)classAttrs[0];
                }
                else
                {
                    _payloadRequestName = new PayloadRequestNameAttribute();
                }                
            }
        }


        private static PayloadActionAttribute GetPayloadAction(PayloadRequest req) 
        {
            Type thisType = req.GetType();
            PayloadActionAttribute action;

            lock (_payloadActions)
            {
                if(!_payloadActions.TryGetValue(thisType, out action)) 
                {
                    object[] classAttrs = thisType.GetCustomAttributes(typeof(PayloadActionAttribute), true);
                    if (classAttrs.Length > 0)
                    {
                        action = (PayloadActionAttribute)classAttrs[0];
                    }
                    else
                    {
                        action = new PayloadActionAttribute();
                    }
                    
                    _payloadActions.Add(thisType, action);
                }
            }
            return action;
        }

        private static PayloadParamAttribute GetPayloadParam(PayloadRequest req, MemberInfo minfo)
        {
            string key = req.GetType() + "::" + minfo.Name;
            PayloadParamAttribute param;

            lock (_payloadParams)
            {
                if (!_payloadParams.TryGetValue(key, out param))
                {
                    object[] attrs = minfo.GetCustomAttributes(typeof(PayloadParamAttribute), true);
                    if (attrs.Length > 0)
                    {
                        param = attrs[0] as PayloadParamAttribute;
                    }
                    else
                    {
                        param = null;
                    }
                                    
                    _payloadParams.Add(key, param);
                }
            }
            return param;
        }

        private string ToSoap12Body()
        {
            StringBuilder soap = new StringBuilder(3000);
            soap.Append("<?xml version=\"1.0\" encoding=\"utf-8\"?><soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"><soap:Body>");

            LoadPayloadAction();
            //<FindMediaInstanceUrls xmlns=\"urn:schemas-xbox-com:billing-data\">

            LoadPayloadRequestName();

            soap.Append("<");
            soap.Append(_payloadAction.Action);
            soap.Append(" xmlns=\"");
            soap.Append(_payloadAction.Namespace);
            soap.Append("\">");

            //XmlNamespaceManager nsMgr = new XmlNamespaceManager();
            //nsMgr.AddNamespace("prefix", _payloadAction.Namespace);

            if (_payloadRequestName.Name != "")
            {
                soap.Append("<" + _payloadRequestName.Name + ">");
            }

            System.Reflection.FieldInfo[] fieldInfos = this.GetType().GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo fieldInfo in fieldInfos)
            {
                // Get the WebResponseParamAttribute (if any)
                PayloadParamAttribute param = GetPayloadParam(this, fieldInfo);
                if (param == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }
                
                if (string.IsNullOrEmpty(param.XPath))
                {
                    param.XPath = fieldInfo.Name;
                }

                soap.Append(SerializeType(fieldInfo.FieldType, fieldInfo.GetValue(this), param.XPath));

            }

            System.Reflection.PropertyInfo[] propInfos = this.GetType().GetProperties(
    System.Reflection.BindingFlags.Instance |
    System.Reflection.BindingFlags.Public
    );

            foreach (System.Reflection.PropertyInfo propInfo in propInfos)
            {
                // Get the WebResponseParamAttribute (if any)
                PayloadParamAttribute param = GetPayloadParam(this, propInfo);
                if (param == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }


                if (string.IsNullOrEmpty(param.XPath))
                {
                    param.XPath = propInfo.Name;
                }

                soap.Append(SerializeType(propInfo.PropertyType, propInfo.GetValue(this, null), param.XPath));

            }

            if (_payloadRequestName.Name != "")
            {
                soap.Append("</" + _payloadRequestName.Name + ">");
            }

            soap.Append("</");
            soap.Append(_payloadAction.Action);
            soap.Append(">");
            soap.Append("</soap:Body></soap:Envelope>");
            return soap.ToString();
        }

        private string SerializeType(Type type, object obj, string name)
        {
            StringWriter sw = new StringWriter();
            XmlSerializer serializer = GetSerializer(type, name);
            serializer.Serialize(sw, obj);
            sw.Flush();
            string xml = sw.ToString();

            int index = xml.IndexOf("?>");
            if (index != -1)
            {
                xml = xml.Substring(index + 2);
            }
            return xml;
        }

        private static XmlSerializer GetSerializer(Type type, string name)
        {
            string key = type.FullName + "::" + name;
            XmlSerializer serializer;

            lock (_serializers)
            {                   
                if (!_serializers.TryGetValue(key, out serializer))
                {
                    
                    XmlReflectionImporter xri = new XmlReflectionImporter();
                    XmlTypeMapping map = xri.ImportTypeMapping(type, new XmlRootAttribute(name));
                    serializer = new XmlSerializer(map);
                    _serializers.Add(key, serializer);
                }
            }

            return serializer;
        }

        public override string GetRelativeUrl()
        {
            switch (_payloadType)
            {
                case PayloadType.HttpPOST:
                    LoadPayloadAction();
                    return _payloadAction.BaseURI + "/" + _payloadAction.Action;
                case PayloadType.Binary:
                    return Xrl;
                case PayloadType.Soap12:
                    LoadPayloadAction();
                    return _payloadAction.BaseURI;
                default:
                    throw new Exception("Do not Know relative URL of payload of type " + _payloadType);
            }
        }

        private static void WriteNameAndValue(List<StringPair> filterList, Type type,
    PayloadParamAttribute reqParam, string name, object fieldValue)
        {
            string value;
            if (type.IsEnum)
            {
                value = Enum.Format(type, Enum.Parse(
                    type, fieldValue.ToString()), "d");
            }
            else
            {
                value = String.Format("{0}", fieldValue);
            }

            // Stand-alone pairs are written out like: "ClientType=Zune"
            if (reqParam.ParamType == PayloadParamType.StandAlone)
            {
                filterList.Add(new StringPair(name, value));
            }
            // NameValue pairs are written out like: "Names=Locale&Values=en-US"
            else if (reqParam.ParamType == PayloadParamType.NameValuePair)
            {
                filterList.Add(new StringPair("Names", name));
                filterList.Add(new StringPair("Values", value));
            }
            else
            {
                throw new Exception("Unknown WebRequestParamType: " + reqParam.ParamType);
            }
        }


        public List<StringPair> WebRequestToList()
        {
            List<StringPair> filterList = new List<StringPair>();

            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo fieldInfo in fieldInfos)
            {
                PayloadParamAttribute reqParam = GetPayloadParam(this, fieldInfo);
                if (reqParam == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }
                
                if (string.IsNullOrEmpty(reqParam.XPath))
                {
                    reqParam.XPath = fieldInfo.Name;
                }
                string name = reqParam.XPath;
                object fieldValue = fieldInfo.GetValue(this);

                if (fieldValue != null)
                {
                    // Crack open Lists and Arrays and write out their contents
                    Array array = null;
                    if (fieldInfo.FieldType.IsGenericType)
                    {
                        System.Reflection.MethodInfo toArrayMeth = fieldInfo.FieldType.GetMethod("ToArray");
                        array = (Array)toArrayMeth.Invoke(fieldValue, null);
                    }
                    if (fieldInfo.FieldType.IsArray)
                    {
                        array = (Array)fieldValue;
                    }
                    if (array != null)
                    {
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= array.GetUpperBound(0); i++)
                        {
                            object elem = array.GetValue(i);
                            string value = String.Format("{0}", elem);

                            WriteNameAndValue(filterList, fieldInfo.FieldType, reqParam, name, elem);
                        }
                    }
                    // If it's not an array, just add the property name and value
                    else
                    {
                        WriteNameAndValue(filterList, fieldInfo.FieldType, reqParam, name, fieldValue);
                    }
                }
            }

            System.Reflection.PropertyInfo[] propInfos = thisType.GetProperties(
    System.Reflection.BindingFlags.Instance |
    System.Reflection.BindingFlags.Public
    );

            foreach (System.Reflection.PropertyInfo propInfo in propInfos)
            {
                PayloadParamAttribute reqParam = GetPayloadParam(this, propInfo);
                if (reqParam == null)
                {
                    // Ignore any field not marked with a WebPayloadParam attribute
                    continue;
                }

                if (string.IsNullOrEmpty(reqParam.XPath))
                {
                    reqParam.XPath = propInfo.Name;
                }
                string name = reqParam.XPath;
                object propValue = propInfo.GetValue(this, null);

                if (propValue != null)
                {
                    // Crack open Lists and Arrays and write out their contents
                    Array array = null;
                    if (propInfo.PropertyType.IsGenericType)
                    {
                        System.Reflection.MethodInfo toArrayMeth = propInfo.PropertyType.GetMethod("ToArray");
                        array = (Array)toArrayMeth.Invoke(propValue, null);
                    }
                    if (propInfo.PropertyType.IsArray)
                    {
                        array = (Array)propValue;
                    }
                    if (array != null)
                    {
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= array.GetUpperBound(0); i++)
                        {
                            object elem = array.GetValue(i);
                            string value = String.Format("{0}", elem);

                            WriteNameAndValue(filterList, propInfo.PropertyType, reqParam, name, elem);
                        }
                    }
                    // If it's not an array, just add the property name and value
                    else
                    {
                        WriteNameAndValue(filterList, propInfo.PropertyType, reqParam, name, propValue);
                    }
                }
            }


            return filterList;
        }

        protected virtual string BuildHttpRequest(string seperator)
        {
            string request = "";
            List<StringPair> list = WebRequestToList();
            foreach (StringPair pair in list)
            {
                request += pair.Key + "=" + pair.Value + seperator;
            }
            if (request.EndsWith(seperator))
            {
                request = request.Remove(request.Length - 1);
            }
            return request;
        }
    }

    public abstract class PayloadRequestWithSSL : PayloadRequest
    {
        public PayloadRequestWithSSL()
            : base()
        {
            this.UseSSL = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\sgprot.cs ===
// 
// SgProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SG Service Integration
// Xbox Online Service
// 
// Author: phansen
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

using live.common;

//[assembly: XomAreaDefinition(XomAreaName.SGProxy)]


namespace live.protocol 
{
    public class SgDefs
    {
        public const int XONLINE_MAX_LOGON_USERS                = 4;
        public const int XONLINE_MAX_ALTERNATE_TITLE_ID         = 4;
        public const int XONLINE_KEY_LENGTH                     = 16;
        public const int XONLINE_NUM_PRIVILEGE_DWORDS           = 8;
        public const int XONLINE_MAX_DWORD_SERVICEIDS           = 4;
    }

    //
    // Structure Representing the SGADDR info
    //  Maps to SGADDR in xonline.x
    //  
    public class SGADDR : WireData
    {
        public uint                 inaSg;
        public uint                 dwSpiSg;
        public ulong                qwXboxId;
        public uint                 abReserved;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(inaSg);
            binaryWriter.Write(dwSpiSg);
            binaryWriter.Write(qwXboxId);
            binaryWriter.Write(abReserved);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                inaSg = (uint)binaryReader.ReadInt32();
                dwSpiSg = (uint)binaryReader.ReadInt32();
                qwXboxId = (ulong)binaryReader.ReadInt64();
                abReserved = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_24, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }
    }

    public class XBOX_LIBRARY_VERSION : WireData
    {
        public ushort               wMajorVersion;
        public ushort               wMinorVersion;
        public ushort               wBuildNumber;
        public ushort               wQFENumber;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wMajorVersion);
            binaryWriter.Write(wMinorVersion);
            binaryWriter.Write(wBuildNumber);
            binaryWriter.Write(wQFENumber);
         }

    }

    public class XUID : WireData
    {
        public ulong                qwUserId;                   // or qwTeamId
        public uint                 dwUserFlags;                // The high 16 bits should come from the UODB User Table.
    }

    public enum SG_MSG_TYPES : ushort
    {
        // Definitions (0x47 is 'G') ---------------------------------------------------------
        SGMSG_TYPE_KICK_REQ         = 0x4705,  // CSgMsgKickReq
        SGMSG_TYPE_KICK_REP         = 0x4706,  // CSgMsgKickRep
        SGMSG_TYPE_XBTOXB_FORWARD   = 0x470A,  // CSgMsgXbToXbForward
        SGMSG_TYPE_SET_QVALS_LAZY   = 0x470B,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_PUSH   = 0x470C,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_REP    = 0x470D,  // CSgMsgSetQValsRep
        SGMSG_TYPE_SPIDATA_REQ      = 0x4710,  // CSgMsgSpiReq
        SGMSG_TYPE_SPIDATA_REP      = 0x4711,  // CSgMsgSpiRep
        SGMSG_TYPE_NOTIFY_CLI_DEL   = 0x4712,  // CSgMsgNotifyCliDelete
        SGMSG_TYPE_NOTIFY_CLI_UPD   = 0x4713,  // CSgMsgNotifyCliUpdate
        SGMSG_TYPE_NOTIFY_CLI_TCHG  = 0x4714,  // CSgMsgNotifyCliTitleChange

        SGMSG_TYPE_SPIDATA          = 0x4782,  // CSgMsgSpiData in the payload
        SGMSG_TYPE_AUTHDATA         = 0x4783,  // CAuthData in the payload
    }

    // Base class that other SG messages derive from
    //
    public class CSgMsgHdr : WireData
    {
        // WireData requires a default constructor with no args for deserialization, so this must exist
        public CSgMsgHdr()
        {
        }
        
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        public CSgMsgHdr( SG_MSG_TYPES msgType, ushort size )
        {
            _wType = (ushort) msgType;
            _cbEnt = size;
        }

        public ushort           _wType;                         // See SGMSG_TYPE_* above
        public ushort           _cbEnt;                         // Size of this entry (including header)

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                _wType = (ushort)binaryReader.ReadInt16();
                _cbEnt = (ushort)binaryReader.ReadInt16();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_25, 
                    "Reached end of stream trying to read CSgMsgHdr", e);
            }
            return this;
        }

    }

    public class CAuthData : WireData
    {
        public CAuthData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_AUTHDATA, 218 );
            wAuthDataVersion = 3;
            wAuthDataSize = 214;
        }

        public CSgMsgHdr            header;
        public ushort               wAuthDataVersion;
        public ushort               wAuthDataSize;
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint                 dwTitleID;
        public uint                 dwTitleVersion;
        public uint                 dwTitleRegion;
        public uint                 dwConsoleRegion;
        public uint                 dwMediaID;
        public uint                 dwLanguageID;
        public uint                 dwAuthDataFlags;
        public ushort               wNumPrivileges;
        [WireInfo(ArraySize=SgDefs.XONLINE_NUM_PRIVILEGE_DWORDS)]
        public uint[]               dwPrivileges;
        public ulong                qwXboxID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public XUID[]               users;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public float[]              afltTrustFactor;
        public uint                 wNumDwordServices;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]               dwServiceID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_ALTERNATE_TITLE_ID)]
        public uint[]               dwAltTitleID;
        [WireInfo(ArraySize=SgDefs.XONLINE_KEY_LENGTH)]
        public byte[]               abKey;
    }

    public class CSgMsgSpiData : WireData
    {
        public CSgMsgSpiData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA, 54 );
        }

        public CSgMsgHdr            header;
        public ushort               _ipportI;                   // IP port of the client on the Internet
        public uint                 _ipaI;                      // IP address of the client on the Internet
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ushort               _wVersionKeyEx;             // KeyEx version of the client
        public ushort               _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        public long                 _liNonce;                   // A random nonce associated with this session
        public long                 _liTimeInit;                // FILETIME marking session initiation
        public uint                 _fCs;                       // TRUE if SG is providing connection services
    }

    public class CSgMsgSpiReq : WireData
    {
        public CSgMsgSpiReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ, 14 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Request number from requester
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
    }

    public class CSgMsgSpiRep : WireData
    {
        public CSgMsgSpiRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REP, 15 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Copy of _dwReqNum from request
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
        public bool                 _fNotFound;                 // TRUE if client not found (no auth-data enclosed)

        [WireInfo(Serialize=false)]
        public CSgMsgSpiData        _spiData;                   // only present if _fNotFound is FALSE

        [WireInfo(Serialize=false)]
        public CAuthData            _authData;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( !_fNotFound )
            {
                _spiData = new CSgMsgSpiData();
                _spiData.ReadStream( binaryReader );
                _authData = new CAuthData();
                _authData.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( !_fNotFound )
            {
                _spiData.WriteStream( binaryWriter );
                _authData.WriteStream( binaryWriter );
            }
        }
    }

    public class CSgMsgSetQValsReq : WireData
    {
        public CSgMsgSetQValsReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_LAZY, 36 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context to be returned in reply

        // The rest of this entry contains a packed series of CQVal structures.
        [WireInfo(Serialize=false)]
        public uint[]               _qvals;                     // TODO: If anyone wants to use this they need to add appropriate Read/WriteStream overrides

        public void SetPush()
        {
            header._wType = (ushort) SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_PUSH;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( header._cbEnt > 36 )
            {
                ushort cbQVals = (ushort)( header._cbEnt - 36 );
                ushort cQVals = (ushort)( cbQVals / 4 );
                _qvals = new uint[ cQVals ];
                for( int iQVal = 0; iQVal < cQVals; iQVal++ )
                {
                    _qvals[ iQVal ] = binaryReader.ReadUInt32();
                }
            }
            else
            {
                // Make _qvals.Length valid even when there aren't any
                _qvals = new uint[ 0 ];
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            header._cbEnt = (ushort)( 32 + ( _qvals.Length * 4 ) );
        }
    }

    public class CSgMsgSetQValsRep : WireData
    {
        public CSgMsgSetQValsRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_REP, 38 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context from corresponding request
        public bool                 _fNotFound;                 // TRUE if client not found
        public bool                 _fNoSuchUser;               // TRUE if SG doesn't know about qwUserId
    }

    public class CSgMsgKickReq : WireData
    {
        public CSgMsgKickReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REQ, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client to kick
    }

    public class CSgMsgKickRep : WireData
    {
        public CSgMsgKickRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REP, 25 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that was kicked
        public bool                 _fNotFound;                 // TRUE if client not found
    }

    public class CSgMsgXbToXbForward : WireData
    {
        public CSgMsgXbToXbForward()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_XBTOXB_FORWARD, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the target client

        // The rest of this entry contains the actual message being forwarded.
    }

    // If _sgaddr._dwSpiSg and _sgaddr._qwXboxId are zero, then the whole SG is going offline
    public class CSgMsgNotifyCliDelete : XRLObject2
    {
        public CSgMsgNotifyCliDelete()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL, 28 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that is going offline
        public uint                 _dwTitleId;                 // The title the client was last in

        public override int Size()
        {
            return 28;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwTitleId = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_26, 
                    "Reached end of stream trying to read CSgMsgNotifyCliDelete", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliUpdate : XRLObject2
    {
        public CSgMsgNotifyCliUpdate()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_UPD, 310 );
            _sgaddr = new SGADDR();
            _rgbTitleData = new byte[ 256 ];
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr; // SGADDR of the client that was updated
        public ulong                _qwUserId;
        public ulong                _qwXnkid;
        public uint                 _dwAuthFlags;
        public uint                 _dwState;
        public uint                 _dwTitleId;
        public ushort               _cbTitleData;

        [WireInfo(ArraySize=256)]
        public byte[]               _rgbTitleData;

        public override int Size()
        {
            return 310;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _qwUserId = binaryReader.ReadUInt64();
                _qwXnkid = binaryReader.ReadUInt64();
                _dwAuthFlags = binaryReader.ReadUInt32();
                _dwState = binaryReader.ReadUInt32();
                _dwTitleId = binaryReader.ReadUInt32();
                _cbTitleData = binaryReader.ReadUInt16();
                _rgbTitleData = binaryReader.ReadBytes(256);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_27, 
                    "Reached end of stream trying to read CSgMsgNotifyCliUpdate", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliTitleChange : XRLObject2
    {
        public CSgMsgNotifyCliTitleChange()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG, 32 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;
        public uint                 _dwOldTitleId;
        public uint                 _dwNewTitleId;

        public override int Size()
        {
            return 32;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwOldTitleId = (uint)binaryReader.ReadInt32();
                _dwNewTitleId = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_28, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }

    }

} // namespace xonline.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\StorageConstants.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage 
 * 
 * StorageConstants.cs
 * 
 * Protocol stuff
 * 
 * */

using System;
using System.IO;
using System.Text;
using System.Diagnostics;

namespace live.protocol 
{
    // Protocol Constants
    public class ProtocolConstants
    {
        public const int    sizeSignature           = 100;
        public const int    sizeHash                = 20;
        public const int    maxSizeAttributes       = 256;
        public const int    maxSizeName             = 255;
        public const int    maxSizeDomain           = 63;
        public const ushort accessTokenVersion      = 1;
        public const int    sizeAccessTokenBase     = 48 + sizeSignature;
        public const int    maxAccessTokenSize      = sizeAccessTokenBase + maxSizeName;
        public const int    syncDomainReservedSize  = 64;
        public const int    maxStorageOperations    = 100;
        
        // Temporary constants. Have to transform them into configurable 
        // settings at some point.
        public const int        maxFileSize     = 10*1024*1024;
        public const string     wstStoreApp     = "StoreDb";
    }

    // Storage Operations
    public enum Operation
    {
        Undefined               = 0,
        FileWrite               = 1,
        FileRead                = 2,
        FileRemove              = 3,
        FileEnumerate           = 4
    }

    public enum Allowed: uint
    {
        None                    = 0,
        All                     = 1,
        Owner                   = 2,
        Team                    = 4,
        UserToken               = 8,
        ServiceToken            = 16,
        ServiceAddr             = 32
    }

    // Each of these enumerations is represented by a uint and each should
    // always have an Invalid member that is defined as 1 greater than the
    // the last legal value.  This allows validation to easily be done and
    // not require changes when new legal values are added.

    // Identity Types
    public enum IdType: uint
    {
        Undefined       = 0,
        UserId          = 1,
        GroupId         = 2,
        TournamentId    = 3,
        TitleId         = 4,
        Invalid         = 5
    }

    // Storage Content Types
    public enum ContentType: uint
    {
        ContentPackage          = 0,
        ContentBlob             = 1,
        Invalid                 = 2 
    }

    // Storage Compression Types
    public enum CompressionType: uint
    {
        Uncompressed            = 0,
        NoCompression           = 1,
        LZX                     = 2,
        Invalid                 = 3
    }

    // Storage Flag Types
    public enum FlagType: uint
    {
        TeamTicket              = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\presenceprot.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

using live.common;

//[assembly: XomAreaDefinition(XomAreaName.PresenceProxy)]


namespace live.protocol 
{
    //
    // Enum of message types. 
    //  Maps to Q_MSG_TYPES in xonline.x
    //  
    public enum Q_MSG_TYPES
    {
        //
        // Incoming messages
        //
        QMSG_MIN_REQ_TYPE                  =  0,
        QMSG_HELLO                         =  0,
        QMSG_USER_INFO                     =  1,
        QMSG_ADD                           =  2,
        QMSG_DELETE                        =  3,
        QMSG_DELETE_MATCHES                =  4,
        QMSG_DEAD_XBOX                     =  5,
        QMSG_DEAD_SG                       =  6,
        QMSG_LIST                          =  7,
        QMSG_DEQUEUE                       =  8,
        QMSG_DEAD_USER                     =  9,
        QMSG_WEB_USER_INFO                 = 10,
        QMSG_WEB_PRESENCE                  = 11,
        QMSG_WEB_LIST                      = 12,
        QMSG_ENUM_MESSAGES                 = 13,
        QMSG_MESSAGE_SUMMARY               = 14,
        QMSG_MESSAGE_DETAILS               = 15,
        QMSG_DELETE_MESSAGE                = 16,
        QMSG_SEND_MESSAGE                  = 17,
        QMSG_REVOKE_MESSAGE                = 18,
        QMSG_DELETE_TITLE                  = 19,
        QMSG_ENUM_TITLES                   = 20,
        QMSG_MESSAGE_FLAGS                 = 21,
        QMSG_ENUM_SYSTEM_MESSAGES          = 22,
        QMSG_SYSTEM_MESSAGE_DETAILS        = 23,
        QMSG_DELETE_SYSTEM_MESSAGE         = 24,
        QMSG_SEND_SYSTEM_MESSAGE           = 25,
        QMSG_REVOKE_MESSAGE_EX             = 26,
        QMSG_ENUM_MESSAGES_2               = 27,
        QMSG_MESSAGE_SUMMARY_2             = 28,
        QMSG_MAX_REQ_TYPE                  = 28,

        //
        // Outgoing messages
        //
        QMSG_MIN_REPLY_TYPE                = 100,
        QMSG_LIST_REPLY                    = 100,
        QMSG_WEB_LIST_REPLY                = 101,
        QMSG_ENUM_MESSAGES_REPLY           = 102,
        QMSG_MESSAGE_SUMMARY_REPLY         = 103,
        QMSG_MESSAGE_DETAILS_REPLY         = 104,
        QMSG_DELETE_MESSAGE_REPLY          = 105,
        QMSG_SEND_MESSAGE_REPLY            = 106,
        QMSG_REVOKE_MESSAGE_REPLY          = 107,
        QMSG_DELETE_TITLE_REPLY            = 108,
        QMSG_ENUM_TITLES_REPLY             = 109,
        QMSG_MESSAGE_FLAGS_REPLY           = 110,
        QMSG_ENUM_SYSTEM_MESSAGES_REPLY    = 111,
        QMSG_SYSTEM_MESSAGE_DETAILS_REPLY  = 112,
        QMSG_DELETE_SYSTEM_MESSAGE_REPLY   = 113,
        QMSG_SEND_SYSTEM_MESSAGE_REPLY     = 114,
        QMSG_ENUM_MESSAGES_2_REPLY         = 115,
        QMSG_MESSAGE_SUMMARY_2_REPLY       = 116,
        QMSG_LIST_REPLY_2                  = 117,
        QMSG_MAX_REPLY_TYPE                = 117
    };       


    public enum P_MSG_TYPES
    {
        //
        // Incoming messages
        //
        PMSG_MIN_REQ_TYPE                  = 1000,
        PMSG_HELLO                         = 1000,
        PMSG_ALIVE                         = 1001,
        PMSG_SYNC                          = 1002,
        PMSG_REFRESH                       = 1003,
        PMSG_ADD                           = 1004,
        PMSG_DELETE                        = 1005,
        PMSG_ACCEPT                        = 1006,
        PMSG_REJECT                        = 1007,
        PMSG_BLOCK                         = 1008,
        PMSG_UNBLOCK                       = 1009,
        PMSG_INVITE                        = 1010,
        PMSG_CANCEL                        = 1011,
        PMSG_INVITE_ANSWER                 = 1012,
        PMSG_NICKNAME                      = 1013,
        PMSG_STATE                         = 1014,
        PMSG_DEAD_XBOX                     = 1015,
        PMSG_DEAD_SG                       = 1016,
        PMSG_ANNOUNCE                      = 1017,
        PMSG_SUBSCRIBED                    = 1018,
        PMSG_UNSUBSCRIBE                   = 1019,
        PMSG_ADDED                         = 1020,
        PMSG_ACCEPTED                      = 1021,
        PMSG_REMOVED                       = 1022,
        PMSG_KICK                          = 1023,
        PMSG_DEAD_USER                     = 1024,
        PMSG_ALIVE_2                       = 1025,
        PMSG_WEB_FRIENDS                   = 1026,
        PMSG_WEB_ALIVE                     = 1027,
        PMSG_WEB_ANNOUNCE                  = 1028,
        PMSG_WEB_SUBSCRIBED                = 1029,
        PMSG_WEB_UNSUBSCRIBE               = 1030,
        PMSG_PEER_SESSION                  = 1031,
        PMSG_TEAM_LIST_TEAMS               = 1032,
        PMSG_TEAM_LIST_MEMBERS             = 1033,
        PMSG_TEAM_CREATE                   = 1034,
        PMSG_TEAM_DELETE                   = 1035,
        PMSG_TEAM_REMOVE                   = 1036,
        PMSG_TEAM_MANAGE_TEAM              = 1037,
        PMSG_TEAM_MANAGE_MEMBER            = 1038,
        PMSG_TEAM_RECRUIT                  = 1039,
        PMSG_TEAM_JOIN                     = 1040,
        PMSG_TEAM_GET_TICKET               = 1041,
        PMSG_PEER_SUBSCRIBE                = 1042,
        PMSG_PEER_UNSUBSCRIBE              = 1043,
        PMSG_WATCH_START                   = 1044,
        PMSG_WATCH_STOP                    = 1045,
        PMSG_ADD_2                         = 1046,
        PMSG_INVITE_2                      = 1047,
        PMSG_ALIVE_INTERNAL                = 1048,
        PMSG_STATE_2                       = 1049,        
        PMSG_GET_STATE                     = 1050,
        PMSG_TEAM_CREATE_XE                = 1051,
        PMSG_TEAM_MANAGE_TEAM_XE           = 1052,
        PMSG_ADD_AFFILIATES                = 1053,
        PMSG_IS_AFFILIATE                  = 1054,
        PMSG_QUERY_AFFILIATES              = 1055,
        PMSG_GET_PRESENCE_INFO             = 1056,
        PMSG_PRESENCE_INFO_REPLY            =1057,
        PMSG_INVALIDATE_USER               = 1058,
        PMSG_FIND_USER                     = 1059,
        PMSG_CHECK_TITLE_MESSAGES          = 1060,
        PMSG_TEAM_LIST_USER_TEAMS          = 1061,
        PMSG_USER_PRE_MIGRATION            = 1062,
        PMSG_USER_FULL_MIGRATION           = 1063,
        PMSG_LOGON_CHECK                   = 1064,
        PMSG_FIND_USERS                    = 1065,
        PMSG_ALIVE_INTERNAL_2              = 1066,
        PMSG_PEER_SUBSCRIBE_EX             = 1067,
        PMSG_PURGE_USER                    = 1068,
        PMSG_GET_FRIENDS_LIST              = 1069,
        PMSG_CONTINUATION                  = 1070,
        PMSG_CONNECTION_HEALTH             = 1071,
        PMSG_MAX_REQ_TYPE                  = 1071,

        //
        // Outgoing messages
        //
        PMSG_MIN_REPLY_TYPE                = 1101,
        PMSG_ALIVE_REPLY                   = 1101,
        PMSG_SYNC_REPLY                    = 1102,
        PMSG_WEB_FRIENDS_REPLY             = 1103,
        PMSG_WEB_ALIVE_REPLY               = 1104,
        PMSG_PEER_SESSION_REPLY            = 1105,
        PMSG_INVITE_REPLY                  = 1106,
        PMSG_TEAM_LIST_TEAMS_REPLY         = 1107,
        PMSG_TEAM_LIST_MEMBERS_REPLY       = 1108,
        PMSG_TEAM_CREATE_REPLY             = 1109,
        PMSG_TEAM_DELETE_REPLY             = 1110,
        PMSG_TEAM_REMOVE_REPLY             = 1111,
        PMSG_TEAM_MANAGE_TEAM_REPLY        = 1112,
        PMSG_TEAM_MANAGE_MEMBER_REPLY      = 1113,
        PMSG_TEAM_RECRUIT_REPLY            = 1114,
        PMSG_TEAM_JOIN_REPLY               = 1115,
        PMSG_TEAM_GET_TICKET_REPLY         = 1116,
        PMSG_PEER_SUBSCRIBE_REPLY          = 1117,
        PMSG_PEER_UNSUBSCRIBE_REPLY        = 1118,
        PMSG_GET_STATE_REPLY               = 1119,
        PMSG_IS_AFFILIATE_REPLY            = 1120,
        PMSG_QUERY_AFFILIATES_REPLY        = 1121,
        PMSG_FIND_USER_REPLY               = 1122,
        PMSG_CHECK_TITLE_MESSAGES_REPLY    = 1123,
        PMSG_TEAM_LIST_USER_TEAMS_REPLY    = 1124,
        PMSG_LOGON_CHECK_REPLY             = 1125,
        PMSG_FIND_USERS_REPLY              = 1126,
        PMSG_PEER_SUBSCRIBE_EX_REPLY       = 1127,
        PMSG_PURGE_USER_REPLY              = 1128,
        PMSG_GET_FRIENDS_LIST_REPLY        = 1129,
        PMSG_CONNECTION_HEALTH_REPLY       = 1130,
        PMSG_MAX_REPLY_TYPE                = 1130
    };

    public enum P_QUEUE_TYPES : ushort
    {
        //
        // Outgoing queued response items
        //
        PQUEUE_BUDDY_REQ            = 0,
        PQUEUE_LIST_CHANGE          = 1,
        PQUEUE_PRESENCE             = 2,
        PQUEUE_INVITE               = 3,
        PQUEUE_INVITE_ANSWER        = 4,
        PQUEUE_TRANSIENT_MSGS       = 5,
        PQUEUE_PEER_PRESENCE        = 6,
        PQUEUE_PRESENCE_2           = 7,
       
        PQUEUE_NUM_TYPES            = 8
    };


    public class PresDefs
    {
        public const int CURRENT_XPPROTOCOL_VER = 0x00010000;
        public const int XONLINE_GAMERTAG_SIZE             = 16;
        public const int XONLINE_PRESENCE_LOCALE_SIZE      = 40;
        public const int MAX_TITLE_STATE_BYTES             = 32;

        // public system set state flags
        public const uint P_STATE_FLAG_NONE                = 0;
        public const uint P_STATE_FLAG_ONLINE              = 0x00000001; // Set if online
        public const uint P_STATE_FLAG_PLAYING             = 0x00000002; // Set if playing a game
        public const uint P_STATE_FLAG_CLOAKED             = 0x00000004; // Set to fake being offline
        public const uint P_STATE_FLAG_VOICE               = 0x00000008; // Set if supports voice
        public const uint P_STATE_FLAG_JOINABLE            = 0x00000010; // Set if session is joinable
        public const uint P_STATE_MASK_GUESTS              = 0x00000060;
        public const uint P_STATE_FLAG_RESERVED0           = 0x00000080;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;

        // console types
        public const uint P_STATE_MASK_CONSOLE_TYPE        = 0x00007000;
        public const uint P_STATE_ENUM_CONSOLE_XBOX        = 0x00000000;
        public const uint P_STATE_ENUM_CONSOLE_XENON       = 0x00001000;
        public const uint P_STATE_ENUM_CONSOLE_WINPC       = 0x00002000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD1       = 0x00003000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD2       = 0x00004000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD3       = 0x00005000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD4       = 0x00006000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD5       = 0x00007000;

        // messaging/notification state flags
        public const uint P_STATE_FLAG_VOICE_TV            = 0x02000000;
        public const uint P_STATE_FLAG_SENTINVITE          = 0x04000000;
        public const uint P_STATE_FLAG_RECEIVEDINVITE      = 0x08000000;
        public const uint P_STATE_FLAG_INVITEACCEPTED      = 0x10000000;
        public const uint P_STATE_FLAG_INVITEREJECTED      = 0x20000000;
        public const uint P_STATE_FLAG_SENTREQUEST         = 0x40000000;
        public const uint P_STATE_FLAG_RECEIVEDREQUEST     = 0x80000000;

        // User buddy status
        public const uint P_BUDDY_STATUS_OK                = 0; // Mutually accepted buddy
        public const uint P_BUDDY_STATUS_PENDING           = 1; // Buddy request pending acceptance
        public const uint P_BUDDY_STATUS_REQUEST           = 2; // Buddy request to accept or reject
 
        // Invite answers
        public const ushort PINVITE_REPLY_NO               = 0;
        public const ushort PINVITE_REPLY_YES              = 1;
        public const ushort PINVITE_REPLY_NEVER            = 2;

        // Affiliate flags
        public const uint X_AFFILIATE_ENCOUNTERED_INDEX         = 0;
        public const uint X_AFFILIATE_COMPLETED_GAME_INDEX      = 1;
        public const uint X_AFFILIATE_POSITIVE_FEEDBACK_INDEX   = 2;
        public const uint X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX   = 3;
        public const uint X_AFFILIATE_AVOIDING_ME_INDEX         = 4;
        public const uint X_AFFILIATE_FAVORITES_INDEX         = 5;
        public const uint X_AFFILIATE_FRIEND_INDEX              = 16;
        public const uint X_AFFILIATE_BLOCK_INDEX               = 17;
        public const uint X_AFFILIATE_MUTE_INDEX                = 18;

        public static uint X_AFFILIATE_INDEX_TO_FLAG(uint dwIndex) { return (uint)(1 << (int)dwIndex); }

        public const uint MAX_FIND_USERS_REQUESTS = 100;
       
    };



    //
    // Structure Representing base Presence & Notification Message info
    //  Maps to BASE_MSG_HEADER in xonline.x
    //  
    public class BaseHeader : XRLObject2
    {
        public uint     dwMsgType;
        public uint     dwMsgLen;
        [WireInfo(HexString=true)]
        public uint     dwSeqNum;
        public SGADDR   sgaddr;

        // BYTE rgbMsgData[ dwMsgLen ];

        [WireInfo(Serialize=false)]
        private WireData container;

        public WireData Container
        {
            get {return container;}
            set {container = value;}
        }
        
        // 
        // WireData requires a default constructor with no args for deserialization, so this must exist
        //        
        public BaseHeader()
        {
        }
        
        // 
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        //        
        public BaseHeader( Q_MSG_TYPES msgType, WireData parent )
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public BaseHeader(P_MSG_TYPES msgType, WireData parent)
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // 
            // NOTE!! The containing WireData object MUST also override Size() otherwise
            //  this will result in an infinite recursion/stack overflow situation
            // 
            if( null != container )
            {
                dwMsgLen = (uint)( container.Size() - Size() );
            }
            else
            {
                // We allow this case for unit tests that want to simulate truncated messages by just sending 
                // the correct base header.
                dwMsgLen = 0;
            }

            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
            sgaddr.WriteStream(binaryWriter);

        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwMsgType = (uint)binaryReader.ReadInt32();
                dwMsgLen = (uint)binaryReader.ReadInt32();
                dwSeqNum = (uint)binaryReader.ReadInt32();
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    "Reached end of stream trying to read BaseHeader", e);
            }
            return this;
        }

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER )
            return 32;
        }        
    };
    public class PresenceXrlObject : XRLRequestObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xpresence.srf";
            }
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_HELLO_MSG in xonline.x
    //
    public class PresenceHelloMsg : XRLObject2
    {
        public PresenceHelloMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_HELLO, this );
        }

        public BaseHeader       header;
        public uint             dwProtocolVersion;

        [WireInfo(NullTerminate=true, ArraySize=79)]
        public string           szDescription;      

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceHelloMsg )
            return 32 + 4 + 80;
        }        
    }

    public class PresenceConnectionHealthMsg : XRLObject2
    {
        public PresenceConnectionHealthMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH, this );
        }

        public BaseHeader       header;
        public uint             dwVersion;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthMsg )
            return 32 + 8;
        }        
    }

    public class PresenceConnectionHealthReplyMsg : XRLObject2
    {
        public PresenceConnectionHealthReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH_REPLY, this );
        }

        public BaseHeader       header;
        public uint             hr;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthReplyMsg )
            return 32 + 8;
        }        
    }

    // Structures returned by APIs ///////////////////////////////////////////////////////////

    //
    // Structure representing a buddy in an Alive reply
    //  maps to P_REPLY_BUDDY in xonline.x
    //
    public class ReplyBuddy : WireData
    {
        public ulong            qwBuddyID;
        public ushort           cbAcctName; // Includes the '\0'
        public byte             bStatus;    // See P_BUDDY_STATUS_XXX
       
        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName; // ASCII Null terminated

        override public int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            return 11 + cbAcctName;
        }
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class QueryAffiliatesReplyData : WireData
    {
        [WireInfo(HexString=true)]
        public ulong            qwAffiliateID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        [WireInfo(HexString=true)]
        public uint             dwTitleID;
        [WireInfo(HexString=true)]
        public ulong            qwSessionID;
        [WireInfo(HexString=true)]
        public uint             mtDateUpdated;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag; // ASCII Null terminated

        override public int Size()
        {
            return 44;
        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwAffiliateID = (ulong)binaryReader.ReadInt64();
                dwListFlags = (uint)binaryReader.ReadInt32();
                dwTitleID = (uint)binaryReader.ReadInt32();
                qwSessionID = (ulong)binaryReader.ReadInt64();
                mtDateUpdated = (uint)binaryReader.ReadInt32();
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_GAMERTAG_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szGamerTag = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szGamerTag = s;
                }
                else
                {
                    szGamerTag = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_15, 
                    "Reached end of stream trying to read QueryAffiliatesReplyData", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwAffiliateID);
            binaryWriter.Write(dwListFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(qwSessionID);
            binaryWriter.Write(mtDateUpdated);

            byte[] b;
            if (szGamerTag != null)
            {
                // write the string, but only up to XONLINE_GAMERTAG_SIZE
                b = new UTF8Encoding().GetBytes(szGamerTag);
                if (b.Length <= PresDefs.XONLINE_GAMERTAG_SIZE)
                {
                    binaryWriter.Write(b);
                }
                else
                {
                    binaryWriter.Write(b, 0, PresDefs.XONLINE_GAMERTAG_SIZE);
                }
            }
            else
            {
                b = new byte[0];
            }

            // if we need to, zero pad the string out to XONLINE_GAMERTAG_SIZE
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }
        }
    }


    // Externally-callable Presence APIs /////////////////////////////////////////////////////

    //
    // Structure representing a request to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_MSG in xonline.x
    //
    public class PresenceLogonCheckMsg : XRLObject2
    {
        public PresenceLogonCheckMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        public override int Size()
        {
            return 32 + 8;
        }
    }

    //
    // Structure representing a the response to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_REPLY_MSG in xonline.x
    //
    public class PresenceLogonCheckReplyMsg : XRLObject2
    {
        public PresenceLogonCheckReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK_REPLY, this);
        }

        public BaseHeader header;
        public uint hr;

        public override int Size()
        {
            return 32 + 4;
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_ALIVE_MSG in xonline.x
    //
    public class PresenceAliveMsg : XRLObject2
    {
        public PresenceAliveMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ushort           cbAcctName;
        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;
        public uint             dwState;            // Must be ( P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED )
        public ulong            qwMatchSessionID;   // Must be zero
        public ushort           cbNickname;         // Must be zero
        public ushort           cbTitleStuff;       // Must be zero

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;
 
        [WireInfo(SizeParam="cbNickname")]
        public byte[]           rgbNickName;        

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;
            cbNickname = null == rgbNickName ? (ushort) 0 : (ushort) rgbNickName.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveMsg ) + cbAcctName + cbTitleStuff + cbNickname
            return 32 + 38 + cbAcctName + cbTitleStuff + cbNickname;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                cbAcctName = binaryReader.ReadUInt16();
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                cbNickname = binaryReader.ReadUInt16();
                cbTitleStuff = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }

                rgbTitleStuff = binaryReader.ReadBytes(cbTitleStuff);
                rgbNickName = binaryReader.ReadBytes(cbNickname);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    "Reached end of stream trying to read PresenceAliveMsg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, version 2
    //  maps to P_ALIVE_2_MSG in xonline.x
    //
    public class PresenceAlive2Msg : XRLObject2
    {
        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public ulong            clientVersion;
        public uint             dwTitleID;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public PresenceAlive2Msg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_ALIVE_2, this);
            qwUserID = 0;
            cbAcctName = 0;

            xnaddr = new XNADDR();
            xnkid = 0;

            xnkey = new byte[16] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

            dwBuddyListVersion = 0;
            dwBlockListVersion = 0;

            clientVersion = 0;
            dwTitleID = 0;
            dwTitleVersion = 0;
            dwTitleRegion = 1;
            ipportI = 0;
            ipaI = 0;
            liNonce = 0;
            liTimeInit = (ulong)DateTime.Now.ToFileTimeUtc();

            SchemaVersion = 0;
            szAcctName = "";
        }

        public PresenceAlive2Msg(IClient client, XblUser user)
            : this()
        {
            header.sgaddr.qwXboxId = client.MachinePuid;
            //header.sgaddr.inaSg = client.SecurityProvider.GetSGIP();

            cbAcctName = (ushort)user.Gamertag.Length;
            clientVersion = client.ClientVersion;
            dwTitleID = client.TitleId;
            //dwTitleRegion = 1;
            //dwTitleVersion = 0;
            qwUserID = user.Puid;
            szAcctName = user.Gamertag;
        }

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAlive2Msg ) + cbAcctName
            return 32 + 120 + cbAcctName;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                cbAcctName = binaryReader.ReadUInt16();
                xnaddr = new XNADDR();
                xnaddr.ReadStream(binaryReader);
                xnkid = binaryReader.ReadUInt64();
                xnkey = binaryReader.ReadBytes(16);
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                clientVersion = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwTitleVersion = binaryReader.ReadUInt32();
                dwTitleRegion = binaryReader.ReadUInt32();
                ipportI = binaryReader.ReadUInt16();
                ipaI = binaryReader.ReadUInt32();
                liNonce = binaryReader.ReadUInt64();
                liTimeInit = binaryReader.ReadUInt64();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_17, 
                    "Reached end of stream trying to read PresenceAlive2Msg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, internal version
    //  maps to P_ALIVE_INTERNAL_MSG in xonline.x
    //
    public class PresenceAliveInternalMsg : XRLObject2
    {
        public PresenceAliveInternalMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 140 + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    public class PresenceAliveInternal2Msg : XRLObject2
    {
        public PresenceAliveInternal2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        public ulong            qwVersionFlags;
        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 148 + PresDefs.XONLINE_PRESENCE_LOCALE_SIZE + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            int iLocaleLen = 0;
            if (szLocale != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szLocale);
                binaryWriter.Write(b);
                iLocaleLen = b.Length;
            }
            for (int iByte = iLocaleLen; iByte < PresDefs.XONLINE_PRESENCE_LOCALE_SIZE; iByte++)
            {
                binaryWriter.Write((byte)0);
            }
            binaryWriter.Write(qwVersionFlags);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    //
    // Structure representing a reply to an Alive request
    //  maps to P_ALIVE_REPLY_MSG in xonline.x
    //
    public class PresenceAliveReply : XRLObject2
    {
        public PresenceAliveReply()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_REPLY, this );
        }

        public BaseHeader       header;
        public uint             hr;                         // On fail other fields set to 0
        public uint             dwBuddyListVersion;
        public ushort           cBuddiesSent;
        public uint             dwBlockListVersion;
        public ushort           cBlocksSent;

        [WireInfo(SizeParam="cBuddiesSent")]
        public ReplyBuddy[]     rgReplyBuddies;
      
        [WireInfo(SizeParam="cBlocksSent")]
        public ulong[]          rgqwBlockIDs; // maps to P_REPLY_BLOCK in xonline.x

        public override int Size()
        {
            // Get the correct sizes before we use them
            cBuddiesSent = null == rgReplyBuddies ? (ushort) 0 : (ushort) rgReplyBuddies.Length;
            cBlocksSent = null == rgqwBlockIDs ? (ushort) 0 : (ushort) rgqwBlockIDs.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveReply ) + cBuddiesSent * sizeof( ReplyBuddy ) + cBlocksSent * sizeof( ulong )
            int iSize = 32 + 16 + cBlocksSent * 8;
            for( int iBuddy = 0; iBuddy < cBuddiesSent; iBuddy++ )
            {
                iSize += rgReplyBuddies[ iBuddy ].Size();
            }
            return iSize;
        }        
    }

    //
    // Structure representing a request to take a user offline
    //  maps to P_DEAD_USER_MSG/Q_DEAD_USER_MSG
    //
    public class PresenceDeadUserMsg : XRLObject2
    {
        public PresenceDeadUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DEAD_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeadUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceStateMsg : PresenceXrlObject
    {
        public PresenceStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;
        public ushort           cbTitleStuff;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + cbTitleStuff
            return 32 + 22 + cbTitleStuff;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cbTitleStuff = rgbTitleStuff == null ? (ushort)0 : (ushort)rgbTitleStuff.Length;
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(cbTitleStuff);
            binaryWriter.Write(rgbTitleStuff);
        }
    }
    

    //
    // Structure representing a rich presence state data
    //  maps to P_RICH_PRESENCE in xonline.x
    //
    public class RichPresence : WireData
    {
        public uint             titlePresence;
        
        public ushort           cContexts;
        public ushort           cProperties;

        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;

        public override int Size()
        {
            // sizeof( RichPresence )
            int cb = 8;

            // add all the contexts
            cb += cContexts * 8;
            
            // add all the props
            if (cProperties > 0)
            {
                foreach (GIProperty prop in rgProps)
                {
                    cb += prop.Size();
                }
            }

            return cb;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                titlePresence = binaryReader.ReadUInt32();
                cContexts = binaryReader.ReadUInt16();
                cProperties = binaryReader.ReadUInt16();
                rgContexts = new GIContext[cContexts];
                for (int i = 0; i < cContexts; ++i)
                {
                    rgContexts[i] = new GIContext();
                    rgContexts[i].ReadStream(binaryReader);
                }
                rgProps = new GIProperty[cProperties];
                for (int i = 0; i < cProperties; ++i)
                {
                    rgProps[i] = new GIProperty();
                    rgProps[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_18, 
                    "Reached end of stream trying to read RichPresence", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cContexts = rgContexts == null ? (ushort)0 : (ushort)rgContexts.Length;
            cProperties = rgProps == null ? (ushort)0 : (ushort)rgProps.Length;

            binaryWriter.Write(titlePresence);
            binaryWriter.Write(cContexts);
            binaryWriter.Write(cProperties);
            for (int i = 0; i < cContexts; ++i)
            {
                rgContexts[i].WriteStream(binaryWriter);
            }
            for (int i = 0; i < cProperties; ++i)
            {
                rgProps[i].WriteStream(binaryWriter);
            }
        }
    }

        
    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceState2Msg : PresenceXrlObject
    {
        public PresenceState2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        public uint             cbRichPresence;     // Count of RP data

        public ushort           cbMemcacheData;     // Count of memcache data
        
        public RichPresence     rpData;

        [WireInfo(SizeParam="cbMemcacheData")]
        public byte[] rgbMemcacheData;

        public override int Size()
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence ) + sizeof(rgbMemcacheData)
            int cb = 32 + 30 + rpData.Size() + cbMemcacheData;
            
            return cb;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;
            
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(dwTitleId);
            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbMemcacheData);
            rpData.WriteStream(binaryWriter);

            if (rgbMemcacheData != null)
            {
                binaryWriter.Write(rgbMemcacheData);
            }
        }
    }

    //
    // Structure representing a request to fetch a user's state
    //  maps to P_GET_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateMsg : PresenceXrlObject
    {
        public PresenceGetStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( qwUserID )
            return 32 + 8;
        }        
        
    }

    //
    // Structure representing a reply to a PresenceGetStateMsg request
    //  maps to P_GET_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateReplyMsg : PresenceXrlObject
    {
        public PresenceGetStateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE_REPLY, this );
            presenceData = new RichPresence();
        }

        public BaseHeader       header;
        public uint             hr;
        
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        
        RichPresence            presenceData;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence )
            int cb = 32 + 20 + presenceData.Size();

            return cb;
        }        
    }
    
    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_MSG in xonline.x
    // 
    public class PresenceAddBuddyMsg : PresenceXrlObject
    {
        public PresenceAddBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public ushort           cbBuddyAcctName;
 
        [WireInfo(SizeParam="cbBuddyAcctName", NullTerminate=true)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbBuddyAcctName = null == szBuddyAcctName ? (ushort) 0 : (ushort) Encoding.UTF8.GetByteCount( szBuddyAcctName );
            // add one for the null terminator
            cbBuddyAcctName ++; 

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddyMsg ) + cbBuddyAcctName
            return 32 + 18 + cbBuddyAcctName;
        }        
        
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwSenderID = binaryReader.ReadUInt64();
                qwBuddyID = binaryReader.ReadUInt64();
                cbBuddyAcctName = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbBuddyAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szBuddyAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szBuddyAcctName = s;
                }
                else
                {
                    szBuddyAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_19, 
                    "Reached end of stream trying to read PresenceAddBuddyMsg", e);
            }
            return this;
        }
     }

    //
    // Structure representing a request to add  users to another user's affiliates list
    //  maps to P_ADD_AFFILIATES_MSG in xonline.x
    // 
    public class PresenceAddAffiliatesMsg : PresenceXrlObject
    {
        public PresenceAddAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_AFFILIATES, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public uint             dwListFlag;
        public uint             dwTitleID;
        public ushort           cwAffiliates;
 
        [WireInfo(SizeParam="cwAffiliates")]
        public ulong[]          pqwAffiliates;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddAffiliatesMsg ) + cwAffiliates * sizeof(ulong);
            return 32 + 18 + (8 * cwAffiliates);
        }        
    }

    //
    // Structure representing a request to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_MSG in xonline.x
    // 
    public class PresenceIsAffiliateMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwAffiliateID;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a reply to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_REPLY_MSG in xonline.x
    // 
    public class PresenceIsAffiliateReplyMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE_REPLY, this );
        }

        public BaseHeader       header;
        public uint             hr;
        public ulong            qwAffiliateID;
        public uint             dwListFlags;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateReplyMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_MSG in xonline.x
    // 
    public class PresenceQueryAffiliatesMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public ulong            qwSenderID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        public uint             cdwLimit;
        [WireInfo(HexString=true)]
        public uint             dwOnlineTitleID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesMsg );
            return 32 + 20;
        }        
    }

    //
    // Structure representing a reply with the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_REPLY_MSG in xonline.x
    // 
    public class PresenceQueryAffiliatesReplyMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES_REPLY, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public uint             hr;
        public uint             cdwResults;

        [WireInfo(SizeParam="cdwResults")]
        public QueryAffiliatesReplyData[]      rgResults;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesReplyMsg ) + cdwResults * sizeof( QueryAffiliatesReplyData );
            return (int)(32 + 8 + (cdwResults * 44));
        }        
        
         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                hr = (uint)binaryReader.ReadInt32();
                cdwResults = (uint)binaryReader.ReadInt32();
                rgResults = new QueryAffiliatesReplyData[cdwResults];
                for (int i = 0; i < cdwResults; ++i)
                {
                    rgResults[i] = new QueryAffiliatesReplyData();
                    rgResults[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_20, 
                    "Reached end of stream trying to read PresenceQueryAffiliatesReplyMsg", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cdwResults = rgResults == null ? (uint)0 : (uint)rgResults.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(hr);
            binaryWriter.Write(cdwResults);
            for (int i = 0; i < cdwResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }
    }


    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_2_MSG in xonline.x
    // 
    public class PresenceAddBuddy2Msg : PresenceXrlObject
    {
        public PresenceAddBuddy2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_2, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public uint             dwMessageFlags;
        public ushort           cbDetails;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        [WireInfo(SizeParam="cbDetails")]
        public byte[]   rgbDetails;

        public MessageDetails details
        {
            get
            {
                if (rgbDetails != null)
                {
                    MessageDetails ret = new MessageDetails();
                    ret.ReadBytes(rgbDetails);
                    return ret;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                if (value == null)
                {
                    rgbDetails = null;
                }
                else
                {
                    rgbDetails = (byte[])value;
                    cbDetails = (ushort)(rgbDetails.Length);
                }
            }
        }

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbDetails = (null == rgbDetails) ? (ushort) 0 : (ushort) rgbDetails.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddy2Msg ) + cbDetails
            return 32 + 38 + cbDetails;
        }        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwSenderID);
            binaryWriter.Write(qwBuddyID);
            binaryWriter.Write(dwMessageFlags);
            binaryWriter.Write(cbDetails);

            byte[] b;
            if (szBuddyAcctName != null)
            {
                b = Encoding.UTF8.GetBytes(szBuddyAcctName);
                binaryWriter.Write(b);
            }
            else
            {
                b = new byte[0];
            }

            // zero pad out to PresDefs.XONLINE_GAMERTAG_SIZE length
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }

            if (rgbDetails != null)
            {
                binaryWriter.Write(rgbDetails);
            }
        }
     }

    //
    // Structure representing a request to remove a user from another user's friends list
    //  maps to P_DELETE_MSG in xonline.x
    // 
    public class PresenceDeleteBuddyMsg : PresenceXrlObject
    {
        public PresenceDeleteBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DELETE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeleteBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to accept a friend request
    //  maps to P_ACCEPT_MSG in xonline.x
    // 
    public class PresenceAcceptBuddyMsg : PresenceXrlObject
    {
        public PresenceAcceptBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ACCEPT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAcceptBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to reject a friend request
    //  maps to P_REJECT_MSG in xonline.x
    // 
    public class PresenceRejectBuddyMsg : PresenceXrlObject
    {
        public PresenceRejectBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_REJECT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;
        public uint             dwNever;
        
        
        public bool fNever
        {
            get { return (dwNever == 0 ? false : true); }
            set { dwNever = (uint)(value ? 1 : 0); }
        }    

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceRejectBuddyMsg )
            return 32 + 20;
        }        
    }

    //
    // Structure representing a request to add a user to another user's mute list
    //  maps to P_BLOCK_MSG in xonline.x
    // 
    public class PresenceMuteUserMsg : PresenceXrlObject
    {
        public PresenceMuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_BLOCK, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceMuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to remove a user from another user's mute list
    //  maps to P_UNBLOCK_MSG in xonline.x
    // 
    public class PresenceUnmuteUserMsg : PresenceXrlObject
    {
        public PresenceUnmuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_UNBLOCK, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID; // If qwBlockID == 0, clear the entire block list

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceUnmuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_MSG in xonline.x
    // 
    public class PresenceInviteUserMsg : PresenceXrlObject
    {
        public PresenceInviteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUserMsg ) + cInvitees * sizeof( ulong )
            return 32 + 22 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_2_MSG in xonline.x
    // 
    public class PresenceInviteUser2Msg : PresenceXrlObject
    {
        public PresenceInviteUser2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwSenderContext;
        public uint             dwTitleID;
        public uint             dwMessageFlags;
        public ushort           cInvitees;
        public ushort           cbDetails;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public MessageDetails   details;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;
            cbDetails = null == details ? (ushort) 0 : (ushort) details.Size();

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUser2Msg ) + cInvitees * sizeof( ulong ) + cbDetails
            return 32 + 28 + cInvitees * 8 + cbDetails;
        }        
    }

    //
    // Structure representing a request to cancel an invitation to a game session
    //  maps to P_CANCEL_MSG in xonline.x
    // 
    public class PresenceCancelInviteMsg : PresenceXrlObject
    {
        public PresenceCancelInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CANCEL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceCancelInviteMsg ) + cInvitees * sizeof( ulong )
            return 32 + 18 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to answer an invitation to a game session
    //  maps to P_INVITE_ANSWER_MSG in xonline.x
    // 
    public class PresenceAnswerInviteMsg : XRLObject2
    {
        public PresenceAnswerInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_ANSWER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;
        public ulong            qwMatchSessionID;
        public ushort           wAnswer;          // See PINVITE_REPLY_XXX

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAnswerInviteMsg )
            return 32 + 26;
        }        
    }


    // Externally-callable Notification APIs /////////////////////////////////////////////////

    //
    // Structure representing a request to dequeue notification items on behalf of a user
    //  maps to Q_DEQUEUE_MSG in xonline.x
    //  
    public class NotificationDequeueMsg : XRLObject2
    {
        public NotificationDequeueMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DEQUEUE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public uint             dwStartItemID;
        public ushort           wMaxItems;
        public uint             dwMaxTotalItemDataSize;

        public override int Size()
        {
            // sizeof( Q_DEQUEUE_MSG )
            return 52;
        }
    }


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_LIST_CHANGE
    //
    public class ListChangeItem : WireData
    {
        public uint        dwListVersion;
        public ulong       qwTargetID;
        public ushort      wOperationID;
        public uint        hr;
        public ushort      cbTargetAcctName;
        
        [WireInfo(SizeParam="cbTargetAcctName")]  // ASCII string null terminated
        public string      szTargetAcctName;

        public override int Size()
        {
            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 20 + cbTargetAcctName;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE
    //
    public class PresenceItem : WireData
    {
        public ulong      qwBuddyID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbNickname;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbNickname")]
        public byte[]     rgbNickName;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            // sizeof( PresenceItem ) + cbNickname + cbTitleStuff
            return 28 + cbNickname + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE
    //
    public class InvitationItem : WireData
    {
        public ulong      qwHostID;
        public ulong      qwMatchSessionID;
        public uint       dwTitleID;
        public ulong      ftSent;

        public override int Size()
        {
            // sizeof( InvitationItem ) 
            return 28;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE_ANSWER
    //
    public class InvitationAnswerItem : WireData   
    {
        public ulong      qwInviteeID;
        public ulong      qwMatchSessionID;
        public ulong      ftSent;
        public ushort     wAnswer;

        public override int Size()
        {
            // sizeof( InvitationAnswerItem ) 
            return 26;
        }        
    };


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PEER_PRESENCE
    //
    public class PeerPresenceItem : WireData
    {
        public ulong      qwUserID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            // sizeof( PeerPresenceItem ) + cbTitleStuff
            return 26 + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE_2
    //
    public class Presence2Item : WireData
    {
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             dwState;
        public ulong            qwMatchSessionID;
        public uint             mtUserTime;
        
        public ushort           cbRichPresence;
        public ushort           cbrpData;

        [WireInfo(SizeParam="cbRichPresence")]
        public string           szRichPresence;        
        
        [WireInfo(SizeParam="cbData", Serialize=false)]
        public RichPresence     rpData;

        public override int Size()
        {
            // sizeof( Presence2Item ) + cbRichPresence + cbData
            return 32 + cbRichPresence + rpData.Size();
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                mtUserTime = binaryReader.ReadUInt32();
                cbRichPresence = binaryReader.ReadUInt16();
                cbrpData = binaryReader.ReadUInt16();
                byte[] byteString = binaryReader.ReadBytes(cbRichPresence);
                szRichPresence = new UTF8Encoding().GetString(byteString);

                if (cbrpData > 0)
                {
                    rpData = new RichPresence();
                    rpData.ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_21, 
                    "Reached end of stream trying to read Presence2Item", e);
            }

            return this;
        }        

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // Implement a little trickery. To the client, rgbData is an array of bytes with 
            //  cbData as the SizeParam. Set the size properly here since WireData won't
            if (null != rpData)
            {
                cbrpData = (ushort)rpData.Size();
            }
            else
            {
                cbrpData = 0;
            }

            byte[] b;
            if (szRichPresence != null)
            {
                b = new UTF8Encoding().GetBytes(szRichPresence);
            }
            else
            {
                b = new byte[0];
            }

            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(mtUserTime);

            // fixup cbRichPresence before we write it
            cbRichPresence = (ushort)b.Length;

            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbrpData);
            if (szRichPresence != null)
            {
                binaryWriter.Write(b);
            }

        }
    };

    //
    // Structure representing a single list item in a dequeue response
    //  maps to Q_LIST_ITEM in xonline.x
    //
    public class NotificationListItem : WireData
    {
        public uint             dwItemID;
        public ushort           wItemLen;
 
        [WireInfo(SizeParam="wItemLen")]
        public byte[]           rgbItemData;

        public override int Size()
        {
            // Get the correct sizes before we use them
            wItemLen = null == rgbItemData ? (ushort) 0 : (ushort) rgbItemData.Length;

            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 6 + wItemLen;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwItemID = binaryReader.ReadUInt32();
                wItemLen = binaryReader.ReadUInt16();
                rgbItemData = binaryReader.ReadBytes(wItemLen);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_22, 
                    "Reached end of stream trying to read NotificationListItem", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            wItemLen = rgbItemData == null? (ushort)0 : (ushort)rgbItemData.Length;

            binaryWriter.Write(dwItemID);
            binaryWriter.Write(wItemLen);
            binaryWriter.Write(rgbItemData);
        }

    }
    
    //
    // Structure representing reply to a request to dequeue notification items on behalf of a user
    //  maps to Q_LIST_REPLY_MSG in xonline.x
    //  
    public class NotificationDequeueReply : XRLObject2
    {
        public NotificationDequeueReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public uint             hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }

    }

    public class NotificationDequeueReply2 : XRLObject2
    {
        public NotificationDequeueReply2()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public uint             hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            // we continue to use Q_LIST_REPLY_MSG size rather than Q_LIST_REPLY_2 size, so that writestream serializes this the same way.
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_PRESENCE_LOCALE_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szLocale = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szLocale = s;
                }
                else
                {
                    szLocale = null;
                }                
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    //XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        // write stream does not include the szLocale field.  szLocale is an internal only field.
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }
    }

    public class PurgeUserRequest : PresenceXrlObject
    {
        public PurgeUserRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
        
    }
    
    public class PurgeUserResponse : PresenceXrlObject
    {
        public PurgeUserResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER_REPLY, this);
        }
        
        public BaseHeader header;
        public uint hr;
        
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;
                
        public override int Size()
        {
            return header.Size() + 20;
        }        
    }
    
    public class WebAliveRequest : PresenceXrlObject
    {
        public WebAliveRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }
    
    public class WebAliveResponse : PresenceXrlObject
    {
        public WebAliveResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE_REPLY, this);
        }
        
        public BaseHeader header;
        public uint hr;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 12;
        }        
    }
    
    public class WebFriendsRequest : PresenceXrlObject
    {
        public WebFriendsRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }    
    
    public class WebFriendsResponse : PresenceXrlObject
    {
        public WebFriendsResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS_REPLY, this);
        }
        
        public BaseHeader header;
        public uint hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public WebFriendsData[] rgFriends;
        
        public override int Size()
        {
            int cbFriends = 0;
            foreach(WebFriendsData f in rgFriends)
            {
                cbFriends += f.Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class WebFriendsData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
        
    public class GetFriendsListRequest : PresenceXrlObject
    {
        public GetFriendsListRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST, this);
        }
        
        public BaseHeader header;
        public ulong qwSender;
        public ulong qwTarget;
        
        
        public override int Size()
        {
            return header.Size() + 16;
        }        
    }    
    
    public class GetFriendsListResponse : PresenceXrlObject
    {
        public GetFriendsListResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST_REPLY, this);
        }
        
        public BaseHeader header;
        public uint hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsListData[] rgFriends;
        
        public override int Size()
        {
            int cbFriends = 0;
            foreach(GetFriendsListData f in rgFriends)
            {
                cbFriends += f.Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class GetFriendsListData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
    public class GetPresenceInfoRequest : PresenceXrlObject
    {
        public GetPresenceInfoRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_PRESENCE_INFO, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public ulong[] rgUsers;        
        
        public override int Size()
        {
            return header.Size() + 16 + ((int)cdwUsers * 8);
        }        
    }    
    
    public class PresenceInfoResponse : PresenceXrlObject
    {
        public PresenceInfoResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PRESENCE_INFO_REPLY, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public PresenceInfoData[] rgUsers;        
        
        public override int Size()
        {
            int cbUsers = 0;
            foreach(PresenceInfoData u in rgUsers)
            {
                cbUsers += u.Size();
            }
            
            return header.Size() + 16 + cbUsers;
        }        
    }    
    
    public class PresenceInfoData : PresenceXrlObject
    {
        public ulong Puid;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ulong qwSessionID;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            return 50 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
        
    //
    // Structure representing a request to invalidate a user's cached data
    //  maps to PMSG_INVALIDATE_USER
    //
    public class InvalidateUserMsg : PresenceXrlObject
    {
        public InvalidateUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVALIDATE_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( InvalidateUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION
    //
    public class PeerSessionMsg : PresenceXrlObject
    {
        public PeerSessionMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;       

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION_REPLY
    //
    public class PeerSessionReplyMsg : PresenceXrlObject
    {
        public PeerSessionReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION_REPLY, this );
        }

        public BaseHeader       header;

        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;

        public XNADDR xnaddr;
        [WireInfo(ArraySize=8)]
        public byte[] xkid;
        [WireInfo(ArraySize=16)]
        public byte[] xnkey;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionReplyMsg )
            return 32 + 12 + 36 + 8 + 16;
        }        
    }
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUserMsg : PresenceXrlObject
    {
        public FindUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER, this );
        }

        public BaseHeader       header;
        
        public ulong            qwUserID;       // User making the request

        public ulong            qwFindID;       // User to be found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag to be found

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 16 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUserReplyMsg : PresenceXrlObject
    {
        public FindUserReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER_REPLY, this );
        }

        public BaseHeader       header;
        
        public ulong            qwFoundID;      // User found - 0 if not found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag found - only valid if qwUserID is not 0

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 8 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    public class FindUsersData : PresenceXrlObject
    {
        public ulong qwUserID;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        public override int Size()
        {
            return 24;
        }        
    }
    
    //
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUsersMsg : PresenceXrlObject
    {
        public FindUsersMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
        }
        
        public FindUsersMsg(uint cdwQueries)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
            this.cdwQueries = cdwQueries;
            rgQueries = new FindUsersData[cdwQueries];
        }

        public BaseHeader header;
        
        public ulong qwUserID;       // User making the request

        [WireInfo(Min=1, Max=PresDefs.MAX_FIND_USERS_REQUESTS)]
        public uint cdwQueries;

        [WireInfo(SizeParam="cdwQueries")]
        public FindUsersData[] rgQueries;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUsersMsg ) + ( cdwQueries * sizeof( FindUsersData ) )
            return 32 + 12 + (24 * (int)cdwQueries);
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUsersReplyMsg : PresenceXrlObject
    {
        public FindUsersReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
        }
        
        public FindUsersReplyMsg(uint cdwResults)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
            this.cdwResults = cdwResults;
            rgResults = new FindUsersData[cdwResults];
        }

        public BaseHeader       header;

        public uint cdwResults;
        
        [WireInfo(SizeParam="cdwResults")]
        public FindUsersData[] rgResults;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg ) + ( cdwResults * sizeof( FindUsersData ) )
            return 32 + 4 + (24 * (int)cdwResults);
        }        
    }
    //
    // Structure representing a request to ick a user off the system
    //  maps to PMSG_KICK
    //
    public class KickMsg : PresenceXrlObject
    {
        public BaseHeader  header;
        public ulong       qwUserID;
        public uint        fFlushTickets;

        public KickMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_KICK, this );
        }

        public override int Size()
        {
            return header.Size() + 12;
        }
    }
    

} // namespace XBOX.Online.Protocol.Presence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\TeamTicket.cs ===
//
// TeamTicket.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Collections;
//using xonline.common.service;

using live.common;

namespace live.protocol
{
    public class TeamTicket : WireData
    {
        public ulong userID;
        public short cTeams;
        public short cbSignature;
        
        [WireInfo(SizeParam="cTeams")] 
        public ulong [] rgqwTeamIDs;
        
        [WireInfo(SizeParam="cbSignature")] 
        public byte [] rgbSignature;

        [WireInfo(Serialize=false)]
        private bool verified = false;
        
        [WireInfo(Serialize=false)]
        public const int TEAM_TICKET_SIGNATURE_LENGTH = 8;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAMS_PER_TICKET = 8;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTicket()
        {
        }
        
        public TeamTicket(ulong userId, ulong teamId)
        {
            userID = userId;
            cTeams = 1;
            rgqwTeamIDs = new ulong[1];
            rgqwTeamIDs[0] = teamId;

            cbSignature = 0;
            rgbSignature = null;
        }
        
        public TeamTicket(BinaryReader reader)
        {
            base.ReadStream(reader);
            if (cTeams > MAXIMUM_TEAMS_PER_TICKET)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS,
                    "TeamTicket contains too many teams: " + cTeams);
            }
            verified = false;
        }


        // 
        // Methods for creating and validating a ticket given SGInfo
        // 
        private byte[] TicketSignature(CSGInfo sginfo)
        {
            MemoryStream m = new MemoryStream(100);
            BinaryWriter w = new BinaryWriter(m);

            w.Write(userID);
            w.Write((short)rgqwTeamIDs.Length);
            w.Write((short)TEAM_TICKET_SIGNATURE_LENGTH);
            foreach(ulong t in rgqwTeamIDs)
            {
                w.Write(t);
            }
            byte[] teamTicket = m.ToArray();

            byte[] fullSignature = sginfo.SignWithKey(teamTicket, 0, teamTicket.Length);
            byte[] signature = new byte[TEAM_TICKET_SIGNATURE_LENGTH];
            Array.Copy(fullSignature,signature,TEAM_TICKET_SIGNATURE_LENGTH);

            return signature;
        }

        public void SignTicket(CSGInfo sginfo)
        {
            cbSignature = TEAM_TICKET_SIGNATURE_LENGTH;
            rgbSignature = TicketSignature(sginfo);
        }

//        public void SignTicket()
//        {
//            SignTicket(CSGInfo.Current);
//        }
        
        public void VerifyTicket(CSGInfo sginfo)
        {
            if (!verified)// && AuthToggle.On)
            {
                if (rgbSignature == null || !ByteArray.Equals(TicketSignature(sginfo), rgbSignature))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_1,
                        "TeamTicket signature verification failed");
                }
                if (!sginfo.IsUserPresent(userID))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_2,
                        "Team ticket is for user not present in auth data: " + userID.ToString("X"));
                }
                verified = true;
            }            
        }

//        public void VerifyTicket()
//        {
//            VerifyTicket(CSGInfo.Current);
//        }
        
        //
        // Return size of this team ticket after serialization
        //
        public override int Size()
        {
            return 12 + (8 * cTeams) + cbSignature;
        }

        public bool Signed()
        {
            return (cbSignature != 0);
        }
        
        public void ClearSignature()
        {
            cbSignature = 0;
            rgbSignature = null;
        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            bool fResult = false;

            if (userId == userID)
            {
                foreach(ulong t in rgqwTeamIDs)
                {
                    if (t == teamId)
                    {
                        fResult = true;
                        break;
                    }
                }
            }
            
            return fResult;            
        }
    }
    
    public class TeamTickets : WireData
    {
        public ushort wType; // == TEAM_TICKETS_TYPE
        public ushort wLength; // number of bytes following this ushort
        public ushort cTickets; // maximum of MAXIMUM_TEAM_TICKETS
        
        [WireInfo(SizeParam="cTickets")] 
        public TeamTicket[] teamTickets;
        
        [WireInfo(Serialize=false)]
        public const ushort TEAM_TICKETS_TYPE = 0x0001;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAM_TICKETS = 1024;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTickets()
        {
        }
        
        public TeamTickets(BinaryReader reader)
        {
            ReadStream(reader);
        }

        public TeamTickets(TeamTicket[] paramTeamTickets)
        {
            teamTickets = paramTeamTickets;

            cTickets = (ushort)teamTickets.Length;
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_3,
                    "Team Tickets contains too many tickets: " + cTickets);
            }
        }

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int actualLength = 2;

            try
            {
                wType = binaryReader.ReadUInt16();
            }
            catch (EndOfStreamException)
            {
                //We need to throw a peekcharendofstreamexception instead of a plain endofstream exception
                //This is to accurately tell the same thing as what peekchar would have told us
                //that is there were no more data in the stream
                throw new PeekCharEndOfStreamException();
            }
            
            if (wType != TEAM_TICKETS_TYPE)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_4,
                    "Team Tickets type expected. Received: " + wType.ToString("X"));
            }
            wLength = binaryReader.ReadUInt16();          
            cTickets = binaryReader.ReadUInt16();
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_5, 
                    "Team Tickets contains too many tickets: " + cTickets);
            }
            teamTickets = new TeamTicket[cTickets];
            for (int i = 0; i < cTickets; ++i)
            {
                teamTickets[i] = new TeamTicket(binaryReader);
                actualLength += teamTickets[i].Size();
            }
            if (actualLength != wLength)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_6, 
                    "Team Tickets length inconsistent. Stated:" + wLength + " Actual:" + actualLength);
            }

            return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            wType = TEAM_TICKETS_TYPE;
            cTickets = (ushort)teamTickets.Length;
            wLength = 2; // length of cTickets
            for (int i = 0; i < cTickets; ++i)
            {
                wLength += (ushort)teamTickets[i].Size();
            }
            base.WriteStream(binaryWriter);
        }

        public void VerifyTickets(CSGInfo sginfo)
        {
            foreach(TeamTicket t in teamTickets)
            {
                t.VerifyTicket(sginfo);
            }
        }
        
//        public void VerifyTickets()
//        {
//            VerifyTickets(CSGInfo.Current);
//        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            foreach(TeamTicket t in teamTickets)
            {
                if (t.userID == userId)
                {
                    return t.VerifyMembership(userId, teamId);
                }
            }

            return false;
        }

        public void VerifyMembershipThrow(ulong userId, ulong teamId)
        {
            if (false == VerifyMembership(userId, teamId))
            {
                throw new XRLException(HResult.XONLINE_E_TEAMS_NOT_A_MEMBER, //XEVENT_AUTHDATA_BAD_TEAM_TICKETS_7,
                    "User " + userId + " is not a member of team " + teamId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\TGTransaction2.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;

using live.common;

namespace live.protocol
{
    public class TGTransaction2 : ITransaction
    {
        IXOnSecurityProvider _securityProvider = new live.client.TG2SecurityProvider(true);
        protected bool UseSSL = false;
        public virtual IXOnSecurityProvider SecurityProvider
        {
            get
            {
                return _securityProvider;
            }
            set
            {
                _securityProvider = value;
            }
        }

/*
        public uint SendRequest(
            IClient client,
            XOService service,
            string url,
            string httpMethod,
            byte[] sendData,
            WebHeaderCollection headers,
            out byte[] responseData)
        {
            uint hr = HResult.S_OK;
            string xErr;

            System.Net.ServicePointManager.ServerCertificateValidationCallback +=
                new System.Net.Security.RemoteCertificateValidationCallback(RemoteCertValidate);

            //WebClient myWebClient = new WebClient();
            //WebProxy webProxy = new WebProxy("10.198.102.212", 13010);
            //myWebClient.Proxy = webProxy;

            live.WebClientProxyWebReference.WebClientProxy myWebClient = new live.WebClientProxyWebReference.WebClientProxy();

            if (headers != null)
            {
                //myWebClient.Headers.Add(headers);
            }
            if ((headers == null) || (headers["User-Agent"] == null))
            {
                //myWebClient.Headers.Add("User-Agent", "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)");
            }

            try
            {
                string[] strHeaders = new string[headers.Count];
                for (int i = 0; i < headers.Count; i++)
                {
                    strHeaders[i] = headers.Get(i);
                }

                if (httpMethod.ToUpper() == HttpMethod.Post)
                {
                    responseData = myWebClient.UploadData((live.client.TG2SecurityProvider)SecurityProvider,
                        (live.WebClientProxyWebReference.XOService)service, url, httpMethod, sendData, strHeaders);
                }
                else if (httpMethod.ToUpper() == HttpMethod.Get)
                {
                    responseData = myWebClient.DownloadData((live.client.TG2SecurityProvider)SecurityProvider,
                        (live.WebClientProxyWebReference.XOService)service, url, strHeaders);
                }
                else
                {
                    throw new Exception("Unsupport HTTP method: " + httpMethod);
                }

                //xErr = myWebClient.ResponseHeaders["X-Err"];
                //if (xErr != null)
                {
                //    hr = UInt32.Parse(xErr, System.Globalization.NumberStyles.HexNumber);
                }
            }
            catch (WebException e)
            {
                // not a normal failure, so throw
                // default to BadRequest if no response is available.
                HttpWebResponse httpResp = (HttpWebResponse)e.Response;
                HttpStatusCode status = HttpStatusCode.BadRequest;
                string respData = "SendRequest failed. But no response data is available.";
                if (httpResp != null)
                {
                    status = httpResp.StatusCode;
                    respData = httpResp.StatusDescription;

                    // get the X-Err header from response
                    xErr = httpResp.Headers["X-Err"];
                    if (xErr != null)
                    {
                        hr = UInt32.Parse(xErr, System.Globalization.NumberStyles.HexNumber);
                    }

                    if (httpResp.ContentLength > 0)
                    {
                        long contentLen = httpResp.ContentLength;
                        Stream stream = httpResp.GetResponseStream();
                        Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                        // Pipes the stream to a higher level stream reader with the required encoding format. 
                        StreamReader readStream = new StreamReader(stream, encode);
                        char[] read = new char[contentLen];
                        int count = readStream.Read(read, 0, read.Length);
                        //respData = Encoding.UTF8.GetString(read);
                        String str = new String(read, 0, count);
                        respData = str;
                    }
                }

                throw new XrlRequestException(url, e.Message, status, sendData, respData, hr, e);
            }
            return hr;
        }

*/

        public uint SendRequest(
            IClient client,
            XOService service,
            string url,
            string httpMethod,
            byte[] sendData,
            WebHeaderCollection headers,
            out byte[] responseData)
        {
            uint hr = HResult.S_OK;
            string xErr;

            live.protocol.proxy.WebClientProxy myWebClient = new live.protocol.proxy.WebClientProxy();
            UriBuilder uri = new UriBuilder(myWebClient.Url);
            IPEndPoint endPoint = Config.Current.GetIPEndPoint(client, service);
            myWebClient.Url = ((endPoint.Port == 443) ? "https://" : "http://") + endPoint.ToString() + uri.Path;
            Logging.WriteLine("DEBUG", "Setting WebClientProxy's url to {0}", myWebClient.Url);

            live.protocol.proxy.CertUtil.SetCertForService(service, myWebClient);


            live.protocol.proxy.TG2SecurityProvider secProv = new live.protocol.proxy.TG2SecurityProvider();
            secProv.SecurityInfo = (live.protocol.proxy.CSGInfo)SecurityProvider.SecurityInfo;

            string[] headerstrings = null;
            if (headers.Count > 0) {
                headerstrings = headers.ToString().Replace("\r","").Trim("\n".ToCharArray()).Split("\n".ToCharArray());
            }

            try
            {
                ClientSettings settings = new ClientSettings();
                settings.ClientType = client.ClientType;
                settings.Key = client.Key;
                settings.MachinePuid = client.MachinePuid;
                //BUGBUG: need to get OfflineXuid from client
                settings.OfflineXuid = 0;
                //BUGBUG: need to get Principal from client
                settings.Principal = "";
                settings.TitleId = client.TitleId;
                hr = myWebClient.SendRequest(settings, secProv, (live.protocol.proxy.XOService)service, url, httpMethod, 
                    headerstrings, sendData, out responseData);
            }
            catch (WebException e)
            {
                // not a normal failure, so throw
                // default to BadRequest if no response is available.
                HttpWebResponse httpResp = (HttpWebResponse)e.Response;
                HttpStatusCode status = HttpStatusCode.BadRequest;
                string respData = "SendRequest failed. But no response data is available.";
                if (httpResp != null)
                {
                    status = httpResp.StatusCode;
                    respData = httpResp.StatusDescription;

                    // get the X-Err header from response
                    xErr = httpResp.Headers["X-Err"];
                    if (xErr != null)
                    {
                        hr = UInt32.Parse(xErr, System.Globalization.NumberStyles.HexNumber);
                    }

                    if (httpResp.ContentLength > 0)
                    {
                        long contentLen = httpResp.ContentLength;
                        Stream stream = httpResp.GetResponseStream();
                        Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                        // Pipes the stream to a higher level stream reader with the required encoding format. 
                        StreamReader readStream = new StreamReader(stream, encode);
                        char[] read = new char[contentLen];
                        int count = readStream.Read(read, 0, read.Length);
                        //respData = Encoding.UTF8.GetString(read);
                        String str = new String(read, 0, count);
                        respData = str;
                    }
                }

                throw new XrlRequestException(url, e.Message, status, sendData, respData, hr, e);
            }
            return hr;
        }


        public virtual uint SendRequest(
           IClient client,
           XblUser activeUser,
           XOService service,
           string relativeUrl,
           string httpMethod,
           WebHeaderCollection webHeaders,
           XRLObject2 reqOb,
           XRLObject2 respOb)
        {
            uint hr;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            byte[] respData;

            reqOb.SchemaVersion = client.SchemaVersion;

            reqOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if ( (webHeaders["X-Schema-Ver"] == null))
            {
                webHeaders.Add("X-Schema-Ver",
                    WireInfoAttribute.VersionToString(client.SchemaVersion));
            }
            if (webHeaders["Content-Type"] == null && reqOb is live.protocol.next.WebRequestBase)
            {
                ((live.protocol.next.WebRequestBase)reqOb).SetWebHeaders(webHeaders);
            }
            else if (webHeaders["Content-Type"] == null && reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetWebHeaders(webHeaders);
            }

            hr = SendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, stream.ToArray(), out respData);


            if (respOb != null && respData != null && respData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(respData));
                respOb.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respData.Length, null);
            }
            //else if (respOb != null && respData == null)
            //{
            //    throw new Exception("TestGateway 2.0 returned null data when expecting a response"); 
            //}

            return hr;
        }

        virtual public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            string serviceAddress;
            FDTransaction.GetServiceInfo(client, service, out serviceAddress);
            string finalUrl;
            if (this.UseSSL)
            {
                int index = serviceAddress.IndexOf(':');
                serviceAddress = serviceAddress.Remove(index) + ":443";
                finalUrl = "https://" + serviceAddress + relativeUrl;
            }

            else
                finalUrl = "http://" + serviceAddress + relativeUrl;


            return SendRequest(client, service, finalUrl, httpMethod, request, webHeaders, out response);
        }


        // Asynchronous methods
        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   XRLObject2 respOb)
        {
            throw new Exception("Async method not implemented");
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            throw new Exception("Async method not implemented");        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\TG2HttpAuthTransaction.cs ===
﻿using System;

namespace live.protocol
{
    public class TG2HttpAuthTransaction : TGTransaction2
    {
        public TG2HttpAuthTransaction()
        {
            SecurityProvider = new live.client.HttpAuthSecurityProvider();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\TGTransaction.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;

using live.client;
using live.common;

namespace live.protocol
{
    public class TGTransaction : ITransaction
    {
        private static IGConnection _connection;

        internal static IGConnection Connection
        {
            get { return _connection; }
            set { }
        }

        private TGSecurityProvider _securityProvider;
        public IXOnSecurityProvider SecurityProvider
        {
            get
            {
                return _securityProvider;
            }
            set
            {
                _securityProvider = (TGSecurityProvider)value;
            }
        }

        static TGTransaction()
        {
            // StressNet
            //System.Net.IPEndPoint ep = new System.Net.IPEndPoint(System.Net.IPAddress.Parse("10.198.102.205"), 3074);
            //_connection = new IGConnection(ep, "XECLISXXX012");
            IPEndPoint ep = Config.Current.GetIPEndPoint(XOService.PresNotification);
            ep.Port = 3074;
            _connection = new IGConnection(ep, "XECLISXXX019");
        }

        public TGTransaction()
        {
            _securityProvider = new TGSecurityProvider(_connection);
        }

        private byte[] TransactFD(ulong xboxId, uint serviceId, string url, string RequestType, byte[] HttpHeader, byte[] Request)
        {

            IGFDRequest req = new IGFDRequest(xboxId, serviceId, url, RequestType, HttpHeader, Request);
            IGFDResponseData res = _connection.IssueRequest(req, true) as IGFDResponseData;
            return res._rgbResponse;
        }

        private uint SendRequest(
            IClient client,
            XOService service,
            string url,
            string httpMethod,
            byte[] sendData,
            WebHeaderCollection headers,
            out byte[] responseData)
        {
            responseData = null;
            uint hr;
            string xErr;

            _securityProvider.SetAuthentication(service, null, null, headers);


            try
            {
                byte[] httpData = TransactFD(client.MachinePuid, (uint)service, url, 
                    httpMethod, headers.ToByteArray(), sendData);

                if (httpData.Length == 0)
                {
                    throw new Exception("TransactFD() returned 0 byte response from server.  Expected at least HTTP 200 response.");
                }

                hr = HResult.S_OK;

                Dictionary<string, string> respHeaders = HttpHelper.GetHeaders(httpData);
                if(httpData.Length >0)
                    responseData = HttpHelper.GetReponseBody(httpData, httpData.Length);

                if (respHeaders.TryGetValue("X-Err", out xErr))
                {
                    hr = HResult.Parse(xErr);
                }
            }
            catch (WebException e)
            {
                xErr = null;
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available.
                    HttpStatusCode status = (e.Response == null ? HttpStatusCode.BadRequest : ((HttpWebResponse)e.Response).StatusCode);

                    throw new XrlRequestException(url, e.Message, status, sendData, e);
                }

                hr = HResult.Parse(xErr);
                responseData = null;
            }

            return hr;
        }

        public uint SendRequest(
            IClient client,
            XblUser activeUser, 
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            XRLObject2 respOb)
        {
            string serviceAddress;
            FDTransaction.GetServiceInfo(client, service, out serviceAddress);
            //string finalUrl = "http://" + serviceAddress + relativeUrl;

            uint hr;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            byte[] respData;

            reqOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }
            if (webHeaders["Content-Type"] == null)
            {
                webHeaders.Add("Content-Type", "xon/" + ((int)service).ToString("x"));
            }
            // TODO: Ensure the assembly is versioned and use the right version
            if (webHeaders["User-Agent"] == null)
            {
                webHeaders.Add("User-Agent", ((int)service).ToString("x") + "/1.0.4325");
            }
            if ((webHeaders["X-Schema-Ver"] == null))
            {
                webHeaders.Add("X-Schema-Ver",
                    WireInfoAttribute.VersionToString(reqOb.SchemaVersion));
            }

            hr = SendRequest(client, service, relativeUrl, httpMethod, stream.ToArray(), webHeaders, out respData);

            if (respOb != null && respData != null && respData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(respData));
                respOb.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respData.Length, null);
            }

            return hr;
        }

        public uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }
            return SendRequest(client, service, relativeUrl, httpMethod, request, webHeaders, out response);
        }

        // Asynchronous methods
        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   XRLObject2 respOb)
        {
            throw new Exception("Async method not implemented");
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            throw new Exception("Async method not implemented");        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\storageProtocol.cs ===
/*==========================================================================
 *
 *  storageProtocol.cs -- This module defines the wire protocol for Storage 
 *                          server.
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Specialized;

using live.common;

namespace live.protocol
{
    public interface IStorageRequest
    {
        uint Flags { get;}
        uint TitleId { get;}
        uint TitleVersion { get;}
        byte UserCountryId { get; }
        ulong UserPuid { get;}
        ulong XboxPuid { get;}
        AccessToken Token { get; }
        TeamTickets Tickets { get; }
    }


    public interface IStorageRequestLight
    {
        uint TitleId { get;}
        uint TitleVersion { get;}
    }


    // ReqHdrWriteFile
    // Header of the WriteFile request
    public class ReqHdrWriteFile : XRLRequestObject2, IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public byte _userCountryId;
        public byte _compressionType;
        public uint _contentType;
        public byte[] _blobHash;
        public byte[] _blobSignature;
        public uint _blobSizeUncompressed;
        [WireInfo(SizeParam = "_attributes")]
        public ushort _attributesSize;
        public uint _blobSize;

        public byte[] _attributes;
        public WriteFileToken _accessToken;
        public TeamTickets _teamTickets;
        public byte[] _blob = null;

        public string GetXRL()
        {
            return "/stfd/writefile.ashx";
        }

        public override string Xrl
        {
            get { return GetXRL(); }
        }

        // ReadFrom
        // Parse message from stream
        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new WriteFileToken(r);
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _userCountryId = r.ReadByte();
            _compressionType = r.ReadByte();
            _contentType = r.ReadUInt32();
            _blobHash = r.ReadBytes(ProtocolConstants.sizeHash);
            _blobSignature = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed = r.ReadUInt32();
            _attributesSize = r.ReadUInt16();
            _blobSize = r.ReadUInt32();


            _attributes = (0 == _attributesSize) ? null : r.ReadBytes(_attributesSize);

            // read team tickets if flags indicate they are present
            if ((_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket)
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            WriteTo(binaryWriter);
        }

        // WriteTo
        // Write message to stream
        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort)0 : (ushort)_attributes.Length;

            _accessToken.WriteTo(w);

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobHash);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if (_attributes != null)
            {
                w.Write(_attributes);
            }

            if (_teamTickets != null)
            {
                _teamTickets.WriteStream(w);
            }
            w.Write(_blob);
        }

        public void Validate()
        {
            _accessToken.Validate();

            if (_contentType >= (uint)ContentType.Invalid)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEVENT_COMMON_CODE_174,
                    "Validate: invalid content type: " + _contentType);
            }

            if (_compressionType >= (uint)CompressionType.Invalid)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEVENT_COMMON_CODE_175,
                    "Validate: invalid compression type: " + _compressionType);
            }

            if (_attributes != null && _attributes.Length > ProtocolConstants.maxSizeAttributes)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEVENT_COMMON_CODE_176,
                    "Validate: attributes size too large: " + _attributes.Length);
            }
        }

        public override int Size()
        {
            return
                (_accessToken == null ? 0 : _accessToken.Size()) +
                (_attributes == null ? 0 : _attributes.Length) +
                144;
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:" + _titleVersion +
                " _userCountryId:" + _userCountryId +
                " _compressionType:" + _compressionType +
                " _contentType:" + _contentType +
                " _blobHash:" + (_blobHash != null ? "(binary)" : "null") +
                " _blobSignature:" + (_blobSignature != null ? "(binary)" : "null") +
                " _blobSizeUncompressed:" + _blobSizeUncompressed +
                " _attributesSize:" + _attributesSize +
                " _blobSize:" + _blobSize +
                " _attributes:" + (_attributes != null ? "(binary)" : "null") +
                " _accessToken:" + (_accessToken != null ? "(" + _accessToken.ToString() + ")" : "null") +
                " _teamTickets:" + (_teamTickets != null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // ReqReadFile
    // ReadFile request
    public class ReqReadFile : XRLRequestObject2, IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public byte _userCountryId;
        public uint _rangeStart;
        public uint _rangeEnd;
        public long _ifModifiedSinceDate;

        public ReadFileToken _accessToken;
        public TeamTickets _teamTickets;

        public string GetXRL()
        {
            return "/stfd/readfile.ashx";
        }

        public override string Xrl
        {
            get { return GetXRL(); }
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _userCountryId = r.ReadByte();
            _rangeStart = r.ReadUInt32();
            _rangeEnd = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ((_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket)
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_rangeStart);
            w.Write(_rangeEnd);
            w.Write(_ifModifiedSinceDate);

            if (_teamTickets != null)
            {
                _teamTickets.WriteStream(w);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            WriteTo(binaryWriter);
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString() +
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _userCountryId:" + _userCountryId +
                " _rangeStart:" + _rangeStart +
                " _rangeEnd:" + _rangeEnd +
                " _ifModifiedSinceDate:" + _ifModifiedSinceDate +
                " _teamTickets:" + (_teamTickets != null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // EnumeratedReadFilerequest fields
    public class EnumeratedReadFileParameters
    {
        public const string IfModifiedSince = "_ifModifiedSinceDate";

        public const string TitleId = "_titleId";

        public const string TitleVersion = "_titleVersion";

        public const string PathName = "_pathName";

        public const string PathNameSize = "_pathNameSize";

        public const string SendXRLResponse = "_sendXRLResponse";

    }


    // This class represents all of the data of a EnumeratedReadFile 
    public class EnumeratedReadFileInfo
    {
        public ushort _pathNameSize;
        [WireInfo(SizeParam="_pathNameSize")]
        public string _pathName;
        //public long _creationDate = new long();
        public long _modifiedDate = new long();


        public EnumeratedReadFileInfo()
        {
        }

        public EnumeratedReadFileInfo(string path, DateTime modifiedDate)
        {
            _pathName = path;
            _pathNameSize = (ushort)path.Length;
            _modifiedDate = modifiedDate.ToFileTimeUtc();
        }

        public void ReadFrom(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryReader reader = new BinaryReader(stream))
                {
                    _pathNameSize = reader.ReadUInt16();
                    if (_pathNameSize > 0)
                    {
                        //_pathName = Encoding.ASCII.GetString(reader.ReadBytes(_pathNameSize));
                        _pathName = reader.ReadString();
                    }
                    _modifiedDate = reader.ReadInt64();
                    //_creationDate = reader.ReadInt64();
                }
            }
        }

        public void WriteTo(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryWriter w = new BinaryWriter(stream))
                {
                    w.Write(_pathNameSize);
                    if (_pathNameSize > 0)
                        w.Write(_pathName);
                    w.Write(_modifiedDate);
                    //w.Write(_creationDate);
                }
            }
        }

        public int Size()
        {

            if (_pathNameSize == 0)
                return (int)(sizeof(ushort) + sizeof(long));
            else
                return (int)(sizeof(ushort) + sizeof(long) + (_pathName.Length * sizeof(char)));
        }


        // ToString
        public override string ToString()
        {
            return (
                " _path :" + _pathName
                //+ " _creationDate:" + _creationDate
                + " _modifiedDate:" + _modifiedDate);
        }

    }


    // ReqEnumeratedReadFile
    // EnumeratedReadFile request
    public class ReqEnumeratedReadFile : IStorageRequestLight
    {
        public long _ifModifiedSinceDate;
        public uint _titleId;
        public uint _titleVersion;
        public ushort _pathNameSize;
        public string _pathName;

        //public uint _rangeStart;
        //public uint _rangeEnd;
        //public ReadFileToken _accessToken;

        public string GetXRL()
        {
            return "/stfd/enumeratedreadfile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _pathNameSize = r.ReadUInt16();
            if (_pathNameSize > 0)
            {
                _pathName = r.ReadString();
            }
            _ifModifiedSinceDate = r.ReadInt64();

            //_accessToken = new ReadFileToken(r);
            //_rangeStart = r.ReadUInt32();
            //_rangeEnd = r.ReadUInt32();           

        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_pathNameSize);
            w.Write(_pathName);
            w.Write(_ifModifiedSinceDate);
        }

        public ReqEnumeratedReadFile()
        {

        }

        public ReqEnumeratedReadFile(NameValueCollection parameters)
        {


            string[] values = new string[] { };
            string key = "";

            //PathName parameter
            key = EnumeratedReadFileParameters.PathName;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length != 1))
            {
                throw new ApplicationException(" PathName parameter required ");
            }
            else if (values.Length == 1)
            {
                _pathName = parameters[key];
            }


            //PathNameSize
            _pathNameSize = Convert.ToUInt16(_pathName.Length);


            //IfModifiedSince parameter
            key = EnumeratedReadFileParameters.IfModifiedSince;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _ifModifiedSinceDate = 0;
            }
            else if (values.Length == 1)
            {
                _ifModifiedSinceDate = Convert.ToDateTime(parameters[key]).ToFileTime();
            }
            else
            {
                throw new ApplicationException(" Only one IfModifiedSinceDate parameter expected");
            }


            //TitleId parameter
            key = EnumeratedReadFileParameters.TitleId;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleId = 0;
            }
            else if (values.Length == 1)
            {
                _titleId = Convert.ToUInt32(parameters[key]);
            }

            else
            {
                throw new ApplicationException(" Only one TitleId parameter expected");
            }


            //TitleVersion parameter
            key = EnumeratedReadFileParameters.TitleVersion;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleVersion = 0;
            }
            else if (values.Length == 1)
            {
                _titleVersion = Convert.ToUInt32(parameters[key]);
            }
            else
            {
                throw new ApplicationException(" Only one TitleVersion parameter expected");
            }
        }


        public void Validate()
        {
            //_accessToken.Validate();
            if (_pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName)
            {
                //XommTrace(atTrace, L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEVENT_COMMON_CODE_148,
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if (_pathNameSize != _pathName.Length)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, //XEVENT_COMMON_CODE_149,
                    "Validate: pathNameSize mismatch.");
            }

        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _pathNameSize:" + _pathNameSize +
                " _pathName:" + _pathName +
                " _ifModifiedSinceDate:" + _ifModifiedSinceDate
                ;
        }

        // Implement StorageRequest properties
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
    }

    // RepReadFile
    // ReadFile reply header
    public class RepHdrReadFile : XRLObject2
    {
        public uint _titleId = 0;
        public uint _titleVersion = 0;
        public ulong _userPuid = 0;
        public byte _userCountryId = 0;
        public ulong _xboxPuid = 0;
        public byte _compressionType = 0;
        public uint _contentType = 0;
        public byte[] _blobSignature = new byte[ProtocolConstants.sizeSignature];
        public uint _blobSizeUncompressed = 0;
        public long _creationDate = 0;
        public long _modifiedDate = 0;
        public ushort _attributesSize = 0;
        public uint _blobSize = 0;
        public byte[] _attributes = null;
        public byte[] _blob = null;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            ReadFrom(binaryReader);
            return this;
        }

        public void ReadFrom(BinaryReader r)
        {
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _userPuid = r.ReadUInt64();
            _userCountryId = r.ReadByte();
            _xboxPuid = r.ReadUInt64();
            _compressionType = r.ReadByte();
            _contentType = r.ReadUInt32();
            _blobSignature = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed = r.ReadUInt32();
            _creationDate = r.ReadInt64();
            _attributesSize = r.ReadUInt16();
            _blobSize = r.ReadUInt32();

            if (_attributesSize > 0)
            {
                _attributes = r.ReadBytes(_attributesSize);
            }

            _blob = r.ReadBytes((int)_blobSize);
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort)0 : (ushort)_attributes.Length;

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if (_attributes != null)
            {
                w.Write(_attributes);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:" + _titleVersion +
                " _userPuid:0x" + _userPuid.ToString("X") +
                " _userCountryId:" + _userCountryId +
                " _xboxPuid:0x" + _xboxPuid.ToString("X") +
                " _compressionType:" + _compressionType +
                " _contentType:" + _contentType +
                " _blobSignature:" + _blobSignature +
                " _blobSizeUncompressed:" + _blobSizeUncompressed +
                " _creationDate:" + _creationDate +
                " _modifiedDate:" + _modifiedDate +
                " _attributesSize:" + _attributesSize +
                " _blobSize:" + _blobSize +
                " _attributes:" + (_attributes != null ? "(binary)" : "null");
        }
    }


    // RepEnumeratedReadFile
    // EnumeratedReadFile reply header
    public class RepHdrEnumeratedReadFile
    {
        public string _path;
        public long _creationDate;
        public long _modifiedDate;

        public void ReadFrom(BinaryReader r)
        {
            _creationDate = r.ReadInt64();
        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_creationDate);
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return (
                " _path :" + _path +
                " _modifiedDate:" + _modifiedDate +
                " _creationDate:" + _creationDate);
        }
    }


    public class ReqRemoveFile : XRLRequestObject2, IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public RemoveFileToken _accessToken;
        public TeamTickets _teamTickets;

        public string GetXRL()
        {
            return "/stfd/removefile.ashx";
        }

        public override string Xrl
        {
            get { return GetXRL(); }
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new RemoveFileToken(r);
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();

            // read team tickets if flags indicate they are present
            if ((_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket)
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            WriteTo(binaryWriter);
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);

            if (_teamTickets != null)
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        public override string ToString()
        {
            return
                _accessToken.ToString() +
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _teamTickets:" + (_teamTickets != null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return 0; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    public class ReadFileHashRequest : XRLRequestObject2
    {
        [WireInfoAttribute(Min = 1, Max = ProtocolConstants.maxSizeName)]
        public ushort pathNameLen;

        [WireInfoAttribute(SizeParam = "pathNameLen")]
        public string pathName;

        public override string Xrl
        {
            get { return "/stfd/readfilehash.ashx"; }
        }

        public override string ToString()
        {
            return
                " pathNameLen:" + pathName.Length +
                " pathName:" + pathName;
        }
    }

    public class ReadFileHashResponse : XRLObject2
    {
        [WireInfoAttribute(ArraySize = (int)ProtocolConstants.sizeHash)]
        public byte[] hash;

        public override string ToString()
        {
            return
                " hash:" + (hash == null ? "" : ByteConvert.ToString(hash));
        }
    }

    public class GetQuotaRequest : XRLRequestObject2
    {
        public uint _domainId;
        public uint _titleId;
        public uint _keyType;
        public ulong _keyValue;

        public override string Xrl
        {
            get { return "/stfd/getquota.ashx"; }
        }

        public override int Size()
        {
            return 20;
        }
    }

    public class GetQuotaResponse : XRLObject2
    {
        public ulong _maxFileSize;
        public ulong _totalBytesMax;
        public ulong _totalBytesUsed;
        public uint _totalFilesMax;
        public uint _totalFilesUsed;

        public override int Size()
        {
            return 24;
        }
    }

    public class ReportBrokenLinkRequest : XRLRequestObject2
    {
        public uint statusData;

        [WireInfoAttribute(Min = 1, Max = XOn.MAX_STORAGE_PATHNAME_LENGTH * XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam = "pathnameLen", Min = 1, Max = XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameRequest : XRLRequestObject2
    {
        [WireInfoAttribute(Min = 1, Max = XOn.MAX_STORAGE_PATHNAME_LENGTH * XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam = "pathnameLen", Min = 1, Max = XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameResponse : XRLObject2
    {
        public uint primaryIP;
        public ushort primaryPort;
        public uint alternateIP;
        public ushort alternatePort;
        public DateTime expiration;
        public ushort ruleLen;

        [WireInfoAttribute(SizeParam = "ruleLen")]
        public string rule;
    }

    // ReqEnumerateFiles
    // EnumerateFile request
    public class ReqEnumerateFiles : XRLRequestObject2, IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public byte _userCountryId;
        public uint _resultsStart;
        public uint _resultsEnd;
        public long _ifModifiedSinceDate;

        public ReadFileToken _accessToken;
        public TeamTickets _teamTickets;

        public string GetXRL()
        {
            return "/stfd/enumeratefiles.ashx";
        }

        public override string Xrl
        {
            get { return GetXRL(); }
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _userCountryId = r.ReadByte();
            _resultsStart = r.ReadUInt32();
            _resultsEnd = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ((_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket)
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            WriteTo(binaryWriter);
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_resultsStart);
            w.Write(_resultsEnd);
            w.Write(_ifModifiedSinceDate);

            if (_teamTickets != null)
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString() +
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _userCountryId:" + _userCountryId +
                " _resultsStart:" + _resultsStart +
                " _resultsEnd:" + _resultsEnd +
                " _ifModifiedSinceDate:" + _ifModifiedSinceDate +
                " _teamTickets:" + (_teamTickets != null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    public class RepEnumerateFilesResponse : XRLObject2
    {
        public uint numFilesTotal;	// total number of files matching the request
        public uint resultsLen;		// actual number of files returned in the response
        public RepEnumerateFiles[] results;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            numFilesTotal = binaryReader.ReadUInt32();
            resultsLen = binaryReader.ReadUInt32();
            results = new RepEnumerateFiles[resultsLen];
            for (int i = 0; i < resultsLen; i++)
            {
                results[i] = new RepEnumerateFiles();
                results[i].ReadFrom(binaryReader);
            }
            return this;
        }
    }

    // RepEnumerateFiles
    // ReadFile reply header
    public class RepEnumerateFiles : XRLObject2
    {
        public uint _titleId = 0;
        public uint _titleVersion = 0;
        public ulong _userPuid = 0;
        public byte _userCountryId = 0;
        public ulong _xboxPuid = 0;
        public uint _contentType = 0;
        public uint _blobSize = 0;
        public uint _blobSizeUncompressed = 0;
        public long _creationDate = 0;
        public long _modifiedDate = 0;
        public ushort _pathNameSize = 0;
        public ushort _attributesSize = 0;
        public string _pathName = null;
        public byte[] _attributes = null;

        public void ReadFrom(BinaryReader r)
        {
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _userPuid = r.ReadUInt64();
            _userCountryId = r.ReadByte();
            _xboxPuid = r.ReadUInt64();
            _contentType = r.ReadUInt32();
            _blobSize = r.ReadUInt32();
            _blobSizeUncompressed = r.ReadUInt32();
            _creationDate = r.ReadInt64();
            _modifiedDate = r.ReadInt64();
            _attributesSize = r.ReadUInt16();
            _pathNameSize = r.ReadUInt16();

            if (_attributesSize > 0)
            {
                _attributes = r.ReadBytes(_attributesSize);
            }
            if (_pathNameSize > 0)
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort)0 : (ushort)_attributes.Length;

            byte[] encName = null;
            if (_pathName != null)
            {
                encName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort)encName.Length;
            }
            else
            {
                _pathNameSize = 0;
            }

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_contentType);
            w.Write(_blobSize);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_modifiedDate);
            w.Write(_attributesSize);
            w.Write(_pathNameSize);

            if (_attributes != null)
            {
                w.Write(_attributes);
            }
            if (_pathName != null && _pathNameSize > 0)
            {
                w.Write(encName);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:" + _titleVersion +
                " _userPuid:0x" + _userPuid.ToString("X") +
                " _userCountryId:" + _userCountryId +
                " _xboxPuid:0x" + _xboxPuid.ToString("X") +
                " _contentType:" + _contentType +
                " _blobSize:" + _blobSize +
                " _blobSizeUncompressed:" + _blobSizeUncompressed +
                " _creationDate:" + _creationDate +
                " _modifiedDate:" + _modifiedDate +
                " _attributesSize:" + _attributesSize +
                " _attributes:" + (_attributes != null ? "(binary)" : "null") +
                " _pathNameSize:" + _pathNameSize +
                " _pathName:" + _pathName;
        }
    }

    public class Translator
    {
        public static ReqReadFile TranslateRequest(ReqEnumeratedReadFile reqEnum)
        {
            ReqReadFile reqReadFile = new ReqReadFile();

            reqReadFile._accessToken = null;
            reqReadFile._ifModifiedSinceDate = reqEnum._ifModifiedSinceDate;
            reqReadFile._titleId = reqEnum._titleId;
            reqReadFile._titleVersion = reqEnum._titleVersion;

            reqReadFile._rangeEnd = reqReadFile._rangeStart = 0;

            return reqReadFile;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\UDPTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.client;
using System.Net;
using System.Net.Sockets;

namespace live.protocol
{
    public class UDPTransaction : ITransaction, IDisposable
    {
        EmptySecurityProvider _securityProvider;
        public const int TimeOutMS = 2000;

        #region ITransaction Members

        public IXOnSecurityProvider SecurityProvider
        {
            get
            {
                if (_securityProvider == null)
                {
                    _securityProvider = new EmptySecurityProvider();
                }
                return _securityProvider;
            }
            set
            {
            }
        }

        public uint SendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, System.Net.WebHeaderCollection webHeaders, XRLObject2 reqOb, XRLObject2 respOb)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public uint SendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, System.Net.WebHeaderCollection webHeaders, byte[] request, out byte[] response)
        {
            IPEndPoint serverIP = Config.Current.GetIPEndPoint(client, service);

            SendFast(request, request.Length, serverIP);

            int length;
            byte[] recv = RecvFast(TimeOutMS, out length);
            response = new byte[length];
            for (int i = 0; i < length; i++)
            {
                response[i] = recv[i];
            }

            return (length > 0 ? HResult.S_OK : HResult.E_FAIL);

        }

        // Asynchronous methods
        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   XRLObject2 respOb)
        {
            throw new Exception("Async method not implemented");
        }

        public IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state)
        {
            throw new Exception("Async method not implemented");
        }

        public uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            throw new Exception("Async method not implemented");        
        }

        #endregion

        private Socket _sock;

        private byte[] _recvBuffer;
        private int _oSendBuffer;
        private int _oRecvBuffer;

        // Incremented for every ConnectionReset event we get, which the SG is supposed to 
        // send for every key exchange. Allow this to be publicly read so we can verify the 
        // SG did this.
        public int connResetCounter = 0;

        // The remote connection after Recv()
        public EndPoint epRemote = new IPEndPoint(IPAddress.Any, 0);

        public IPEndPoint LocalIP
        {
            get
            {
                return (IPEndPoint)udpSocket.LocalEndPoint;
            }
        }

        public UDPTransaction()
        {
        }

        protected Socket udpSocket
        {
            get
            {
                if (_sock == null)
                {
                    ReCreate();
                }

                return _sock;
            }
        }


        public void Reset()
        {
            _sock = null;
        }

        private void ReCreate()
        {
            _sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            EndPoint epLocal = (EndPoint)new IPEndPoint(IPAddress.Any, 0);
            _sock.Bind(epLocal);
            if (_recvBuffer == null || _recvBuffer.Length != 3000)
                _recvBuffer = new byte[3000];

            // Socket options
            _oSendBuffer = (int)_sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer);
            _oRecvBuffer = (int)_sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer);
            _oSendBuffer *= 2;
            _oRecvBuffer *= 2;
            _sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, _oSendBuffer);
            _sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, _oRecvBuffer);

        }

        public void Send(byte[] pb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, host);
            if (sentBytes != pb.Length)
                throw new Exception("UDP send failed.");
        }

        public void SendFast(byte[] pb, int cb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, 0, cb, System.Net.Sockets.SocketFlags.None, host);
            if (sentBytes != cb)
                throw new Exception("UDP send failed.");
        }


        public byte[] Recv(int timeoutInMs)
        {
            int packetSize = 0;
            RecvFast(timeoutInMs, out packetSize);
            if (packetSize > 0)
            {
                byte[] smallBuf = new byte[packetSize];
                Array.Copy(_recvBuffer, 0, smallBuf, 0, packetSize);
                return smallBuf;
            }
            return null;
        }

        public byte[] RecvFast(int timeoutInMs, out int packetSize)
        {
            RecvFast(timeoutInMs, _recvBuffer, out packetSize);
            if (packetSize > 0)
                return _recvBuffer;
            else
                return null;
        }

        public void RecvFast(int timeoutInMs, byte[] buffer, out int packetSize)
        {
            DateTime begin = DateTime.Now;

            packetSize = 0;
            connResetCounter = 0;
        TryAgain:
            if (udpSocket.Poll(timeoutInMs * 1000, SelectMode.SelectRead))
            {
                try
                {
                    packetSize = udpSocket.ReceiveFrom(buffer, ref epRemote);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    // WSAECONNRESET
                    // This happens when we receive an ICMP Port Unreachable packet.
                    // The SG happens to send one out for every KeyExXbToSgInit message.
                    // It does this because of some Netgear router bug. WinSock is kinda
                    // stupid here -- this is a *connectionless* protocol after all so it should
                    // just swallow a connection reset message -- so let's try it again. 
                    // This should succeed and read the reply that actually was sent.
                    if (e.ErrorCode == 10054 && connResetCounter < 1)
                    {
                        connResetCounter++;
                        timeoutInMs -= (int)(DateTime.Now.Subtract(begin).TotalMilliseconds);
                        if (timeoutInMs > 0)
                        {
                            goto TryAgain;
                        }
                    }
                    else
                    {
                        throw e;
                    }
                }
            }
        }

        public byte[] SendRecv(byte[] pb, string IP, ushort port, int timeOut)
        {
            return SendRecv(pb, new IPEndPoint(IPAddress.Parse(IP), port), timeOut);
        }

        public byte[] SendRecv(byte[] pb, IPEndPoint host, int timeOut)
        {
            Send(pb, host);
            return Recv(timeOut);
        }

        /// <summary>
        /// The callback function for use with RecvAsync.
        /// </summary>
        /// <param name="state">The state object passed in to RecvAsync.</param>
        /// <param name="buffer">The buffer passed in to RecvAsync.</param>
        /// <param name="length">The amount of data that was read into the buffer.</param>
        /// <param name="endpoint">The location that the packet came from.</param>
        /// <param name="connection_reset">True if the connection was reset, false if not.</param>
        /// <param name="exc">The exception, if any, that was thrown by EndReceiveFrom.</param>
        public delegate void RecvAsyncCallback(object state, byte[] buffer, int length, IPEndPoint endpoint,
            bool connection_reset, Exception exc);

        protected class RecvAsyncState
        {
            public Socket Socket = null;
            public byte[] Buffer = null;
            public RecvAsyncCallback Callback = null;
            public object State = null;
            public EndPoint Location = new IPEndPoint(IPAddress.Any, 0);
            public bool ConnReset = false;
        }

        /// <summary>
        /// Asynchronously receives data from the socket.
        /// </summary>
        /// <param name="buffer">The buffer to fill with data. It is suggested to be 1500 bytes.</param>
        /// <param name="callback">The callback function.</param>
        /// <param name="state">The state object for use by the callback function.</param>
        public void RecvAsync(byte[] buffer, RecvAsyncCallback callback, object state)
        {
            RecvAsyncState state_obj = new RecvAsyncState();
            state_obj.Socket = udpSocket;
            state_obj.Buffer = buffer;
            state_obj.Callback = callback;
            state_obj.State = state;

            state_obj.Socket.BeginReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref state_obj.Location,
                RecvAsyncEnd, state_obj);
        }

        protected void RecvAsyncEnd(IAsyncResult result)
        {
            RecvAsyncState state = (RecvAsyncState)result.AsyncState;

            int read = 0;
            Exception exc = null;

            try
            {
                read = state.Socket.EndReceiveFrom(result, ref state.Location);
            }
            catch (SocketException e)
            {
                // WSAECONNRESET
                if (e.ErrorCode == 10054 && !state.ConnReset)
                {
                    state.ConnReset = true;
                    state.Socket.BeginReceiveFrom(state.Buffer, 0, state.Buffer.Length, SocketFlags.None,
                        ref state.Location, RecvAsyncEnd, state);
                    return;
                }
                else
                {
                    exc = e;
                }
            }
            catch (Exception e)
            {
                exc = e;
            }

            state.Callback(state.State, state.Buffer, read, (IPEndPoint)state.Location, state.ConnReset, exc);
        }

        #region IDisposable Members

        ~UDPTransaction()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (_sock != null)
            {
                _sock.Close();
                _sock = null;
            }
            GC.SuppressFinalize(this);
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\UacsProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Caching;
using System.Text;
using System.Diagnostics;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.InteropServices;

using live.common;
using live.client;
using xonline.core.wiredata;

namespace live.protocol
{
    public class AcceptTermsOfUseRequest : XRLObject2
    {
        public ulong userPuid = 0;

        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/AcceptTou.ashx"; }
        }
    }


    public class ChangeGamertagRequest : XRLObject2
    {
        public ulong machinePuid     = 0;

        public ulong userPuid        = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag       = "";

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/ChangeGamertag.ashx"; }
        }
    }

    public class ChangeGamertagResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key  = null;    // new key
    }


    public class ClearSubscriptionsRequest : XRLObject2
    {
        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/ClearSubscriptions.ashx"; }
        }
    }

    public class EnumerateEligibleRequest : XRLObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public uint        rating;

        public DateTime    lastChangedDate = DateTime.Now;

        public uint        offeringType;

        public uint        bitFilter;

        public uint        descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort      languageId;

        public ushort      voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string      voucher;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/EnumerateEligible.ashx"; }
        }
    }

    public class GetANIDRequest : XRLRequestObject2
    {
        public ulong userXuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetANID.ashx"; }
        }
    }

    public class GetANIDResponse : XRLObject2
    {
        public ushort AnidLength;

        [WireInfo(SizeParam = "AnidLength")]
        public string userAnid;

        public uint anidHr;
    }
    public class GetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/GetPaymentInfo.ashx"; }
        }
     }

    public class GetPaymentInfoResponse : XRLObject2
    {
        public byte countryId;

        public byte cardTypeId;

        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength")]
        public string cardNumber;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits;
    }

    public class GetPostalCodeRequest : XRLObject2
    {
        public byte countryId = 0;

        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/GetPostalCode.ashx"; }
        }
    }

    public class GetPostalCodeResponse : XRLObject2
    {
        public byte matchCount;

        [WireInfo(SizeParam="matchCount")]
        public PostalCodeMatch[] match;
    }

    public class PostalCodeMatch : XRLObject2
    {
        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        public ushort provinceLength = 0;

        [WireInfo(SizeParam="provinceLength")]
        public string province = String.Empty;

        public ushort cityLength = 0;

        [WireInfo(SizeParam="cityLength")]
        public string city = String.Empty;

        public ushort streetLength = 0;

        [WireInfo(SizeParam="streetLength")]
        public string street = String.Empty;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateAccountRequest : XRLRequestObject2, ICreateAccountRequest
    {
        public ulong machinePuid;

        public uint titleId;

        public DateTime birthdate;

        public byte msSpam;

        public byte partnerSpam;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte cardTypeId;

        public DateTime cardExpiration;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort activationCodeLength;

        [WireInfo(SizeParam="activationCodeLength")]
        public string activationCode;

        [WireInfo(Serialize=false)]
        public string countryCode;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/CreateOwnerAcct.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get
            {
                PhoneInfoData pi = new PhoneInfoData();
                pi.phonePrefix = phonePrefix;
                pi.phoneNumber = phoneNumber;
                pi.phoneExtension = phoneExtension;
                return pi;
            }
        }
        public AddressInfoData AddressInfo
        {
            get
            {
                AddressInfoData ai = new AddressInfoData();
                ai.street1 = street1;
                ai.street2 = street2;
                ai.city = city;
                ai.district = district;
                ai.state = state;
                ai.postalCode = postalCode;
                return ai;
            }
        }
        public byte PaymentInstrumentType
        {
            get { return (byte) 1; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get
            {
                CreditCardInfoData cci = new CreditCardInfoData();
                cci.accountHolderName = cardHolder;
                cci.accountNumber = cardNumber;
                cci.cardType = cardTypeId;
                cci.expirationDate = cardExpiration;
                return cci;
            }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
    }

    public class CreateAccountResponse : XRLObject2
    {
        public ulong puid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    public class GetSubscriptionInfoRequest : XRLRequestObject2
    {
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionInfo.ashx"; }
        }
    }

    public class GetSubscriptionInfoResponse : XRLObject2
    {
        public byte subscriptionLengthInMonths;

        public uint paymentTypeId;
    }

    public class GetSubscriptionStatusRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public uint  serviceId;

        public uint  languageId;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusResponse : XRLObject2
    {
        public ulong currentOfferId;

        public byte  currentOfferStatus;

        public byte  anniversaryDate;

        public DateTime startDate;

        public DateTime endDate;

        public uint  renewalGracePeriod;

        public byte  renewalStatus;

        public ulong renewalOfferId;

        //
        // + Details object for current offer
        //
        public GetSubscriptionStatusDetailsData currentOfferDetails;

        //
        // + Details object for renewal offer if applicable
        //

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusDetailsData : XRLObject2
    {
        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string ISOCode;

        public uint   offeringDetails;
    }

    // requests that contain account recovery type information should
    // implement this so the common comparison routine can be used.
    public interface IRecoveryRequest
    {
        string PostalCode { get; }
        string PhonePrefix { get; }
        string PhoneNumber { get; }
        string PhoneExtension { get; }
        string CardHolder { get; }
        string CardNumber { get; }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class LinkWebAccountRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(Min=1)]
        public uint credentialType;

        [WireInfo(Min=1, Max=128)] // TODO: fix the max value
        public ushort webIdLen;

        [WireInfo(SizeParam="webIdLen")]
        public byte[] webId;

        public byte webIdIsOwner;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/LinkWebAccount.ashx"; }
        }
    }

    public class LinkWebAccountResponse : XRLObject2
    {
        public ulong userPuid;

        public ulong ownerPuid;

        public ulong oldUserWebPuid;

        public ulong oldOwnerWebPuid;
    }

    public class RenewSubscriptionRequest : XRLObject2
    {
        public ulong    userPuid;

        public ulong    machinePuid;

        public uint     titleId;

        public ulong    offerId;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort   voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string   voucher;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/RenewSubscription.ashx"; }
        }
    }

    public class ReserveNameRequest : XRLObject2
    {
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public string Xrl
        {
            get { return "/xuacs/ReserveName.ashx"; }
        }
    }

    public class ReserveNameSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class ReserveNameResponse : XRLObject2
    {
        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public ReserveNameSuggestedName[] names;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class RestoreAccountRequest : XRLObject2, IRecoveryRequest
    {
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/RestoreAccount.ashx"; }
        }
    }

    public class RestoreAccountResponse : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class SetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH)]
        public byte[] accountPin;

        public byte countryId;

        public byte cardTypeId;

        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/SetPaymentInfo.ashx"; }
        }
    }

    public class SetUserAccountStatusRequest : XRLObject2
    {
        public ulong puid           = 0;

        public int newTermsOfService = 0;

        public int forceNameChangeRequired = 0;

        public DateTime suspendedUntil = DateTime.Now;

        public ushort totalDaysSuspended = 0;

        public DateTime voiceBannedUntil = DateTime.Now;

        public ushort totalDaysVoiceBanned = 0;

        public uint billingAccountStatus = 0;

        public uint resetPassword = 0;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/SetUserAccountStatus.ashx"; }
        }
    }

    public class TroubleshootAccountRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/TroubleshootAccount.ashx"; }
        }
    }

    public class TroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public uint billingHR;
    }

    public class VerifyBillingPinRequest : XRLObject2
    {
        public ulong  userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/VerifyBillingPIN.ashx"; }
        }
    }

    public class VerifyVoucherRequest : XRLObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/VerifyVoucherGetOffer.ashx"; }
        }
    }

    public class VerifyVoucherResponse : XRLObject2
    {
        public ulong offerId;
    }

    public class SetUserSettingsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   userFlags          =0;        // the new user flags

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/SetUserSettings.ashx"; }
        }
    }

    public class SetUserSettings2Request : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   tier               =0;        // the new tier of the user

        public ushort   userFlags          =0;        // the new user flags

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userPrivileges;               // the new user privileges

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/SetUserSettings2.ashx"; }
        }
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xuacs/useraccount.asmx", "GetPointsBalance", "")]
    public class XeGetPointsBalanceRequest : PayloadRequestWithSSL
    {
        [PayloadParam]
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/xuacs/XeGetPointsBalance.ashx";
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:user-account-data", "GetPointsBalanceResults")]
    public class XeGetPointsBalanceResponse : PayloadResponse
    {
        static byte AboveLowBalance             = 0x01;

        public XeGetPointsBalanceResponse()
        {
            responseFlags = 0;
        }

        [PayloadParam("PointsBalance")]
        public uint pointsBalance;

        [PayloadParam("DmpAccountStatus")]
        public byte dmpAccountStatus;

        public byte responseFlags; // aboveLowBalance

        [PayloadParam("AboveLowBalance")]
        public bool aboveLowBalance
        {
            get
            {
                return IsFlagSet(AboveLowBalance, responseFlags);
            }
            set
            {
                SetFlag(AboveLowBalance, value, ref responseFlags);
            }
        }
    }

    public class UpdateParentalControlsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userRestrictPrivileges;               // the user restricted privileges

        [WireInfo(Min=1, Max=XOn.XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH*XOn.UTF8_MULT)]
        public ushort sourceLength = 0;

        [WireInfo(SizeParam="sourceLength", NullTerminate=true)]
        public string source;

        [WireInfo(MinSchemaVersion = "6.3")]
        public ushort tokenLength = 0;

        [WireInfo(MinSchemaVersion = "6.3", SizeParam = "tokenLength", NullTerminate = false)]
        public PassportSessionToken_WD[] tokens;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint setProfilePermissionEntries = 0;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint clearProfilePermissionEntries = 0;

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/XeUpdateParentalControls.ashx"; }
        }
    }

    public class PassportSessionToken_WD : WireData
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;   // Passport session ticket.
    }

    public class GetUserBillingNotificationsRequest : XRLRequestObject2
    {
        public const byte     flagsAllMessages = 1;

        [WireInfo(HexString=true)]
        public       ulong    userPuid;         // userid to read notifications for

        public       byte     flags;            // Set bit 0 for all messages

        public       DateTime notificationDate; // notifications before this date

        public override string Xrl
        {
            get { return "/xuacs/GetUserBillingNotifications.ashx"; }
        }
    }

    public class UserBillingNotification : WireData
    {
        public const int      notificationIdSubscriptionExpiration = 10020;
        public const int      notificationIdCreditCardDecline      = 20010;

        public       DateTime notificationDate = DateTime.MinValue; // Date of arrival

        public       int      isReadNotification = 0;

        // Protocol only supports
        public       int      notificationId = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      creditCardType = 0; // maps to XONLINE_CREDIT_CARD_TYPE in xondefs.h

        // Valid for notificationId = CreditCardDecline only
        public       ushort   accountNumberLastFour = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      declineReasonId = 0; // maps to XONLINE_CREDIT_CARD_DECLINE_TYPE in xondefs.h

        // Valid for notificationId = SubscriptionExpiration only
        public       DateTime subscriptionExpirationDate;
    }

    public class GetUserBillingNotificationsResponse : XRLObject2
    {
        public const int      MAX_COUNT = 10;

        [WireInfo(Max=MAX_COUNT)]
        public ushort userBillingNotificationsCount;

        [WireInfo(SizeParam="userBillingNotificationsCount")]
        public UserBillingNotification[] userBillingNotifications;
    }

    public class XeGetUserSubscriptionDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public ushort instanceIdLength = 0;

        [WireInfo(SizeParam="instanceIdLength")]
        public string instanceId = "";

        //
        // Helpers for client & widget code
        //
        public string Xrl
        {
            get { return "/xuacs/XeGetUserSubscriptionDetails.ashx"; }
        }
    }

    public class UserSubscriptionDetailsData : XRLObject2
    {
        public const ushort maxFormattedPriceLength = 20;

        public uint wholePart;

        public byte fractionalPart;

        [WireInfo(HexString=true)]
        public byte currencyFormat;

        [WireInfo(Min=0, Max=3)]
        public ushort isoCodeLength;

        [WireInfo(SizeParam="isoCodeLength")]
        public string isoCode;

        [WireInfo(Min=0, Max=maxFormattedPriceLength)]
        public ushort formattedPriceLength;

        [WireInfo(SizeParam="formattedPriceLength")]
        public string formattedPrice;

        [WireInfo(HexString=true)]
        public uint offeringDetails;
    }


    public class XeGetUserSubscriptionDetailsResponse : XRLObject2
    {
        public const ushort maxDescriptionLength = 500;
        public const ushort maxFriendlyNameLength = 50;

        public ushort subscriptionIdLength = 0;

        [WireInfo(SizeParam="subscriptionIdLength")]
        public string subscriptionId = "";

        [WireInfo(Max=maxDescriptionLength)]
        public ushort descriptionLength = 0;

        [WireInfo(SizeParam="descriptionLength")]
        public string description = "";

        public byte currentOfferStatus;
        [WireInfo(MinSchemaVersion = "4.3")]
        public bool delayedCancel;

        [WireInfo(Max=maxFriendlyNameLength)]
        public ushort friendlyNameLength = 0;

        [WireInfo(SizeParam="friendlyNameLength")]
        public string friendlyName = "";

        public byte anniversaryDate;

        public DateTime purchaseDate = DateTime.UtcNow;

        public DateTime activationDate = DateTime.UtcNow;

        public DateTime endDate = DateTime.UtcNow;

        public byte hasViolations;

        public uint renewalGracePeriod;

        public byte renewalOfferStatus;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        public UserSubscriptionDetailsData currentOfferDetails;

        public UserSubscriptionDetailsData renewalOfferDetails;

        public PaymentInstrumentInfoEx paymentInstrument;

    }

    public class XeGetANID : XRLRequestObject2
    {
        public ulong UserXuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetANID.ashx"; }
        }
    }

    public class XeGetANIDResponse : XRLObject2
    {
        public ushort AnidLength;

        [WireInfo(SizeParam = "AnidLength")]
        public string UserAnid;

        public uint anidHr;
    }
}

namespace live.protocol.next
{
    //
    //  Uacs Web Methods
    //
    public abstract class UacsWebRequest : WebRequestBase
    {
        private const string UACS_BASE_URL = "/xuacs/useraccount.asmx/";

        public static class UacsOperation
        {
            public static readonly string GetPointsBalance = "GetPointsBalance";
            public static readonly string SignIn = "SignIn";
        }

        public UacsWebRequest(string operation)
            : base(UACS_BASE_URL, operation)
        {
        }
    }

    public abstract class UacsWebResponse : WebResponseBase
    {
    }

    /// <summary>
    /// GetPointsBalance request
    /// </summary>
    public class GetPointsBalanceWebRequest : UacsWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;

        public GetPointsBalanceWebRequest()
            : base(UacsOperation.GetPointsBalance)
        {
	        this.UseSSL = true;
        }
    }

    /// <summary>
    /// GetPointsBalance response
    /// </summary>
    public class GetPointsBalanceWebResponse : UacsWebResponse
    {
        public int PointsBalance = 0;
        public bool AboveLowBalance = false;
        public byte DmpAccountStatus = 0;
    }

    public class ErrorInfo
    {
        public uint HResult;
        public bool TagChangeRequired;
        public bool AcceptedTermsOfService;
        public bool AccountSuspended;
        public bool SubscriptionLapsed;
        public bool BillingUnavailable;
    }

    public class AccountInfo
    {
        public ulong XboxPuid;
        public ulong LivePuid;
        public string Tag;
        public string CountryCode;
        public bool ParentallyControlled;
        public byte[] Privileges;
        public uint PointsBalance;
        public bool IsLightweight;
    }

    public class SubscriptionInfo
    {
        public ulong XboxOfferId;
        public string BillingInstanceId;
        public string Status;
        public bool HasBillingViolation;
        public bool HasPendingCancel;
        public string MusicNetSku;
        public DateTime StartDate;
        public DateTime EndDate;
    }

    public class SessionInfo
    {
        public byte[] SessionKey;
        public string MusicNetAuthToken;
        public string GeoCountryCode;
    }

    public class SignInResults
    {
        public ErrorInfo ErrorInfo;
        public AccountInfo AccountInfo;
        public SubscriptionInfo SubscriptionInfo;
        public SessionInfo SessionInfo;
    }

    /// <summary>
    /// GetPointsBalance request
    /// </summary>
    public class SignInWebRequest : UacsWebRequest
    {
        public SignInWebRequest()
            : base(UacsOperation.SignIn)
        {
        }
    }

    /// <summary>
    /// GetPointsBalance response
    /// </summary>
    public class SignInWebResponse : UacsWebResponse
    {
        public ErrorInfo ErrorInfo;
        public AccountInfo AccountInfo;
        public SubscriptionInfo SubscriptionInfo;
        public SessionInfo SessionInfo;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\statprot.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;

using live.common;
using live.protocol.Presence;

namespace live.protocol
{
    public class ProtocolConstant
    {
        public const uint   MaxNicknameLength = 31;
        public const uint   MaxSpecsPerRequest = 101;
        public const uint   MaxSpecsPerSetDataRequest = 20;
        public const uint   MaxAttrPerSpec = 64;
        public const uint   MaxAttrPerUnitSpec = 70;
        public const string AttachStorageDomain = "Stats";

        // BUGBUG: review V2 protocol parameters:
        public const uint   MaxProcedureCount = 1000;
        public const uint   MaxUtf8StringParamSize = 1024;
        public const uint   MaxStatPostParamCount = 256;
        public const uint   MaxStatUnitGetSpecs   = 5;
        public const uint   MaxStatUnitEnumEntries = 100;
    }

    // Reserved attribute ids for special types of stats
    public class SpecialAttrib
    {
        public const ushort Rank                = 0xFFFF;
        public const ushort Rating              = 0xFFFE;
        public const ushort Nickname            = 0xFFFD;
        public const ushort LeaderboardSize     = 0xFFFC;
        public const ushort AttachmentPathName  = 0xFFFB;
        public const ushort AttachmentSize      = 0xFFFA;
        public const ushort UnitActivity        = 0xFFF9;
        public const ushort UnitLastPlayedDate  = 0xFFF8;

        // MuSigma attributes
        public const ushort Skill               = 61;
        public const ushort GamesPlayed         = 62;
        public const ushort Mu                  = 63;
        public const ushort Sigma               = 64;
    }

    public class StatParam
    {
        public const byte Null         = 0;
        public const byte Int8         = 1;
        public const byte Int16        = 2;
        public const byte Int32        = 3;
        public const byte Int64        = 4;
        public const byte Float        = 5;
        public const byte Utf8string   = 6;
        public const byte Puid         = 7;

        static public byte MapFromAttrType(AttrType attrType)
        {
            byte statParamType = 0;

            switch (attrType)
            {
                case AttrType.None:
                    statParamType = StatParam.Null;
                    break;

                case AttrType.Long:
                    statParamType = StatParam.Int32;
                    break;

                case AttrType.LongLong:
                    statParamType = StatParam.Int64;
                    break;

                case AttrType.Double:
                    statParamType = StatParam.Float;
                    break;

                case AttrType.String:
                    statParamType = StatParam.Utf8string;
                    break;

                default:
                    throw new Exception("Invalid AttrType " + attrType.ToString() + " to StatParam");
            }

            return statParamType;
        }

        static public AttrType MapToAttrType(byte statParamType)
        {
            AttrType attrType = AttrType.None;

            switch (statParamType)
            {
                case StatParam.Null:
                    attrType = AttrType.None;
                    break;

                case StatParam.Int8:
                case StatParam.Int16:
                case StatParam.Int32:
                    attrType = AttrType.Long;
                    break;

                case StatParam.Puid:
                case StatParam.Int64:
                    attrType = AttrType.LongLong;
                    break;

                case StatParam.Float:
                    attrType = AttrType.Double;
                    break;

                case StatParam.Utf8string:
                    attrType = AttrType.String;
                    break;

                default:
                    throw new Exception("Invalid StatParam " + statParamType.ToString() + " to AttrType");
            }

            return attrType;
        }
    }

    public class StatPostProcedure
    {
        public const ushort Replace     = 0x8001;
        public const ushort ReplaceUnit = 0x8002;
        public const ushort Add         = 0x8003;
        public const ushort AddUnit     = 0x8004;
        public const ushort Elo         = 0x8005;
        public const ushort EloUnit     = 0x8006;
        public const ushort If          = 0x8007;
        public const ushort IfUnit      = 0x8008;
        public const ushort Min         = 0x8009;
        public const ushort MinUnit     = 0x800A;
        public const ushort Max         = 0x800B;
        public const ushort MaxUnit     = 0x800C;
        public const ushort MuSigma     = 0x800D;
        public const ushort MuSigmaEx   = 0x800E;
    }

    public class StatPostIfComparisonType
    {
        public const byte Equal             = 1;
        public const byte Greater           = 2;
        public const byte GreaterOrEqual    = 3;
        public const byte Less              = 4;
        public const byte LessOrEqual       = 5;
        public const byte Exist             = 6;
        public const byte NotExist          = 7;
        public const byte NotEqual          = 8;
    }

    public class UnitEnumFlags
    {
        public const uint   SortActivity = 1;
        public const uint   SortRating   = 2;
        //public const uint   NoTags       = 4; // BUGBUG: implement this back someday
    }

    // Attribute types
    public enum AttrType
    {
        None        = 0,
        Long        = 1,
        LongLong    = 2,
        Double      = 3,
        String      = 4
    }

    /// <summary>
    /// StatLbIdParser
    /// </summary>
    /// <remarks>
    /// Leaderboard ID parser helper class
    /// </remarks>
    public class StatLbIdParser
    {
        public const int MaxCompetitionPartitions = 4;
        public const uint PartitionMask           = 0xC0000000;
        public const uint TemplateMask            = 0x3C000000;
        public const uint CompetitionMask         = PartitionMask | TemplateMask;
        public const int  TemplateShift           = 26;
        public const int  PartitionShift          = 30;
        public const uint SkillMask               = 0x02000000;

        public const uint SkillModeMask           = 0x0000ffff;
        public const uint SkillTypeMask           = 0xffff0000;

        public const uint SkillTypeRanked         = 0xffff0000;
        public const uint SkillTypeStandard       = 0xfffe0000;


        static public bool IsCompetition(uint uiLbId)
        {
            return ((uiLbId & CompetitionMask) != 0) && !IsSkill(uiLbId);
        }

        static public bool IsSkill(uint uiLbId)
        {
            return ((uiLbId & SkillMask) != 0);
        }

        static public bool IsRankedSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeRanked);
        }
        static public bool IsStandardSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeStandard);
        }
        static public uint GetGameModeId(uint uiLbId)
        {
            return (uiLbId & SkillModeMask);
        }

        static public byte GetPartition(uint uiLbId)
        {
            return (byte)((uiLbId & PartitionMask) >> PartitionShift);
        }

        static public uint GetTemplateId(uint uiLbId)
        {
            return (uiLbId & TemplateMask) >> TemplateShift;
        }

    }

    #region Stats/Leaderboard V1 (XBOX) Protocol

    /// <summary>
    /// MsgSetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Count of attributes</param>
    /// <param name="Attribs">Attribute data message</param>
    /// <returns>
    /// RepSetDataCanUploadAtt for S_CAN_UPLOAD_ATT
    /// </returns>
    public class MsgSetData
    {
        public uint             _uiTitleId;     // Title Id
        public ulong            _ulUserId;      // User PUID
        public uint             _uiLbId;        // Leaderboard Id
        public uint             _uiAttrCount;   // Attribute count
        public MsgAttribData[]  _attribs;       // Attributes. Number of objects is _uiAttrCount

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _ulUserId       = reader.ReadUInt64();

            if(_ulUserId == 0)
                throw new Exception("_ulUserId cannot be zero.");

            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount cannot be zero.");

            if(_uiAttrCount > ProtocolConstant.MaxAttrPerSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, //XEvent.Id.XSTATSFD_INVALID_REQUEST,
                    "_uiAttrCount ("+_uiAttrCount+") > " + ProtocolConstant.MaxAttrPerSpec);

            _attribs        = new MsgAttribData[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attribs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataCanUploadAtt
    /// </summary>
    /// <param name="AccessToken">Storage access token</param>
    /// <param name="RefCount">Count of objects in Refs</param>
    /// <param name="Refs">Leaderboard/User pairs</param>
    /// <remarks>
    /// Response object with a storage access token that allows an attachment to be uploaded
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataCanUploadAtt
    {
        public WriteFileToken   _accessToken;               // Storage access token
        public ushort                   _usRefCount;        // # of objects in _refs
        public RepSetDataReference[]    _refs;              // Lb/User pairs that will have a reference to this attachment. Size is _usRefCount

        public void WriteTo(BinaryWriter writer)
        {
            _usRefCount = (ushort) _refs.Length;

            _accessToken.WriteTo(writer);
            writer.Write(_usRefCount);
            foreach(RepSetDataReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _accessToken        = new WriteFileToken();
            _accessToken.ReadFrom(reader);
            _usRefCount         = reader.ReadUInt16();
            _refs               = new RepSetDataReference[_usRefCount];
            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new RepSetDataReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_accessToken: " + _accessToken.ToString() +
                "\n_usRefCount=" + _usRefCount);

            for(int ndx=0; ndx < _usRefCount; ndx++)
            {
                str.Append("\n " + ndx + ":" + _refs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataReference
    /// </summary>
    /// <param name="Lb">Leaderboard id</param>
    /// <param name="User">User PUID</param>
    /// <remarks>
    /// Attachment part of RepSetDataCanUploadAtt
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataReference
    {
        public uint     _uiLb;      // Leaderboard Id
        public ulong    _ulUser;    // User PUID

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return string.Format("_uiLb={0} _ulUser=0x{1}", _uiLb, _ulUser);
        }
    }

    /// <summary>
    /// ReqGetData
    /// </summary>
    /// <param name="Messages">Request messages</param>
    /// <returns>RepGetData response</returns>
    /// <remarks>
    /// Reads data from leaderboard server as described in the request messages
    /// </remarks>
    public class ReqGetData
    {
        public MsgGetData[]    _messages;

        public void ReadFrom(BinaryReader reader)
        {
            ArrayList messages = new ArrayList((int)ProtocolConstant.MaxSpecsPerRequest);

            try
            {
                while(true)
                {
                    MsgGetData newMsg = new MsgGetData();
                    newMsg.ReadFrom(reader);

                    if(messages.Count == ProtocolConstant.MaxSpecsPerRequest)
                        throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_1,
                            "Too many specs in request");
                        // BUGBUG: hr=HResult.XONLINE_E_STAT_TOO_MANY_SPECS
                        
                    messages.Add(newMsg);
                }
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            if(messages.Count == 0)
                throw new Exception("Request cannot be empty.");

            _messages = (MsgGetData[]) messages.ToArray(typeof(MsgGetData));
        }

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgGetData msg in _messages)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _messages.Length; ndx++)
            {
                str.Append(_messages[ndx]);
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// MsgGetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Attribute count</param>
    /// <param name="AttrIds">Array of attribute ids (size==AttrCount)</param>
    /// <remarks>
    /// Leaderboard query message.  Specifies title, leaderboard, and attributes to retrieve.
    /// </remarks>
    public class MsgGetData
    {
        public uint     _uiTitleId;     // Title Id
        public ulong    _ulUserId;      // User PUID
        public uint     _uiLbId;        // Leaderboard Id
        public uint     _uiAttrCount;   // Attribute Count
        public ushort[] _attrIds;       // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            try
            {
                _uiTitleId      = reader.ReadUInt32();
            }
            catch (EndOfStreamException)
            {
                //only the first element following a previous peekchar
                throw new PeekCharEndOfStreamException();
            }
            
            _ulUserId       = reader.ReadUInt64();
            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount is zero.");

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_2,
                    "_uiAttrCount (" +_uiAttrCount+" > " + ProtocolConstant.MaxAttrPerSpec);

            _attrIds = new ushort[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attrIds.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepGetData
    public class RepGetData
    {
        public MsgRepGetData[] _reps = null;

        public void ReadFrom(BinaryReader reader, ReqGetData req)
        {
            ArrayList messages = new ArrayList((int)ProtocolConstant.MaxSpecsPerRequest);

            int iMsg=0;
            try
            {
                while(true)
                {
                    MsgRepGetData newMsg = new MsgRepGetData();
                    newMsg._attribs = new MsgAttribData[req._messages[iMsg]._uiAttrCount];
                    newMsg.ReadFrom(reader);
                    messages.Add(newMsg);
                }
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            _reps = (MsgRepGetData[]) messages.ToArray(typeof(MsgRepGetData));
        }

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgRepGetData msg in _reps)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _reps.Length; ndx++)
            {
                str.Append(_reps[ndx]);
            }

            return str.ToString();
        }
    }

    // MsgRepGetData
    // GetData reply
    public class MsgRepGetData
    {
        public ulong            _ulUserId;  // User PUID
        public uint             _uiLbId;    // Leaderboard Id
        public MsgAttribData[]  _attribs;   // Attributes

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            foreach(MsgAttribData attribData in _attribs)
            {
                attribData.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _ulUserId   = reader.ReadUInt64();
            _uiLbId     = reader.ReadUInt32();

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgEnumLB
    // Message Enumerate Leaderboard
    public class MsgEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size
        public uint     _uiAttrCount;           // Size of _attrIds
        public ushort[] _attrIds;               // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_3,
                    "Invalid MsgEnumLb. _uiAttrCount("+_uiAttrCount+") > ProtocolConstant.MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerSpec+")");
            }

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, //XEvent.Id.COMMON_HACK_33,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }

            _attrIds        = new ushort[_uiAttrCount];
            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
            writer.Write(_uiAttrCount);

            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepEnumLB
    // Reply to Enumerate Leaderboard
    public class RepEnumLB
    {
        public uint             _uiLbSize;
        public uint             _uiRepUserCount;
        public uint             _uiAttrPerUser;
        public RepEnumLBUser[]  _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _uiRepUserCount     = reader.ReadUInt32();
            _uiAttrPerUser      = reader.ReadUInt32();

            _users              = new RepEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepEnumLBUser((int)_uiAttrPerUser);
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_uiRepUserCount);
            writer.Write(_uiAttrPerUser);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbSize=" + _uiLbSize+
                "\n_uiRepUserCount=" + _uiRepUserCount+
                "\n_uiAttrPerUser=" + _uiAttrPerUser +
                "\n_users:\n");

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.Append("\n "+ndx+":" + _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepEnumLBUser
    {
        public RepEnumLBUser(int iAttrCount)
        {
            _attribs = new MsgAttribData[iAttrCount];
        }

        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bSizeXName;
        public byte             _bSizeNickname;
        public string           _xName;
        public string           _nickname;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bSizeXName         = reader.ReadByte();
            _bSizeNickname      = reader.ReadByte();

            byte [] arrByte     = reader.ReadBytes(_bSizeXName);
            if (arrByte.Length != (int)_bSizeXName)
                throw new Exception("Error - RepEnumLBUser:: Bytes Read is not equal _bSizeXName");

            _xName              = Encoding.UTF8.GetString(arrByte);
            _nickname           = Encoding.Unicode.GetString(reader.ReadBytes(_bSizeNickname));

            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encXName = Encoding.UTF8.GetBytes(_xName);
            _bSizeXName     = (byte) encXName.Length;

            byte[] encNick  = Encoding.Unicode.GetBytes(_nickname);
            _bSizeNickname  = (byte) encNick.Length;

            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bSizeXName);
            writer.Write(_bSizeNickname);
            writer.Write(encXName);
            writer.Write(encNick);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUser=0x" + _ulUser.ToString("x") +
                "\n_uiRank=" + _uiRank +
                "\n_lRating=" + _lRating +
                "\n_bSizeXName=" + _bSizeXName +
                "\n_bSizeNickname=" + _bSizeNickname +
                "\n_xName=" + _xName +
                "\n_nickname=" + _nickname +
                "\n_attribs=");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgAttribData
    // Attribute with data. Used in several messages.
    public class MsgAttribData
    {
        public ushort   _usAttrId;
        public byte     _bAttrType;
        public object   _value;

        public void ReadFrom(BinaryReader reader)
        {
            _usAttrId   = reader.ReadUInt16();
            _bAttrType  = reader.ReadByte();

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    _value = (object) reader.ReadInt32();
                    break;
                case AttrType.LongLong:
                    _value = (object) reader.ReadInt64();
                    break;
                case AttrType.Double:
                    _value = (object) reader.ReadDouble();
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte bNickSize = reader.ReadByte();
                        _value = (object) Encoding.Unicode.GetString(reader.ReadBytes(bNickSize));
                    }
                    else
                    {
                        ushort usSize = reader.ReadUInt16();
                        _value = (object) Encoding.UTF8.GetString(reader.ReadBytes(usSize));
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_usAttrId);
            writer.Write(_bAttrType);

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    writer.Write((int)_value);
                    break;
                case AttrType.LongLong:
                    writer.Write((long)_value);
                    break;
                case AttrType.Double:
                    writer.Write((double)_value);
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte[] nickbin = Encoding.Unicode.GetBytes((string)_value);
                        writer.Write((byte)nickbin.Length);
                        writer.Write(nickbin);
                    }
                    else
                    {
                        byte[] stringbin = Encoding.UTF8.GetBytes((string)_value);
                        writer.Write((ushort)stringbin.Length);
                        writer.Write(stringbin);
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public override string ToString()
        {
            return string.Format("_usAttrId={0} _bAttrType={1} _value={2}",
                _usAttrId, _bAttrType, (_value != null ? _value : "(null)"));
        }
    }

    // MsgReset
    // Reset message
    public class MsgReset
    {
        public uint titleId;
        public ulong userId;
        public uint leaderBoardType;
        public TeamTickets _teamTickets = null;

        public void ReadFrom(BinaryReader reader)
        {
            titleId         = reader.ReadUInt32();
            userId          = reader.ReadUInt64();
            leaderBoardType = reader.ReadUInt32();

            try
            {
                _teamTickets = new TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(titleId);
            writer.Write(userId);
            writer.Write(leaderBoardType);

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            return
                "\ntitleId=0x"+titleId.ToString("x")+
                "\nuserId=0x"+userId.ToString("x")+
                "\nleaderBoardType="+leaderBoardType+
                "\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)");
        }

        public string GetXRL()
        {
            return "/xstats/xstatsreset.ashx";
        }
    }

    // MsgCommitAttachment
    // CommitAttachment message.
    public class MsgCommitAttachment
    {
        public uint     _uiTitleId;
        public uint     _uiAttSize;
        public uint     _uiAttSizeUncomp;
        public ushort   _usSizePathName;
        public ushort   _usRefCount;
        public string   _pathName;
        public MsgCommitAttachmentReference[] _refs;

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encPathName  = Encoding.UTF8.GetBytes(_pathName);
            _usSizePathName     = (ushort) encPathName.Length;
            _usRefCount         = (ushort) _refs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_uiAttSize);
            writer.Write(_uiAttSizeUncomp);
            writer.Write(_usSizePathName);
            writer.Write(_usRefCount);
            writer.Write(encPathName);

            foreach(MsgCommitAttachmentReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiAttSize      = reader.ReadUInt32();
            _uiAttSizeUncomp= reader.ReadUInt32();
            _usSizePathName = reader.ReadUInt16();
            _usRefCount     = reader.ReadUInt16();

            if(_usRefCount > ProtocolConstant.MaxSpecsPerSetDataRequest)
                throw new Exception("_usRefCount("+_usRefCount+")>ProtocolConstant.MaxSpecsPerSetDataRequest("+ProtocolConstant.MaxSpecsPerSetDataRequest+")");

            _pathName       = Encoding.UTF8.GetString(reader.ReadBytes(_usSizePathName));
            _refs           = new MsgCommitAttachmentReference[_usRefCount];

            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new MsgCommitAttachmentReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            return
                " _uiTitleId:0x"+_uiTitleId.ToString("x")+
                " _uiAttSize:"+_uiAttSize+
                " _uiAttSizeUncomp:"+_uiAttSizeUncomp+
                " _usSizePathName:"+_usSizePathName+
                " _usRefCount:"+_usRefCount+
                " _pathName:"+_pathName+
                " _refs:"+MsgCommitAttachmentReference.ToString(_refs);
        }
    }

    // MsgCommitAttachmentReference
    // Attachment reference part of MsgCommitAttachment
    public class MsgCommitAttachmentReference
    {
        public uint     _uiLb;
        public ulong    _ulUser;

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return
                " _uiLb:"+_uiLb+
                " _ulUser:"+_ulUser;
        }

        public static string ToString(IList msgs)
        {
            StringBuilder str = new StringBuilder();
            foreach(MsgCommitAttachmentReference msg in msgs)
            {
                str.Append(msg.ToString());
            }
            return str.ToString();
        }
    }

    // MsgWebEnumLB
    // Message Web Enumerate Leaderboard
    public class MsgWebEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, //XEvent.Id.COMMON_HACK_34,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }


        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize;
        }
    }

    // RepWebEnumLB
    // Reply to Web Enumerate Leaderboard
    public class RepWebEnumLB
    {
        public uint                 _uiLbSize;
        public ulong                _ulLastResetTime;
        public uint                 _uiRepUserCount;
        public RepWebEnumLBUser[]   _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _ulLastResetTime    = reader.ReadUInt64();
            _uiRepUserCount     = reader.ReadUInt32();

            _users              = new RepWebEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepWebEnumLBUser();
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_ulLastResetTime);
            writer.Write(_uiRepUserCount);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_uiLbSize={0}"+
                "\n_ulLastResetTime={1}"+
                "\n_uiRepUserCount={2}" +
                "\n_users:\n",
                _uiLbSize,
                _ulLastResetTime,
                _uiRepUserCount);

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.AppendFormat("\n {0}:{1}", ndx.ToString(), _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepWebEnumLBUser
    {
        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bAttribCount;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bAttribCount       = reader.ReadByte();

            _attribs = new MsgAttribData[_bAttribCount];
            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bAttribCount);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_ulUser=0x{0}" +
                "\n_uiRank={1}" +
                "\n_lRating={2}" +
                "\n_attribs=",
                _ulUser.ToString("x"),
                _uiRank.ToString(),
                _lRating.ToString());

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // ReqRemoveAtt
    // Remove Attachment request
    public class MsgRemoveAtt
    {
        public ushort       _usSizeAttachPathName = 0;
        public string       _attachPathName       = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usSizeAttachPathName = reader.ReadUInt16();
            _attachPathName = Encoding.UTF8.GetString(reader.ReadBytes(_usSizeAttachPathName));
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encAttachPathName = Encoding.UTF8.GetBytes(_attachPathName);
            _usSizeAttachPathName = (ushort) encAttachPathName.Length;

            writer.Write(_usSizeAttachPathName);
            writer.Write(encAttachPathName);
        }

        public override string ToString()
        {
            return
                "\n_usSizeAttachPathName=" + _usSizeAttachPathName +
                "\n_attachPathName=" + _attachPathName != null ? _attachPathName : "(null)";
        }
    }

    // RepRemoveAtt
    public class RepRemoveAtt
    {
        public ushort   _usPuidCount    = 0;
        public ulong[]  _puids          = null;

        public void ReadFrom(BinaryReader br)
        {
            _usPuidCount = br.ReadUInt16();
            _puids = new ulong[_usPuidCount];

            for(int i=0; i < _puids.Length; i++)
            {
                _puids[i] = br.ReadUInt64();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usPuidCount = (ushort) _puids.Length;

            bw.Write(_usPuidCount);

            for(int i=0; i < _puids.Length; i++)
            {
                bw.Write(_puids[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usPuidCount=" + _usPuidCount +
                "\n_puids=");

            if(_puids != null)
            {
                for(int i=0; i < _puids.Length; i++)
                {
                    str.Append(" 0x"+_puids[i].ToString("x"));
                }
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// ReqStatPost
    /// </summary>
    /// <param name="TitleID">Title ID</param>
    /// <param name="ProcCount">Count of procedures</param>
    /// <param name="Procs">Procedure calls</param>
    /// <param name="TeamTickets">Team Tickets objects</param>
    /// <remarks>
    /// Supports running leaderboard operator procedures as defined in StatPostProcedure
    /// </remarks>
    public class ReqStatPost
    {
        public uint         _uiTitleId   = 0;
        public ushort       _usProcCount = 0;
        public MsgStatPostProcedureCall[] _procs = null;
        public TeamTickets _teamTickets = null;

        public string GetXRL()
        {
            return "/xstats/statpost.ashx";
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _usProcCount    = reader.ReadUInt16();

            if(_usProcCount > ProtocolConstant.MaxProcedureCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, //XEvent.Id.XSTATSFD_INVALID_REQUEST_4,
                    "Too many procedures (" + _usProcCount + ")");
            }

            _procs = new MsgStatPostProcedureCall[_usProcCount];
            for(ushort i=0; i < _procs.Length; i++)
            {
                _procs[i] = new MsgStatPostProcedureCall();
                _procs[i].ReadFrom(reader);
            }

            try
            {
                _teamTickets = new TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

//             Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_LOW, ToString());

        }

        public void WriteTo(BinaryWriter writer)
        {
            _usProcCount = (ushort) _procs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_usProcCount);

            for(ushort i=0; i < _usProcCount; i++)
            {
                _procs[i].WriteTo(writer);
            }

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId="+_uiTitleId+
                "\n_usProcCount="+_usProcCount+
                "\n_procs: ");

            if(_procs != null)
            {
                for(ushort i=0; i < _procs.Length; i++)
                {
                    str.Append(_procs[i].ToString());
                }
            }

            str.Append("\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }


    // MsgStatPostProcedureCall
    public class MsgStatPostProcedureCall
    {
        public ushort       _usProcId = 0;
        public ushort       _usParamCount = 0;
        public MsgStatPostParameter[] _params = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usProcId = reader.ReadUInt16();
            _usParamCount = reader.ReadUInt16();

            if(_usParamCount > ProtocolConstant.MaxStatPostParamCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PARAMETERS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_5,
                    "Procedure id: "+_usProcId+" has too many parameters ("+ _usParamCount +")");
            }

            _params = new MsgStatPostParameter[_usParamCount];

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i] = new MsgStatPostParameter();
                _params[i].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _usParamCount = (ushort) _params.Length;

            writer.Write(_usProcId);
            writer.Write(_usParamCount);

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usProcId="+_usProcId+
                "\n_usParamCount="+_usParamCount+
                "\n_params: ");

            if(_params != null)
            {
                for(ushort i=0; i < _params.Length; i++)
                {
                    // BUGBUG: add extra check on _param[i] != null. Repeat this on the rest of the file.
                    str.Append(_params[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgStatPostParameter
    public class MsgStatPostParameter
    {
        public byte         _bParamType = 0;
        public object       _data = null;

        public void ReadFrom(BinaryReader reader)
        {
            _bParamType = reader.ReadByte();

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    reader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) reader.ReadByte(); // BUGBUG: sign?
                    break;
                case StatParam.Int16:
                    _data = (object) reader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) reader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) reader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) reader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = reader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(reader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) reader.ReadUInt64();
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_bParamType);

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    writer.Write((byte)0);
                    break;
                case StatParam.Int8:
                    writer.Write((byte)_data);
                    break;
                case StatParam.Int16:
                    writer.Write((short)_data);
                    break;
                case StatParam.Int32:
                    writer.Write((int)_data);
                    break;
                case StatParam.Int64:
                    writer.Write((long)_data);
                    break;
                case StatParam.Float:
                    writer.Write((double)_data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string)_data);
                    writer.Write((ushort) encstring.Length);
                    writer.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    writer.Write((ulong)_data);
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public override string ToString()
        {
            return "("+_bParamType+")"+
                (_data == null ? "(null)" : _data.ToString()) + " ";
        }
    }

    // ReqStatUnitGet
    public class ReqStatUnitGet // BUGBUG: name doesn't match with reply's. words inverted.
    {
        public uint     _uiTitleId  = 0;
        public ulong    _ulPuid1    = 0;
        public ulong    _ulPuid2    = 0;
        public ulong    _ulPuid3    = 0;
        public ulong    _ulPuid4    = 0;
        public ushort   _usSpecCount= 0;
        public MsgUnitStatGetSpec[] _specs = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _ulPuid1    = br.ReadUInt64();
            _ulPuid2    = br.ReadUInt64();
            _ulPuid3    = br.ReadUInt64();
            _ulPuid4    = br.ReadUInt64();
            _usSpecCount= br.ReadUInt16();

            if(_usSpecCount > ProtocolConstant.MaxStatUnitGetSpecs)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_6,
                    "_usSpecCount("+_usSpecCount+" > MaxStatUnitGetSpecs("+ProtocolConstant.MaxStatUnitGetSpecs+")");

            _specs = new MsgUnitStatGetSpec[_usSpecCount];
            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpec();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;

            bw.Write(_uiTitleId);
            bw.Write(_ulPuid1);
            bw.Write(_ulPuid2);
            bw.Write(_ulPuid3);
            bw.Write(_ulPuid4);
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+ _uiTitleId.ToString("x")+
                "\n_ulPuid1=0x" +  _ulPuid1.ToString("x")+
                "\n_ulPuid2=0x" +  _ulPuid2.ToString("x")+
                "\n_ulPuid3=0x" +  _ulPuid3.ToString("x")+
                "\n_ulPuid4=0x" +  _ulPuid4.ToString("x")+
                "\n_usSpecCount="+ _usSpecCount +
                "\n_specs:");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpec
    public class MsgUnitStatGetSpec
    {
        public uint         _uiLbId     = 0;
        public ushort       _usNumStats = 0;
        public ushort[]     _statIds    = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId     = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();

            if(_usNumStats > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_7,
                    "_usNumStats("+_usNumStats+" > MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerUnitSpec+")");

            _statIds = new ushort[_usNumStats];

            for(ushort i=0; i < _usNumStats; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _statIds.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "_uiLbId = " + _uiLbId +
                "_usNumStats = " + _usNumStats +
                "_statIds: ");

            if(_statIds != null)
            {
                for(int i=0; i < _statIds.Length; i++)
                {
                    str.Append(" "+i);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitStatGet
    public class RepUnitStatGet
    {
        public ushort                   _usSpecCount = 0;
        public MsgUnitStatGetSpecData[] _specs       = null;

        public void ReadFrom(BinaryReader br)
        {
            _usSpecCount = br.ReadUInt16();
            _specs = new MsgUnitStatGetSpecData[_usSpecCount];

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpecData();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usSpecCount="+_usSpecCount+
                "\n_specs: ");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpecData
    public class MsgUnitStatGetSpecData
    {
        public uint             _uiLbId;
        public ushort           _usNumStats;
        public MsgAttribData[]  _stats;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();
            _stats = new MsgAttribData[_usNumStats];
            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _stats.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbId="+_uiLbId+
                "\n_usNumStats="+_usNumStats+
                "\n_stats:");

            if(_stats != null)
            {
                for(int i=0; i < _stats.Length; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // ReqUnitEnum
    public class ReqUnitEnum
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public uint     _uiFlags        = 0;
        public ulong    _ulPuid         = 0;
        public ushort   _usPageSize     = 0;
        public ushort   _usStatCount    = 0;
        public ushort[] _statIds        = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
            _uiFlags        = br.ReadUInt32();

            if( (_uiFlags & UnitEnumFlags.SortActivity) != 0
                && (_uiFlags & UnitEnumFlags.SortRating) != 0 )
                throw new Exception("Invalid flags. SortActivity and SortRating flags are mutually exclusive.");

            if((_uiFlags & ~(UnitEnumFlags.SortActivity |
                           UnitEnumFlags.SortRating)) != 0)
            {
                throw new Exception("Invalid flags.");
            }

            _ulPuid         = br.ReadUInt64();
            _usPageSize     = br.ReadUInt16();

            if(_usPageSize == 0)
                throw new Exception("Error: _usPageSize is zero");

            _usStatCount    = br.ReadUInt16();

            if(_usStatCount > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, //XEvent.Id.XSTATSFD_INVALID_REQUEST_8,
                    "_usStatCount (" + _usStatCount + ") > MaxAttrPerSpec ("+
                    ProtocolConstant.MaxAttrPerUnitSpec + ")");

            _statIds        = new ushort[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usStatCount = (ushort) _statIds.Length;

            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_uiFlags);
            bw.Write(_ulPuid);
            bw.Write(_usPageSize);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+  _uiTitleId.ToString("x")+
                "\n_uiLbId="+       _uiLbId+
                "\n_uiFlags="+      _uiFlags+
                "\n_ulPuid=0x"+     _ulPuid.ToString("x")+
                "\n_usPageSize="+   _usPageSize+
                "\n_usStatCount="+  _usStatCount+
                "\n_statIds: ");

            if(_statIds != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    str.Append(" "+_statIds[i]);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitEnum
    public class RepUnitEnum
    {
        public ushort               _usNumEntries   = 0;
        public MsgUnitEnumEntry[]   _entries        = null;

        public void ReadFrom(BinaryReader br)
        {
            _usNumEntries = br.ReadUInt16();
            _entries = new MsgUnitEnumEntry[_usNumEntries];

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i] = new MsgUnitEnumEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumEntries = (ushort) _entries.Length;
            bw.Write(_usNumEntries);

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usNumEntries=" + _usNumEntries +
                "\n_entries: ");

            if(_entries != null)
            {
                for(ushort i=0; i < _entries.Length; i++)
                {
                    str.Append(_entries[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitEnumEntry
    public class MsgUnitEnumEntry
    {
        public ulong            _puid1          = 0;
        public ulong            _puid2          = 0;
        public ulong            _puid3          = 0;
        public ulong            _puid4          = 0;
        public ushort           _usSizeName1    = 0;
        public string           _name1          = String.Empty;
        public ushort           _usSizeName2    = 0;
        public string           _name2          = String.Empty;
        public ushort           _usSizeName3    = 0;
        public string           _name3          = String.Empty;
        public ushort           _usSizeName4    = 0;
        public string           _name4          = String.Empty;
        public ushort           _usStatCount    = 0;
        public MsgAttribData[]  _stats          = null;

        public void ReadFrom(BinaryReader br)
        {
            _puid1        = br.ReadUInt64();
            _puid2        = br.ReadUInt64();
            _puid3        = br.ReadUInt64();
            _puid4        = br.ReadUInt64();
            _usSizeName1  = br.ReadUInt16();
            _name1        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName1));
            _usSizeName2  = br.ReadUInt16();
            _name2        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName2));
            _usSizeName3  = br.ReadUInt16();
            _name3        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName3));
            _usSizeName4  = br.ReadUInt16();
            _name4        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName4));
            _usStatCount  = br.ReadUInt16();
            _stats        = new MsgAttribData[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] encName1 = Encoding.UTF8.GetBytes(_name1);
            _usSizeName1 = (ushort) encName1.Length;
            byte[] encName2 = Encoding.UTF8.GetBytes(_name2);
            _usSizeName2 = (ushort) encName2.Length;
            byte[] encName3 = Encoding.UTF8.GetBytes(_name3);
            _usSizeName3 = (ushort) encName3.Length;
            byte[] encName4 = Encoding.UTF8.GetBytes(_name4);
            _usSizeName4 = (ushort) encName4.Length;

            bw.Write(_puid1);
            bw.Write(_puid2);
            bw.Write(_puid3);
            bw.Write(_puid4);
            bw.Write(_usSizeName1);
            bw.Write(encName1);
            bw.Write(_usSizeName2);
            bw.Write(encName2);
            bw.Write(_usSizeName3);
            bw.Write(encName3);
            bw.Write(_usSizeName4);
            bw.Write(encName4);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_puid1=0x"+      _puid1.ToString("x")+
                "\n_puid2=0x"+      _puid2.ToString("x")+
                "\n_puid3=0x"+      _puid3.ToString("x")+
                "\n_puid4=0x"+      _puid4.ToString("x")+
                "\n_usSizeName1="+  _usSizeName1+
                "\n_name1="+        _name1+
                "\n_usSizeName2="+  _usSizeName2+
                "\n_name2="+        _name2+
                "\n_usSizeName3="+  _usSizeName3+
                "\n_name3="+        _name3+
                "\n_usSizeName4="+  _usSizeName4+
                "\n_name4="+        _name4+
                "\n_usStatCount="+  _usStatCount+
                "\n_stats: ");

            if(_stats != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    public class ReqCompCreateLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiTemplateId   = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiTemplateId   = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiTemplateId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiTemplateId: "+ _uiTemplateId;
        }
    }

    public class RepCompCreateLb
    {
        public uint     _uiLbId     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiLbId: 0x" + _uiLbId.ToString("x");
        }
    }

    public class ReqCompDeleteLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: "+ _uiLbId;
        }
    }

    public class ReqFindRating
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public long     _lRating        = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _uiLbId     = br.ReadUInt32();
            _lRating    = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: " + _uiLbId+
                "\n_lRating: " + _lRating;
        }
    }

    public class RepFindRating
    {
        public ulong    _ulPuid     = 0;
        public uint     _uiRank     = 0;
        public long     _lRating    = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
            _uiRank = br.ReadUInt32();
            _lRating = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
            bw.Write(_uiRank);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x")+
                "\n_uiRank: "+_uiRank+
                "\n_lRating: "+_lRating;
        }
    }

    public class ReqCertReset
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class ReqCertVerify
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class RepCertVerify
    {
        public ushort               _usEntryCount = 0;
        public MsgCertVerifyEntry[] _entries = null;

        public void ReadFrom(BinaryReader br)
        {
            _usEntryCount = br.ReadUInt16();
            _entries = new MsgCertVerifyEntry[_usEntryCount];
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i] = new MsgCertVerifyEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usEntryCount = (ushort) _entries.Length;
            bw.Write(_usEntryCount);
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usEntryCount:"+_usEntryCount+
                "\n_entries:");

            for(int i=0; i < _entries.Length; i++)
            {
                str.Append((_entries[i] != null ? _entries[i].ToString() : "(null)"));
            }

            return str.ToString();
        }
    }

    public class MsgCertVerifyEntry
    {
        public byte     _bLevel;
        public ushort   _usSizeDescription = 0;
        public string   _description;

        public void ReadFrom(BinaryReader br)
        {
            _bLevel = br.ReadByte();
            _usSizeDescription  = br.ReadUInt16();
            _description = Encoding.UTF8.GetString(br.ReadBytes((int)_usSizeDescription));
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] binDescription = Encoding.UTF8.GetBytes(_description);
            _usSizeDescription = (ushort) binDescription.Length;

            bw.Write(_bLevel);
            bw.Write(_usSizeDescription);
            bw.Write(binDescription);
        }
    }
    #endregion

    #region Stats/Leaderboard V2 (Xenon) Protocol

    /// <summary>
    /// StatsColumn
    /// </summary>
    /// <param name="ColumnId">Stats column id (usually ordinal)</param>
    /// <param name="Type">Stats column datatype</param>
    /// <param name="Data">Stat data value</param>
    /// <remarks>
    /// Data object for holding the contents of a stat column.
    /// </remarks>
    public class StatsColumn : WireData
    {
        public ushort ColumnId;
        public byte Type = 0;
        protected object _data = null;

        public StatsColumn()
        {
        }

        public StatsColumn(ushort ColumnId, byte Type, object Data)
        {
            this.ColumnId = ColumnId;
            this.Type     = Type;
            this._data    = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            ColumnId = binaryReader.ReadUInt16();
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           //XEvent.Id.COMMON_CODE_53,
                                           "Unexpected type: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(ColumnId);
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           //XEvent.Id.COMMON_CODE_54,
                                           "Unexpected type: " + Type.ToString());
            }
        }
    }

    /// <summary>
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="Rating">User rating</param>
    /// <param name="GamerTagLength">Length of gamer tag string</param>
    /// <param name="GamerTag">Gamer tag string</param>
    /// <param name="ColumnCount">Count of columns</param>
    /// <param name="Columns">Stats columns collection</param>
    /// <remarks>
    /// Data object for a stats result row
    /// </remarks>
    public class StatsRow : WireData
    {
        public ulong Puid   = 0;
        public uint  Rank   = 0;
        public ulong Rating = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAM_DATA)]
        public uint GamerTagLength = 0;

        [WireInfo(SizeParam="GamerTagLength")]
        public string GamerTag = null;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public StatsColumn[] Columns = null;

        public StatsRow()
        {
        }

        /// <summary>
        /// StatsRow constructor
        /// </summary>
        /// <param name="puid">User ID for row</param>
        /// <param name="rank">Rank of row</param>
        /// <param name="rating">Rating of row</param>
        /// <param name="gamerTag">GamerTag for row</param>
        /// <param name="columns">Count of columns of data in row</param>
        /// <remarks>
        /// Constructor that sets values for row and allocates an array for column data
        /// </remarks>
        public StatsRow(ulong puid, uint rank, ulong rating, string gamerTag, uint columns)
        {
            Puid        = puid;
            Rank        = rank;
            Rating      = rating;
            GamerTag    = gamerTag;
            ColumnCount = columns;
            Columns     = new StatsColumn[columns];
        }
    }

    /// <summary>
    /// StatsResultSet
    /// </summary>
    /// <param name="ViewId">View id (leaderboard ID)</param>
    /// <param name="RowCount">Stat row count</param>
    /// <param name="Rows">Stat rows collection</param>
    /// <remarks>
    /// Data object for result set of stat query
    /// </remarks
    public class StatsResultSet : WireData
    {
        public ulong ViewId;
        public uint ViewSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ROW_COUNT)]
        public uint RowCount = 0;

        [WireInfo(SizeParam="RowCount")]
        public StatsRow[] Rows = null;
    }

    /// <summary>
    /// StatsSpec
    /// </summary>
    /// <param name="ViewId">View id (leaderboard id)</param>
    /// <param name="ColumnCount">Count of column id's</param>
    /// <param name="ColumnIds">Collection of column id's to query</param>
    /// <remarks>
    /// Data object representing a stats query
    /// </remarks>
    public class StatsSpec : WireData
    {
        public uint ViewId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public ushort[] ColumnIds = null;
    }

    /// <summary>
    /// StatsOperatorParameter
    /// </summary>
    /// <param name="Type">Paramter data type (StatParamType)</param>
    /// <param name="Data">Parameter data</param>
    /// <remarks>
    /// Data object for a stats operator parameter
    /// </remarks>
    public class StatsOperatorParameter : WireData
    {
        public byte Type = 0;
        protected object _data = null;

        public StatsOperatorParameter()
        {
        }

        public StatsOperatorParameter(byte Type, object Data)
        {
            this.Type  = Type;
            this._data = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    binaryReader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           //XEvent.Id.COMMON_CODE_55,
                                           "Unexpected _datatype: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           //XEvent.Id.COMMON_CODE_56,
                                           "Unexpected _datatype: " + Type.ToString());
            }
        }

        public override string ToString(int indent)
        {
            StringBuilder bldr = new StringBuilder();

            bldr.Append("\n" + "".PadLeft(indent));
            bldr.Append("Type=" + Type + "\n");
            bldr.Append("".PadLeft(indent));
            bldr.Append("_data=");

            switch(Type)
            {
                case StatParam.Null:
                    bldr.Append("NULL");
                    break;
                case StatParam.Int8:
                    bldr.Append((Byte) _data);
                    break;
                case StatParam.Int16:
                    bldr.Append((Int16) _data);
                    break;
                case StatParam.Int32:
                    bldr.Append((Int32) _data);
                    break;
                case StatParam.Int64:
                    bldr.Append((Int64) _data);
                    break;
                case StatParam.Float:
                    bldr.Append((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    bldr.Append((UInt16) encstring.Length);
                    bldr.Append(encstring);
                    break;
                }
                case StatParam.Puid:
                    bldr.Append((UInt64) _data);
                    break;
                default:
                    bldr.Append("UNKNOWN!");
                    break;
            }

            return bldr.ToString();
        }
    }

    /// <summary>
    /// StatsOperator
    /// </summary>
    /// <param name="OperatorId">Operator type</param>
    /// <param name="ParameterCount">Count of operator parameters</param>
    /// <param name="Parameters">Collection of parameters</param>
    /// <remarks>
    /// Data object for a stats operator
    /// </remarks>
    public class StatsOperator : WireData
    {
        public ushort OperatorId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAMS)]
        public ushort ParameterCount = 0;

        [WireInfo(SizeParam="ParameterCount")]
        public StatsOperatorParameter[] Parameters = null;

        public StatsOperator()
        {
        }

        public StatsOperator(BinaryReader binaryReader)
        {
            base.ReadStream(binaryReader);
        }
    }

    /// <summary>
    /// StatsPostRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="OperatorCount">Count of operators</param>
    /// <param name="Operators">Collection of operators</param>
    /// <param name="TeamTickets">Collection of team tickets (optional)</param>
    /// <returns>StatsPostResponse</returns>
    /// <remarks>
    /// Batch of stat operator requests that generates StatsPostResponse.
    /// Operators dictate the functionality.
    /// Typical operators include REPLACE, ADD, MIN, MAX
    /// </remarks>
    public class StatsPostRequest : XRLObject2
    {
        public uint TitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_COUNT)]
        public ushort OperatorCount = 0;

        [WireInfo(SizeParam="OperatorCount")]
        public StatsOperator[] Operators = null;

        public TeamTickets TeamTickets = null;

        public string GetXRL()
        {
            return "/xstats/xstatpostxe.ashx";
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            TitleId       = binaryReader.ReadUInt32();
            OperatorCount = binaryReader.ReadUInt16();

            if (OperatorCount > XOn.XONLINE_MAX_STATS_OP_COUNT)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, //XEvent.Id.COMMON_HACK_40,
                    "Operators exceed max allowed (" + OperatorCount + ")");
            }
            ArrayList operators = new ArrayList();
            for (ushort i = 0; i < OperatorCount; i++)
            {
                operators.Add(new StatsOperator(binaryReader));
            }
            Operators = new StatsOperator[OperatorCount];
            operators.CopyTo(Operators);

            // Check to see if there are any team tickets
            try
            {
                TeamTickets = new TeamTickets(binaryReader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(TitleId);

            if (OperatorCount == 0 && Operators.Length > 0)
            {
                OperatorCount = (ushort) Operators.Length;
            }

            binaryWriter.Write(OperatorCount);

            foreach (StatsOperator op in Operators)
            {
                op.WriteStream(binaryWriter);
            }

            if (TeamTickets != null)
            {
                TeamTickets.WriteStream(binaryWriter);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\nTitleId=" + TitleId +
                "\nOperatorCount=" + OperatorCount +
                "\nOperators: ");

            if (Operators != null)
            {
                foreach (StatsOperator op in Operators)
                {
                    str.Append(op.ToString());
                }
            }

            str.Append("\nTeamTickets: " + (TeamTickets != null ? TeamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }

    /// <summary>
    /// StatsPostResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response for StatPostRequest.
    /// </remarks>
    public class StatsPostResponse : XRLObject2
    {
        public uint TitleId = 0;

        // TODO: Return array of operation return codes
    }

    /// <summary>
    /// StatsReadRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserCount">Count of users</param>
    /// <param name="Users">Collection of user id's</param>
    /// <param name="SpecCount">Count of query specs</param>
    /// <param name="Specs">Collection of query specs</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Query for users and specific view columns.
    /// Results are generated with one result set per query spec with
    /// each user having a record in the result set.
    /// </remarks>
    public class StatsReadRequest : XRLObject2
    {
        public uint TitleId;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_USER_COUNT)]
        public uint UserCount;

        [WireInfo(SizeParam="UserCount")]
        public ulong[] Users = null;

        // TODO: make the spec count NPDB configurable
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint SpecCount;

        [WireInfo(SizeParam="SpecCount")]
        public StatsSpec[] Specs = null;

        public string GetXRL()
        {
            return "/xstats/xstatread.ashx";
        }
    }

    /// <summary>
    /// StatsEnumByUserRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User id for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified user id and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByUserRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong UserId   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public string GetXRL()
        {
            return "/xstats/xstatenumbyuser.ashx";
        }
    }

    /// <summary>
    /// StatsEnumByRankRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rank">Rank value for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rank and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRankRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rank     = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public string GetXRL()
        {
            return "/xstats/xstatenumbyrank.ashx";
        }
    }

    /// <summary>
    /// StatsEnumByRatingRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rating">Rating for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rating and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRatingRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rating   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public string GetXRL()
        {
            return "/xstats/xstatenumbyrating.ashx";
        }
    }

    /// <summary>
    /// StatsReadResponse
    /// </summary>
    /// <param name="ResultsCount">Count of result sets</param>
    /// <param name="Results">Collection of result sets</param>
    /// <remarks>
    /// Response to StatsReadRequest.
    /// Contains collection of result sets for the corresponding query specs.
    /// </remarks>
    public class StatsReadResponse : XRLObject2
    {
        [WireInfo (Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint ResultsCount = 0;

        [WireInfo(SizeParam="ResultsCount")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEnumResponse : XRLObject2
    {
        public ushort StatsResultSetLen = 0;
        [WireInfo(SizeParam="StatsResultSetLen")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEstimateRankRequestStruct:XRLObject2
    {
        public int   m_nLbId = 0;
        public ulong m_ulRating = 0;
    }
    
    public class StatsEstimateRankForRatingsRequest:XRLObject2
    {
        public int  m_nTitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRatingRequestCount = 0;

        [WireInfo(SizeParam="m_uRatingRequestCount")]
        public StatsEstimateRankRequestStruct[] m_arrRatingStruct = null;

        public string GetXRL()
        {
            return "/xstats/xstatestimaterankforratings.ashx";
        }
    }

    public class StatsEstimateRankForRatingsResponse:XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRankForRatingReplyCount = 0;

        [WireInfo(SizeParam="m_uRankForRatingReplyCount")]
        public uint[] m_arruiRankForRating = null;
    }

    #endregion

    #region Achievements Protocol (Xenon)

    /// <summary>
    /// Achievement
    /// </summary>
    /// <param name="AchievementId">Achievement ID</param>
    /// <param name="Achieved">Achieved datetime</param>
    /// <param name="Flags">Flags</param>
    /// <remarks>
    /// Data object for an achievement
    /// </remarks>
    public class Achievement : WireData
    {
        public uint  AchievementId = 0;
        public DateTime Achieved   = XOn.MinDateTime;
        public uint  Sequence      = 0;
        public int   Flags         = 0;
        public byte  Type          = 0;
        public int   Cred          = 0;

        public uint  ImageId       = 0;

        public byte TitleLen       = 0;
        public string Title        = "";

        public byte DescriptionLen = 0;
        public string Description  = "";

        public byte HowToLen       = 0;
        public string HowTo        = "";

        public byte NextIdsLen     = 0;
        public uint[] NextIds      = null;

        public byte ReplaceIdsLen  = 0;
        public uint[] ReplaceIds      = null;


        public Achievement()
        {
        }

        /// <summary>
        /// Achievement
        /// </summary>
        /// <param name="achievementId">Achievement ID</param>
        /// <param name="achieved">Achieved datetime</param>
        /// <param name="flags">Flags</param>
        /// <remarks>
        /// Achievement constructor
        /// </remarks>
        public Achievement(uint achievementId, DateTime achieved, int flags)
        {
            this.AchievementId = achievementId;
            this.Achieved      = achieved;
            this.Flags         = flags;
        }

        public const int XACHIEVEMENT_DETAILS_PLATFORM_MASK  = 0x00700000;
        public const int XACHIEVEMENT_DETAILS_PLATFORM_SHIFT = 20;

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            int newFlags = existingFlags & ~XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            newFlags |= (platformType << XACHIEVEMENT_DETAILS_PLATFORM_SHIFT) & XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            return(newFlags);
        }
    }

    /// <summary>
    /// AchievementWriteRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievements</param>
    /// <returns>AchievementWriteResponse</returns>
    /// <remarks>
    /// Request to write a set of achievements to the database for a specific user + title.
    /// </remarks>
    public class SyncAchievementsRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong UserId  = 0;
        public DateTime Version = XOn.MinDateTime;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;

        public string GetXRL()
        {
            return "/xstats/syncachievements.ashx";
        }
    }

    /// <summary>
    /// AchievementWriteResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class SyncAchievementsResponse : XRLObject2
    {
        public DateTime Version = XOn.MinDateTime;
        public ushort TotalAchievements = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort  AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementEnumRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementEmumResponse</returns>
    /// <remarks>
    /// Request to read all achievements for a specific user
    /// </remarks>
    public class AchievementEnumRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAchievements = XOn.XONLINE_MAX_ACHIEVEMENTS;


        public string GetXRL()
        {
            return "/xstats/xachievementenum.ashx";
        }
    }

    /// <summary>
    /// AchievementEnumResponse
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementsCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievement descriptions</param>
    /// <remarks>
    /// Response to AchievementEnumRequest.
    /// </remarks>
    public class AchievementEnumResponse : XRLObject2
    {
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementClearRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementClearResponse</returns>
    /// <remarks>
    /// Request to clear all achievements for a specific user
    /// for the specified title id
    /// </remarks>
    public class AchievementClearRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;

        public string GetXRL()
        {
            return "/xstats/xachievementclear.ashx";
        }
    }

    /// <summary>
    /// AchievementClearResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <returns>Puid</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class AchievementClearResponse : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
    }

    #endregion

    public class ProfileDefs
    {
        public const uint XPROFILE_PERMISSIONS                          = 0x10040000;
        public const uint XPROFILE_GAMER_TYPE                           = 0x10040001;
        public const uint XPROFILE_GAMER_YAXIS_INVERSION                = 0x10040002;
        public const uint XPROFILE_OPTION_CONTROLLER_VIBRATION          = 0x10040003;
        public const uint XPROFILE_TITLE_SPECIFIC1                      = 0x63E83FFF;
        public const uint XPROFILE_TITLE_SPECIFIC2                      = 0x63E83FFE;
        public const uint XPROFILE_TITLE_SPECIFIC3                      = 0x63E83FFD;
        public const uint XPROFILE_GAMERCARD_ZONE                       = 0x10040004;
        public const uint XPROFILE_GAMERCARD_REGION                     = 0x10040005;
        public const uint XPROFILE_GAMERCARD_CRED                       = 0x10040006;
        public const uint XPROFILE_GAMER_PRESENCE_USER_STATE            = 0x10040007;
        public const uint XPROFILE_GAMERCARD_HAS_VISION                 = 0x10040008;
        public const uint XPROFILE_GAMERCARD_REP                        = 0x5004000B;
        public const uint XPROFILE_OPTION_VOICE_MUTED                   = 0x1004000C;
        public const uint XPROFILE_OPTION_VOICE_THRU_SPEAKERS           = 0x1004000D;
        public const uint XPROFILE_OPTION_VOICE_VOLUME                  = 0x1004000E;
        public const uint XPROFILE_GAMERCARD_PICTURE_KEY                = 0x4064000F;
        public const uint XPROFILE_GAMERCARD_PERSONAL_PICTURE           = 0x40640010;
        public const uint XPROFILE_GAMERCARD_MOTTO                      = 0x402C0011;
        public const uint XPROFILE_GAMERCARD_TITLES_PLAYED              = 0x10040012;
        public const uint XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED        = 0x10040013;
        public const uint XPROFILE_GAMER_DIFFICULTY                     = 0x10040015;
        public const uint XPROFILE_GAMER_CONTROL_SENSITIVITY            = 0x10040018;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_FIRST          = 0x1004001d;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_SECOND         = 0x1004001e;
        public const uint XPROFILE_GAMER_ACTION_AUTO_AIM                = 0x10040022;
        public const uint XPROFILE_GAMER_ACTION_AUTO_CENTER             = 0x10040023;
        public const uint XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL        = 0x10040024;
        public const uint XPROFILE_GAMER_RACE_TRANSMISSION              = 0x10040026;
        public const uint XPROFILE_GAMER_RACE_CAMERA_LOCATION           = 0x10040027;
        public const uint XPROFILE_GAMER_RACE_BRAKE_CONTROL             = 0x10040028;
        public const uint XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL       = 0x10040029;
        public const uint XPROFILE_GAMERCARD_TITLE_CRED_EARNED          = 0x10040038;
        public const uint XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED = 0x10040039;
        public const uint XPROFILE_GAMER_TIER = 0x1004003A;
        public const uint XPROFILE_MESSENGER_SIGNUP_STATE = 0x1004003B;
        public const uint XPROFILE_MESSENGER_AUTO_SIGNIN = 0x1004003C;
        public const uint XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD = 0x1004003D;
        public const uint XPROFILE_FRIENDSAPP_SHOW_BUDDIES = 0x1004003E;
        public const uint XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS = 0x1004003F;
        public const uint XPROFILE_GAMERCARD_USER_NAME = 0x41040040;
        public const uint XPROFILE_GAMERCARD_USER_LOCATION = 0x40520041;
        public const uint XPROFILE_GAMERCARD_USER_URL = 0x41900042;
        public const uint XPROFILE_GAMERCARD_USER_BIO = 0x43E80043;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_1 = 0x63E80044;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_2 = 0x63E80045;
        public const uint XPROFILE_GAMERCARD_PARTY_INFO = 0x61000046;



        // Web-only settings
        public const uint WEB_EMAIL_FORMAT                              = 0x10042000;
        public const uint WEB_FLAGS                                     = 0x10042001;
        public const uint WEB_SPAM                                      = 0x10042002;
        public const uint WEB_FAVORITE_GENRE                            = 0x10042003;
        public const uint WEB_FAVORITE_GAME                             = 0x10042004;
        public const uint WEB_FAVORITE_GAME1                            = 0x10042005;
        public const uint WEB_FAVORITE_GAME2                            = 0x10042006;
        public const uint WEB_FAVORITE_GAME3                            = 0x10042007;
        public const uint WEB_FAVORITE_GAME4                            = 0x10042008;
        public const uint WEB_FAVORITE_GAME5                            = 0x10042009;
        public const uint WEB_PLATFORMS_OWNED                           = 0x1004200a;
        public const uint WEB_CONNECTION_SPEED                          = 0x1004200b;
        public const uint WEB_FLASH                                     = 0x1004200c;
        public const uint WEB_VIDEO_PREFERENCE                          = 0x1004200d;

        // Argo/Crux settings
        public const uint XPROFILE_CRUX_MEDIA_PICTURE                   = 0x406403E8;
        public const uint XPROFILE_CRUX_MEDIA_PICTURE_PRIVATE           = 0x406403E9;
        public const uint XPROFILE_CRUX_MEDIA_STYLE1                    = 0x100403EA;
        public const uint XPROFILE_CRUX_MEDIA_STYLE2                    = 0x100403EB;
        public const uint XPROFILE_CRUX_MEDIA_STYLE3                    = 0x100403EC;
        public const uint XPROFILE_CRUX_TOP_ALBUM1                      = 0x100403ED;
        public const uint XPROFILE_CRUX_TOP_ALBUM2                      = 0x100403EE;
        public const uint XPROFILE_CRUX_TOP_ALBUM3                      = 0x100403EF;
        public const uint XPROFILE_CRUX_TOP_ALBUM4                      = 0x100403F0;
        public const uint XPROFILE_CRUX_TOP_ALBUM5                      = 0x100403F1;
        public const uint XPROFILE_CRUX_OFFLINE_ID                      = 0x603403F2;
        public const uint XPROFILE_CRUX_BKGD_IMAGE                      = 0x100403F3;
        public const uint XPROFILE_CRUX_LAST_CHANGE_TIME                = 0x700803F4;
        public const uint XPROFILE_CRUX_TOP_MUSIC                       = 0x60A803F5;
        public const uint XPROFILE_CRUX_MEDIA_MOTTO                     = 0x410003F6;
        public const uint XPROFILE_CRUX_TOP_MEDIAID1                    = 0x601003F7;
        public const uint XPROFILE_CRUX_TOP_MEDIAID2                    = 0x601003F8;
        public const uint XPROFILE_CRUX_TOP_MEDIAID3                    = 0x601003F9;
        public const uint XPROFILE_CRUX_BIO                             = 0x43E803FA;
        public const uint XPROFILE_CRUX_BG_SMALL_PRIVATE                = 0x406403FB;
        public const uint XPROFILE_CRUX_BG_LARGE_PRIVATE                = 0x406403FC;
        public const uint XPROFILE_CRUX_BG_SMALL_PUBLIC                 = 0x406403FD;
        public const uint XPROFILE_CRUX_BG_LARGE_PUBLIC                 = 0x406403FE;

        // Service Types
        // (service type flag) = 0x1 << (service type id)
        // service type ids are found in t_service_types
        // 1 = Xbox Live
        // 2 = Zune
        public const uint XPROFILE_SERVICE_TYPE_FLAG_XBOX = 0x2;
        public const uint XPROFILE_SERVICE_TYPE_FLAG_ZUNE = 0x4;

        // XBanc stuff
        public static byte[] BuildXBancKey(uint settingId, uint titleId, ulong userId)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter br = new BinaryWriter(ms);
            br.Write(ProfileDefs.XBancPrefix);
            br.Write(titleId);
            br.Write(settingId);
            br.Write(userId);
            return ms.ToArray();
        }
        
        public static byte[] XBancPrefix
        {
            get
            {
                return _XBancPrefix;
            }
        }
        public static byte[] XBancNoValue
        {
            get 
            {
                return _XBancNoValue;
            }
        }

        private static byte[] _XBancPrefix;
        private static byte[] _XBancNoValue;

        static ProfileDefs()
        {
            _XBancPrefix = new byte[] {(byte)'P', (byte)'r', (byte)'o', (byte)'f', (byte)'i', (byte)'l', (byte)'e'};
            _XBancNoValue = new byte[] {(byte)'N', (byte)'o', (byte)' ', (byte)'V', (byte)'a', (byte)'l', (byte)'u', (byte)'e'};
        }
    }

    #region Gamer Profile Protocol (Xenon)

    /// <summary>
    /// UserSetting
    /// </summary>
    /// <remarks>
    /// Describes a single setting.  Used in both setting and getting values.
    /// </remarks>
    public class UserSetting : WireData
    {
        public UserSetting() {}
        public UserSetting(ulong userId, uint settingId)
        {
            UserId = userId;
            SettingId = settingId;
        }
        public UserSetting(ulong userId, uint source, uint settingId, byte[] value)
        {
            UserId = userId;
            SettingId = settingId;
            Source = source;
            Value = value;
        }

        public uint Source = XOn.XSOURCE_NO_VALUE;
        public ulong UserId = 0;
        public uint SettingId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_VALUE_BYTES)]
        public ushort ValueLen = 0;

        [WireInfo(SizeParam="ValueLen")]
        public byte[] Value = null;
    }

    /// <summary>
    /// ReadSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="ForUserIdsLen">Count of user id's</param>
    /// <param name="ForUserIds">User ids to read</param>
    /// <param name="SettingsIdsLen">Count of settings</param>
    /// <param name="SettingsIds">Setting ids to read</param>
    /// <remarks>
    /// Retrieves a list of settings for a list of users
    /// </remarks>
    public class ReadSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort ForUserIdsLen;
        [WireInfo(SizeParam="ForUserIdsLen")]
        public ulong[] ForUserIds;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingIdsLen;
        [WireInfo(SizeParam="SettingIdsLen")]
        public uint[] SettingIds;

        public string GetXRL()
        {
            return "/xstats/readsettings.ashx";
        }
     }

    /// <summary>
    /// ReadSettingsResponse
    /// </summary>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to ReadSettingsRequest
    /// </remarks>
    public class ReadSettingsResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT * XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }





    public class UserTitle : WireData
    {
        public UserTitle() {}
        public UserTitle(uint titleId, DateTime lastPlayed, uint sequence, uint creds, ushort achievements)
        {
            TitleId = titleId;
            LastPlayed = lastPlayed;
            Sequence = sequence;
            NumCreds = creds;
            NumAchievements = achievements;
        }


        public uint TitleId = 0;

        [WireInfo(Max=XOn.MAX_TITLE_NAME_LEN)]
        public ushort TitleNameLen = 0;

        [WireInfo(SizeParam="TitleNameLen")]
        public string TitleName = "";

        public DateTime LastPlayed = DateTime.MinValue;
        public uint NumCreds = 0;
        public ushort NumAchievements = 0;
        public ushort TotalAchievements = 0;
        public uint TotalCred = 0;
        public uint Sequence = 0;
        public uint Reserved = 0;
    }

    public class SyncTitlesRequest : XRLObject2
    {
        public SyncTitlesRequest() {}
        public SyncTitlesRequest(ulong userId, DateTime version)
        {
            UserId = userId;
            Version = version;
        }

        public ulong UserId = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        public DateTime Version = DateTime.MinValue;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;



        public string GetXRL()
        {
            return "/xstats/synctitles.ashx";
        }
    }


    public class SyncTitlesResponse : XRLObject2
    {
        public DateTime Version = DateTime.MinValue;
        public ushort TotalTitles = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;
    }




    public class EnumTitlesRequest : XRLObject2
    {
        public EnumTitlesRequest() {}
        public EnumTitlesRequest(ulong userId, ulong forUserId, ushort startingIndex, ushort maxTitles)
        {
            UserId = userId;
            ForUserId = forUserId;
            StartingIndex = startingIndex;
            MaxTitles = maxTitles;
        }

        public ulong UserId;
        public ulong ForUserId;
        public ushort LocaleId;
        public ushort StartingIndex;
        public ushort MaxTitles;

        public string GetXRL()
        {
            return "/xstats/enumtitles.ashx";
        }


    }

    public class EnumTitlesResponse : XRLObject2
    {
        public ushort TitlesLen;
        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles;
    }



    public class TitleClearRequest : XRLObject2
    {
        public ulong UserId;
        public uint TitleId;

        public string GetXRL()
        {
            return "/xstats/cleartitle.ashx";
        }

    }






    /// <summary>
    /// SyncSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Updates one or more of a single user's profile settings
    /// </remarks>
    public class SyncSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;
        public DateTime Version;
        public ushort StartinIndex;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        public string GetXRL()
        {
            return "/xstats/syncsettings.ashx";
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncSettingsResponse : XRLObject2
    {
        public DateTime Version;
        public ushort TotalSettings;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }




    public class SyncAllRequest : XRLObject2
    {
        public SyncAllRequest() {}
        public SyncAllRequest(ulong userId, uint titleId, ushort localeId, byte[] guid)
        {
            UserId = userId;
            TitleId = titleId;
            LocaleId = localeId;
            Guid = guid;
        }


        public uint TitleId;
        public ulong UserId;
        public ushort LocaleId;

        [WireInfo(ArraySize=16)]
        public byte[] Guid;


        // settings
        //
        public DateTime SettingsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        // titles
        //
        public DateTime TitlesVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;


        // achievements
        //
        public DateTime AchievementsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;


        public string GetXRL()
        {
            return "/xstats/syncall.ashx";
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncAllResponse : XRLObject2
    {
        public SyncSettingsResponse Settings = new SyncSettingsResponse();
        public SyncTitlesResponse Titles = new SyncTitlesResponse();
        public SyncAchievementsResponse Achievements = new SyncAchievementsResponse();
    }


    public class ContextString : WireData
    {
        public uint ContextId;
        public uint NameLen;
        public string Name;
    }

    public class ContextEnumRequest : XRLObject2
    {
        public uint TitleId;
        public uint ContextId;
        public ushort LocaleId;
        public uint StartingIndex;
        public uint MaxContexts;

        public string GetXRL()
        {
            return "/xstats/contextenum.ashx";
        }

    }

    public class ContextEnumResponse : XRLObject2
    {
        public uint TotalContexts;

        public uint ContextsLen;
        public ContextString[] Contexts;
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\XbosProtocol.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Web;
using System.Web.Caching;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using live.common;
using live.common.next;
using live.client;

namespace live.protocol
{
    [ComVisible(false)]
    public interface IMeasurable
    {
        uint GetSize();
    }

    public enum ConsoleTypeEnum
    {
        Xbox1       = 0,
        XboxCom     = 1,
        Xenon       = 2,
        Marketplace = 3,
        PC          = 4
    }

    public enum OfferCatalogTypeEnum
    {
        Unknown     = 0,
        Xbox        = 1,
        Ems         = 2
    }


    public abstract class XRLObject2WithFlags : XRLObject2
    {
        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort)(value | flag);
            else
                value = (ushort)(value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }
    }

    public abstract class XRLRequestObject2WithFlags : XRLRequestObject2
    {
        public override string GetHttpMethod()
        {
            return HttpMethod.Post;
        }

        public override string GetRelativeUrl()
        {
            return Xrl;
        }

        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort)(value | flag);
            else
                value = (ushort)(value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }
    }

    public class AutoupdReferralRequest : XRLRequestObject2
    {
        public ulong  machinePuid;
        public uint   titleId;
        public uint   baseVersion; // Base version (Dash only)

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/AutoupdReferral.ashx"; }
        }
    }

    public class ReferralLocation : XRLObject2
    {
        public ushort rank;

        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string Xrl;          // XRL to update package
    }

    public class AutoupdReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   titleVersion;   // Update version

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class ContentAvailableRequest : XRLRequestObject2
    {
        public uint titleId =0;

        public int esrbRating =0;

        public uint bitFilter =0;

        public DateTime lastChangedDate = DateTime.UtcNow;

        public byte countryId = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentAvailable.ashx"; }
        }
    }

    public class ContentReferralRequest : XRLRequestObject2
    {
        public ulong machinePuid;
        public ulong userPuid0;
        public ulong userPuid1;
        public ulong userPuid2;
        public ulong userPuid3;
        public uint  titleId;
        public ulong offerId;
        public uint  esrbRating;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentReferral.ashx"; }
        }
    }

    public class ContentReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   bitFlags;       // Package bit flags

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class OfferingCancelRequest : XRLRequestObject2
    {
        public ulong userPuid;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingCancel.ashx"; }
        }
    }

    public class OfferingDetailsRequest : XRLRequestObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetails.ashx"; }
        }
    }

    public class OfferingDetailsResponse : XRLObject2
    {
        public uint   instanceCount;

        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string isoCode;

        public uint   offeringDetails;

        public uint   detailsBlobLength;

        [WireInfo(SizeParam="detailsBlobLength")]
        public byte[] detailsBlob;
    }

    public class OfferingDetailsNoUserRequest : XRLRequestObject2
    {
        public byte countryId;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetailsNoUser.ashx"; }
        }
    }

    public class OfferingEnumerateRequest : XRLRequestObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public int         esrbRating;

        public DateTime    lastChangedDate = DateTime.UtcNow;

        public uint        offerType;

        public uint        bitFilter;

        public int         descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingEnumerate.ashx"; }
        }
    }

    public class OfferingEnumerateRecord : XRLObject2
    {
        public short  recordSize;

        public short  recordIndex;

        public ulong  offerId;

        public int    offerType;

        public int    bitFlags;

        public int    packageSize;

        public int    installSize;

        public DateTime activationDate;

        public int    esrbRating;

        public short  offerFlags;

        public int    titleSpecificDataSize;

        public int    titleSpecificDataOffset;

        [WireInfo(SizeParam="titleSpecificDataSize")]
        public byte[] enumBlob;
    }

    public class OfferingEnumerateResponse : XRLObject2
    {
        public short    recordCount;

        public short    flags;

        public DateTime lastChangedDate;

        [WireInfo(SizeParam="recordCount")]
        public OfferingEnumerateRecord[] records;
    }

    public class OfferingPurchaseRequest : XRLRequestObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingPurchase.ashx"; }
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentUpdateAccessTimesRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentUpdateAccessTimes.ashx";
            }
        }
    }

    public class ContentEnumerateRequest : XRLRequestObject2WithFlags
    {
        static byte UserPlayedGameFilter        = 0x01;
        static byte UserHasPurchasedFilter      = 0x02;
        static byte NewContentOnlyFilter        = 0x04;
        static byte MatchRequiredTierFilter     = 0x08;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public byte countryID = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;

        public ushort languageID = XOn.XC_LANGUAGE_ENGLISH;

        [WireInfo(HexString=true)]
        public ushort gameRating = 0x00ff;  // US, Allow all games;

        [WireInfo(HexString=true)]
        public uint offerType = (uint)OfferingTypeEnum.Any; // all offer types (content, points bundle, gamertag, etc)

        [WireInfo(HexString=true)]
        public uint paymentType = (uint)PaymentTypeEnum.Any;   // Any payment type (credit card, token, points, etc)

        public byte tierRequired = 3;

        [WireInfo(HexString=true)]
        public uint titleID = 0;    // all titles

        [WireInfo(HexString=true)]
        public uint titleCategories = 0xffffffff;   // not used

        [WireInfo(HexString=true)]
        public byte requestFlags = 0;   // userPlayedGameFilter, userHasPurchasedFilter

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex = 0;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults = 30; // client uses this value

        public int genreID = Genres.GENRE_NONE.Id;     // root genres, across all product type ids

        public bool userPlayedGameFilter
        {
            get
            {
                return IsFlagSet(UserPlayedGameFilter, requestFlags);
            }
            set
            {
                SetFlag(UserPlayedGameFilter, value, ref requestFlags);
            }
        }

        public bool userHasPurchasedFilter
        {
            get
            {
                return IsFlagSet(UserHasPurchasedFilter, requestFlags);
            }
            set
            {
                SetFlag(UserHasPurchasedFilter, value, ref requestFlags);
            }
        }

        public bool newContentOnlyFilter
        {
            get
            {
                return IsFlagSet(NewContentOnlyFilter, requestFlags);
            }
            set
            {
                SetFlag(NewContentOnlyFilter, value, ref requestFlags);
            }
        }

        public bool matchRequiredTierFilter
        {
            get
            {
                return IsFlagSet(MatchRequiredTierFilter, requestFlags);
            }
            set
            {
                SetFlag(MatchRequiredTierFilter, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentEnumerate2.ashx";
            }
        }
    }

    public class OfferPrice : XRLObject2
    {
        public uint paymentType;

        public byte taxType;

        public int wholePrice;

        public int fractionalPrice;

        public ushort priceTextLength;

        [WireInfo(SizeParam="priceTextLength", NullTerminate=true)]
        public string priceText;
      }

    public class BasicContentInfo : XRLObject2WithFlags
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort UserHasViewed             = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsRecentContent           = 0x0008;

        public BasicContentInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ulong previewOfferID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint licenseMask;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public byte tierRequired;

        public ushort gameRating;

        public ushort responseFlags; // userHasPurchased, userHasViewed, isUnrestricted

        public uint packageSize;

        public uint installSize;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint assetID;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint purchaseQuantity;

        public byte pricesLength;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.DateTime maxStartDate;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool userHasViewed
        {
            get
            {
                return IsFlagSet(UserHasViewed, responseFlags);
            }
            set
            {
                SetFlag(UserHasViewed, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isRecentContent
        {
            get
            {
                return IsFlagSet(IsRecentContent, responseFlags);
            }
            set
            {
                SetFlag(IsRecentContent, value, ref responseFlags);
            }
        }
    }


    public class ContentEnumerateResponse : XRLObject2, IMeasurable
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentInfo[] infos;

        public uint offersTotal;

        uint IMeasurable.GetSize()
        {
            uint size = 6;

            for (uint iInfo = 0; iInfo < offersReturned; iInfo++)
            {
                size += 90;
                size += infos[iInfo].offerNameLength;
                size += (uint)infos[iInfo].sellTextLength;
                size += infos[iInfo].titleNameLength;

                for (uint iPrice = 0; iPrice < infos[iInfo].pricesLength; iPrice++)
                {
                    size += 15;
                    size += infos[iInfo].prices[iPrice].priceTextLength;
                }
            }

            return size;
        }

        public ContentEnumerateResponse Copy()
        {
            ContentEnumerateResponse copy = new ContentEnumerateResponse();

            copy.offersReturned = offersReturned;
            copy.offersTotal = offersTotal;

            copy.infos = new BasicContentInfo[infos.Length];
            for (uint iInfo = 0; iInfo < infos.Length; iInfo++)
            {
                copy.infos[iInfo] = new BasicContentInfo();

                copy.infos[iInfo].offerID = infos[iInfo].offerID;
                copy.infos[iInfo].previewOfferID = infos[iInfo].previewOfferID;
                copy.infos[iInfo].offerNameLength = infos[iInfo].offerNameLength;
                copy.infos[iInfo].offerName = infos[iInfo].offerName;
                copy.infos[iInfo].offerType = infos[iInfo].offerType;
                copy.infos[iInfo].contentId = infos[iInfo].contentId;
                copy.infos[iInfo].licenseMask = infos[iInfo].licenseMask;
                copy.infos[iInfo].titleID = infos[iInfo].titleID;
                copy.infos[iInfo].titleCategory = infos[iInfo].titleCategory;
                copy.infos[iInfo].titleNameLength = infos[iInfo].titleNameLength;
                copy.infos[iInfo].titleName = infos[iInfo].titleName;
                copy.infos[iInfo].tierRequired = infos[iInfo].tierRequired;
                copy.infos[iInfo].gameRating = infos[iInfo].gameRating;
                copy.infos[iInfo].responseFlags = infos[iInfo].responseFlags;
                copy.infos[iInfo].packageSize = infos[iInfo].packageSize;
                copy.infos[iInfo].installSize = infos[iInfo].installSize;
                copy.infos[iInfo].sellTextLength = infos[iInfo].sellTextLength;
                copy.infos[iInfo].sellText = infos[iInfo].sellText;
                copy.infos[iInfo].assetID = infos[iInfo].assetID;
                copy.infos[iInfo].purchaseQuantity = infos[iInfo].purchaseQuantity;
                copy.infos[iInfo].pricesLength = infos[iInfo].pricesLength;
                copy.infos[iInfo].maxStartDate = infos[iInfo].maxStartDate;

                copy.infos[iInfo].prices = new OfferPrice[infos[iInfo].prices.Length];
                for (uint iPrice =0; iPrice < infos[iInfo].prices.Length; iPrice++)
                {
                    copy.infos[iInfo].prices[iPrice] = new OfferPrice();

                    copy.infos[iInfo].prices[iPrice].paymentType = infos[iInfo].prices[iPrice].paymentType;
                    copy.infos[iInfo].prices[iPrice].taxType = infos[iInfo].prices[iPrice].taxType;
                    copy.infos[iInfo].prices[iPrice].wholePrice = infos[iInfo].prices[iPrice].wholePrice;
                    copy.infos[iInfo].prices[iPrice].fractionalPrice = infos[iInfo].prices[iPrice].fractionalPrice;
                    copy.infos[iInfo].prices[iPrice].priceTextLength = infos[iInfo].prices[iPrice].priceTextLength;
                    copy.infos[iInfo].prices[iPrice].priceText = infos[iInfo].prices[iPrice].priceText;
                }
            }

            return copy;
        }
    }

    public class ContentDetailsRequest : XRLRequestObject2
    {
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offers;        // count of offers

        [WireInfo(HexString=true, SizeParam="offers", MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(HexString=true, MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;    // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentDetails.ashx";
            }
        }
    }

    public class ContentDetailsResponse : XRLObject2
    {
        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned", MinSchemaVersion="2.0")]
        public BasicContentInfo [] infos;

        [WireInfo(MaxSchemaVersion="1.0")]
        public BasicContentInfo basicInfo;
    }

    public class SubscriptionEnumerateRequest : XRLRequestObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForRenewals                 = 0x0002;
        static ushort QueryForCurrent                  = 0x0004;
        static ushort QueryForExpired                  = 0x0008;
        static ushort QueryForSuspended                = 0x0010;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte userTier;

        public byte countryID;

        public ushort languageID;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // live, game, 24-hour, add-on

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // queryForEquivalent, queryForUpgrades, queryForDowngrades

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionEnumerate.ashx";
            }
        }

        public bool queryForNew
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool queryForRenewals
        {
            get
            {
                return IsFlagSet(QueryForRenewals, requestFlags);
            }
            set
            {
                SetFlag(QueryForRenewals, value, ref requestFlags);
            }
        }

        public bool queryForCurrent
        {
            get
            {
                return IsFlagSet(QueryForCurrent, requestFlags);
            }
            set
            {
                SetFlag(QueryForCurrent, value, ref requestFlags);
            }
        }

        public bool queryForExpired
        {
            get
            {
                return IsFlagSet(QueryForExpired, requestFlags);
            }
            set
            {
                SetFlag(QueryForExpired, value, ref requestFlags);
            }
        }

        public bool queryForSuspended
        {
            get
            {
                return IsFlagSet(QueryForSuspended, requestFlags);
            }
            set
            {
                SetFlag(QueryForSuspended, value, ref requestFlags);
            }
        }
    }

    public class BasicSubscriptionInfo : XRLObject2WithFlags
    {
        static ushort UserIsSubscribed          = 0x0001;
        static ushort UserHasCancelled          = 0x0002;

        public BasicSubscriptionInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        public byte relationType;

        public byte convertMode;

        public ushort instanceIDLength;

        [WireInfo(SizeParam="instanceIDLength", NullTerminate=true)]
        public string instanceID;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public ushort gameRating;

        public byte duration;

        public byte frequency;

        public byte tierProvided;

        public byte tierRequired;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        public ulong relatedOfferID;

        public ushort responseFlags; // userIsSubscribed

        public byte pricesLength;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        [WireInfo(Serialize=false)]
        public int subscriptionStatusID;
        public bool userIsSubscribed
        {
            get
            {
                return IsFlagSet(UserIsSubscribed, responseFlags);
            }
            set
            {
                SetFlag(UserIsSubscribed, value, ref responseFlags);
            }
        }

        public bool userHasCancelled
        {
            get
            {
                return IsFlagSet(UserHasCancelled, responseFlags);
            }
            set
            {
                SetFlag(UserHasCancelled, value, ref responseFlags);
            }
        }
    }


    public class SubscriptionEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicSubscriptionInfo [] infos;

        public int offersTotal;
    }

    public class SubscriptionDetailsRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryID;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageID;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionDetails.ashx";
            }
        }
    }

    public class SubscriptionDetailsResponse : XRLObject2
    {
        public BasicSubscriptionInfo basicInfo;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeContentAvailableRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentAvailable.ashx";
            }
        }
    }

    public class XeContentAvailableResponse : XRLObject2
    {
        public byte newOffersLength = 32;

        [WireInfo(SizeParam="newOffersLength")]
        public uint [] newOffers;

        public byte totalOffersLength = 32;

        [WireInfo(SizeParam="totalOffersLength")]
        public uint [] totalOffers;
    }

    public class XeWmdrmChallengeBlock : XRLObject2
    {
        public const int CHALLENGE_BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=CHALLENGE_BLOCK_MAX_LEN)]
        public ushort challengeBlockLength;

        [WireInfo(SizeParam="challengeBlockLength")]
        public byte[] challengeBlock;
    }

    public class XeWmdrmLicenseBlock : XRLObject2
    {
        public const int LICENSE_BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=LICENSE_BLOCK_MAX_LEN)]
        public ushort licenseBlockLength;

        [WireInfo(SizeParam="licenseBlockLength")]
        public byte[] licenseBlock;
    }

    public class XeAcquireVideoLicenseRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public WMID wmid;

        public const int CHALLENGE_BLOCK_MAX_COUNT = 13;

        [WireInfo(Min=1, Max=CHALLENGE_BLOCK_MAX_COUNT)]
        public ushort challengeBlockCount;

        [WireInfo(SizeParam="challengeBlockCount")]
        public XeWmdrmChallengeBlock[] challengeBlocks;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeAcquireVideoLicense.ashx";
            }
        }
    }

    public class XeAcquireVideoLicenseResponse : XRLObject2
    {
        public const int LICENSE_BLOCK_MAX_COUNT = 33;

        [WireInfo(Min=1, Max=LICENSE_BLOCK_MAX_COUNT)]
        public ushort licenseBlockCount;

        [WireInfo(SizeParam="licenseBlockCount")]
        public XeWmdrmLicenseBlock[] licenseBlocks;

        public ushort contentURLLength;

        [WireInfo(SizeParam="contentURLLength")]
        public string contentURL;
    }

    public class XeAcquireVideoContentURLRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public WMID wmid;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeAcquireVideoContentURL.ashx";
            }
        }
    }

    public class XeAcquireVideoContentURLResponse : XRLObject2
    {
        public ushort contentURLLength;

        [WireInfo(SizeParam = "contentURLLength")]
        public string contentURL;
    }

    public class XeAcknowledgeLicenseDeliveryRequest : XRLRequestObject2 {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public WMID wmid;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeAcknowledgeLicenseDelivery.ashx";
            }
        }
    }

    public class XeAcknowledgeLicenseDeliveryResponse : XRLObject2
    {
    }

    public class XeOfferPurchaseRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint offerIDLength;

        [WireInfo(SizeParam="offerIDLength", HexString=true, MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.2")]
        public ushort EncryptedPasswordLength;
        [WireInfo(SizeParam = "EncryptedPasswordLength", MinSchemaVersion = "4.0")]
        public string EncryptedPassword;


        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchase.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseGamertag.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagResponse : XRLObject2
    {
        public byte newKeyLength;

        [WireInfo(SizeParam="newKeyLength")]
        public byte [] newKey;
    }

    public class MusicItem : XRLObject2
    {
        public ushort mnetIDLength;

        [WireInfo(SizeParam="mnetIDLength")]
        public string mnetID;

        public uint componentType;

        public ushort artistNameLength;

        [WireInfo(SizeParam="artistNameLength")]
        public string artistName;

        public ushort titleFieldLength;

        [WireInfo(SizeParam="titleFieldLength")]
        public string titleField;

        public int retailPriceInPoints;

        public decimal retailPriceInCurrency;

        public decimal wholesalePriceInCurrency;
    }

    public class XeOfferPurchaseMusicRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort ipAddressLength;

        [WireInfo(SizeParam="ipAddressLength")]
        public string ipAddress;

        public ushort externalOrderIDLength;

        [WireInfo(SizeParam="externalOrderIDLength")]
        public string externalOrderID;

        public ushort itemCount;

        [WireInfo(SizeParam="itemCount")]
        public MusicItem [] items;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseMusic.ashx";
            }
        }
    }

    public class PointsPurchaseQuery : XRLObject2
    {
        public ushort purchaseType; // DMPPurchaseType

        public ushort orderIDType; // DMPOrderIDType

        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;
    }

    public class XeGetPointsPurchaseStatusRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort queryCount;

        [WireInfo(SizeParam="queryCount")]
        public PointsPurchaseQuery [] queries;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetPointsPurchaseStatus.ashx";
            }
        }
    }

    public class PointsPurchaseStatus : XRLObject2
    {
        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;

        public int status; // DMPTransacionStatus
    }

    public class XeGetPointsPurchaseStatusResponse : XRLObject2
    {
        public ushort statusCount;

        [WireInfo(SizeParam="statusCount")]
        public PointsPurchaseStatus [] statuses;
    }

    public class WMID : XRLObject2
    {
        public ushort wmidLength;

        [WireInfo(SizeParam="wmidLength")]
        public string wmid;

        public uint videoType;
    }

    public class XeOfferPurchaseVideoRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public WMID wmid;

        public uint expectedPrice;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseVideo.ashx";
            }
        }
    }

    public class XeOfferPurchaseVideoResponse : XRLObject2
    {
        public ushort wmidCount;

        [WireInfo(SizeParam="wmidCount")]
        public WMID [] wmids;
    }

    //
    // banner of the day protocol
    //

    public enum BannerListLevel : byte
    {
        BannerOnly = 1,
        HotList = 2
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class BannerListRequest : XRLRequestObject2
    {
        public ulong userPuid;
        public uint langId;
        public byte level;
        public int  startingIndex;
        public int  maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeBannerGetList.ashx";
            }
        }
    }

    public enum BannerType : byte
    {
        Min = 0,
        Live_Blade_Billboard = 0,
        Live_Blade_Marketplace = 1,
        Marketplace_Storefront = 2,
        V1_Marketplace_Demos_and_Game_Videos = 3,
        V1_Marketplace_Games = 4,
        V1_Marketplace_Themes_and_Gamer_Pictures = 5,
        Games_Blade_Arcade_Banner = 6,
        V1_Marketplace_Arcade = 7,
        V1_Marketplace_Game_Demos = 8,
        V1_Marketplace_Trailers_and_Game_Videos = 9,
        V1_Marketplace_Gamer_Pictures = 10,
        V1_Marketplace_Media_and_Entertainment = 11,
        MediaMarketplace_Video_Main_Large = 12,
        MediaMarketplace_Video_Main_Small = 13,
        MediaMarketplace_Video_Movies_Main = 14,
        MediaMarketplace_Video_TV_Main = 15,
        MediaMarketplace_Video_Music_Videos_Main = 16,
        MediaMarketplace_Video_Viral_Main_Top = 17,
        MediaMarketplace_Video_Viral_Main_Middle = 18,
        MediaMarketpalce_Video_Viral_Main_Bottom = 19,
        V2_Marketplace_Demos_and_Game_Videos = 20,
        V2_Marketplace_Games = 21,
        V2_Marketplace_Themes_and_Gamer_Pictures = 22,
        V2_Marketplace_Arcade = 23,
        V2_Marketplace_Game_Demos = 24,
        V2_Marketplace_Trailers_and_Game_Videos = 25,
        V2_Marketplace_Gamer_Pictures = 26,
        V2_Marketplace_Media_and_Entertainment = 27,
        V2_Marketplace_Game_Trailers = 28,
        V2_Marketplace_Gaming_Community = 29,
        V2_Marketplace_Game_Tips_and_Support_Videos = 30,
        // Added in Spring 2007
        V2_Games_Blade_Title_Promo = 31,
        V2_Marketplace_Games_Small = 32,
        V2_Marketplace_Game_Arcade_Small = 33,
        V2_Marketplace_GameDemos_Small = 34,
        V2_Marketplace_ThemesGamerPic_Small = 35,
        V2_Marketplace_Video_GameVideo_US_Small = 36,
        V2_Marketplace_Video_GameVideo_US_Large = 37,
        V2_Marketplace_Video_NonUS_Small = 38,
        V2_Marketplace_Video_GameVideo_NonUS_Small = 39,
        // Added in Fall 2007
        XBLA = 40,
        Games_Blade_Featured_Title = 41,
        Feature_Item_Flag_Slot = 42,
        Free_TV = 43,
        Games_on_Demand_Small = 44,
        Games_on_Demand_Large = 45,
        V3_Featured_Items_1 = 46,
        V3_Featured_Items_2 = 47,
        V3_Featured_Items_3 = 48,
        V3_Featured_Items_4 = 49,
        V3_Featured_Items_5 = 50,
        V3_Featured_Items_6 = 51,
        V3_Featured_Items_7 = 52,
        V3_Featured_Items_8 = 53,
        V3_Featured_Items_9 = 54,
        V3_Featured_Items_10 = 55,
        Games_Lib_Featured_BDE = 56,
        Game_AddOns_Small = 57,
        Game_AddOns_Large = 58,
        Game_Related_Downloads_small = 59,
        Game_Related_Downloads_large = 60,
        New_Arrivals = 61,
        Billboard_Games_Blade = 62,
        Billboard_Media_Blade = 63,
        Marketplace_top_level_slot_A = 64,
        Marketplace_top_level_slot_B = 65,
        Marketplace_top_level_slot_C = 66,
        BDE_Parking = 67,
        // Begin Future Slots
        Future_slot_A = 68,
        Future_slot_B = 69,
        Future_slot_C = 70,
        Future_slot_D = 71,
        Future_slot_E = 72,
        Future_slot_F = 73,
        Future_slot_G = 74,
        Future_slot_H = 75,
        // End Future Slots
        Max,
    }

    public class XOnlineString : WireData
    {
        public ushort len;
        [WireInfo(SizeParam="len")]
        public string str;
    }

    public class BannerBaseListEntry : WireData
    {
        public byte bannerType;
        public bool isMyGame;  // whether banner shows on personalized pages
        public ushort width;
        public ushort height;
        public XOnlineString path = new XOnlineString();
    }

    public class BannerHotListEntry : BannerBaseListEntry
    {
        public uint titleId;
        public XOnlineString titleName = new XOnlineString();
        public ulong offerId;
        public XOnlineString offerName = new XOnlineString();
        public OfferPrice price;
        public DateTime dateApproved;
    }

    public class BannerListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerBaseListEntry[] bannerList = null;  // can be BannerHotListEntry[]
    }

    public class BannerHotListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerHotListEntry[] hotList = null;
    }


    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeGetTitleDetailsRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint titleId;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public byte tierRequired;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetTitleDetails.ashx";
            }
        }
    }

    public class XeGetTitleDetailsResponse : XRLObject2, IMeasurable
    {
        [WireInfo(HexString=true)]
        public ushort gameRating;

        public ushort titleLength;
        [WireInfo(SizeParam="titleLength")]
        public string title;

        public ushort sellTextLength;
        [WireInfo(SizeParam="sellTextLength")]
        public string sellText;

        public ushort developerLength;
        [WireInfo(SizeParam="developerLength")]
        public string developer;

        public ushort publisherLength;
        [WireInfo(SizeParam="publisherLength")]
        public string publisher;

        public ushort genreLength;
        [WireInfo(SizeParam="genreLength")]
        public string genre;

        public bool subscriptionContent;
        public bool themeContent;
        public bool demoContent;
        public bool trailerContent;
        public bool played;

        uint IMeasurable.GetSize()
        {
            uint size = 12 + 5;

            size += (uint) (titleLength + sellTextLength + developerLength + publisherLength + genreLength);

            return size;
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateTitlesByFilterRequest : XRLRequestObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForPlayed                 = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public int genreId = 0;

        public uint offerType = 0;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // new content filter, games played filter

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateTitlesByFilter.ashx";
            }
        }

        public bool gamesWithNewContentFilter
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool gamesPlayedFilter
        {
            get
            {
                return IsFlagSet(QueryForPlayed, requestFlags);
            }
            set
            {
                SetFlag(QueryForPlayed, value, ref requestFlags);
            }
        }
    }

    public class XeEnumerateTitlesByFilterResponse : XRLObject2, IMeasurable
    {
        public uint titlesReturned = 0;

        [WireInfo(SizeParam="titlesReturned")]
        public EnumeratedTitleInfo [] titles;

        public uint totalTitleCount = 0;

        uint IMeasurable.GetSize()
        {
            uint size = 8;

            for (uint iTitle = 0; iTitle < titlesReturned; iTitle++)
            {
                size += 16;
                size += titles[iTitle].titleNameLength;
            }

            return size;
        }
    }

    public class EnumeratedTitleInfo : XRLObject2
    {
        public ushort titleNameLength;
        [WireInfo(SizeParam="titleNameLength")]
        public string titleName;

        public uint titleId;

        public bool played;

        public uint purchasedContentCount;
        public uint totalContentCount;
        public bool newContentExists;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateGenresRequest : XRLRequestObject2
    {
        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public uint offerType = 0;
        public int parentGenreId = 0;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateGenres.ashx";
            }
        }
    }

    public class XeEnumerateGenresResponse : XRLObject2
    {
        public ushort genresReturned = 0;

        [WireInfo(SizeParam="genresReturned")]
        public EnumeratedGenreInfo [] genres;

        public uint totalGenreCount = 0;
    }

    public class EnumeratedGenreInfo : XRLObject2
    {
        public int genreId = 0;

        public ushort localizedGenreLength = 0;

        [WireInfo(SizeParam="localizedGenreLength")]
        public string localizedGenreName = "";
    }

    [WireInfo(MaxSchemaVersion = "4.9")]
    public class XeContentReferralRequest : XRLRequestObject2
    {
        public ulong userId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentReferral.ashx";
            }
        }
    }

    public class XeContentReferralLocation : XRLRequestObject2
    {
        public ushort rank;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_XRL_MAX_LEN)]
        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string _xrl;
        public override string Xrl
        {
            get
            {
                return _xrl;
            }
        }
    }

    public class XeContentReferralResponse : XRLObject2
    {
        public uint packageSize;

        public uint installSize;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LOCATIONS_MAX_COUNT)]
        public ushort locationsCount;

        [WireInfo(SizeParam="locationsCount")]
        public XeContentReferralLocation[] locations;
    }

    public class XeContentRefreshLicenseRequest : XRLRequestObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentRefreshLicense.ashx";
            }
        }
    }

    public class XeContentRefreshLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }

    public class GetTitleActivationListRequest : XRLRequestObject2
    {
        public const uint SIGNATUREFORMAT_LITTLE_ENDIAN = 0;
        public const uint SIGNATUREFORMAT_BIG_ENDIAN    = 1;

        // machinePuid or consoleId?
        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(HexString=true)]
        public UInt32 requestedTitleId;

        [WireInfo(Min=0, Max=1)]
        public UInt32 signatureFormat;

        public override string Xrl
        {
            get
            {
                return "/xbos/GetTitleActivationList.ashx";
            }
        }
    }

    public class GetTitleActivationListResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.TITLE_ACTIVATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        // Everything below here (the body) is signed

        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(Min=0, Max=XOn.TITLE_ACTIVATION_LIST_MAX_LEN)]
        public UInt32 titlesLength;

        [WireInfo(SizeParam="titlesLength")]
        public TitleLicenseInfo[] titles;

        // Not part of protocol...

        public uint GetBodySize()
        {
            return
                + 8
                + (XOn.XONLINE_MAX_LOGON_USERS * 8)
                + 4
                + 4
                + (titlesLength * 8);
        }

    }

    public class TitleLicenseInfo : WireData
    {
        public const uint LicenseFlags_GrantedUser1   = 0x01;
        public const uint LicenseFlags_GrantedUser2   = 0x02;
        public const uint LicenseFlags_GrantedUser3   = 0x04;
        public const uint LicenseFlags_GrantedUser4   = 0x08;
        public const uint LicenseFlags_GrantedMachine = 0x10;

        [WireInfo(HexString=true)]
        public UInt32 titleId;

        [WireInfo(HexString=true)]
        public UInt32 licenseFlags;
    }
    public class XeOfferingVerifyTokenRequest : XRLRequestObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;
        [WireInfo(HexString=true, MinSchemaVersion="4.2")]
        public ulong userPuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/XeOfferingVerifyToken.ashx"; }
        }
    }

    public class XeOfferingVerifyTokenResponse : XRLObject2
    {
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeGetRevocationListRequest : XRLRequestObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE)]
        public byte[] clientNonce;

        public override string Xrl
        {
            get { return "/xbos/GetRevocationList.ashx"; }
        }
    }

    public class XeGetRevocationListReply : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SERVER_NONCE_SIZE)]
        public byte[] serverNonce;

        [WireInfo(Max=XOn.REVOCATION_LIST_MAX_ENTRIES)]
        public uint numListEntries;

        [WireInfo(SizeParam="numListEntries")]
        public RevocationListEntry[] entries;
    }

    public class RevocationListEntry : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_ENTRY_DIGEST_SIZE)]
        public byte[] digest;
    }


    public class Asset : WireData
    {
        public uint     assetID;

        public int      quantity;        // signed quantity, may be negative during Consume
    }

    public class AssetEnumerateRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        public uint     flags;          // unused

        public ushort   startingIndex;

        public ushort   maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetEnumerate.ashx";
            }
        }
    }

    // Signable asset structure.
    public class AssetPackage : WireData
    {
        public DateTime  dtAssets;

        public uint     cAssets;

        public uint     cTotalAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset[]  assets;
    }

    public class AssetEnumerateResponse : XRLObject2
    {
        public const int ASSET_SIGNATURE_SIZE = 256;

        [WireInfo(ArraySize=ASSET_SIGNATURE_SIZE)]
        public byte[]   signature;

        public AssetPackage package;
    }

    public class AssetConsumeRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        public uint     cAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset []  assets;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetConsume.ashx";
            }
        }
    }

    public class AssetConsumeResponse : XRLObject2
    {

    }

    public class XeWmdrmCreateCertificateRequest : XRLRequestObject2
    {
        public const int DEVICE_PUBLIC_KEY_LEN = 40;

        [WireInfo(Min=0, Max=0)]
        public uint flags;

        [WireInfo(ArraySize=DEVICE_PUBLIC_KEY_LEN)]
        public byte[] devicePublicKey;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeWmdrmCreateCertificate.ashx";
            }
        }
    }

    public class XeWmdrmCertificateBlock : XRLObject2
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_LEN)]
        public ushort certBlockLength;

        [WireInfo(SizeParam="certBlockLength")]
        public byte[] certBlock;
    }

    public class XeWmdrmCreateCertificateReply : XRLObject2
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_COUNT = 2;

        [WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;

        [WireInfo(SizeParam="certBlockCount")]
        public XeGenericBlock[] certBlocks;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentHistoryEnumerateRequest : XRLRequestObject2WithFlags
    {
        static byte QueryForIsAcquirable = 0x0001;

        [WireInfo(HexString=true)]
        public ulong userPuid; // user's live XUID making the request

        [WireInfo(MinSchemaVersion = "3.0")]
        public ulong machinePuid;

        public byte countryID; // live Country

        public ushort languageID; // live Language

        [WireInfo(HexString=true)]
        public uint offerType; // content OfferTypes, or SyncCastWMIS

        [WireInfo(HexString=true)]
        public byte requestFlags; // isAcquirableOnlyFilter

        public int startingIndex;

        public int maxResults;

        public bool isAcquirableOnlyFilter
        {
            get
            {
                return IsFlagSet(QueryForIsAcquirable, requestFlags);
            }
            set
            {
                SetFlag(QueryForIsAcquirable, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentHistoryEnumerate.ashx";
            }
        }
    }

    public class ContentHistoryEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentHistoryInfo [] infos;

        public uint offersTotal;
    }

    public class BasicContentHistoryInfo : XRLObject2WithFlags
    {
        static ushort IsAcquirable = 0x0001;
        static ushort IsUnrestricted = 0x0002;

        public BasicContentHistoryInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID; // OfferID for Xbox-LIVE true/full Offers

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName; // Text-Name for the above offerID

        public uint offerType; // content OfferTypes, or SyncCastWMIS

        public uint titleID; // primary TitleID that the Offer belongs to

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName; // Text-Name for above titleID

        public ushort responseFlags; // isAcquirable, isUnrestricted

        public WMID wmid; // WMIS Guid/Type structure (movie/tv episode/tv season)

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licenseAcknowledged;

        [WireInfo(MinSchemaVersion = "3.0")]
        public DateTime licenseExpiration;

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licensedOnMachine;

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, responseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }
    }


    public class TransferMachineLicenseRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuidOld;

        [WireInfo(HexString=true)]
        public ulong machinePuidNew;

        public override string Xrl
        {
            get
            {
                return "/xbos/TransferMachineLicenses.ashx";
            }
        }
    }

    public class TitleActivationInfo
    {
        public const int MaxUserLogin = 4;
        public const int LiveSignatureLength = 256;

        public const UInt32 LicenseFlags_GrantedUser1 = 0x01;
        public const UInt32 LicenseFlags_GrantedUser2 = 0x02;
        public const UInt32 LicenseFlags_GrantedUser3 = 0x04;
        public const UInt32 LicenseFlags_GrantedUser4 = 0x08;
        public const UInt32 LicenseFlags_GrantedMachine = 0x10;

        public const UInt32 SIGNATUREFORMAT_LITTLE_ENDIAN = 0;
        public const UInt32 SIGNATUREFORMAT_BIG_ENDIAN = 1;

    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "FindMediaInstanceUrls", "urn:schemas-xbox-com:billing-data")]
    public class FindMediaInstanceUrlsRequest : PayloadRequestWithSSL
    {
        [WireInfo(Min = 1, Max = 20)]
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        [WireInfo(Serialize = false)]
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam("mediaInstanceIds")]
        public string[] MediaInstanceStrings
        {
            get
            {
                List<string> strings = new List<string>(mediaInstanceIds.Length);
                foreach (Guid guid in mediaInstanceIds)
                {
                    strings.Add(guid.ToString());
                }
                return strings.ToArray();
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/FindMediaInstanceUrls.ashx";
            }
        }
    }

    public enum MediaUrlType : int
    {
        Video = 1,
        VideoChapter = 2,    // unsupported by XBOX client
        SAMI = 3,
        Image = 4,
        Music = 5,
        GameContent = 6
    }

    public class TypedMediaUrl : WireData
    {
        public int type;

        [WireInfo(Min = 1, Max = 500)]
        public uint length;

        [WireInfo(SizeParam = "length", NullTerminate = true)]
        public string url;
    }

    public class MediaInstanceUrl : WireData
    {
        [WireInfo(MinSchemaVersion = "4.1")]
        public Guid mediaId;

        public Guid mediaInstanceId;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong packageSize;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong installSize;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize = (int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize = (int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(MinSchemaVersion = "5.1")] // New in Summer 2009
        public uint packageType;

        [WireInfo(Max = 10)]
        public uint fileCount;

        [WireInfo(SizeParam = "fileCount")]
        public TypedMediaUrl[] urls;
    }
    /*  Soap Version
        [PayloadResponse("urn:schemas-xbox-com:billing-data", "FindMediaInstanceUrlsResponse")]
        public class FindMediaInstanceUrlsResponse : PayloadResponse
        {
            public uint mediaInstanceIdCount;

            [WireInfo(SizeParam = "mediaInstanceIdCount")]
            [PayloadParam("FindMediaInstanceUrlsResult")]
            public MediaInstanceUrl[] mediaInstanceUrls;
        }
     */

    [PayloadResponse("urn:schemas-xbox-com:billing-data", "ArrayOfMediaInstanceUrl")]
    public class FindMediaInstanceUrlsResponse : PayloadResponse
    {
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        [PayloadParam("/")]
        public MediaInstanceUrl[] mediaInstanceUrls;
    }


    public class OfferExpectedPrice : XRLObject2
    {
        public Guid offerId;
        public uint expectedPrice;
    }

    //used by web service version of PurchaseMediaOffers
    public class OfferMediaTypeExpectedPriceWS : XRLObject2
    {
        public Guid offerId;
        public int mediaTypeId;
        public uint expectedPrice;
    }

    //used by wired version PurchaseMediaOffers to support purchase content using currency
    public class OfferMediaTypeExpectedPrice : XRLObject2
    {
        public Guid offerId;
        public int mediaTypeId;

        public uint expectedPriceWhole;

        [WireInfo(MinSchemaVersion = "5.2")]
        public uint expectedPriceFractional;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "PurchaseOffers", "urn:schemas-xbox-com:billing-data")]
    public class PurchaseOffersRequest : PayloadRequestWithSSL
    {
        [PayloadParam("userPuid")]
        public ulong UserPuid;
        [PayloadParam("machinePuid")]
        public ulong MachinePuid;

        public uint OffersLength;

        [WireInfo(SizeParam = "OffersLength")]
        public OfferExpectedPrice[] Offers;

        [PayloadParam("paymentType")]
        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;

        [PayloadParam("paymentInstrumentId")]
        [WireInfo(SizeParam = "PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;
        public ushort BillingTokenLength;

        [PayloadParam("billingToken")]
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken;

        [PayloadParam("storeId")]
        public uint StoreId = 1;

        [PayloadParam("offerIds")]
        public string[] OfferIds
        {
            get
            {
                List<string> list = new List<string>(Offers.Length);
                foreach (OfferExpectedPrice oep in Offers)
                {
                    list.Add(oep.offerId.ToString());
                }
                return list.ToArray();
            }
        }

        [PayloadParam("expectedPrices")]
        public uint[] ExpectedPrices
        {
            get
            {
                List<uint> list = new List<uint>(Offers.Length);
                foreach (OfferExpectedPrice oep in Offers)
                {
                    list.Add(oep.expectedPrice);
                }
                return list.ToArray();
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseOffers.ashx";
            }
        }
    }


    public class XePurchaseMediaOffersRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam="offersLength")]
        public OfferMediaTypeExpectedPrice [] offers;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.3")]
        public uint storeId = 1;

        [WireInfo(MinSchemaVersion = "6.4")]
        public SubscriptionPurchaseInfo subscriptionPurchaseInfo = null;

        [WireInfo(MinSchemaVersion = "6.9")]
        public Guid trackingGuid = Guid.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseMediaOffers.ashx";
            }
        }
    }

    public class SubscriptionPurchaseInfo : XRLObject2
    {
        [WireInfo(MinSchemaVersion = "6.4")]
        public uint subscriptionTimeExtendedInMonths = 0;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "PurchaseMediaOffers", "urn:schemas-xbox-com:billing-data")]
    public class PurchaseMediaOffersRequest : PayloadRequestWithSSL
    {
        [PayloadParam("userPuid")]
        public ulong UserPuid;
        [PayloadParam("machinePuid")]
        public ulong MachinePuid;

        public uint OffersLength;

        [WireInfo(SizeParam = "OffersLength")]
        public OfferMediaTypeExpectedPriceWS[] Offers;

        [PayloadParam("paymentType")]
        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;

        [PayloadParam("paymentInstrumentId")]
        [WireInfo(SizeParam = "PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;
        public ushort BillingTokenLength;

        [PayloadParam("billingToken")]
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken;

        [PayloadParam("storeId")]
        public uint StoreId = 1;

        [PayloadParam("offerIds")]
        public string[] OfferIds
        {
            get
            {
                List<string> list = new List<string>(Offers.Length);
                foreach (OfferMediaTypeExpectedPriceWS oep in Offers)
                {
                    list.Add(oep.offerId.ToString());
                }
                return list.ToArray();
            }
        }

        [PayloadParam("mediaTypes")]
        public int[] MediaTypeIds
        {
            get
            {
                List<int> list = new List<int>(Offers.Length);
                foreach (OfferMediaTypeExpectedPriceWS omtep in Offers)
                {
                    list.Add(omtep.mediaTypeId);
                }
                return list.ToArray();
            }
        }

        [PayloadParam("expectedPrices")]
        public uint[] ExpectedPrices
        {
            get
            {
                List<uint> list = new List<uint>(Offers.Length);
                foreach (OfferMediaTypeExpectedPriceWS oep in Offers)
                {
                    list.Add(oep.expectedPrice);
                }
                return list.ToArray();
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseMediaOffers.ashx";
            }
        }
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "VerifyToken", "urn:schemas-xbox-com:billing-data")]
    public class VerifyTokenRequest : PayloadRequestWithSSL
    {
        [PayloadParam("userPuid")]
        public ulong UserPuid;

        [PayloadParam("machinePuid")]
        public ulong MachinePuid;

        [PayloadParam("billingToken")]
        public string BillingToken;

        [PayloadParam("storeId")]
        public int StoreId;

        public override string Xrl
        {
            get
            {
                return string.Empty;
            }
        }
    }

    public class XboxOfferInfo
    {
        public ulong offerId;
        public int offerTypeId;
    }

    public class EmsOfferInfo
    {
        public Guid offerId;
        public Guid mediaId;
        public int mediaType;
    }

    [PayloadResponse("urn:schemas-xbox-com:billing-data", "VerifyTokenResults")]
    public class VerifyTokenResults : PayloadResponse
    {
        [PayloadParam]
        public XboxOfferInfo xboxOfferInfo;

        [PayloadParam]
        public EmsOfferInfo emsOfferInfo;
    }

    public class XeVerifyTokenRequest : XRLRequestObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public uint storeId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeVerifyToken.ashx";
            }
        }
    }

    public class XeXboxOfferInfo : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeEmsOfferInfo : XRLObject2
    {
        public Guid offerId;

        public Guid mediaId;

        public uint mediaType;
    }

    public class XeVerifyTokenResponse : XRLObject2
    {
        public ushort offerCatalogType;

        public XeXboxOfferInfo xboxOfferInfo = null;

        public XeEmsOfferInfo emsOfferInfo = null;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "SubscriptionEnumerate", "")]
    public class WSSubscriptionEnumerateRequest : PayloadRequestWithSSL
    {
        [PayloadParam]
        public ulong userPuid;

        [PayloadParam]
        public ulong machinePuid;

        [PayloadParam]
        public    uint offerType;

        [PayloadParam]
        public    uint paymentType;

        [PayloadParam]
        public    uint titleId;

        [PayloadParam]
        public    bool queryForNew;

        [PayloadParam]
        public    bool queryForRenewals;

        [PayloadParam]
        public    bool queryForCurrent;

        [PayloadParam]
        public    bool queryForCancelled;

        [PayloadParam]
        public    bool queryForSuspended;

        public override string Xrl
        {
            get
            {
                return string.Empty;
            }
        }
    }

    [PayloadResponse("urn:schemas-xbox-com:billing-data", "SubscriptionEnumerateResults")]
    public class WSSubscriptionEnumerateResponse : PayloadResponse
    {
        [PayloadParam]
        public live.common.ws.SubscriptionInfo[] SubscriptionInfos;

        [PayloadParam]
        public int OffersTotal;
    }


    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xbos/billing.asmx", "PurchaseBillingOffer", "urn:schemas-xbox-com:billing-data")]
    public class PurchaseBillingOfferRequest : PayloadRequestWithSSL
    {
        [PayloadParam("userPuid")]
        public ulong UserPuid;

        [PayloadParam("machinePuid")]
        public ulong MachinePuid;

        [PayloadParam("offerId")]
        public ulong OfferId;

        [PayloadParam("paymentType")]
        public uint PaymentType;

        [PayloadParam("paymentInstrumentId")]
        public string PaymentInstrumentID;

        public ushort BillingTokenLength;

        [PayloadParam("billingToken")]
        public string BillingToken;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseBillingOffer.ashx";
            }
        }
    }

}

namespace live.protocol.next
{
    public class OfferExpectedPrice : XRLObject2
    {
        public Guid offerId;
        public uint expectedPrice;
    }

    public class OfferMediaTypeExpectedPrice : XRLObject2
    {
        public Guid offerId;
        public int mediaTypeId;
        public uint expectedPrice;
    }



    //
    //Billing XRL methods
    //
    public class XRLPurchaseOffersRequest : XRLRequestObject2
    {
        public ulong UserPuid;
        public ulong MachinePuid;

        public uint OffersLength;

        [WireInfo(SizeParam = "OffersLength")]
        public OfferExpectedPrice[] Offers;

        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;
        [WireInfo(SizeParam = "PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;
        public ushort BillingTokenLength;
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken;
        public uint StoreId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseOffers.ashx";
            }
        }
    }

    //
    // Billing Web Methods
    //

    public abstract class BillingWebRequest : WebRequestBase
    {
        public const string BILLING_BASE_URL = "/xbos/billing.asmx/";
        public const string HISTORY_BASE_URL = "/xbos/history.asmx/";
        public const string SUBSCRIPTION_BASE_URL = "/xbos/SubscriptionOfferEnumerate.asmx/";

        public static class BillingOperation
        {
            public static readonly string PurchaseOffers = "PurchaseOffers";
            public static readonly string PurchaseMediaOffers = "PurchaseMediaOffers";
            public static readonly string GetPurchaseStatus = "GetPurchaseStatus";
            public static readonly string Query = "Query";
            public static readonly string Execute = "Execute";
            public static readonly string VerifyToken = "VerifyToken";
            public static readonly string Enumerate = "Enumerate";
        }

        public static class HistoryMethed
        {
            public static readonly string PurchaseHistory = "PurchaseHistory";
            public static readonly string DownloadHistory = "DownloadHistory";
        }

        public List<StringPair> FilterPairs = null;

        public BillingWebRequest(string basePath, string operation)
            : base(basePath, operation)
        {
        }

        protected override string BuildHttpRequest(string seperator)
        {
            StringBuilder request = new StringBuilder(base.BuildHttpRequest(seperator));
            if (FilterPairs != null)
            {
                foreach (StringPair pair in FilterPairs)
                {
                    request.Append(seperator + pair.Key + "=" + pair.Value);
                }
            }
            return request.ToString();
        }

        public override string GetRelativeUrl()
        {
            string relativeUrl = "/" + _basePath + "/" + _operation;
            if (RequestType == WebRequestType.Get)
            {
                relativeUrl += ToQueryString();
            }
            return relativeUrl;
        }
    }

    // userPuid=string&machinePuid=string&ipAddress=string&offerIds=string&offerIds=string
    //  &expectedPrices=string&expectedPrices=string&paymentType=string
    //  &paymentInstrumentId=string&billingToken=string

    // userPuid=2600292942994909&machinePuid=0&ipAddress=&offerIds=System.Guid[]
    //  &expectedPrices=System.UInt32[]&paymentType=CreditCard
    //  &paymentInstrumentId=&billingToken=

    public class PurchaseOffersWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("ipAddress", WebRequestParamType.StandAlone)]
        public string IPAddress;
        [WebRequestParam("offerIds", WebRequestParamType.StandAlone)]
        public Guid[] OfferIds;
        [WebRequestParam("expectedPrices", WebRequestParamType.StandAlone)]
        public uint[] ExpectedPrices;
        [WebRequestParam("paymentType", WebRequestParamType.StandAlone)]
        public PaymentTypeEnum PaymentType;
        [WebRequestParam("paymentInstrumentId", WebRequestParamType.StandAlone)]
        public string PaymentInstrumentId;
        [WebRequestParam("billingToken", WebRequestParamType.StandAlone)]
        public string BillingToken;
        [WebRequestParam("storeId", WebRequestParamType.StandAlone)]
        public uint StoreId = 2;

        public PurchaseOffersWebRequest()
            : base(BILLING_BASE_URL, BillingOperation.PurchaseOffers)
        {
            this.UseSSL = true;
        }
    }

    public class PurchaseMediaOffersWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("offerIds", WebRequestParamType.StandAlone)]
        public string[] OfferIds;
        [WebRequestParam("mediaTypes", WebRequestParamType.StandAlone)]
        public int[] MediaTypeIds;
        [WebRequestParam("expectedPrices", WebRequestParamType.StandAlone)]
        public uint[] ExpectedPrices;
        [WebRequestParam("paymentType", WebRequestParamType.StandAlone)]
        public PaymentTypeEnum PaymentType;
        [WebRequestParam("paymentInstrumentId", WebRequestParamType.StandAlone)]
        public string PaymentInstrumentId;
        [WebRequestParam("billingToken", WebRequestParamType.StandAlone)]
        public string BillingToken;
        [WebRequestParam("storeId", WebRequestParamType.StandAlone)]
        public int StoreId = 2;

        public PurchaseMediaOffersWebRequest()
            : base(BILLING_BASE_URL, BillingOperation.PurchaseMediaOffers)
        {
            this.UseSSL = true;
        }
    }

    public class PurchaseHistoryWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("methodName", WebRequestParamType.StandAlone)]
        public string MethodName;
        public PurchaseHistoryWebRequest()
            : base(HISTORY_BASE_URL, BillingOperation.Query)
        {
            MethodName = HistoryMethed.PurchaseHistory;
            this.UseSSL = true;
        }

        public PurchaseHistoryWebRequest(ulong userPuid, ulong machinePuid, List<StringPair> filterList)
            : this()
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;
            FilterPairs = filterList;
        }
        
        public PurchaseHistoryWebRequest(ulong userPuid, ulong machinePuid, List<StringPair> filterList,string methodName)
            :this(userPuid,machinePuid,filterList)
        {
            MethodName = methodName;
        }
    }

    public class SubscriptionOfferEnumerateWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;

        [WebRequestParam("queryModifiers", WebRequestParamType.StandAlone)]
        public ulong QueryModifiers;


        public SubscriptionOfferEnumerateWebRequest()
            : base(SUBSCRIPTION_BASE_URL, BillingOperation.Enumerate)
        {
           this.UseSSL = true;
        }

        public SubscriptionOfferEnumerateWebRequest(ulong userPuid, ulong machinePuid,ulong queryModifiers,List<StringPair> filterList)
            : this()
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;
            QueryModifiers = queryModifiers;
            FilterPairs = filterList;
        }
    }


    public class DownloadHistoryWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;

        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;

        [WebRequestParam("methodName", WebRequestParamType.StandAlone)]
        public string MethodName;

        public DownloadHistoryWebRequest()
            : base(HISTORY_BASE_URL, BillingOperation.Query)
        {
            MethodName = HistoryMethed.DownloadHistory;
            this.UseSSL = true;
        }

        public DownloadHistoryWebRequest(ulong userPuid, ulong machinePuid, List<StringPair> filterList)
            : this()
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;
            FilterPairs = filterList;
        }
    }

    public class BillingWebResponse : WebResponseBase
    {
    }

    public class PurchaseOffersWebResponse : BillingWebResponse
    {
    }

    public class PurchaseMediaOffersWebResponse : BillingWebResponse
    {
    }

    public class SubscriptionOfferEnumerateWebResponse : BillingWebResponse
    {
    }

    public class PurchaseHistoryWebResponse : BillingWebResponse
    {
        public bool UseGZIP = false;
        
        public PurchaseHistoryWebResponse()
            : base()
        {}

        public PurchaseHistoryWebResponse(bool useGZIP)
            : base()
        {
            UseGZIP = useGZIP;
        }

        public override void ReadFromRequest(System.IO.BinaryReader reader, UTF8Encoding enc, long len, System.Collections.Specialized.NameValueCollection queryString)
        {
            if(UseGZIP)
            {
                byte[] respBytes = new byte[8192];
                int readLen = 0, currLen = 0;

                //unzip
                using(GZipStream gzipstream = new GZipStream(reader.BaseStream, CompressionMode.Decompress))
                {
                    MemoryStream memstream = new MemoryStream();

                    while((readLen = gzipstream.Read(respBytes, 0, 8192)) > 0)
                    {
                        memstream.Write(respBytes, currLen, readLen);
                        currLen += readLen;
                    }

                    memstream.Position = 0;
                    reader = new BinaryReader(memstream);
                    len = currLen;
                }
            }
            
            base.ReadFromRequest(reader, enc, len, queryString);
        }
        
    }

    public class DownloadHistoryWebResponse : BillingWebResponse
    {
    }

    /// <summary>
    /// Xrl request for Preview Product Purchase API
    /// </summary>
    public class XePreviewProductPurchaseRequest : XRLRequestObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam = "offersLength")]
        public OfferProductInfo[] offers;

        [WireInfo(HexString = true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam = "paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public uint storeId = 1;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = string.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }
    }

    /// <summary>
    /// Offer Product Info class
    /// </summary>
    public class OfferProductInfo : XRLObject2
    {
        public Guid offerId;

        public int productTypeId;
    }

    /// <summary>
    /// PreviewProduct purchase response
    /// </summary>
    public class XePreviewProductPurchaseResponse : XRLRequestObject2
    {
        public Guid offerId;

        public double offerPrice;
        

        public PreviewSubscriptionProductInfo previewSubscriptionInfo;

        public int taxTypeId;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }

    }

    public class PreviewSubscriptionProductInfo : XRLObject2
    {
        public Guid subscriptionId;

        public bool autoRenewal;

        public double nextChargeAmount;

        public DateTime nextChargeDate;

        public double netPrice;

        public double discount;

        public int timeExtendedinMonths;

        public Guid defaultRenewalOfferId = Guid.Empty;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\WebRequest.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Text;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using live.common;

namespace live.protocol.next
{
    public enum WebRequestParamType
    {
        StandAlone,
        NameValuePair
    }

    public enum Requirement
    {
        Required,
        Optional
    }

    public class WebRequestParamAttribute : Attribute
    {
        public string WireName;
        public WebRequestParamType ParamType;
        public Requirement Requirement;
        public string DefaultValue;

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = Requirement.Required;
            DefaultValue = null;
        }

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType,
            Requirement requirement)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = requirement;
            DefaultValue = null;
        }

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType,
            Requirement requirement, string defaultValue)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = requirement;
            DefaultValue = defaultValue;
        }
    }

    public class WebRequestMethodNameAttribute : Attribute
    {
        public string MethodName;

        public WebRequestMethodNameAttribute(string methodName)
        {
            MethodName = methodName;
        }
    }

    public class XmlNamespaceAttribute : Attribute
    {
        public string XmlNamespace;
        public string Prefix;

        public XmlNamespaceAttribute(string xmlNamespace)
        {
            XmlNamespace = xmlNamespace;
        }

        public XmlNamespaceAttribute(string prefix, string xmlNamespace)
        {
            Prefix = prefix;
            XmlNamespace = xmlNamespace;
        }
    }

    public class CustomWebRequest : WebRequestBase
    {
        private string _customRequest = null;
        public string CustomRequest
        {
            get
            {
                return _customRequest;
            }
            set
            {
                _customRequest = value;
            }
        }

        public CustomWebRequest(string basePath, string operation, string customRequest)
            : base(basePath, operation)
        {
            CustomRequest = customRequest;
        }

        protected override string BuildHttpRequest(string seperator)
        {
            METHOD.ENTER();
            METHOD.EXIT();
            return CustomRequest;
        }
    }

    public abstract class WebRequestBase : HttpRequestObject2
    {
        public enum WebRequestType
        {
            Get,
            Post,
            Soap1_1,
            Soap1_2
        }

        public static WebRequestType RequestType = WebRequestType.Post;
        public bool UseSSL = false;
        // We break a URL such as "http://ipaddr:port/xbos/billing.asmx/PurchaseHistory?..." into:
        // _basePath = "/xbos/billing.asmx/"    (required)
        // _operation = "PurchaseOffers"        (required)
        protected readonly string _basePath;
        protected readonly string _operation;

        protected WebRequestBase(string basePath, string operation)
        {
            _basePath = RemoveLeadingTrailingSlashes(basePath);
            _operation = RemoveLeadingTrailingSlashes(operation);
        }

        private string RemoveLeadingTrailingSlashes(string source)
        {
            int startIndex = 0;
            int length = source.Length;

            if (source.StartsWith("/"))
            {
                startIndex++;
                length--;
            }
            if (source.EndsWith("/"))
            {
                length--;
            }
            return source.Substring(startIndex, length);
        }

        public override string GetRelativeUrl()
        {
            string relativeUrl = "/" + _basePath + "/" + _operation;
            if (RequestType == WebRequestType.Get)
            {
                relativeUrl += ToQueryString();
            }
            return relativeUrl;
        }

        public override string GetHttpMethod()
        {
            switch (RequestType)
            {
                case WebRequestType.Get: return HttpMethod.Get;
                case WebRequestType.Post: return HttpMethod.Post;
                case WebRequestType.Soap1_1: return HttpMethod.Post;
                case WebRequestType.Soap1_2: return HttpMethod.Post;
                default: throw new Exception("Unknown FilterRequestType: " + RequestType);
            }
        }

        public void SetWebRequestType(WebRequestType requestType)   
        {
            RequestType = requestType;
        }

        public void SetWebHeaders(WebHeaderCollection headers)
        {
            switch (RequestType)
            {
                case WebRequestType.Get:
                    break;
                case WebRequestType.Post:
                    headers.Add("Content-Type", "application/x-www-form-urlencoded");
                    break;
                case WebRequestType.Soap1_1:
                    headers.Add("Content-Type", "text/xml; charset=utf-8");
                    break;
                case WebRequestType.Soap1_2:
                    headers.Add("Content-Type", "application/soap+xml; charset=utf-8");
                    break;
                default: throw new Exception("Unknown ContentType: " + RequestType);
            }
        }

        private static void WriteNameAndValue(List<StringPair> filterList, FieldInfo fieldInfo,
            WebRequestParamAttribute reqParam, string name, object fieldValue)
        {
            string value;
            if (fieldInfo.FieldType.IsEnum)
            {
                value = Enum.Format(fieldInfo.FieldType, Enum.Parse(
                    fieldInfo.FieldType, fieldValue.ToString()), "d");
            }
            else
            {
                value = String.Format("{0}", fieldValue);
            }

            // Stand-alone pairs are written out like: "ClientType=Zune"
            if (reqParam.ParamType == WebRequestParamType.StandAlone)
            {
                filterList.Add(new StringPair(name, value));
            }
            // NameValue pairs are written out like: "Names=Locale&Values=en-US"
            else if (reqParam.ParamType == WebRequestParamType.NameValuePair)
            {
                // If it's optional and set to the default value, don't bother writing it out
                if (reqParam.Requirement == Requirement.Optional)
                {
                    if (value == reqParam.DefaultValue)
                    {
                        return;
                    }
                }
                filterList.Add(new StringPair("Names", name));
                filterList.Add(new StringPair("Values", value));
            }
            else
            {
                throw new Exception("Unknown WebRequestParamType: " + reqParam.ParamType);
            }
        }

        public static List<StringPair> WebRequestToList(object webRequest)
        {
            List<StringPair> filterList = new List<StringPair>();

            Type thisType = webRequest.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo fieldInfo in fieldInfos)
            {
                object[] fieldAttrs = fieldInfo.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (fieldAttrs.Length == 0)
                {
                    // Ignore any field not marked with a WebRequestParam attribute
                    continue;
                }
                WebRequestParamAttribute reqParam = (WebRequestParamAttribute)fieldAttrs[0];
                string name = reqParam.WireName;
                object fieldValue = fieldInfo.GetValue(webRequest);

                if (fieldValue != null)
                {
                    // Crack open Lists and Arrays and write out their contents
                    Array array = null;
                    if (fieldInfo.FieldType.IsGenericType)
                    {
                        try
                        {
                            System.Reflection.MethodInfo toArrayMeth = fieldInfo.FieldType.GetMethod("ToArray");
                            array = (Array)toArrayMeth.Invoke(fieldValue, null);
                        }
                        catch {
                            array = null;
                        }
                    }
                    if (fieldInfo.FieldType.IsArray)
                    {
                        array = (Array)fieldValue;
                    }
                    if (array != null)
                    {
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= array.GetUpperBound(0); i++)
                        {
                            object elem = array.GetValue(i);
                            string value = String.Format("{0}", elem);

                            WriteNameAndValue(filterList, fieldInfo, reqParam, name, elem);
                        }
                    }
                    // If it's not an array, just add the property name and value
                    else
                    {
                        WriteNameAndValue(filterList, fieldInfo, reqParam, name, fieldValue);
                    }
                }
            }

            return filterList;
        }

        protected virtual string BuildHttpRequest(string seperator)
        {
            string request = "";
            List<StringPair> list = WebRequestBase.WebRequestToList(this);
            foreach (StringPair pair in list)
            {
                request += pair.Key + "=" + pair.Value + seperator;
            }
            if (request.EndsWith(seperator))
            {
                request = request.Remove(request.Length - 1);
            }
            return request;
        }

        public virtual string ToQueryString()
        {
            return "?" + BuildHttpRequest("&");
        }

        public virtual string ToPostBody()
        {
            return BuildHttpRequest("&");
        }

/*
<?xml version="1.0" encoding="utf-8"?>
<soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">
  <soap12:Body>
    <getPuidFromXName xmlns="http://xbox.com/xsuppapi/">
      <XName>string</XName>
    </getPuidFromXName>
  </soap12:Body>
</soap12:Envelope>
 */
        public virtual string ToSoap12Body()
        {
            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            System.Xml.XmlTextWriter xmlWriter = new System.Xml.XmlTextWriter(ms, Encoding.UTF8);
            //xmlWriter.Formatting = System.Xml.Formatting.Indented;

            xmlWriter.WriteStartDocument();

            // Write out the root element
            xmlWriter.WriteStartElement("soap12", "Envelope", "http://www.w3.org/2003/05/soap-envelope");
            xmlWriter.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
            xmlWriter.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");
            //xmlWriter.WriteAttributeString("xmlns", "soap12", null, "http://www.w3.org/2003/05/soap-envelope");
            xmlWriter.WriteStartElement("soap12", "Body", null);

            // Write out the protocol specific data
            WebRequestMethodNameAttribute methodNameAttr = (WebRequestMethodNameAttribute)
                Attribute.GetCustomAttribute(this.GetType(), typeof(WebRequestMethodNameAttribute));
            string methodName = methodNameAttr.MethodName;

            XmlNamespaceAttribute xmlNamespaceAttr = (XmlNamespaceAttribute)
                Attribute.GetCustomAttribute(this.GetType(), typeof(XmlNamespaceAttribute));
            string xmlNs = xmlNamespaceAttr.XmlNamespace;

            xmlWriter.WriteStartElement(methodName, xmlNs);
            List<StringPair> list = WebRequestBase.WebRequestToList(this);
            foreach (StringPair pair in list)
            {
                xmlWriter.WriteElementString(pair.Key, pair.Value);
            }
            xmlWriter.WriteEndElement();

            // Close the body and envelope
            xmlWriter.WriteEndElement();
            xmlWriter.WriteEndElement();

            xmlWriter.WriteEndDocument();
            xmlWriter.Flush();

            string results = System.Text.Encoding.UTF8.GetString(ms.GetBuffer()).TrimEnd(new char[] { '\0' });
            return results;
        }



        public override void WriteStream(System.IO.BinaryWriter binaryWriter)
        {
            METHOD.ENTER();

            switch (RequestType)
            {
                case WebRequestType.Get:
                    break;
                case WebRequestType.Post:
                    binaryWriter.Write(Encoding.UTF8.GetBytes(ToPostBody()));
                    break;
                case WebRequestType.Soap1_2:
                    binaryWriter.Write(Encoding.UTF8.GetBytes(ToSoap12Body()));
                    break;
                default:
                    throw new Exception("WriteStream doesn't support FilterRequestType: " + RequestType);
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\xCryptoProtocol.cs ===
/*==========================================================================
 *
 *  xCryptoProtocol.cs -- This module defines the wire protocol for 
 *                          xCrypto server
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Caching;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

using live.common;

namespace live.protocol
{
    //public class XCryptoRequestBase : XRLObject2
    //{
    //    public uint containerClass;
    //}

    public class XCryptoData : WireData
    {
        [WireInfo(Min = 1)]
        public uint dataLength;

        [WireInfo(SizeParam = "dataLength")]
        public byte[] data;

        public XCryptoData ()
        {
        }

        public XCryptoData(byte[] data)
            : this(data, data.Length)
        {
        }
        public XCryptoData ( byte[] data, int dataLength )
        {
            this.data = data;
            this.dataLength = (uint)dataLength;
        }
    }

    public class XCryptoSignRequest : XRLRequestObject2
    {
        public XCryptoData sha1;

        public override string Xrl { get { return "/xcrypto/XCryptoSign.ashx"; } }
    }

    public class XCryptoSignResponse : XRLObject2
    {
        public XCryptoData sig;
    }


    public class XCryptoVerifySignatureRequest : XRLRequestObject2
    {
        public XCryptoData sha1;

        public XCryptoData sig;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifySignature.ashx"; } }
    }

    public class XCryptoVerifySignatureResponse : XRLObject2
    {
        public bool verified;
    }


    //============================
    // Carbon PAK Verification
    //============================
    public class XCryptoVerifyConsolePakRequest : XRLRequestObject2
    {
        public const int DATA_SIZE = 16;

        public UInt64 consoleId;

        public XCryptoData clear;

        public XCryptoData pakEncrypted;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifyConsolePak.ashx"; } }
    }

    public class XCryptoVerifyConsolePakResponse : XRLObject2
    {
        public bool verified;
    }
    public class XCryptoDecryptRequest : XRLRequestObject2
    {
        public XCryptoData cipher;

        public override string Xrl { get { return "/xcrypto/XCryptoDecrypt.ashx"; } }
    }

    public class XCryptoDecryptResponse : XRLObject2
    {
        public XCryptoData clear;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\WebResponse.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace live.protocol.next
{
    public class WebResponseParamAttribute : Attribute
    {
        public string XPath;
        public string Prefix;
        public string XmlNamespace;

        public WebResponseParamAttribute(string xPath, string prefix, string xmlNamespace)
        {
            XPath = xPath;
            Prefix = prefix;
            XmlNamespace = xmlNamespace;
        }
    }

    public abstract class WebResponseBase : XRLObject2
    {
        public string Response;

        public override void ReadFromRequest(System.IO.BinaryReader reader, UTF8Encoding enc, long len, System.Collections.Specialized.NameValueCollection queryString)
        {
            byte[] resp = reader.ReadBytes((int)len);
            Response = enc.GetString(resp);

            ReadFromRequest(Response);
        }

        public virtual void ReadFromRequest(string response)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(response);

            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo fieldInfo in fieldInfos)
            {
                // Get the WebResponseParamAttribute (if any)
                object[] fieldAttrs = fieldInfo.GetCustomAttributes(typeof(WebResponseParamAttribute), true);
                if (fieldAttrs.Length == 0)
                {
                    // Ignore any field not marked with a WebResponseParam attribute
                    continue;
                }
                WebResponseParamAttribute respParam = (WebResponseParamAttribute)fieldAttrs[0];
                string xpath = respParam.XPath;

                XmlNamespaceManager nsMgr = new XmlNamespaceManager(xmlDoc.NameTable);
                nsMgr.AddNamespace(respParam.Prefix, respParam.XmlNamespace);

                XmlNode targetNode = xmlDoc.SelectSingleNode(xpath, nsMgr);
                object val = Convert.ChangeType(targetNode.InnerText, fieldInfo.FieldType);
                fieldInfo.SetValue(this, val);
            }
        }

        public override string ToString()
        {
            return Response;
        }
    }

    // If you don't have/need a well-defined response class, this class serves as a generic
    // container for any response the server returns
    public class XmlWebResponse : WebResponseBase
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\XOnWebClient.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

using live.common;

namespace live.protocol
{
    public enum FDTransmitState
    {
        Connecting,
        Sending,
        Receiving,
        Completed
    };

    // Maintains the context of the async Transmit call
    public class FDTransmitContext : IAsyncResult
    {
        private ManualResetEvent transmitCompletedEvent = null;

        public FDWebClient WebClient = null;

        private TcpClient client = null;
        private AsyncCallback callback = null;
        private Object context = null;
        private byte state = (byte)FDTransmitState.Connecting;

        // Input variables to Transmit
        public IXOnSecurityProvider SecProv = null;
        public XOService Service;
        public Uri Uri = null;
        public string Method = String.Empty;
        public byte[] RequestData = null;
        
        // Scratch variables - Needed in the process of
        // sending and receiving data
        public NetworkStream NetStream = null;
        public int TotalBytesRead = 0;
        public int Offset = 0;
        public Dictionary<string, string> Headers = null;
        public int EohIndex = -1;
        public int ContentLength = -1;
        public byte[] ReceiveBuffer = null;
        public byte[] ResponseData = null;
        public Exception Exception = null;

        public FDTransmitContext(FDWebClient webClient,
                                 TcpClient client,
                                 IXOnSecurityProvider secProv,
                                 XOService service,
                                 Uri uri,
                                 string method,
                                 byte[] requestData,
                                 AsyncCallback callback,
                                 Object context)
        {
            this.WebClient = webClient;
            this.client = client;
            
            // Store all the input parameters of the Transmit call
            this.SecProv = secProv;
            this.Service = service;
            this.Uri = uri;
            this.Method = method;
            this.RequestData = requestData;
            
            this.callback = callback;
            this.context = context;
        }
 
        public TcpClient Client
        {
            get
            {
                return client;
            }
        }

        public byte State
        {
            get
            {
                return state;
            }
        }

        // We are done. Complete the request
        public void CompleteRequest()
        {
            state = (byte)FDTransmitState.Completed;

            if (transmitCompletedEvent != null)
            {
                transmitCompletedEvent.Set();
            }
            
            // Call the callback if there is one
            if (callback != null)
            {
                this.callback(this);
            }
        }

        public void NextState()
        {            
            if (state != (byte)FDTransmitState.Completed)
            {
                state++;
            }

            if (state == (byte)FDTransmitState.Completed)
            {
                CompleteRequest();
            }
        }
        
        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
            {
                return context;
            }
        }
        
        public bool CompletedSynchronously
        {
            get
            {
                return(false);
            }
        }

        public bool IsCompleted
        {
            get
            {
                return (Thread.VolatileRead(ref state) == 
                        (byte)FDTransmitState.Completed);
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            { 
                if (transmitCompletedEvent == null)
                {
                    bool done = IsCompleted;
                    ManualResetEvent mre = new ManualResetEvent(done);

                    if (Interlocked.CompareExchange(
                            ref transmitCompletedEvent, mre, null) != null)
                    {
                        // Another thread created this event
                        mre.Close();
                    }
                    else
                    {
                        if (!done && IsCompleted)
                        {
                            // If the operation wasn't done when we created
                            // the event but is now
                            transmitCompletedEvent.Set();
                        }

                    }                    
                }

                return transmitCompletedEvent;
            }
        }
    }

    public class FDWebClient
    {
        private const int c_recvBufferSize = 4096;
        private const string c_headerSeperator = "\r\n";

        private static byte[] _emptyByteArray = new byte[0];
        private static byte[] _trash = new byte[128];
        private byte[] _recvBuffer = new byte[c_recvBufferSize];
        private string _sentHeaders;

        public int ReceiveTimeout = 120000;
        public int SendTimeout = 120000;

        WebHeaderCollection _headers = new WebHeaderCollection();
        public WebHeaderCollection Headers
        {
            get
            {
                return _headers;
            }
            set
            {
                _headers = value;
            }
        }

        WebHeaderCollection _responseHeaders = new WebHeaderCollection();
        public WebHeaderCollection ResponseHeaders
        {
            get
            {
                return _responseHeaders;
            }
            set
            {
                _responseHeaders = value;
            }
        }

        private void SendWebRequest(TcpClient tcpClient, Uri destUri, string method, byte[] requestData)
        {
            NetworkStream netstream = tcpClient.GetStream();

            string reqHeader = method + " " + destUri.PathAndQuery + " HTTP/1.1\r\n";
            reqHeader += "Host: " + destUri.Host + "\r\n";
            reqHeader += "Content-Length: " + requestData.Length + "\r\n";
            byte[] reqHeaderBytes = Encoding.ASCII.GetBytes(reqHeader);
            byte[] messageHeaderBytes = _headers.ToByteArray();
            _sentHeaders = reqHeader + Encoding.UTF8.GetString(messageHeaderBytes);
            byte[] message = new byte[reqHeaderBytes.Length + messageHeaderBytes.Length + requestData.Length];
            reqHeaderBytes.CopyTo(message, 0);
            messageHeaderBytes.CopyTo(message, reqHeaderBytes.Length);
            requestData.CopyTo(message, reqHeaderBytes.Length + messageHeaderBytes.Length);
            
            netstream.Write(message, 0, message.Length);
        }

        private byte[] ReceiveWebResponse(TcpClient tcpClient, out int totalBytesRead)
        {
            NetworkStream netstream = tcpClient.GetStream();
            byte[] responseData = null;

            totalBytesRead = 0;
            int offset = 0;
            int eohIndex = -1;
            int contentLength = -1;
            bool done = false;
            Dictionary<string, string> headers = null;
            do
            {
                // Get the data
                int bytesRead = netstream.Read(_recvBuffer, 0, c_recvBufferSize);
                totalBytesRead += bytesRead;

                // Prepare the response buffer
                if (responseData == null)
                {
                    responseData = new byte[totalBytesRead];
                }

                // Grow the response buffer
                if (bytesRead > responseData.Length - offset)
                {
                    byte[] newResponseData = new byte[responseData.Length + bytesRead];
                    responseData.CopyTo(newResponseData, 0);
                    responseData = newResponseData;
                }

                // Copy the data in from the response buffer
                Array.Copy(_recvBuffer, 0, responseData, offset, bytesRead);
                offset += bytesRead;

                // Check if we've got a full header yet
                if (eohIndex == -1)
                {
                    eohIndex = GetEndOfHeaderIndex(responseData);
                }
                // If we've got a full header...
                if (eohIndex != -1)
                {
                    // Check if we've got all the data
                    if (contentLength == -1)
                    {
                        headers = GetHeaders(responseData);
                        if (headers != null)
                        {
                            string xerr;
                            if (!headers.TryGetValue("X-Err", out xerr))
                            {
                                string contentLengthValue = headers["Content-Length"];
                                {
                                    contentLength = Int32.Parse(contentLengthValue);
                                    Logging.WriteLine("ReceiveWebResponse: Content-Length == " +
                                        contentLength, "PROTOCOL");
                                }
                            }
                            else
                            {
                                // X-Err found, bailing
                                done = true;
                            }
                        }
                    }
                }
                if (totalBytesRead == eohIndex + 1 + contentLength)
                {
                    done = true;
                }
            } while (!done);

            // throw Web exception if get 4xx and 5xx http error and there is NOT X-Err header
            if (headers != null && headers.ContainsKey("Content-Type") 
                && headers["Content-Type"] == "text/html" && !headers.ContainsKey("X-Err"))
            {
                string textResponse = Encoding.UTF8.GetString(responseData);
                string errorcodeText = textResponse.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[1];
                int errorcode = int.Parse(errorcodeText);
                if (errorcode >= 400 && errorcode <= 599)
                {
                    int index = textResponse.IndexOf("\r\n\r\n");
                    if (index > -1)
                    {
                        textResponse = textResponse.Substring(index + 4);
                    }
                    throw new WebException("Got a http response of " + errorcodeText + "\n" + textResponse);

                }
            }

            Logging.WriteLine("ReceiveWebResponse: totalBytesRead == " + totalBytesRead, "PROTOCOL");
            return responseData;
        }

        private static int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (-1 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public Dictionary<string, string> GetHeaders(byte[] responseData)
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string, string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    if(!headerDict.ContainsKey(parts[0].Trim()))
                    {
                        headerDict.Add(parts[0].Trim(), parts[1].Trim());
                    }
                }
            }
            return headerDict;
        }

        private byte[] ProcessWebResponse(byte[] responseData, int totalBytesRead)
        {
            Debug.Assert(responseData != null);
            Debug.Assert(totalBytesRead > 0);

            string responseHeaders = GetHeaderString(responseData);
            if (responseHeaders != "")
            {
                string[] headers = responseHeaders.Split(c_headerSeperator.ToCharArray());
                foreach (string header in headers)
                {
                    if (header.StartsWith("HTTP/1.1 "))
                    {
                        continue;
                    }
                    if (header.Trim() == "")
                    {
                        continue;
                    }
                    _responseHeaders.Add(header);
                }
            }

            int startOfBody = GetEndOfHeaderIndex(responseData) + 1;
            int responseBodySize = totalBytesRead - startOfBody;
            byte[] responseBody;
            if (responseBodySize > 0)
            {
                responseBody = new byte[responseBodySize];
                for (int i = 0; i < responseBodySize; i++)
                {
                    responseBody[i] = responseData[startOfBody + i];
                }
            }
            else
            {
                responseBody = null;
            }

            return responseBody;
        }

        private static void ShutdownAndClose(TcpClient tcpClient)
        {
            NetworkStream netstream = tcpClient.GetStream();
            Socket socket = tcpClient.Client;

            // Send and receive should be shutdown independently of each other
            if (socket.Connected)
            {
                // Do a half-close on the underlying socket
                socket.Shutdown(SocketShutdown.Send);

                while (socket.Receive(_trash) > 0)
                {
                }
            }

            // KB821625
            socket.Close();
            netstream.Close();
            tcpClient.Close();
        }

        private byte[] Transmit(
            IXOnSecurityProvider secProv,
            XOService service,
            string address,
            string method,
            byte[] requestData)
        {
            // Connect to the remote host
            Uri uri = new Uri(address);
            TcpClient tcpClient = new TcpClient(uri.Host, uri.Port);
            tcpClient.ReceiveTimeout = ReceiveTimeout;
            tcpClient.SendTimeout = SendTimeout;
            tcpClient.Client.LingerState.Enabled = false;

            secProv.SetAuthentication(
                service,
                (IPEndPoint)tcpClient.Client.LocalEndPoint,
                (IPEndPoint)tcpClient.Client.RemoteEndPoint,
                _headers);

            // Send the HTTP request
            SendWebRequest(tcpClient, uri, method, requestData);

            // Receive and parse the response, if any
            int totalBytesRead;
            byte[] responseData = ReceiveWebResponse(tcpClient, out totalBytesRead);
            byte[] responseBody = ProcessWebResponse(responseData, totalBytesRead);

            // Clean-up after ourselves
            ShutdownAndClose(tcpClient);

            return responseBody;
        }

        public byte[] UploadData(
            IXOnSecurityProvider secProv, 
            XOService service, 
            string address, 
            string method, 
            byte[] requestData)
        {
            if (method.ToUpper() == HttpMethod.Get)
            {
                throw new System.Net.WebException("Cannot send a content-body with this verb-type.");
            }

            return Transmit(secProv, service, address, method, requestData);
        }

        public byte[] DownloadData(
            IXOnSecurityProvider secProv,
            XOService service,
            string address)
        {
            return Transmit(secProv, service, address, HttpMethod.Get, _emptyByteArray);
        }

        // Async methods

        // Go through all the individual asynchronous steps in Transmit
        private void HandleTransmitCallback(IAsyncResult result)
        {
            FDTransmitContext context = (FDTransmitContext)result.AsyncState;

            TcpClient tcpClient = context.Client;
            
            // Handle the callback based on the state
            switch (context.State)
            {
                case (byte)FDTransmitState.Connecting:
                {
                    // Connection is done
                    try
                    {
                        tcpClient.EndConnect(result);
                    }
                    catch (Exception e)
                    {
                        context.Exception = e;
                        context.CompleteRequest();
                        break;
                    } 
                    
                    // Move to the next state
                    context.NextState();
                    
                    tcpClient.ReceiveTimeout = ReceiveTimeout;
                    tcpClient.SendTimeout = SendTimeout;
                    tcpClient.Client.LingerState.Enabled = false;
                    
                    context.SecProv.SetAuthentication(
                        context.Service,
                        (IPEndPoint)tcpClient.Client.LocalEndPoint,
                        (IPEndPoint)tcpClient.Client.RemoteEndPoint,
                        _headers);                
                
                    // Send the data
                    NetworkStream netstream = tcpClient.GetStream();
                                                                
                    string reqHeader = context.Method + " " 
                        + context.Uri.PathAndQuery + " HTTP/1.1\r\n";

                    reqHeader += "Host: " + context.Uri.Host + "\r\n";
                    reqHeader += "Content-Length: " + 
                        context.RequestData.Length 
                        + "\r\n";
                    byte[] reqHeaderBytes = Encoding.ASCII.GetBytes(reqHeader);
                    byte[] messageHeaderBytes = _headers.ToByteArray();
                    _sentHeaders = reqHeader + 
                        Encoding.UTF8.GetString(messageHeaderBytes);
                    byte[] message = new byte[reqHeaderBytes.Length + 
                                              messageHeaderBytes.Length + 
                                              context.RequestData.Length];
                    
                    reqHeaderBytes.CopyTo(message, 0);
                    messageHeaderBytes.CopyTo(message, reqHeaderBytes.Length);
                    context.RequestData.CopyTo(message, 
                                               reqHeaderBytes.Length + 
                                               messageHeaderBytes.Length);

                    netstream.BeginWrite(message, 
                                         0, 
                                         message.Length,
                                         new AsyncCallback(
                                             HandleTransmitCallback),
                                         context);
                    
                    break;
                }
                
                case (byte)FDTransmitState.Sending:
                {
                    // Data Send is done
                    NetworkStream netstream = tcpClient.GetStream();
                    
                    try
                    {
                        netstream.EndWrite(result);
                    }
                    catch (Exception e)
                    {
                        context.Exception = e;
                        context.CompleteRequest();
                        break; 
                    } 
                    
                    // Move to the next state
                    context.NextState();
                    
                    // Do the Receive
                    context.TotalBytesRead = 0;
                    context.ReceiveBuffer = new byte[c_recvBufferSize];
                    netstream.BeginRead(context.ReceiveBuffer,
                                        0,
                                        c_recvBufferSize,
                                        new AsyncCallback(
                                            HandleTransmitCallback),
                                        context);
                                        
                    break;
                }
                
                case (byte)FDTransmitState.Receiving:
                {
                    bool done = false;                                        
                    NetworkStream netstream = tcpClient.GetStream();
                    int bytesRead = 0;
                    
                    try
                    {
                        bytesRead = netstream.EndRead(result);
                    }
                    catch (Exception e)
                    {
                        context.Exception = e;
                        context.CompleteRequest();
                        break;
                    } 

                    context.TotalBytesRead += bytesRead;
                    if (context.ResponseData == null)
                    {
                        context.ResponseData = 
                            new byte[context.TotalBytesRead];
                    }

                    // Grow the response buffer if needed
                    if (bytesRead > (context.ResponseData.Length - 
                                     context.Offset))
                    {
                        byte[] newResponseData = 
                            new byte[context.ResponseData.Length + bytesRead];
                        context.ResponseData.CopyTo(newResponseData, 0);
                        context.ResponseData = newResponseData;
                    }
                                 
                    // Copy the data in from the response buffer
                    Array.Copy(context.ReceiveBuffer, 
                               0, 
                               context.ResponseData, 
                               context.Offset, 
                               bytesRead);
                
                    context.Offset += bytesRead;

                    // Check if we've got a full header yet
                    if (context.EohIndex == -1)
                    {
                        context.EohIndex = 
                            GetEndOfHeaderIndex(context.ResponseData);
                    }
                    
                    // If we've got a full header...
                    if (context.EohIndex != -1)
                    {
                        // Check if we've got all the data
                        if (context.ContentLength == -1)
                        {
                            context.Headers = GetHeaders(context.ResponseData);
                            if (context.Headers != null)
                            {
                                string xerr;
                                if (!context.Headers.TryGetValue(
                                        "X-Err", out xerr))
                                {
                                    string contentLengthValue = 
                                        context.Headers["Content-Length"];
                                    
                                    context.ContentLength = Int32.Parse(
                                        contentLengthValue);
                                    
                                    Logging.WriteLine(
                                        "ReceiveWebResponse: " + 
                                        "Content-Length == " +
                                        context.ContentLength, "PROTOCOL");
                                }
                                else
                                {
                                    // X-Err found, bailing
                                    done = true;
                                }
                            }
                        }
                    }
                    if (context.TotalBytesRead == 
                        context.EohIndex + 1 + context.ContentLength)
                    {
                        done = true;
                    }
                    
                    if (!done)
                    {
                        // We are not done receiving. Receive more data
                        // without changing the current state
                        netstream.BeginRead(context.ReceiveBuffer,
                                            0,
                                            c_recvBufferSize,
                                            new AsyncCallback(
                                                HandleTransmitCallback),
                                            context);                        
                    }
                    else
                    {
                        // We are done receiving. Close the connection
                        ShutdownAndClose(tcpClient);

                        // Move to Completed state. This will fire the
                        // async wait handle and the callbacks
                        context.NextState();
                    }

                    break;
                }                
            }           
        }

        public IAsyncResult BeginTransmit(
            IXOnSecurityProvider secProv,
            XOService service,
            string address,
            string method,
            byte[] requestData,
            AsyncCallback callback,
            Object state)
        {
            Uri uri = new Uri(address);
            TcpClient tcpClient = new TcpClient();
            
            IAsyncResult result = new FDTransmitContext(this,
                                                        tcpClient,
                                                        secProv,
                                                        service,
                                                        uri,
                                                        method,
                                                        requestData,
                                                        callback,
                                                        state);

            // Start off the first step of Transmit
            // and do the rest of the steps as callbacks
            
            // Connect to the remote host
            tcpClient.BeginConnect(uri.Host, 
                                   uri.Port, 
                                   new AsyncCallback(HandleTransmitCallback),
                                   result);

            // Return the IAsyncResult which will track the 
            // completeion of the complete sequence
            return result;
        }
        
        public byte[] EndTransmit(IAsyncResult result)
        {
            // Wait for the operaion to complete if it has not already
            if (!result.IsCompleted)
            {
                result.AsyncWaitHandle.WaitOne();
                result.AsyncWaitHandle.Close();
            }
            
            FDTransmitContext context = (FDTransmitContext)result;

            // Throw any exceptions thatheppened during processing
            if (context.Exception != null)
            {
                throw context.Exception;
            }
            

            // Check headers for errors
            if (context.Headers != null &&
                context.Headers.ContainsKey("Content-Type") &&
                context.Headers["Content-Type"] == "text/html" &&
                !context.Headers.ContainsKey("X-Err"))
            {
                string textResponse =
                    Encoding.UTF8.GetString(context.ResponseData);

                string errorcodeText =
                    textResponse.Split(
                        new char[] { ' ' },
                        StringSplitOptions.RemoveEmptyEntries)[1];

                int errorcode = int.Parse(errorcodeText);
                if (errorcode >= 400 && errorcode <= 599)
                {
                    int index = textResponse.IndexOf("\r\n\r\n");
                    if (index > -1)
                    {
                        textResponse = textResponse.Substring(index + 4);
                    }

                    throw new WebException("Got a http response of " +
                                           errorcodeText + "\n" + textResponse);
                }
            }

            byte[] responseBody = ProcessWebResponse(context.ResponseData, 
                                                     context.TotalBytesRead);
            
            return responseBody;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\XRLException.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Web;
using System.Collections;

using live.common;

namespace live.common
{
    [ComVisible(false)]
    public class ExceptionWithoutEvent : Exception
    {
        public ExceptionWithoutEvent(string message) : base(message)
        {
        }

        public ExceptionWithoutEvent(string message, Exception innerException) : base(message, innerException)
        {
        }
    }

    [ComVisible(false)]
    public class ExceptionWithEventId : Exception
    {
        public ExceptionWithEventId(string message) : base(message)
        {
        }

        public ExceptionWithEventId(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public void AppendInfo(string str)
        {
            _info.Append(str + "\n");
        }

        public override string ToString()
        {
            return base.ToString() + "\nInfo:\n" + _info;
        }

        protected StringBuilder _info = new StringBuilder();
    }

    [ComVisible(false)]
    public class XRLException : ExceptionWithEventId
    {
        uint _hresult = live.common.HResult.E_FAIL;

        public XRLException(uint hr, string message)
            : base(message)
        {
            _hresult = hr;
        }

        public XRLException(uint hr, string message, Exception innerException)
            : base(message, innerException)
        {
            _hresult = hr;
        }

        new public uint HResult
        {
            get { return _hresult; }
            set { _hresult = value; }
        }

        public static uint ToHResult(Exception e)
        {
            uint hr = live.common.HResult.XONLINE_E_SERVER_ERROR;

            if (e is XRLException)
            {
                hr = ((XRLException)e).HResult;
            }

            return hr;
        }

        public override string Message
        {
            get
            {
                return base.Message + "; HResult=" + HResult.ToString("X8");
            }
        }
    }


    //Here is an exception that we would only use to communicate a peek char returning no value
    //This exception ususally would be caught and ignored
    public class PeekCharEndOfStreamException : Exception
    {
        public PeekCharEndOfStreamException() : base()
        {
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\AffiliateState.cs ===
using System;
using System.Threading;
using System.Collections;
using live.common;

namespace live.protocol.Presence
{

	[Flags]
	public enum AffiliateFlags : uint {
		// Actual Affiliate Lists
		Encountered      = 0x00000001, 
		CompletedGame    = 0x00000002,
		PositiveFeedback = 0x00000004,
		NegativeFeedback = 0x00000008,
		AvoidingMe       = 0x00000010,
        Favorites        = 0x00000020,
		// Emulated Affiliate Lists
		Friend           = 0x00010000, 
		Block            = 0x00020000, 
		Mute             = 0x00040000, 
		Any              = 0xffffffff
	}
	
	// Affiliate state tracks affialiation for a given user. This is 
	// a heavy class but intended to be used across tests to do deep validation
	// of affiliation records
	public class AffiliateState
	{
        static uint[] MaxAffiliates = {
            100,    // encountered
            500,    // completed game
            500,    // positive feedback
            500,    // negative feedback
            500,    // avoiding me
            100     // favorites
        };

		//
		// One item indexed into multiple hash tables based on the 
		// loaded or populated Add() calls
		//
		public class AffiliateHashItem
		{
			void ClearMembers()
			{
				User         = null;
				AffiliateId  = 0;
				ListFlags    = 0;
				TitleId      = 0;
				SessionId    = 0;
				DateUpdated  = 0;
				GamerTag     = null;
			}

			public AffiliateHashItem()
			{
				ClearMembers();
			}

			public AffiliateHashItem(PNState user)
			{
				ClearMembers();
				User = user;
				if(null != User.Xbox)
				{
					TitleId = User.Xbox.TitleId;
				}

				SessionId = User.MatchSessionId;
				GamerTag = User.Name;
				AffiliateId = User.UserId;
			}

			public AffiliateHashItem(PNState user, QueryAffiliatesReplyData replyData)
			{
				this.User 		= user;
				AffiliateId 	= replyData.qwAffiliateID;
				ListFlags 	    = replyData.dwListFlags;
				TitleId 		= replyData.dwTitleID;
				SessionId 	    = replyData.qwSessionID;
				DateUpdated 	= replyData.mtDateUpdated;
				GamerTag 		= replyData.szGamerTag;
			}

			public PNState	User;
			public ulong 	AffiliateId;
			public uint 	ListFlags;
			public uint 	TitleId;
			public ulong 	SessionId;
			public uint 	DateUpdated;
			public string 	GamerTag;
		}

		PNState _Owner;
		public Hashtable _Unknown;            // Should not be in any affiliate list
		public Hashtable _All;                // All affiliations stored (the master list)
		public Hashtable _Encountered;        // Was Encountered
		public Hashtable _CompletedGame;      // Was Preferred player
		public Hashtable _PositiveFeedback;   // Feedback Server: Positive
		public Hashtable _NegativeFeedback;   // Feedback Server: Negative
		//public Hashtable _AvoidingMe;         // Feedback Server: Negative (reverse assoc)
        public Hashtable _Favorites;          // Favorites List 

		bool _Initialized;

        public AffiliateState Clone()
        {
            if (!_Initialized) return null;
            AffiliateState newState = new AffiliateState(_Owner);
            newState._Unknown = (Hashtable)_Unknown.Clone();
            newState._All = (Hashtable)_All.Clone();
            newState._Encountered = (Hashtable)_Encountered.Clone();
            newState._CompletedGame = (Hashtable)_CompletedGame.Clone();
            newState._PositiveFeedback = (Hashtable)_PositiveFeedback.Clone();
            newState._NegativeFeedback = (Hashtable)_NegativeFeedback.Clone();
            newState._Favorites = (Hashtable)_Favorites.Clone();
            return newState;
        }

		void AddToHash(Hashtable table, PNState [] list, uint flags, uint titleId, uint MaxEntries)
		{
			foreach(PNState u in list) 
			{
				// First ensure that the hash item is in the global index, notify
				// the test client if the flags or title ID is changing.
				AffiliateHashItem hashItem = _All[u.UserId] as AffiliateHashItem;
				if(null != hashItem)
				{
					uint preFlags = hashItem.ListFlags;
					uint preTitleId = hashItem.TitleId;

					hashItem.ListFlags |= flags;
					hashItem.TitleId = titleId;

					if(hashItem.ListFlags != preFlags)
					{
						System.Diagnostics.Debug.WriteLine(String.Format("AddToHash(): Modifying HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}", 
								u.UserId, preFlags, hashItem.ListFlags));
					}
					if(hashItem.TitleId != preTitleId)
					{
						System.Diagnostics.Debug.WriteLine(String.Format("AddToHash(): Modifying HashItem[{0:x}].TitleId: {1:x8}->{2:x8}", 
								u.UserId, preTitleId, hashItem.TitleId));
					}
				}
				else
				{
					hashItem = new AffiliateHashItem(u);
					hashItem.ListFlags = flags;
					hashItem.TitleId = titleId;
                    hashItem.DateUpdated = GetDateUpdated(table);
					_All[u.UserId] = hashItem;
				}

				// Index the new or existing hash item into the request hash table
                if (table.Count == MaxEntries)
                {
                    RemoveOldestFromHash(table, flags);
                }
				table[u.UserId] = hashItem;
			}
		}

        uint GetDateUpdated(Hashtable table)
        {
            if (table.Count == 0)
                return 0;

            AffiliateHashItem hi = null;
            foreach (AffiliateHashItem hashItem in table.Values)
            {
                if (hi == null)
                {
                    hi = hashItem;
                    continue;
                }
                if (hi.DateUpdated < hashItem.DateUpdated)
                {
                    hi = hashItem;
                }
            }
            return hi.DateUpdated + 1;
        }

        void RemoveOldestFromHash(Hashtable table, uint flags)
        {
            if(table.Count == 0)
                return;

            AffiliateHashItem hi = null;
            foreach(AffiliateHashItem hashItem in table.Values)
            {
                if (hi == null)
                {
                    hi = hashItem;
                    continue;
                }
                if (hi.DateUpdated > hashItem.DateUpdated)
                {
                    hi = hashItem;
                }
            }
            RemoveFromHash(table, hi.AffiliateId, flags);
        }

        void RemoveFromHash(Hashtable table, ulong UserId, uint flags)
        {
            AffiliateHashItem hashItem = _All[UserId] as AffiliateHashItem;
            if (null != hashItem)
            {
                uint preFlags = hashItem.ListFlags;
                hashItem.ListFlags &= ~flags;
                System.Diagnostics.Debug.WriteLine(String.Format("RemoveFromHash(): HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}",
                        UserId, preFlags, hashItem.ListFlags));
            }
            else
            {
                System.Diagnostics.Debug.WriteLine(String.Format("RemoveFromHash() on non-hashed user: {0:x}", UserId));
            }

            table.Remove(UserId);
        }

		void RemoveFromHash(Hashtable table, PNState[] list, uint flags)
		{
			foreach(PNState u in list)
			{
                RemoveFromHash(table, u.UserId, flags);
			}
		}


		//------------------------------------------------------------------------------
		//
		// Public methods
		//

		public AffiliateState(PNState user)
		{
			Initialize(user);
		}


		public AffiliateState(AffiliateState copyState)
		{
			Initialize(copyState);
		}


		public void Initialize(AffiliateState copyState)
		{
			Initialize(copyState._Owner);
		}

		public void Initialize(PNState owner)
		{
			if(!_Initialized)
			{
				_Owner = owner;

				_Unknown = new Hashtable();
				_All = new Hashtable();
				_Encountered = new Hashtable();
				_CompletedGame = new Hashtable();
				_PositiveFeedback = new Hashtable();
				_NegativeFeedback = new Hashtable();
                _Favorites = new Hashtable();
				System.Diagnostics.Debug.WriteLine("Initialized state Owner Puid: " + _Owner.UserId.ToString("x") + ", TitleId: " + _Owner.Xbox.TitleId);
				_Initialized = true;
			}
		}

		// Clear all of the user hashes and reload them from the actual
		// server supplied data.
		public void Restore()
		{
			// Clear all hashes
			ClearHashTables();

			// Load hashtables
			Load(UInt32.MaxValue, false);
		}

		//------------------------------------------------------------------------------
		// 
		// Load existing affiliate properties
		//
		
		void ValidateAndLoadHash(string name, uint flags, PQueryAffiliatesReplyMsgData replyData, Hashtable hashTable)
		{
			if(HResult.Failed(replyData.hr))
			{
				throw new HResultException(replyData.hr, "Failed to load affiliates data: "  + name);
			}

			System.Diagnostics.Debug.WriteLine("ValidateAndLoadHash: "  + name + ", count: " + replyData.cdwResults);	

			for(uint i = 0; i < replyData.cdwResults; ++i)
			{
				QueryAffiliatesReplyData data = replyData.rgResults[i];
				
				// Find an existing hash item matching the input data
				AffiliateHashItem hashItem = _All[data.qwAffiliateID] as AffiliateHashItem;
				if(null == hashItem)
				{
				 	hashItem = new AffiliateHashItem(null, data);
					_All[data.qwAffiliateID] = hashItem;
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("Updating existing hash item for AffiliateId: " + data.qwAffiliateID.ToString("x"));

					hashItem.ListFlags = data.dwListFlags;
					hashItem.TitleId = data.dwTitleID;
					hashItem.SessionId = data.qwSessionID;
					hashItem.DateUpdated = data.mtDateUpdated;
				}

				// Store off the affiliate hash item
				hashTable[data.qwAffiliateID] = hashItem;
			}
		}

		// Default load ignores TitleId and grabs as much as possible
		public void Load()
		{
			Load(UInt32.MaxValue, false);
		}

		public PQueryAffiliatesReplyMsgData LoadExternal(uint limit, bool useTitleId, uint flags)
		{
			return LoadExternal(limit, useTitleId, flags, false);
		}

		public PQueryAffiliatesReplyMsgData LoadExternal(uint limit, bool useTitleId, uint flags, bool dataCenter)
		{
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			PMsgQueryAffiliates request = new PMsgQueryAffiliates(_Owner, limit, flags, queryTitleId);

			if(true == dataCenter)
			{
				request.AuthMethod  = PNRequestMsg.FDAuth.HttpHdr;
				request.PortOnFD    = PNRequestMsg.FDPort.PresNoti_DC;
			}

			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;
			live.server.Presence.TransactFD(_Owner, request, out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;

			return replyData;
		}

		public void Load(uint limit, bool useTitleId)
		{
			// This could all be done in one shot but I'm going to validate that each query only returns the set of players
			// that I'm interested in. Also going to query all to compare against what I got from individual queries.
			
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			// Create the query messages
			PMsgQueryAffiliates queryEncountered = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.Encountered, queryTitleId);
			PMsgQueryAffiliates queryCompletedGame = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.CompletedGame, queryTitleId);
			PMsgQueryAffiliates queryPositive = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.PositiveFeedback, queryTitleId);
			PMsgQueryAffiliates queryNegative = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.NegativeFeedback, queryTitleId);
            PMsgQueryAffiliates queryFavorites = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.Favorites, queryTitleId);
			PMsgQueryAffiliates queryAll = new PMsgQueryAffiliates(_Owner, limit, 0xffffffff, queryTitleId);
			

			// Issue all of the messages, validate and load them into the correct hash table
			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;

            live.server.Presence.TransactFD(_Owner, queryEncountered, out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("Encountereds", (uint)AffiliateFlags.Encountered, replyData, _Encountered);

            live.server.Presence.TransactFD(_Owner, queryPositive, out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("PositiveFeedback", (uint)AffiliateFlags.PositiveFeedback, replyData, _PositiveFeedback);

            live.server.Presence.TransactFD(_Owner, queryCompletedGame, out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("CompletedGames", (uint)AffiliateFlags.CompletedGame, replyData, _CompletedGame);

            live.server.Presence.TransactFD(_Owner, queryFavorites, out replyMsg);
            replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
            ValidateAndLoadHash("Favorites", (uint)AffiliateFlags.Favorites, replyData, _Favorites);
            live.server.Presence.TransactFD(_Owner, queryNegative, out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("NegativeFeedback", (uint)AffiliateFlags.NegativeFeedback, replyData, _NegativeFeedback);

			// Do a full query and make sure that there aren't any users that are with unsupported flags
			
		}

		public void ClearHashTables()
		{
			_Unknown.Clear();
			_PositiveFeedback.Clear();
			_NegativeFeedback.Clear();
			_Encountered.Clear();
			_CompletedGame.Clear();
            _Favorites.Clear();
			_All.Clear();
		}

		//------------------------------------------------------------------------------
		//
		// Affiliate list management
		//

		public void Add(PNState user, uint flags)
		{
			Add(new PNState[]{user}, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNState user, uint flags, uint titleId)
		{
			Add(new PNState[]{user}, flags, titleId);
		}

		public void Add(PNState [] list, uint flags)
		{
			Add(list, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNState [] list, uint flags, uint titleId)
		{
			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				AddToHash(_Encountered, list, flags, titleId, MaxAffiliates[0]);
			}
			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				RemoveFromHash(_NegativeFeedback, list, (uint)AffiliateFlags.NegativeFeedback);
				AddToHash(_PositiveFeedback, list, flags, titleId, MaxAffiliates[2]);
			}
			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				RemoveFromHash(_PositiveFeedback, list, (uint)AffiliateFlags.PositiveFeedback);
				AddToHash(_NegativeFeedback, list, flags, titleId, MaxAffiliates[3]);
			}
			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				// If you complete a game you also belong in the set of encountered
				// players
				AddToHash(_CompletedGame, list, (uint)AffiliateFlags.CompletedGame, titleId, MaxAffiliates[1]);
				AddToHash(_Encountered, list, (uint)AffiliateFlags.Encountered, titleId, MaxAffiliates[0]);
			}
            if (0 != (flags & (uint)AffiliateFlags.Favorites))
            {
                AddToHash(_Favorites, list, flags, titleId, MaxAffiliates[5]);
            }

			PMsgAddAffiliates req = new PMsgAddAffiliates(
					_Owner, 
					flags,
					titleId, 
					list);
            live.server.Presence.TransactFD(_Owner, req);
		}

		// Get the actual number of combined instances across all of the
		// specified lists in the flags 
		public uint GetInstanceCount(uint flags)
		{
			uint count = 0;

			count += (uint)_Encountered.Count;
			count += (uint)_CompletedGame.Count;
			count += (uint)_PositiveFeedback.Count;
			count += (uint)_NegativeFeedback.Count;
            count += (uint)_Favorites.Count;

			return count;
		}

		public PNState GetOwner()
		{
			return _Owner;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\wiredata.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Web;

using live.common;
using xcs = xonline.common.service;
using xonline.core.wiredata;

//[assembly: XomAreaDefinition(XomAreaName.WireDataBin)]
//[assembly: XomAreaDefinition(XomAreaName.WireDataTxt)]

namespace live.protocol
{
    //TODO: this should be in a shared place instead of both here AND livelib, but for now it exists in 2 places and needs to be updated accordingly
    public static class WireDataPublicKey
    {
        private static byte[] key = null;
        private static int version = 0;

        public static byte[] GetLatestKey()
        {
            if (key == null)
            {
                UpdateCachedKey();
            }
            return key;
        }

        public static void SetLatestKey(byte[] latestKey)
        {
            key = latestKey;
        }

        public static int GetLatestKeyVersion()
        {
            if (version == 0)
            {
                UpdateCachedKeyVersion();
            }
            return version;
        }

        public static void SetLatestKeyVersion(int latestKeyVersion)
        {
            version = latestKeyVersion;
        }

        private static void UpdateCachedKey()
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader dr;
            string query = @"select [vc_value] from [t_live_registry_settings] 
                            where vc_setting = 'WiredataPublicKey' and
                            vc_environment = '" + ServerTestFramework.Global.XEnv.GetEnv() + "'";
            npdb.ReadData(query, out dr);
            if (dr.HasRows)
            {
                dr.Read();
                string storedKey = dr.GetString(0);
                key = System.Convert.FromBase64String(storedKey);
            }
            else
            {
                throw new Exception(string.Format("Failed to find WiredataPublicKey in t_live_registry_settings for environment: {0}!", ServerTestFramework.Global.XEnv.GetEnv()));
            }
        }

        private static void UpdateCachedKeyVersion()
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader dr;
            string query = @"select [vc_value] from [t_live_registry_settings] 
                            where vc_setting = 'WiredataKeyVersion' and
                            vc_environment = '" + ServerTestFramework.Global.XEnv.GetEnv() + "'";
            npdb.ReadData(query, out dr);
            if (dr.HasRows)
            {
                dr.Read();
                string sVersion = dr.GetString(0);
                version = Int32.Parse(sVersion);
            }
            else
            {
                throw new Exception(string.Format("Failed to find WiredataKeyVersion in t_live_registry_settings for environment: {0}!", ServerTestFramework.Global.XEnv.GetEnv()));
            }
        }
    }

    //
    // Attribute placed on fields of a class derived from WireData to add context to the field in order to serialize it
    //
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        public int      ArraySize = -1;

        public string   SizeParam = null;

        public bool     HexString = false;

        public bool     Serialize = true;

        public bool     NullTerminate = false; // For strings, specifies that the on the wire format should be null-terminated

        public bool     MaskString = false;
        public bool     LimitString = false;   // specifies in ToString() if string length should be limited
                                               // actual limit is defined in the npdb setting wiredata_stringLimit

        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public static WireInfoAttribute None = new WireInfoAttribute();


        private long   _min       = 0;
        private long   _max       = 0;
        public bool   MaxSet      = false;
        public bool   MinSet      = false;

        public String   MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String   MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint     MinSchemaVersionVal = 0;
        public uint     MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", ( version & 0xFFFF0000 ) >> 16, version & 0xFFFF);
        }
    }


    //
    // Wire Protocol objects should inherit from WireData to assume serialization and deserialization properties
    //
    [ComVisible(false)]
    public class WireData
    {
        public BehaviorInjection BehaviorInjection = new BehaviorInjection();

        // Setting this to true will dump WireData info as it's being written to a stream
        public static bool  DumpDiagnosticInfo = false;

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // This is the version number of the latest schema. Must be the same as
        // XLIVE_SCHEMA_VERSION in xonline.xd in the client tree.
        public static readonly uint CurrentSchemaVersion = MakeSchemaVersion(6, 0);

        // Version of the schema to use for serializing/deserializing this object.
        public uint SchemaVersion = CurrentSchemaVersion;

        // If set, you will need to manually provide array sizes when writing WireDatas
        protected bool      ManualArraySize = false;


        //
        // When going through the reflection data for a type, we downconvert the type data
        //  from the native object format to an integer representation so that we can use
        //  switch statements during serialization and deserialization.
        //
        enum TypeData
        {
            TD_BOOLEAN,
            TD_BYTE,
            TD_BYTE_ARRAY,
            TD_CHAR,
            TD_DECIMAL,
            TD_DOUBLE,
            TD_SHORT,
            TD_INT,
            TD_LONG,
            TD_SBYTE,
            TD_FLOAT,
            TD_USHORT,
            TD_UINT,
            TD_ULONG,
            TD_STRING,
            TD_DATETIME,
            TD_WIREDATA,
            TD_GUID,
            TD_UNSUPPORTED
        };


        //
        // The WireTypeInfo
        //
        private class WireTypeInfo
        {
            // Convert the type data to a friendly enum for perf
            public TypeData[]   fieldType = null;
            public FieldInfo[]  fields = null;
            public WireInfoAttribute[] wireInfo = null;
            public WireInfoAttribute myWireInfo = null;

            // Cache which fields are arrays for perf
            public bool[]       fIsArray = null;

            // These values are used to connect array types
            //  to the field that specifies the length of the field
            //  use forward to find the length field from the array field
            //  use reverse to fine the array field from the length field
            public int[]        forward = null;
            public int[]        reverse = null;

            public WireTypeInfo(int size)
            {
                fieldType = new TypeData[size];

                wireInfo = new WireInfoAttribute[size];

                fIsArray = new bool[size];

                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    fieldType[i] = TypeData.TD_UNSUPPORTED;

                    fIsArray[i] = false;

                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        private static void ListFieldsInSubclasses(Type type, ArrayList outlist)
        {
            if (type == typeof(WireData))
            {
                return;
            }

            ListFieldsInSubclasses(type.BaseType, outlist);

            FieldInfo[] fieldsRaw = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < fieldsRaw.Length; i++)
            {
                outlist.Add(fieldsRaw[i]);
            }
        }

        //
        // The actual WireTypeInfo cache of all WireData types in the current assembly
        //
        private static Hashtable wireTypeInfoCache = new Hashtable();
        private static ReaderWriterLock rwlWireTypeInfoCache = new ReaderWriterLock();
        private const int LockTimeout = 30000;

        //
        // We do all the reflection processing once per type and cache
        // it in the wireTypeInfoCache hash table above.
        //
        private WireTypeInfo GetWireTypeInfo()
        {
            WireTypeInfo index = null;
            Type t = GetType();
            rwlWireTypeInfoCache.AcquireReaderLock(LockTimeout);
            try
            {
                // Do the quick check first to see if this type has already been initialized
                index = (WireTypeInfo)wireTypeInfoCache[t];
                if (index != null)
                {
                    return index;
                }

                // upgrade to a writer lock
                LockCookie lc = rwlWireTypeInfoCache.UpgradeToWriterLock(LockTimeout);
                try
                {
                    // Check to see if this WireData has already been initialized.
                    // If we blocked on the lock, the first thread to
                    // finish the operation makes the rest irrelevant.
                    index = (WireTypeInfo)wireTypeInfoCache[t];
                    if (index != null)
                    {
                        return index;
                    }

                    ArrayList fieldsList = new ArrayList();
                    ListFieldsInSubclasses(GetType(), fieldsList);
                    FieldInfo[] fields = fieldsList.ToArray(typeof(FieldInfo)) as FieldInfo[];

                    // Index this WireData derivative
                    index = new WireTypeInfo(fields.Length);

                    // Cache fields for later
                    index.fields = fields;

                    // Cache 'my' WireInfo, of this type, for later
                    index.myWireInfo = GetWireInfo(GetType());
                    for (int i = 0; i < index.fields.Length; i++)
                    {
                        FieldInfo           field = index.fields[i];
                        Type                type = field.FieldType;

                        index.wireInfo[i] = GetWireInfo(field);

                        if (type.IsArray || type == typeof(string))
                        {
                            index.fIsArray[i] = true;

                            // Get the base type of the array
                            if (type.IsArray)
                            {
                                type = type.GetElementType();
                            }

                            // Find the length specifier and setup the forward/reverse indexers
                            // but only if we actually intend to serialize this field at some
                            // point in the future
                            if (index.wireInfo[i].Serialize == true)
                            {
                                if (index.wireInfo[i].ArraySize == -1)
                                {
                                    string sizeParamName = index.wireInfo[i].SizeParam;
                                    if (sizeParamName == null)
                                    {
                                        sizeParamName = field.Name + "Len";
                                    }

                                    int j;
                                    for (j = 0; j < i; j++)
                                    {
                                        if (index.fields[j].Name == sizeParamName)
                                        {
                                            break;
                                        }
                                    }

                                    if (j == i)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");
                                    }

        // Something we should enable post-tsunami..
        //#if DEBUG
        //                            if (index.wireInfo[j].MaxSet == false)
        //                            {
        //                            }
        //#endif


                                    index.forward[i] = j;
                                    index.reverse[j] = i;
                                }
                                else
                                {
                                    if (index.wireInfo[i].SizeParam != null)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                                    }
                                }
                            }
                        }

                        // Convert the FieldType info into our private enum
                        TypeData    td = TypeData.TD_UNSUPPORTED;
                        bool        fHex = false;
                        if (type.IsSubclassOf(typeof(Enum)))
                        {
                            type = Enum.GetUnderlyingType(type);
                        }

                        if (type == typeof(bool))
                        {
                            td = TypeData.TD_BOOLEAN;
                        }
                        else if (type == typeof(byte))
                        {
                            if(index.fIsArray[i])
                            {
                                td = TypeData.TD_BYTE_ARRAY;
                            }
                            else
                            {
                                td = TypeData.TD_BYTE;
                                fHex = index.wireInfo[i].HexString;
                            }
                        }
                        else if (type == typeof(char))
                        {
                            td = TypeData.TD_CHAR;
                        }
                        else if (type == typeof(decimal))
                        {
                            td = TypeData.TD_DECIMAL;
                        }
                        else if (type == typeof(double))
                        {
                            td = TypeData.TD_DOUBLE;
                        }
                        else if (type == typeof(short))
                        {
                            td = TypeData.TD_SHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(int))
                        {
                            td = TypeData.TD_INT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(long))
                        {
                            td = TypeData.TD_LONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(sbyte))
                        {
                            td = TypeData.TD_SBYTE;
                        }
                        else if (type == typeof(float))
                        {
                            td = TypeData.TD_FLOAT;
                        }
                        else if (type == typeof(ushort))
                        {
                            td = TypeData.TD_USHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(uint))
                        {
                            td = TypeData.TD_UINT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(ulong))
                        {
                            td = TypeData.TD_ULONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(string))
                        {
                            td = TypeData.TD_STRING;
                        }
                        else if (type == typeof(DateTime))
                        {
                            td = TypeData.TD_DATETIME;
                        }
                        else if (type == typeof(Guid))
                        {
                            td = TypeData.TD_GUID;
                        }
                        else if (type.IsSubclassOf(typeof(WireData)))
                        {
                            td = TypeData.TD_WIREDATA;
                        }

                        if (td == TypeData.TD_UNSUPPORTED)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" not supported.");
                        }

                        index.fieldType[i] = td;

                        if (fHex != index.wireInfo[i].HexString)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" cannot be output in hexadecimal.");
                        }

                    }

                    wireTypeInfoCache.Add(GetType(), index);
                    return index;
                }
                finally
                {
                    rwlWireTypeInfoCache.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                rwlWireTypeInfoCache.ReleaseReaderLock();
            }
        }

        //
        // Retrieve the WireInfo attributes from the memberinfo specified
        //
        private WireInfoAttribute GetWireInfo(MemberInfo info)
        {
            object[] attribs = info.GetCustomAttributes(typeof(WireInfoAttribute), false);
            int len = attribs.Length;

            Debug.Assert(len == 0 || len == 1);

            if (len == 1)
            {
                return (WireInfoAttribute)attribs[0];
            }
            else
            {
                return WireInfoAttribute.None;
            }
        }


        // How much to indent nested object and array members when converting to a string
        private const int C_INDENT = 2;

        //
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public virtual string ToString(int indent)
        {
            Type type = GetType();
            WireTypeInfo index = GetWireTypeInfo();

            StringBuilder str = new StringBuilder();
            str.Append(type.Name + " {\n");

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo       field = index.fields[i];
                object          o = field.GetValue(this);

                if ((o != null) && (index.fIsArray[i]) && (index.fieldType[i] != TypeData.TD_STRING) && (index.fieldType[i] != TypeData.TD_BYTE_ARRAY))
                {
                    int actualArraySize = (o as Array).Length;

                    str.Append("".PadLeft(indent + C_INDENT) + field.Name + " is an array of length " + actualArraySize + "\n");

                    for (int j = 0; j < actualArraySize; j++)
                    {
                        object val = (o as Array).GetValue(j);

                        str.Append("".PadLeft(indent + C_INDENT) + field.Name + "[" + j + "]");

                        // Check for array of complex type
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            str.Append("=" + (val as WireData).ToString(indent + C_INDENT) + "\n");
                        }
                        else
                        {
                            str.Append("=" + PrintValue(val, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].MaskString) + "\n");
                        }
                    }
                }
                else
                {
                    str.Append("".PadLeft(indent + C_INDENT) + field.Name);

                    if (o == null)
                    {
                        str.Append("= null\n");
                    }
                    // Check for complex type
                    else if (index.fieldType[i] == TypeData.TD_WIREDATA)
                    {
                        str.Append("=" + (o as WireData).ToString(indent + C_INDENT) + "\n");
                    }
                    else
                    {
                        str.Append("=" + PrintValue(o, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].MaskString) + "\n");
                    }
                }
            }

            str.Append("".PadLeft(indent) + "}");

            return str.ToString();
        }

        // Format a byte array as a hex string
        static protected string ByteArrayToString(byte[] bin)
        {
            StringBuilder str = new StringBuilder(bin.Length * 2 + 1);
            for(int i=0; i < bin.Length; i++)
            {
                str.Append(bin[i].ToString("x2"));
            }

            return str.ToString();
        }


        //
        // Override the ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public override string ToString()
        {
            return ToString(0);
        }


        //
        // Log to the appropriate log area
        //
        protected string LogBinary(Stream stream)
        {
            string result = "";

            if (stream.CanSeek && stream.CanRead)
            {
                long position = stream.Position;
                long length = stream.Length;

                int bytesToRead = (int)(length - position);
                int bytesRead = 0;

                byte []     bytes = new byte[bytesToRead];

                while (bytesToRead > 0)                
                {
                    int n = stream.Read(bytes, bytesRead, bytesToRead);

                    if (n == 0)
                    {
                        break;
                    }

                    bytesRead += n;
                    bytesToRead -=n;
                }
                
                string[]    lines = ByteConvert.ToFormattedStrings(bytes);
                
                foreach (string s in lines)
                {
                    //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, s);
                }

                // Put things back the way they were when we started
                stream.Seek(position, SeekOrigin.Begin);
                
            }
            else
            {
                result = "unsupported stream type.";
            }

            return result;
        }


        //
        // Log to the appropriate log area
        //
        protected string LogText()
        {
            string     delimiter = "\n";
            string []  lines = this.ToString(0).Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, s);
            }

            return "";
        }


        //
        // Read a bunch of bytes into a WireData object
        //
        public WireData ReadBytes(byte[] bytes)
        {
            return ReadStream(new MemoryStream(bytes));
        }

        public void ReadDelegate(xonline.common.service.WireData ignored, BinaryReader binaryReader)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log the input buffer
            //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input:");
            //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo field = index.fields[i];

                object o = null;

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                try
                {
                    // Handle arrays
                    if (index.fIsArray[i])
                    {
                        int size = index.wireInfo[i].ArraySize;

                        if (size == -1)
                        {
                            try
                            {
                                size = Convert.ToInt32(index.fields[index.forward[i]].GetValue(this));
                            }
                            catch (InvalidCastException e)
                            {
                                throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                            }
                        }

                        if (field.FieldType == typeof(string))
                        {
                            string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(size));
                            int termPos = s.IndexOf((char)0);

                            if (termPos > 0)
                            {
                                o = s.Substring(0, s.IndexOf((char)0));
                            }
                            else if (termPos == -1)
                            {
                                o = s;
                            }
                            else
                            {
                                o = "";
                            }
                        }
                        else if (index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            o = binaryReader.ReadBytes(size);
                            // bugs 24888, 31444
                            // Win2k SP2 doesn't throw if size bytes can't be read, it just quietly ignores it..
                            if (((byte[])o).Length < size)
                            {
                                throw new EndOfStreamException("Unable to read " + size + " bytes from stream; only found " + ((byte[])o).Length);
                            }
                        }
                        else
                        {
                            Type[] types = { typeof(int) };
                            object[] param = { size };

                            o = field.FieldType.GetConstructor(types).Invoke(param);

                            for (int j = 0; j < size; j++)
                            {
                                (o as Array).SetValue(ReadValue(binaryReader, index.fieldType[i], field.FieldType.GetElementType(), null), j);
                            }
                        }
                    }
                    else
                    {
                        // For nested WireData objects, default constructors may have already initialized child objects
                        //  with valid state. An example of this is Presence protocol structures that set up a container
                        //  reference to the parent object at construction. In these cases, we want to just use the
                        //  already created object and fill in the values rather than constructing a new one.
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            o = field.GetValue(this);
                        }

                        o = ReadValue(binaryReader, index.fieldType[i], field.FieldType, o);

                        // check max/min range
                        CheckRange(o, index.wireInfo[i], index.fieldType[i], field.Name);
                    }
                }
                catch (EndOfStreamException e)
                {
                    throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, //XEvent.Id.COMMON_HACK_77, 
                        "Reached end of stream trying to read " + field.Name, e);
                }


                field.SetValue(this, o);
            }
        }

        //
        // Read a stream into a WireData object
        //
        public virtual WireData ReadStream(Stream stream)
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        //
        // Read from a BinaryReader into a WireData object
        //  Strings are decoded with UTF8.
        //  DateTime is converted from a 64 bit systime and is represented in LocalTime
        //
        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            xcs.WireDataReadDelegate readDelegate = this.ReadDelegate;

            try
            {
                if (EncryptionRequired)
                    //WireDataDecrypt.Read(new xonline.common.service.WireData(), readDelegate, binaryReader);
                    throw new NotSupportedException("You can't decrypt WireData objects in test code.");
                else
                {
                    readDelegate(new xonline.common.service.WireData(), binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, //xcs.XEvent.Id.COMMON_HACK_77, 
                    "Failed to read enough bytes for type " + GetType().Name, e);
            }

            // Log text representation
            //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
            //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            return this;
        }

        private void CheckRange(object o, WireInfoAttribute wireInfo, TypeData typeData, string name)
        {
            long val;

            switch (typeData)
            {
            case TypeData.TD_BYTE:
                val = (long)(byte)o;
                break;

            case TypeData.TD_SHORT:
                val = (long)(short)o;
                break;

            case TypeData.TD_INT:
                val = (long)(int)o;
                break;

            case TypeData.TD_LONG:
                val = (long)(long)o;
                break;

            case TypeData.TD_SBYTE:
                val = (long)(sbyte)o;
                break;

            case TypeData.TD_FLOAT:
                val = (long)(float)o;
                break;

            case TypeData.TD_USHORT:
                val = (long)(ushort)o;
                break;

            case TypeData.TD_UINT:
                val = (long)(uint)o;
                break;

            case TypeData.TD_ULONG:
                val = (long)(ulong)o;
                break;

            default:
                // numeric type, nothing to do
                return;
            }


            if (wireInfo.MaxSet == true && val > wireInfo.Max)
            {
                throw new XRLException(HResult.E_INVALIDARG, //XEvent.Id.MC_BAD_PARAMETER,
                    "The value specified for field "  + name + " (" + val + ") exceeds the Max allowed value (" + wireInfo.Max + ") !");
            }

            if (wireInfo.MinSet == true && val < wireInfo.Min)
            {
                throw new XRLException(HResult.E_INVALIDARG, //XEvent.Id.MC_BAD_PARAMETER_1,
                    "The value specified for field "  + name + " (" +  val + ") is less than the Min allowed value (" + wireInfo.Min + ") !");
            }
        }

        //
        // Override the operator byte[] to allow assigning a WireData object directly to a byte array.
        //
        public static explicit operator byte[](WireData wiredata)
        {
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);

            return stream.ToArray();
        }

        //
        // Write a WireData object to the given stream
        //
        public virtual void WriteStream(Stream stream)
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }


        public void WriteDelegate(xonline.common.service.WireData ignored, BinaryWriter binaryWriter)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log text representation
            //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Output: ");
            //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo field = index.fields[i];

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                if (WireData.DumpDiagnosticInfo)
                {
                    //Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_HIGH, field.Name);
                }

                object o = field.GetValue(this);

                if (index.fIsArray[i])
                {
                    int actualArraySize = 0;

                    if (o != null)
                    {
                        actualArraySize = index.fieldType[i] == TypeData.TD_STRING ? Encoding.UTF8.GetByteCount((string)o) : (o as Array).Length;

                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (index.wireInfo[i].ArraySize != -1 && actualArraySize > index.wireInfo[i].ArraySize)
                            {
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                            }
                        }

                        if (index.fieldType[i] == TypeData.TD_STRING)
                        {
                            byte[] b = new UTF8Encoding().GetBytes((string)o);

                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // string as a member would fail to be written.
                            //
                            if (b.Length > 0)
                            {
                                binaryWriter.Write(b);
                            }

                            if (index.wireInfo[i].NullTerminate)
                            {
                                binaryWriter.Write((byte)0); // Write out the null if requested
                            }
                        }
                        else if (index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            byte[] b = (byte[])o;
                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // byte array as a member would fail to be written.
                            //
                            if (b.Length > 0)
                            {
                                binaryWriter.Write(b);
                            }
                        }
                        else
                        {
                            for (int j = 0; j < actualArraySize; j++)
                            {
                                object val = (o as Array).GetValue(j);
                                WriteValue(binaryWriter, val, index.fieldType[i]);
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if ((index.wireInfo[i].ArraySize != -1) && (index.wireInfo[i].ArraySize > actualArraySize))
                        {
                            if (index.fieldType[i] == TypeData.TD_STRING || index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[index.wireInfo[i].ArraySize - actualArraySize]);
                            }
                            else
                            {
                                if (index.fieldType[i] == TypeData.TD_WIREDATA)
                                {
                                    throw new Exception("WireData(): for type " + GetType().Name + "." + field.FieldType.GetElementType().Name + " -- The number of elements in the array must equal the ArraySize. No padding can be done for complex types.");
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < index.wireInfo[i].ArraySize; j++)
                                    {
                                        WriteValue(binaryWriter, 0, index.fieldType[i]);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            int iArray = index.reverse[i];

                            object oT = index.fields[iArray].GetValue(this);
                            if (oT == null)
                            {
                                o = 0;
                            }
                            else if (index.fieldType[iArray] == TypeData.TD_STRING)
                            {
                                int iSize = Encoding.UTF8.GetByteCount((string)oT);
                                if (index.wireInfo[iArray].NullTerminate)
                                {
                                    iSize += 1; // Add the null onto the size
                                }
                                o = iSize;
                            }
                            else
                            {
                                o = ((Array)oT).Length;
                            }
                        }
                    }

                    WriteValue(binaryWriter, o, index.fieldType[i]);
                }
            }

            // Log the binary output
            //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Output: ");
            //Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryWriter.BaseStream));
        }

        //
        // Write a WireData object to the given binaryWriter
        //  Strings are encoded with UTF8.
        //  DateTime is converted to a 64 bit systime in UTC
        //
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            xcs.WireDataWriteDelegate writeDelegate = this.WriteDelegate;

            if (this.EncryptionRequired)
            {
               using (xcs.RsaPublicKey key = new xcs.RsaPublicKey(WireDataPublicKey.GetLatestKeyVersion(), WireDataPublicKey.GetLatestKey())) 
               {

                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WireDataEncrypt.Write(new xonline.common.service.WireData(), writeDelegate, binaryWriter, key);
              }
            }
            else
            {
                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WriteDelegate(new xonline.common.service.WireData(), binaryWriter);
            }
        }

        //
        // Serialize the object to obtain its size in bytes. This is SLOW!
        //
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);

            return (int)stream.Length;
        }

        #region Read/Write Converters
        //
        // Read a value of the provided type from the binaryReader
        //
        private object ReadValue(BinaryReader reader, TypeData typeData, Type type, object o)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                o = reader.ReadBoolean();
                break;

            case TypeData.TD_BYTE:
                o = reader.ReadByte();
                break;

            case TypeData.TD_CHAR:
                o = reader.ReadChar();
                break;

            case TypeData.TD_DECIMAL:
                o = reader.ReadDecimal();
                break;

            case TypeData.TD_DOUBLE:
                o = reader.ReadDouble();
                break;

            case TypeData.TD_SHORT:
                o = reader.ReadInt16();
                break;

            case TypeData.TD_INT:
                o = reader.ReadInt32();
                break;

            case TypeData.TD_LONG:
                o = reader.ReadInt64();
                break;

            case TypeData.TD_SBYTE:
                o = reader.ReadSByte();
                break;

            case TypeData.TD_FLOAT:
                o = reader.ReadSingle();
                break;

            case TypeData.TD_USHORT:
                o = reader.ReadUInt16();
                break;

            case TypeData.TD_UINT:
                o = reader.ReadUInt32();
                break;

            case TypeData.TD_ULONG:
                o = reader.ReadUInt64();
                break;

            case TypeData.TD_DATETIME:
                o = DateTime.FromFileTimeUtc(reader.ReadInt64());
                break;

            case TypeData.TD_WIREDATA:
                Debug.Assert(type.IsSubclassOf(typeof(WireData)));
                if (o == null)
                {
                    ConstructorInfo ci = type.GetConstructor(Type.EmptyTypes);
                    if (ci == null)
                    {
                        throw new Exception(String.Format("Type {0} must have a default (parameterless) constructor.", type.ToString()));
                    }
                    else
                    {
                        o = ci.Invoke(null);
                    }
                }

                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                wd.ReadStream(reader);
                break;

            case TypeData.TD_GUID:
                o = new Guid(reader.ReadBytes(16));
                break;

            default:
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");

            }

            return o;
        }

        //
        // Write a value of the provided type to the binaryWriter
        //
        private void WriteValue(BinaryWriter writer, object o, TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                writer.Write(Convert.ToBoolean(o));
                break;

            case TypeData.TD_BYTE:
                writer.Write(Convert.ToByte(o));
                break;

            case TypeData.TD_CHAR:
                writer.Write(Convert.ToChar(o));
                break;

            case TypeData.TD_DECIMAL:
                writer.Write(Convert.ToDecimal(o));
                break;

            case TypeData.TD_DOUBLE:
                writer.Write(Convert.ToDouble(o));
                break;

            case TypeData.TD_SHORT:
                writer.Write(Convert.ToInt16(o));
                break;

            case TypeData.TD_INT:
                writer.Write(Convert.ToInt32(o));
                break;

            case TypeData.TD_LONG:
                writer.Write(Convert.ToInt64(o));
                break;

            case TypeData.TD_SBYTE:
                writer.Write(Convert.ToSByte(o));
                break;

            case TypeData.TD_FLOAT:
                writer.Write(Convert.ToSingle(o));
                break;

            case TypeData.TD_USHORT:
                writer.Write(Convert.ToUInt16(o));
                break;

            case TypeData.TD_UINT:
                writer.Write(Convert.ToUInt32(o));
                break;

            case TypeData.TD_ULONG:
                writer.Write(Convert.ToUInt64(o));
                break;

            case TypeData.TD_DATETIME:
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
                break;

            case TypeData.TD_WIREDATA:
                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                wd.WriteStream(writer);
                break;

            case TypeData.TD_GUID:
                writer.Write(((Guid)o).ToByteArray());
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }
        }

        public void SerializeArray(WireData [] arrObject, int nLength, BinaryWriter binaryWriter)
        {
             for (int i=0;i<nLength;i++)
             {
                arrObject[i].SchemaVersion = this.SchemaVersion;
                arrObject[i].WriteStream(binaryWriter);
             }
        }

        //
        // Write a value of the provided type to a string
        //
        private string PrintValue(object o, TypeData typeData, bool fHex, bool fMask)
        {
            string str;

            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                str = (Convert.ToBoolean(o)).ToString();
                break;

            case TypeData.TD_BYTE:
                str = fHex ? "0x" + (Convert.ToByte(o)).ToString("X2") : (Convert.ToByte(o)).ToString();
                break;

            case TypeData.TD_BYTE_ARRAY:
                str = ByteArrayToString((byte[])o);
                break;

            case TypeData.TD_CHAR:
                str = (Convert.ToChar(o)).ToString();
                break;

            case TypeData.TD_DECIMAL:
                str = (Convert.ToDecimal(o)).ToString();
                break;

            case TypeData.TD_DOUBLE:
                str = (Convert.ToDouble(o)).ToString();
                break;

            case TypeData.TD_SHORT:
                str = fHex ? "0x" + (Convert.ToInt16(o)).ToString("X4") : (Convert.ToInt16(o)).ToString();
                break;

            case TypeData.TD_INT:
                str = fHex ? "0x" + (Convert.ToInt32(o)).ToString("X8") : (Convert.ToInt32(o)).ToString();
                break;

            case TypeData.TD_LONG:
                str = fHex ? "0x" + (Convert.ToInt64(o)).ToString("X16") : (Convert.ToInt64(o)).ToString();
                break;

            case TypeData.TD_SBYTE:
                str = (Convert.ToSByte(o)).ToString();
                break;

            case TypeData.TD_FLOAT:
                str = (Convert.ToSingle(o)).ToString();
                break;

            case TypeData.TD_USHORT:
                str = fHex ? "0x" + (Convert.ToUInt16(o)).ToString("X4") : (Convert.ToUInt16(o)).ToString();
                break;

            case TypeData.TD_UINT:
                str = fHex ? "0x" + (Convert.ToUInt32(o)).ToString("X8") : (Convert.ToUInt32(o)).ToString();
                break;

            case TypeData.TD_ULONG:
                str = fHex ? "0x" + (Convert.ToUInt64(o)).ToString("X16") : (Convert.ToUInt64(o)).ToString();
                break;

            case TypeData.TD_DATETIME:
                str = (Convert.ToDateTime(o).ToFileTimeUtc()).ToString();
                break;

            case TypeData.TD_STRING:
                str = (string)o;
                break;

            case TypeData.TD_GUID:
                str = ((Guid)o).ToString();
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }

            // If the field is masked, replace all of the characters with an
            // asterisk ('*').  This will likely only be used for fields which
            // contain credit card or direct debit account numbers or other
            // equally sensitive data.
            if (fMask && str != null && str.Length > 0)
            {
                StringBuilder sb = new StringBuilder(str.Length);
                for (int i = 0; i < str.Length; i++)
                {
                    sb.Append("*");
                }
                str = sb.ToString();
            }

            return str;
        }

        //
        // Return the size for a given type (only supports types used by ReadValue)
        //
        private uint SizeOfType(TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_DECIMAL:
            case TypeData.TD_GUID:
                return 16;

            case TypeData.TD_DATETIME:
            case TypeData.TD_DOUBLE:
            case TypeData.TD_LONG:
            case TypeData.TD_ULONG:
                return 8;

            case TypeData.TD_FLOAT:
            case TypeData.TD_INT:
            case TypeData.TD_UINT:
                return 4;

            case TypeData.TD_SHORT:
            case TypeData.TD_USHORT:
                return 2;

            case TypeData.TD_BOOLEAN:
            case TypeData.TD_BYTE:
            case TypeData.TD_CHAR:
            case TypeData.TD_SBYTE:
                return 1;

            case TypeData.TD_WIREDATA:
                return 0;

            default:
                throw new Exception("Type \"" + typeData.ToString() + "\" not supported by SizeOfType.");
            }
        }

        public static uint GetSchemaVersion(HttpRequest req)
        {
            // Assume version 1.0 for back compat
            uint schemaVersion = MakeSchemaVersion(1,0);

            String schemaVersionStr = req.Headers["X-Schema-Ver"];
            if (schemaVersionStr != null)
            {
                schemaVersion = WireInfoAttribute.StringToVersion(schemaVersionStr);
            }

            return schemaVersion;
        }

        public void ValidateSchemaVersion()
        {
            // Check current SchemaVersion against the one the Class expects
            WireTypeInfo myInfo = GetWireTypeInfo();

            if( this.SchemaVersion < myInfo.myWireInfo.MinSchemaVersionVal ||
                this.SchemaVersion > myInfo.myWireInfo.MaxSchemaVersionVal)
            {
                throw new XRLException(HResult.XONLINE_E_UNSUPPORTED_METHOD, //XEvent.Id.COMMON_HACK_81,
                    "Wiredata Request SchemaVersion " + WireInfoAttribute.VersionToString(this.SchemaVersion) + " not allowed: " + this.GetType().ToString());
            }
        }
        
        private bool EncryptionRequired
        {
            get
            {
                object[] attributes = this.GetType().GetCustomAttributes(typeof(WireDataEncryptionAttribute), true);
                if ((attributes == null) || (attributes.Length == 0)) return false;

                WireDataEncryptionAttribute attribute = (WireDataEncryptionAttribute)attributes[0];
                return this.SchemaVersion >= WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\XrlObject2.cs ===
using System;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Web;

namespace live.protocol
{
    public static class HttpMethod
    {
        public readonly static string Get = "GET";
        public readonly static string Post = "POST";
    }

    public abstract class HttpRequestObject2 : XRLObject2
    {
        public abstract string GetHttpMethod();
        public abstract string GetRelativeUrl();
    }

    public abstract class XRLRequestObject2 : HttpRequestObject2
    {
        public override string GetHttpMethod()
        {
            return HttpMethod.Post;
        }

        public override string GetRelativeUrl()
        {
            return Xrl;
        }

        public abstract string Xrl
        {
            get;
        }
    }

    [ComVisible(false)]
    public abstract class XRLObject2 : WireData
    {
        //-----------------------------------------------------
        // ReadFromRequest
        //
        public virtual void ReadFromRequest(HttpRequest req)
        {
            Type t = this.GetType();

            BinaryReader reader = new BinaryReader(req.InputStream);

            Debug.Assert(req.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");

            // failures here can be ignored, this is just for logging purposes
            try
            {
                if (HttpContext.Current != null && HttpContext.Current.Items["XRLRequest"] == null)
                {
                    HttpContext.Current.Items["XRLRequest"] = this;
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine("Error setting HttpContext.Current.Items[\"XRLRequest\"]: " + e.ToString());
                //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_WARNING, "Error setting HttpContext.Current.Items[\"XRLRequest\"]: " + e.ToString());
            }


            //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer...");

            // Allow the base WireData class to read
            ReadStream(reader);
        }

        public virtual void ReadFromRequest(BinaryReader reader, UTF8Encoding enc, long len, NameValueCollection queryString)
        {
            Type t = this.GetType();

            //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer...");

            // QueryString reading no longer supported
            if (len == 0 && queryString != null && queryString.Count != 0)
            {
                throw new Exception("XRLObject.ReadFromRequest: Post buffer empty!Read from QueryString no longer supported by XRLObject2");
            }

            // Allow the base WireData class to read
            ReadStream(reader);
        }


        //-----------------------------------------------------
        // WriteToResponse
        //
        //      this overrideable implementation uses reflection
        //      to find any instance fields, and writes
        //      most common types to the response stream in the
        //      order of declaration.
        //
        //      - strings are sent in UTF8.
        //      - DateTime is sent as a SYSTEMTIME struct as
        //      defined by windows.h(?)
        //
        public virtual void WriteToResponse(HttpResponse resp)
        {
            BinaryWriter writer = new BinaryWriter(resp.OutputStream);
            Debug.Assert(resp.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");
            WriteToResponse(writer, (UTF8Encoding)resp.ContentEncoding);
        }

        public virtual void WriteToResponse(BinaryWriter writer, UTF8Encoding enc)
        {
            Type t = this.GetType();

            //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject.WriteToResponse: Writing " + t.ToString() + " to response...");

            // Allow the base WireData class to write
            WriteStream(writer);
        }

        public virtual byte[] GetBytes()
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            return stream.ToArray();
        }

        public virtual void SetBytes(byte[] buf)
        {
            MemoryStream stream = new MemoryStream(buf);
            BinaryReader reader = new BinaryReader(stream);

            ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, buf.Length, null);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\Message.cs ===
// Message.cs
//
//  Friendly wrapper for an invidual message
//

using System;
using live.common;

namespace live.protocol.Presence
{
    public abstract class Message
    {
        public const uint MANY_RECIPIENTS = 0xffffffff;

        // Priority type, used to set appropiate flag
        public enum Priority { Normal, Required, Recomended }

        // Message data common to derived message types (sytem and user)
        public byte                 Type;
        public ulong                Context;
        public uint                 TitleID;
        public DateTime             SentTime;
        public ushort               ExpireMinutes;  // An offset in minutes from the sent time
        public string               SenderName;
        public uint                 Flags;
        public uint                 ID;             // ID may be MANY_RECIPIENTS when a message is sent to multiple recipients (see Recipients)
        public RecipientResult[]    Recipients;     // Set on Send()

        // Must be created to send or retrieved separately on recieve
        public MsgDetails Details;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\GIblob.cs ===
using System;
using System.IO;
using System.Collections;
using live.common;

namespace live.protocol.Presence
{
	public class GIBlob : WireData
	{
		public uint             TitlePresence;
        public ushort           ContextsLen;
        public ushort           PropertiesLen;
        [WireInfo(SizeParam="ContextsLen")]
        public GIContext[]      Contexts;
        [WireInfo(SizeParam="PropertiesLen")]
        public GIProperty[]     Properties;

		// Containers to aid in blob building
		[WireInfo(Serialize=false)]	
		protected ArrayList 	contexts;
		[WireInfo(Serialize=false)]	
		protected ArrayList		properties;

		public GIBlob()
		{
			contexts = new ArrayList();
			properties = new ArrayList();
		}

		public void AddContext(uint id, uint value)
		{
			AddContext(new GIContext(id, value));
		}

		public void AddContext(GIContext gictx)
		{
			contexts.Add(gictx);
		}

		public void SetContext(uint id, uint value)
		{
			foreach(GIContext ctx in contexts)
			{
				if(ctx.Id == id)
				{
					ctx.Value = value;
				}
			}
		}
		
		public void AddProperty(GIProperty giprop)
		{
			properties.Add(giprop);
		}

		public void SetProperty(GIProperty giprop)
		{
			foreach(GIProperty p in properties)
			{
				if(p.Id == giprop.Id)
				{
					p.Value = giprop.Value;
				}
			}
		}

		public void Clear()
		{
			contexts.Clear();
			properties.Clear();

			// Clear serialized data
			TitlePresence = 0;
			ContextsLen = 0;
			Contexts = null;
			PropertiesLen = 0;
			Properties = null;
		}

		public byte[] GetBytes()
		{
			return GetBytes(true);
		}

		public byte[] GetBytes(bool checkSize)
		{
			ContextsLen = (ushort)contexts.Count;
			Contexts = (GIContext[])contexts.ToArray(typeof(GIContext));
			PropertiesLen = (ushort)properties.Count;
			Properties = (GIProperty[])properties.ToArray(typeof(GIProperty));
			
			// serialize members to binary stream
			MemoryStream stream = new MemoryStream(256);
			WriteStream(stream);

			if(checkSize && stream.Length > 256) 
			{
				throw new Exception("GIBlob cannot be larger than 256 bytes");
			}

			return stream.ToArray();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\xsigprot.cs ===
/*==========================================================================
 *
 *  XSigProt.cs -- This module defines the wire protocol for Signature server
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Caching;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

using live.common;
using live.client;

namespace live.protocol
{
    public class XSigAuthData : WireData
    {
        public uint        _titleID;
        public uint        _titleVersion;
        public ulong       _XboxID;
        public ulong       _userID1;
        public ulong       _userID2;
        public ulong       _userID3;
        public ulong      _userID4;
        static public int GetSizeInBytes()
        {
            return 48;
        }
    };

    // ------------------------------------------
    //      SignOnBehalf request
    // ------------------------------------------
    public class XSigSignOnBehalfRequest : XRLRequestObject2
    {
        public const int XONLINE_XSIG_DIGEST_SIZE=20;
        public uint        _serviceId;

        [WireInfo(ArraySize=XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;

        public XSigAuthData  _authData;

        static public int GetSizeInBytes()
        {
            return 4+XSigAuthData.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public virtual new string ToString()
        {
            string szSigData = _serviceId.ToString("X8") + "|"
                +(ByteConvert.ToString(_digest))+ "|"
                + _authData._titleID.ToString("X8") + "|"
                + _authData._titleVersion.ToString("X8") + "|"
                + _authData._XboxID.ToString("X16") + "|"
                + _authData._userID1.ToString("X16") + "|"
                + _authData._userID2.ToString("X16") + "|"
                + _authData._userID3.ToString("X16") + "|"
                + _authData._userID4.ToString("X16");

            return szSigData;
        }

        public string GetXRL()
        {
            return "/xsig/SignOnBehalf.ashx";
        }

        public override string Xrl { get { return "/xsig/SignOnBehalf.ashx"; } }

    }

    // ------------------------------------------
    //      GetSigningKey request
    // ------------------------------------------
    //
    // None: This request type takes no input data.


    public class XSigSignature : XRLObject2
    {
        public const int XONLINE_XSIG_RESERVED_SIZE = 16;
        public const int XONLINE_XSIG_SIGNATURE_KEY_SIZE = 20;
        public const short XONLINE_XSIG_SIGNATURE_VERSION = 1;

        public short       _signatureVersion = XONLINE_XSIG_SIGNATURE_VERSION;
        public short       _keyVersion;
        public uint        _serviceId = 0;
        public long        _timeStamp ;
        public XSigAuthData       _authData;
        [WireInfo(ArraySize=XONLINE_XSIG_RESERVED_SIZE)]
        public byte[]  _reserved;
        [WireInfo(ArraySize=XONLINE_XSIG_SIGNATURE_KEY_SIZE)]
        public byte[]  _signature;

        [WireInfo(Serialize=false)]
        public ulong _liNonce = 0;

        static public int GetSizeInBytes()
        {
            return 16 + XSigAuthData.GetSizeInBytes() + XONLINE_XSIG_RESERVED_SIZE + XONLINE_XSIG_SIGNATURE_KEY_SIZE;
        }

        // NOTE: Since WireData overloads operator byte[], casting this object to a byte[] will allow you to
        // get the signature for use as a binary array.

        public virtual new string ToString()
        {
            string szSigData;

            if ( this._signature == null )
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    "null";
            }
            else
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    (ByteConvert.ToString(this._signature));
            }

            return szSigData;
        }

    };

    // ------------------------------------------
    //      SignOnBehalf response
    // ------------------------------------------
    public class XSigSignOnBehalfResponse : XRLObject2
    {
        public uint          _hresult;
        public XSigSignature _signature;
    }

    // ------------------------------------------
    //      XSigVerifySignatureRequest request
    // ------------------------------------------
    public class XSigVerifySignatureRequest : XRLObject2
    {
        [WireInfo(ArraySize=XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;
        public XSigSignature  _signature;

        static public int GetSizeInBytes()
        {
            return XSigSignature.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public string GetXRL()
        {
            return "/xsig/VerifySignature.ashx";
        }
    }

    // ------------------------------------------
    //      XSigVerifySignatureResponse
    // ------------------------------------------
    public class XSigVerifySignatureResponse : XRLObject2
    {
         public uint      _hresult;
    }

    // ------------------------------------------
    //      CheckRevocation
    // ------------------------------------------

    public class ContentTuple : WireData
    {
        public uint TitleId;
        public uint TitleVersion;
        public ulong ConsolePuid;

        [WireInfo(ArraySize=5)]
        public byte[] ConsoleId = new byte[5];

        [WireInfo(ArraySize=4)]
        public ulong[] UserPuid = new ulong[4];

        [WireInfo(ArraySize=20)]
        public byte[] Digest = new byte[20];

        public override WireData ReadStream(BinaryReader reader)
        {
            TitleId = reader.ReadUInt32();
            TitleVersion = reader.ReadUInt32();
            ConsolePuid = reader.ReadUInt64();

            ConsoleId = reader.ReadBytes(5);
            if (ConsoleId.Length != 5)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, /*XEvent.Id.COMMON_CODE_177,*/ "failed to read 5 bytes for ConsoleID!");
            }


            for (int i = 0; i < UserPuid.Length; i++)
                UserPuid[i] = reader.ReadUInt64();

            Digest = reader.ReadBytes(20);
            if (Digest.Length != 20)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, /*XEvent.Id.COMMON_CODE_178, */"failed to read 20 bytes for Digest!");
            }

            return this;
        }

    }

    public class CheckRevocationRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumContentTuples = 0;

        [WireInfo(SizeParam="NumContentTuples")]
        public ContentTuple[] Tuples = new ContentTuple[0];

        public string GetXRL()
        {
            return "/xsig/CheckRevocation.ashx";
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            NumContentTuples = reader.ReadUInt32();
            if (NumContentTuples > XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)
            {
                throw new XRLException(HResult.E_INVALIDARG, /*XEvent.Id.COMMON_CODE_179,*/ "Rquest contained too many Content Tuples!");
            }

            Tuples = new ContentTuple[NumContentTuples];
            for (int i = 0; i < NumContentTuples; i++)
            {
                Tuples[i] = new ContentTuple();
                Tuples[i].ReadStream(reader);
            }

            return this;
        }

    }

    public class CheckRevocationResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumHrs = 0;

        [WireInfo(SizeParam="NumHrs")]
        public uint[] Hrs = new uint[0];

        public override void WriteStream(BinaryWriter writer)
        {
            writer.Write(Hrs.Length);
            for (int i = 0; i < Hrs.Length; i++)
            {
                writer.Write(Hrs[i]);
            }
        }
    }


    public class XmstvCreateCertificateRequest : XRLObject2
    {
        const int RSAPUB_2048_SIZE = 272;
        public const int SHA1_DIGEST_SIZE = 20;

        public uint Flags;

        [WireInfo(ArraySize=XmstvCreateCertificateRequest.RSAPUB_2048_SIZE)]
        public byte[] AvPubKey;

        [WireInfo(ArraySize=XmstvCreateCertificateRequest.RSAPUB_2048_SIZE)]
        public byte[] NonAvPubKey;

        public ulong KeyNonce;

        [WireInfo(ArraySize=XmstvCreateCertificateRequest.SHA1_DIGEST_SIZE)]
        public byte[] KeyedHash;

        public string Xrl
        {
            get
            {
                return "/xsig/XmstvCreateCertificate.ashx";
            }
        }
    }


    public class XmstvCreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvCertificateSize;

        [WireInfo(SizeParam="AvCertificateSize")]
        public byte[] AvCertificate; 

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvSerializedCertificateSize;

        [WireInfo(SizeParam="AvSerializedCertificateSize")]
        public byte[] AvSerializedCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvCertificateSize;

        [WireInfo(SizeParam="NonAvCertificateSize")]
        public byte[] NonAvCertificate; 

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvSerializedCertificateSize;

        [WireInfo(SizeParam="NonAvSerializedCertificateSize")]
        public byte[] NonAvSerializedCertificate;
    }


    public class CreateCertificateRequest : XRLRequestObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int RSAPUB_2048_SIZE = 272;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        public ulong userPuid;

        [WireInfo(ArraySize = RSAPUB_2048_SIZE)]
        public byte[] PubKey;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate.ashx";
            }
        }
    }


    public class CreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }

    public class CreateCertificate2Request : XRLRequestObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        [WireInfo(ArraySize = XE_CONSOLE_CERTIFICATE_SIZE - CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] ConsoleCertificate;

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate2.ashx";
            }
        }
    }

    public class XEConsoleCertificate : WireData
    {
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_ID_SIZE = 5;
        public const int CONSOLE_CERT_PART_NUMBER_SIZE = 11;
        public const int CONSOLE_CERTIFICATE_RESERVED_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_EXPONENT_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_MODULUS_SIZE = 128;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = XE_CONSOLE_CERTIFICATE_SIZE)]
        public ushort CertSize;             // Size of this structure (424);

        [WireInfo(ArraySize = CONSOLE_ID_SIZE)]
        public byte[] ConsoleId;            // Uniquely ids console

        [WireInfo(ArraySize = CONSOLE_CERT_PART_NUMBER_SIZE)]
        public byte[] ConsolePartNumber;    // Identifies mfg part number

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_RESERVED_SIZE)]
        public byte[] Reserved;             // Reserved for future use

        public ushort Privileges;           // Privileges for SG

        public uint ConsoleType;            // States whether console is a retail or dev/test kit
        
        public ulong ManufacturingDate;     // Date of mfg for console
        
        [WireInfo(ArraySize = CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[] ConsolePublicKey;     // Console's Public Key
        
        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;      // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)

    }

    public class CreateCertificate2Response : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }
    public interface ILicenseApiResponse
    {
        MediaInstanceIdOfferIdPair IdPair { get; set; }
        uint Hr { get; set; }
    }
    
    public class Availability: WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;
        public uint hr;

        [XmlIgnore]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnore]
        public uint Hr { get { return hr; } set { hr = value; } }
    }

    public class MediaInstanceIdOfferIdPair : WireData
    {
        public Guid miid;
        public Guid oid;
    }

    public class MediaLicense : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public ushort licenseType;

        public const int LICENSE_BLOCK_MAX_COUNT = 13;

        [XmlIgnore]
        [WireInfo(Max = LICENSE_BLOCK_MAX_COUNT)]
        public ushort licenseBlockCount;

        [XmlIgnore]
        [WireInfo(SizeParam="licenseBlockCount")]
        public XeGenericBlock[] licenseBlocks;

        [WireInfo(Serialize=false)]
        public byte[] license;

        public uint hr;

        [XmlIgnore]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnore]
        public uint Hr { get { return hr; } set { hr = value; } }
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xsig/xsigweb.asmx", "AcquireMediaLicenses", "urn:schemas-xbox-com:xsigweb-data")]
    public class AcquireMediaLicensesRequest : PayloadRequestWithSSL
    {
        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        [PayloadParam]
        [WireInfo(Serialize = false)]
        public string[] miids;

        [PayloadParam]
        [WireInfo(Serialize = false)]
        public string[] oids;

        [PayloadParam("xuid")]
        public ulong userPuid;

        [PayloadParam]
        [WireInfo(Serialize = false)]
        public string clientInfo;

        public const int CLIENT_INFO_BLOCK_MAX_COUNT = 13;

        [WireInfo(Min=1, Max=CLIENT_INFO_BLOCK_MAX_COUNT)]
        public ushort clientInfoBlockCount;

        [WireInfo(SizeParam="clientInfoBlockCount")]
        public XeGenericBlock[] clientInfoBlocks;

        public override string Xrl { get { return "/xsig/AcquireMediaLicenses.ashx"; } }
    }

    [PayloadResponse("urn:schemas-xbox-com:xsigweb-data", "ArrayOfMediaLicense")]
    public class AcquireMediaLicensesResponse : PayloadResponse
    {
        [WireInfo(Min=1)]
        public ushort mediaLicensesLength;

        [WireInfo(SizeParam="mediaLicensesLength")]
        [PayloadParam("/")]
        public MediaLicense[] mediaLicenses;
    }


    public class Acknowledgement : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public uint hr;

        [XmlIgnore]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnore]
        public uint Hr { get { return hr; } set { hr = value; } }
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xsig/xsigweb.asmx", "AcknowledgeLicensesDelivery", "urn:schemas-xbox-com:xsigweb-data")]
    public class AcknowledgeLicensesDeliveryRequest : PayloadRequestWithSSL
    {
        [PayloadParam]
        [WireInfo(Serialize = false)]
        public string[] miids;

        [PayloadParam]
        [WireInfo(Serialize = false)]
        public string[] oids;

        [PayloadParam("xuid")]
        public ulong userPuid;

        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        public override string Xrl { get { return "/xsig/AcknowledgeLicensesDelivery.ashx"; } }
    }

    [PayloadResponse("urn:schemas-xbox-com:xsigweb-data", "ArrayOfAcknowledgement")]
    public class AcknowledgeLicensesDeliveryResponse : PayloadResponse
    {
        [WireInfo(Min=1)]
        public ushort acknowledgementsLength;

        [WireInfo(SizeParam="acknowledgementsLength")]
        [PayloadParam("/")]
        public Acknowledgement[] acknowledgements;
    }

    [PayloadClient(typeof(ZuneClient), PayloadType.HttpPOST)]
    [PayloadAction("/xsig/xsigweb.asmx", "CheckLicensesAvailability", "urn:schemas-xbox-com:xsigweb-data")]
    public class CheckLicensesAvailabilityRequest : PayloadRequestWithSSL
    {
        [PayloadParam]
        public string[] miids;

        [PayloadParam]
        public string[] oids;

        [PayloadParam("xuid")]
        public ulong userPuid;

        public override string Xrl { get { return ""; } }
    }

    [PayloadResponse("urn:schemas-xbox-com:xsigweb-data", "ArrayOfAvailability")]
    public class CheckLicensesAvailabilityResponse : PayloadResponse
    {
        [PayloadParam("/")]
        public Availability[] mediaLicenses;
    }


    //
    // RefreshGameLicense
    //
    public class RefreshGameLicenseRequest : XRLRequestObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl { get { return "/xsig/RefreshGameLicense.ashx"; } }
    }

    public class RefreshGameLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }
    //
    // END RefreshGameLicense
    //

    public enum HeaderVersion : uint
    {
        V1 = 1,
    }

    public enum HeaderFlags : uint
    {
        None = 0,

        RedSigned = 0x80000000,
    }

    public class SignedHeader : WireData
    {
        public const int XONLINE_HEADER_HASH_SIZE = 20;

        public UInt32 fileType;
        public uint headerVersion;
        public UInt32 headerSize;
        public DateTime signedDateTime;
        public UInt32 fileSize;
        public uint flags;

        [WireInfo(ArraySize = XONLINE_HEADER_HASH_SIZE)]
        public byte[] fileHash;

        [WireInfo(ArraySize = SIGNATURE_SIZE)]
        public byte[] signature;

        public const int SIGNATURE_SIZE = 256;
    }

    //
    // END Xsigner
    //

    //
    // START License Migration
    //
    public enum UpdateTransferStateEnum
    {
        Start,
        Complete,
        Cancel
    }

    public class UpdateLicenseTransferStateRequest : XRLRequestObject2
    {
        public UpdateTransferStateEnum command;

        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/UpdateLicenseTransferState.ashx"; } }
    }
    public enum LicenseTransferStatusEnum
    {
        LicenseTransferTimeout = -2,
        MultipleSignInDetected = -1,

        NotStarted = 0,
        PendingConsoleSignIn = 1,
        PendingUserConfirmation = 2,
        Completed = 3
    }

    public class GetLicenseTransferStateRequest : XRLRequestObject2
    {
        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/GetLicenseTransferState.ashx"; } }
    }
    public class ConsoleLicenseCount : WireData
    {
        public UInt32 licenseCount;

        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;
    }


    public class GetLicenseTransferStateResponse : XRLObject2
    {
        public LicenseTransferStatusEnum currentStatus = LicenseTransferStatusEnum.NotStarted;

        public Boolean restartAllowed = true;

        public DateTime lastUpdated = DateTime.FromFileTimeUtc(0);

        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;

        public UInt16 sourceConsolesLength;

        [WireInfo(SizeParam = "sourceConsolesLength")]
        public ConsoleLicenseCount[] sourceConsoles;

        public UInt16 sourceVideoConsolesLength;

        [WireInfo(SizeParam = "sourceVideoConsolesLength")]
        public ConsoleLicenseCount[] sourceVideoConsoles;
    }
    //
    // END License Migration
    public sealed class GetSignedHeaderRequest : XRLRequestObject2
    {
        public const int XONLINE_HEADER_HASH_SIZE = 20;

        public const uint ONLY_LEGAL_FILE_TYPE = 0x52475459;

        public UInt32 fileSize;

        public UInt32 fileType;

        [WireInfo(ArraySize = XONLINE_HEADER_HASH_SIZE)]
        public byte[] fileHash;

        public override string Xrl { get { return "/xsig/GetSignedHeader.ashx"; } }
    }

    public sealed class GetSignedHeaderResponse : XRLObject2
    {
        public UInt32 headerSize;

        [WireInfo(SizeParam = "headerSize", LimitString = true)]
        public byte[] header;
    }

    public sealed class ValidateCertificateRequest : XRLRequestObject2
    {
        public const int MAX_CERT_SIZE = 3000;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort certificateSize;

        [WireInfo(SizeParam = "certificateSize")]
        public byte[] certificate;

        public override string Xrl
        {
            get
            {
                return "/xsig/ValidateCertificate.ashx";
            }
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAcceptBuddy.cs ===
// PMsgAcceptBuddy.cs
//
//	Presence Accept Buddy Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Accept a request to be someone's buddy
	/// </summary>
	public class PMsgAcceptBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User accepting the request</param>
		/// <param name="buddy">Buddy that made the request</param>
		public PMsgAcceptBuddy( PNState user, PNState buddy ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ACCEPT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PAcceptBuddyMsgData data = new PAcceptBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Accept buddy request
	/// </summary>
	public class PAcceptBuddyMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BuddyID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\MsgUtils.cs ===
// MsgUtils.cs
//
//	Utiliy classes and functions used by messaging that dont' have a better place to be
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message notification flags in lower 24 bits and message type in upperbyte
	/// </summary>
	public class MsgNotification : WireData
	{
		MsgNotification( uint dw ) { dwTypeAndFlags = dw; }

		public uint dwTypeAndFlags;

		public byte type  {get{ return (byte)( dwTypeAndFlags >> 24 ); }}
		public uint flags {get{ return  dwTypeAndFlags & 0x00FFFFFF;   }}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Utility functions taken from macros found in xonlinep.h
	/// </summary>
	public class MsgUtility
	{
		public static bool IsMessageTransient( uint msgId )
		{
			return 0 != (msgId & XonPresNoti.MSG_ID_TRANSIENT_MESSAGE );
		}

		public static bool IsNotifyMsgType( byte type ) 
		{
			return (type == XonPresNoti.MSG_TYPE_GAME_INVITE);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Custom Exception class to carry and identify failures due to invalid message properties 
	/// </summary>
	public class InvalidMsgPropertyException : Exception
	{
		public MsgProperty Prop; 
		public InvalidMsgPropertyException( MsgProperty prop ) : base() { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message) : base(message) { Prop = prop; }
		public InvalidMsgPropertyException( MsgProperty prop, string message, Exception inner) : base(message, inner) { Prop = prop; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\MsgProperty.cs ===
// MsgProperty.cs
//
//	Message property protocol data
//
//
using System;
using System.IO;
using System.Text;

namespace live.protocol.Presence
{
	/// <summary>
	/// Message Property tags occupy a word where the upper byte indicates the property's 
	/// data type, and the lower byte indicates a unique identifier for the property.
	/// Property identifiers only need to be unique within a given message type.
	/// </summary>
	public class MsgPropertyTag : WireData
	{
		public ushort tag;

		public const ushort size = 2;

		public static ushort Make( byte type, byte id ) 
		{ 
			return (ushort)( ((ushort)type << 8) | id ); 
		}
			
		public byte id   {get{ return (byte)( tag & 0xff ); }}
		public byte type {get{ return (byte)( tag >> 8 );   }}
	}

    
	/// <summary>
	/// Message Property contains the tag and a value who's meaning depends on property
	/// type. 
	/// </summary>
	public class MsgProperty : WireData
	{
		// This property's type and unique identifier
		public MsgPropertyTag wPropTag = new MsgPropertyTag();
		
		// Value depends on property type
		public ushort _data;     

		public const ushort size = MsgPropertyTag.size + 2;

        public byte id      { get { return wPropTag.id; } }
        public byte type    { get { return wPropTag.type; } }

        public ushort tag
        {
            get { return wPropTag.tag; }
            set { wPropTag.tag = value; }
        }

        public ushort data 
        {
            get { return _data; }
            set { _data = value; }
        }

		// For type XONLINE_MSG_PROP_TYPE_I2
		public ushort wordData 
		{
			get{ return _data;  }
			set{ _data = value; }
		}
		
		// For type XONLINE_MSG_PROP_TYPE_I1
		public byte byteData 
		{
			get{ return (byte)_data; }
			set{ _data = value;      }
		}

		// For type XONLINE_MSG_PROP_TYPE_BOOL
		public bool boolData 
		{
			get{ return _data == 1;       }
			set{ _data = (ushort)(value ? 1 : 0); }
		}
	
		// For all other types the offset from the start of MsgDeatails property data blob 
		public ushort offset 
		{
			get{ return _data;  }
			set{ _data = value; }
		}

        public static MsgPropertyWrapped NULLProperty()
        {
            return NULLProperty(1 | (XonPresNoti.MSG_PROP_TYPE_NULL << 8));
        }
        public static MsgPropertyWrapped NULLProperty(ushort tag)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.data = 0;
            return prop;
        }

        public static MsgPropertyWrapped I1Property(byte data)
        {
            return I1Property(1 | (XonPresNoti.MSG_PROP_TYPE_I2 << 8), data);
        }
        public static MsgPropertyWrapped I1Property(ushort tag, byte data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.byteData = data;
            return prop;
        }

        public static MsgPropertyWrapped I2Property(ushort data)
        {
            return I2Property(1 | (XonPresNoti.MSG_PROP_TYPE_I2 << 8), data);
        }
        public static MsgPropertyWrapped I2Property(ushort tag, ushort data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.wordData = data;
            return prop;
        }

        public static MsgPropertyWrapped I4Property(uint data)
        {
            return I4Property(1 | (XonPresNoti.MSG_PROP_TYPE_I4 << 8), data);
        }
        public static MsgPropertyWrapped I4Property(ushort tag, uint data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(4);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        public static MsgPropertyWrapped I8Property(ulong data)
        {
            return I8Property(1 | (XonPresNoti.MSG_PROP_TYPE_I8 << 8), data);
        }
        public static MsgPropertyWrapped I8Property(ushort tag, ulong data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(8);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        public static MsgPropertyWrapped StringProperty(string data)
        {
            return StringProperty(1 | (XonPresNoti.MSG_PROP_TYPE_STRING << 8), data);
        }
        public static MsgPropertyWrapped StringProperty(ushort tag, string data)
        {
            MsgPropertyString str = new MsgPropertyString();
            str.sLen = (ushort)data.Length;
            str.s = data;

            MsgPropertyWrapped prop = new MsgPropertyWrapped(str);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped FileTimeProperty(DateTime data)
        {
            return FileTimeProperty(1 | (XonPresNoti.MSG_PROP_TYPE_FILETIME << 8), data);
        }
        public static MsgPropertyWrapped FileTimeProperty(ushort tag, DateTime data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(8);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data.ToFileTime());
            return prop;
        }

        public static MsgPropertyWrapped BinaryProperty(byte [] data)
        {
            return BinaryProperty(1 | (XonPresNoti.MSG_PROP_TYPE_BINARY << 8), data);
        }

        public static MsgPropertyWrapped BinaryProperty(ushort tag, byte[] data)
        {
            MsgPropertyBinary binary = new MsgPropertyBinary();
            binary.dataLen = (ushort)data.Length;
            binary.data = data;
                
            MsgPropertyWrapped prop = new MsgPropertyWrapped(binary);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped AttachmentProperty(uint cbAttach, uint dwFlags, string url)
        {
            return AttachmentProperty(1 | (XonPresNoti.MSG_PROP_TYPE_ATTACHMENT << 8), cbAttach, dwFlags, url);
        }

        public static MsgPropertyWrapped AttachmentProperty(ushort tag, uint cbAttach, uint dwFlags, string url)
        {
            MsgPropertyAttachment attachment = new MsgPropertyAttachment();
            attachment.cbAttach = cbAttach;
            attachment.dwFlags = dwFlags;
            attachment.urlLen = (uint)url.Length;
            attachment.url = url;

            MsgPropertyWrapped prop = new MsgPropertyWrapped(attachment);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            return prop;
        }

        public static MsgPropertyWrapped BoolProperty(bool data)
        {
            return BoolProperty(1 | (XonPresNoti.MSG_PROP_TYPE_BOOL << 8), data);
        }
        public static MsgPropertyWrapped BoolProperty(ushort tag, bool data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(0);
            prop.tag = tag;
            prop.boolData = data;
            return prop;
        }
        
        public static MsgPropertyWrapped StringIdProperty(uint data)
        {
            return StringIdProperty(1 | (XonPresNoti.MSG_PROP_TYPE_STRING_ID << 8), data);
        }
        public static MsgPropertyWrapped StringIdProperty(ushort tag, uint data)
        {
            MsgPropertyWrapped prop = new MsgPropertyWrapped(4);
            prop.tag = tag;
            prop.data = MsgProperty.size;
            prop.GetWriter().Write(data);
            return prop;
        }

        /// <summary>
        /// Do a specific read for the type of data stored in this property. If it
        /// exists outside this property than it must preceed this property in the
        /// stream. This is the case for msg properties passed as parameters in
        /// wire protocol. For handling a group of properties in a details blob
        /// use MsgDetails.GetPropertyData() which can handle the stream seek and object
        /// conversion.
        /// </summary>
        public byte[] ReadExtraData(BinaryReader reader)
        {
            byte []exdata = new byte[0];

            switch(wPropTag.type)
			{
				case XonPresNoti.MSG_PROP_TYPE_NULL:
				case XonPresNoti.MSG_PROP_TYPE_BOOL:
				case XonPresNoti.MSG_PROP_TYPE_I1:
				case XonPresNoti.MSG_PROP_TYPE_I2:
                    // Types under 2 bytes are stored directly in the property data
                    break;
				case XonPresNoti.MSG_PROP_TYPE_I4:
				case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    exdata = reader.ReadBytes(4);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_FILETIME:
				case XonPresNoti.MSG_PROP_TYPE_I8:
                    exdata = reader.ReadBytes(8);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_STRING:
                    MsgPropertyString propString = new MsgPropertyString();
                    exdata = (byte[])propString.ReadStream(reader);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_BINARY:
					MsgPropertyBinary propBinary = new MsgPropertyBinary();
					exdata = (byte[])propBinary.ReadStream(reader);
                    break;
				case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
					MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
					exdata = (byte[])propAttach.ReadStream(reader);
					break;
				default:
					throw new Exception( "Invalid property type:  " + wPropTag.type.ToString("x"));
			}

            return exdata;
        }
	}

    /// <summary>
    ///  Wraps a message property with some extra data to hold
    ///  the actual property data. This can be used for passing
    ///  around properties and using them for parameters to APIs
    ///  such as RevokeMsgEx
    /// </summary>
    public class MsgPropertyWrapped : WireData
    {
        public MsgProperty Property;
        [WireInfo(ArraySize=0)]
        public byte[]      ExtraData;

        public ushort tag {
            get { return Property.tag; }
            set { Property.tag = value; }
        }

        public ushort data {
            get { return Property.data; }
            set { Property.data = value; }
        }

        public byte byteData {
            get { return Property.byteData; }
            set { Property.byteData = value; }
        }

        public ushort wordData {
            get { return Property.wordData; }
            set { Property.wordData = value; }
        }

        public bool boolData {
            get { return Property.boolData; }
            set { Property.boolData = value; }
        }

        public byte type {
            get { return Property.type; }
        }

        /// <summary>
        /// Create the wrapped msg property, allocate cb extra
        /// bytes for the payload.
        /// </summary>
        public MsgPropertyWrapped(uint cb)
        {
            Property  = new MsgProperty();
            ExtraData = new byte[cb];
        }

        /// <summary>
        /// Create the wrapped message property, the extra
        /// wire data will be serialized new into the payload
        /// of this property.
        /// </summary>
        public MsgPropertyWrapped(WireData extraWireData)
        {
            Property = new MsgProperty();

            // Allocate the extra buffer to hold the wiredata
            // and serialize into this buffer
            uint cbytes = (uint)extraWireData.Size();
            ExtraData = new byte[cbytes];
            BinaryWriter writer = new BinaryWriter(new MemoryStream(ExtraData));
            extraWireData.WriteStream(writer);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            // Read the property object and get extra fixed or variable length
            // data stored after the property.
            Property.ReadStream(reader);
            ExtraData = Property.ReadExtraData(reader);
            return this;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            // Write the property and then the extra data
            // immediately after
            Property.WriteStream(writer);
            writer.Write(ExtraData);
        }

        /// <summary>
        /// Return a writer that allows writing to the allocated
        /// extra block. 
        /// </summary>
        public BinaryWriter GetWriter()
        {
            return new BinaryWriter(new MemoryStream(ExtraData), Encoding.UTF8);
        }
        /// <summary>
        /// Return a reader that allows reading from the
        /// extra block.
        /// </summary>
        public BinaryReader GetReader()
        {
            return new BinaryReader(new MemoryStream(ExtraData));
        }

    }

	/// <summary>
	/// Format of MSG_PROP_TYPE_BINARY property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyBinary : WireData
	{
		public ushort dataLen;
		public byte[] data;
	}

	/// <summary>
	/// Format of MSG_PROP_TYPE_ATTACHMENT property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyAttachment : WireData
	{
		public uint   cbAttach;
		public uint   dwFlags;
		public uint   urlLen;
		[WireInfo(NullTerminate=true)] 
		public string url;
	}

	/// <summary>
	/// Format of MSG_PROP_TYPE_STRING property found in MsgDetails property data blob
	/// </summary>
	public class MsgPropertyString : WireData
	{
		public ushort sLen;
        [WireInfo(NullTerminate = true)]
		public string s;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\MsgDetails.cs ===
// MsgDetails.cs
//
//  Message details protocol data
//

using System;
using System.IO;
using System.Text;
using System.Collections;

namespace live.protocol.Presence
{
    /// <summary>
    /// Message details data (a collection of Message Properties)
    /// </summary>
    public class MsgDetails : WireData
    {
        // Protocol Data
        public ushort        propertiesLen;
        public ushort        propertyDataLen;
        public MsgProperty[] properties;
        public byte[]        propertyData;

        /// <summary>
        /// Better than Size with a capital S that lives in WireData
        /// </summary>
        public ushort size 
        {
            get
            {
                if( _writePropList != null )
                {
                    return (ushort)(4 + (_writePropList.Count * MsgProperty.size) + _writeData.Length);
                }
                else
                {
                    return (ushort)(4 + (propertiesLen * MsgProperty.size) + propertyDataLen); 
                }
            }
        }

        // Dynamic storage used by "AddProperty" methods.
        private ArrayList    _writePropList = null;
        private MemoryStream _writeData     = null;
        private BinaryWriter _writer        = null;

        /// <summary>
        /// Create a blank set of message details that's ready to have properties added.
        /// Use of static factory, allows default constructor used by input serialization
        /// to not have to create the dynamic storage crap
        /// </summary>
        public static MsgDetails CreateBlank()
        {
            MsgDetails details      = new MsgDetails();
            details._writePropList  = new ArrayList();
            details._writeData      = new MemoryStream();
            details._writer         = new BinaryWriter( details._writeData, Encoding.UTF8 );
            details.properties      = new MsgProperty[0];
            details.propertyData    = new byte[0];

            return details;
        }

        /// <summary>
        /// Output serializion overload that first loads portocol data member variable form
        /// dynamic storage variable use by AddPorperty methods before calling base version
        /// </summary>
        /// <param name="binaryWriter">Output serializer</param>
        public override void WriteStream( BinaryWriter binaryWriter )
        {
            properties   = (MsgProperty[]) _writePropList.ToArray( typeof( MsgProperty ) );
            propertyData = _writeData.ToArray();

            base.WriteStream( binaryWriter );
        }


        /// <summary>
        /// Add a wrapped property type, the data will be extracted
        /// from the extra bytes and put into the details by way of 
        /// another AddProperty call with the stored type.
        /// </summary>
        public void AddProperty(MsgPropertyWrapped wrappedProperty)
        {
            BinaryReader reader = null;

            switch(wrappedProperty.type)
            {
                case XonPresNoti.MSG_PROP_TYPE_NULL:
                    AddProperty(wrappedProperty.tag);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_I1:
                    AddProperty(wrappedProperty.tag, wrappedProperty.byteData);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_I2:
                    AddProperty(wrappedProperty.tag, wrappedProperty.wordData);
                    break;;
                
                case XonPresNoti.MSG_PROP_TYPE_I4:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt32());
                    break;
                
                case XonPresNoti.MSG_PROP_TYPE_I8:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt64());
                    break;
                
                case XonPresNoti.MSG_PROP_TYPE_STRING:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyString propString = new MsgPropertyString();
                    propString.ReadStream( reader );
                    AddProperty(wrappedProperty.tag, propString.s);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_FILETIME:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, DateTime.FromFileTime(reader.ReadInt64()));
                    break;

                case XonPresNoti.MSG_PROP_TYPE_BINARY:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyBinary propBinary = new MsgPropertyBinary();
                    propBinary.ReadStream(reader);
                    AddProperty(wrappedProperty.tag, propBinary.data);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
                    reader = wrappedProperty.GetReader();
                    MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
                    propAttach.ReadStream( reader );
                    AddProperty(wrappedProperty.tag, propAttach.cbAttach, propAttach.dwFlags, propAttach.url);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_BOOL:
                    AddProperty(wrappedProperty.tag, wrappedProperty.boolData);
                    break;

                case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    reader = wrappedProperty.GetReader();
                    AddProperty(wrappedProperty.tag, reader.ReadUInt32());
                    break;

                default:
                    throw new Exception( "Can't convert wrapped property, invalid property type: " + wrappedProperty.type);
            } 
        }

        /// <summary>
        /// Add an empty property
        /// </summary>
        /// <param name="tag">Property tag</param>
        public void AddProperty( ushort tag ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.data         = 0;

            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add an 8-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u8">8-bit value</param>
        public void AddProperty( ushort tag, byte u8 ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.byteData     = u8;

            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add a 16-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u16">16-bit value</param>
        public void AddProperty( ushort tag, ushort u16 ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.wordData     = u16;

            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add a 32-bit property
        /// (Also works for String Server ID's)
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u32">32-bit value</param>
        public void AddProperty( ushort tag, uint u32 ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( u32 );
            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add a 64-bit property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="u64">64-bit value</param>
        public void AddProperty( ushort tag, ulong u64 ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( u64 );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a string property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="sz">String value</param>
        public void AddProperty( ushort tag, string sz ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyString propString = new MsgPropertyString();
            propString.s = sz;

            propString.WriteStream( _writer );
            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add a DataTime property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="dt">DateTime value</param>
        public void AddProperty( ushort tag, DateTime dt ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            _writer.Write( dt.ToFileTime() );
            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add a Binary Blob property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="blob">Binary array</param>
        public void AddProperty( ushort tag, byte[] blob ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyBinary propBinary = new MsgPropertyBinary();
            propBinary.data = blob;

            propBinary.WriteStream( _writer );
            _writePropList.Add( prop );
        }
        
        /// <summary>
        /// Add an Attachment property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="size"></param>
        /// <param name="flags"></param>
        /// <param name="url"></param>
        public void AddProperty( ushort tag, uint size, uint flags, string url ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.offset       = (ushort)_writeData.Length;

            MsgPropertyAttachment propAttachment = new MsgPropertyAttachment();
            propAttachment.cbAttach = size;
            propAttachment.dwFlags  = flags;
            propAttachment.url      = url;

            propAttachment.WriteStream( _writer );
            _writePropList.Add( prop );
        }

        /// <summary>
        /// Add a Bool property
        /// </summary>
        /// <param name="tag">Property tag</param>
        /// <param name="b">Bool value</param>
        public void AddProperty( ushort tag, bool b ) 
        {
            MsgProperty prop  = new MsgProperty();
            prop.wPropTag.tag = tag;
            prop.boolData     = b;

            _writePropList.Add( prop );
        }

        // Wraps binary property data blob for use by "Get" methodes
        private MemoryStream _propData = null;
        private BinaryReader _reader   = null;

        /// <summary>
        /// Input serialization that first loads up the protocol data members then set up 
        /// buffer/reader wrapper for binary data blob
        /// </summary>
        /// <param name="binaryReader">Input serializer</param>
        /// <returns>Self</returns>
        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            _propData = new MemoryStream( propertyData );
            _reader   = new BinaryReader( _propData, Encoding.UTF8 );

            return this;
        }

        /// <summary>
        /// Checks if a Null type property is present.  Because this type of property has no data all
        /// we can do is see if it's there
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>true if property found and type is null</returns>
        public bool HasNullProperty( ushort tag )
        {
            try
            {
                byte index = GetPropertyIndex( tag );
                if( XonPresNoti.MSG_PROP_TYPE_NULL == properties[index].wPropTag.type )
                {
                    return true;
                }
            }
            catch( InvalidMsgPropertyException ) {}

            return false;
        }

        /// <summary>
        /// Returns the byte value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public byte GetByteProperty( ushort tag )
        {
            return (byte)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I1 );
        }

        /// <summary>
        /// Returns the word value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public ushort GetWordProperty( ushort tag )
        {
            return (ushort)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I2 );
        }

        /// <summary>
        /// Returns the dword value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public uint GetDwordProperty( ushort tag )
        {
            return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I4 );
        }

        /// <summary>
        /// Returns the qword value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public ulong GetQwordProperty( ushort tag )
        {
            return (ulong)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_I8 );
        }

        /// <summary>
        /// Returns the string value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public string GetStringProperty( ushort tag )
        {
            return (string)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING );
        }

        /// <summary>
        /// Returns the DateTime value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public DateTime GetDateTimeProperty( ushort tag )
        {
            return (DateTime)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_FILETIME );
        }

        /// <summary>
        /// Returns the byte array value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public byte[] GetBinaryProperty( ushort tag )
        {
            return (byte[])GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BINARY );
        }

        /// <summary>
        /// Returns the Attachment info value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public MsgPropertyAttachment GetAttachmentProperty( ushort tag )
        {
            return (MsgPropertyAttachment)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_ATTACHMENT );
        }

        /// <summary>
        /// Returns the boolean value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public bool GetBoolProperty( ushort tag )
        {
            return (bool)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_BOOL );
        }

        /// <summary>
        /// Returns the String ID value of the property with the given tag
        /// </summary>
        /// <param name="index">Property tag</param>
        /// <returns>Value of property </returns>
        public uint GetStringIdProperty( ushort tag )
        {
            return (uint)GetPropertyData( GetPropertyIndex( tag ), XonPresNoti.MSG_PROP_TYPE_STRING_ID );
        }
        
        /// <summary>
        /// Finds the index of a given property tag in the properties list
        /// </summary>
        /// <param name="tag">Property Id</param>
        /// <returns>Index into properties list</returns>
        public byte GetPropertyIndex( ushort tag )
        {
            for( byte i = 0; i < properties.Length; ++i )
            {
                if( properties[i].wPropTag.tag == tag )
                {
                    return i;
                }
            }
            
            throw new InvalidMsgPropertyException( null, "Msg Prop "+tag.ToString( "4X" )+" Not Found" );
        }

        public MsgProperty GetProperty(ushort tag)
        {
            for(byte i = 0; i < properties.Length; ++i)
            {
                if(properties[i].wPropTag.tag == tag)
                {
                    return properties[i];
                }
            }
            throw new InvalidMsgPropertyException( null, "Msg Prop "+tag.ToString( "4X" )+" Not Found" );
        }
                
        /// <summary>
        /// Returns the value of the property at given index as the type indicated in the property tag
        /// </summary>
        /// <param name="index">Index into MsgProperty array</param>
        /// <returns>Value of property in type specified by index</returns>
        public object GetPropertyData( byte index, byte type )
        {
            if( index >= properties.Length )
                throw new ArgumentOutOfRangeException( "index" );

            if( type != properties[index].wPropTag.type )
            {
                throw new InvalidMsgPropertyException( properties[index], 
                    "Msg Prop "+properties[index].wPropTag.tag.ToString( "4X" )+" Invalid - "+
                    "Expected type: "+type+", Got type: "+properties[index].wPropTag.type );
            }

            // Create the reader if it doesn't exist yet
            if(null == _reader)
            {
                _propData = new MemoryStream( propertyData );
                _reader   = new BinaryReader( _propData, Encoding.UTF8 );
            }

            switch( type )
            {
                case XonPresNoti.MSG_PROP_TYPE_NULL:
                    throw new Exception( "Can't Get Property Data, Null properties have no value" );

                case XonPresNoti.MSG_PROP_TYPE_I1:
                    return properties[index].byteData;

                case XonPresNoti.MSG_PROP_TYPE_I2:
                    return properties[index].wordData;
                
                case XonPresNoti.MSG_PROP_TYPE_I4:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt32();
                
                case XonPresNoti.MSG_PROP_TYPE_I8:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt64();
                
                case XonPresNoti.MSG_PROP_TYPE_STRING:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyString propString = new MsgPropertyString();
                    propString.ReadStream( _reader );
                    return propString.s;

                case XonPresNoti.MSG_PROP_TYPE_FILETIME:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return DateTime.FromFileTime( _reader.ReadInt64() );

                case XonPresNoti.MSG_PROP_TYPE_BINARY:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyBinary propBinary = new MsgPropertyBinary();
                    propBinary.ReadStream( _reader );
                    return propBinary.data;

                case XonPresNoti.MSG_PROP_TYPE_ATTACHMENT:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    MsgPropertyAttachment propAttach = new MsgPropertyAttachment();
                    propAttach.ReadStream( _reader );
                    return propAttach;

                case XonPresNoti.MSG_PROP_TYPE_BOOL:
                    return properties[index].boolData;

                case XonPresNoti.MSG_PROP_TYPE_STRING_ID:
                    _reader.BaseStream.Seek( properties[index].offset, SeekOrigin.Begin );
                    return _reader.ReadUInt32();

                default:
                    throw new Exception( "Can't Get Property, Invalid Prop Type: "+properties[index].wPropTag.type );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAddBuddy.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgAddBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor, defaults to old style add, by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		public PMsgAddBuddy( PNState user, PNState buddy ) 
			: this( user, buddy, false ) 
		{} 

		//////////////////////////////////////
		/// <summary>
		/// Constructor, defaults to old style add 
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="byName">Ask using buddy name instead of PUID</param>
		public PMsgAddBuddy( PNState user, PNState buddy, bool byName ) 
			: this( user, buddy, 0, null, byName )
		{}

		//////////////////////////////////////
		/// <summary>
		/// Constructor, allows flags and details for add2, defaults to add by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		public PMsgAddBuddy( PNState user, PNState buddy, uint flags, MsgDetails details ) 
			: this( user, buddy, flags, details, false ) 
		{} 

		/// <summary>
		/// Constructor, allows flags and details for add2, defaults to add by PUID
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddy">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		/// <param name="byName">Ask using buddy name instead of PUID</param>
		public PMsgAddBuddy( PNState user, PNState buddy, uint flags, MsgDetails details, bool byName ) 
			: this( user, 
					byName ? 0 : buddy.UserId, 
					byName ? buddy.Name : null,
					flags, 
					details )
		{}

		/// <summary>
		/// Constructor, buddyId or buddyName can be specified. Leave
		/// the either of them blank to change the behavior (add by name, add by id)
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddyId">User being asked to be buddies</param>
		/// <param name="buddyName">User being asked to be buddies</param>
		public PMsgAddBuddy( PNState user, ulong buddyId, string buddyName)
			: this( user, buddyId, buddyName, 0, null)
		{}

		/// <summary>
		/// Constructor, allows flags and details for add2, buddyId or buddyName can be specified. Leave
		/// the either of them blank to change the behavior (add by name, add by id)
		/// </summary>
		/// <param name="user">User asking to be buddies</param>
		/// <param name="buddyId">User being asked to be buddies</param>
		/// <param name="buddyName">User being asked to be buddies</param>
		/// <param name="flags">Message flags</param>
		/// <param name="details">Message details</param>
		public PMsgAddBuddy( PNState user, ulong buddyId, string buddyName, uint flags, MsgDetails details)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			if( details == null )
			{
				Msg.Hdr.MsgType = XonPresNoti.PMSG_ADD;
				PAddBuddyMsgData data = new PAddBuddyMsgData();

				data.UserID       = user.UserId;
				data.BuddyID      = buddyId;
				data.BuddyName    = buddyName;

				Msg.Data          = data;
			}
			else
			{
				Msg.Hdr.MsgType = XonPresNoti.PMSG_ADD_2;
				PAddBuddyMsgData2 data = new PAddBuddyMsgData2();

				data.UserID       = user.UserId;
				data.BuddyID      = buddyId;
				data.BuddyName    = buddyName;

				data.Details      = details;
				data.cbDetails    = details.size;
				data.MessageFlags = flags;

				Msg.Data          = data;
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add buddy request
	/// </summary>
	public class PAddBuddyMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  BuddyID;
		public ushort BuddyNameLen;
		public string BuddyName; // ASCII Null terminated, only used if qwBuddyID == 0
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add buddy 2 request
	/// </summary>
	public class PAddBuddyMsgData2 : PNMsgData
	{
		public ulong      UserID;
		public ulong      BuddyID;
		public uint       MessageFlags;
		public ushort     cbDetails;
		[WireInfo(ArraySize=16)] // XONLINE_GAMERTAG_SIZE
		public string     BuddyName; // ASCII Null terminated, only used if qwBuddyID == 0
		public MsgDetails Details;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAddAffiliates.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgAddAffiliates : PNRequestMsg
	{
        public PMsgAddAffiliates( PNState user, uint dwFlags, uint dwTitleId, PNState[] pnuAffiliates ) 
        {
            ulong[] Affiliates = new ulong[pnuAffiliates.Length];
            for (int i=0; i<pnuAffiliates.Length; i++)
            {
                Affiliates[i] = pnuAffiliates[i].UserId;
            }
            this.Initialize(user, dwFlags, dwTitleId, Affiliates);
        }
        public PMsgAddAffiliates( PNState user, uint dwFlags, uint dwTitleId, ulong[] Affiliates )
        {
            this.Initialize(user, dwFlags, dwTitleId, Affiliates);
        }
        private void Initialize( PNState user, uint dwFlags, uint dwTitleId, ulong[] Affiliates ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			Msg.Hdr.MsgType = XonPresNoti.PMSG_ADD_AFFILIATES;
			PAddAffiliatesMsgData data = new PAddAffiliatesMsgData();

			data.qwSenderID = user.UserId;
			data.dwMessageFlags = dwFlags;
			data.dwTitleID = dwTitleId;
			data.cwAffiliates = (ushort)(Affiliates.Length);
            data.pqwAffiliates = Affiliates;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AddAffiliates request
	/// </summary>
	public class PAddAffiliatesMsgData : PNMsgData
	{
            public ulong            qwSenderID;
            public uint               dwMessageFlags;
            public uint               dwTitleID;
            public ushort           cwAffiliates;
     
            [WireInfo(SizeParam="cwAffiliates")]
            public ulong[]          pqwAffiliates;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAlive.cs ===
// PMsgAlive.cs
//
//	Presence Alive Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	The pre aftershock way to establish a user's Presence in the system. 
	///	Translated to P_ALIVE_INTERNAL_MSG by the Front Door. Old unused fields were 
	/// kept for client compatability, but they've never actually been relied upon
	/// </summary>
	public class PMsgAlive : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAlive( PNState user ) 
		{
			SentFrom      = Requestor.Client;
			PortOnFD      = FDPort.PresNoti;
			AuthMethod    = FDAuth.SGMsg;
			ServiceOnFD   = FDService.Presence;
			ClientVersion = user.Client.ClientVersion;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PAliveMsgData data = new PAliveMsgData();
			data.UserID           = user.UserId;
			data.TitleID          = user.Xbox.TitleId;
			data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
			data.State            = XonPresNoti.P_STATE_MASK_ONLINE | 
				                    XonPresNoti.P_STATE_MASK_CLOAKED;           
			data.MatchSessionID   = 0;           // dropped 
			data.AcctName         = user.Name;
			data.TitleStuff       = new byte[0]; // dropped 
			data.Nickname         = new byte[0]; // dropped 
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Alive request
	/// </summary>
	public class PAliveMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint   TitleID;
		[WireInfo(NullTerminate=true)]
		public ushort AcctNameLen;
		public uint   BuddyListVersion;
		public uint   BlockListVersion;
		public uint   State;            // const: (P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED)
		public ulong  MatchSessionID;   // Must be zero
		public ushort NicknameLen;      // Must be zero
		public ushort TitleStuffLen;    // Must be xero
		[WireInfo(NullTerminate=true)] 
		public string AcctName;
		public byte[] TitleStuff;
		public byte[] Nickname;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to all Alive replies
	/// </summary>
	public class PAliveReplyMsgData : PNMsgData
	{
		public uint        HR;
		public uint        BuddyListVersion;
		public ushort      BuddiesLen;
		public uint        BlockListVersion;
		public ushort      BlocksLen;
		public BuddyData[] Buddies;
		public ulong[]     Blocks;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Buddy data included in Alive replies
	/// </summary>
	public class BuddyData : WireData
	{
		public ulong  BuddyID;
		public ushort NameLen;
		public byte   Status; // const: P_BUDDY_STATUS_xxx
		public string Name;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgCancelInvite.cs ===
// PMsgCancelInvite.cs
//
//	Presence Cancel Game Invite Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Cancel invitaion of 1 or more users to a particular session
	/// </summary>
	public class PMsgCancelInvite : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User canceling invitation</param>
		/// <param name="buddies">Array of buddies getting uninvited</param>
		public PMsgCancelInvite( PNState user, PNState[] buddies ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_CANCEL;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PCancelInviteMsgData data = new PCancelInviteMsgData();
			data.UserID         = user.UserId;
			data.MatchSessionID = user.MatchSessionId;
			data.Invitees       = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Cancel invite request
	/// </summary>
	public class PCancelInviteMsgData : PNMsgData
	{
		public ulong   UserID;
		public ulong   MatchSessionID;
		public ushort  InviteesLen;
		public ulong[] Invitees;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgCheckTitleMessages.cs ===
// PMsgCheckTitleMessages.cs
//
//	Presence CheckTitleMessages Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgCheckTitleMessages : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgCheckTitleMessages( PNState user, uint dwTitleId, uint dwTitleRegion ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_CHECK_TITLE_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PCheckTitleMessagesMsgData data = new PCheckTitleMessagesMsgData();
			data.UserID = user.UserId;
			data.TitleID = dwTitleId;
			data.TitleRegion = dwTitleRegion;
			data.AltTitleID1 = 0;
			data.AltTitleID2 = 0;
			data.AltTitleID3 = 0;
			data.AltTitleID4 = 0;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PCheckTitleMessagesMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint  TitleID;
		public uint  AltTitleID1;
		public uint  AltTitleID2;
		public uint  AltTitleID3;
		public uint  AltTitleID4;
		public uint  TitleVersion;
		public uint  TitleRegion;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PCheckTitleMessagesReplyMsgData : PNMsgData
	{
		public uint        HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgBlockVoice.cs ===
// PMsgBlockVoice.cs
//
//	Presence Block voice (Mute) Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Add a user to my block (mute) list
	/// </summary>
	public class PMsgBlockVoice : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		/// <param name="block">User being blocked</param>
		public PMsgBlockVoice( PNState user, PNState block ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_BLOCK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PBlockVoiceMsgData data = new PBlockVoiceMsgData();
			data.UserID  = user.UserId;
			data.BlockID = block.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Block voice request
	/// </summary>
	public class PBlockVoiceMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BlockID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAlive2.cs ===
// PMsgAlive2.cs
//
//	Presence Alive Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	The post aftershock way to establish a user's Presence in the system. 
	///	Translated to P_ALIVE_INTERNAL_MSG by the Front Door. 
	/// </summary>
	public class PMsgAlive2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAlive2( PNState user ) 
		{
			SentFrom      = Requestor.Client;
			PortOnFD      = FDPort.PresNoti;
			AuthMethod    = FDAuth.SGMsg;
			ServiceOnFD   = FDService.Presence;
			ClientVersion = user.Client.ClientVersion;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PAlive2MsgData data = new PAlive2MsgData();
			data.UserID           = user.UserId;
            data.xnaddr           = new XNADDR();//user.Client.XnAddr;
            data.xnkid            = new XNKID(); //user.Client.XnKId;
            data.xnkey            = new XNKEY(); // user.Client.XnKey;
			data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
			data.ClientVersion    = user.Client.ClientVersion;
			data.TitleID          = user.Xbox.TitleId;
            data.TitleVersion     = 0; // user.Xbox.TitleVer;
            data.TitleRegion      = 1; // user.Xbox.TitleRegion;
			data.PortI            = 0; // TBD!!
			data.IpI              = 0; // TBD!!
			data.Nonce            = 0; // TBD!!
			data.TimeInit         = DateTime.Now;
			data.AcctName         = user.Name;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Alive_2 request
	/// </summary>
	public class PAlive2MsgData : PNMsgData
	{
		public ulong    UserID;
		[WireInfo(NullTerminate=true)]
		public ushort   AcctNameLen;
		public XNADDR   xnaddr;
		public XNKID    xnkid;
		public XNKEY    xnkey;
		public uint     BuddyListVersion;
		public uint     BlockListVersion;
		public ulong    ClientVersion; // XBOX_LIBRARY_VERSION
		public uint     TitleID;
		public uint     TitleVersion;
		public uint     TitleRegion;
		public ushort   PortI; 
		public uint     IpI; // IN_ADDR 
		public long     Nonce; 
		public DateTime TimeInit; // FILETIME
		[WireInfo(NullTerminate=true)]
		public string   AcctName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgDeleteBuddy.cs ===
// PMsgDeleteBuddy.cs
//
//	Presence Delete Buddy Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete a buddy from my buddy list
	/// </summary>
	public class PMsgDeleteBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User deleting the buddy</param>
		/// <param name="buddy">Buddy being deleted</param>
		public PMsgDeleteBuddy( PNState user, PNState buddy ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DELETE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PDeleteBuddyMsgData data = new PDeleteBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete buddy request
	/// </summary>
	public class PDeleteBuddyMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BuddyID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgAliveInternal.cs ===
// PMsgAlive.cs
//
//	Presence Alive Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Establishes the user's Presence in the system.  This version of alive only goes from 
	/// FD to INH. FD maps what it can from client alives and adds SG session data such as 
	/// alternate title ID's and client winsockx enpoint info.
	/// </summary>
	public class PMsgAliveInternal : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User being logged in</param>
		public PMsgAliveInternal( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_ALIVE_INTERNAL;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PAliveInternalMsgData data = new PAliveInternalMsgData();
			data.UserID           = user.UserId;
            data.xnaddr           = new XNADDR();//user.Client.XnAddr;
            data.xnkid            = new XNKID(); //user.Client.XnKId;
            data.xnkey            = new XNKEY(); // user.Client.XnKey;
            data.BuddyListVersion = user.BuddyListVer;
			data.BlockListVersion = user.BlockListVer;
			data.ClientVersion    = user.Client.ClientVersion;
			data.TitleID          = user.Xbox.TitleId;
			data.AltTitleID1      = 0; // TBD!!
			data.AltTitleID2      = 0; // TBD!!
			data.AltTitleID3      = 0; // TBD!!
			data.AltTitleID4      = 0; // TBD!!
            data.TitleVersion     = 0; //user.Client.TitleVer;
            data.TitleRegion      = 1; // user.Client.TitleRegion;
			data.PortI            = 0; // TBD!!
			data.IpI              = 0; // TBD!!
			data.Nonce            = 0; // TBD!!
			data.TimeInit         = DateTime.Now;
			data.AcctName         = user.Name;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AliveInternal request
	/// </summary>
	public class PAliveInternalMsgData : PNMsgData
	{
		public ulong    UserID;
		[WireInfo(NullTerminate=true)]
		public ushort   AcctNameLen;
		public XNADDR   xnaddr;
		public XNKID    xnkid;
		public XNKEY    xnkey;
		public uint     BuddyListVersion;
		public uint     BlockListVersion;
		public ulong    ClientVersion; // XBOX_LIBRARY_VERSION
		public uint     TitleID;
		public uint     AltTitleID1;
		public uint     AltTitleID2;
		public uint     AltTitleID3;
		public uint     AltTitleID4;
		public uint     TitleVersion;
		public uint     TitleRegion;
		public ushort   PortI; 
		public uint     IpI; // IN_ADDR 
		public long     Nonce; 
		public DateTime TimeInit; // FILETIME
		[WireInfo(NullTerminate=true)]
		public string   AcctName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgDeleteTeam.cs ===
// PMsgDeleteTeam.cs
//
//	Presence Delete Team Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete a team
	/// </summary>
	public class PMsgDeleteTeam : PNRequestMsg
	{

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User deleting team</param>
		/// <param name="team">Team being deleted</param>
		public PMsgDeleteTeam( PNState user, Team team ) 
			: this( user, team.TitleId, team.Id ) {}
		
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User deleting team</param>
		/// <param name="titleId">Title team belongs too</param>
		/// <param name="teamId">Id of team being deleted</param>
		public PMsgDeleteTeam( PNState user, uint titleId, ulong teamId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_DELETE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PDeleteTeamMsgData data = new PDeleteTeamMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			data.TeamID  = teamId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Team request
	/// </summary>
	public class PDeleteTeamMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  TitleID;
		public ulong TeamID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Team replies
	/// </summary>
	public class PDeleteTeamReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgCreateTeam.cs ===
// PMsgCreateTeam.cs
//
//	Presence Create Team Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Create a new team
	/// </summary>
	public class PMsgCreateTeam : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor, current logged on title
		/// </summary>
		/// <param name="user">User doing the creating</param>
		/// <param name="team">Team being created</param>
		/// <param name="creator">TeamMember doing the creating</param>
		public PMsgCreateTeam( PNState user, Team team, TeamMember creator ) 
			: this( user, user.Xbox.TitleId, team, creator ) {}

		//////////////////////////////////////
		/// <summary>
		/// Constructor, specific (alt) title
		/// </summary>
		/// <param name="user">User doing the creating</param>
		/// <param name="titleId">Title (perhaps alt title) creating team for</param>
		/// <param name="team">Team being created</param>
		/// <param name="creator">TeamMember doing the creating</param>
		public PMsgCreateTeam( PNState user, uint titleId, Team team, TeamMember creator ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_CREATE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PCreateTeamMsgData data = new PCreateTeamMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = titleId;
			data.MaxMembers      = team.MaxMembers;
			data.TeamName        = team.Name;
			data.TeamDescription = team.Description;
			data.TeamMotto       = team.Motto;
			data.TeamURL         = team.Url;
			data.TeamData        = team.Data;
			data.CreatorData     = creator.Data;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Create Team request
	/// </summary>
	public class PCreateTeamMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint   TitleID;
        public uint   MaxMembers;
		public ushort TeamNameLen;
		public ushort TeamDescriptionLen;
		public ushort TeamMottoLen;
		public ushort TeamURLLen;
		public ushort TeamDataLen;
		public ushort CreatorDataLen;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        public string TeamName;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        public string TeamDescription;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        public string TeamMotto;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        public string TeamURL;
		public byte[] TeamData; 
		public byte[] CreatorData;

        public override void WriteStream(System.IO.BinaryWriter binaryWriter)
        {
            binaryWriter.Write(UserID);
            binaryWriter.Write(TitleID);
            binaryWriter.Write(MaxMembers);
            
            byte[] TeamNameBytesNN = System.Text.UnicodeEncoding.Unicode.GetBytes(TeamName);
            byte[] TeamNameBytes = new byte[TeamNameBytesNN.Length + 2];
            TeamNameBytesNN.CopyTo(TeamNameBytes, 0);
            binaryWriter.Write((ushort)TeamNameBytes.Length);
            
            byte[] TeamDescriptionBytesNN = System.Text.UnicodeEncoding.Unicode.GetBytes(TeamDescription);
            byte[] TeamDescriptionBytes = new byte[TeamDescriptionBytesNN.Length + 2];
            TeamDescriptionBytesNN.CopyTo(TeamDescriptionBytes, 0);
            binaryWriter.Write((ushort)TeamDescriptionBytes.Length);

            byte[] TeamMottoBytesNN = System.Text.UnicodeEncoding.Unicode.GetBytes(TeamMotto);
            byte[] TeamMottoBytes = new byte[TeamMottoBytesNN.Length + 2];
            TeamMottoBytesNN.CopyTo(TeamMottoBytes, 0);
            binaryWriter.Write((ushort)TeamMottoBytes.Length);

            byte[] TeamURLBytesNN = System.Text.UnicodeEncoding.Unicode.GetBytes(TeamURL);
            byte[] TeamURLBytes = new byte[TeamURLBytesNN.Length + 2];
            TeamURLBytesNN.CopyTo(TeamURLBytes, 0);
            binaryWriter.Write((ushort)TeamURLBytes.Length);

            binaryWriter.Write((ushort)TeamData.Length);
            binaryWriter.Write((ushort)CreatorData.Length);
            binaryWriter.Write(TeamNameBytes);
            binaryWriter.Write(TeamDescriptionBytes);
            binaryWriter.Write(TeamMottoBytes);
            binaryWriter.Write(TeamURLBytes);
            binaryWriter.Write(TeamData);
            binaryWriter.Write(CreatorData);
        }
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Create Team replies
	/// </summary>
	public class PCreateTeamReplyMsgData : PNMsgData
	{
		public uint     HR;
		public ulong    TeamID;
		public DateTime WhenCreated;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgFindUser.cs ===
// PMsgFindUser.cs
//
//  Presence FindUser Message
//

using System;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Allows update of title specific data stored by Presence for a particular user. 
    /// Title initiates immediate update all the way to server. Because of this and the 
    /// potential for misuse this message has been phased out for new titles.
    /// </summary>
    public class PMsgFindUser : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgFindUser( PNState user, ulong puid, string gamertag ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_FIND_USER;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = live.server.Presence.PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId   = user.Client.MachinePuid;

            PFindUserMsgData data   = new PFindUserMsgData();
            data.UserID             = user.UserId;

            data.FindID             = puid;
            data.GamerTag           = gamertag;
            Msg.Data                = data;
        }
    }

    public class PMsgFindUsers : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgFindUsers( PNState user, ulong[] puids, string[] gamertags ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_FIND_USERS;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = live.server.Presence.PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId   = user.Client.MachinePuid;

            if (puids.Length != gamertags.Length)
            {
                throw new ArgumentException("puid and gamertag arrays must be identical lengths.");
            }

            PFindUsersMsgData data   = new PFindUsersMsgData();
            data.UserID             = user.UserId;
            data.cdwQueries = (uint)puids.Length;
            data.rgQueries = new PFindUsersData[puids.Length];

            for (int iQuery = 0; iQuery < puids.Length; iQuery++)
            {
                data.rgQueries[iQuery] = new PFindUsersData();
                data.rgQueries[iQuery].FindID = puids[iQuery];
                data.rgQueries[iQuery].GamerTag = gamertags[iQuery];
            }
            
            Msg.Data                = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUser request
    /// </summary>
    public class PFindUserMsgData : PNMsgData
    {
        public ulong    UserID;

        public ulong    FindID;         // UserID to find, 0 if use GamerTag
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user to find
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUser response
    /// </summary>
    public class PFindUserReplyMsgData : PNMsgData
    {
        public ulong    FoundID;        // PUID of found user. 0 if not found
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user found
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUsers request
    /// </summary>
    public class PFindUsersMsgData : PNMsgData
    {
        public ulong    UserID;
        public uint cdwQueries;
        [WireInfo(SizeParam="cdwQueries")]
        public PFindUsersData[] rgQueries;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to FindUsers response
    /// </summary>
    public class PFindUsersReplyMsgData : PNMsgData
    {
        public uint cdwResults;
        [WireInfo(SizeParam="cdwResults")]
        public PFindUsersData[] rgResults;
    }

    public class PFindUsersData : PNMsgData
    {
        public ulong    FindID;         // UserID to find, 0 if use GamerTag
        [WireInfo(ArraySize=16)]        // XONLINE_GAMERTAG_SIZE
        public string   GamerTag;       // ASCII Null terminated, user to find
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgInvalidateUser.cs ===
// PMsgInvalidateUser.cs
//
//  Presence InvalidateUser Message
//

using System;

namespace live.protocol.Presence
{
    /// <summary>
    /// Allows update of title specific data stored by Presence for a particular user. 
    /// Title initiates immediate update all the way to server. Because of this and the 
    /// potential for misuse this message has been phased out for new titles.
    /// </summary>
    public class PMsgInvalidateUser : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User who's data is being updated</param>
        /// <param name="nickname">new nickname data</param>
        public PMsgInvalidateUser( PNState user ) 
        {
            SentFrom                = Requestor.Client;
            PortOnFD                = FDPort.PresNoti_DC;
            AuthMethod              = FDAuth.SGMsg;
            ServiceOnFD             = FDService.Presence;

            Msg.Hdr                 = new PNMsgHdr();
            Msg.Hdr.MsgType         = XonPresNoti.PMSG_INVALIDATE_USER;
            Msg.Hdr.MsgLen          = 0;
            Msg.Hdr.SeqNum          = live.server.Presence.PresSeqNum;

            Msg.Hdr.Sgaddr          = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg    = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg    = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId   = user.Client.MachinePuid;

            PInvalidateUserMsgData data = new PInvalidateUserMsgData();
            data.UserID             = user.UserId;
            Msg.Data                = data;
        }
    }

    /// <summary>
    /// Message data specific to InvalidateUser request
    /// </summary>
    public class PInvalidateUserMsgData : PNMsgData
    {
        public ulong    UserID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgGetTeamTicket.cs ===
// PMsgGetTeamTicket.cs
//
//	Presence Get Team Ticket Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Join a team that user has been recruited to
	/// </summary>
	public class PMsgGetTeamTicket : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User asking for their team ticket</param>
		/// <param name="titleId">Title (perhaps alt title) getting ticket for</param>
		public PMsgGetTeamTicket( PNState user, uint titleId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_GET_TICKET;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PGetTeamTicketMsgData data = new PGetTeamTicketMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get Team Ticket request
	/// </summary>
	public class PGetTeamTicketMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get Team Ticket replies
	/// </summary>
	public class PGetTeamTicketReplyMsgData : PNMsgData
	{
		public uint       HR;
		public TeamTicket Ticket;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgInvite.cs ===
// PMsgInvite.cs
//
//	Presence Game Invite Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Invite 1 or more users to a title session
	/// </summary>
	public class PMsgInvite : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User sending the invitaion</param>
		/// <param name="buddies">Array of buddies being invited</param>
		public PMsgInvite( PNState user, PNState[] buddies ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PInviteMsgData data = new PInviteMsgData();
			data.UserID         = user.UserId;
			data.TitleID        = user.Xbox.TitleId;
			data.MatchSessionID = user.MatchSessionId;
            data.Invitees       = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite request
	/// </summary>
	public class PInviteMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint    TitleID;
		public ulong   MatchSessionID;
		public ushort  InviteesLen;
		public ulong[] Invitees;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Invite 1 or more users to a session, new version that supports messaging and team
	/// and competition invitations
	/// </summary>
	public class PMsgInvite2 : PNRequestMsg
	{
		public PMsgInvite2( PNState user, PNState[] buddies, ulong context, uint flags, MsgDetails details ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PInvite2MsgData data = new PInvite2MsgData();
			data.UserID        = user.UserId;
			data.SenderContext = context;
			data.TitleID       = user.Xbox.TitleId;
			data.MessageFlags  = flags;
            data.Invitees      = new ulong[ buddies.Length ];
			for( int i = 0; i< data.Invitees.Length; ++i )
			{
				data.Invitees[i] = buddies[i].UserId;
			}
			data.cbDetails = details.size;
			data.Details   = details;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite 2 request
	/// </summary>
	public class PInvite2MsgData : PNMsgData
	{
		public ulong      UserID;
		public ulong      SenderContext;
		public uint       TitleID;
		public uint	      MessageFlags;
		public ushort     InviteesLen;
		public ushort     cbDetails; 
		public ulong[]    Invitees;
		public MsgDetails Details;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgGetFriendsList.cs ===
using System;

namespace live.protocol.Presence
{    
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgGetFriendsList : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgGetFriendsList( PNState sender, PNState target ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_FRIENDS_LIST;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

            // Fill out the SGADDR so we can resolve the psuedo 
            // XBOX info from the FakeSG for creating HTTP auth
            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg = sender.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg = sender.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId = sender.Client.MachinePuid;

			PGetFriendsListMsgData data = new PGetFriendsListMsgData();
			data.SenderID = sender.UserId;
			data.TargetID = target.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PGetFriendsListMsgData : PNMsgData
	{
		public ulong  SenderID;
		public ulong  TargetID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PGetFriendsListReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
		public uint        Version;
		public uint      cdwFriends;
        
              [WireInfo(SizeParam="cdwFriends")]
		public GetFriendsListData[] rgFriends;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class GetFriendsListData : WireData
	{
		public ulong  BuddyID;
		public uint   Status;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgInviteAnswer.cs ===
// PMsgInviteAnswer.cs
//
//	Presence Game Invite Answer Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Single user answers an invitaion to a particular session
	/// </summary>
	public class PMsgInviteAnswer : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User responding to the invitation</param>
		/// <param name="host">Session host that made the invitaion</param>
		/// <param name="accept">Is invitaion accepted</param>
		public PMsgInviteAnswer( PNState user, PNState host, bool accept ) :
			this( user, host, (accept ? XonPresNoti.PINVITE_REPLY_YES : XonPresNoti.PINVITE_REPLY_NO) )
		{}
		
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User responding to the invitation</param>
		/// <param name="host">Session host that made the invitaion</param>
		/// <param name="reply">Reply code for yes, no, or never</param>
		public PMsgInviteAnswer( PNState user, PNState host, ushort reply ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_INVITE_ANSWER;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PInviteAnswerMsgData data = new PInviteAnswerMsgData();
			data.UserID         = user.UserId;
			data.HostID         = host.UserId;
			data.MatchSessionID = host.MatchSessionId;
			data.Answer         = reply;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Invite Answer request
	/// </summary>
	public class PInviteAnswerMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  HostID;
		public ulong  MatchSessionID;
		public ushort Answer; // const: PINVITE_REPLY_NO or PINVITE_REPLY_YES
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgGetPresenceInfo.cs ===
// PMsgWebFriends.cs
//
//	Presence Web Friends Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgGetPresenceInfo : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgGetPresenceInfo( PNState user, PNState target ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_PRESENCE_INFO;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;
                        
			PGetPresenceInfoMsgData data = new PGetPresenceInfoMsgData();
			data.dwContext = 0;
			data.qwSenderID = user.UserId;
			data.cdwUsers = 1;
			data.rgUsers = new ulong[1];
			data.rgUsers[0] = target.UserId;
            
			Msg.Data = data;
		}

		// Craft all fields of get presence info request
		public PMsgGetPresenceInfo(uint dwContext, ulong qwXboxId, ulong qwSenderId, uint cdwPuids, ulong[] rgqwPuids)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_GET_PRESENCE_INFO;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = qwXboxId;
                        
			PGetPresenceInfoMsgData data = new PGetPresenceInfoMsgData();
			data.dwContext = dwContext;
			data.qwSenderID = qwSenderId;
			data.cdwUsers = cdwPuids;
			data.rgUsers = rgqwPuids;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PGetPresenceInfoMsgData : PNMsgData
	{
            public uint dwContext;
            public ulong qwSenderID;
            public uint cdwUsers;

            [WireInfo(SizeParam="cdwUsers")]
            public ulong[] rgUsers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PPresenceInfoReplyMsgData : PNMsgData
	{
            public uint dwContext;
            public ulong qwSenderID;
            public uint cdwUsers;

            [WireInfo(SizeParam="cdwUsers")]
            public PresenceInfo[] rgUsers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class PresenceInfo : WireData
	{
		public ulong  SenderID;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ulong  qwSessionID;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgJoinTeam.cs ===
// PMsgJoinTeam.cs
//
//	Presence Join Team Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Join a team that user has been recruited to
	/// </summary>
	public class PMsgJoinTeam : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Xbox 1 style join constructor
		/// </summary>
		/// <param name="user">User replying to recruit msg</param>
		/// <param name="team">Team being recuited to</param>
		/// <param name="answer">Yes, No, or Never</param>
		/// <param name="recruitMsg">Recruit messaage user recieived, null if not known</param>
		public PMsgJoinTeam( PNState user, Team team, Team.JoinResponse answer, UserMessage recruitMsg ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_JOIN;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PJoinTeamMsgData data = new PJoinTeamMsgData();
			data.UserID       = user.UserId;
			data.TitleID      = team.TitleId;
			data.TeamID       = team.Id;
			data.RecruitMsgId = (recruitMsg != null) ? recruitMsg.ID : 0;
			switch( answer )
			{ 
				case Team.JoinResponse.Yes:   data.Answer = XonPresNoti.REPLY_YES;   break;
				case Team.JoinResponse.No:    data.Answer = XonPresNoti.REPLY_NO;    break;
				case Team.JoinResponse.Never: data.Answer = XonPresNoti.REPLY_NEVER; break;
				default:
					throw new ArgumentException( "oops", "answer" );
			}
			Msg.Data = data;
		}

		//////////////////////////////////////
		/// <summary>
		/// Xenon style join constructor (message-less)
		/// </summary>
		/// <param name="user">User replying to recruit msg</param>
		/// <param name="team">Team being recuited to</param>
		/// <param name="answer">Yes, No, or Never</param>
		/// <param name="recruitMsg">Recruit messaage user recieived, null if not known</param>
		public PMsgJoinTeam( PNState user, Team team, Team.JoinResponse answer ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_JOIN;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PJoinTeamMsgData data = new PJoinTeamMsgData();
			data.UserID       = user.UserId;
			data.TitleID      = team.TitleId;
			data.TeamID       = team.Id;
			data.RecruitMsgId = 0;
			switch( answer )
			{ 
				case Team.JoinResponse.Yes:   data.Answer = XonPresNoti.REPLY_YES;   break;
				case Team.JoinResponse.No:    data.Answer = XonPresNoti.REPLY_NO;    break;
				case Team.JoinResponse.Never: data.Answer = XonPresNoti.REPLY_NEVER; break;
				default:
					throw new ArgumentException( "oops", "answer" );
			}
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Join Team request
	/// </summary>
	public class PJoinTeamMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint   TitleID;
		public ulong  TeamID;
		public uint	  RecruitMsgId;
		public byte   Answer;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Join Team replies
	/// </summary>
	public class PJoinTeamReplyMsgData : PNMsgData
	{
		public uint HR;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgListTeams.cs ===
// PMsgListTeams.cs
//
//	Presence List Teams Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// List the teams a user belongs to
	/// </summary>
	public class PMsgListTeams : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor, current logged on title
		/// </summary>
		/// <param name="user">User getting their teams list</param>
		/// <param name="teamIds">Team Ids to get info on</param>
		public PMsgListTeams( PNState user, ulong[] teamIds ) 
			: this( user, user.Xbox.TitleId, teamIds ) {}

		//////////////////////////////////////
		/// <summary>
		/// Constructor, specific (alt) title
		/// </summary>
		/// <param name="user">User getting their teams list</param>
		/// <param name="titleId">Title (perhaps alt title) listing teams for</param>
		/// <param name="teamIds">Team Ids to get info on</param>
		public PMsgListTeams( PNState user, uint titleId, ulong[] teamIds ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_LIST_TEAMS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PListTeamsMsgData data = new PListTeamsMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			data.TeamIds = teamIds;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List request
	/// </summary>
	public class PListTeamsMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint	   TitleID;
		public uint    TeamIdsLen;
		public ulong[] TeamIds;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List replies
	/// </summary>
	public class PListTeamsReplyMsgData : PNMsgData
	{
		public uint       HR;
		public uint       TeamsLen;
		public TeamInfo[] Teams;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Team data returned in Team List replies
	/// </summary>
	public class TeamInfo : WireData
	{
		public ulong    TeamID;
		public uint     NumMembers;
		public ushort   TeamNameLen;
		public ushort   TeamDescriptionLen;
		public ushort   TeamMottoLen;
		public ushort   TeamURLLen;
		public ushort   TeamDataLen;
		public DateTime Created;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamName;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamDescription;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamMotto;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamURL;
		public byte[]   TeamData;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgListTeamMembers.cs ===
// PMsgListTeamMembers.cs
//
//	Presence List Team Members Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// List the members of a team a user belongs to
	/// </summary>
	public class PMsgListTeamMembers : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User getting their teams list</param>
		/// <param name="team">Team to get member info on</param>
		/// <param name="showRecruits">Include recruits in member list</param>
		public PMsgListTeamMembers( PNState user, Team team, bool showRecruits ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_LIST_MEMBERS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PListTeamMembersMsgData data = new PListTeamMembersMsgData();
			data.UserID       = user.UserId;
			data.TitleID      = team.TitleId;
			data.TeamId       = team.Id;
			data.ShowRecruits = showRecruits;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List Members request
	/// </summary>
	public class PListTeamMembersMsgData : PNMsgData
	{
		public ulong UserID;
		public uint	 TitleID;
		public ulong TeamId;
		public int   _ShowRecruits; // BOOL

		public bool ShowRecruits
		{
			get{ return( (_ShowRecruits == 0) ? false : true ); }
			set{ _ShowRecruits = ( value ? 1 : 0 ); }
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List Members replies
	/// </summary>
	public class PListTeamMembersReplyMsgData : PNMsgData
	{
		public uint             HR;
		public ulong			TeamID;
		public ushort           MemberListLen;
		public TeamMemberInfo[] MemberList;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Team Member data returned in Team List Members replies
	/// </summary>
	public class TeamMemberInfo : WireData
	{
		public ulong    MemberID;
		public byte     MemberNameLen;
		public int      _IsMember; // BOOL
		public uint     MemberPrivliges;
		public ushort   MemberDataLen;
		public DateTime WhenJoined;
		public string   MemberName;
		public byte[]   MemberData;

		public bool IsMember
		{
			get{ return( (_IsMember == 0) ? false : true ); }
			set{ _IsMember = ( value ? 1 : 0 ); }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgIsAffiliate.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	determine if a user is on the sender's buddy list
	/// </summary>
	public class PMsgIsAffiliate : PNRequestMsg
	{
		public PMsgIsAffiliate( PNState user, PNState affiliate) : this(user, affiliate.UserId)
		{
		}
		
		public PMsgIsAffiliate( PNState user, ulong qwAffiliateId ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			Msg.Hdr.MsgType = XonPresNoti.PMSG_IS_AFFILIATE;
			PIsAffiliateMsgData data = new PIsAffiliateMsgData();

			data.qwSenderID = user.UserId;
			data.qwAffiliateID = qwAffiliateId;
            
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to IsAffiliate request
	/// </summary>
	public class PIsAffiliateMsgData : PNMsgData
	{
            public ulong            qwSenderID;
            public ulong            qwAffiliateID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to IsAffiliate reply
	/// </summary>
	public class PIsAffiliateReplyMsgData : PNMsgData
	{
            public uint             hr;
            public ulong            qwAffiliateID;
            public uint             dwListFlags;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgListUserTeams.cs ===
// PMsgListUserTeams.cs
//
//	Presence List Teams Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// List the teams a user belongs to
	/// </summary>
	public class PMsgListUserTeams : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor, current logged on title
		/// </summary>
		/// <param name="user">User getting their teams list</param>
		public PMsgListUserTeams( PNState user ) 
			: this( user, user.Xbox.TitleId ) {}

		//////////////////////////////////////
		/// <summary>
		/// Constructor, specific (alt) title
		/// </summary>
		/// <param name="user">User getting their teams list</param>
		/// <param name="titleId">Title (perhaps alt title) listing teams for</param>
		public PMsgListUserTeams( PNState user, uint titleId ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_LIST_USER_TEAMS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PListUserTeamsMsgData data = new PListUserTeamsMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List request
	/// </summary>
	public class PListUserTeamsMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint	   TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Teams List replies
	/// </summary>
	public class PListUserTeamsReplyMsgData : PNMsgData
	{
		public uint       HR;
		public uint       TeamsLen;
		public UserTeamInfo[] Teams;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Team data returned in Team List replies
	/// </summary>
	public class UserTeamInfo : WireData
	{
		public ulong    TeamID;
		public int     _IsMember; // BOOL
		public bool IsMember
		{
			get
			{ 
				return( (_IsMember == 0) ? false : true ); 
			}
			set
			{ 
				_IsMember = ( value ? 1 : 0 ); 
			}
		}

		//[WireInfo(ArraySize=16,UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(ArraySize = 16, NullTerminate = true)]
		public string   TeamName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgManageTeam.cs ===
// PMsgManageTeam.cs
//
//	Presence Manage Team Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Manage (change) team information
	/// </summary>
	public class PMsgManageTeam : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User changing team</param>
		/// <param name="team">team being changed</param>
		/// <param name="name">new team name</param>
		/// <param name="description">new team description</param>
		/// <param name="motto">new team motto</param>
		/// <param name="url">new team url</param>
		/// <param name="teamData">new team data blob</param>
		public PMsgManageTeam( 
			PNState user,
			Team   team,
			string name,
			string description,
			string motto,
			string url,
			byte[] teamData ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_MANAGE_TEAM;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PManageTeamMsgData data = new PManageTeamMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = team.TitleId;
			data.TeamID          = team.Id;
			data.TeamName        = name;
			data.TeamDescription = description;
			data.TeamMotto       = motto;
			data.TeamURL         = url;
			data.TeamData        = teamData;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team request
	/// </summary>
	public class PManageTeamMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint	  TitleID;
		public ulong  TeamID;
		public ushort TeamNameLen;
		public ushort TeamDescriptionLen;
		public ushort TeamMottoLen;
		public ushort TeamURLLen;
		public ushort TeamDataLen;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamName;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamDescription;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamMotto;
		//[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
		public string TeamURL;
		public byte[] TeamData; 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team replies
	/// </summary>
	public class PManageTeamReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgLogonCheck.cs ===
// PMsgLogonCheck.cs
//
//	Presence LogonCheck Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// determines if a user is already logged in at another location.
	/// </summary>
	public class PMsgLogonCheck : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">user to query logon status</param>
		public PMsgLogonCheck( PNState user, ulong xboxid ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_LOGON_CHECK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = xboxid;

			PLogonCheckMsgData data = new PLogonCheckMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to LogonCheck request
	/// </summary>
	public class PLogonCheckMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to LogonCheck reply
	/// </summary>
	public class PLogonCheckReplyMsgData : PNMsgData
	{
		public uint        HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgManageTeamMember.cs ===
// PMsgManageTeamMember.cs
//
//	Presence Manage Team Member Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Manage (change) team member information
	/// </summary>
	public class PMsgManageTeamMember : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making change</param>
		/// <param name="team">Team being changed</param>
		/// <param name="member">Member being changed</param>
		/// <param name="memberPrivliges">New member privliges</param>
		/// <param name="memberData">New member data blob</param>
		public PMsgManageTeamMember( 
			PNState      user,
			Team        team,
			TeamMember  member,
			uint        memberPrivliges,
			byte[]      memberData ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_MANAGE_MEMBER;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PManageTeamMemberMsgData data = new PManageTeamMemberMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = team.TitleId;
			data.TeamID          = team.Id;
			data.MemberID        = member.UserId;	
			data.MemberPrivliges = memberPrivliges;
			data.MemberData      = memberData;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team Member request
	/// </summary>
	public class PManageTeamMemberMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint   TitleID;
		public ulong  TeamID;
		public ulong  MemberID;
		public uint   MemberPrivliges;
		public ushort MemberDataLen;
		public byte[] MemberData; 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team Member replies
	/// </summary>
	public class PManageTeamMemberReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgPeerSubscribe.cs ===
// PMsgPeerSubscribe.cs
//
//	Presence Subscibe to peer presence info Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows user to subscribe to presence notifications for other users that are not 
	/// friends
	/// </summary>
	public class PMsgPeerSubscribe : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting presence notifications</param>
		/// <param name="peers">Users who's presence will be provided</param>
		//////////////////////////////////////
		public PMsgPeerSubscribe( PNState user, PNState[] peers ) : this(user, ConvertToPuids(peers))
		{
		}

		static ulong[] ConvertToPuids(PNState[] peers)
		{
			ulong []rgqw = null;
			
			if(null != peers)
			{
				rgqw = new ulong[peers.Length];

				for(int i = 0; i < peers.Length; ++i)
				{
					rgqw[i] = peers[i].UserId;
				}
			}
			else
			{
				rgqw = new ulong[0];
			}

			return rgqw;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting presence notifications</param>
		/// <param name="peers">Users who's presence will be provided</param>
		public PMsgPeerSubscribe( PNState user, ulong[] peers ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SUBSCRIBE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PPeerSubscribeMsgData data = new PPeerSubscribeMsgData();
			data.UserID = user.UserId;
			data.Peers  = peers;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Subscribe request
	/// </summary>
	public class PPeerSubscribeMsgData : PNMsgData
	{
		public ulong   UserID;
		public ushort  PeersLen = 0;
		public ulong[] Peers;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Subscribe reply
	/// </summary>
	public class PPeerSubscribeReplyMsgData : PNMsgData
	{
		public uint HR = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgPeerUnsubscribe.cs ===
// PMsgPeerUnsubscribe.cs
//
//	Presence Unsubscibe to peer presence info Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Cancels subcription to presence notifications for other users that are not 
	/// friends
	/// </summary>
	public class PMsgPeerUnsubscribe : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User wanting to cancel presence notifications</param>
		public PMsgPeerUnsubscribe( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_UNSUBSCRIBE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PPeerUnsubscribeMsgData data = new PPeerUnsubscribeMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Unsubscribe request
	/// </summary>
	class PPeerUnsubscribeMsgData : PNMsgData
	{
		public ulong UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Unsubscribe reply
	/// </summary>
	class PPeerUnsubscribeReplyMsgData : PNMsgData
	{
		public uint HR = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgPeerSession.cs ===
// PMsgPeerSession.cs
//
//	Presence Get Peer Session info Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows Retrieval of Client Winsock Endpoint info sent up with alives starting 
	/// with the aftershock release.
	/// </summary>
	public class PMsgPeerSession : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making the request for data</param>
		/// <param name="host">User who's endpoint data is requested</param>
		public PMsgPeerSession( PNState user, PNState host ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SESSION;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PPeerSessionMsgData data = new PPeerSessionMsgData();
			data.UserID     = user.UserId;
			data.HostUserID = host.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Session request
	/// </summary>
	class PPeerSessionMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong HostUserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Peer Session reply
	/// </summary>
	class PPeerSessionReplyMsgData : PNMsgData
	{
		public ulong  HostUserID   = 0;
		public uint   TitleID      = 0;
		public uint   TitleVersion = 0;
		public uint   TitleRegion  = 0;
		public XNADDR XnAddr       = new XNADDR();
		public XNKID  XnKId        = new XNKID();
		public XNKEY  XnKey        = new XNKEY();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgPeerSubscribeEx.cs ===
// PMsgAddBuddy.cs
//
//	Presence Add Buddy Request Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///	Attempt to add the given person to the sender's buddy list, either by the
	/// person's ID or name. Either Buddy ID or Nmae size must be zero.
	/// </summary>
	public class PMsgPeerSubscribeEx : PNRequestMsg
	{
        public const uint X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS = 0x1;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK = 0xFF00000000000000;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD = 0x0100000000000000;
        public const ulong X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE = 0x0200000000000000;
        
        public PMsgPeerSubscribeEx( PNState user, PNState[] pnuAdds, PNState[] pnuSubs ) 
        {
            ulong[] targets = new ulong[pnuAdds.Length + pnuSubs.Length];
            for (int i=0; i<pnuAdds.Length; i++)
            {
                targets[i] = pnuAdds[i].UserId | X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD;
            }
            for (int i=pnuAdds.Length; i<pnuAdds.Length+pnuSubs.Length; i++)
            {
                targets[i] = pnuSubs[i-pnuAdds.Length].UserId | X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE;
            }
            this.Initialize(user, X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS, targets);
        }
        public PMsgPeerSubscribeEx( PNState user, PNState[] pnuAbsolute ) 
        {
            ulong[] targets = new ulong[pnuAbsolute.Length];
            for (int i=0; i<pnuAbsolute.Length; i++)
            {
                targets[i] = pnuAbsolute[i].UserId;
            }
            this.Initialize(user, 0, targets);
        }
        public PMsgPeerSubscribeEx( PNState user, uint dwFlags, ulong[] targets )
        {
            this.Initialize(user, dwFlags, targets);
        }
        private void Initialize( PNState user, uint dwFlags, ulong[] targets ) 
	{
		SentFrom    = Requestor.Client;
		PortOnFD    = FDPort.PresNoti;
		AuthMethod  = FDAuth.SGMsg;
		ServiceOnFD = FDService.Presence;

		Msg.Hdr = new PNMsgHdr();
		Msg.Hdr.MsgLen  = 0;
		Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

		Msg.Hdr.Sgaddr = new SGADDR();
		Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
		Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
		Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

		Msg.Hdr.MsgType = XonPresNoti.PMSG_PEER_SUBSCRIBE_EX;
		PPeerSubscribeExMsgData data = new PPeerSubscribeExMsgData();

		data.qwUserID = user.UserId;
		data.dwFlags = dwFlags;
		data.cwTargets = (ushort)(targets.Length);
              data.pqwTargets = targets;
        
		Msg.Data = data;
	}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to AddAffiliates request
	/// </summary>
	public class PPeerSubscribeExMsgData : PNMsgData
	{
            public ulong            qwUserID;
            public uint               dwFlags;
            public ushort           cwTargets;
     
            [WireInfo(SizeParam="cwTargets")]
            public ulong[]          pqwTargets;
	}

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates reply
    /// </summary>
    public class PPeerSubscribeExReplyMsgData : PNMsgData
    {
        public uint             hr;
        public ushort         cwResults;

        [WireInfo(SizeParam="cwResults")]
        public PeerSubscribeExReplyData[]      rgResults;
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class PeerSubscribeExReplyData : WireData
    {
        public ulong            qwUserID;
        public uint             dwState;
        public uint             dwTitleID;
        public uint             mtUserTime;

        [WireInfo(ArraySize=16)]
        public string           szGamerTag; // ASCII Null terminated
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgQueryAffiliates.cs ===
// PMsgAddBuddy.cs
//
//  Presence Add Buddy Request Message
//

using System;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// determine if a user is on the sender's buddy list
    /// </summary>
    public class PMsgQueryAffiliates : PNRequestMsg
    {
        public PMsgQueryAffiliates( PNState user, uint cdwLimit, uint dwListFlags, uint dwOnlineTitleID ) 
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.PresNoti;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Presence;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

            Msg.Hdr.MsgType = XonPresNoti.PMSG_QUERY_AFFILIATES;
            PQueryAffiliatesMsgData data = new PQueryAffiliatesMsgData();

            data.qwSenderID = user.UserId;
            data.cdwLimit = cdwLimit;
            data.dwListFlags = dwListFlags;
            data.dwOnlineTitleID = dwOnlineTitleID;

            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates request
    /// </summary>
    public class PQueryAffiliatesMsgData : PNMsgData
    {
        public ulong            qwSenderID;
        public uint             dwListFlags;
        public uint             cdwLimit;
        public uint             dwOnlineTitleID;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to QueryAffiliates reply
    /// </summary>
    public class PQueryAffiliatesReplyMsgData : PNMsgData
    {
        public uint             hr;
        public uint            cdwResults;

        [WireInfo(SizeParam="cdwResults")]
        public QueryAffiliatesReplyData[]      rgResults;
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class QueryAffiliatesReplyData : WireData
    {
        public ulong            qwAffiliateID;
        public uint             dwListFlags;
        public uint             dwTitleID;
        public ulong            qwSessionID;
        public uint             mtDateUpdated;

        [WireInfo(ArraySize=16)]
        public string           szGamerTag; // ASCII Null terminated
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgNickname.cs ===
// PMsgNickname.cs
//
//	Presence Set Nickname (UserData) Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows update of title specific data stored by Presence for a particular user. 
	/// Title initiates immediate update all the way to server. Because of this and the 
	/// potential for misuse this message has been phased out for new titles.
	/// </summary>
	public class PMsgNickname : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's data is being updated</param>
		/// <param name="nickname">new nickname data</param>
		public PMsgNickname( PNState user, byte[] nickname ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_NICKNAME;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PNicknameMsgData data = new PNicknameMsgData();
			data.UserID   = user.UserId;
			data.Nickname = nickname;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Nickname request
	/// </summary>
	public class PNicknameMsgData : PNMsgData
	{
		public ulong  UserID;
		public ushort NicknameLen;
		public byte[] Nickname;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgManageTeamXe.cs ===
// PMsgManageTeamXe.cs
//
//	Presence Manage Team Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Manage (change) team information
	/// </summary>
	public class PMsgManageTeamXe : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User changing team</param>
		/// <param name="team">team being changed</param>
		/// <param name="name">new team name</param>
		/// <param name="description">new team description</param>
		/// <param name="motto">new team motto</param>
		/// <param name="url">new team url</param>
		/// <param name="teamData">new team data blob</param>
		public PMsgManageTeamXe( 
			PNState user,
			Team   team,
			string name,
			string description,
			string motto,
			string url,
			byte[] teamData ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_MANAGE_TEAM_XE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PManageTeamXeMsgData data = new PManageTeamXeMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = team.TitleId;
			data.TeamID          = team.Id;
			data.TeamName        = name;
			data.TeamDescription = description;
			data.TeamMotto       = motto;
			data.TeamURL         = url;
			data.TeamData        = teamData;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team request
	/// </summary>
	public class PManageTeamXeMsgData : PNMsgData
	{
		public ulong  UserID;
		public uint	  TitleID;
		public ulong  TeamID;
		public ushort TeamNameLen;
		public ushort TeamDescriptionLen;
		public ushort TeamMottoLen;
		public ushort TeamURLLen;
		public ushort TeamDataLen;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamName;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamDescription;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamMotto;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=true)]
        [WireInfo(NullTerminate = true)]
        public string TeamURL;
		public byte[] TeamData; 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Manage Team replies
	/// </summary>
	public class PManageTeamXeReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgRecruitTeamMember.cs ===
// PMsgRecruitTeamMember.cs
//
//	Presence Recruit Team Member Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Recruit a new team member
	/// </summary>
	public class PMsgRecruitTeamMember : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Xbox 1 style recruit constructor
		/// </summary>
		/// <param name="user">User doing the recruiting</param>
		/// <param name="team">Team being recruited too</param>
		/// <param name="recruit">New Team member being recruited</param>
		/// <param name="msg">carries flags and custom properties that should be in recruit message</param>
		public PMsgRecruitTeamMember( PNState user, Team team, TeamMember recruit, UserMessage msg ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_RECRUIT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PRecruitTeamMemberMsgData data = new PRecruitTeamMemberMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = team.TitleId;
			data.TeamID          = team.Id;
			data.MemberID        = recruit.UserId;
			data.MemberName      = recruit.Name;
			data.MemberPrivliges = recruit.Privliges;
			data.MemberData      = recruit.Data;
			data.MessageFlags    = msg.Flags;
			data.cbDetails       = msg.Details.size;
			data.Details         = msg.Details;
			Msg.Data = data;
		}

		//////////////////////////////////////
		/// <summary>
		/// Xenon style recruit constructor
		/// </summary>
		/// <param name="user">User doing the recruiting</param>
		/// <param name="team">Team being recruited too</param>
		/// <param name="recruit">New team member being recruited</param>
		public PMsgRecruitTeamMember( PNState user, Team team, TeamMember recruit)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_RECRUIT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PRecruitTeamMemberMsgData data = new PRecruitTeamMemberMsgData();
			data.UserID          = user.UserId;
			data.TitleID         = team.TitleId;
			data.TeamID          = team.Id;
			data.MemberID        = recruit.UserId;
			data.MemberName      = recruit.Name;
			data.MemberPrivliges = recruit.Privliges;
			data.MemberData      = recruit.Data;
			data.MessageFlags    = 0;
			data.cbDetails       = 0;
			data.Details         = null;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Recruit Team Member request
	/// </summary>
	public class PRecruitTeamMemberMsgData : PNMsgData
	{
		public ulong      UserID;
		public uint       TitleID;
		public ulong      TeamID;
		public ulong      MemberID;
		[WireInfo(ArraySize=16)] // XONLINE_GAMERTAG_SIZE
		public string     MemberName;
		public uint       MemberPrivliges;
		public uint       MessageFlags;
		public ushort     MemberDataLen;
		public ushort     cbDetails;
		public MsgDetails Details;
		public byte[]     MemberData; 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Recruit Team Member replies
	/// </summary>
	public class PRecruitTeamMemberReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgState.cs ===
// PMsgState.cs
//
//	Presence Set State (TitleData) Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows update of title specific data stored by Presence for a particular user similar 
	/// to nickname.  However timing is not immediate or title initiated.  Instead the data 
	/// rides in periodic SG heatbeat messages.
	/// </summary>
	public class PMsgState : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgState( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_STATE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PStateMsgData data = new PStateMsgData();
			data.UserID         = user.UserId;
			data.State          = user.State;
			data.MatchSessionID = user.MatchSessionId;
			data.TitleStuff     = user.TitleStuff;
			Msg.Data = data;
		}
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to State request
	/// </summary>
	public class PStateMsgData : PNMsgData
	{
		public ulong   UserID;
		public uint    State;
		public ulong   MatchSessionID;
		public ushort  TitleStuffLen;
		public byte[]  TitleStuff;
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Xenon version of state message. This message functions like state, but deprecates the 
	/// rgbTitleStuff member, and replaces it with the Rich Presence related contexts and properties. 
	/// </summary>
	public class PMsgState2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgState2( PNState user ) 
		{
			SentFrom               = Requestor.Client;
			PortOnFD               = FDPort.PresNoti_DC;
			AuthMethod             = FDAuth.None;
			ServiceOnFD            = FDService.Presence;

			Msg.Hdr                = new PNMsgHdr();
			Msg.Hdr.MsgType        = XonPresNoti.PMSG_STATE_2;
			Msg.Hdr.MsgLen         = 0;
			Msg.Hdr.SeqNum         = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr         = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg   = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg   = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId  = user.Client.MachinePuid;

			PState2MsgData data    = new PState2MsgData();
			data.UserID            = user.UserId;
			data.State             = user.State;
			data.MatchSessionID    = user.MatchSessionId;
			
			data.TitleID           = user.Xbox.TitleId;
			data.cbRichPresence    = 0;
			data.TitlePresence     = 0;

			data.cProperties       = 0;
			data.cContexts         = 0;
            
			Msg.Data               = data;
		}

	}
	

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to State2 request
	/// </summary>
    public class PState2MsgData : PNMsgData
    {
        public ulong   UserID;
        public uint    State;
        public ulong   MatchSessionID;

        public uint    TitleID;
        public uint    cbRichPresence;     // Count of bytes in RP data

        public uint    TitlePresence;

        public ushort  cContexts;
        public ushort  cProperties;
        
        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;

        public uint RPSize()
        {
            // sizeof( RichPresence )
            int cb = 8;
        
            // add all the contexts
            cb += cContexts * 8;
            
            // add all the props
            if (cProperties > 0)
            {
                foreach (GIProperty prop in rgProps)
                {
                    cb += prop.Size();
                }
            }

            return (uint)cb;
        }

    }


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Allows for the retrieval of State data about a user, including the Rich Presence contexts and properties
	/// this message is currently only consumed by the FD in response to a Dequeue or Alive so that 
	/// the Rich Presence string can be created for a user. 
	/// </summary>
	public class PMsgGetState : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User who's state data is being updated</param>
		public PMsgGetState( PNState user ) 
		{
			SentFrom               = Requestor.Client;
			PortOnFD               = FDPort.PresNoti_DC;
			AuthMethod             = FDAuth.None;
			ServiceOnFD            = FDService.Presence;

			Msg.Hdr                = new PNMsgHdr();
			Msg.Hdr.MsgType        = XonPresNoti.PMSG_GET_STATE;
			Msg.Hdr.MsgLen         = 0;
			Msg.Hdr.SeqNum         = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr         = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg   = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg   = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId  = user.Client.MachinePuid;

			PGetStateMsgData data  = new PGetStateMsgData();
			data.UserID            = user.UserId;
            
			Msg.Data               = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get State request
	/// </summary>
	public class PGetStateMsgData : PNMsgData
	{
		public ulong UserID;
	}
	

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Get State reply
	/// </summary>
	public class PGetStateReplyMsgData : PNMsgData
	{
		public uint             HR;

        public uint             State;            // See P_STATE_MASK_XXX
        public ulong            MatchSessionID;

        public uint             TitleID;          // Xenon state now conveys title changes
        
        public uint             TitlePresence;
        
        public ushort           cContexts;
        public ushort           cProperties;

        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgRemoveTeamMember.cs ===
// PMsgRemoveTeamMember.cs
//
//	Presence Remove Team Member Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Remove a member from a team
	/// </summary>
	public class PMsgRemoveTeamMember : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User doing remove</param>
		/// <param name="team">Team being changed</param>
		/// <param name="member">Member being removed</param>
		public PMsgRemoveTeamMember( PNState user, Team team, TeamMember member )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Teams;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Teams;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_TEAM_REMOVE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PRemoveTeamMemberMsgData data = new PRemoveTeamMemberMsgData();
			data.UserID   = user.UserId;
			data.TitleID  = team.TitleId;
			data.TeamID   = team.Id;
			data.MemberID = member.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Remove team member request
	/// </summary>
	public class PRemoveTeamMemberMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  TitleID;
		public ulong TeamID;
		public ulong MemberID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Remove team member replies
	/// </summary>
	public class PRemoveTeamMemberReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgWebFriends.cs ===
// PMsgWebFriends.cs
//
//	Presence Web Friends Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// login a user from the web
	/// </summary>
	public class PMsgWebAlive : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants to log in</param>
		public PMsgWebAlive( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_WEB_ALIVE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PWebAliveMsgData data = new PWebAliveMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Alive request
	/// </summary>
	public class PWebAliveMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Alive reply
	/// </summary>
	public class PWebAliveReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
	}


    
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Request a dump of friend status information for a specified user
	/// </summary>
	public class PMsgWebFriends : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants friend status</param>
		public PMsgWebFriends( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_WEB_FRIENDS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			// Fill out the SGADDR so we can resolve the psuedo 
			// XBOX info from the FakeSG for creating HTTP auth
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PWebFriendsMsgData data = new PWebFriendsMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends request
	/// </summary>
	public class PWebFriendsMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Web Friends reply
	/// </summary>
	public class PWebFriendReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ulong       UserID;
		public uint        Version;
		public uint      cdwFriends;
        
              [WireInfo(SizeParam="cdwFriends")]
		public WebFriend[] rgFriends;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Online friend data included in Web Friends reply
	/// </summary>
	public class WebFriend : WireData
	{
		public ulong  BuddyID;
		public uint   Status;
		public uint   OnlineState;
		public uint   TitleID;
		public uint   mtLastActive;
		public ushort cbStateData;
		public uint   cbRichPresence;

              [WireInfo(ArraySize=16)]
		public string szGamerTag;
              
              [WireInfo(SizeParam="cbStateData")]
		public byte[] StateData;
              
              [WireInfo(SizeParam="cbRichPresence")]
		public byte[] szRichPresence;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PNMsgDeadUser.cs ===
// PNMsgDeadUser.cs
//
//	Presence or Notification Dead User Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inform the presence or notification server that the given user just went offline.
	/// Format is the same for both Presence and Notification
	///
	/// DeadUser is a forged user message, it requires a valid auth data response from the
	/// SG but the user ID cannot be in the ticket.
	/// </summary>
	public class PNMsgDeadUser : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that is offline</param>
		/// <param name="service">Presence or Notificaion</param>
		public PNMsgDeadUser( PNState user ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_DEAD_USER;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			Msg.Hdr.MsgLen  = 0;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PNDeadUserMsgData data = new PNDeadUserMsgData();
			data.UserID = user.UserId;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dead User request
	/// </summary>
	public class PNDeadUserMsgData : PNMsgData
	{
		public ulong UserID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PNConditionalWaitState.cs ===
using System;
using System.Text;
using System.Threading;
using System.Collections;

namespace live.protocol.Presence
{
	/// <summary>
	/// Create a multi-value wait state where all conditions must be
	/// met for the wait to complete.
	/// </summary>
	public class PNConditionalWaitState
	{
		protected abstract class Condition
		{
			public bool   Active;
			public PNState Source;
			public PNState Target;

			public abstract bool Check(QValPacket qval);
		}

		/// <summary>
		/// Condition class that wraps a qflag change on a user. This condition
		/// will be satisified when that qflag is delivered to the user.
		/// </summary>
		protected class QFlagCondition  : Condition
		{
			public uint QFlagMask;

			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder().Append(
						"QFlagCondition: Source: ").Append(
						Source.UserId.ToString("x")).Append(
						", Target: ").Append(
						Target.UserId.ToString("x")).Append(
						", QFlags: ").Append(
						QFlagMask.ToString("x8")).Append(
						", Active: ").Append(
						Active);

				return buffer.ToString();
			}

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check = false;
				if((qval.QFlags & QFlagMask) != 0)
				{
					// See if the correct target user was dequeued
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_BUDDY_REQ))
					{
						PNState.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = ((null != info) && (XonPresNoti.P_BUDDY_STATUS_PENDING == info.Status));
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_LIST_CHANGE))
					{
						PNState.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = (null != info); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PRESENCE))
					{
						PNState.BuddyInfo info = Target.GetBuddyInfo(Source.UserId);
						check = (null != info) && (null != info.Presence); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_INVITE))
					{
						PNState.InvitationInfo info = Target.GetInvitationInfo(Source.UserId);
						check = (null != info) && (null != info.Invitation);
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_INVITE_ANSWER))
					{
						PNState.InvitationInfo info = Target.GetInvitationInfo(Source.UserId);
						check = (null != info) && (null != info.InvitationAnswer);
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PEER_PRESENCE))
					{
						PNState.PeerInfo info = Target.GetPeerInfo(Source.UserId);
						check = (null != info) && (null != info.PeerPresence); 
					}
					if(0 != (QFlagMask & XonPresNoti.QFLAG_MASK_PRESENCE_2))
					{
						PNState.BuddyInfo buddyInfo = Target.GetBuddyInfo(Source.UserId);
						check = (null != buddyInfo) && (buddyInfo.RichPresence != null); 

						// Check peers fallthrough
						if(!check)
						{
							PNState.PeerInfo peerInfo = Target.GetPeerInfo(Source.UserId);
							check = (null != peerInfo) && (null != peerInfo.RichPresence); 
						}
					}
				}

				return check;
			}
		}

		/// <summary>
		/// Condition class that wraps a messaging qval change.
		/// will be satisified when that qval data is delivered to the user.
		/// </summary>
		protected class MessagingCondition : Condition
		{
			public uint DataFlags;
			public uint MsgType;

			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder();

                buffer.Append("MessagingCondition: Source: ");
                buffer.Append(Source.UserId.ToString("x"));

                buffer.Append(", Target: ");
                buffer.Append(Target.UserId.ToString("x"));

                buffer.Append(", DataFlags: ");
                buffer.Append(DataFlags.ToString("x8"));

                buffer.Append(", MsgType: ");
                buffer.Append(MsgType.ToString("x2"));

                buffer.Append(", Active: ");
                buffer.Append(Active);

				return buffer.ToString();
			}

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check   = false;
				uint msgId   = 0;
				uint msgData = 0;

				PNState.MessageInfo []rgInfo = Target.GetMessageInfoFrom(Source);
				foreach(PNState.MessageInfo info in rgInfo)
				{
					// Check the found item from the sender
					// and the dataflags specified match
					if(    (0 == DataFlags || DataFlags == (info.Data & DataFlags)) 
						&& (0 == MsgType || ((info.Data >> 24 & 0xff) == MsgType))
						&& (null == info.Message || info.Message.SenderID == Source.UserId))
					{
						check    = true;
						msgId    = info.Id;
						msgData  = info.Data;
					}
				}

				return check;
			}
		}

		/// <summary>
		/// Condition class that wraps a deleted message qval change.
		/// will be satisified when that qval data is delivered to the user.
		/// </summary>
		protected class DeletedMessagingCondition : Condition
		{
			public uint MsgId;

			public override string ToString()
			{
				StringBuilder buffer = new StringBuilder().Append(
						"DeletedMessagingCondition: Source: ").Append(
						Source.UserId.ToString("x")).Append(
						", Target: ").Append(
						Target.UserId.ToString("x")).Append(
						", MsgId: ").Append(
						MsgId.ToString("x8")).Append(
						"Active: ").Append(
						Active);

				return buffer.ToString();
			}

			public override bool Check(QValPacket qval)
			{
				// Read all qvals for the target
				bool check   = false;
				uint msgId   = 0;
				uint msgData = 0;

				PNState.MessageInfo []rgInfo = Target.GetMessageInfoFrom(Source);
				foreach(PNState.MessageInfo info in rgInfo)
				{
					// Match message ID, ensure message has been marked deleted
					// by deleted message qval and if the message has been retrieved
					// check that the source ID matches
					if(info.Id == MsgId && true == info.Deleted && (null != info.Message || info.Message.SenderID == Source.UserId))
					{
						check    = true;
						msgId    = info.Id;
						msgData  = info.Data;
					}
				}

				return check;
			}
		}

		ArrayList  _Conditions;
		ArrayList  _Completed;

		public uint MaxTimeout;


		/// <summary>
		/// Create a new conditional wait state for a target user. A default of 5 seconds
		/// will be used for the wait timeout.
		/// </summary>
		/// <param name="user">User to act as the target</param>
		public PNConditionalWaitState() : this(60)
		{
		}
		
		
		/// <summary>
		/// Create a new conditional wait state for a target user.
		/// </summary>
		/// <param name="user">User to act as the target</param>
		/// <param name="maxTimeoutSeconds">Timeout in seconds for the wait state</param>
		public PNConditionalWaitState(uint maxTimeoutSeconds)
		{
			_Conditions = new ArrayList();
			_Completed = new ArrayList();
			MaxTimeout = maxTimeoutSeconds;
		}

		/// <summary>
		/// Add a new required qflag that should arive based on the action of 
		/// a certain sender.
		/// </summary>
		/// <param name="qFlagMask">Bits to wait on, usually this will be a single bit. See XonPresNoti for bit definitions.</param>
		/// <param name="sender">Initiator of the action.</param>
		public void AddRequiredQFlag(uint qFlagMask, PNState source, PNState target)
		{
			QFlagCondition cond = new QFlagCondition();
			cond.Source = source;
			cond.Target = target;
			cond.QFlagMask = qFlagMask;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required messaging qval that should arive based on the action
		/// of the sender. Match the type of the message.
		/// </summary>
		public void AddRequiredMessageType(uint msgType, PNState source, PNState target)
		{
			MessagingCondition cond = new MessagingCondition();
			cond.Source    = source;
			cond.Target    = target;
			cond.MsgType   = msgType;
			cond.DataFlags = 0;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required messaging qval that should arive based on the action
		/// of the sender. Match the data flags in the message
		/// </summary>
		public void AddRequiredMessageData(uint dataFlags, PNState source, PNState target)
		{
			MessagingCondition cond = new MessagingCondition();
			cond.Source    = source;
			cond.Target    = target;
			cond.MsgType   = 0;
			cond.DataFlags = dataFlags;
			_Conditions.Add(cond);
		}

		/// <summary>
		/// Add a new required deleted messaging qval that should arive based on the action
		/// of the sender.
		/// </summary>
		public void AddRequiredDeletedMessageId(uint msgId, PNState source, PNState target)
		{
			DeletedMessagingCondition cond = new DeletedMessagingCondition();
			cond.Source = source;
			cond.Target = target;
			cond.MsgId = msgId;
			_Conditions.Add(cond);
		}


		/// <summary>
		/// Build a condition string.
		/// </summary>
		/// <returns>A string representing all conditions currently unsatisfied</returns>
		public override string ToString()
		{
			StringBuilder buffer = new StringBuilder(512);
			uint count = 0;

			foreach(Condition cond in _Conditions)
			{
				if(cond.Active)
				{
					buffer.Append(String.Format("[{0}]: {1}\n", 
								count, 
								cond.ToString()));
				}
				count++;
			}

			return buffer.ToString();
		}

        public void WaitOnConditions()
        {
            WaitOnConditions(false);
        }

		/// <summary>
		/// Wait on all conditions.
		/// </summary>
		public void WaitOnConditions(bool ErrorOnUnexpectedQval)
		{
			DateTime abortTime = DateTime.Now.AddSeconds(MaxTimeout);
			if(0 == _Conditions.Count)
			{
				goto lbDone;
			}

			Hashtable targetsHash = new Hashtable();
			ArrayList toRemove = new ArrayList();
			uint activeCount = 0;

			// Mark all conditions active and collect the set 
			// of all targets hashed to target ID
			foreach(Condition cond in _Conditions)
			{
				// Mark condition active cond.Active = true;
				activeCount++;
				cond.Active = true;
				
				// Hang array of conditions off of target ID in hash
				ArrayList conditions = (ArrayList)targetsHash[cond.Target.UserId];
				if(null == conditions)
				{
					conditions = new ArrayList();
					targetsHash[cond.Target.UserId] = conditions;
				}
				conditions.Add(cond);
			}
			
			try
			{
				ArrayList targetsHashToRemove = new ArrayList();

                while(activeCount > 0 && abortTime > DateTime.Now)
				{
                    // Poll qvals for all target users
					QValPacket qval = null;

					targetsHashToRemove.Clear();

					// Loop over each distinct target type
					IDictionaryEnumerator enumerator = targetsHash.GetEnumerator();
					while(enumerator.MoveNext())
					{
						ulong targetId        = (ulong)enumerator.Key; 
						ArrayList conditions  = enumerator.Value as ArrayList;

						// Get the first condition and the target for group of conditions
						PNState target = (conditions[0] as Condition).Target;

						
						// First check for and process any qvals on target
						if(target.DequeueQVals(out qval))
						{
							target.HandleQValPacket(qval);

							// Process the conditions linked to target
							foreach(Condition cond in conditions)
							{
								if(cond.Check(qval))
								{
									cond.Active = false;
									activeCount--;
									toRemove.Add(cond);
								}
							}

							if(toRemove.Count > 0)
							{
								// Remove the matched conditions
								foreach(Condition cond in toRemove)
								{
									conditions.Remove(cond);
								}

								// Clear conditions to remove array
								toRemove.Clear();
							}
                            else if (ErrorOnUnexpectedQval)
                            {
                                // TODO: what exception if any should be thrown
                                throw new Exception(String.Format("QVal received by User {0} did not match any conditions.", target.UserId));
                            }
						
						} // end qval read

						// Satisfied all of this targets conditions, make for removal
						// and go to next item.
						if(0 == conditions.Count)
						{
							targetsHashToRemove.Add(targetId);
						}
					} // End target hash loop

					// Process any removal targets from the target hash (this cannot be done
					// while using collection enumeration so we do it out of the while loop
					// here.)
					//
					foreach(UInt64 targetId in targetsHashToRemove)
					{
						targetsHash.Remove(targetId);
					}

					Thread.Sleep(PNState.QValPollingInterval);
				} // End active timeout loop
			} 
			catch(Exception)
			{
				// Log uncaught conditions and re-throw
				throw;
			}

			// Catch timeout condition
			if(activeCount > 0 && abortTime < DateTime.Now)
			{
				throw new TimeoutException("Timed out waiting on conditions:\n" + this.ToString());
			}

        lbDone:
            return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgRejectBuddy.cs ===
// PMsgRejectBuddy.cs
//
//	Presence Reject Buddy Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Reject a request to be someone's buddy. If never is indicated all future buddy 
	/// requests from the user being rejected will be blocked at the server.  The "never"
	/// list is stored on the server and there is no way to remove someone explicitly from 
	/// it, but sending someone on it a buddy request will remove them implicitly.
	/// </summary>
	public class PMsgRejectBuddy : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User rejecting the buddy</param>
		/// <param name="buddy">Buddy being rejected</param>
		/// <param name="never">Block all future requests</param>
		public PMsgRejectBuddy( PNState user, PNState buddy, bool never ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_REJECT;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PRejectBuddyMsgData data = new PRejectBuddyMsgData();
			data.UserID  = user.UserId;
			data.BuddyID = buddy.UserId;
			data.Never   = never;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Reject buddy request
	/// </summary>
	public class PRejectBuddyMsgData : PNMsgData
	{
		public ulong  UserID;
		public ulong  BuddyID;
		public int    _Never;  // BOOL

		public bool Never
		{
			get{ return( (_Never == 0) ? false : true ); }
			set{ _Never = ( value ? 1 : 0 ); }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PMsgUnblockVoice.cs ===
// PMsgUnblockVoice.cs
//
//	Presence Unblock voice (un-Mute) Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Remove a particular user (or all users) from my blocklist.
	/// </summary>
	public class PMsgUnblockVoice : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants someone unblocked</param>
		/// <param name="block">User being unblocked</param>
		public PMsgUnblockVoice( PNState user, PNState block )
			: this( user, block.UserId ) 
		{}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants blocklist emptied</param>
		public PMsgUnblockVoice( PNState user )
			: this( user, 0 ) 
		{}
		
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User that wants someone unblocked</param>
		/// <param name="blockId">User PUID being unblocked</param>
		private PMsgUnblockVoice( PNState user, ulong blockId ) 
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Presence;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.PMSG_UNBLOCK;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;

			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			PNUnblockVoiceMsgData data = new PNUnblockVoiceMsgData();
			data.UserID  = user.UserId;
			data.BlockID = blockId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Unblock request
	/// </summary>
	public class PNUnblockVoiceMsgData : PNMsgData
	{
		public ulong UserID;
		public ulong BlockID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PNMsg.cs ===
// PNMsg.cs
//
//	Common Presence and Notification message classes
//

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Collections;
using live.common;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNADDR : WireData
	{
		public XNADDR() : this( 1, 2, 3, 10, 15 ) {}
		public XNADDR( uint ip, uint oip, ushort oport, byte enet0, byte oid0 )
		{
			ina = ip; inaOnline = oip; wPortOnline = oport; abEnet[0] = enet0; abOnline[0] = oid0; 
		}

		public uint   ina;         // IN_ADDR: IP address (zero if not static/DHCP)
		public uint   inaOnline;   // IN_ADDR: Online IP address (zero if not online)
		public ushort wPortOnline; // Online port
		[WireInfo(ArraySize=6)]  
		public byte[] abEnet = new byte[6];   // Ethernet MAC address
		[WireInfo(ArraySize=20)] 
		public byte[] abOnline = new byte[20]; // Online identification

		///////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Validates given value agaist current state
		/// </summary>
		/// <param name="xnAddr">Test value</param>
		public void Check( XNADDR xnAddr )
		{
			if( ina != xnAddr.ina )
			{
				throw new Exception( "Check XNADDR: ina - Expected "+ina+", Given "+xnAddr.ina );
			}
			if( inaOnline != xnAddr.inaOnline )
			{
				throw new Exception( "Check XNADDR: inaOnline - Expected "+inaOnline+", Given "+xnAddr.inaOnline );
			}
			if( wPortOnline != xnAddr.wPortOnline )
			{
				throw new Exception( "Check XNADDR: wPortOnline - Expected "+wPortOnline+", Given "+xnAddr.wPortOnline );
			}
			if( ! ArrayEx.Compare( abEnet, xnAddr.abEnet ) )
			{
				throw new Exception( "Check XNADDR: abEnet - Expected "+ArrayEx.ToString( abEnet )+", Given "+ArrayEx.ToString( xnAddr.abEnet ) );
			}
			if( ! ArrayEx.Compare( abOnline, xnAddr.abOnline ) )
			{
				throw new Exception( "Check XNADDR: abOnline - Expected "+ArrayEx.ToString( abOnline )+", Given "+ArrayEx.ToString( xnAddr.abOnline ) );
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNKID : WireData
	{
		public XNKID() : this( 0xacae1dee ) {}
		public XNKID( ulong ul ) { ab = ul; }
			
		public ulong ab; // byte[8]: xbox to xbox key identifier

		///////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Validates given value agaist current state
		/// </summary>
		/// <param name="xnKID">Test value</param>
		public void Check( XNKID xnKID )
		{
			if( ab != xnKID.ab )
			{
				throw new Exception( "Check XNKID: ab - Expected "+ab+", Given "+xnKID.ab );
			}
		} 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Part of Online Socket Library client endpoint desciptors (from winsockx.h)
	/// </summary>
	public class XNKEY : WireData
	{
		public XNKEY() : this( 0xcccccccc, 0xeeeeeeee ) {}
		public XNKEY( ulong ul1, ulong ul2 ) { ab1 = ul1; ab2 = ul2; }

		public ulong ab1; // byte[16]: xbox to xbox key exchange key
		public ulong ab2; 

		///////////////////////////////////////////////////////////////////////
		// Check
		//
		public void Check( XNKEY xnKey )
		{
			if( ab1 != xnKey.ab1 )
			{
				throw new Exception( "Check XNKEY: ab1 - Expected "+ab1+", Given "+xnKey.ab1 );
			}
			if( ab2 != xnKey.ab2 )
			{
				throw new Exception( "Check XNKEY: ab2 - Expected "+ab2+", Given "+xnKey.ab2 );
			}
		} 
	} 

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common header for Pres and Noti messages (BASE_MSG_HEADER)
	/// </summary>
	public class PNMsgHdr : WireData
	{
		public uint   MsgType; // Unique Msg ID: PMSG_xxx, QMSG_xxx, or MSGTYPE_ACK
		public uint   MsgLen;  // Amount of data in message following this header
		public uint   SeqNum;  // Distinguishes individual messages within a session (incremented by client)
		public SGADDR Sgaddr;  // Unique session identifier (Set up by SG when client connects)
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Base class for specific Pres and Noti message data.
	/// </summary>
	public abstract class PNMsgData : WireData
	{
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common wrapper for commom Presence and notication message header and custom data.
	/// (Duplicates Read and Write stream semantics without derivation or specific
	/// overloading becuse the Wiredata constructor did not like some of the stuff
	/// that needed to be ddone here. The PresNoti protocol is not very stream friendly.)
	/// </summary>
	public class PNMsg
	{
		public PNMsgHdr  Hdr  = null;
		public PNMsgData Data = null;

		//////////////////////////////////////
		/// <summary>
		/// Loads known Pres and Noit reply messaages from a data stream.
		/// </summary>
		/// <param name="stream">Reply message data stream</param>
		public void ReadStream( Stream stream )
		{
			// Get header from stream
			Hdr = new PNMsgHdr();
			Hdr.ReadStream( stream );
            byte[] data = null;
            if (Hdr.MsgLen <= stream.Length)
            {
                // Get rest of data from stream
                data = new byte[Hdr.MsgLen];
                stream.Read(data, 0, data.Length);
            }
			
			// Load specific message data
			switch( Hdr.MsgType )
			{
				case XonPresNoti.PMSG_ALIVE_REPLY:
					Data = new PAliveReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_LIST_REPLY:
					Data = new QDequeueReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_WEB_FRIENDS_REPLY:
					Data = new PWebFriendReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_WEB_ALIVE_REPLY:
					Data = new PWebAliveReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SESSION_REPLY:
					Data = new PPeerSessionReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.MSGTYPE_ACK:
					Data = new PNBaseAckReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_MESSAGES_REPLY:
					Data = new QEnumMsgsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_MESSAGES_2_REPLY:
					Data = new QEnumMsgs2ReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_SUMMARY_REPLY:
					Data = new QSummaryReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_SUMMARY_2_REPLY:
					Data = new QSummary2ReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_DETAILS_REPLY:
					Data = new QDetailsReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_DELETE_MESSAGE_REPLY:
					Data = new QDeleteMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_SEND_MESSAGE_REPLY:
					Data = new QSendMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_REVOKE_MESSAGE_REPLY:
					Data = new QRevokeMsgReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_DELETE_TITLE_REPLY:
					Data = new QDeleteTitleReplyMsgData();
					Data.ReadBytes( data );
					break;
				
				case XonPresNoti.QMSG_ENUM_TITLES_REPLY:
					Data = new QEnumTitlesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_MESSAGE_FLAGS_REPLY:
					Data = new QFlagsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_ENUM_SYSTEM_MESSAGES_REPLY:
					Data = new QEnumSystemMsgsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_SYSTEM_MESSAGE_DETAILS_REPLY:
					Data = new QSystemDetailsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_DELETE_SYSTEM_MESSAGE_REPLY:
					Data = new QDeleteSystemMsgReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.QMSG_SEND_SYSTEM_MESSAGE_REPLY:
					Data = new QSendSystemMsgReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_LIST_TEAMS_REPLY:
					Data = new PListTeamsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_LIST_MEMBERS_REPLY:
					Data = new PListTeamMembersReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_CREATE_REPLY:
					Data = new PCreateTeamReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_DELETE_REPLY:
					Data = new PDeleteTeamReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_REMOVE_REPLY:
					Data = new PRemoveTeamMemberReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_MANAGE_TEAM_REPLY:
					Data = new PManageTeamReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_MANAGE_MEMBER_REPLY:
					Data = new PManageTeamMemberReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_RECRUIT_REPLY:
					Data = new PRecruitTeamMemberReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_JOIN_REPLY:
					Data = new PJoinTeamReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_GET_TICKET_REPLY:
					Data = new PGetTeamTicketReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SUBSCRIBE_REPLY:
					Data = new PPeerSubscribeReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_UNSUBSCRIBE_REPLY:
					Data = new PPeerUnsubscribeReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_GET_STATE_REPLY:
					Data = new PGetStateReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_IS_AFFILIATE_REPLY:
					Data = new PIsAffiliateReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_QUERY_AFFILIATES_REPLY:
					Data = new PQueryAffiliatesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PRESENCE_INFO_REPLY:
					Data = new PPresenceInfoReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_FIND_USER_REPLY:
					Data = new PFindUserReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_CHECK_TITLE_MESSAGES_REPLY:
					Data = new PCheckTitleMessagesReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_TEAM_LIST_USER_TEAMS_REPLY:
					Data = new PListUserTeamsReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_LOGON_CHECK_REPLY:
					Data = new PLogonCheckReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_FIND_USERS_REPLY:
					Data = new PFindUsersReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_PEER_SUBSCRIBE_EX_REPLY:
					Data = new PPeerSubscribeExReplyMsgData();
					Data.ReadBytes( data );
					break;

				case XonPresNoti.PMSG_GET_FRIENDS_LIST_REPLY:
					Data = new PGetFriendsListReplyMsgData();
					Data.ReadBytes( data );
					break;

				default:
					throw new Exception( "PN reply message type unknown" );
			}
		}

		//////////////////////////////////////
		/// <summary>
		/// Serializes Pres and Noti request messages to a data stream.
		/// </summary>
		/// <param name="stream">Request message data stream</param>
		public void WriteStream( Stream stream )
		{
			// Write Msg Data to intermediate stream
			MemoryStream DataStream = new MemoryStream();
			Data.WriteStream( DataStream );

			// Set Msg Data length
			Hdr.MsgLen = (uint)DataStream.Length;
			
			// Write header and data
			Hdr.WriteStream( stream );
			DataStream.WriteTo( stream );
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to the common Base Ack Reply
	/// </summary>
	public class PNBaseAckReplyMsgData : PNMsgData
	{
		public uint  AckMsgType; // MsgType of message being acknowledged
		public uint  AckSeqNum;  // SeqNum of message being acknowledged
		public ulong AckUserID;
		public uint  HRAck;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Combines Msg data with properties needed to process requests
	/// </summary>
	public abstract class PNRequestMsg
	{
		public PNMsg Msg = new PNMsg();

		//////////////////////////////////////
		/// <summary>
		/// Source of request
		/// </summary>
		public enum Requestor { Client, PresInh }
		public Requestor SentFrom = Requestor.Client;

		//////////////////////////////////////
		/// <summary>
		/// FD Port to use when sending to FD 
		/// </summary>
		public enum FDPort { None, PresNoti, Teams, Messaging, PresNoti_DC, Teams_DC, Messaging_DC }
		public FDPort PortOnFD = FDPort.None;

		//////////////////////////////////////
		/// <summary>
		/// Auth Method to use when sending to FD
		/// </summary>
		public enum FDAuth { None, SGMsg, HttpHdr };
		public FDAuth AuthMethod = FDAuth.None;

		//////////////////////////////////////
		/// <summary>
		/// Client version added to User Agent string if non-zero when http header is created
		/// </summary>
		public ulong ClientVersion
		{
			get{ return clientVersion; }
			set
			{
				if( clientVersion != value )
				{
					clientVersion = value;
				}
			}
		}
		private ulong clientVersion = 5960;  // Needs to be set so it can go in the header always

		//////////////////////////////////////
		/// <summary>
		/// Service Url used to create http header
		/// </summary>
		public string ServiceUrl 
		{
			get{ return serviceUrl; }
			set
			{
				if( serviceUrl != value )
				{
					serviceUrl = value;
				}
			}
		}
		private string serviceUrl = "";

		//////////////////////////////////////
		/// <summary>
		/// Service User agent used in http header
		/// </summary>
		public string ServiceUA
		{
			get{ return serviceUA; }
			set
			{
				if( serviceUA != value )
				{
					serviceUA = value;
				}
			}
		}
		private string serviceUA  = "";

		//////////////////////////////////////
		/// <summary>
		/// FD Service to request, Loads Url, service ID, and UA (based on service ID)
		/// </summary>
		public enum FDService {	None, Presence, Notification, Messaging, Teams }
		public FDService ServiceOnFD
		{
			set
			{ 
				switch( value )
				{
					case FDService.Presence:
						ServiceId  = XOService.PresNotification;
						ServiceUrl = XonPresNoti.PRESENCE_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.PresServ_VER_MAJOR+"."+
							XonPresNoti.PresServ_VER_MINOR.ToString("00");
						break;
					case FDService.Notification:
						ServiceId  = XOService.PresNotification;
						ServiceUrl = XonPresNoti.NOIFICATION_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.PresServ_VER_MAJOR+"."+
							XonPresNoti.PresServ_VER_MINOR;
						break;
					case FDService.Teams:
						ServiceId  = XOService.Teams;
						ServiceUrl = XonPresNoti.TEAMS_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.TeamServ_VER_MAJOR+"."+
							XonPresNoti.TeamServ_VER_MINOR;
						break;
					case FDService.Messaging:
						ServiceId  = XOService.MessagingService;
						ServiceUrl = XonPresNoti.MESSAGING_URL;
						ServiceUA  = 
							ServiceId.ToString( "x" )+"/"+
							XonPresNoti.MessServ_VER_MAJOR+"."+
							XonPresNoti.MessServ_VER_MINOR;
						break;
					case FDService.None:
					default:
						ServiceId  = XOService.InvalidService;
						ServiceUrl = "";
						ServiceUA  = "";
						break;
				}
			}
		}
        public XOService ServiceId = XOService.InvalidService;

		public WebHeaderCollection GetFDHttpHdr( ref CSGInfo slot, long lContentLength )
		{
            WebHeaderCollection header = new WebHeaderCollection();

            string serviceUserAgent = ServiceUA;
			
			if( ClientVersion != 0 )
			{
				ServiceUA += "."+ClientVersion;
			}

            header.Add("User-Agent", serviceUserAgent);

            string serviceContentType = "xon/" + ServiceId.ToString("x");
			header.Add( "Content-Type", serviceContentType );

			if( AuthMethod == FDAuth.HttpHdr )
			{
				HTTPAuthData authData = new HTTPAuthData(0, 0, 0, slot.userPuid0, slot.titleId, (uint)ServiceId, 0);

				// Setup additional properties
				authData.wLanguageID = slot.languageID;
				authData.dwAuthDataFlags = slot.authDataFlags;

				// Populate user slot info
				authData.xUsers[0].qwUserID = slot.userPuid0;
				authData.xUsers[1].qwUserID = slot.userPuid1;
				authData.xUsers[2].qwUserID = slot.userPuid2;
				authData.xUsers[3].qwUserID = slot.userPuid3;

				authData.xUsers[0].dwUserFlags = slot.userFlag0;
				authData.xUsers[1].dwUserFlags = slot.userFlag1;
				authData.xUsers[2].dwUserFlags = slot.userFlag2;
				authData.xUsers[3].dwUserFlags = slot.userFlag3;

				header.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA,authData.GetBase64EncodedString());
			}
            return header;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgDeleteSystemMsg.cs ===
// QMsgDeleteSystemMsg.cs
//
//	Notification (Messaging) Delete System Msg message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete specified system message
	/// </summary>
	public class QMsgDeleteSystemMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="titleId">Title responsible for message</param>
		/// <param name="msgId">Id of message</param>
		public QMsgDeleteSystemMsg( uint titleId, uint msgId, bool RevokeAlso )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_SYSTEM_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QDeleteSystemMsgMsgData data = new QDeleteSystemMsgMsgData();
			data.TitleID = titleId;
			data.MsgID   = msgId;
			data.Flags   = RevokeAlso ? XonPresNoti.DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL : 0x0;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete System Msg request
	/// </summary>
	public class QDeleteSystemMsgMsgData : PNMsgData
	{
		public uint TitleID;
		public uint MsgID;
		public uint Flags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete System Msg reply
	/// </summary>
	public class QDeleteSystemMsgReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgDeleteTitle.cs ===
// QMsgDeleteTitle.cs
//
//	Notification (Messaging) Delete Title Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete title
	/// </summary>
	public class QMsgDeleteTitle : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		/// <param name="titleId">Id of title</param>
		public QMsgDeleteTitle( PNState user, uint titleId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_TITLE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QDeleteTitleMsgData data = new QDeleteTitleMsgData();
			data.UserID  = user.UserId;
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Title request
	/// </summary>
	public class QDeleteTitleMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Title reply
	/// </summary>
	public class QDeleteTitleReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgDeleteMsg.cs ===
// QMsgDeleteMsg.cs
//
//	Notification (Messaging) Delete Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Delete message for a user
	/// </summary>
	public class QMsgDeleteMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="msgId">Id of message</param>
		/// <param name="flags"></param>
		public QMsgDeleteMsg( PNState user, uint msgId, uint flags )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DELETE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QDeleteMsgMsgData data = new QDeleteMsgMsgData();
			data.UserID    = user.UserId;
			data.MessageID = msgId;
			data.Flags     = flags;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Msg request
	/// </summary>
	public class QDeleteMsgMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
		public uint  Flags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Delete Msg reply
	/// </summary>
	public class QDeleteMsgReplyMsgData : PNMsgData
	{
		public uint HR;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgDequeue.cs ===
// QMsgDequeue.cs
//
//	Notification Dequeue Message
//

using System;
using System.IO;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Retrieves and deletes notificaion messege queue items for a user
	/// </summary>
	public class QMsgDequeue : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of queue</param>
		/// <param name="qType">One of the available Message Queue types (see XonPresNoti)</param>
		public QMsgDequeue( PNState user, ushort qType )  : this(user, qType, 0, 100, UInt16.MaxValue)
		{
		}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of queue</param>
		/// <param name="qType">One of the available Message Queue types (see XonPresNoti)</param>
		/// <param name="startItemID">First queue item in list to dequeue</param>
		/// <param name="maxItems">The maximum number of items that can dequeue</param>
		/// <param name="maxTotalItemDataSize">The maximum number of bytes to allocate for the item buffer on the server</param>
		public QMsgDequeue( PNState user, ushort qType, uint startItemID, ushort maxItems, uint maxTotalItemDataSize)
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.PresNoti;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Notification;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_DEQUEUE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QDequeueMsgData data = new QDequeueMsgData();
			data.UserID               = user.UserId;
			data.QType                = qType;
			data.StartItemID          = startItemID;
			data.MaxItems             = maxItems;
			data.MaxTotalItemDataSize = maxTotalItemDataSize;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Dequeue request
	/// </summary>
	public class QDequeueMsgData : PNMsgData
	{
		public ulong  UserID;
		public ushort QType; // const: PQUEUE_xxx
		public uint   StartItemID;
		public ushort MaxItems;
		public uint   MaxTotalItemDataSize;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Top level of message data specific to Dequeue reply
	/// </summary>
	public class QDequeueReplyMsgData : PNMsgData
	{
		public ListReplyHdr Hdr;
		public ushort       ItemsLen;
		public ListItem[]   Items;

		public override WireData ReadStream( BinaryReader reader )
		{
			Hdr = (ListReplyHdr) new ListReplyHdr().ReadStream( reader );
			ItemsLen = Hdr.ItemsLen;
			Items = new ListItem[ ItemsLen ];
			
			for( int i = 0; i < Items.Length; i++ )
			{
				Items[i] = new ListItem();
				Items[i].Hdr = new ListItemHdr();
				Items[i].Hdr.ReadStream( reader );

				// Get rest of data from stream
				byte[] itemData = new byte[ Items[i].Hdr.ItemLen ];
				reader.Read( itemData, 0, itemData.Length );

				switch( Hdr.QType )
				{
					case XonPresNoti.PQUEUE_PRESENCE:
						Items[i].Data = new PresenceItem();
						break;

					case XonPresNoti.PQUEUE_BUDDY_REQ:
					case XonPresNoti.PQUEUE_LIST_CHANGE:
						Items[i].Data = new ListChangeItem();
						break;

					case XonPresNoti.PQUEUE_INVITE:
						Items[i].Data = new InvitationItem();
						break;
					
					case XonPresNoti.PQUEUE_INVITE_ANSWER:
						Items[i].Data = new InvitationAnswerItem();
						break;

					case XonPresNoti.PQUEUE_PEER_PRESENCE:
						Items[i].Data = new PeerPresenceItem();
						break;
					
					case XonPresNoti.PQUEUE_PRESENCE_2:
						Items[i].Data = new Presence2Item();
						break;
					
					default:
						throw new Exception( "List reply queue type unknown" );
				}
				Items[i].Data.ReadBytes( itemData );
			}

			return this;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Header portion of message data specific to Dequeue reply.
	/// </summary>
	public class ListReplyHdr : WireData
	{
		public ulong     UserID;
		public ushort    QType;
		public uint      HR;
		public uint      NextItemID;
		public ushort    QLeft;
		public ushort    ItemsLen;
		public uint      TotalItemDataSize;
		public uint	     QValsLen;
		public uint[]    QVals;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Top level of List Item. One or more of these follow ListReplyHdr in message data 
	/// specific to Dequeue reply.
	/// </summary>
	public class ListItem	
	{
		public ListItemHdr  Hdr;
		public ListItemData Data;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Common header for all QType specific list items
	/// </summary>
	public class ListItemHdr : WireData
	{
		public uint   ItemID;
		public ushort ItemLen;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Base class for QType specific list items
	/// </summary>
	abstract public class ListItemData : WireData
	{
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Presence list item specific data
	/// </summary>
	public class PresenceItem : ListItemData
	{
		public ulong  BuddyID;
		public uint   TitleID;
		public uint   State;
		public ulong  MatchSessionID;
		public ushort NicknameLen;
		public ushort TitleStuffLen;
		public byte[] Nickname;
		public byte[] TitleStuff;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Presence2 list item specific data
	/// </summary>
	public class Presence2Item : ListItemData
	{
		public ulong    BuddyID;
		public uint     TitleID;
		public uint     State;
		public ulong    MatchSessionID;
        public uint     BuddyStateTime;        
        public ushort   RichPresenceLen;
        public ushort   DataLen;
        public string   RichPresence;        
        public byte[]   Data;
		
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Peer Presence list item specific data
	/// </summary>
	public class PeerPresenceItem : ListItemData
	{
		public ulong  UserID;
		public uint   TitleID;
		public uint   State;
		public ulong  MatchSessionID;
		public ushort TitleStuffLen;
		public byte[] TitleStuff;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// List Change list item specific data. (Also used for buddy requests.)
	/// </summary>
	public class ListChangeItem : ListItemData
	{
		public uint   ListVersion;
		public ulong  TargetID;
		public ushort OperationID; // const: PLIST_BUDDY_xxx
		public uint   HR;
		public ushort TargetAcctNameLen;
		public string TargetAcctName;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inivitation list item specific data
	/// </summary>
	public class InvitationItem : ListItemData
	{
		public ulong       HostID;
		public ulong       MatchSessionID;
		public uint        TitleID;
		public DateTime    TimeSent;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Inivitation Answer list item specific data
	/// </summary>
	public class InvitationAnswerItem : ListItemData
	{
		public ulong       InviteeID;
		public ulong       MatchSessionID;
		public DateTime    TimeSent;
		public ushort      Answer; // const: PINVITE_REPLY_xxx
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgAdd.cs ===
// QMsgAdd.cs
//
//	Notification Add Item Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Tell Notificaion to add a new item of the given item type to one or more users' 
	/// queues. (Only needed when isolating notification.  Presence normally does this 
	/// for it's QTypes.)
	/// </summary>
	public class QMsgAdd : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="qType">One of the available Message Queue types</param></param>
		/// <param name="users">PUIDS of users to get Message</param>
		/// <param name="itemData">Message Data</param>
		public QMsgAdd( ushort qType, ulong[] users, byte[] itemData )
		{
			SentFrom    = Requestor.PresInh;
			PortOnFD    = FDPort.None;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.None;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ADD;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QAddMsgData data = new QAddMsgData();
			data.QType    = qType;
			data.Users    = users;
			data.ItemData = itemData;

			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Add request
	/// </summary>
	public class QAddMsgData : PNMsgData
	{
		public ushort  QType; // const: PQUEUE_xxx
		public ushort  UsersLen; 
		public ulong[] Users;
		public byte[]  ItemData;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgDetails.cs ===
// QMsgDetails.cs
//
//	Notification (Messaging) Details Message
//

using System;
using System.IO;
using live.common;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get details of specified message for a user
	/// </summary>
	public class QMsgDetails : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="msgId">Id of message</param>
		/// <param name="setFlags"></param>
		/// <param name="unsetFlags"></param>
		public QMsgDetails( PNState user, uint msgId, uint setFlags, uint unsetFlags )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_DETAILS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QDetailsMsgData data = new QDetailsMsgData();
			data.UserID     = user.UserId;
			data.MessageID  = msgId;
			data.SetFlags   = setFlags;
			data.UnsetFlags = unsetFlags;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Details request
	/// </summary>
	public class QDetailsMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
		public uint  SetFlags;
		public uint  UnsetFlags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Details reply
	/// </summary>
	public class QDetailsReplyMsgData : PNMsgData
	{
		public uint           HR;
		public UserMsgSummary Summary;
		public MsgDetails     Details;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			// Read HR
			HR = binaryReader.ReadUInt32();

			// Read summary
			Summary = new UserMsgSummary();
			Summary.ReadStream(binaryReader);

			// Conditionally read details
			if(HResult.Succeeded(HR))
			{
				Details = new MsgDetails();
				Details.ReadStream(binaryReader);
			}

			return this;
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\PNState.cs ===
// PNState.cs
//
//  Presence and Notification User Sim Object
//

using System;
using System.Text;
using System.Threading;
using System.Collections;
using live.common;

using MsgDefs = xonline.common.protocol.MsgDefs;

namespace live.protocol.Presence
{
    /// <summary>
    /// Simulation state for a user in the the presence and notificatiion system.
    /// This is state storage, the methods here to not attempt to maintain consistency 
    /// or correctness of User state data.
    /// </summary>
    public class PNState : IDisposable
	{
		public static double DefaultNotificationWait = 60.0;             // 60 seconds


		// Polling interval for qval changes in milliseconds(Dependent on QVal updates from
		// presence, but this is the rate that we will request qval updates from the 
		// FakeSG over the remoting port.)
		public static int QValPollingInterval = 250;
        public const uint MAX_QVAL_QUEUE_SIZE = 1000;
        public Queue QValPacketQueue = new Queue();

		// Static Lookup table for All users
		private static Hashtable Lookup = new Hashtable();
		public static PNState Find( ulong id )
		{
            lock (Lookup.SyncRoot)
            {
                return (PNState)(Lookup.Contains(id) ? Lookup[id] : null);
            }
		}

        public static PNState FindOrCreate(IClient client, XblUser user, IXOnSecurityProvider xbox)
        {
            PNState state = null;
            lock (Lookup.SyncRoot)
            {
                if (Lookup.Contains(user.Puid))
                {
                    return (PNState)Lookup[user.Puid];
                }
                
                state = new PNState(client, user, xbox);
            }
            return state;
        }
        public static PNState Service = new PNState("LiveService", 0);

		// Time to wait for Buddy list notifications 
		public double NotificationWait = DefaultNotificationWait;


		/// <summary>
		/// Enumerated flags passed or'd together can be passed
		/// to HandleQValPacket to control how qval data is processed
		/// </summary>
		public const uint HQV_ReadMessages   = 0x00000001;   // Mark messages processed as read
		public const uint HQV_DeleteMessages = 0x00000002;   // Delete messages as read

		/// <summary>
		/// Used to store information about users buddies
		/// </summary>
		public class BuddyInfo
		{
			public PNState User;
			public byte   Status = XonPresNoti.NOT_A_BUDDY; // or const: P_BUDDY_STATUS_xxx
			public string Name;

			public InvitationItem   Invitation;
			public PresenceItem     Presence;
			public Presence2Item    RichPresence;
            public bool             Validate;

			public BuddyInfo( byte status, string name)
			{
				Status = status;
				Name   = name;
                Validate = false;
			}

			public BuddyInfo( byte status, PNState user)
			{
				Status = status;
				Name = user.Name;
				User = user;
                Validate = false;
			}
		}

		/// <summary>
		/// Represents an invitation from a user to a game session. If the Host == this then this is
		/// an out going InvitationItem
		/// </summary>
		public class InvitationInfo
		{
			public bool            Owns;                  // True when the user created this invitation
			public PNState          Host;                  // Host of the match session
			public ulong           MatchSession;          // Outgoing invites will have this field set but no dequeud invite item
			public ulong           Context;               // Extra context for use with competitions 
			public PNState[]        Invited;               // List of invited users
			public InvitationItem  Invitation;            // Dequeued invitation record from presence.
			public InvitationAnswerItem InvitationAnswer; // Dequeued invitation answer from presence.
			public uint            MessageId;             // Message ID of the invitation

			public InvitationInfo()
			{
				Host         = null;
				MatchSession = 0;
				Invitation   = null;
			}

			public InvitationInfo(PNState host)
			{
				Host         = host;
				MatchSession = 0;
				Invitation   = null;
			}

			public InvitationInfo(PNState host, ulong sessionId)
			{
				Host         = host;
				MatchSession = sessionId;
				Invitation   = null;
			}
		}

		/// <summary>
		/// Represents a peer subscription to another user
		/// </summary>
		public class PeerInfo
		{
			public PNState           User;         // Reference to peer
			public PeerPresenceItem PeerPresence; // Dequeued peer presence data;
			public PresenceItem     Presence;     // Dequeued presence data
			public Presence2Item    RichPresence; // Dequeued presence2 data 
			public InvitationItem   Invitation;   // Dequeued invitation record from presence.
            public bool Validate;

			public PeerInfo()
			{
				User           = null;
				PeerPresence   = null;
				Presence       = null;
				RichPresence   = null;
				Invitation     = null;
                Validate       = false;
			}

			public PeerInfo(PNState user)
			{
				User           = user;
				PeerPresence   = null;
				Presence       = null;
				RichPresence   = null;
				Invitation     = null;
                Validate       = false;
			}
		}

		/// <summary>
		/// Represents message data that was received in a messaging QVAL
		/// </summary>
		public class MessageInfo
		{
			public bool            Deleted;
			public uint            Id;
			public uint            Data;
			public UserMessage     Message;

			public byte MessageType
			{
				get {
					return (byte)(Data >> 24);
				}
			}

			public bool IsSameTitle
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_SAME_TITLE));
				}
			}
			public bool IsSamePublisher
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_SAME_PUBLISHER));
				}
			}
			public bool IsInviteFromFriend
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND));
				}
			}
			public bool HasVoice
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_HAS_VOICE));
				}
			}
			public bool HasText
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_HAS_TEXT));
				}
			}
			public bool IsAltTitle
			{
				get {
					return (0 != (Data & XonPresNoti.MSG_NOTIFICATION_FLAG_ALT_TITLE));
				}
			}

			public override string ToString()
			{
				return "Id: " + Id + "(" + XonPresNoti.BuildMsgNotificationFlagsString(Data) + "), Del?: " + Deleted.ToString();
			}

		}


		// Fixed state data 
        public XblUser User = null;
		public ulong     UserId
        {
            get
            {
                if (User != null)
                {
                    return User.Puid;
                }
                return 0;
            }
        }

        public string Name
        {
            get
            {
                if (User != null)
                {
                    return User.Gamertag;
                }
                return "";
            }
        }


        public IClient Client;
        public IXOnSecurityProvider Xbox;

		// Variable state data
		public byte[]    WebId          = {};
		public uint      State          = XonPresNoti.P_STATE_MASK_NONE;
		public byte[]    TitleStuff     = {};
		public byte[]    Nickname       = {};
		public ulong     MatchSessionId = 0;
		public uint      BuddyListVer   = 0;
		public uint      BlockListVer   = 0;
        
        // When true use HttpHdr auth, set with WebAlive/unset with WebLogoff
        private bool     IsWebUser = false; 

		private Hashtable Buddies       = null; // Hash of friend PUID to BuddyInfo objects
		private ArrayList Blocks        = null; // List of blocks created by this user
		private Hashtable Invites       = null; // Hash of invitee PUID to InviteInfo objects
		private Hashtable Peers         = null; // Hash of peer PUID to PeerInfo objects
		private Hashtable Messages      = null; // Hash of message ID to MessageInfo objects
        private AffiliateState Affiliates = null; // All affiliate data
		private GIBlob    _GIBlob       = null;
		private static Hashtable EmptyHash  = new Hashtable();
		private static ArrayList EmptyList  = new ArrayList();


		public IDictionaryEnumerator BuddyEnumerator
		{
			get {
				return (Buddies!=null) ? Buddies.GetEnumerator() : EmptyHash.GetEnumerator();
			}
		}

		public IEnumerator BlocksEnumerator
		{
			get {
				return (Blocks!=null) ? Blocks.GetEnumerator() : EmptyList.GetEnumerator();
			}
		}

		public IDictionaryEnumerator InviteEnumerator
		{
			get {
				return (Invites!=null) ? Invites.GetEnumerator() : EmptyHash.GetEnumerator();
			}
		}

		public IDictionaryEnumerator PeerEnumerator
		{
			get {
				return (Peers!=null) ? Peers.GetEnumerator() : EmptyHash.GetEnumerator();
			}
		}
		
		public IDictionaryEnumerator MessageEnumerator
		{
			get {
				return (Messages!=null) ? Messages.GetEnumerator() : EmptyHash.GetEnumerator();
			}
		}

        public AffiliateState LoadedAffiliates
        {
            get
            {
                return Affiliates.Clone();
            }
        }

		// counts on classes of buddies
		public uint BuddiesOK           // 0
		{
			get
			{
				uint c = 0;
				IDictionaryEnumerator enumerator = BuddyEnumerator;
				while(enumerator.MoveNext())
				{
					BuddyInfo bi = enumerator.Value as BuddyInfo;
					if(bi.Status == 0)
					{
						c++;
					}
				}
				return c;
			}
		}

		public uint BuddiesPending      // 1
		{
			get
			{
				uint c = 0;
				IDictionaryEnumerator enumerator = BuddyEnumerator;
				while(enumerator.MoveNext())
				{
					BuddyInfo bi = enumerator.Value as BuddyInfo;
					if(bi.Status == 1)
					{
						c++;
					}
				}
				return c;
			}
		}

		public uint BuddiesRequested    // 2
		{
			get
			{
				uint c = 0;
				IDictionaryEnumerator enumerator = BuddyEnumerator;
				while(enumerator.MoveNext())
				{
					BuddyInfo bi = enumerator.Value as BuddyInfo;
					if(bi.Status == 2)
					{
						c++;
					}
				}
				return c;
			}
		}

		public uint BuddiesAny
		{
			get 
			{
				return (uint)(null != Buddies ? Buddies.Count : 0);
			}
		}

		public uint PeerSubscriptions
		{
			get 
			{
				return (uint)(null != Peers ? Peers.Count : 0);
			}
		}

        public PNState[] PeerSubscribes
        {
            get
            {
                PNState[] peerSubscribes = new PNState[Peers != null ? Peers.Count : 0];
                int iPeer = 0;
                foreach (PeerInfo peerInfo in Peers.Values)
                {
                    peerSubscribes[iPeer] = peerInfo.User;
                    iPeer++;
                }
                
                return peerSubscribes;
            }
        }


        // counts on invitation that received
        public uint NumberOfInvitations
        {
            get
            {
                return (this.Invites != null) ? ((uint)this.Invites.Count) : 0;
            }
        }
		// Invitation signal count
		private uint LastInviteBlipCount;
		private QValPacket _LastQValPacket = new QValPacket();


		// Lastest QVal packet delivery 
		public QValPacket LastQValPacket
		{
			get {
				ProcessQVals();
				return _LastQValPacket;
			}
		}

		public GIBlob GIBlob {
			get {
				if(null == _GIBlob)
				{
					_GIBlob = new GIBlob();
				}
				return _GIBlob;
			}
			set {
				_GIBlob = value;
			}
		}

        private PNState(string GamerTag, ulong UserId)
        {
            User = new XblUser(UserId, GamerTag);

            User.Settings.ExpandedState.Add(UserId, this);
        }

		/// <summary>
		/// Create with name raw values provided
		/// </summary>
		/// <param name="name">User's gamertag</param>
		/// <param name="userId">User's PUID</param>
		private PNState( IClient client, XblUser user ) 
		{
            Client = client;
            User = user;
            Xbox = new live.client.EmptySecurityProvider();

			Lookup[ UserId ] = this;

            User.Settings.ExpandedState.Add(user.Puid, this);
		}

        /// <summary>
		/// Create with name raw values provided, link user to provided console
		/// </summary>
		/// <param name="name">User's gamertag</param>
		/// <param name="userId">User's PUID</param>
		/// <param name="xbox">Linked console</param>
		private PNState( IClient client, XblUser user, IXOnSecurityProvider xbox)
        {
            Client = client;
            User = user;
            Connect(xbox);

            Lookup[ UserId ] = this;

            User.Settings.ExpandedState.Add(UserId, this);
        }

        private bool Disposed = false;

		~PNState()
		{
            // Dispose when the GC kicks in and if we haven't already cleaned up
            this.Dispose(!Disposed);
		}

        /// <summary>
        /// Public Dispose method that can be called. 
        /// For callers that want to control when cleanup happens.
        /// </summary>
        public void Dispose()
        {
            if (!this.Disposed)
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
                this.Disposed = true;
            }
        }

        /// <summary>
        /// Clean up managed (and unmanaged if we ever have any) resources
        /// </summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // clean up managed resources

                // At least try to give the lookup table a break.
                Lookup.Remove(this.UserId);

                User.Settings.ExpandedState.Remove(this.UserId);
            }

            // clean up unmanaged resources
        }

		/// <summary>
		/// Checks users state bits to see in online flag is set
		/// </summary>
		public bool LoggedOn
		{
			get{ return( 0 != (State & XonPresNoti.P_STATE_MASK_ONLINE) ); }
		}

		/// <summary>
		/// Checks if an xbox is set for this user
		/// </summary>
		public bool Connected
		{
            // null and empty can be used for not connected
			get{ return( Xbox != null 
                && !(Xbox is live.client.EmptySecurityProvider) ); }
		}

		/// <summary>
		/// Establish connection with FakeSG so it will start collecting QVals
		/// for this user
		/// </summary>
		/// <param name="xbox">Xbox that user will connect to FakeSG through</param>
		public void Connect( IXOnSecurityProvider xbox )
		{
			// Clear user off existing xbox
			if(null != Xbox)
			{
                Xbox.RemoveUser(User);
			}

			// Replace our xbox reference
			Xbox = xbox;
		}

		/// <summary>
		/// Remove association with fake SG, QVal reply will start reporting this
		/// user as not found 
		/// </summary>
		public void Disconnect()
		{
            PNMsgDeadUser deadUser = new PNMsgDeadUser(this);
            live.server.Presence.TransactFD(this, deadUser);

			// Reset the last qval 
			_LastQValPacket.Clear();
            // no longer associated with this client or security provider
            Xbox = null;
            Client = null;
			ClearState();
		}

		/// <summary>
		/// Reload the online presence record. 
		/// </summary>
		public void Invalidate()
		{
			// Async message request
			PMsgInvalidateUser req = new PMsgInvalidateUser(this);
			live.server.Presence.TransactFD(this, req);
		}

		/// <summary>
		/// Cleans out user login state
		/// </summary>
		public void ClearState()
		{
			// Notify that the user is clearing state as this has impacts on testing
			// internal state between calls to presence
			if(XonPresNoti.P_STATE_MASK_NONE != State && null != Buddies)
			{
				System.Diagnostics.Debug.WriteLine(String.Format("ClearState[{0:x}]", UserId));
				State          = XonPresNoti.P_STATE_MASK_NONE;
				TitleStuff     = new byte[0];
				Nickname       = new byte[0];
				MatchSessionId = 0;
				BuddyListVer   = 0;
				Buddies        = null;
				BlockListVer   = 0;
				Blocks         = null;
				Peers          = null;
				Invites        = null;
				Messages       = null;
			}
		}

        public uint Alive()
        {
            PMsgAlive aliveMsg = new PMsgAlive(this);
            return AliveInternal(aliveMsg);
        }

        public uint Alive2()
        {
            PMsgAlive2 aliveMsg = new PMsgAlive2(this);
            return AliveInternal(aliveMsg);
        }

		/// <summary>
		/// Build and send alive msg, then update state with default presecne flags and buddy
		/// and block list info returned
		/// </summary>
        private uint AliveInternal(PNRequestMsg aliveMsg)
		{
			PNMsg replyMsg;
            live.server.Presence.TransactFD(this, aliveMsg, out replyMsg);

			PAliveReplyMsgData reply = (PAliveReplyMsgData)replyMsg.Data;

			if( HResult.Failed( reply.HR ) )
			{ 
				throw new HResultException( reply.HR, "User[" + UserId.ToString("x") + "] Alive failed with HR = " + reply.HR.ToString( "X" ) + " in reply. " );
			}

			// Default State after a successfull alive
			State = XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_CLOAKED;           

			BuddyListVer = reply.BuddyListVersion;
			Buddies = new Hashtable( reply.Buddies.Length );
			foreach( BuddyData buddy in reply.Buddies )
			{
				PNState user = Find(buddy.BuddyID);
				if(user != null)
				{
					Buddies[ buddy.BuddyID ] = new BuddyInfo( buddy.Status, user );
				}
				else
				{
					Buddies[ buddy.BuddyID ] = new BuddyInfo( buddy.Status, buddy.Name );
				}
			}

			BlockListVer = reply.BlockListVersion;
			Blocks = new ArrayList( reply.Blocks );

            return reply.HR;
		}

        public void LoadAffiliates()
        {
            if (Affiliates == null)
            {
                Affiliates = new AffiliateState(this);
                Affiliates.Load();
            }
            else
            {
                Affiliates.Restore();
            }
        }

        public void AddAffiliate(PNState affiliate, uint flags)
        {
            if (Affiliates == null)
            {
                Affiliates = new AffiliateState(this);
                Affiliates.Load();
            }

            Affiliates.Add(affiliate, flags, Client.TitleId);
        }


        public uint WebAlive()
        {
            try
            {
                IsWebUser = true;

                // Do a quick Xbox check, if it doesn't exist create
                // a dummy entry so we can use existing message constructors
                // without changing them 
                if (null == Xbox)
                {
                    Xbox = new live.client.EmptySecurityProvider();
                }

                // Send the web alive request
                PMsgWebAlive aliveMsg = new PMsgWebAlive(this);
                PNMsg replyMsg;
                live.server.Presence.TransactFD(this, aliveMsg, out replyMsg);

                PWebAliveReplyMsgData reply = (PWebAliveReplyMsgData)replyMsg.Data;

                if (HResult.Failed(reply.HR))
                {
                    throw new HResultException(reply.HR, "User[" + UserId.ToString("x") + "] WebAlive failed with HR = " + reply.HR.ToString("X") + " in reply. ");
                }

                System.Diagnostics.Debug.WriteLine(String.Format("WebAlive[{0:x}]: HR: {1:x}", UserId, reply.HR));
                return reply.HR;
            }
            finally
            {
                Xbox = null;
            }
        }

        public void WebLogoff()
        {
            IsWebUser = false;
        }

        public void InternalTransactFD(PNRequestMsg request)
        {
            PNMsg reply;
            InternalTransactFD(request, out reply);
        }

        public void InternalTransactFD(PNRequestMsg request, out PNMsg reply)
        {
            if(IsWebUser)
            {
                // Change the authentication type
                request.AuthMethod = PNRequestMsg.FDAuth.HttpHdr;

                // Convert the port
                switch(request.PortOnFD)
                {
                    case PNRequestMsg.FDPort.PresNoti:
                        request.PortOnFD = PNRequestMsg.FDPort.PresNoti_DC;
                        break;
                    case PNRequestMsg.FDPort.Teams:
                        request.PortOnFD = PNRequestMsg.FDPort.Teams_DC;
                        break;
                    case PNRequestMsg.FDPort.Messaging:
                        request.PortOnFD = PNRequestMsg.FDPort.Messaging_DC;
                        break;
                }
            }
            live.server.Presence.TransactFD(this, request, out reply);
        }

		public uint CheckTitleMessages()
		{
            PMsgCheckTitleMessages req = new PMsgCheckTitleMessages(this, Xbox.TitleId, 1);//Xbox.TitleRegion);
			PNMsg resp;
            live.server.Presence.TransactFD(this, req, out resp);
			PCheckTitleMessagesReplyMsgData data = (PCheckTitleMessagesReplyMsgData)resp.Data;
			return data.HR;
		}

		/// <summary>
		/// Send a request to add a buddy.  
		/// Buddy list update happens if/when notificaiton is handled
		/// </summary>
		/// <param name="buddy">User being asked to be a buddy</param>
		public void AddBuddy( PNState buddy )
		{
			PMsgAddBuddy addMsg = new PMsgAddBuddy( this, buddy );
            InternalTransactFD(addMsg);
		}

		/// <summary>
		/// Send accept of a buddy request.
		/// Buddy list update happens if/when notificaiton is handled
		/// </summary>
		/// <param name="buddy">User that asked to be buddies</param>
		public void AcceptBuddy( PNState buddy )
		{
            BuddyInfo bi = GetBuddyInfo(buddy.UserId);
			PMsgAcceptBuddy acceptMsg = new PMsgAcceptBuddy( this, buddy );
			InternalTransactFD( acceptMsg );
            if (bi != null)
            {
                bi.Status = XonPresNoti.P_BUDDY_STATUS_ACCEPTED;
            }
		}

		/// <summary>
		/// Send reject of a buddy request.
		/// Buddy list update happens if/when notificaiton is handled
		/// </summary>
		/// <param name="buddy">User that asked to be buddies</param>
		public void RejectBuddy( PNState buddy ) 
		{ 
			RejectBuddy( buddy, false ); 
		}

		/// <summary>
		/// Send reject of a buddy request.
		/// Buddy list update happens if/when notificaiton is handled
		/// </summary>
		/// <param name="buddy">User that asked to be buddies</param>
		/// <param name="never">Never see buddy request from that user again</param>
		public void RejectBuddy( PNState buddy, bool never )
		{
			PMsgRejectBuddy rejectMsg = new PMsgRejectBuddy( this, buddy, never );
			InternalTransactFD( rejectMsg );
		}

		/// <summary>
		/// Send delete of requested buddy (accepted or not).
		/// Buddy list update happens if/when notificaiton is handled
		/// </summary>
		/// <param name="buddy">Buddy being deleted</param>
		public void DeleteBuddy( PNState buddy )
		{
			PMsgDeleteBuddy deletetMsg = new PMsgDeleteBuddy( this, buddy );
			InternalTransactFD( deletetMsg );
		}

		/// <summary>
		/// Send delete to all buddies and make sure all buddy lists (theirs and 
		/// ours) get updated by waiting for and handling notifications.
		/// </summary>
		public void DeleteAllBuddies()
		{
			ArrayList dead = new ArrayList();
			ulong[] keys = new ulong[Buddies.Keys.Count];
			Buddies.Keys.CopyTo(keys,0);
			foreach( ulong buddyId in keys )
			{
				BuddyInfo bi    = GetBuddyInfo(buddyId);
				PNState    buddy = PNState.Find(buddyId);

				if( buddy == null )
				{ 
					DeleteBuddy( buddy );
				}
				else
				{
					if( bi.Status == XonPresNoti.NOT_A_BUDDY )
					{
						// unlikely, normally removal happens when delete notification comes in.
						dead.Add( buddyId );
					}
					else
					{
						DeleteBuddy( buddy );
						WaitForBuddyStatusDeleted( buddy );
						buddy.WaitForBuddyStatusDeleted( this );
					}
				}
			}

			foreach( ulong buddyId in dead )
			{
				Buddies.Remove( buddyId );
			}
		}

		/// <summary>
		/// Lookup buddy information for any buddy state by the associated
		/// buddies user ID.
		/// </summary>
		public BuddyInfo GetBuddyInfo(ulong buddyId)
		{
			if(Buddies != null)
			{
				return Buddies[buddyId] as BuddyInfo;
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Add a user to the list of peer subscribed users.
		/// </summary>
		public void AddPeerSubscription(PNState peer)
		{
			AddPeerSubscription(new PNState[]{peer});
		}

		/// <summary>
		/// Add an array of users to the list of peer subscribed users.
		/// </summary>
		public void AddPeerSubscription(PNState []peers)
		{
			if(null == peers)
			{
				throw new ArgumentException("peers cannot be null");
			}

			// Create our new peer subscription array
			uint i = 0;
			PNState []subscribe = new PNState[PeerSubscriptions + peers.Length];

			// Add existing peers
			IDictionaryEnumerator e = PeerEnumerator;
			while(e.MoveNext())
			{
				PeerInfo info = (PeerInfo)e.Value;
				if(null != info)
				{
					subscribe[i++] = info.User;
				}
			}

			// Add new peers
			foreach(PNState peer in peers)
			{
				subscribe[i++] = peer;
			}

			// Update peer subscription
			PeerSubscribe(subscribe);
		}

		/// <summary>
		/// Remove one of the users that is subscribed and update subscriptions
		/// on server.
		/// </summary>
		public void RemovePeerSubscription(PNState peer)
		{
			RemovePeerSubscription(new PNState[]{peer});
		}

		/// <summary>
		/// Remove an array of users that are subscribed and update subscriptions
		/// on server.
		/// </summary>
		public void RemovePeerSubscription(PNState []peers)
		{
			// Remove existing peers 
			if(null != Peers && Peers.Count > 0)
			{
				foreach(PNState peer in peers)
				{
					if(Peers.Contains(peer.UserId))
					{
						Peers.Remove(peer.UserId);
					}
				}
			}

			// Create new peer subscription
			PNState []subscribe = new PNState[PeerSubscriptions];
			uint i = 0;
			IDictionaryEnumerator e = PeerEnumerator;
			while(e.MoveNext())
			{
				PeerInfo info = (PeerInfo)e.Value;
				if(null != info)
				{
					subscribe[i++] = info.User;
				}
			}

			// Update peer subscription
			PeerSubscribe(subscribe);
		}

		/// <summary>
		/// Peer subscribe to a single user. Replaces any subscriptions.
		/// </summary>
		public void PeerSubscribe(PNState topeer)
		{
			PeerSubscribe(new PNState[]{topeer});    
		}

		/// <summary>
		/// Peer subscribe to a list of users. Replaces any subscriptions.
		/// </summary>
		public void PeerSubscribe(PNState []topeerlist)
		{
			PMsgPeerSubscribe request = new PMsgPeerSubscribe( this, topeerlist );
			PNMsg reply;
            live.server.Presence.TransactFD(this, request, out reply);
			PPeerSubscribeReplyMsgData replyData = (PPeerSubscribeReplyMsgData)(reply.Data);
			if(HResult.Failed(replyData.HR))
			{
				throw new HResultException( replyData.HR, "PeerSubscribe failed User: " + UserId.ToString("x"));
			}

			// Allow the caller to pass in null for testing purposes, just clear
			// the peer hash if there is one and skip hash updates
			if(null == topeerlist)
			{
				if(null != Peers)
				{
					Peers.Clear();
				}

				goto lbDone;
			}

			// Update the hash with new peer info structures keeping existing 
			// peer info unless we don't have any peer info yet in which case
			// we can do the cheaper straight import
			if(null != Peers && Peers.Count > 0)
			{
				Hashtable NewPeers = new Hashtable(topeerlist.Length);
				foreach(PNState user in topeerlist)
				{
					if(!Peers.Contains(user.UserId))
					{
						NewPeers[user.UserId] = new PeerInfo(user);
					}
					else
					{
						NewPeers[user.UserId] = Peers[user.UserId];
					}
				}
				Peers = NewPeers;
			}
			else
			{
				if(null == Peers)
				{
					Peers = new Hashtable(topeerlist.Length);
				}

				foreach(PNState user in topeerlist)
				{
					Peers[user.UserId] = new PeerInfo(user);
				}
			}
lbDone:
			return;
		}


        /// <summary>
        /// Peer subscribe to a single user. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribeEx(PNState topeer)
        {
            PeerSubscribeEx(new PNState[] { topeer });
        }


        /// <summary>
        /// Peer subscribe to a list of users. Replaces any subscriptions.
        /// </summary>
        public void PeerSubscribeEx(PNState[] topeerlist)
        {
            PMsgPeerSubscribeEx pMsg = new PMsgPeerSubscribeEx(this, topeerlist);
            PNMsg reply;
            live.server.Presence.TransactFD(this, pMsg, out reply);
            PPeerSubscribeExReplyMsgData pReplyData = (PPeerSubscribeExReplyMsgData)(reply.Data);
            if (HResult.Failed(pReplyData.hr))
            {
                throw new HResultException(pReplyData.hr, "PeerSubscribeEx failed User: " + UserId.ToString("x"));
            }

            // Allow the caller to pass in null for testing purposes, just clear
            // the peer hash if there is one and skip hash updates
            if (null == topeerlist)
            {
                if (null != Peers)
                {
                    Peers.Clear();
                }

                goto lbDone;
            }

            // Update the hash with new peer info structures keeping existing 
            // peer info unless we don't have any peer info yet in which case
            // we can do the cheaper straight import
            if (null != Peers && Peers.Count > 0)
            {
                Hashtable NewPeers = new Hashtable(topeerlist.Length);
                foreach (PNState user in topeerlist)
                {
                    if (!Peers.Contains(user.UserId))
                    {
                        NewPeers[user.UserId] = new PeerInfo(user);
                    }
                    else
                    {
                        NewPeers[user.UserId] = Peers[user.UserId];
                    }
                }
                Peers = NewPeers;
            }
            else
            {
                if (null == Peers)
                {
                    Peers = new Hashtable(topeerlist.Length);
                }

                foreach (PNState user in topeerlist)
                {
                    Peers[user.UserId] = new PeerInfo(user);
                }
            }

            for (int i = 0; i < pReplyData.rgResults.Length; i++)
            {
                // TODO: what to do about xbox 1 users
                PeerInfo info = (PeerInfo)Peers[pReplyData.rgResults[i].qwUserID];
                if (info != null)
                {
                    // fill in what we know
                    Presence2Item richPresence = new Presence2Item();
                    richPresence.BuddyID = pReplyData.rgResults[i].qwUserID;
                    richPresence.State = pReplyData.rgResults[i].dwState;
                    richPresence.TitleID = pReplyData.rgResults[i].dwTitleID;
                    richPresence.BuddyStateTime = pReplyData.rgResults[i].mtUserTime;
                    richPresence.Data = new byte[0];
                    richPresence.RichPresence = "";
                    info.RichPresence = richPresence;
                }
            }

        lbDone:
            return;
        }


        /// <summary>
        /// Add Peer subscription to an add list of users. Remove any subscriptions from the delete list.
        /// </summary>
        public void PeerSubscribeEx(PNState[] Add, PNState[] Delete)
        {
            if (Add == null)
            {
                Add = new PNState[0];
            }
            if (Delete == null)
            {
                Delete = new PNState[0];
            }

            PMsgPeerSubscribeEx pMsg = new PMsgPeerSubscribeEx(this, Add, Delete);
            PNMsg reply;
            live.server.Presence.TransactFD(this, pMsg, out reply);
            PPeerSubscribeExReplyMsgData pReplyData = (PPeerSubscribeExReplyMsgData)(reply.Data);
            if (HResult.Failed(pReplyData.hr))
            {
                throw new HResultException(pReplyData.hr, "PeerSubscribeEx failed User: " + UserId.ToString("x"));
            }

            // Update the hash with new peer info structures keeping existing 
            // peer info unless we don't have any peer info yet in which case
            // we can do the cheaper straight import
            if (null != Peers && Peers.Count > 0)
            {
                Hashtable NewPeers = new Hashtable(Add.Length + Peers.Count);
                Hashtable Removed = new Hashtable(Delete.Length);
                foreach (PNState user in Delete)
                {
                    if (Peers.Contains(user.UserId))
                    {
                        Removed.Add(user.UserId, Peers[user.UserId]);
                        Peers.Remove(user.UserId);
                    }
                }
                foreach (PNState user in Add)
                {
                    ulong userId = user.UserId;
                    if (!Peers.Contains(userId))
                    {
                        if (Removed.Contains(userId))
                        {
                            NewPeers[userId] = Removed[userId];
                        }
                        else
                        {
                            NewPeers[userId] = new PeerInfo(user);
                        }
                    }
                    else
                    {
                        NewPeers[userId] = Peers[userId];
                    }
                }
                foreach (PeerInfo peer in Peers.Values)
                {
                    if (!NewPeers.Contains(peer.User.UserId))
                    {
                        NewPeers[peer.User.UserId] = peer;
                    }
                }
                Peers = NewPeers;
            }
            else
            {
                if (null == Peers)
                {
                    Peers = new Hashtable(Add.Length);
                }

                foreach (PNState user in Add)
                {
                    Peers[user.UserId] = new PeerInfo(user);
                }
            }

            return;
        }

		/// <summary>
		/// Tear down any existing peer subscriptions on server.
		/// </summary>
		public void PeerUnsubscribe()
		{
			PMsgPeerUnsubscribe request = new PMsgPeerUnsubscribe(this);
			PNMsg reply;
            live.server.Presence.TransactFD(this, request, out reply);
			PPeerUnsubscribeReplyMsgData replyData = (PPeerUnsubscribeReplyMsgData)reply.Data;
			if(HResult.Failed(replyData.HR))
			{
				throw new HResultException(replyData.HR, "PeerUnsubscribe failed User: " + UserId.ToString("x"));
			}

			// Clear the peer lookup table
			Peers = null;
		}

		/// <summary>
		/// Test peer subscription state.
		/// </summary>
		public bool IsPeerSubscribed(PNState topeer)
		{
			return IsPeerSubscribed(topeer.UserId);         
		}

		/// <summary>
		/// Test peer subscription state.
		/// </summary>
		public bool IsPeerSubscribed(ulong toPuid)
		{
			if(null == Peers)
			{
				return false;
			}
			return Peers.Contains(toPuid);
		}

		/// <summary>
		/// Lookup a peer info tracking struct.
		/// </summary>
		public PeerInfo GetPeerInfo(ulong userId)
		{
			if(Peers != null)
			{
				return Peers[userId] as PeerInfo;
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Tell WaitForInviteBlip that you are waiting for an additional
		/// invite. (Stores current invite sequence number)
		/// </summary>
		public void ExpectInviteBlip()
		{
			LastInviteBlipCount = LastQValPacket.InviteSequenceNum;
		}

		/// <summary>
		/// Wait for the invite count to go above the last stored invite 
		/// blip count (see ExpectInviteBlip()).
		/// </summary>
		public void WaitForInviteBlip()
		{
			DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );

			while( true )
			{
				uint blipCount = LastQValPacket.InviteSequenceNum;
				if( blipCount > LastInviteBlipCount )
                {
					return;
                }

				if( DateTime.Now > abortTime )
                {
					throw new TimeoutException( "User[" + UserId.ToString("x") + "] Timed out waiting for Invite blip" );
                }

			}
		}

		/// <summary>
		/// Send game session invitation to one or more users
		/// </summary>
		/// <param name="invited">Users to invite</param>
		public void Invite( PNState[] invited, ulong sessionId )
		{
			EnterSession(sessionId, false);

			// Send the invite. Sending as PMSG_INVITE_2, since PMSG_INVITE has been deprecated
			MsgDetails msgDetails = MsgDetails.CreateBlank();
			msgDetails.AddProperty(MsgDefs.XONLINE_MSG_PROP_SESSION_ID, MatchSessionId);

			// Send the invite
			PMsgInvite2 inviteMsg = new PMsgInvite2( this, invited, 0, 0, msgDetails );
			live.server.Presence.TransactFD(this, inviteMsg);

			// Populate the outgoing invite
			if(null == Invites)
			{
				Invites = new Hashtable();
			}

			InvitationInfo invite = new InvitationInfo(this, sessionId);
			invite.Owns     = true;
			invite.Invited  = invited;
			Invites[UserId] = invite;
		}

		/// <summary>
		/// Send game session invitation to one or more users with extra 
		/// messaging parameters and/or competition/team data.
		/// </summary>
		/// <param name="invited">Users to invite</param>
		public void Invite2( PNState[] invited, ulong sessionId, ulong senderContext, uint msgFlags, MsgDetails msgDetails )
		{
			EnterSession(sessionId, false);

			// Send the invite
			PMsgInvite2 inviteMsg = new PMsgInvite2( this, invited, senderContext, msgFlags, msgDetails );
            live.server.Presence.TransactFD(this, inviteMsg);

			// Populate the outgoing invite
			if(null == Invites)
			{
				Invites = new Hashtable();
			}

			InvitationInfo invite = new InvitationInfo(this, sessionId);
			invite.Owns     = true;
			invite.Invited  = invited;
			invite.Context  = senderContext;
			Invites[UserId] = invite;
		}

		/// <summary>
		/// Send acceptance of invitation to game session
		/// </summary>
		/// <param name="host">User that sent the invitations</param>
		public void AcceptInvite( PNState host )
		{
			QValPacket qval = null;
			InvitationInfo invite = GetInvitationInfo(host.UserId);

			if(null == invite)
			{
				// Try to dequeue invitation if the users are friends
				// or retrieve the message if they are not.
				if(null != GetBuddyInfo(host.UserId))
				{
					// Try to get the invitation info if it doesn't exist. This will throw if 
					// an invite is not available in NotificationWait seconds.
					qval = WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
					HandleQValPacket(qval);
	
					invite = GetInvitationInfo(host.UserId);
				}
				
				// Users should always receive an invite message
				qval = WaitForNewMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE);
				HandleQValPacket(qval, HQV_ReadMessages);

				invite = GetInvitationInfo(host.UserId);
			}

			// Send the answer
			PMsgInviteAnswer answerMsg = new PMsgInviteAnswer( this, host, true );
            live.server.Presence.TransactFD(this, answerMsg);

			// Change our virtual match session ID, notify presence of the change
			EnterSession(invite.MatchSession, false);
		
			// Cleanup our internal state 
			if(null != Invites)
			{
				Invites.Remove(host.UserId);
			}

			// Remove the host invite if he is a buddy
			BuddyInfo buddy = GetBuddyInfo(host.UserId);
			if(null != buddy)
			{
				buddy.Invitation = null;
			}

			// Remove the host invite if he is a peer
			PeerInfo peer = GetPeerInfo(host.UserId);
			if(null != peer)
			{
				peer.Invitation = null;
			}

			// Remove any invite messages
			RemoveMessageInfo(invite.MessageId);
		}

		/// <summary>
		/// Lookup an invite tracking struct by host user ID
		/// </summary>
		public InvitationInfo GetInvitationInfo(ulong userId)
		{
			if(Invites != null)
			{
				return Invites[userId] as InvitationInfo;
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Lookup an invite tracking struct by that is being hosted
		/// by this user. There can be only one.
		/// </summary>
		public InvitationInfo GetPendingOwnedInvite()
		{
			IDictionaryEnumerator enumerator = InviteEnumerator;
			while(enumerator.MoveNext())
			{
				InvitationInfo info = enumerator.Value as InvitationInfo;
				if(info.Owns)
				{
					return info;
				}
			}

			// Could not find owned outgoing invite
			return null;
		}

        /// <summary>
        /// Check to see if an invite is pending from a buddy.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvitedFromBuddy(PNState host)
        {
            BuddyInfo buddy = GetBuddyInfo(host.UserId);
            return (buddy != null) && (buddy.Invitation != null);
        }

        /// <summary>
        /// Check to see if an invite is pending from a peer.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvitedFromPeer(PNState host)
        {
            PeerInfo peer = GetPeerInfo(host.UserId);
            return (peer != null) && (peer.Invitation != null);
        }

        /// <summary>
        /// Check to see if an invite is pending from anyone at all.
        /// </summary>
        /// <param name="host">User that might have sent the invitation</param>/
        public bool IsInvited(PNState host)
        {
            return IsInvitedFromBuddy(host) || IsInvitedFromPeer(host);
        }

		/// <summary>
		/// Look for unanswereqd pending invite
		/// </summary>
		public bool HasUnAnsweredInvite()
		{
			IDictionaryEnumerator enumerator = InviteEnumerator;
			while(enumerator.MoveNext())
			{
				InvitationInfo info = enumerator.Value as InvitationInfo;
				if(info.Owns)
				{
					return true;
				}
			}
			return false;
		}

        /// <summary>
        /// Send rejection of invitation to game session
        /// </summary>
        /// <param name="host">User that sent the invitations</param>
        public void RejectInvite( PNState host )
        {
            RejectInvite( host, false );
        }

        /// <summary>
        /// Reject a pending invite.
        /// </summary>
        /// <param name="host">User that sent the invitations</param>
        /// <param name="never">Add host to user's never list</param>
        public void RejectInvite( PNState host, bool never )
		{
			ushort reply = (never ? XonPresNoti.PINVITE_REPLY_NEVER : XonPresNoti.PINVITE_REPLY_NO);
			PMsgInviteAnswer answerlMsg = new PMsgInviteAnswer( this, host, reply );
            live.server.Presence.TransactFD(this, answerlMsg);

			BuddyInfo buddy = GetBuddyInfo(host.UserId);
			if(null != buddy)
			{
				buddy.Invitation = null;
			}

            PeerInfo peer = GetPeerInfo(host.UserId);
            if(null != peer)
            {
            	peer.Invitation = null;
            }

            if(null != Invites)
            {
                Invites.Remove(host.UserId);
            }
        }

        /// <summary>
        /// Send revocation of game session invitation to one or more users
        /// </summary>
        /// <param name="invited">Users no longer invited</param>
        public void CancelInvite( PNState[] invited )
        {
            PMsgCancelInvite cancelMsg = new PMsgCancelInvite( this, invited );
            live.server.Presence.TransactFD(this, cancelMsg);

			LeaveSession();

            if(null != Invites)
            {
                Invites.Remove(this.UserId);
            }
        }

		/// <summary>
		/// If we are not already in a session this will cause this user
		/// to appear to enter a session.
		/// </summary>
		public void EnterSession(ulong sessionId, bool joinable)
		{
			if(sessionId != MatchSessionId)
			{
                uint state = State;
                state |= XonPresNoti.P_STATE_MASK_PLAYING;

				if(joinable)
				{
					state |= XonPresNoti.P_STATE_MASK_JOINABLE;
				}

				SetTitleData(state, sessionId, TitleStuff);
			}
		}

		/// <summary>
		/// Make it appear to presence and reporting that we have left any session
		/// that we might have been a part of
		/// </summary>
		public void LeaveSession()
		{
			if(0 != MatchSessionId )
			{
                uint state = State;
				state &= ~(XonPresNoti.P_STATE_MASK_PLAYING|XonPresNoti.P_STATE_MASK_JOINABLE);
				SetTitleData(state, 0, TitleStuff);
			}
		}

		/// <summary>
		/// Lookup a stored message tracking struct by the message ID.
		/// </summary>
		public MessageInfo GetMessageInfo(uint msgId)
		{
			if(null != Messages)
			{
				return Messages[msgId] as MessageInfo;
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Lookup all stored message tracking structs by the sending user ID.
		/// </summary>
		public MessageInfo[] GetMessageInfoFrom(PNState sender)
		{
			return GetMessageInfoTypeFrom(sender, 0);
		}

		/// <summary>
		/// Lookup all stored message tracking structs by the sending user ID and message type.
		/// If the message type is 0 all messages from this user will be returned.
		/// </summary>
		public MessageInfo[] GetMessageInfoTypeFrom(PNState sender, byte msgType)
		{
			ArrayList messages = new ArrayList();
			IDictionaryEnumerator enumerator = MessageEnumerator;

			while(enumerator.MoveNext())
			{
				MessageInfo info = enumerator.Value as MessageInfo;
				if(info.Message != null && info.Message.SenderID == sender.UserId)
				{
					if(0 == msgType || msgType == info.Message.Type)
					{
						messages.Add(info);
					}
				}
			}

			return (MessageInfo[])messages.ToArray(typeof(MessageInfo));
		}

		/// <summary>
		/// Delete a message by it's ID. Also removes any tracking structs.
		/// </summary>
		public uint DeleteMessage(uint msgId)
		{
			uint hr = HResult.S_OK;
			PNMsg replyMsg;
			QMsgDeleteMsg deleteMsg = new QMsgDeleteMsg( this, msgId, 0 );
            live.server.Presence.TransactFD(this, deleteMsg, out replyMsg);

			QDeleteMsgReplyMsgData deleteReplyData = (QDeleteMsgReplyMsgData)(replyMsg.Data);
			hr = deleteReplyData.HR;

			if(HResult.Failed(hr))
			{
				System.Diagnostics.Debug.WriteLine(String.Format("DeleteMessage[{0:x}]: failed for MsgId: {1:x}, HR: 0x{2:x8}",
						UserId,
						msgId,
						hr));
			}
			else
			{
				RemoveMessageInfo(msgId);
			}

			return hr;
		}

		/// <summary>
		/// Remove messages that have been revoked or deleted on the server (we have received
		/// a deleted message qval for this message ID)
		/// </summary>
		public void RemoveDeletedMessages()
		{
			IDictionaryEnumerator enumerator = MessageEnumerator;
			ArrayList toRemove = new ArrayList();
			while(enumerator.MoveNext())
			{
				MessageInfo info = enumerator.Value as MessageInfo;
				if(info.Deleted)
				{
					toRemove.Add(info);
				}
			}

			foreach(MessageInfo info in toRemove)
			{
				Messages.Remove(info.Id);
			}
		}

		/// <summary>
		/// For all tracking message structs delete the message on the server. Also
		/// removes tracking struct and returns the array of hresults returned from
		/// DeleteMessage().
		/// </summary>
		public uint[] DeleteAllMessages()
		{
			uint []hresults = null;
			if(null != Messages && Messages.Values.Count > 0)
			{
				hresults = new uint[Messages.Values.Count];
				uint i = 0;
				IDictionaryEnumerator enumerator = MessageEnumerator;

				while(enumerator.MoveNext())
				{
					MessageInfo info = enumerator.Value as MessageInfo;
					if(null != info)
					{
						hresults[i] = DeleteMessage(info.Id);
					}

					i++;
				}
			}

			return hresults;
		}

		/// <summary>
		/// Remove a message tracking struct.
		/// </summary>
		public void RemoveMessageInfo(uint msgId)
		{
			if(null != Messages && Messages.Contains(msgId))
			{
				Messages.Remove(msgId);
			}
		}

        /// <summary>
        /// Send addition to list of voice blocked users
        /// </summary>
        /// <param name="block">User to shut up</param>
        public void Mute( PNState block )
        {
            PMsgBlockVoice blockMsg = new PMsgBlockVoice( this, block );
            live.server.Presence.TransactFD(this, blockMsg);

            Blocks.Add( block.UserId );
            if( Blocks.Count > 250 )
            {
                Blocks.RemoveRange( 0, 25 );
            }

            BlockListVer++;
        }
        
        /// <summary>
        /// Send deletion from list of voice blocked users
        /// </summary>
        /// <param name="unblock">User to listen to again</param>
        public void UnMute( PNState unblock )
        {
            PMsgUnblockVoice unBlockMsg = new PMsgUnblockVoice( this, unblock );
            live.server.Presence.TransactFD(this, unBlockMsg);

            Blocks.Remove( unblock.UserId );

            BlockListVer++;
        }

        /// <summary>
        /// Sets the Console Type Bits in the Local State
        /// </summary>
        private void AddConsoleStateInfo(ref uint state)
        {
            state &= ~XonPresNoti.P_STATE_MASK_CONSOLE_TYPE;
            switch(this.Client.ClientType)
            {
                case ClientType.Xenon:
                    state |= XonPresNoti.P_STATE_ENUM_CONSOLE_XENON;
                    break;
                case ClientType.Panorama:
                    state |= XonPresNoti.P_STATE_ENUM_CONSOLE_WINPC;
                    break;
                case ClientType.XenonBackCompat:
                case ClientType.Xbox:
                    state |= XonPresNoti.P_STATE_ENUM_CONSOLE_XBOX;
                    break;
                default:
                    throw new ApplicationException("Invalid ClientType");
            }
        }

        /// <summary>
        /// Send current state flags, match session and Title data to server
        /// </summary>
        public void SetTitleData() 
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
			if(null != _GIBlob)
			{
            	SetTitleData( state, MatchSessionId, _GIBlob.GetBytes() ); 
			}
			else
			{
            	SetTitleData( state, MatchSessionId, TitleStuff ); 
			}
        }

        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title 
        /// data to server
        /// </summary>
        /// <param name="state">New state flags</param>
        public void SetTitleData( uint state ) 
        { 
			if(null != _GIBlob)
			{
            	SetTitleData( state, MatchSessionId, _GIBlob.GetBytes() ); 
			}
			else
			{
            	SetTitleData( state, MatchSessionId, TitleStuff ); 
			}
        }
        
        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title 
        /// data to server
        /// </summary>
        /// <param name="matchId">New match session ID</param>
        public void SetTitleData( ulong matchId ) 
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
            if (null != _GIBlob)
			{
            	SetTitleData( state, matchId, _GIBlob.GetBytes() ); 
			}
			else
			{
				SetTitleData( state, matchId, TitleStuff );
			}
        }
        
        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title 
        /// data to server
        /// </summary>
        /// <param name="titleStuff">New title data</param>
        public void SetTitleData( byte[] titleStuff ) 
        {
            uint state = State;
            AddConsoleStateInfo(ref state);
            SetTitleData(state, MatchSessionId, titleStuff); 
        }
        
        /// <summary>
        /// Store new value(s). Then send current state flags, match session and Title 
        /// data to server
        /// </summary>
        /// <param name="state">New state flags</param>
        /// <param name="matchId">New match session ID</param>
        /// <param name="titleStuff">New title data</param>
        public void SetTitleData( uint state, ulong matchSessionId, byte[] titleStuff )
        {
            State          = state;
            MatchSessionId = matchSessionId;
            TitleStuff     = titleStuff;
            
			if(Xbox != null && LoggedOn)
			{
                Xbox.SetUserState(User, matchSessionId, state, titleStuff);
			}
        }

        /// <summary>
        /// Get web friends direct from FD (not webcache)
        /// </summary>
        public PWebFriendReplyMsgData GetWebFriends()
        {
            PNMsg replyMsg;
            PMsgWebFriends webFriendMsg = new PMsgWebFriends( this );
            live.server.Presence.TransactFD(this, webFriendMsg, out replyMsg);

            PWebFriendReplyMsgData replyData = (PWebFriendReplyMsgData) replyMsg.Data;

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Get Web Friends HR = 0x"+replyData.HR.ToString( "X8" ) );
            
            return replyData;
        }

        /// <summary>
        /// Get friends direct from FD (not webcache)
        /// </summary>
        public PGetFriendsListReplyMsgData GetFriendsList(PNState target)
        {
            PMsgGetFriendsList pMsg = new PMsgGetFriendsList(this, target);
            PNMsg reply;
            live.server.Presence.TransactFD(this, pMsg, out reply);
            PGetFriendsListReplyMsgData replyData = (PGetFriendsListReplyMsgData)(reply.Data);

            if (replyData.HR != HResult.S_OK)
                throw new HResultException(replyData.HR, "Get Friends List HR = 0x" + replyData.HR.ToString("X8"));

            return replyData;
        }

		/// <summary>
		/// Use datacenter port to query presence info for a target.
		/// </summary>
		public PresenceInfo GetPresenceInfo(PNState target)
		{
			PMsgGetPresenceInfo req = new PMsgGetPresenceInfo(this, target);
			PNMsg rep;

            live.server.Presence.TransactFD(this, req, out rep);

			PPresenceInfoReplyMsgData repData = (PPresenceInfoReplyMsgData)rep.Data;
			if(null != repData && null != repData.rgUsers && repData.cdwUsers > 0)
			{
				return repData.rgUsers[0];
			}
			else
			{
				return null;
			}
		}

        ///// <summary>
        ///// Get host sesion data, including windosk endpoint
        ///// </summary>
        ///// <param name="host">User being asked about</param>
        ///// <param name="sessInfo">Session data retrieved</param></param>
        //public void GetPeerSession( PNState host, out XSessionInfo sessInfo )
        //{
        //    PNMsg replyMsg;
        //    PMsgPeerSession peerSessionMsg = new PMsgPeerSession( this, host );
        //    live.server.Presence.TransactFD(this, peerSessionMsg, out replyMsg);

        //    PPeerSessionReplyMsgData psReplyMsg = (PPeerSessionReplyMsgData) replyMsg.Data;
            
        //    if( psReplyMsg.HostUserID != host.UserId )
        //    {
        //        throw new Exception( "got peer session info reply for wrong host" );
        //    }

        //    sessInfo = new XSessionInfo();
        //    sessInfo.TitleId     = psReplyMsg.TitleID;
        //    sessInfo.TitleVer    = psReplyMsg.TitleVersion;
        //    sessInfo.TitleRegion = psReplyMsg.TitleRegion;
        //    sessInfo.XnAddr      = psReplyMsg.XnAddr;
        //    sessInfo.XnKId       = psReplyMsg.XnKId;
        //    sessInfo.XnKey       = psReplyMsg.XnKey;
        //}

        /// <summary>
        /// Checks for outgoing buddy request
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>A request has been sent to buddy</returns>
        public bool BuddyStatusPending( PNState buddy )
        { 
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_PENDING ); 
        }
        
        /// <summary>
        /// Checks for incoming buddy request
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>A request has come from buddy</returns>
        public bool BuddyStatusRequested( PNState buddy ) 
        { 
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_REQUEST ); 
        }

        /// <summary>
        /// Checks for established buddy relationship
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>User is a fully accepted buddy</returns>
        public bool BuddyStatusOK( PNState buddy ) 
        { 
            return BuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_OK ); 
        }

        /// <summary>
        /// Checks for specified buddy stats
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <param name="status">Status being checked for</param>
        /// <returns>Is a user a buddy with the given status</returns>
        public bool BuddyStatus( PNState buddy, byte status )
        {
            BuddyInfo info = GetBuddyInfo(buddy.UserId);
            return (info != null) && (info.Status == status);
        }

        /// <summary>
        /// Checks for existence of buddy list entry (regardless of Status)
        /// </summary>
        /// <param name="buddy">User being checked</param>
        /// <returns>User is in buddy list</returns>
        public bool IsBuddy( PNState buddy )
        {
            BuddyInfo info = GetBuddyInfo(buddy.UserId);
            return (info != null) && (info.Status != XonPresNoti.NOT_A_BUDDY);
        }

        static public void MutualWaitForDelete(PNState sender, PNState receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.NOT_A_BUDDY );
        }

        static public void MutualWaitForSentRequest(PNState sender, PNState receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_PENDING );
        }

        static public void MutualWaitForRecvRequest(PNState sender, PNState receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_REQUEST );
        }

        static public void MutualWaitForFullFriend(PNState sender, PNState receiver)
        {
            MutualWaitForStatus( sender, receiver, XonPresNoti.P_BUDDY_STATUS_OK );
        }

        /// <summary>
        /// Wait for a buddy request to a user to be confirmed
        /// </summary>
        /// <param name="buddy">User request was sent to</param>
        public void WaitForBuddyStatusPending( PNState buddy ) 
        { 
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_PENDING ); 
        }

        /// <summary>
        /// Wait for a buddy request from a user to come in 
        /// </summary>
        /// <param name="buddy">User that made request</param>
        public void WaitForBuddyStatusRequested( PNState buddy ) 
        { 
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_REQUEST ); 
        }
        
        /// <summary>
        /// Wait for an accepted buddy request to be confirmed
        /// </summary>
        /// <param name="buddy">User that either made or accepted the request</param>
        public void WaitForBuddyStatusOK( PNState buddy ) 
        { 
            WaitForBuddyStatus( buddy, XonPresNoti.P_BUDDY_STATUS_OK ); 
        }
        
        /// <summary>
        /// Wait for a buddy deletion to be confirmed. 
        /// </summary>
        /// <param name="buddy">User that is to be removed</param>
        public void WaitForBuddyStatusDeleted( PNState buddy ) 
        { 
            WaitForBuddyStatus( buddy, XonPresNoti.NOT_A_BUDDY ); 
        }

        /// <summary>
        /// Waits and watches Qflags and gets list change and buddy request notifications 
        /// (if flags indicate the need to) in order to try for specified buddy stats.
        /// </summary>
        /// <param name="buddy">User waiting on</param>
        /// <param name="status">Satus being watied for</param>
        static public void MutualWaitForStatus( PNState sender, PNState receiver, byte status )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( DefaultNotificationWait );

            while( true )
            {
                
				sender.ProcessQVals();
				receiver.ProcessQVals();
                
                BuddyInfo sendbi = sender.GetBuddyInfo(receiver.UserId);
                BuddyInfo recvbi = receiver.GetBuddyInfo(sender.UserId);

                if( status == XonPresNoti.NOT_A_BUDDY )
                {
                    // Check if buddy is absent or irelevant
                    if( ((sendbi == null) || (sendbi.Status == XonPresNoti.NOT_A_BUDDY)) &&
                        ((recvbi == null) || (recvbi.Status == XonPresNoti.NOT_A_BUDDY)))
                    {
                        break;
                    }
                }
                else if( status == XonPresNoti.P_BUDDY_STATUS_OK )
                {
                    if( (sendbi != null && sendbi.Status == status &&
                          recvbi != null && recvbi.Status == status))
                    {
                        break;
                    }
                }
                else
                {
                    // Check if buddy is present and relevant
                    if( (sendbi != null && sendbi.Status == status &&
                         recvbi != null && recvbi.Status == 3 - status) )
                    {
                        break;
                    }
                }

				if( DateTime.Now > abortTime )
                {
					string message = String.Format("MutualWaitforBuddyStatus(): Sender: {0:x} and Receiver: {1:x} timed out {2} seconds waiting for buddy status: {3}",
							sender.UserId,
							receiver.UserId,
							DefaultNotificationWait,
							XonPresNoti.BuddyStatusToString(status));
                    throw new TimeoutException( message); 
                }

            
                Thread.Sleep( QValPollingInterval );
			}
        }

        /// <summary>
        /// Waits and watches Qflags and gets list change and buddy request notifications 
        /// (if flags indicate the need to) in order to try for specified buddy stats.
        /// </summary>
        /// <param name="buddy">User waiting on</param>
        /// <param name="status">Satus being watied for</param>
        public void WaitForBuddyStatus( PNState buddy, byte status )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );

            while( true )
            {
				ProcessQVals();

                BuddyInfo bi = GetBuddyInfo(buddy.UserId);
                if( status == XonPresNoti.NOT_A_BUDDY )
                {
                    // Check if buddy is absent or irelevant
                    if( (bi == null) || (bi.Status == XonPresNoti.NOT_A_BUDDY) )
                    {
                        break;
                    }
                }
                else
                {
                    // Check if buddy is present and relevant
                    if( (bi != null) && (bi.Status == status) )
                    {
                        break;
                    }
                }
            
                if( DateTime.Now > abortTime )
                {
					string message = String.Format("WaitForBuddyStatus(): User: {0:x} timed out {1} seconds waiting for buddy status: {2} on user {3:x}",
							UserId,
							NotificationWait,
							XonPresNoti.BuddyStatusToString(status),
							buddy.UserId);
                    throw new TimeoutException( message); 
                }
                
                Thread.Sleep( QValPollingInterval );
            }
        }

        public enum PresenceFields
        {
            SessionID = 0x1,
            NickName = 0x2,
            State = 0x4,
            TitleID = 0x8,
            TitleData = 0x10,
            All = 0x1F
        }
        /// <summary>
        /// Waits and watches Qflags and gets presence notifications 
        /// 
        /// </summary>
        /// <param name="buddy">User waiting on</param>
        /// <param name="field">The field(s) to wait for in pi</param>
        /// <param name="pi">A PresenceItem containing the fields to wait for equality on</param>
        public void WaitForBuddyPresence( PNState buddy,  PresenceFields field, PresenceItem pi )
        {
            DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );

            int toMatch = ((field & PresenceFields.SessionID) == PresenceFields.SessionID ? 1 : 0) + 
                ((field & PresenceFields.NickName) == PresenceFields.NickName ? 1 : 0) + 
                ((field & PresenceFields.State) == PresenceFields.State ? 1 : 0) + 
                ((field & PresenceFields.TitleID) == PresenceFields.TitleID ? 1 : 0) + 
                ((field & PresenceFields.TitleData) == PresenceFields.TitleData ? 1 : 0);
            while( true )
            {
				if( DateTime.Now > abortTime )
                {
                    throw new TimeoutException("User[" + UserId.ToString("x") + "] Timed out waiting for buddy status confirmation: " + field.ToString());
                }

				ProcessQVals();

                int Matched = 0;
                BuddyInfo bi = GetBuddyInfo(buddy.UserId);
                if(bi != null)
                {
                    // Check to see if the state already matches
                    if((field & PresenceFields.NickName) == PresenceFields.NickName &&
                        bi.Presence != null && bi.Presence.Nickname.Length == pi.Nickname.Length &&
                        ArrayEx.SubArrayCompare(bi.Presence.Nickname, 0, pi.Nickname, 0, pi.Nickname.Length))
					{
                        Matched++;
					}
                    if((field & PresenceFields.SessionID) == PresenceFields.SessionID &&
                        bi.Presence != null && bi.Presence.MatchSessionID == pi.MatchSessionID)
					{
                        Matched++;
					}
                    if((field & PresenceFields.State) == PresenceFields.State &&
                        bi.Presence != null && bi.Presence.State == pi.State)
					{
                        Matched++;
					}
                    if((field & PresenceFields.TitleID) == PresenceFields.TitleID &&
                        bi.Presence != null && bi.Presence.TitleID == pi.TitleID)
					{
                        Matched++;
					}
                    if((field & PresenceFields.TitleData) == PresenceFields.TitleData &&
                        bi.Presence != null && bi.Presence.TitleStuff.Length == pi.TitleStuff.Length &&
                        ArrayEx.SubArrayCompare(bi.Presence.TitleStuff, 0, pi.TitleStuff, 0, pi.TitleStuff.Length))
					{
                        Matched++;
					}
                    if(toMatch == Matched)
					{
                        break;
					}
                }
                
                Thread.Sleep( QValPollingInterval );
            }
        }

        /// <summary>
        /// Gets and processes List Change notification queue items
        /// </summary>
        public void GetListChangeNotifications()   
        { 
            GetNotifications( XonPresNoti.PQUEUE_LIST_CHANGE ); 
        }

        /// <summary>
        /// Gets and processes Buddy Request notification queue items
        /// </summary>
        public void GetBuddyRequestNotifications() 
        { 
            GetNotifications( XonPresNoti.PQUEUE_BUDDY_REQ ); 
        }

        /// <summary>
        /// Gets and processes Invite notification queue items
        /// </summary>
        public void GetInviteNotifications()       
        { 
            GetNotifications( XonPresNoti.PQUEUE_INVITE ); 
        }

        /// <summary>
        /// Gets and processes Invite Answer notification queue items
        /// </summary>
        public void GetInviteAnswerNotifications() 
        { 
            GetNotifications( XonPresNoti.PQUEUE_INVITE_ANSWER ); 
        }

        /// <summary>
        /// Gets and processes Presence notification queue items
        /// </summary>
        public void GetPresenceNotifications()     
        { 
            GetNotifications( XonPresNoti.PQUEUE_PRESENCE ); 
        }

        /// <summary>
        /// Gets and processes Peer Presence notification queue items
        /// </summary>
        public void GetPeerPresenceNotifications()     
        { 
            GetNotifications( XonPresNoti.PQUEUE_PEER_PRESENCE ); 
        }

        /// <summary>
        /// Gets and processes Presence notification queue items
        /// </summary>
        public void GetPresence2Notifications()     
        { 
            GetNotifications( XonPresNoti.PQUEUE_PRESENCE_2 ); 
        }
        
        /// <summary>
        /// Dequeues a raw list of notifications
        /// </summary>
        /// <param name="qType">Queue to dequeue from</param>
        /// <returns>List of qType specific list items</returns>
        public ListItem[] GetRawNotifications( ushort qType )
        {
            QDequeueReplyMsgData reply = DequeueNotifications(qType);
            return reply.Items;
        }

        /// <summary>
        /// Provide granular control over the dequeue message
        /// </summary>
        /// <param name="qType">Queue to dequeue from</param>
        /// <returns>Dequeue reply data</returns>/ 
        public QDequeueReplyMsgData DequeueNotifications(ushort qType)
        {
            return DequeueNotifications(qType, 0, 100, UInt16.MaxValue);
        }

        /// <summary>
        /// Provide granular control over the dequeue message
        /// </summary>
        /// <param name="qType">Queue to dequeue from</param>
        /// <param name="startItemID">Item in queue to start with</param>
        /// <param name="maxItems">Max items to return</param>
        /// <param name="maxTotalItemsDataSize">Max total payload data size to return in bytes</param>
        /// <returns>Dequeue reply data</returns>/ 
        public QDequeueReplyMsgData DequeueNotifications(ushort qType, uint startItemID, ushort maxItems, uint maxTotalItemDataSize)
        {
			uint left = 100;
			QDequeueReplyMsgData reply = null;

			// Spool the dequeue requests
			while(0 != left)
			{
            	QMsgDequeue dequeueMsg = new QMsgDequeue( this, qType, startItemID, maxItems, maxTotalItemDataSize );
            	PNMsg replyMsg;
                live.server.Presence.TransactFD(this, dequeueMsg, out replyMsg);

            	reply = (QDequeueReplyMsgData)replyMsg.Data;

            	if( HResult.Failed( reply.Hdr.HR ) )
            	{ 
                	System.Diagnostics.Debug.WriteLine(String.Format("DequeueNotifications[{0:x}]: failed with HR: 0x{1:x8}", 
							UserId,
							reply.Hdr.HR));

					break;
            	}

                EnqueueQVals(false, reply.Hdr.QVals);
	
				//System.Diagnostics.Debug.WriteLine("DequeueNotifications: QVals updated from dequeue: Sequence: {0}, Flags: 0x{1:x8} ({2})",
						//_LastQValPacket.QValSequenceNum, 
						//_LastQValPacket.QFlags, 
						//XonPresNoti.BuildQFlagsString(_LastQValPacket.QFlags));
	
				// Distill the raw notification items
            	ProcessDequeue(qType, reply.Items);
			
				// Figure out how many items we have left to dequeue
            	left = reply.Hdr.QLeft;
			}
            
            return reply;
        }

        /// <summary>
        /// Gets and processes notification queue items
        /// </summary>
        /// <param name="qType">ID of Queue to get items from</param>
        public void GetNotifications( ushort qType )
        {
			// Dequeue all of the notifications (this will send them 
			// through an internal process that changes state based
			// on the ListIems
			DequeueNotifications( qType );
        }

        /// <summary>
        /// Returns the presence server's idea of what the team ticket is for the current title.
        /// Note this will depend on what the Fake SG tells it the key data is.
        /// </summary>
        /// <returns>Team ticket from server</returns>
        public TeamTicket GetTeamTicket()
        {
            return GetTeamTicket( Xbox.TitleId );
        }

        /// <summary>
        /// Returns the presence server's idea of what the team ticket is for specified title.
        /// Note this will depend on what the Fake SG tells it the key data is.
        /// </summary>
        /// <returns>Team ticket from server</returns>
        public TeamTicket GetTeamTicket( uint titleId )
        {
            PMsgGetTeamTicket getTicketMsg = new PMsgGetTeamTicket( this, titleId );
            PNMsg replyMsg;
            live.server.Presence.TransactFD(this, getTicketMsg, out replyMsg);

            PGetTeamTicketReplyMsgData replyData = (PGetTeamTicketReplyMsgData)(replyMsg.Data);

            if( replyData.HR != HResult.S_OK )
                throw new HResultException( replyData.HR, "Get Team Ticket HR = 0x"+Hexer.tohex( replyData.HR ));

            return replyData.Ticket;
        }

        /// <summary>
        /// Get a list of all the teams the user is in for their current title,
        /// </summary>
        /// <returns>New ArrayList populated with Team objects</returns>
        public Team[] GetTeamList()
        {
            return GetTeamList( Xbox.TitleId );
        }
        
        /// <summary>
        /// Get a list of all the teams the user is in for specified title,
        /// Note this title must be valid in users SPIData
        /// </summary>
        /// <param name="titleId">Title teams were created in</param>
        /// <returns>Array of Team objects</returns>
        public Team[] GetTeamList( uint titleId )
        {
            // populate the team list with team objects
            ArrayList teams = new ArrayList();
            try 
            {
                TeamTicket ticket = GetTeamTicket( titleId );
                
                // list out the teams in the ticket using the list teams msg
                PMsgListTeams listTeamsMsg = new PMsgListTeams( this, titleId, ticket.teamIDs );
                PNMsg replyMsg;
                live.server.Presence.TransactFD(this, listTeamsMsg, out replyMsg);

                // cast the response data
                PListTeamsReplyMsgData replyData = (PListTeamsReplyMsgData)(replyMsg.Data);

                if(replyData.HR != HResult.S_OK)
                    throw new HResultException(replyData.HR, "Get Team List HR = 0x"+replyData.HR.ToString("X8") );
        
                teams.Capacity = (int)replyData.TeamsLen;
                
                for(int i = 0; i < replyData.TeamsLen; ++i)
                {
                    TeamInfo teamInfo = replyData.Teams[i];

                    // construct a new team object with the loaded team info
                    Team team = new Team( this, titleId, teamInfo );
                    
                    teams.Add( team );
                }
            }
            catch(HResultException ex) 
            {
                if(ex.HR != HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND) 
                    throw;
            }
            return (Team[]) teams.ToArray( typeof( Team ) );
        }

        /// <summary>
        /// Get a list of all the teams the user is in for specified title
        /// Note this title must be valid in users SPIData
        /// </summary>
        /// <param name="titleId">Title teams were created in</param>
        /// <returns>Array of Team objects</returns>
        public Team[] GetImplicitTeamList( uint titleId )
        {
            // populate the team list with team objects
            ArrayList teams = new ArrayList();
            try 
            {
                // list out the teams in the ticket using the list teams msg
                PMsgListTeams listTeamsMsg = new PMsgListTeams( this, titleId, null );
                PNMsg replyMsg;
                live.server.Presence.TransactFD(this, listTeamsMsg, out replyMsg);

                // cast the response data
                PListTeamsReplyMsgData replyData = (PListTeamsReplyMsgData)(replyMsg.Data);

                if(replyData.HR != HResult.S_OK)
                    throw new HResultException(replyData.HR, "Get Team List HR = 0x"+replyData.HR.ToString("X8") );
        
                teams.Capacity = (int)replyData.TeamsLen;
                
                for(int i = 0; i < replyData.TeamsLen; ++i)
                {
                    TeamInfo teamInfo = replyData.Teams[i];

                    // construct a new team object with the loaded team info
                    Team team = new Team( this, titleId, teamInfo );
                    
                    teams.Add( team );
                }
            }
            catch(HResultException ex) 
            {
                if(ex.HR != HResult.XONLINE_E_TEAMS_TEAM_NOT_FOUND) 
                    throw;
            }
            return (Team[]) teams.ToArray( typeof( Team ) );
        }

        /// <summary>
		/// Wait for next message (any).
		/// </summary>
		public QValPacket WaitForNewMessage()
		{
			return WaitForNewMessage(0xffffffff);
		}

		/// <summary>
		/// Wait for a specific type of message to be delivered to the user.
		/// </summary>
		public QValPacket WaitForNewMessageType(byte messageType)
		{
			return WaitForNewMessage((uint)(messageType << 24));
		}

		/// <summary>
		/// Wait for a message matching data flags to appear in the 0th slot of the
		/// messaging qvals. Passing zero will return the first non-zero qval. 
		/// </summary>
		public QValPacket WaitForNewMessage(uint dataFlags)
		{
			DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );
			QValPacket retPacket = null;

			System.Diagnostics.Debug.WriteLine(String.Format("WaitForNewMessage[{0:x}]: Waiting on new data: 0x{1:x8} ({2})", 
					UserId,
					dataFlags,
					XonPresNoti.BuildMsgNotificationFlagsString(dataFlags)));

            while(true)
            {
                if( DateTime.Now > abortTime )
                {
                    throw new TimeoutException( "User[" + UserId.ToString("x") + "] Timed out waiting for new message qval, dataFlags: " + dataFlags.ToString("x8") );
                }

				// Get all delivered qvals for this timeslice
                while (DequeueQVals(out retPacket))
				{
					for(uint i = 0; i < 3; ++i)
					{
						if((0 != retPacket.NewMessageId(i)) && (0 != (dataFlags & retPacket.NewMessageData(i))))
						{
							// got match 
							goto lbFinished;
						}
					}

					// Unmatched packets should still be processed, just warn when
					// we have some actual flags that will be acted on but were not 
					// caught by the flags filter
					if(retPacket.QFlags != 0)
					{
						System.Diagnostics.Debug.WriteLine(String.Format("WaitForNewMessage[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3}) Ids({4}, {5}, {6}), Data({7:x8}, {8:x8}, {9:x8})", 
							UserId,
							retPacket.QValSequenceNum, 
							retPacket.QFlags, 
							XonPresNoti.BuildQFlagsString(retPacket.QFlags),
							retPacket.NewMessageId(0),
							retPacket.NewMessageId(1),
							retPacket.NewMessageId(2),
							retPacket.NewMessageData(0),
							retPacket.NewMessageData(1),
							retPacket.NewMessageData(2)));
					}

					HandleQValPacket(retPacket);
				}

                Thread.Sleep( QValPollingInterval );
            }
lbFinished:

			return retPacket;
		}

		/// <summary>
		/// Wait for a non-zero message ID on the deleted message qval payload
		/// </summary>
        public QValPacket WaitForDeletedMessage()
        {
            return WaitForDeletedMessage(0xffffffff);
        }

		/// <summary>
		/// Wait for a specific message ID on the deleted message qval payload
		/// </summary>
		public QValPacket WaitForDeletedMessage(uint msgId)
		{
			DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );
			QValPacket retPacket = null;

			System.Diagnostics.Debug.WriteLine(String.Format("WaitForDeletedMessage[{0:x}]: Waiting on deleted message", UserId));

            while(true)
            {
                if( DateTime.Now > abortTime )
                {
                    throw new TimeoutException( "User[" + UserId.ToString("x") + "] Timed out waiting for new message qval" );
                }

				// Get all delivered qvals for this timeslice
                while (DequeueQVals(out retPacket))
				{
                    // Match any message first, specific message after
					if(msgId == 0xffffffff && retPacket.DeletedMessageId(0) != 0)
					{
						goto lbFinished;
					}
					else if(retPacket.DeletedMessageId(0) == msgId)
					{
                        goto lbFinished;
                    }
                    else
                    {
						// Unmatched packets should still be processed, just warn when
						// we have some actual flags that will be acted on but were not 
						// caught by the flags filter
						if(retPacket.QFlags != 0)
						{
							System.Diagnostics.Debug.WriteLine(String.Format("WaitForDeletedMessage[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3})", 
								UserId,
								retPacket.QValSequenceNum, 
								retPacket.QFlags, 
								XonPresNoti.BuildQFlagsString(retPacket.QFlags)));
						}

						HandleQValPacket(retPacket);
					}
				}

                Thread.Sleep( QValPollingInterval );
            }
lbFinished:

			return retPacket;
		}
		/// <summary>
		/// Wait for a single qval flag, note that this method can be bad for internal state since
		/// it doesn't ensure that the items are dequeued or that the qvals are updated correctly.
		/// Also any flags that come in before the one specified will not be correctly handled.
		/// </summary>
		public QValPacket WaitForQFlags(uint qFlagsMask)
		{
			DateTime abortTime = DateTime.Now.AddSeconds( NotificationWait );
			QValPacket retPacket = null;

			System.Diagnostics.Debug.WriteLine(String.Format("WaitForQFlags[{0:x}]: Waiting on qflags {1:x} ({2})",
					UserId,
					qFlagsMask,
					XonPresNoti.BuildQFlagsString(qFlagsMask)));

            while(true)
            {
                if( DateTime.Now > abortTime )
                {
                    throw new TimeoutException( "User[" + UserId.ToString("x") + "] Timed out waiting for QFlags: "+qFlagsMask.ToString( "X8" ) );
                }

				// Get all delivered qvals for this timeslice
                while (DequeueQVals(out retPacket))
				{
					if((retPacket.QFlags & qFlagsMask) == qFlagsMask)
					{
						// got match 
						goto lbFinished;
					}
					else
					{
						// Unmatched packets should still be processed, just warn when
						// we have some actual flags that will be acted on but were not 
						// caught by the flags filter
						if(retPacket.QFlags != 0)
						{
							System.Diagnostics.Debug.WriteLine(String.Format("WaitForQFlags[{0:x}]: Unmatched QValPacket: Sequence: {1}, Flags: 0x{2:x8} ({3})", 
								UserId,
								retPacket.QValSequenceNum, 
								retPacket.QFlags, 
								XonPresNoti.BuildQFlagsString(retPacket.QFlags)));
						}

						HandleQValPacket(retPacket);
					}
				}

                Thread.Sleep( QValPollingInterval );
            }
lbFinished:

			return retPacket;
		}

		/// <summary> 
		/// Process qvals for a period of time. This can be used to ensure a fairly
		/// clean read on the read after this is done. Use the HQV flags to control
		/// qval processing.
		/// </summary> 
		public void ProcessQVals(uint seconds, uint hqvFlags)
		{
			System.Diagnostics.Debug.WriteLine(String.Format("ProcessQVals[{0:x}]: processing qvals for: {1} seconds", UserId, seconds));

			DateTime abortTime = DateTime.Now.AddSeconds(seconds);
			while(abortTime > DateTime.Now)
			{
				Thread.Sleep((int)((1000 * seconds) / 100));
				ProcessQVals(hqvFlags);
			}
		}
		
		/// <summary> 
		/// Process qvals with default settings.
		/// </summary> 
		public void ProcessQVals()
		{
			ProcessQVals(0);	
		}

		/// <summary> 
		/// Process qvals on the wire, dequeue and updating internal state with dequeues.
		/// Flags may be 0 or a combination of the HQV flags to control how the processed
		/// qvals should be processed.
		/// </summary> 
		public void ProcessQVals(uint hqvFlags)
		{
			// While we have qval packets queued for this user
			// Dequeue the latest qval packet
			QValPacket packet;
            while (DequeueQVals(out packet))
			{
				TimeSpan Delta = DateTime.Now - packet.DeliveryTime;
				System.Diagnostics.Debug.WriteLine(String.Format("ProcessQVals[{0:x}]: Sequence: {1}, QFlags: {2:x8}, ProcessLag: {3}", 
						UserId,
						packet.QValSequenceNum, 
						packet.QFlags, 
						Delta));

				HandleQValPacket(packet, hqvFlags);
				_LastQValPacket.Copy(packet);
			}
		}

        public void HandleQValPacket(QValPacket packet)
		{
			HandleQValPacket(packet, 0);
		}

		public void HandleQValPacket(QValPacket packet, uint hqvFlags)
		{
			if(packet.QValSequenceNum > _LastQValPacket.QValSequenceNum)
			{
				uint QFlags = packet.QFlags;

				System.Diagnostics.Debug.WriteLine(String.Format("HandleQValPacket[{0:x}]: consuming QValSequence: {1}, QFlags: 0x{2:x8}", 
						UserId,
						packet.QValSequenceNum,
						packet.QFlags));


				// Process the dequeues based on pending qflags markers
				if((QFlags & XonPresNoti.QFLAG_MASK_BUDDY_REQ) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_BUDDY_REQ);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_LIST_CHANGE) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_PRESENCE) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_PRESENCE);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_INVITE) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_INVITE);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_INVITE_ANSWER) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_INVITE_ANSWER);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_PEER_PRESENCE) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_PEER_PRESENCE);
				}
				if((QFlags & XonPresNoti.QFLAG_MASK_PRESENCE_2) != 0)
				{
					GetNotifications(XonPresNoti.PQUEUE_PRESENCE_2);
				}
			}

			if(packet.NewMessageSequenceNum > _LastQValPacket.NewMessageSequenceNum)
			{
				System.Diagnostics.Debug.WriteLine(String.Format("HandleQValPacket[{0:x}]: consuming message qval sequence: {1}, Ids: {2:x}, {3:x}, {4:x}", 
						UserId,
						packet.NewMessageSequenceNum,
						packet.NewMessageId(0),
						packet.NewMessageId(1),
						packet.NewMessageId(2)));

				ProcessNewMessages(packet, hqvFlags);
			}

			if(packet.DeletedMessageSequenceNum > _LastQValPacket.DeletedMessageSequenceNum)
			{
				System.Diagnostics.Debug.WriteLine(String.Format("HandleQValPacket[{0:x}]: consuming deleted qval sequence: {1}, Ids: {2:x}, {3:x}, {4:x}",
						UserId,
						packet.DeletedMessageSequenceNum,
						packet.DeletedMessageId(0),
						packet.DeletedMessageId(1),
						packet.DeletedMessageId(2)));

				ProcessDeletedMessages(packet, hqvFlags);
			}
		}

		// Handle all items delivered in the dequeue
		private void ProcessDequeue(uint qType, ListItem[] items)
		{
			System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: QType: {1} ({2}), Items.Length: {3}", 
						UserId,
						qType, 
						XonPresNoti.QTypeToString(qType), 
						items.Length));

            for( int i = 0; i < items.Length; ++i )
            {
                switch( qType )
                {
                    case XonPresNoti.PQUEUE_LIST_CHANGE:
                    case XonPresNoti.PQUEUE_BUDDY_REQ:
                    {
                        ListChangeItem item = (ListChangeItem)items[i].Data;

                        if( HResult.Failed( item.HR ) )
                        { 
							System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: failure item index: {1}, HR: {2:x8}",
									UserId,
                                    i,
									item.HR
									));

                            if (item.HR == XonPresNoti.E_USER_EXISTS)
							{
								// They're already friends
								continue;
							}
                            else
                            {
                                throw new HResultException(item.HR, "Negative HRESULT on listchange item: " + i);
                            }
                        }
	
                        if( item.ListVersion > BuddyListVer )
                        {
                            BuddyListVer = item.ListVersion;
                        }	
						else if(HResult.Succeeded(item.HR))
						{
							System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: ListChangeItem received with list version <= current BuddyListVer: {1} <= {2}",
									UserId,
									item.ListVersion, 
									BuddyListVer));
						}

                        BuddyInfo buddy = GetBuddyInfo(item.TargetID);
                        if( buddy == null )
                        {
							PNState user = Find(item.TargetID);
							if(user != null)
							{
								buddy = new BuddyInfo(XonPresNoti.NOT_A_BUDDY, user);
							}
							else
							{
                            	buddy = new BuddyInfo( XonPresNoti.NOT_A_BUDDY, item.TargetAcctName );
							}
                            Buddies[ item.TargetID ] = buddy;
                        }

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: BuddyListOperation: {1}, User: {2:x}, UserName: {3}",
								UserId,
								XonPresNoti.ListChangeOpToString(item.OperationID),
								item.TargetID,
								item.TargetAcctName));

                        switch( item.OperationID )
                        {
                            case XonPresNoti.PLIST_BUDDY_NOP:
                                if( buddy.Status == XonPresNoti.NOT_A_BUDDY )
                                {
                                    Buddies.Remove( item.TargetID );
                                }
                                break;

                            case XonPresNoti.PLIST_BUDDY_ADD:
								if(HResult.Succeeded(item.HR))
								{
									buddy.Status = XonPresNoti.P_BUDDY_STATUS_PENDING;
								}
								else
								{
									System.Diagnostics.Debug.WriteLine(String.Format("Buddy add failed for buddy {0:x}, HR: {1:x}, removing temporary buddy record", item.TargetID, item.HR));
									Buddies.Remove(item.TargetID);
								}
                                break;

                            case XonPresNoti.PLIST_BUDDY_ADDED:
                                buddy.Status = XonPresNoti.P_BUDDY_STATUS_REQUEST;
                                break;

                            case XonPresNoti.PLIST_BUDDY_ACCEPT:
                                buddy.Status = XonPresNoti.P_BUDDY_STATUS_OK;
                                break;

                            case XonPresNoti.PLIST_BUDDY_REJECT:
                            case XonPresNoti.PLIST_BUDDY_DELETE:
                                Buddies.Remove( item.TargetID );
                                break;
                            default:
								System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: Invalid ListChange OperationID: {1}",
										UserId, item.OperationID));
								break;
                        }
                        break;
                    }
                    case XonPresNoti.PQUEUE_INVITE:
					{
						InvitationItem item = (InvitationItem)items[i].Data;

						PNState invitor = Find(item.HostID);

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: Invitation received from: {1}", 
								UserId,
								invitor != null ? invitor.Name : item.HostID.ToString("x")));

						BuddyInfo buddy = GetBuddyInfo(item.HostID);
						if(null != buddy)
						{
							buddy.Invitation = item;
						}

						PeerInfo peer = GetPeerInfo(item.HostID);
						if(null != peer)
						{
							peer.Invitation = item;
						}

                        // Add the new invitation object
                        InvitationInfo invite = new InvitationInfo(invitor, item.MatchSessionID);
                        invite.Invitation = item;

                        if(null == Invites)
                        {
                            Invites = new Hashtable();
                        } 
                        Invites[item.HostID] = invite;

                        break;
                    }
                    case XonPresNoti.PQUEUE_INVITE_ANSWER:
                    {
                        InvitationAnswerItem item = (InvitationAnswerItem)items[i].Data;

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: InvitationAnswer received from: {1:x}", 
								UserId,
								item.InviteeID));

                        if(null == Invites)
                        {
                            Invites = new Hashtable();
                        }

                        InvitationInfo invite = Invites[UserId] as InvitationInfo;

                        if(null == invite)
                        {
                            System.Diagnostics.Debug.WriteLine("InvitationAnswer arrived which does not have a corresponding invitation info object, creating one");
                            invite = new InvitationInfo(this, item.MatchSessionID);
							invite.Owns = true;
                            Invites[item.InviteeID] = invite;
                        }
						else if(invite.Owns == false)
						{
							System.Diagnostics.Debug.WriteLine("InvitationAnswer arrived on user who was tracking an invitation but does not own it, setting ownership flag");
							invite.Owns = true;
						}

                        invite.InvitationAnswer = item;

                        break;
                    }
                    case XonPresNoti.PQUEUE_PRESENCE:
                    {
                        PresenceItem item = (PresenceItem)items[i].Data;

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: Presence received from: {1:x} (Title: {2:x}, State: {3:x}, SessId: {4:x})", 
								UserId,
								item.BuddyID,
								item.TitleID,
								item.State,
								item.MatchSessionID));

                        //ValidatePresenceItem(item); 

                        BuddyInfo buddy = GetBuddyInfo(item.BuddyID);
                        if(null != buddy)
                        {
                            buddy.Presence = item;
                            buddy.Validate = true;
                        }

						PeerInfo peer = GetPeerInfo(item.BuddyID);
						if(null != peer)
						{
							peer.Presence = item;
                            peer.Validate = true;
						}

                        break;
                    }
                    case XonPresNoti.PQUEUE_PEER_PRESENCE:
                    {
                        PeerPresenceItem item = (PeerPresenceItem)items[i].Data;

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: PeerPresence received from: {1:x} (Title: {2:x}, State: {3:x}, SessId: {4:x})", 
								UserId,
								item.UserID,
								item.TitleID,
								item.State,
								item.MatchSessionID));

						//ValidatePeerPresenceItem(item);

						PeerInfo peer = GetPeerInfo(item.UserID);
                        if (null != peer)
                        {
                            peer.PeerPresence = item;
                            peer.Validate = true;
                        }

                        break;
                    }
                    case XonPresNoti.PQUEUE_PRESENCE_2:
                    {
                        Presence2Item item = (Presence2Item)items[i].Data;

						System.Diagnostics.Debug.WriteLine(String.Format("ProcessDequeue[{0:x}]: RichPresence received from: {1:x} (Title: {2:x}, State: {3:x}, StateTime: {4}, SessId: {5:x}, String: {6})", 
								UserId,
								item.BuddyID,
								item.TitleID,
								item.State,
								item.BuddyStateTime,
								item.MatchSessionID,
								item.RichPresence));

						//ValidatePresence2Item(item);

                        BuddyInfo buddy = GetBuddyInfo(item.BuddyID);
                        if(null != buddy)
                        {
                            buddy.RichPresence = item;
                            buddy.Validate = true;
                        }

                        PeerInfo peer = GetPeerInfo(item.BuddyID);
						if(null != peer)
						{
							peer.RichPresence = item;
                            peer.Validate = true;
						}
                        
                        break;
                    }

                    default:
                    { 
                        throw new Exception( "Get Notifications wierdness: Bad QType" );
                    }
                }
            }
		}

		private void ProcessNewMessages(QValPacket packet, uint hqvFlags)
		{
			for(uint i = 0; i < 3; ++i)
			{
				uint msgId = packet.NewMessageId(i);
				uint msgData = packet.NewMessageData(i);

				if(0 != msgId && 0 != msgData)
				{
					System.Diagnostics.Debug.WriteLine(String.Format("ProcessNewMessages[{0:x}]: processing MsgId: {1:x}, Data: {2:x8} ({3})", 
							UserId,
							msgId,
							msgData,
							XonPresNoti.BuildMsgNotificationFlagsString(msgData)));

					if(null != GetMessageInfo(msgId))
					{
						// The message has already been indexed on a previous read, we can skip it
						continue;
					}

					//
					// Retreive the message data 
					//
					UserMessage msg = UserMessage.CreateBlank();
					uint setFlags = (0 != (hqvFlags & HQV_ReadMessages)) ? XonPresNoti.MSG_FLAG_READ : 0;

					uint hr = msg.GetDetails(this, msgId, setFlags, 0);

					if(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == hr)
					{
                        // This log message is deprecated for now. Test cases in messaging should cover this explicity
                        // this is such a common occurrence when quickly making buddies that it has become a bit annoying
						//System.Diagnostics.Debug.WriteLine("ProcessNewMessages[{0:x}]: MsgId: {1:x} did not exist may have been revoked or read by another action",
						//		UserId,
						//		msgId); 
						continue;
					}
					else if(!HResult.Succeeded(hr))
					{
						System.Diagnostics.Debug.WriteLine(String.Format("ProcessNewMessages[{0:x}]: GetDetails() failed for MsgId: {1:x}, HR: 0x{2:x8}",
								UserId,
								msgId,
								hr)); 
						continue;
					}

					// Save the summary
					MessageInfo info = new MessageInfo();
					info.Id          = msgId;
					info.Data        = msgData;
					info.Message     = msg;

					// Index message
					if(null == Messages)
					{
						Messages = new Hashtable();
					}

					Messages[info.Id] = info;

					// 
					// Do special by-type processing
					//
					if(XonPresNoti.MSG_TYPE_GAME_INVITE == info.MessageType)
					{
						InvitationInfo invite = GetInvitationInfo(info.Message.SenderID);

						if(null == invite)
						{
							invite = new InvitationInfo();

							invite.Owns         = false;
							invite.Host         = Find(info.Message.SenderID) as PNState;
							invite.MatchSession = (ulong)msg.Details.GetQwordProperty( XonPresNoti.MSG_PROP_SESSION_ID );

							if(null == Invites)
							{
								Invites = new Hashtable();
							}

							Invites[info.Message.SenderID] = invite;
						}

						invite.MessageId = msgId;
					}

					// 
					// Handle messaging HQV post process flags
					//
					if(0 != (HQV_DeleteMessages & hqvFlags))
					{
						DeleteMessage(msgId);
					}
				}
			}
		}

		private void ProcessDeletedMessages(QValPacket packet, uint hqvFlags)
		{
			for(uint i = 0; i < 3; ++i)
			{
				uint msgId = packet.DeletedMessageId(i);

				if(0 != msgId)
				{
					System.Diagnostics.Debug.WriteLine(String.Format("ProcessDeletedMessages[{0:x}]: processing MsgId: {1:x}", 
							UserId,
							msgId));

					MessageInfo info = GetMessageInfo(msgId);
					if(null == info)
					{
						info = new MessageInfo();
						info.Id          = msgId;
						info.Data        = 0;
						info.Message     = null;
					}

					info.Deleted     = true;

					// Index message
					if(null == Messages)
					{
						Messages = new Hashtable();
					}

					Messages[info.Id] = info;
				}
			}
		}

        public UserTitle[] EnumerateTitles()
        {
		    QMsgEnumTitles req = new QMsgEnumTitles(this);
            PNMsg rep;
            live.server.Presence.TransactFD(this, req, out rep);

	        QEnumTitlesReplyMsgData repData = (QEnumTitlesReplyMsgData)rep.Data;

            if(HResult.Failed(repData.HR))
            {
                throw new HResultException(repData.HR, "EnumerateTitles() failed failed for user: " + UserId);
            }

            return repData.Titles;
        }

        public void DeleteTitle(uint titleId)
        {
		    QMsgDeleteTitle req = new QMsgDeleteTitle(this, titleId);
            PNMsg rep;
            live.server.Presence.TransactFD(this, req, out rep);

            QDeleteTitleReplyMsgData repData = (QDeleteTitleReplyMsgData)rep.Data;

            if(HResult.Failed(repData.HR))
            {
                throw new HResultException(repData.HR, "DeleteTitle() failed failed for user: " + UserId);
            }
        }

  		/// <summary>
		/// This method is called to accumulate 
		/// SG qval data on the state object.
		///
		/// Technically the real SG would accumulate these changes for the
		/// user this method will packetize it so that this process is not lossy.
		/// </summary>
		public bool EnqueueQVals(bool bIsPush, uint [] qvalData)
		{
            lock (QValPacketQueue.SyncRoot)
            {
                if (QValPacketQueue.Count > MAX_QVAL_QUEUE_SIZE)
                {
                    return false;
                }

                QValPacket packet = new QValPacket();
                packet.Push = bIsPush;
                packet.Data = qvalData;
                packet.DeliveryTime = DateTime.Now;
                QValPacketQueue.Enqueue(packet);
            }
			return true;
		}

		/// <summary>
		/// Read queued qval packets until false is returned.
		/// </summary>
		public bool DequeueQVals(out QValPacket packet)
		{
            if (Xbox is live.client.FakeSGSecurityProvider)
            {
                live.client.FakeSGSecurityProvider fakeSG = Xbox as live.client.FakeSGSecurityProvider;
                if (Xbox != null)
                {
                    return fakeSG.DequeueQVals(UserId, out packet);
                }
                packet = null;
                return false;
            }
            else if (Xbox is live.client.TG2SecurityProvider)
            {
                live.client.TG2SecurityProvider tg2sp = Xbox as live.client.TG2SecurityProvider;
                if (Xbox != null)
                {
                    return tg2sp.DequeueQVals(UserId, out packet);
                }
                packet = null;
                return false;
            }
            else
            {
                lock (QValPacketQueue.SyncRoot)
                {
                    if (QValPacketQueue.Count > 0)
                    {
                        packet = QValPacketQueue.Dequeue() as QValPacket;
                        return true;
                    }
                    else
                    {
                        packet = null;
                        return false;
                    }
                }
            }
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgEnumMsgs.cs ===
// QMsgEnumMsgs.cs
//
//	Notification (Messaging) Enumerate Messages message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerates messages for a user
	/// </summary>
	public class QMsgEnumMsgs : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User messages are to</param>
		public QMsgEnumMsgs( PNState user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QEnumMsgsMsgData data = new QEnumMsgsMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs request
	/// </summary>
	public class QEnumMsgsMsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs reply
	/// </summary>
	public class QEnumMsgsReplyMsgData : PNMsgData
	{
		public uint             HR;
		public ushort           MessagesLen;
		public UserMsgSummary[] Messages;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgRevokeExMsg.cs ===
// QMsgRevokeMsgEx.cs
//
//  Notification (Messaging) Revoke Ex Message
//

using System;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Revoke a message for a user
    /// </summary>
    public class QMsgRevokeMsgEx : PNRequestMsg
    {
        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="sender">Sender of message</param>
        /// <param name="context">Message context</param>
        /// <param name="type">Message type</param>
        /// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
        public QMsgRevokeMsgEx( PNState user, 
                                ulong senderContext, 
                                uint revokeFlags,
                                byte msgType, 
                                MsgPropertyWrapped prop,
                                RecipientResult[] recipients )
        {
            SentFrom    = Requestor.Client;
            PortOnFD    = FDPort.Messaging;
            AuthMethod  = FDAuth.SGMsg;
            ServiceOnFD = FDService.Messaging;

            Msg.Hdr = new PNMsgHdr();
            Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE_EX;
            Msg.Hdr.MsgLen  = 0;
            Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
            
            Msg.Hdr.Sgaddr = new SGADDR();
            Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
            Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
            Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;


            QRevokeExMsgMsgData data = new QRevokeExMsgMsgData();
            data.SenderID       = user.UserId;
            data.SenderContext  = senderContext;
            data.Flags          = revokeFlags;
            data.MessageType    = msgType;

            if(null == prop)
            {
                data.PropTag        = 0;
                data.cbProp         = 0;
                data.rgbProp        = new byte[0];
            }
            else
            {
                data.PropTag        = prop.tag;
                data.cbProp         = (ushort)prop.ExtraData.Length;
                data.rgbProp        = prop.ExtraData;
            }

            if(null == recipients)
            {
                data.RecipientsLen  =  0;
                data.Recipients     = null;
            }
            else
            {
                data.RecipientsLen  = (ushort)recipients.Length;
                data.Recipients     = recipients;
            }

            Msg.Data = data;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Revoke Msg request
    /// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
    /// and context are deleted
    /// </summary>
    public class QRevokeExMsgMsgData : PNMsgData
    {
        public ulong                SenderID;
        public ulong                SenderContext;
        public uint                 Flags;
        public ushort               PropTag;
        public ushort               RecipientsLen;
        public ushort               cbProp;
        public byte                 MessageType;
        
        public RecipientResult[]    Recipients;
        [WireInfo(SizeParam="cbProp")]
        public byte[]               rgbProp;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message data specific to Revoke Msg By Prop reply
    /// </summary>
    public class QRevokeExMsgReplyMsgData : PNMsgData
    {
        public uint hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgFlags.cs ===
// QMsgFlags.cs
//
//	Notification (Messaging) Flags Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Set flags of specified message for a user
	/// </summary>
	public class QMsgFlags : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="msgId">Id of message</param>
		/// <param name="setFlags"></param>
		/// <param name="unsetFlags"></param>
		public QMsgFlags( PNState user, uint msgId, uint setFlags, uint unsetFlags )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_FLAGS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QFlagsMsgData data = new QFlagsMsgData();
			data.UserID     = user.UserId;
			data.MessageID  = msgId;
			data.SetFlags   = setFlags;
			data.UnsetFlags = unsetFlags;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Flags request
	/// </summary>
	public class QFlagsMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
		public uint  SetFlags;
		public uint  UnsetFlags;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Flags reply
	/// </summary>
	public class QFlagsReplyMsgData : PNMsgData
	{
		public uint hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgEnumMsgs2.cs ===
// QMsgEnumMsgs.cs
//
//	Notification (Messaging) Enumerate Messages message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerates messages for a user
	/// </summary>
	public class QMsgEnumMsgs2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User messages are to</param>
		public QMsgEnumMsgs2( PNState user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_MESSAGES_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QEnumMsgs2MsgData data = new QEnumMsgs2MsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs request
	/// </summary>
	public class QEnumMsgs2MsgData : PNMsgData
	{
		public ulong  UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Msgs reply
	/// </summary>
	public class QEnumMsgs2ReplyMsgData : PNMsgData
	{
		public uint             HR;
		public ushort           MessagesLen;
		public UserMsgSummary2[] Messages;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgEnumTitles.cs ===
// QMsgEnumTitles.cs
//
//	Notification (Messaging) Enumerate Titles Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerate titles
	/// </summary>
	public class QMsgEnumTitles : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">User making request</param>
		public QMsgEnumTitles( PNState user )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_TITLES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QDeleteTitleMsgData data = new QDeleteTitleMsgData();
			data.UserID = user.UserId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Titles request
	/// </summary>
	public class QEnumTitlesMsgData : PNMsgData
	{
		public ulong UserID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate Titles reply
	/// </summary>
	public class QEnumTitlesReplyMsgData : PNMsgData
	{
		public uint        HR;
		public ushort      TitlesLen;
		public UserTitle[] Titles;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Per title info retruned when a user enumerates titlte.
	/// </summary>
	public class UserTitle : WireData
	{
		public uint     TitleID;
		public DateTime LastLogon;
		public uint     Flags;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgEnumSystemMsgs.cs ===
// QMsgEnumSystemMsgs.cs
//
//	Notification (Messaging) Enumerate System Messages Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Enumerate non user specific messages for a particular title. 
	/// System will be 0 or Dash title ID - TBD.
	/// </summary>
	public class QMsgEnumSystemMsgs : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="titleId">Title responsible for message</param>
		public QMsgEnumSystemMsgs( uint titleId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.HttpHdr;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_ENUM_SYSTEM_MESSAGES;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QEnumSystemMsgsMsgData data = new QEnumSystemMsgsMsgData();
			data.TitleID = titleId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate System Msgs request
	/// </summary>
	public class QEnumSystemMsgsMsgData : PNMsgData
	{
		public uint TitleID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Enumerate System Msgs reply
	/// </summary>
	public class QEnumSystemMsgsReplyMsgData : PNMsgData
	{
		public uint               HR;
		public ushort             SummariesLen;
		public SystemMsgSummary[] Summaries;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgRevokeMsg.cs ===
// QMsgRevokeMsg.cs
//
//	Notification (Messaging) Revoke Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Revoke a message for a user
	/// </summary>
	public class QMsgRevokeMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">Sender of message</param>
		/// <param name="context">Message context</param>
		/// <param name="type">Message type</param>
		/// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
		public QMsgRevokeMsg( PNState sender, ulong context, byte type, RecipientResult[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = sender.Client.MachinePuid;

			QRevokeMsgMsgData data = new QRevokeMsgMsgData();
			data.SenderID      = sender.UserId;
			data.SenderContext = context;
			data.MessageType   = type;
			data.Recipients    = recipients;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg request
	/// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
	/// and context are deleted
	/// </summary>
	public class QRevokeMsgMsgData : PNMsgData
	{
		public ulong             SenderID;
		public ulong			 SenderContext;  // Never used, must be zero
		public ushort            RecipientsLen;
		public byte	             MessageType;    // Never used, must be zero
		public RecipientResult[] Recipients;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg reply
	/// </summary>
	public class QRevokeMsgReplyMsgData : PNMsgData
	{
		public uint hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgRevokeMsgByProp.cs ===
// QMsgRevokeMsgByProp.cs
//
//	Notification (Messaging) Revoke by Property Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Revoke a message for a user
	/// </summary>
	public class QMsgRevokeMsgByProp : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">Sender of message</param>
		/// <param name="context">Message context</param>
		/// <param name="type">Message type</param>
		/// <param name="recipients">If recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted</param>
		public QMsgRevokeMsgByProp( PNState sender, ulong context, byte type, RecipientResult[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_REVOKE_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = sender.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = sender.Client.MachinePuid;

			QRevokeMsgByPropMsgData data = new QRevokeMsgByPropMsgData();
			// TBD! Figure out how to load this
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg request
	/// If recipients.dwMessageID is zero, all messages of this type with a matching sender 
	/// and context are deleted
	/// </summary>
	public class QRevokeMsgByPropMsgData : PNMsgData
	{
		public ulong  SenderID; // XPNFD requires that UserID be the first member
		public ushort RecipientIdsLen;
		public byte   MessageType; // If4 recipients.dwMessageID is zero, all messages of this type with a matching sender and context are deleted
		public uint   Flags;
		public ushort PropTag;
		// TBD! Figure out how to get the property setup for wiredata, not doing this now 
		//		because this is not valid from the FD so I won't be using this message
		// WORD cbProp;
		// BYTE rgbProp[];
		public ulong RecipientIds;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Revoke Msg By Prop reply
	/// </summary>
	public class QRevokeMsgByPropReplyMsgData : PNMsgData
	{
		public uint hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgSummary2.cs ===
// QMsgSummary.cs
//
//	Notification (Messaging) Summary Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get summary of specified message for a user
	/// </summary>
	public class QMsgSummary2 : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="messageId">Id of message</param>
		public QMsgSummary2( PNState user, uint messageId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_SUMMARY_2;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QSummary2MsgData data = new QSummary2MsgData();
			data.UserID    = user.UserId;
			data.MessageID = messageId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary request
	/// </summary>
	public class QSummary2MsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary reply
	/// </summary>
	public class QSummary2ReplyMsgData : PNMsgData
	{
		public uint           HR;
		public UserMsgSummary2 Summary;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgSystemDetails.cs ===
// QMsgSystemDetails.cs
//
//	Notification (Messaging) System Msg Details message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get details of specified system message
	/// </summary>
	public class QMsgSystemDetails : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="titleId">Title responsible for message</param>
		/// <param name="msgId">Id of message</param>
		public QMsgSystemDetails( uint titleId, uint msgId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SYSTEM_MESSAGE_DETAILS;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QSystemDetailsMsgData data = new QSystemDetailsMsgData();
			data.TitleID = titleId;
			data.MsgID   = msgId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to System Msg Details request
	/// </summary>
	public class QSystemDetailsMsgData : PNMsgData
	{
		public uint TitleID;
		public uint MsgID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to System Msg Details reply
	/// </summary>
	public class QSystemDetailsReplyMsgData : PNMsgData
	{
		public uint             HR;
		public SystemMsgSummary Summary;
		public MsgDetails       Details;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgSummary.cs ===
// QMsgSummary.cs
//
//	Notification (Messaging) Summary Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Get summary of specified message for a user
	/// </summary>
	public class QMsgSummary : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="user">Owner of message</param>
		/// <param name="messageId">Id of message</param>
		public QMsgSummary( PNState user, uint messageId )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_MESSAGE_SUMMARY;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = user.Xbox.IpSg;
			Msg.Hdr.Sgaddr.dwSpiSg  = user.Xbox.SpiSg;
			Msg.Hdr.Sgaddr.qwXboxId = user.Client.MachinePuid;

			QSummaryMsgData data = new QSummaryMsgData();
			data.UserID    = user.UserId;
			data.MessageID = messageId;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary request
	/// </summary>
	public class QSummaryMsgData : PNMsgData
	{
		public ulong UserID;
		public uint  MessageID;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Summary reply
	/// </summary>
	public class QSummaryReplyMsgData : PNMsgData
	{
		public uint           HR;
		public UserMsgSummary Summary;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QValPacket.cs ===
using System;

namespace live.protocol.Presence
{
	/// <summary>
	/// A representation of the QVAL data that is delivered from notification
	/// to the SG and from the SG to the client. This class packages up the data
	/// and flags so that we can percolate the data from the wire up to the test
	/// infrastructure.
	/// </summary>
	[Serializable]
	public class QValPacket
	{
		private uint []_Data = new uint[15];

		/// <summary>
		///	File time when this qval was delivered
		/// </summary>
		public DateTime DeliveryTime;

		/// <summary>
		/// Push flag set to indicate urgent data delivery
		/// </summary>
		public bool Push;

		/// <summary>
		/// Set the qvals in the packet, copy them into an internal 
		/// buffer.
		/// </summary>
		public uint[] Data
		{
			get {
				return _Data;
			}
			set {
				Array.Copy(value, _Data, 15);
			}
		}

		/// <summary>
		/// Notification Queue Flags
		/// </summary>
		public uint QVal 
		{
			get {
				return _Data[0];
			}
		}

		public uint QValSequenceNum
		{
			get {
				return _Data[0] >> 8;
			}
		}

		/// <summary>
		/// Indication of payload available in queue.
		/// </summary>
		public uint QFlags
		{
			get {
				return _Data[1];
			}
		}

		/// <summary>
		/// Low byte indicates positive existence
		/// of invite transient message, high 24 bits
		/// indicate the sequence number of the invite.
		/// </summary>
		public uint InviteQVal
		{
			get { 
				return _Data[2];
			}
		}

		/// <summary>
		/// Read invite sequence from invite qval.
		/// </summary>
		public uint InviteSequenceNum
		{
			get {
				return _Data[2] >> 8;
			}
		}

		public uint NewMesageIdQVal 
		{
			get {
				return _Data[3];
			}
		}

		/// <summary>
		/// This value is the same for both msg data and id qvals
		/// </summary>
		public uint NewMessageSequenceNum
		{
			get {
				return _Data[3] >> 8;
			}
		}
		
		/// <summary>
		/// The last 3 message IDs that arrived.
		/// </summary>
		public uint NewMessageId(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[4+index];
		}
		
		/// <summary>
		/// </summary>
		public uint NewMessageDataQVal 
		{
			get {
				return _Data[7];
			}
		}

		/// <summary>
		/// Data for the last 3 messages that arrived
		/// </summary>
		public uint NewMessageData(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[8 + index];
		}
		
		/// <summary>
		/// Raw qval value for deleted message payload.
		/// </summary>
		public uint DeletedMessageQVal 
		{
			get {
				return _Data[11];
			}
		}
		
		/// <summary>
		/// Last sequence number for the delete message qval and associated payloads.
		/// </summary>
		public uint DeletedMessageSequenceNum
		{
			get {
				return _Data[11] >> 8;
			}
		}

		

		/// <summary>
		/// Last 3 messages deleted
		/// </summary>
		public uint DeletedMessageId(uint index)
		{
			if(index > 2)
				throw new IndexOutOfRangeException("Only values between 0 and 2 are accepted");
			return _Data[12 + index];
		}

		/// <summary>
		/// Perform copy operation on data rather than object assignment.
		/// </summary>
		public void Copy(QValPacket packet)
		{
			Push          = packet.Push;
			Data          = packet.Data;
			DeliveryTime  = packet.DeliveryTime;
		}

		/// <summary>
		/// Clear the qval payload data.
		/// </summary>
		public void Clear()
		{
			_Data = new uint[15];
		}

		/// <summary>
		/// Find the first matching message type in messaging qvals for provided type ID.
		/// If no appropriate message is found returns 0.
		/// </summary>
		public uint FirstMessageIdMatchingType(byte msgType)
		{
			uint msgId = 0;
			uint msgData = 0;
			uint msgIdMatch = 0;
			uint msgDataMatch = (uint)(msgType << 24);

			for(uint i = 0; i < 3; ++i)
			{
				msgId   = NewMessageId(i);
				msgData = NewMessageData(i);

				if(0 != msgId && 0 != msgData)
				{
					if((msgData & 0xff000000) == msgDataMatch)
					{
						msgIdMatch = msgId;
						break;
					}
				}
			}

			return msgIdMatch;
		}


		//------------------------------------------------------------------------------
		//
		// QFlag property accessors
		//
		//------------------------------------------------------------------------------
		
		public bool HasBuddyRequest
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_BUDDY_REQ);
			}
		}
		public bool HasListChange
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_LIST_CHANGE);
			}
		}
		public bool HasPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PRESENCE);
			}
		}
		public bool HasInvite
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_INVITE);
			}
		}
		public bool HasInviteAnswer
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_INVITE_ANSWER);
			}
		}
		public bool HasTransientMessage
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS);
			}
		}
		public bool HasPeerPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PEER_PRESENCE);
			}
		}
		public bool HasRichPresence
		{
			get {
				return 0 != (_Data[1] & XonPresNoti.QFLAG_MASK_PRESENCE_2);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\SystemMessage.cs ===
// SystemMessage.cs
//
//	System Message storage and mainipulation
//

using System;
using live.common;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// System message summary data
    /// </summary>
    public class SystemMsgSummary : WireData
    {
        public uint TitleID;
        public ulong SenderContext;
        public DateTime SentTime;
        public uint Region;
        public uint MessageID;
        public uint MessageFlags;
        public ushort ExpireMinutes; // An offset in minutes from the sent time
        public ushort cbDetails;
        public byte MessageType;
        [WireInfo(ArraySize = 15)] // XONLINE_GAMERTAG_SIZE-1      
        public string SenderName;
        [WireInfo(ArraySize = 64)] // XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN
        public string Description;
    }

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// System Message Wrapper
	/// </summary>
	public class SystemMessage : Message
	{
		// Used by Delete to specify clearing of messages from user queues as well
		public enum RevokeAlso { Yes, No }

		// Message data unique to system messages
		public uint   Region;
		public string Description;

		// Default constructor only used by static factory methods
		private SystemMessage() {}

		//////////////////////////////////////
		/// <summary>
		/// Creates a blank System message 
		/// </summary>
		/// <returns>Blank system message ready to be loaded for sending</returns>
		public static SystemMessage CreateBlank()
		{
			SystemMessage msg = new SystemMessage();
			msg.Details = MsgDetails.CreateBlank();
			return msg;
		}

		//////////////////////////////////////
		/// <summary>
		/// Fully parametarized creation of sytem message
		/// </summary>
		/// <param name="senderName">Name of sender</param>
		/// <param name="titleID">Title message is for</param>
		/// <param name="region">Region message is for</param>
		/// <param name="context">Message specific context</param>
		/// <param name="sentTime">Message activation time</param>
		/// <param name="flags">Message flags</param>
		/// <param name="expireMinutes">Minutes until message expires after it is activated</param>
		/// <param name="type">Message Type</param>
		/// <param name="description">Message Descripion</param>
		/// <param name="details">Collection of message properties</param>
		/// <returns>A system message loaded and ready for sending</returns>
		public static SystemMessage Create(
			string     senderName,
			uint       titleID,
			uint       region,
			ulong      context,
			DateTime   sentTime,
			uint       flags,
			ushort     expireMinutes,
			byte       type,
			string     description,
			MsgDetails details )
		{
			SystemMessage msg = new SystemMessage();

			msg.SenderName    = senderName;
			msg.TitleID       = titleID;
			msg.Region        = region;
			msg.Context       = context;
			msg.SentTime      = sentTime;
			msg.Flags         = flags;
			msg.ExpireMinutes = expireMinutes;
			msg.Type          = type;
			msg.Description   = description;
			msg.Details       = details;
			
			return msg;
		}
 
		//////////////////////////////////////
		/// <summary>
		/// Fully parametarized creaton of Live type system message
		/// </summary>
		/// <param name="priority">Message priority, used to set flags</param>
		/// <param name="senderName">Name of Sender</param>
		/// <param name="titleId">Title message is for</param>
		/// <param name="region">Region message is for</param>
		/// <param name="description">Message Descripion</param>
		/// <param name="stringId">ID for string server lookup</param>
		/// <param name="delayedSendMinutes">Minutes from now message will activate</param>
		/// <param name="expireMinutes">Minutes until message expires after it is activated</param>
		/// <returns>A complete Live type system message loaded and ready for sending</returns>
		public static SystemMessage CreateLiveMsg( 
			Priority priority,
			string   senderName,
			uint     titleId,
			uint     region,
			string   description,
			uint     stringId,
			ushort   delayedSendMinutes,
			ushort   expireMinutes )
		{
			MsgDetails details = MsgDetails.CreateBlank();
			details.AddProperty( XonPresNoti.MSG_PROP_SYSTEM_TEXT, stringId );

			uint flags = 0;
			switch( priority )
			{
				case Priority.Required:   flags = XonPresNoti.MSG_FLAG_REQUIRED;   break;
				case Priority.Recomended: flags = XonPresNoti.MSG_FLAG_RECOMMENDED; break;
			}

			return Create( 
				senderName,
				titleId,
				region,
				0, // context required for Live Message type
				DateTime.UtcNow.AddMinutes( delayedSendMinutes ),
				flags,
				expireMinutes,
				XonPresNoti.MSG_TYPE_LIVE_MESSAGE,
				description,
				details );
		}

		//////////////////////////////////////
		/// <summary>
		/// Constuct with received message summary
		/// </summary>
		/// <param name="summary">Message summary wire data</param>
		public SystemMessage( SystemMsgSummary summary )
		{
			TitleID       = summary.TitleID;
			Context       = summary.SenderContext;
			SentTime      = summary.SentTime;
			Region        = summary.Region;
			ID            = summary.MessageID;
			Flags         = summary.MessageFlags;
			ExpireMinutes = summary.ExpireMinutes; // An offset in minutes from the sent time
			Type          = summary.MessageType;
			SenderName    = summary.SenderName;
			Description   = summary.Description;
		}

		//////////////////////////////////////
		/// <summary>
		/// Constuct with system details message
		/// </summary>
		/// <param name="titleId">Title message was for</param>
		/// <param name="msgId">ID of message</param>
		public SystemMessage( uint titleId, uint msgId )
		{
			QMsgSystemDetails detailsMsg = new QMsgSystemDetails( titleId, msgId );

			PNMsg replyMsg;
			live.server.Presence.TransactFD( PNState.Service, detailsMsg, out replyMsg );

			QSystemDetailsReplyMsgData replyData = (QSystemDetailsReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "System Details Message HR = 0x"+Hexer.tohex( replyData.HR ));

			TitleID       = replyData.Summary.TitleID;
			Context       = replyData.Summary.SenderContext;
			Region        = replyData.Summary.Region;
			ID            = replyData.Summary.MessageID;
			Flags         = replyData.Summary.MessageFlags;
			ExpireMinutes = replyData.Summary.ExpireMinutes;
			Type          = replyData.Summary.MessageType;
			SenderName    = replyData.Summary.SenderName;
			Description   = replyData.Summary.Description;
			SentTime      = replyData.Summary.SentTime;
			Details       = replyData.Details;
		}

		//////////////////////////////////////
		/// <summary>
		/// Send message based on current contents. Changes Message ID if send succedes
		/// </summary>
		/// <returns>Message ID if succesfull</returns>
		public uint Send()
		{
			QMsgSendSystemMsg sendMsg = new QMsgSendSystemMsg( this );
			
			PNMsg replyMsg;
            live.server.Presence.TransactFD(PNState.Service, sendMsg, out replyMsg);

			QSendSystemMsgReplyMsgData replyData = (QSendSystemMsgReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Send System Message HR = 0x"+Hexer.tohex( replyData.HR ));

			ID = replyData.MsgID;
			
			return ID;
		}

		//////////////////////////////////////
		/// <summary>
		/// Static fully parametarized deletion
		/// </summary>
		/// <param name="titleId">Title message was sent to</param>
		/// <param name="msgId">ID of message</param>
		/// <param name="revoke">option to also delete message already delivered to users</param>
		public static void Delete( uint titleId, uint msgId, RevokeAlso revoke )
		{
			QMsgDeleteSystemMsg delMsg = new QMsgDeleteSystemMsg( titleId, msgId, revoke == RevokeAlso.Yes );

			PNMsg replyMsg;
            live.server.Presence.TransactFD(PNState.Service, delMsg, out replyMsg);

			QDeleteSystemMsgReplyMsgData replyData = (QDeleteSystemMsgReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Delete System Message HR = 0x"+Hexer.tohex( replyData.HR ));
		}

		//////////////////////////////////////
		/// <summary>
		/// Delete this message (based on current contents)
		/// </summary>
		/// <param name="revoke">Option to also delete message already delivered to users</param>
		public void Delete( RevokeAlso revoke )
		{
			Delete( TitleID, ID, revoke ); 
		}

		//////////////////////////////////////
		/// <summary>
		/// Gets details and stores them
		/// </summary>
		public void GetDetails()
		{
			QMsgSystemDetails detailsMsg = new QMsgSystemDetails( TitleID, ID );

			PNMsg replyMsg;
            live.server.Presence.TransactFD(PNState.Service, detailsMsg, out replyMsg);

			QSystemDetailsReplyMsgData replyData = (QSystemDetailsReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "System Details Message HR = 0x"+Hexer.tohex( replyData.HR ));
			
			Details = replyData.Details;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgSendMsg.cs ===
// QMsgSendMsg.cs
//
//	Notification (Messaging) Send Message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Send a message for a user
	/// </summary>
	public class QMsgSendMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sender">User sending message</param>
		/// <param name="msg">Message being sent</param>
		/// <param name="recipients">UserIds message is too</param>
		public QMsgSendMsg( PNState sender, UserMessage msg, ulong[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging;
			AuthMethod  = FDAuth.SGMsg;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();

            // Possible system message
            if(null == sender || null == sender.Xbox)
            {
			    Msg.Hdr.Sgaddr.inaSg  = 0;
			    Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			    Msg.Hdr.Sgaddr.qwXboxId = 0;
            }
            else
            {
			    Msg.Hdr.Sgaddr.inaSg  = sender.Xbox.IpSg;
			    Msg.Hdr.Sgaddr.dwSpiSg  = sender.Xbox.SpiSg;
			    Msg.Hdr.Sgaddr.qwXboxId = sender.Client.MachinePuid;
            }

			QSendMsgMsgData data = new QSendMsgMsgData();
			data.SenderID      = msg.SenderID;
			data.SenderName    = msg.SenderName;
			data.SenderTitleID = msg.TitleID;
			data.SenderContext = msg.Context;
			data.MessageFlags  = msg.Flags;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.MessageType   = msg.Type;
			data.Recipients    = recipients;
			data.Details       = msg.Details;
			data.cbDetails	   = msg.Details.size; 
			Msg.Data = data;
		}

		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Message being sent</param>
		/// <param name="recipients">UserIds message is too</param>
		public QMsgSendMsg( UserMessage msg, ulong[] recipients )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QSendMsgMsgData data = new QSendMsgMsgData();
			data.SenderID      = msg.SenderID;
			data.SenderName    = msg.SenderName;
			data.SenderTitleID = msg.TitleID;
			data.SenderContext = msg.Context;
			data.MessageFlags  = msg.Flags;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.MessageType   = msg.Type;
			data.Recipients    = recipients;
			data.Details       = msg.Details;
			data.cbDetails	   = msg.Details.size; 
			Msg.Data = data;
		}
	}


	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send Msg request
	/// </summary>
	public class QSendMsgMsgData : PNMsgData
	{
		public ulong      SenderID;
		public ulong      SenderContext;
		public uint       MessageFlags;
		public uint       SenderTitleID;
		public ushort     ExpireMinutes;
		public ushort     cbDetails; 
		public ushort     RecipientsLen;
		public byte       MessageType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string     SenderName;
		public ulong[]    Recipients;
		public MsgDetails Details;
	}

//	//
//	// Invite Messages between Presence & Notification clusters include the following information
//	//  tacked on to the end of a Q_SEND_MESSAGE_MSG, one per recipient.
//	//
//	struct Q_SEND_MESSAGE_ADDENDUM 
//	{
//		BYTE        fFriend;
//		ULONGLONG   qwWebID;
//	};

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send Msg reply
	/// </summary>
	public class QSendMsgReplyMsgData : PNMsgData
	{
		public uint              hr;
		public ushort            recipientsLen;
		public RecipientResult[] recipients;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Recipient result is message Id on success and HR on failure
	/// </summary>
	public class RecipientResult : WireData
	{
		public ulong  userId;
		public uint   data;

		public uint msgId {
            get{ return data; }
            set{ data = value; }
        }
		public uint hr {
            get{ return data; }
            set{ data = value; }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\QMsgSendSystemMsg.cs ===
// QMsgSendSystemMsg.cs
//
//	Notification (Messaging) Send System Msg message
//

using System;

namespace live.protocol.Presence
{
	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Send a system message
	/// </summary>
	public class QMsgSendSystemMsg : PNRequestMsg
	{
		//////////////////////////////////////
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">System Message Object</param>
		public QMsgSendSystemMsg( SystemMessage msg )
		{
			SentFrom    = Requestor.Client;
			PortOnFD    = FDPort.Messaging_DC;
			AuthMethod  = FDAuth.None;
			ServiceOnFD = FDService.Messaging;

			Msg.Hdr = new PNMsgHdr();
			Msg.Hdr.MsgType = XonPresNoti.QMSG_SEND_SYSTEM_MESSAGE;
			Msg.Hdr.MsgLen  = 0;
			Msg.Hdr.SeqNum  = live.server.Presence.PresSeqNum;
			
			Msg.Hdr.Sgaddr = new SGADDR();
			Msg.Hdr.Sgaddr.inaSg  = 0;
			Msg.Hdr.Sgaddr.dwSpiSg  = 0;
			Msg.Hdr.Sgaddr.qwXboxId = 0;

			QSendSystemMsgMsgData data = new QSendSystemMsgMsgData();
			data.TitleID       = msg.TitleID;
			data.SentTime      = msg.SentTime;
			data.SenderContext = msg.Context;
			data.Region        = msg.Region;
			data.MsgFlags      = msg.Flags;
			data.MsgType       = msg.Type;
			data.ExpireMinutes = msg.ExpireMinutes;
			data.SenderName    = msg.SenderName;
			data.cbDetails     = msg.Details.size;
			data.Details       = msg.Details;
			data.Description   = msg.Description;
			Msg.Data = data;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send System Msg request
	/// </summary>
	public class QSendSystemMsgMsgData : PNMsgData
	{
		public uint       TitleID;
		public ulong      SenderContext;
		public DateTime	  SentTime;
		public uint       Region; 
		public uint       MsgFlags;
		public ushort     ExpireMinutes;
		public ushort     cbDetails;
		public byte       MsgType;
		[WireInfo(ArraySize=15)] // XONLINE_GAMERTAG_SIZE-1      
		public string     SenderName;
		[WireInfo(ArraySize=64)] // XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN
		public string   Description;
		public MsgDetails Details;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Message data specific to Send System Msg reply
	/// </summary>
	public class QSendSystemMsgReplyMsgData : PNMsgData
	{
		public uint HR;
		public uint MsgID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\TeamMember.cs ===
// TeamMember.cs
//
//	Handy container for Team members
//

using System;
using live.common;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Sim Object for Team members, storage and validation for team meber specific user 
    /// data.
    /// </summary>
    public class TeamMember
    {
        // Parent team's data
        public Team Team;

        // Join Info
        public DateTime WhenJoined = DateTime.MinValue;
        public bool Joined = false;

        // Member Info
        public PNState User;
        public uint Privliges;
        public byte[] Data;

        public ulong UserId
        {
            get
            {
                return User.UserId;
            }
        }

        public string Name
        {
            get
            {
                return User.Name;
            }
        }


        // Random data generators
        public uint RandomTitlePriv
        {
            get
            {
                uint priv = (uint)Team.RandGen.Next();
                return (priv <<= 5);
            }
        }
        public uint RandomLivePriv
        {
            get { return (uint)Team.RandGen.Next(0, 0x20); }
        }
        public uint RandomPriv
        {
            get { return RandomTitlePriv | RandomLivePriv; }
        }
        public byte[] RandomData
        {
            get
            {
                int dataSize = Team.RandGen.Next(0, (int)XonPresNoti.MAX_TEAM_MEMBER_DATA_SIZE + 1);
                byte[] data = new byte[dataSize];
                Team.RandGen.NextBytes(data);
                return data;
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Load member data with valid random stuff. (no Live privileges)
        /// </summary>
        public void LoadWithRandomInfo()
        {
            Data = RandomData;
            Privliges = RandomPriv;
        }


        //////////////////////////////////////
        /// <summary>
        /// Constructor, random data and title privliges, no Live privilleges.
        /// </summary>
        /// <param name="parentTeam">Team member belongs to</param>
        /// <param name="user">User that is becoming member</param>
        public TeamMember(Team parentTeam, PNState user)
        {
            Team = parentTeam;
            User = user;

            LoadWithRandomInfo();
        }


        //////////////////////////////////////
        /// <summary>
        /// Constructor, random data and specified privliges.
        /// </summary>
        /// <param name="parentTeam">Team member belongs to</param>
        /// <param name="user">User that is becoming member</param>
        /// <param name="privliges">Intial privileges</param>
        public TeamMember(Team parentTeam, PNState user, uint privliges)
        {
            Team = parentTeam;
            User = user;

            LoadWithRandomInfo();
            Privliges = privliges;
        }


        //////////////////////////////////////
        /// <summary>
        /// Constructor, Specifies data and privliges
        /// </summary>
        /// <param name="parentTeam">Team member belongs to</param>
        /// <param name="user">User that is becoming member</param>
        /// <param name="priv">Member privliges</param>
        /// <param name="data">Member data</param>
        public TeamMember(Team parentTeam, PNState user, uint priv, byte[] data)
        {
            Team = parentTeam;
            User = user;
            Privliges = priv;
            Data = data;
        }


        //////////////////////////////////////
        /// <summary>
        /// Get recruit message for member, if memeber is not yet joined
        /// </summary>
        /// <returns>Recruit message sent to this member</returns>
        public UserMessage WaitForRecruitMsg()
        {
            if (Joined)
            {
                System.Diagnostics.Debug.WriteLine(String.Format("Member: {0:x} already joined", UserId));
            }

            UserMsgFolder folder = new UserMsgFolder(User);
            UserMessage recruitMsg =
                folder.WaitForMsgByContext(XonPresNoti.MSG_TYPE_TEAM_RECRUIT, this.Team.Id, 30);

            return recruitMsg;
        }

        //////////////////////////////////////
        /// <summary>
        /// Waits to make sure member does not get a recruit message
        /// </summary>
        public void WaitForNoRecruitMsg()
        {
            UserMsgFolder folder = new UserMsgFolder(User);
            bool timedOut = false;
            try
            {
                folder.WaitForMsgByContext(XonPresNoti.MSG_TYPE_TEAM_RECRUIT, this.Team.Id, 30);
            }
            catch (TimeoutException)
            {
                timedOut = true;
            }

            if (!timedOut)
                throw new Exception("Didn't expect to get a recruit message");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\Team.cs ===
// Team.cs
//
//	Handy container for Team info
//

using System;
using System.Collections;
using System.Threading;
using live.common;

namespace live.protocol.Presence
{
	/// <summary>
	/// Sim object for teams, local storage and handy methods for creation and veriication
	/// </summary>
	public class Team
	{
		// Xenon specific
		public bool 	XenonTeam;

		// Members
		public  uint      MaxMembers;
		private ArrayList members = new ArrayList();
		
		// Creation info
		public uint		TitleId = 0;
		public ulong    Id = 0;
		public bool     Created {get{ return Id != 0; }}
		public DateTime WhenCreated = DateTime.MinValue;
		
		// Managable info 
		public string Name;
		public string Description;
		public string Motto;
		public string Url;
		public byte[] Data;
		
		// Random data generators
		public RandomEx RandGen = new RandomEx();
		public string RandomName
		{
			get{ return RandGen.GeneratePrefixedUnicodeString( "T:", 12, (int)XonPresNoti.MAX_TEAM_NAME_SIZE-1 ); }
		}
		public string RandomDescription
		{
			get{ return RandGen.GenerateUnicodeString( 0, (int)XonPresNoti.MAX_TEAM_DESCRIPTION_SIZE-1 ); }
		}
		public string RandomMotto
		{
			get{ return RandGen.GenerateUnicodeString( 0, (int)XonPresNoti.MAX_TEAM_MOTTO_SIZE-1 ); }
		}
		public string RandomUrl
		{
			get{ return RandGen.GenerateUnicodeString( 0, (int)XonPresNoti.MAX_TEAM_URL_SIZE-1 ); }
		}
		public byte[] RandomData
		{
			get
			{
				int dataSize = RandGen.Next( 0, (int)XonPresNoti.MAX_TEAM_DATA_SIZE+1 );
				byte[] data = new byte[ dataSize ];
				RandGen.NextBytes( data );
				return data;
			}
		}


		/// <summary>
		/// Load team data with valid random stuff.
		/// </summary>
		public void LoadWithRandomInfo()
		{
			MaxMembers = (uint) 
				RandGen.Next( 
				(int)XonPresNoti.MIN_MAX_TEAM_MEMBER_COUNT, 
				(int)XonPresNoti.MAX_TEAM_MEMBER_COUNT+1 );

			Name        = RandomName;
			Description = RandomDescription;
			Motto       = RandomMotto;
			Url         = RandomUrl;
			Data        = RandomData;
		}


		/// <summary>
		/// Constructor, random everything, no members 
		/// </summary>
		/// <param name="creator">User creating team</param>
		public Team()
		{
			LoadWithRandomInfo();
		}

	
		/// <summary>
		/// Simple Constructor, random strings and data, set number for maxmembers, no members
		/// </summary>
		/// <param name="creator">User creating team</param>
		/// <param name="maxMembers">Max number of team members</param>
		public Team( uint maxMembers )
		{
			LoadWithRandomInfo();
			MaxMembers = maxMembers;
		}
		

		/// <summary>
		/// Constructor that allows loading of a team from the server given it's ID
		/// </summary>
		/// <param name="requestor">User making the server requests</param>
		/// <param name="titleId">Title team is in</param>
		/// <param name="teamId">ID of team</param>
		public Team( PNState requestor, uint titleId, ulong teamId )
		{
			ulong[] TeamIds = { teamId };
			PMsgListTeams listMsg = new PMsgListTeams( requestor, titleId, TeamIds );
		
			PNMsg replyMsg;
			live.server.Presence.TransactFD( requestor, listMsg, out replyMsg );
		
			PListTeamsReplyMsgData teamReplyData = (PListTeamsReplyMsgData)(replyMsg.Data);
		
			if( teamReplyData.HR != HResult.S_OK )
				throw new HResultException( teamReplyData.HR, "List Teams HR = 0x"+teamReplyData.HR.ToString("X8") );
		
			LoadTeamInfo( teamReplyData.Teams[0], titleId );

			LoadMembers( requestor );
		}

		/// <summary>
		/// Constructor that allows loading of a team from the server given it's info block and a title Id
		/// </summary>
		/// <param name="user">User making server requests</param>
		/// <param name="titleId">Title team was created in</param>
		/// <param name="teamInfo">TeamInfo block already retrieved from server</param>
		public Team( PNState requestor, uint titleId, TeamInfo teamInfo )
		{
			LoadTeamInfo( teamInfo, titleId );
            
			LoadMembers( requestor );
		}

		/// <summary>
		/// Sets team data with info block from server
		/// </summary>
		/// <param name="teamInfo">TeamInfo block already retrieved from server</param>
		private void LoadTeamInfo( TeamInfo teamInfo, uint titleId )
		{
			Id          = teamInfo.TeamID;
			TitleId     = titleId;
			Name        = teamInfo.TeamName;
			Description = teamInfo.TeamDescription;
			Motto       = teamInfo.TeamMotto;
			Url         = teamInfo.TeamURL;
			Data        = teamInfo.TeamData;
			WhenCreated = teamInfo.Created;
			MaxMembers  = teamInfo.NumMembers;
		}

		/// <summary>
		/// Sets team member data with info retrieved from server
		/// </summary>
		/// <param name="requestor">User making server requests</param>
		private void LoadMembers( PNState requestor )
		{
			PNMsg replyMsg;
			PMsgListTeamMembers listTeamMembersMsg = new PMsgListTeamMembers( requestor, this, true );
            live.server.Presence.TransactFD(requestor, listTeamMembersMsg, out replyMsg);

			PListTeamMembersReplyMsgData membersReplyData = (PListTeamMembersReplyMsgData)replyMsg.Data;

			if( membersReplyData.HR != HResult.S_OK )
				throw new HResultException( membersReplyData.HR, "List Team Members HR = 0x"+membersReplyData.HR.ToString("X8") );

			for( int i = 0; i < membersReplyData.MemberListLen; ++i )
			{
				TeamMemberInfo memberInfo = membersReplyData.MemberList[i];
                PNState user = PNState.FindOrCreate(null, new XblUser(memberInfo.MemberID, memberInfo.MemberName), null);
				TeamMember member = new TeamMember( this, user, memberInfo.MemberPrivliges, memberInfo.MemberData );
				member.WhenJoined = memberInfo.WhenJoined;
				member.Joined     = memberInfo.IsMember;
				AddToMemberList( member );
			}
		}


		/// <summary>
		/// Creates a team with the current data and default creator data for users current title, 
		///  only member is creator
		/// </summary>
		/// <param name="creator">User sending create message</param>
		/// <returns>Team ID</returns>
		public ulong Create( PNState creator )
		{
			TeamMember creatingMember = new TeamMember( this, creator );

			return Create( creator, creatingMember, creator.Xbox.TitleId );
		}

		/// <summary>
		/// Creates a team with the current data and default creator data for the speicifed title,
		///  only member is creator
		/// </summary>
		/// <param name="creator">User sending create message</param>
		/// <param name="titleId">Title team will be created for</param>
		/// <returns>Team ID</returns>
		public ulong Create( PNState creator, uint titleId )
		{
			TeamMember creatingMember = new TeamMember( this, creator );

			return Create( creator, creatingMember, titleId );
		}

		/// <summary>
		/// Creates a team with the current team data and provied creator data for the specified title, 
		///  only member is creator
		/// </summary>
		/// <param name="creator">User sending create message</param>
		/// <param name="creatingMember">Preloaded member based on creator</param>
		/// <param name="titleId">Title team will be created for</param>
		/// <returns>Team ID</returns>
		public ulong Create( PNState creator, TeamMember creatingMember, uint titleId )
		{
			if( Created )
				throw new Exception( "Team already Created" );

			PMsgCreateTeam createMsg = new PMsgCreateTeam( creator, titleId, this, creatingMember );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( creator, createMsg, out replyMsg );
		
			PCreateTeamReplyMsgData replyData = (PCreateTeamReplyMsgData)(replyMsg.Data);
			CheckCreateReply( replyData );
			SetCreated( creatingMember, replyData.WhenCreated, titleId, replyData.TeamID );

			return Id;
		}

		/// <summary>
		/// Checks create message reply
		/// </summary>
		/// <param name="replyData">Contents of create message reply</param>
		public void CheckCreateReply( PCreateTeamReplyMsgData replyData )
		{
			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Create Team HR = 0x"+replyData.HR.ToString("X8") );

			TimeSpan dt = DateTime.UtcNow - replyData.WhenCreated;
			if( Math.Abs( dt.TotalHours ) > 0.05 ) // 3 minutes
				throw new Exception( "Team creation time is wrong. Server says: "+replyData.WhenCreated.ToString() );
			WhenCreated = replyData.WhenCreated;

			if( (replyData.TeamID == 0) || 
				((replyData.TeamID & 0xfefe000000000000) != 0xfefe000000000000) )
				throw new Exception( "Team PUID is invalid: "+replyData.TeamID.ToString("X8") );
		}

		/// <summary>
		/// Completes setup of team following creation to prepare it for validation
		/// </summary>
		/// <param name="creatingMember">Member that created the team</param>
		/// <param name="whenCreated">When team was created</param>
		/// <param name="titleId">Title team is for</param>
		/// <param name="teamId">Id server gave team</param>
		public void SetCreated( TeamMember creatingMember, DateTime whenCreated, uint titleId, ulong teamId )
		{
			Id      = teamId;
			TitleId = titleId;
		
			AddToMemberList( creatingMember );
			creatingMember.Joined     = true;
			creatingMember.WhenJoined = whenCreated;
			creatingMember.Privliges  = 0xffffffff;  // all Privileges
		}

		/// <summary>
		/// Deletes Team, specified user does it
		/// </summary>
		public void Delete( PNState reaper ) 
		{
			PMsgDeleteTeam deleteMsg = new PMsgDeleteTeam( reaper, this );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( reaper, deleteMsg, out replyMsg );

			PDeleteTeamReplyMsgData replyData = (PDeleteTeamReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Delete Team HR = 0x"+replyData.HR.ToString("X8"));

			ClearMemberList();
			Id = 0;
		}


		/// <summary>
		/// Changes a team's name, description, motto, url, and data blob
		/// </summary>
		/// <param name="user">User doing change</param>
		/// <param name="name">New name</param>
		/// <param name="desc">New Description</param>
		/// <param name="motto">New Motto</param>
		/// <param name="url">New Url</param>
		/// <param name="data">New Data blob</param>
		public void ManageTeam( PNState user, string name, string desc, string motto, string url, byte[] data )
		{
			PMsgManageTeam manageMsg = new PMsgManageTeam( user, this, name, desc, motto, url, data );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, manageMsg, out replyMsg );

			PManageTeamReplyMsgData replyData = (PManageTeamReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Manage Team HR = 0x"+replyData.HR.ToString("X8") );

			Name        = name;
			Description = desc;
			Motto       = motto;
			Url         = url;
			Data        = data;
		}
		
		public void ManageTeamXe( PNState user, string name, string desc, string motto, string url, byte[] data )
		{
			PMsgManageTeamXe manageMsg = new PMsgManageTeamXe( user, this, name, desc, motto, url, data );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, manageMsg, out replyMsg );

			PManageTeamReplyMsgData replyData = (PManageTeamReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Manage Team HR = 0x"+replyData.HR.ToString("X8") );

			Name        = name;
			Description = desc;
			Motto       = motto;
			Url         = url;
			Data        = data;
		}


		/// <summary>
		/// Changes a team's name
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="name">New name</param>
		public void ChangeTeamName( PNState user, string name )
		{
			ManageTeam( user, name, Description, Motto, Url, Data );
		}

	
		/// <summary>
		/// Changes a team's description
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="desc">New Description</param>
		public void ChangeTeamDescription( PNState user, string desc )
		{
			ManageTeam( user, Name, desc, Motto, Url, Data );
		}


		/// <summary>
		/// Changes a team's motto
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="motto">New Motto</param>
		public void ChangeTeamMotto( PNState user, string motto)
		{
			ManageTeam( user, Name, Description, motto, Url, Data );
		}

	
		/// <summary>
		/// Changes a team's url
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="url">New Url</param>
		public void ChangeTeamUrl( PNState user, string url )
		{
			ManageTeam( user, Name, Description, Motto, url, Data );
		}


		/// <summary>
		/// Changes a team's data blob
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="data">New Data blob</param>
		public void ChangeTeamDataBlob( PNState user, byte[] data )
		{
			ManageTeam( user, Name, Description, Motto, Url, data );
		}

        /*
		/// <summary>
		/// Simple method to add a user to a team with random data
		/// </summary>
		/// <param name="recruitor">Current team member</param>
		/// <param name="recruitee">New team member</param>
		public TeamMember AddMember( PNState recruitor, PNState recruitee )
		{
			TeamMember recruit = new TeamMember( this, recruitee );
			return AddMember(recruitor, recruit);
		}

		/// <summary>
		/// Simple method to add a user to a team with specific privliges and random data
		/// </summary>
		/// <param name="recruitor">Current team member</param>
		/// <param name="recruitee">New team member</param>
		/// <param name="privliges">Privliges new member could have</param>
		public TeamMember AddMember( PNState recruitor, PNState recruitee, uint privliges )
		{
			TeamMember recruit = new TeamMember( this, recruitee, privliges );
			return AddMember(recruitor, recruit);
		}

		/// <summary>
		/// Add a new member send and acknoledge a recruit message
		/// </summary>
		/// <param name="recruitor">Current team member</param>
		/// <param name="recruitee">New team member</param>
		/// <param name="privliges">Privliges new member could have</param>
		public TeamMember AddMember( PNState recruitor, TeamMember recruit)
		{
			UserMessage msg = UserMessage.CreateTeamRecruitMsg(recruitor, Id);

			// Send and track the recruit
			Recruit( recruitor, recruit, msg );

			// Wait for message on recruitee and process it
			QValPacket qval = recruit.User.WaitForNewMessageType(XonPresNoti.MSG_TYPE_TEAM_RECRUIT);
			recruit.User.HandleQValPacket(qval, PNState.HQV_ReadMessages);

			PNState.MessageInfo[] rgMsgInfo = recruit.User.GetMessageInfoTypeFrom(recruitor, XonPresNoti.MSG_TYPE_TEAM_RECRUIT);
			foreach(PNState.MessageInfo msgInfo in rgMsgInfo)
			{
				if(Id == msgInfo.Message.Context)
				{
					System.Diagnostics.Debug.WriteLine(String.Format("Team.AddMember(): {0:x} received the team recruit message from {1:x}, MsgID: {2:x}, TeamID: {3:x}.. joining",
							recruit.UserId,
							recruitor.UserId,
							msgInfo.Message.ID,
							msgInfo.Message.Context));

					// Send the join response
					Join( recruit.User, msgInfo.Message, JoinResponse.Yes );
				}
			}

			return recruit;
		}
		*/
		/// <summary>
		/// Send Xbox 1 Recruit message and adds recruit to local member list
		/// </summary>
		/// <param name="user">User making offer to join</param>
		/// <param name="recruit">Potential team member</param>
		/// <param name="msg">Message sent to annouce invitaion</param>
		public void Recruit( PNState user, TeamMember recruit, UserMessage msg )
		{
			PMsgRecruitTeamMember recruitMsg = new PMsgRecruitTeamMember( user, this, recruit, msg );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, recruitMsg, out replyMsg );

			PRecruitTeamMemberReplyMsgData replyData = (PRecruitTeamMemberReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
			{
				throw new HResultException( replyData.HR, "Recruit failed user: " + 
						user.UserId.ToString("x") + ", recruit: " + 
						recruit.UserId.ToString("x"));
			}

			AddToMemberList( recruit );
		}

		/// <summary>
		/// Send Xenon Recruit message and adds recruit to local member list
		/// </summary>
		/// <param name="user">User making offer to join</param>
		/// <param name="recruit">Potential team member</param>
		/// <param name="msg">Message sent to annouce invitaion</param>
		public void Recruit( PNState user, TeamMember recruit )
		{
			PMsgRecruitTeamMember recruitMsg = new PMsgRecruitTeamMember( user, this, recruit );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, recruitMsg, out replyMsg );

			PRecruitTeamMemberReplyMsgData replyData = (PRecruitTeamMemberReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
			{
				throw new HResultException( replyData.HR, "Recruit failed user: " + 
						user.UserId.ToString("x") + ", recruit: " + 
						recruit.UserId.ToString("x"));
			}

			AddToMemberList( recruit );
		}
		/// <summary>
		/// Posible answers when joining, Never adds sender to never list.
		/// </summary>
		public enum JoinResponse { Yes, No, Never };

		/// <summary>
		/// Xbox 1 style respond to invitaion to join team from a message
		/// </summary>
		/// <param name="recruit">User being recruited, must arlready be in local member list</param>
		/// <param name="recruitMsg">Recruit message responding user recieved</param>
		/// <param name="joining">Response (yes, no, never)</param>
		public void Join( PNState recruit, UserMessage recruitMsg, JoinResponse joining )
		{
			TeamMember member = FindMemberInList( recruit.UserId );
			if( member == null )
			{
				System.Diagnostics.Debug.WriteLine( "Join not allowed on users who aren't already member list. Use Recruit() or AddMember()" );
			}
				
			PMsgJoinTeam joinMsg = new PMsgJoinTeam( recruit, this, joining, recruitMsg );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( recruit, joinMsg, out replyMsg );

			PJoinTeamReplyMsgData replyData = (PJoinTeamReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
			{
				throw new HResultException( replyData.HR, 
						"Join failed for Team: " + Id.ToString("x") + 
						", User: " + recruit.UserId.ToString("x") );
			}

			if( joining == JoinResponse.Yes )
			{
				member.Joined = true;
				member.WhenJoined = DateTime.UtcNow;
			}
			else if(false == member.Joined)
			{
                // Emulate server behavior, when you're already joined and you send a No response
                // it makes sure you're not already a member first
				RemoveFromMemberList( member.UserId );
			}
		}

		/// <summary>
		/// Xenon style respond to invitaion to join team from a message (message-less)
		/// </summary>
		/// <param name="recruit">User being recruited, must arlready be in local member list</param>
		/// <param name="joining">Response (yes, no, never)</param>
		public void Join( PNState recruit, JoinResponse joining )
		{
			TeamMember member = FindMemberInList( recruit.UserId );
			if( member == null )
			{
				throw new Exception( "Join not allowed on users who aren't already member list. Use Recruit() or AddMember()" );
			}
				
			PMsgJoinTeam joinMsg = new PMsgJoinTeam( recruit, this, joining );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( recruit, joinMsg, out replyMsg );

			PJoinTeamReplyMsgData replyData = (PJoinTeamReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
			{
				throw new HResultException( replyData.HR, 
						"Join failed for Team: " + Id.ToString("x") + 
						", User: " + recruit.UserId.ToString("x") );
			}

			if( joining == JoinResponse.Yes )
			{
				member.Joined = true;
				member.WhenJoined = DateTime.UtcNow;
			}
			else
			{
				RemoveFromMemberList( member.UserId );
			}
		}
		
		/// <summary>
		/// Removal of member from team
		/// </summary>
		/// <param name="user">User doing the deed</param>
		/// <param name="outcast">Team Member getting removed</param>
		public void Remove( PNState user, TeamMember outcast )
		{
			DoRemoveMsg( user, outcast );
			RemoveFromMemberList( outcast.UserId );
		}

		/// <summary>
		/// Remove all members from the team.
		/// </summary>
		/// <param name="user">User doing the deed</param>
		public void RemoveAllMembers( PNState user )
		{
			foreach( TeamMember outcast in members )
			{
				DoRemoveMsg( user, outcast );
			}

			ClearMemberList();
		}


		/// <summary>
		/// Sends message to server to remove a team member
		/// </summary>
		/// <param name="user">User doing the deed</param>
		/// <param name="outcast">Team Member getting removed</param>
		private void DoRemoveMsg( PNState user, TeamMember outcast )
		{
			PMsgRemoveTeamMember removeMsg = new PMsgRemoveTeamMember( user, this, outcast );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, removeMsg, out replyMsg );

			PRemoveTeamMemberReplyMsgData replyData = (PRemoveTeamMemberReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Remove Team Member HR = 0x"+replyData.HR.ToString("X8"));
		}


		/// <summary>
		/// Change a team members privliges and data blob.
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="member">Member being changed</param>
		/// <param name="privliges">New privlige flags</param>
		/// <param name="data">New data blob</param>
		public void ManageMember( PNState user, TeamMember member, uint privliges, byte[] data )
		{
			PMsgManageTeamMember manageMemberMsg 
				= new PMsgManageTeamMember( user, this, member, privliges, data );
			PNMsg replyMsg;
			live.server.Presence.TransactFD( user, manageMemberMsg, out replyMsg );

			PManageTeamMemberReplyMsgData replyData = (PManageTeamMemberReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Manage Team Member HR = 0x"+replyData.HR.ToString("X8") );

			member.Privliges = privliges;
			member.Data      = data;
		}

	
		/// <summary>
		/// Change a team members privliges.
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="member">Member being changed</param>
		/// <param name="privliges">New privlige flags</param>
		public void ChangeMemberPrivliges( PNState user, TeamMember member, uint privliges )
		{
			ManageMember( user, member, privliges, member.Data );
		}


		/// <summary>
		/// Change a team members data blob.
		/// </summary>
		/// <param name="user">Member doing change</param>
		/// <param name="member">Member being changed</param>
		/// <param name="data">New data blob</param>
		public void ChangeMemberDataBlob( PNState user, TeamMember member, byte[] data )
		{
			ManageMember( user, member, member.Privliges, data );
		}
	
		/// <summary>
		/// Get a count of the number of members loaded in this team object.
		/// </summary>
		/// <returns>Count of members loaded into team object</returns>
		public int MemberListCount()
		{
			return members.Count;
		}


		/// <summary>
		/// Get a count of the number of joined members loaded in this team object.
		/// </summary>
		/// <returns>Count of members loaded into team object that have joined</returns>
		public int MemberListJoinedCount()
		{
			int count = 0;
			for( int i = 0; i < members.Count; ++i )
			{
				TeamMember member = (TeamMember) members[i];
				if( member.Joined )
				{
					++count;
				}
			}
			return count;
		}


		/// <summary>
		/// Get local member list
		/// </summary>
		/// <returns>List of local member state objects</returns>
		public TeamMember[] GetMemberList()
		{
			return (TeamMember[])( members.ToArray( typeof( TeamMember ) ) );
		}


		/// <summary>
		/// Add a new user to team's local member list
		/// </summary>
		/// <param name="user">User that will become a member</param>
		private void AddToMemberList( TeamMember newMember )
		{
			if( null == FindMemberInList( newMember.UserId ))
            {
			    members.Add( newMember );
            }
		}

		
		/// <summary>
		/// Removes an item from the team's local member list
		/// </summary>
		/// <param name="user">User Puid that will be removed from internal list</param>
		public void RemoveFromMemberList( ulong userId )
		{
			bool memberRemoved = false;
			for( int i = 0; i < members.Count; ++i )
			{
				TeamMember member = (TeamMember) members[i];
				if( member.UserId == userId )
				{
					members.RemoveAt( i );
					memberRemoved = true;
					break;
				}
			}

			if( ! memberRemoved )
				throw new Exception( "Removing a team member that wasn't in member list" );
		}


		/// <summary>
		/// Removes all items from team's local member list 
		/// </summary>
		private void ClearMemberList() 
		{
			members.Clear();
		}


		/// <summary>
		/// Finds a item in the team's local member list
		/// </summary>
		/// <param name="memberId">User Id of member</param>
		/// <returns>Member object, null if not found</returns>
		public TeamMember FindMemberInList( ulong memberId )
		{
			for( int i = 0; i < members.Count; ++i )
			{
				TeamMember member = (TeamMember) members[i];
				if( member.UserId == memberId )
				{
					return member;
				}
			}
			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\TeamTicket.cs ===
// TeamTicket.cs
//
//	Wire Data for team tickets
//

using System;
using System.IO;
using System.Security.Cryptography;

using live.common;

namespace live.protocol.Presence
{

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Collection of team tickets
	/// </summary>
    /// 
	public class TeamTickets : WireData
	{
        public ushort wType; // == TEAM_TICKETS_TYPE
        public ushort wLength; // number of bytes following this ushort
        public ushort cTickets; // maximum of MAXIMUM_TEAM_TICKETS

        [WireInfo(SizeParam = "cTickets")]
        public TeamTicket[] teamTickets;

		public TeamTicketsHdr  hdr  = new TeamTicketsHdr();
		public TeamTicketsList list = new TeamTicketsList();

		public override void WriteStream( BinaryWriter writer )
		{
			// Write list to intermediate stream
			MemoryStream listStream = new MemoryStream();
			list.WriteStream( listStream );

			// Set Msg Data length
			hdr.wLength = (ushort)listStream.Length;
			
			// Write header and list
			hdr.WriteStream( writer );
			writer.Write( listStream.ToArray());
		}

        public TeamTickets()
        {
        }

        public TeamTickets(BinaryReader reader)
        {
            ReadStream(reader);
        }

		[WireInfo(Serialize=false)]
		public const ushort TEAM_TICKETS_TYPE = 0x0001;

		[WireInfo(Serialize=false)]
		public const uint MAXIMUM_TEAM_TICKETS = 1024;

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int actualLength = 2;


            try
            {
                wType = binaryReader.ReadUInt16();
            }
            catch (EndOfStreamException)
            {
                //We need to throw a peekcharendofstreamexception instead of a plain endofstream exception
                //This is to accurately tell the same thing as what peekchar would have told us
                //that is there were no more data in the stream
                throw new PeekCharEndOfStreamException();
            }


            if (wType != TEAM_TICKETS_TYPE)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, /*XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_4,*/ "Team Tickets type expected. Received: " + wType.ToString("X"));
            }
            wLength = binaryReader.ReadUInt16();
            cTickets = binaryReader.ReadUInt16();
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, /*XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_5,*/ "Team Tickets contains too many tickets: " + cTickets);
            }
            teamTickets = new TeamTicket[cTickets];
            for (int i = 0; i < cTickets; ++i)
            {
                teamTickets[i] = new TeamTicket(binaryReader);
                actualLength += teamTickets[i].Size();
            }
            if (actualLength != wLength)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, /*XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_6,*/ "Team Tickets length inconsistent. Stated:" + wLength + " Actual:" + actualLength);
            }

            return this;
        }

	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// The header part of TeamTickets
	/// </summary>
	public class TeamTicketsHdr : WireData
	{
		public ushort wType = TeamTickets.TEAM_TICKETS_TYPE;
		public ushort wLength; // of ticket list 
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// The ticket list part of TeamTickets
	/// </summary>
	public class TeamTicketsList : WireData
	{
		public ushort       ticketsLen; // maximum of MAXIMUM_TEAM_TICKETS
		public TeamTicket[] tickets;
	}

	////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// A single team ticket
	/// </summary>
	public class TeamTicket : WireData
	{
        public short   cTeams;
        public ulong   userID;
		public short   teamIDsLen;
		public short   signatureLen;
		public ulong[] teamIDs;
		public byte[]  signature;

		[WireInfo(Serialize=false)]
		public const int TEAM_TICKET_SIGNATURE_LENGTH = 8;

		[WireInfo(Serialize=false)]
		public const uint MAXIMUM_TEAMS_PER_TICKET = 8;

        public TeamTicket()
        {
        }

        public TeamTicket(BinaryReader reader)
        {
            base.ReadStream(reader);
            if (cTeams > MAXIMUM_TEAMS_PER_TICKET)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, /*XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS,*/ "TeamTicket contains too many teams: " + cTeams);
            }
        }


		public bool Populate(ulong userID, ulong teamID, byte[] key)
		{
			return Populate(userID, new ulong[]{teamID}, key);
		}

		public bool Populate(ulong userID, ulong[] teamIDs, byte[]key)
		{
			this.userID=userID;
			this.teamIDs=new ulong[teamIDs.GetLength(0)];
			Array.Copy(teamIDs,this.teamIDs,teamIDs.GetLength(0));
			if (false==ComputeSignature(key))
			{
				return false;
			}
			return true;
		}
	
		// 
		// Methods for creating and validating a ticket given SGInfo
		// 
		public bool ComputeSignature(byte[] key)
		{
			// validate params
			if ((key.GetLength(0)!=16)||(null==teamIDs))
			{
				return false;
			}		

			// create the team ticket
			MemoryStream m = new MemoryStream(100);
			BinaryWriter w = new BinaryWriter(m);
			w.Write(userID);
			w.Write((short)teamIDs.Length);
			w.Write((short)TEAM_TICKET_SIGNATURE_LENGTH);
			foreach(ulong t in teamIDs)
			{
				w.Write(t);
			}
			byte[] teamTicket = m.ToArray();

			// create the signature of the team ticet using the 16 byte key (should ride along with SGInfo)
			HMACSHA1 hmacsha1 = new HMACSHA1(key);
			byte[] fullSignature = hmacsha1.ComputeHash(teamTicket);

			// copy the full signature to the local signature truncating if neccessary
			signature = new byte[TEAM_TICKET_SIGNATURE_LENGTH];
			Array.Copy(fullSignature,signature,TEAM_TICKET_SIGNATURE_LENGTH);

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\UserTeams.cs ===
// UserTeams.cs
//
//	Handy container for a user's Team info across titles
//

using System;
using System.Collections;
using live.common;


namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Table of a user's teams, listed by title
    /// </summary>
    public class UserTeams
    {
        public PNState User;
        private Hashtable titles = new Hashtable();

        //////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="user">User that is the member of the teams</param>
        public UserTeams(PNState user)
        {
            User = user;
        }


        //////////////////////////////////////
        /// <summary>
        /// Add a team to the list for the specified title
        /// </summary>
        /// <param name="titleId">Title team exists in</param>
        /// <param name="team">Team User is member of</param>
        public void Add(Team team)
        {
            if (team.Id == 0)
                throw new ArgumentException("UserTeams: Can't add Team Id 0, only valid created teams allowed");

            if (!titles.Contains(team.TitleId))
            {
                titles[team.TitleId] = new Hashtable((int)XonPresNoti.MAX_TEAM_COUNT);
            }
            Hashtable teams = (Hashtable)titles[team.TitleId];

            if (teams.Contains(team.Id))
                throw new ArgumentException("UserTeams: Can't add Team Id " + team.Id + ", it's already listed");

            teams[team.Id] = team;
        }

        //////////////////////////////////////
        /// <summary>
        /// Gets a team out
        /// </summary>
        /// <param name="teamId">Id of team</param>
        /// <param name="titleId">Title Id of team</param>
        /// <returns>Team object</returns>
        public Team Get(ulong teamId, uint titleId)
        {
            Team team = null;
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];
                if (teams.Contains(teamId))
                {
                    team = (Team)teams[teamId];
                }
            }
            return team;
        }

        //////////////////////////////////////
        /// <summary>
        /// Removes a team from the list for the specified title
        /// </summary>
        /// <param name="titleId">Title team exists in</param>
        /// <param name="teamId">Id of team user has left</param>
        public void Remove(uint titleId, ulong teamId)
        {
            if (!titles.Contains(titleId))
                throw new Exception("UserTeams: Can't remove team.  There aren't any for Title ID: " + teamId.ToString("X16"));

            Hashtable teams = (Hashtable)titles[titleId];
            if (!teams.Contains(teamId))
                throw new Exception("UserTeams: Can't remove team Id " + teamId + ", it's not in list");

            teams.Remove(teamId);
            if (teams.Count == 0)
            {
                titles.Remove(titleId);
            }
        }


        //////////////////////////////////////
        /// <summary>
        /// Removes all teams from the list for the specified title
        /// </summary>
        /// <param name="titleId">Title teams exists in</param>
        public void Clear(uint titleId)
        {
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];
                teams.Clear();
                titles.Remove(titleId);
            }
        }


        //////////////////////////////////////
        /// <summary>
        /// Removes all teams from all titles
        /// </summary>
        public void Clear()
        {
            foreach (uint titleId in titles.Keys)
            {
                Hashtable teams = (Hashtable)titles[titleId];
                teams.Clear();
            }
            titles.Clear();
        }


        //////////////////////////////////////
        /// <summary>
        /// Get the count of teams for the specified title
        /// </summary>
        /// <param name="titleId">Title teams exist in</param>
        /// <returns>number of teams for this title</returns>
        public uint Count(uint titleId)
        {
            uint count = 0;
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];
                count = (uint)teams.Count;
            }
            return count;
        }


        //////////////////////////////////////
        /// <summary>
        /// Get's the first team for the user's current title
        /// </summary>
        /// <returns>One of the users teams (whichever the enurator thinks is first</returns>
        public Team GetFirstTeam()
        {
            uint titleId = User.Xbox.TitleId;
            Team team = null;
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];

                IDictionaryEnumerator teamEnumerator = teams.GetEnumerator();
                teamEnumerator.MoveNext();
                team = (Team)teamEnumerator.Value;
            }
            return team;
        }


        //////////////////////////////////////
        /// <summary>
        /// Gets the list of teams for a specified title
        /// </summary>
        /// <param name="titleId">Title teams exist in</param>
        /// <returns>Array of Teams</returns>
        public Team[] GetTeams(uint titleId, bool bIncludeRecruits)
        {
            ArrayList teamList = new ArrayList((int)XonPresNoti.MAX_TEAM_COUNT);
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];
                foreach (ulong teamId in teams.Keys)
                {
                    TeamMember member = ((Team)teams[teamId]).FindMemberInList(User.UserId);
                    if ((member != null) &&
                        (bIncludeRecruits || (member.Joined)))
                    {
                        teamList.Add(teams[teamId]);
                    }
                }
            }
            return (Team[])teamList.ToArray(typeof(Team));
        }


        //////////////////////////////////////
        /// <summary>
        /// Gets the list of team IDs for a specified title
        /// </summary>
        /// <param name="titleId">Title teams exist in</param>
        /// <returns>Array of Team IDs</returns>
        public ulong[] GetTeamIds(uint titleId, bool bIncludeRecruits)
        {
            ArrayList teamList = new ArrayList((int)XonPresNoti.MAX_TEAM_COUNT);
            if (titles.Contains(titleId))
            {
                Hashtable teams = (Hashtable)titles[titleId];
                foreach (ulong teamId in teams.Keys)
                {
                    TeamMember member = ((Team)teams[teamId]).FindMemberInList(User.UserId);
                    if ((member != null) &&
                        (bIncludeRecruits || (member.Joined)))
                    {
                        teamList.Add(teamId);
                    }
                }
            }

            return (ulong[])teamList.ToArray(typeof(ulong));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\UserMessage.cs ===
// UserMessage.cs
//
//  User Message storage and mainipulation
//

using System;
using live.common;

namespace live.protocol.Presence
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Messaging protocol time is a shortened offset from 1/1/2003
    /// </summary>
    public class MsgTime : WireData
    {
        public uint time;

        // 1/1/2003 - used for conversion between FILETIME and MSGTIME
        public const ulong FT_MSGTIME_BEGIN = 0x01C2B128BA2B4000;

        public DateTime dt
        {
            set { time = (uint)(((ulong)(value.ToFileTimeUtc()) - FT_MSGTIME_BEGIN) / 10000000); }
            get { return DateTime.FromFileTimeUtc((long)(((ulong)(time) * 10000000) + FT_MSGTIME_BEGIN)); }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message summary data
    /// </summary>
    public class UserMsgSummary : WireData
    {
        public ulong SenderID;
        public ulong SenderContext;
        public MsgTime SentTime;
        public uint MessageID;
        public uint MessageFlags;
        public uint SenderTitleID;
        public ushort ExpireMinutes; // An offset in minutes from the sent time
        public ushort cbDetails;
        public byte MessageType;
        [WireInfo(ArraySize = 15)] // XONLINE_GAMERTAG_SIZE-1      
        public string SenderName;
    }

    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Message summary data
    /// </summary>
    public class UserMsgSummary2 : WireData
    {
        public ulong SenderID;
        public ulong SenderContext;
        public MsgTime SentTime;
        public uint MessageID;
        public uint MessageFlags;
        public uint SenderTitleID;
        public ushort ExpireMinutes; // An offset in minutes from the sent time
        public ushort cbDetails;
        public byte MessageType;
        [WireInfo(ArraySize = 15)] // XONLINE_GAMERTAG_SIZE-1      
        public string SenderName;
        //[WireInfo(UnicodeEncoded=true,NullTerminate=false,ArraySize=20)] // XONLINE_MAX_SUBJECT_SIZE
        [WireInfo(NullTerminate = false, ArraySize = 40)] // XONLINE_MAX_SUBJECT_SIZE * 2 bytes
        public string Subject;
    }

    public class UserMessage : Message
    {
        // Message data unique to user messages
        public ulong             SenderID;
        public string            Subject;

        // Default constructor only used by static factory methods
        private UserMessage() {}

        /// <summary>
        /// Create and load a new message for recpient with message ID
        /// </summary>
        /// <returns>New message object with details and summary or exception</return>
        public static UserMessage CreateAndLoad(PNState recipient, uint inID)
        {
            return CreateAndLoad(recipient, inID, 0, 0);
        }

        /// <summary>
        /// Create and load a new message for recpient with message ID, set flags and 
        /// unsetflags are passed to details request.
        /// </summary>
        /// <returns>New message object with details and summary or exception</return>
        public static UserMessage CreateAndLoad(PNState recipient, uint inID, uint setFlags, uint unsetFlags)
        {
            UserMessage msg = new UserMessage();

            uint hr = msg.GetDetails(recipient, inID, setFlags, unsetFlags);
            if(!HResult.Succeeded(hr))
            {
                throw new HResultException(hr, "CreateAndLoad(): Failed to load message details");
            }

            return msg;
        }

        /// <summary>
        /// Creates a blank User message 
        /// </summary>
        /// <returns>Blank user message ready to be loaded for sending</returns>
        public static UserMessage CreateBlank()
        {
            UserMessage msg = new UserMessage();
            msg.Details = MsgDetails.CreateBlank();
            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xbox 1 user message with details
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="type">Message Type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <param name="details">Collection of message properties</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNState     sender,
            byte       type,
            ulong      context,
            uint       flags,
            ushort     expireMinutes,
            MsgDetails details )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;

            // Live  messages are sent as xbox 1 dash
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0xfffe0000; 
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = details;

            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xbox 1 user message without details 
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="type">Message Type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNState sender,
            byte   type,
            ulong  context,
            uint   flags,
            ushort expireMinutes )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = MsgDetails.CreateBlank();

            return msg;
        }

        /// <summary>
        /// Fully parametarized creation of xenon user message with details 
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="subject">Subject from message summary</param>
        /// <param name="type">Message type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <param name="details">Collection of message properties</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNState     sender,
            string     subject,
            byte       type,
            ulong      context,
            uint       flags,
            ushort     expireMinutes,
            MsgDetails details)
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Subject       = subject;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = details;

            return msg;
        }
    
        /// <summary>
        /// Fully parametarized creation of xenon user message without details 
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="subject">Subject from message summary</param>
        /// <param name="type">Message type</param>
        /// <param name="context">Message specific context</param>
        /// <param name="flags">Message flags</param>
        /// <param name="expireMinutes">Minutes until message expires</param>
        /// <returns>A user message loaded and ready for sending</returns>
        public static UserMessage Create(
            PNState sender,
            string subject,
            byte   type,
            ulong  context,
            uint   flags,
            ushort expireMinutes )
        {
            UserMessage msg = new UserMessage();

            msg.SenderID      = sender.UserId;
            msg.SenderName    = sender.Name;
            msg.TitleID       = (null != sender.Xbox) ? sender.Xbox.TitleId : 0;
            msg.Subject       = subject;
            msg.Context       = context;
            msg.Flags         = flags;
            msg.ExpireMinutes = expireMinutes;
            msg.Type          = type;
            msg.Details       = MsgDetails.CreateBlank();

            return msg;
        }

        /// <summary>
        /// Creation of basic custom message type
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <returns>Most basic custom message</returns>
        public static UserMessage CreateTitleCustomMsg( PNState sender )
        {
            return Create( sender, XonPresNoti.MSG_TYPE_TITLE_CUSTOM, 0, 0, 0 );
        }

        /// <summary>
        /// Creation of basic friends request message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <returns>Most basic friend request message</returns>
        public static UserMessage CreateFriendsRequestMsg( PNState sender )
        {
            UserMessage msg = Create( sender, XonPresNoti.MSG_TYPE_FRIEND_REQUEST, 0, 0, 0 );
            return msg;
        }

        /// <summary>
        /// Creation of basic team recruit message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="teamId">Id of team being recruited into</param>
        /// <returns>Most basic team recruit message</returns>
        public static UserMessage CreateTeamRecruitMsg( PNState sender, ulong teamId )
        {
            return Create( sender, XonPresNoti.MSG_TYPE_TEAM_RECRUIT, teamId, XonPresNoti.MSG_FLAG_TEAM_CONTEXT, 0);
        }

        /// <summary>
        /// Creation of a service originated comp reminder, see comps\query\elimination.cs
        /// </summary>
        public static UserMessage CreateCompReminderMsg( 
                ulong entityId,  // Round that entry should join
                string compName, 
                ushort round,
                DateTime roundStart,
                uint titleId,
                ushort expireMin)
        {
            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_NAME, compName);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_START, roundStart);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_ROUND, round);
            
            UserMessage msg = Create( 
                    PNState.Service,
                    XonPresNoti.MSG_TYPE_COMP_REMINDER, 
                    entityId,                           // sender context
                    XonPresNoti.MSG_FLAG_COMP_CONTEXT,  
                    expireMin,
                    details); 
            msg.TitleID = titleId;

            return msg;
        }

        /// <summary>
        /// Creation of a user originated competition join request to another user he would
        /// like to join the competition.
        /// </summary>
        public static UserMessage CreateCompRequestMsg(
                PNState sender, 
                ulong compEntityId,
                string compName,
                DateTime compStart,
                DateTime compRegClose,
                uint titleId,
                ushort expireMin)
        {
            return CreateCompRequestMsg(sender, compEntityId, compName, compStart, compRegClose, titleId, 0, expireMin, MsgDetails.CreateBlank());
        }

        public static UserMessage CreateCompRequestMsg(
                PNState sender,
                ulong compEntityId,
                string compName,
                DateTime compStart,
                DateTime compRegClose,
                uint titleId,
                uint flags,
                ushort expireMin,
                MsgDetails details)
        {
            UserMessage msg = Create(
                    sender,
                    XonPresNoti.MSG_TYPE_COMP_REQUEST,
                    compEntityId,
                    flags,
                    expireMin,
                    details);
            msg.TitleID = titleId;
            
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_NAME, compName);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_START, compStart);
            details.AddProperty(XonPresNoti.MSG_PROP_COMP_REG_CLOSE, compRegClose);
            msg.Flags |= XonPresNoti.MSG_FLAG_COMP_CONTEXT;

            return msg;
        }

        /// <summary>
        /// Creation of basic game invite message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="sessionId">Id of session being invited to</param>
        /// <returns>Most basic game invite message</returns>
        public static UserMessage CreateGameInviteMsg( PNState sender, ulong sessionId )
        {
            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty( XonPresNoti.MSG_PROP_SESSION_ID, sessionId );
            
            return Create( sender, XonPresNoti.MSG_TYPE_GAME_INVITE, 0, 0, 0, details );
        }

        /// <summary>
        /// Creation of basic game invite message
        /// </summary>
        /// <param name="sender">User sending the message</param>
        /// <param name="sessionId">Id of session being invited to</param>
        /// <returns>Most basic game invite message</returns>
        public static UserMessage CreatePersonalMessage( PNState sender, string text )
        {
            UserMessage msg = Create( sender, XonPresNoti.MSG_TYPE_PERSONAL_MESSAGE, 0, 0, 0, null );
            UserMessage.AttachText(msg, text);
            return msg;
        }

        /// <summary>
        /// Attach a basic string text summary to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        /// <param name="strData">String to attach as a text property</param>
        public static void AttachText(UserMessage msg, string strData)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add text summary 
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT, strData);
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT_LANGUAGE, (int)1);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_TEXT;
        }

        /// <summary>
        /// Deprecated, call specific voice attachment function per platform
        /// </summary>
        public static void AttachVoice(UserMessage msg)
        {
            AttachXboxVoice(msg);
        }

        /// <summary>
        /// Attach a generic xbox 1 fake voice attachment to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        public static void AttachXboxVoice(UserMessage msg)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add voice
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA, 10*1024, 0/*flags*/, "http://xonline.msgbuilder/attachment.wav");
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_CODEC, (ushort)2);
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_DURATION, (int)200);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_VOICE;
        }

        /// <summary>
        /// Attach a generic fake voice attachment to a message
        /// </summary>
        /// <param name="msg">Message to attach details</param>
        public static void AttachXenonVoice(UserMessage msg)
        {
            MsgDetails details = msg.Details;
            if(null == details)
            {
                details = msg.Details = MsgDetails.CreateBlank();
            }
            // Add voice
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA, 10*1024, 0/*flags*/, "http://xonline.msgbuilder/attachment.wav");
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_CODEC, (ushort)2);
            details.AddProperty(XonPresNoti.MSG_PROP_VOICE_DATA_DURATION, (int)200);
            msg.Flags |= XonPresNoti.MSG_FLAG_HAS_VOICE;
        }

        /// <summary>
        /// Constuct with received xbox 1 message summary
        /// </summary>
        /// <param name="summary">Message summary wire data</param>
        public UserMessage( UserMsgSummary summary )
        {
            SenderID      = summary.SenderID;
            Context       = summary.SenderContext;
            SentTime      = summary.SentTime.dt;
            ID            = summary.MessageID;
            Flags         = summary.MessageFlags;
            TitleID       = summary.SenderTitleID;
            ExpireMinutes = summary.ExpireMinutes;
            Type          = summary.MessageType;
            SenderName    = summary.SenderName;
        }

        /// <summary>
        /// Constuct with received xenon message summary 
        /// </summary>
        /// <param name="summary">Message summary wire data</param>
        public UserMessage( UserMsgSummary2 summary2 )
        {
            PopulateMetadata(summary2);
            
        }

        public uint GetSummary( PNState recipient, uint msgId )
        {
            uint hr = HResult.S_OK;

            //
            // Retreive the message summary
            //
            PNMsg replyMsg;
            QMsgSummary summaryMsg = new QMsgSummary( recipient, msgId );
            live.server.Presence.TransactFD( recipient, summaryMsg, out replyMsg );

            QSummaryReplyMsgData summaryReplyData = (QSummaryReplyMsgData)replyMsg.Data;
            hr = summaryReplyData.HR;

            if(!HResult.Succeeded(hr))
            {
                System.Diagnostics.Debug.WriteLine(String.Format("GetSummary2(): failed for User: {0:x}, MsgID: {1}, HR = {2:x8}",
                        recipient.UserId,
                        msgId,
                        hr)); 
            }
            else 
            {
                PopulateMetadata(summaryReplyData.Summary);
            }

            return hr;
        }

        public uint GetSummary2( PNState recipient, uint msgId )
        {
            uint hr = HResult.S_OK;

            //
            // Retreive the message summary
            //
            PNMsg replyMsg;
            QMsgSummary2 summaryMsg = new QMsgSummary2( recipient, msgId );
            live.server.Presence.TransactFD( recipient, summaryMsg, out replyMsg );

            QSummary2ReplyMsgData summaryReplyData = (QSummary2ReplyMsgData)replyMsg.Data;
            hr = summaryReplyData.HR;

            if(!HResult.Succeeded(hr))
            {
                System.Diagnostics.Debug.WriteLine(String.Format("GetSummary2(): failed for User: {0:x}, MsgID: {1}, HR = {2:x8}",
                        recipient.UserId,
                        msgId,
                        hr));
            }
            else 
            {
                PopulateMetadata(summaryReplyData.Summary);
            }

            return hr;
        }

        public uint GetDetails( PNState recipient ) 
        { 
            return GetDetails( recipient, 0, 0 ); 
        }

        public uint GetDetails( PNState recipient, uint setFlags, uint unsetFlags ) 
        { 
            return GetDetails( recipient, ID, setFlags, unsetFlags ); 
        }

        public uint GetDetails( PNState recipient, uint inID) 
        { 
            return GetDetails( recipient, inID, 0, 0 ); 
        }

        public uint GetDetails( PNState recipient, uint inID, uint setFlags, uint unsetFlags) 
        {
            uint hr = HResult.S_OK;

            // Allow loading when ID is not yet known (message hasn't been enumerated but
            // we can load directly from messaging QVals.
            if(ID != inID)
            {
                ID = inID;
            }

            QMsgDetails detailsMsg = new QMsgDetails( recipient, ID, setFlags, unsetFlags );

            PNMsg replyMsg;
            live.server.Presence.TransactFD( recipient, detailsMsg, out replyMsg );

            QDetailsReplyMsgData replyData = (QDetailsReplyMsgData)(replyMsg.Data);
            hr = replyData.HR;
               
            if(HResult.Succeeded(hr))
            {
                if(0 == SenderID)
                {
                    // Populate the metadata from included summary
                    PopulateMetadata(replyData.Summary);
                }

                Details = replyData.Details;
                Flags = replyData.Summary.MessageFlags;
            }

            return hr;
        }

        
        public uint Send(PNState recipient)
        {
            return Send(PNState.Find(SenderID), new PNState[]{recipient}, PNRequestMsg.FDPort.Messaging);
        }
        public uint Send(PNState recipient, PNRequestMsg.FDPort port)
        {
            return Send(PNState.Find(SenderID), new PNState[]{recipient}, port);  
        }
        public uint Send(PNState sender, PNState recipient)
        {
            return Send(sender, new PNState[]{recipient}, PNRequestMsg.FDPort.Messaging); 
        }
        public uint Send(PNState sender, PNState recipient, PNRequestMsg.FDPort port)
        {
            return Send(sender, new PNState[]{recipient}, PNRequestMsg.FDPort.Messaging); 
        }
        public uint Send(PNState sender, PNState []recipients)
        {
            return Send(sender, recipients, PNRequestMsg.FDPort.Messaging);
        }

        public uint Send( PNState sender, PNState []recipients, PNRequestMsg.FDPort port)
        {
            ulong[] recipientIds = new ulong[recipients.Length];
            
            // Copy the recipient IDs
            for(uint i = 0; i < recipients.Length; ++i)
            {
                recipientIds[i] = recipients[i].UserId;
            }

            QMsgSendMsg sendMsg = new QMsgSendMsg( sender, this, recipientIds );
            sendMsg.PortOnFD = port;
            PNMsg replyMsg;
            live.server.Presence.TransactFD( sender, sendMsg, out replyMsg );

            QSendMsgReplyMsgData replyData = (QSendMsgReplyMsgData)(replyMsg.Data);
                
            // Store the recipients and sent time
            Recipients = replyData.recipients;
            SentTime = DateTime.UtcNow;

            if(Recipients.Length == 1)
            {
                ID = replyData.recipients[0].msgId;
            }
            else if(Recipients.Length > 1)
            {
                ID = MANY_RECIPIENTS;
            }

            // Check reply results
            if(HResult.Failed(replyData.hr))
            {
                throw new HResultException(replyData.hr, "QMsgSendMsgReply.HR");
            }

            // Validate all the recipients
            for(uint i = 0; i < replyData.recipientsLen; ++i)
            {
                RecipientResult result = replyData.recipients[i];
            }


            return ID;
        }

        public void Delete( PNState deleter ) 
        { 
            Delete( deleter, false ); 
        }

        public void Delete( PNState deleter, bool block )
        {
            uint flags = block ? XonPresNoti.DELETE_MESSAGE_FLAG_BLOCK_SENDER : 0;
            QMsgDeleteMsg deleteMsg = new QMsgDeleteMsg( deleter, ID, flags );

            PNMsg replyMsg;
            live.server.Presence.TransactFD( deleter, deleteMsg, out replyMsg );

            QDeleteMsgReplyMsgData replyData = (QDeleteMsgReplyMsgData)(replyMsg.Data);
            if( replyData.HR != HResult.S_OK )
            {
                throw new HResultException( replyData.HR, "Delete Message HR = "+replyData.HR.ToString( "x" ) );
            }
        }

        public void PopulateMetadata(UserMsgSummary summary)
        {
            SenderID      = summary.SenderID;
            Context       = summary.SenderContext;
            SentTime      = summary.SentTime.dt;
            ID            = summary.MessageID;
            Flags         = summary.MessageFlags;
            TitleID       = summary.SenderTitleID;
            ExpireMinutes = summary.ExpireMinutes;
            Type          = summary.MessageType;
            SenderName    = summary.SenderName;
            Subject       = "";
        }

        public void PopulateMetadata(UserMsgSummary2 summary2)
        {
            SenderID      = summary2.SenderID;
            Context       = summary2.SenderContext;
            SentTime      = summary2.SentTime.dt;
            ID            = summary2.MessageID;
            Flags         = summary2.MessageFlags;
            TitleID       = summary2.SenderTitleID;
            ExpireMinutes = summary2.ExpireMinutes;
            Type          = summary2.MessageType;
            SenderName    = summary2.SenderName;
            Subject       = summary2.Subject;
        }

        public void CreateRecipients(int count)
        {
            Recipients = new RecipientResult[count];
            for(int i = 0; i < count; ++i)
            {
                Recipients[i] = new RecipientResult();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\UserMsgFolder.cs ===
// UserMsgFolder.cs
//
//	User message container
//

using System;
using System.Collections;
using System.Threading;
using live.common;

namespace live.protocol.Presence
{
	/// <summary>
	/// Collection of a particular user's messages
	/// </summary>
	public class UserMsgFolder
	{
        //------------------------------------------------------------------------------
        // Public property accessors
        //------------------------------------------------------------------------------

		public PNState Owner
        {
            get {
                return _Owner;
            }
        }
	    	
		public ushort InboxCount {
            get { 
                return (ushort)(_Inbox.Count); 
            }
        }
        // Alias for inbox count
        public ushort Count {
            get {
                return (ushort)_Inbox.Count;
            }
        }

        public ushort OutboxCount {
            get {
                return (ushort)(_Outbox.Count);
            }
        }

        public UserMessage [] Inbox {
            get {
                return (UserMessage[])_Inbox.ToArray(typeof(UserMessage));
            }
        }

        public UserMessage [] Outbox {
            get {
                return (UserMessage[])_Outbox.ToArray(typeof(UserMessage));
            }
        }

        public UserMessage FirstMessage {
            get {
                if(0 == _Inbox.Count)
                {
                    throw new Exception("No messages in the inbox");
                }
                return (UserMessage)_Inbox[0];
            }
        }

        
        //------------------------------------------------------------------------------
        // Internal properties
        //------------------------------------------------------------------------------
        private PNState      _Owner;
		private ArrayList   _Inbox = new ArrayList();		
		private ArrayList   _Outbox = new ArrayList();		


        //------------------------------------------------------------------------------ 
        // Public API
        //------------------------------------------------------------------------------ 

		/// <summary>
		/// Construct an empty folder for a user
		/// </summary>
		/// <param name="owner">Owner user</param>
		public UserMsgFolder( PNState owner )
		{
			_Owner = owner;
		}

        /// <summary>
		/// Deletes all messages from the server
		/// </summary>
		public void DeleteInbox()
		{
			DeleteInbox(false);
		}

        // Alias for DeleteInbox()
        public void DeleteAllMessages()
        {
            DeleteInbox();
        }
        // Alias for DeleteInbox()
        public void DeleteAllMessages(bool block)
        {
            DeleteInbox(block);
        }

		/// <summary>
		/// Deletes all messages from the server
		/// </summary>
		public void DeleteInbox(bool block)
		{
            try
            {
                foreach(UserMessage msg in _Inbox)
                {
                    msg.Delete(_Owner, block);
                }
			}
            finally
            {
			    _Inbox.Clear();
            }
		}

        /// <summary>
        /// Clear all of the sent messages stored
        /// </summary>
        public void ClearOutbox()
        {
            _Outbox.Clear();
        }

        /// <summary>
        /// Manually add a message to the collection. 
        /// </summary>
        public void AddSentMessage(UserMessage msg)
        {
            _Outbox.Add(msg);
        }

		/// <summary>
		/// Indexer to sent message table
		/// </summary>
		public UserMessage this[ uint msgId ]
		{
			get { 
                UserMessage msg = FindMessage(msgId);
                if(null == msg)
                {
                    throw new IndexOutOfRangeException( "MsgId: "+msgId+", is not in folder" );
                }

                return msg;
			}
		}


		/// <summary>
		/// Enumerate messages from server
		/// </summary>
		/// <returns>Number of messages present </returns>
		public ushort Load()
		{
			_Inbox.Clear();

			QMsgEnumMsgs enumMsg = new QMsgEnumMsgs( _Owner );

			PNMsg replyMsg;
			live.server.Presence.TransactFD( _Owner, enumMsg, out replyMsg );

			QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Enum Messages HR = 0x"+Hexer.tohex( replyData.HR ));

			foreach( UserMsgSummary summary in replyData.Messages )
			{
                CacheSummary(summary);
			}

			return InboxCount;
		}

		/// <summary>
		/// Enumerate messages from server using new enum2 message type
		/// </summary>
		/// <returns>Number of messages present </returns>
		public ushort Load2()
		{
			_Inbox.Clear();

			QMsgEnumMsgs2 enumMsg = new QMsgEnumMsgs2( _Owner );

			PNMsg replyMsg;
			live.server.Presence.TransactFD( _Owner, enumMsg, out replyMsg );

			QEnumMsgs2ReplyMsgData replyData = (QEnumMsgs2ReplyMsgData)(replyMsg.Data);

			if( replyData.HR != HResult.S_OK )
				throw new HResultException( replyData.HR, "Enum Messages HR = 0x"+Hexer.tohex( replyData.HR ));

			foreach( UserMsgSummary2 summary in replyData.Messages )
			{
			    CacheSummary(summary);
			}

			return InboxCount;
		}

		/// <summary>
		/// Finds messages in folder that match given criteria
		/// </summary>
		/// <param name="type">Messsage type</param>
		/// <param name="senderId">User ID of sender</param>
		/// <returns>Array of messages that match</returns>
		public UserMessage[] FindBySender( byte type, ulong senderId )
		{
			ArrayList msgList = new ArrayList();
			foreach(UserMessage msg in _Inbox)
            {
				if( (msg.SenderID == senderId) && ((0 == type) || (msg.Type == type)) )
				{
					msgList.Add( msg );
				}
			}

			return (UserMessage[])msgList.ToArray(typeof(UserMessage));
		}


		/// <summary>
		/// Finds messages in folder that match given criteria
		/// </summary>
		/// <param name="type">Messsage type</param>
		/// <param name="context">Message type specific context (ie. comp ID)</param>
		/// <returns>Array of messages that match</returns>
		public UserMessage[] FindByContext( byte type, ulong context )
		{
			ArrayList msgList = new ArrayList();
			foreach(UserMessage msg in _Inbox)
			{
				if( (msg.Type    == type) && (msg.Context == context) )
				{
					msgList.Add( msg );
				}
			}

			return (UserMessage[])msgList.ToArray(typeof(UserMessage));
		}

		
		/// <summary>
		/// Finds messages in folder that match given criteria
		/// </summary>
		/// <param name="type">Messsage type</param>
		/// <param name="senderId">User ID of sender</param>
		/// <param name="context">Message type specific context (ie. comp ID)</param>
		/// <returns>Array of messages that match</returns>
		public UserMessage[] Find( byte type, ulong senderId, ulong context )
		{
			ArrayList msgList = new ArrayList();
			foreach(UserMessage msg in _Inbox)
			{
				if( (msg.SenderID == senderId) && (msg.Type == type) && (msg.Context  == context) )
				{
					msgList.Add( msg );
				}
			}

			return (UserMessage[])msgList.ToArray(typeof(UserMessage));
		}


		/// <summary>
		/// Waits for a message that matches given criteria
		/// </summary>
		/// <param name="type">Message type</param>
		/// <param name="senderId">User ID of sender</param>
		/// <param name="waitSec">Seconds to wait</param>
		/// <returns>The first message found that matches</returns>
		public UserMessage WaitForMsgBySender( byte type, ulong senderId, ushort waitSec )
		{
			DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

			while( true )
			{
				Load();
				UserMessage[] msgs = FindBySender( type, senderId );
				if( msgs.Length != 0 )
				{
					return msgs[0];
				}
				
				if( DateTime.Now > abortTime )
					throw new TimeoutException( "Timed out waiting for Message" );

				Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
			}
		}

		
		/// <summary>
		/// Waits for a message that matches given criteria
		/// </summary>
		/// <param name="type">Message type</param>
		/// <param name="context">Message type specific context (ie. comp ID)</param>
		/// <param name="waitSec">Seconds to wait</param>
		/// <returns>The first message found that matches</returns>
		public UserMessage WaitForMsgByContext( byte type, ulong context, ushort waitSec )
		{
			DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

			while( true )
			{
				Load();
				UserMessage[] msgs = FindByContext( type, context );
				if( msgs.Length != 0 )
				{
					return msgs[0];
				}
				
				if( DateTime.Now > abortTime )
					throw new TimeoutException("Timed out waiting for Message" );

				Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
			}
		}

		
		/// <summary>
		/// Waits for a message that matches given criteria
		/// </summary>
		/// <param name="type">Message type</param>
		/// <param name="senderId">User ID of sender</param>
		/// <param name="context">Message type specific context (ie. comp ID)</param>
		/// <param name="waitSec">Seconds to wait</param>
		/// <returns>The first message found that matches</returns>
		public UserMessage WaitForMsg( byte type, ulong senderId, ulong context, ushort waitSec )
		{
			DateTime abortTime = DateTime.Now.AddSeconds( waitSec );

			while( true )
			{
				Load();
				UserMessage[] msgs = Find( type, senderId, context );
				if( msgs.Length != 0 )
				{
					return msgs[0];
				}
				
				if( DateTime.Now > abortTime )
					throw new TimeoutException( "Timed out waiting for Message" );

				Thread.Sleep( (int)((float)(waitSec / 10) * 1000.0) );
			}
		}

        public bool ContainsMessage(uint msgId)
        {
            bool found = false;
            foreach(UserMessage msg in _Inbox)
            {
                if(msg.ID == msgId)
                {
                    found = true;
                    break;
                }
            }

            return found;
        }

        //------------------------------------------------------------------------------
        // Internal API
        //------------------------------------------------------------------------------
        UserMessage FindMessage(uint msgId)
        {
            foreach(UserMessage msg in _Inbox)
            {
                if(msg.ID == msgId)
                {
                    return msg;
                }
            }
            return null;  
        }

        void CacheSummary(UserMsgSummary summary) {
            UserMessage msg = FindMessage(summary.MessageID);
            if(null == msg)
            {
                msg = new UserMessage(summary);
            }
            else
            {
                msg.PopulateMetadata(summary);
            }
            _Inbox.Add(msg);
        }

        void CacheSummary(UserMsgSummary2 summary)
        {
            UserMessage msg = FindMessage(summary.MessageID);
            if(null == msg)
            { 
                msg = new UserMessage(summary);
            }
            else
            {
                msg.PopulateMetadata(summary);
            }
            _Inbox.Add(msg);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\Presence\XonPresNoti.cs ===
// XonPresNoti.cs
//
//  Duplication of constants found in Presence and Notification
//  sectoin of Xonlinep.h
//
//  NOTE: Does not include internal constants not usefull for testing purposes.

using System;

namespace live.protocol.Presence
{
    //////////////////////////////////////
    // XonPresNoti 
    //
    //  Container for constants
    //
    public class XonPresNoti 
    {
        // XPNF Service Urls
        // -----------------
        public static readonly string PRESENCE_URL    = "/xpnfront/xpresence.srf";
        public static readonly string NOIFICATION_URL = "/xpnfront/xnotification.srf";
        public static readonly string TEAMS_URL       = "/xpnfront/xteams.srf";
        public static readonly string MESSAGING_URL   = "/xpnfront/xmessaging.srf";
        public static readonly string STATE_URL       = "/xpnfront/state.ashx";
        
        // Current protocol versions
        // -------------------------
        public const uint   CURRENT_XPPROTOCOL_VER = 0x00010000; // v1.0
        public const ushort PresProt_VER_MAJOR = 1;
        public const ushort PresProt_VER_MINOR = 0;

        // Current service versions
        // ------------------------
        public const uint   PRESENCE_SERVICE_VER = 0x00010000; //  1 = XONLINE_PRESENCE_SERVICE
        public const ushort PresServ_VER_MAJOR = 1;
        public const ushort PresServ_VER_MINOR = 0;
        public const uint MESSAGING_SERVICE_VER  = 0x00010000; // 18 = XONLINE_MESSAGING_SERVICE
        public const ushort MessServ_VER_MAJOR = 1;
        public const ushort MessServ_VER_MINOR = 0;
        public const uint TEAM_SERVICE_VER       = 0x00010000; // 19 = XONLINE_TEAM_SERVICE
        public const ushort TeamServ_VER_MAJOR = 1;
        public const ushort TeamServ_VER_MINOR = 0;

        // Presence Message Types (IDs)
        // ----------------------------
        // ... Incoming
        public const uint PMSG_HELLO              = 1000;
        public const uint PMSG_ALIVE              = 1001;
        public const uint PMSG_SYNC               = 1002;
        public const uint PMSG_REFRESH            = 1003;
        public const uint PMSG_ADD                = 1004;
        public const uint PMSG_DELETE             = 1005;
        public const uint PMSG_ACCEPT             = 1006;
        public const uint PMSG_REJECT             = 1007;
        public const uint PMSG_BLOCK              = 1008;
        public const uint PMSG_UNBLOCK            = 1009;
        public const uint PMSG_INVITE             = 1010;
        public const uint PMSG_CANCEL             = 1011;
        public const uint PMSG_INVITE_ANSWER      = 1012;
        public const uint PMSG_NICKNAME           = 1013;
        public const uint PMSG_STATE              = 1014;
        public const uint PMSG_DEAD_XBOX          = 1015;
        public const uint PMSG_DEAD_SG            = 1016;
        public const uint PMSG_DEAD_USER          = 1024;
        public const uint PMSG_ALIVE_2            = 1025;
        public const uint PMSG_WEB_FRIENDS        = 1026;
        public const uint PMSG_WEB_ALIVE          = 1027;
        public const uint PMSG_PEER_SESSION       = 1031;
        public const uint PMSG_TEAM_LIST_TEAMS    = 1032;
        public const uint PMSG_TEAM_LIST_MEMBERS  = 1033;
        public const uint PMSG_TEAM_CREATE        = 1034;
        public const uint PMSG_TEAM_DELETE        = 1035;
        public const uint PMSG_TEAM_REMOVE        = 1036;
        public const uint PMSG_TEAM_MANAGE_TEAM   = 1037;
        public const uint PMSG_TEAM_MANAGE_MEMBER = 1038;
        public const uint PMSG_TEAM_RECRUIT       = 1039;
        public const uint PMSG_TEAM_JOIN          = 1040;
        public const uint PMSG_TEAM_GET_TICKET    = 1041;
        public const uint PMSG_PEER_SUBSCRIBE     = 1042;
        public const uint PMSG_PEER_UNSUBSCRIBE   = 1043;
        public const uint PMSG_WATCH_START        = 1044;
        public const uint PMSG_WATCH_STOP         = 1045;
        public const uint PMSG_ADD_2              = 1046;
        public const uint PMSG_INVITE_2           = 1047;
        public const uint PMSG_ALIVE_INTERNAL     = 1048;
        public const uint PMSG_STATE_2            = 1049;
        public const uint PMSG_GET_STATE          = 1050;
        public const uint PMSG_TEAM_CREATE_TEAM_XE= 1051;
        public const uint PMSG_TEAM_MANAGE_TEAM_XE= 1052;
        public const uint PMSG_ADD_AFFILIATES     = 1053;
        public const uint PMSG_IS_AFFILIATE       = 1054;
        public const uint PMSG_QUERY_AFFILIATES         = 1055;
        public const uint PMSG_GET_PRESENCE_INFO        = 1056;
        public const uint PMSG_PRESENCE_INFO_REPLY             = 1057;
        public const uint PMSG_INVALIDATE_USER          = 1058;
        public const uint PMSG_FIND_USER                = 1059;
        public const uint PMSG_CHECK_TITLE_MESSAGES     = 1060;
        public const uint PMSG_TEAM_LIST_USER_TEAMS     = 1061;
        public const uint PMSG_USER_PRE_MIGRATION            = 1062;
        public const uint PMSG_USER_FULL_MIGRATION           = 1063;
        public const uint PMSG_LOGON_CHECK                   = 1064;
        public const uint PMSG_FIND_USERS                    = 1065;
        public const uint PMSG_ALIVE_INTERNAL_2              = 1066;
        public const uint PMSG_PEER_SUBSCRIBE_EX             = 1067;
        public const uint PMSG_PURGE_USER                    = 1068;
        public const uint PMSG_GET_FRIENDS_LIST              = 1069;        
        // ... Outgoing
        public const uint PMSG_ALIVE_REPLY              = 1101;
        public const uint PMSG_SYNC_REPLY               = 1102;
        public const uint PMSG_WEB_FRIENDS_REPLY        = 1103;
        public const uint PMSG_WEB_ALIVE_REPLY          = 1104;
        public const uint PMSG_PEER_SESSION_REPLY       = 1105;
        public const uint PMSG_INVITE_REPLY             = 1106;
        public const uint PMSG_TEAM_LIST_TEAMS_REPLY    = 1107;
        public const uint PMSG_TEAM_LIST_MEMBERS_REPLY  = 1108;
        public const uint PMSG_TEAM_CREATE_REPLY        = 1109;
        public const uint PMSG_TEAM_DELETE_REPLY        = 1110;
        public const uint PMSG_TEAM_REMOVE_REPLY        = 1111;
        public const uint PMSG_TEAM_MANAGE_TEAM_REPLY   = 1112;
        public const uint PMSG_TEAM_MANAGE_MEMBER_REPLY = 1113;
        public const uint PMSG_TEAM_RECRUIT_REPLY       = 1114;
        public const uint PMSG_TEAM_JOIN_REPLY          = 1115;
        public const uint PMSG_TEAM_GET_TICKET_REPLY    = 1116;
        public const uint PMSG_PEER_SUBSCRIBE_REPLY     = 1117;
        public const uint PMSG_PEER_UNSUBSCRIBE_REPLY   = 1118;
        public const uint PMSG_GET_STATE_REPLY          = 1119;
        public const uint PMSG_IS_AFFILIATE_REPLY       = 1120;
        public const uint PMSG_QUERY_AFFILIATES_REPLY   = 1121;
        public const uint PMSG_FIND_USER_REPLY          = 1122;
        public const uint PMSG_CHECK_TITLE_MESSAGES_REPLY= 1123;
        public const uint PMSG_TEAM_LIST_USER_TEAMS_REPLY = 1124;
        public const uint PMSG_LOGON_CHECK_REPLY             = 1125;
        public const uint PMSG_FIND_USERS_REPLY              = 1126;
        public const uint PMSG_PEER_SUBSCRIBE_EX_REPLY       = 1127;
        public const uint PMSG_PURGE_USER_REPLY              = 1128;
        public const uint PMSG_GET_FRIENDS_LIST_REPLY        = 1129;

        // Notification Message Types (IDs)
        // --------------------------------
        // ... Incoming
        public const uint QMSG_HELLO                  = 0;
        public const uint QMSG_USER_INFO              = 1;
        public const uint QMSG_ADD                    = 2;
        public const uint QMSG_DELETE                 = 3;
        public const uint QMSG_DELETE_MATCHES         = 4;
        public const uint QMSG_DEAD_XBOX              = 5;
        public const uint QMSG_DEAD_SG                = 6;
        public const uint QMSG_LIST                   = 7;
        public const uint QMSG_DEQUEUE                = 8;
        public const uint QMSG_DEAD_USER              = 9;
        public const uint QMSG_WEB_USER_INFO          = 10;
        public const uint QMSG_WEB_PRESENCE           = 11;
        public const uint QMSG_WEB_LIST               = 12;
        public const uint QMSG_ENUM_MESSAGES          = 13;
        public const uint QMSG_MESSAGE_SUMMARY        = 14;
        public const uint QMSG_MESSAGE_DETAILS        = 15;
        public const uint QMSG_DELETE_MESSAGE         = 16;
        public const uint QMSG_SEND_MESSAGE           = 17;
        public const uint QMSG_REVOKE_MESSAGE         = 18;
        public const uint QMSG_DELETE_TITLE           = 19;
        public const uint QMSG_ENUM_TITLES            = 20;
        public const uint QMSG_MESSAGE_FLAGS          = 21;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES   = 22;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS = 23;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE  = 24;
        public const uint QMSG_SEND_SYSTEM_MESSAGE    = 25;
        public const uint QMSG_REVOKE_MESSAGE_EX      = 26;
        public const uint QMSG_ENUM_MESSAGES_2        = 27;
        public const uint QMSG_MESSAGE_SUMMARY_2      = 28;

        // ... Outgoing
        public const uint QMSG_LIST_REPLY                   = 100;
        public const uint QMSG_WEB_LIST_REPLY               = 101;
        public const uint QMSG_ENUM_MESSAGES_REPLY          = 102;
        public const uint QMSG_MESSAGE_SUMMARY_REPLY        = 103;
        public const uint QMSG_MESSAGE_DETAILS_REPLY        = 104;
        public const uint QMSG_DELETE_MESSAGE_REPLY         = 105;
        public const uint QMSG_SEND_MESSAGE_REPLY           = 106;
        public const uint QMSG_REVOKE_MESSAGE_REPLY         = 107;
        public const uint QMSG_DELETE_TITLE_REPLY           = 108;
        public const uint QMSG_ENUM_TITLES_REPLY            = 109;
        public const uint QMSG_MESSAGE_FLAGS_REPLY          = 110;
        public const uint QMSG_ENUM_SYSTEM_MESSAGES_REPLY   = 111;
        public const uint QMSG_SYSTEM_MESSAGE_DETAILS_REPLY = 112;
        public const uint QMSG_DELETE_SYSTEM_MESSAGE_REPLY  = 113;
        public const uint QMSG_SEND_SYSTEM_MESSAGE_REPLY    = 114;
        public const uint QMSG_ENUM_MESSAGES_2_REPLY        = 115;
        public const uint QMSG_MESSAGE_SUMMARY_2_REPLY      = 116;
        public const uint QMSG_LIST_REPLY_2                 = 117;

        // Misc protocol related constants
        // --------------------------------
        // ... Max Sizes
        public const uint MAX_HELLO_DESCRIPTION_LEN  = 80;
        public const uint MAX_ACCTNAME_BYTES         = 16; // XONLINE_GAMERTAG_SIZE
        public const uint MAX_NICKNAME_BYTES         = 24;
        public const uint MAX_TITLE_STATE_BYTES      = 32;
        public const uint MAX_TITLE_DATA_BYTES       = 256;
        public const uint MAX_NOT_TITLE_STATE_BYTES  = 8;  // Constants for spliting state
        public const uint MAX_NOT_NICKNAME_BYTES     = 24; //   into the old notification message
        public const uint MAX_BUDDIES                = 100;
        public const uint MAX_BLOCKS                 = 250;
        public const uint MAX_PEER_SUBSCRIPTIONS     = 1000;
        public const uint MAX_NUM_MESSAGES           = 125;
        public const uint MAX_MESSAGE_RECIPIENTS     = 100;
        public const uint MAX_MESSAGE_DETAILS        = 4096;
        public const uint MAX_RETURNED_USER_TITLES   = 100; // max that QMSG_ENUM_TITLES will return
        public const uint MAX_RETURNED_SYSTEM_MSGS   = 100; // max that QMSG_ENUM_SYSTEM_MESSAGES will return
        public const uint MAX_TRANSIENT_MESSAGES     = 25;
        public const uint MAX_PERSISTENT_MESSAGES    = 100;
        public const uint MAX_TOTAL_USER_MESSAGES    = (MAX_TRANSIENT_MESSAGES + MAX_PERSISTENT_MESSAGES);
        public const uint MAX_SYSTEM_MSG_DESC_LEN    = 64;
        public const uint MAX_TEAM_COUNT             = 8;
        public const uint MAX_TEAM_RECRUIT_COUNT     = 100;
        public const uint MAX_TEAM_MEMBER_COUNT      = 64;
        public const uint MIN_MAX_TEAM_MEMBER_COUNT  = 2;
        public const uint MAX_TEAM_NAME_SIZE         = 16;
        public const uint MAX_TEAM_NAME_BYTES        = 32;
        public const uint MAX_TEAM_DESCRIPTION_SIZE  = 256;
        public const uint MAX_TEAM_DESCRIPTION_BYTES = 512;
        public const uint MAX_TEAM_MOTTO_SIZE        = 256;
        public const uint MAX_TEAM_MOTTO_BYTES       = 512;
        public const uint MAX_TEAM_URL_SIZE          = 256;
        public const uint MAX_TEAM_URL_BYTES         = 512;
        public const uint MAX_TEAM_DATA_SIZE         = 100;
        public const uint MAX_TEAM_MEMBER_DATA_SIZE  = 100;
        public const uint MAX_SUBJECT_SIZE           = 20;
        // ... Invites expire after 1-day
        public const uint INVITE_EXPIRATION_MINUTES = 1440;
        // ... Friend requests and Team recruits expire after 30 days
        public const uint FRIEND_REQUEST_EXPIRATION_MINUTES  = 43200; 
        public const uint TEAM_RECRUIT_EXPIRATION_MINUTES    = 43200;
        // ... Invalid Match Session ID
        public const ulong IGNOREME_SESSID = 0;
        // ... Common Ack Message Type (ID)
        public const uint MSGTYPE_ACK = 0xffffffff;
        // ... Flag to block a sender when deleting a message
        public const uint DELETE_MESSAGE_FLAG_BLOCK_SENDER = 0x00000001;
        // ... Flags for Revoke Ex messages
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID       = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER   = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT  = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP     = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE     = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED    = 0xFFFFFFC0;
        // ... Flag to clean our user queues as well when deleting a system message
        public const uint DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL = 0x00000001;
        // ... Flag that user has opted in to marketing for a title when enrumerating titles
        public const uint USER_TITLE_FLAG_ACCEPT_MARKETING = 0x00000001;

        // Presence State Masks
        // --------------------
        public const uint P_STATE_MASK_NONE                        = 0x00000000;
        public const uint P_STATE_MASK_ONLINE                      = 0x00000001;
        public const uint P_STATE_MASK_PLAYING                     = 0x00000002;
        public const uint P_STATE_MASK_CLOAKED                     = 0x00000004;
        public const uint P_STATE_MASK_VOICE                       = 0x00000008;
        public const uint P_STATE_MASK_JOINABLE                    = 0x00000010;
        public const uint P_STATE_MASK_GUESTS                      = 0x00000060;
        public const uint P_STATE_MASK_RESERVED0                   = 0x00000080;
        public const uint P_STATE_MASK_JOINABLE_FRIENDS_ONLY       = 0x00000100;
        public const uint P_STATE_MASK_PARTY_JOINABLE              = 0x00000200;
        public const uint P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY = 0x00000400;
        public const uint P_STATE_MASK_PARTY_PLAYING               = 0x00000800;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;

        public const uint P_STATE_MASK_PARTY_COUNTER       = 0x00300000;
        
        // console types
        public const uint P_STATE_MASK_CONSOLE_TYPE        = 0x00007000;
        public const uint P_STATE_ENUM_CONSOLE_XBOX        = 0x00000000;
        public const uint P_STATE_ENUM_CONSOLE_XENON       = 0x00001000;
        public const uint P_STATE_ENUM_CONSOLE_WINPC       = 0x00002000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD1       = 0x00003000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD2       = 0x00004000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD3       = 0x00005000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD4       = 0x00006000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD5       = 0x00007000;

        public const uint P_STATE_MASK_SENTREQUEST     = 0x40000000;
        public const uint P_STATE_MASK_RECEIVEDREQUEST = 0x80000000;

        // Buddy Status
        // ------------
        public const byte NOT_A_BUDDY            = 0xff;
        public const byte P_BUDDY_STATUS_OK      = 0;  // Mutualy accepted buddy
        public const byte P_BUDDY_STATUS_PENDING = 1;  // Buddy request pending acceptance
        public const byte P_BUDDY_STATUS_REQUEST = 2;  // Buddy request to accept or reject
        public const byte P_BUDDY_STATUS_ACCEPTED = 3; // Client only status to avoid multiple accepts


        /// <summary>
        /// Get the friendly name for a buddy status byte
        /// </summary>
        public static string BuddyStatusToString(byte status)
        {
            switch(status)
            {
                case NOT_A_BUDDY:
                    return "NotABuddy";
                case P_BUDDY_STATUS_OK:
                    return "BuddyOk";
                case P_BUDDY_STATUS_PENDING:
                    return "BuddyPending";
                case P_BUDDY_STATUS_REQUEST:
                    return "BuddyRequested";
                case P_BUDDY_STATUS_ACCEPTED:
                    return "BuddyAccepted";
                default:
                    return "Unknown";
            }
        }

        // Invitation Replies
        // ------------------
        public const ushort PINVITE_REPLY_NO    = 0;
        public const ushort PINVITE_REPLY_YES   = 1;
        public const ushort PINVITE_REPLY_NEVER = 2;

        // Generic Reply Values
        // ------------------
        public const byte REPLY_NO    = 0;
        public const byte REPLY_YES   = 1;
        public const byte REPLY_NEVER = 2;

        // Team Member Privliges
        // ---------------------
        public const uint TEAM_DELETE                    = 0x00000001;
        public const uint TEAM_MODIFY_DATA               = 0x00000002;
        public const uint TEAM_MODIFY_MEMBER_PERMISSIONS = 0x00000004;
        public const uint TEAM_DELETE_MEMBER             = 0x00000008;
        public const uint TEAM_RECRUIT_MEMBERS           = 0x00000010;
        public const uint TEAM_LIVE_PERMISSIONS_FORCE_DWORD = 0xFFFFFFFF;
        
        // Notification Queue Types and Masks
        // ----------------------------------
        // ... Request IDs
        public const ushort PQUEUE_BUDDY_REQ      = 0;
        public const ushort PQUEUE_LIST_CHANGE    = 1;
        public const ushort PQUEUE_PRESENCE       = 2;
        public const ushort PQUEUE_INVITE         = 3;
        public const ushort PQUEUE_INVITE_ANSWER  = 4;
        public const ushort PQUEUE_TRANSIENT_MSGS = 5;
        public const ushort PQUEUE_PEER_PRESENCE  = 6;
        public const ushort PQUEUE_PRESENCE_2     = 7;

        
        /// <summary>
        /// Get the friendly name for a presence QType ID
        /// </summary>
        public static string QTypeToString(uint qType)
        {
            switch(qType)
            {
                case PQUEUE_BUDDY_REQ:
                    return "BuddyRequest";
                case PQUEUE_LIST_CHANGE:
                    return "ListChange";
                case PQUEUE_PRESENCE:
                    return "Presence";
                case PQUEUE_INVITE:
                    return "Invite";
                case PQUEUE_INVITE_ANSWER:
                    return "InviteAnswer";
                case PQUEUE_TRANSIENT_MSGS:
                    return "TransientMessages";
                case PQUEUE_PEER_PRESENCE:
                    return "PeerPresence";
                case PQUEUE_PRESENCE_2:
                    return "RichPresence";
                default:
                    return "Unknown";
            }
        }

        // ... Qflag Masks 
        public const uint QFLAG_MASK_BUDDY_REQ      = 0x00000001;
        public const uint QFLAG_MASK_LIST_CHANGE    = 0x00000002;
        public const uint QFLAG_MASK_PRESENCE       = 0x00000004;
        public const uint QFLAG_MASK_INVITE         = 0x00000008;
        public const uint QFLAG_MASK_INVITE_ANSWER  = 0x00000010;
        public const uint QFLAG_MASK_TRANSIENT_MSGS = 0x00000020;
        public const uint QFLAG_MASK_PEER_PRESENCE  = 0x00000040;
        public const uint QFLAG_MASK_PRESENCE_2     = 0x00000080;
        public const uint QFLAG_MASK_ANY            = 0x000000FF;

        /// <summary>
        /// Build a string representation of a qflags bit set
        /// </summary>
        public static string BuildQFlagsString(uint flags)
        {
            string strFlags = "";
            if((flags & XonPresNoti.QFLAG_MASK_BUDDY_REQ) != 0)
                strFlags += "+BuddyRequest";
            if((flags & XonPresNoti.QFLAG_MASK_LIST_CHANGE) != 0)
                strFlags += "+ListChange";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE) != 0)
                strFlags += "+Presence";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE) != 0)
                strFlags += "+Invite";
            if((flags & XonPresNoti.QFLAG_MASK_INVITE_ANSWER) != 0)
                strFlags += "+InviteAnswer";
            if((flags & XonPresNoti.QFLAG_MASK_TRANSIENT_MSGS) != 0)
                strFlags += "+TransientMsgs";
            if((flags & XonPresNoti.QFLAG_MASK_PEER_PRESENCE) != 0)
                strFlags += "+PeerPresence";
            if((flags & XonPresNoti.QFLAG_MASK_PRESENCE_2) != 0)
                strFlags += "+Presence2";

            return strFlags;
        }

        // List Change Operations
        // ----------------------
        public const ushort PLIST_BUDDY_NOP    = 0;
        public const ushort PLIST_BUDDY_ADD    = 1;
        public const ushort PLIST_BUDDY_ADDED  = 2;
        public const ushort PLIST_BUDDY_ACCEPT = 3;
        public const ushort PLIST_BUDDY_REJECT = 4;
        public const ushort PLIST_BUDDY_DELETE = 5;

        /// <summary> 
        /// Get the friendly name for a list change operation
        /// </summary>
        public static string ListChangeOpToString(ushort listChangeOp)
        {
            switch(listChangeOp)
            {
                case PLIST_BUDDY_NOP:
                    return "Noop";
                case PLIST_BUDDY_ADD:
                    return "BuddyAdd";
                case PLIST_BUDDY_ADDED:
                    return "BuddyAdded";
                case PLIST_BUDDY_ACCEPT:
                    return "BuddyAccept";
                case PLIST_BUDDY_REJECT:
                    return "BuddyReject";
                case PLIST_BUDDY_DELETE:
                    return "BuddyDelete";
                default:
                    return "Unknown";
            }
        }

        //
        // Affiliates
        //
        public const ushort X_ADD_AFFILIATE_MAX = 16;

        // Message IDs
        // -----------
        public const uint MSG_ID_SEND_FAILED       = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint MSG_ID_SYSTEM_MESSAGE    = 0x40000000; // A message sent by the Live service or a publisher
        public const uint MSG_ID_TRANSIENT_MESSAGE = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint MSG_ID_BASE_MASK         = 0x00FFFFFF;
        public const uint MSG_ID_RESERVED_MASK     = 0x1F000000;

        // Message Notifications
        // ---------------------
        public const uint MSG_NOTIFICATION_FLAG_SAME_TITLE         = 0x000001;
        public const uint MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     = 0x000002;
        public const uint MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND = 0x000004;
        public const uint MSG_NOTIFICATION_FLAG_HAS_VOICE          = 0x000008;
        public const uint MSG_NOTIFICATION_FLAG_HAS_TEXT           = 0x000010;
        public const uint MSG_NOTIFICATION_FLAG_ALT_TITLE          = 0x000020;
        public const uint MSG_NOTIFICATION_FLAG_TITLE_RESERVED     = 0xFF0000;
        public const uint MSG_NOTIFICATION_FLAG_RESERVED           = 0x00FFC0;

        /// <summary>
        /// Build a string representation of the messaging qval notification flags.
        /// </summary>
        public static string BuildMsgNotificationFlagsString(uint dataFlags)
        {
            string strFlags = "";

            // Pull out the type from high byte
            strFlags += "Type[" + MessageTypeToString((uint)(0xff & (dataFlags >> 24))) + "] ";

            // Pull metadata flags from flags from low 3 bytes
            strFlags += "Flags[" + (0x00ffffff & dataFlags).ToString("x8") + "] ";

            // Standard flags
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_TITLE) != 0)
                strFlags += "+SameTitle";
            if((dataFlags & MSG_NOTIFICATION_FLAG_SAME_PUBLISHER) != 0)
                strFlags += "+SamePublisher";
            if((dataFlags & MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND) != 0)
                strFlags += "+FromFriend";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_VOICE) != 0)
                strFlags += "+HasVoice";
            if((dataFlags & MSG_NOTIFICATION_FLAG_HAS_TEXT) != 0)
                strFlags += "+HasText";
            if((dataFlags & MSG_NOTIFICATION_FLAG_ALT_TITLE) != 0)
                strFlags += "+AltTitle";

            return strFlags;
        }
 
        // Message Types
        // -------------
        // A message type establishes the purpose of the message and the properties that 
        // are required for a message of that type.
        public const byte MSG_TYPE_TITLE_CUSTOM      = 1;  // context: title defined;    required props: title defined
        public const byte MSG_TYPE_FRIEND_REQUEST    = 2;  // context: 0;                required props: none
        public const byte MSG_TYPE_GAME_INVITE       = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte MSG_TYPE_TEAM_RECRUIT      = 4;  // context: inviting team ID; required props: none
        public const byte MSG_TYPE_COMP_REMINDER     = 5;  // context: comp event ID;    required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_EVENT_START
        public const byte MSG_TYPE_COMP_REQUEST      = 6;  // context: comp entity ID;   required props: MSG_PROP_COMP_NAME, MSG_PROP_COMP_START, MSG_PROP_COMP_REG_CLOSE 
        public const byte MSG_TYPE_LIVE_MESSAGE      = 7;  // context: 0                 required props: MSG_PROP_SYSTEM_TEXT
        public const byte MSG_TYPE_PERSONAL_MESSAGE  = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte MSG_TYPE_VIDEO_MESSAGE     = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte MSG_TYPE_QUICK_CHAT_INVITE = 10; // context: 0
        public const byte MSG_TYPE_VIDEO_CHAT_INVITE = 11; // context: 0
        public const byte MSG_TYPE_PARTY_CHAT_INVITE = 12; // context: 0

        public static string MessageTypeToString(uint msgType)
        {
            switch(msgType)
            {
                case MSG_TYPE_TITLE_CUSTOM:
                    return "TitleCustom";       
                case MSG_TYPE_FRIEND_REQUEST:
                    return "FriendRequest";     
                case MSG_TYPE_GAME_INVITE:
                    return "GameInvite";        
                case MSG_TYPE_TEAM_RECRUIT:
                    return "TeamRecruit";       
                case MSG_TYPE_COMP_REMINDER:
                    return "CompReminder";      
                case MSG_TYPE_COMP_REQUEST:
                    return "CompRequest";       
                case MSG_TYPE_LIVE_MESSAGE:
                    return "LiveMessage";       
                case MSG_TYPE_PERSONAL_MESSAGE:
                    return "PersonalMessage";       
                case MSG_TYPE_VIDEO_MESSAGE:
                    return "VideoMessage";      
                case MSG_TYPE_QUICK_CHAT_INVITE:
                    return "ChatInvite";        
                case MSG_TYPE_VIDEO_CHAT_INVITE:
                    return "VideoChatInvite";
                case MSG_TYPE_PARTY_CHAT_INVITE:
                    return "PartyInvite";
                default:
                    return "UnknownType";
            }
        }

        // Message Flags
        // -------------
        public const uint MSG_FLAG_REQUIRED              = 0x00000001; // User required to read this message
        public const uint MSG_FLAG_RECOMMENDED           = 0x00000002; // User has a system recommended message
        public const uint MSG_FLAG_HAS_VOICE             = 0x00000004; // Message contains a voice attachment
        public const uint MSG_FLAG_HAS_TEXT              = 0x00000008; // Message contains a text body
        public const uint MSG_FLAG_READ                  = 0x00000010; // Message has been read
        public const uint MSG_FLAG_NON_EXPORTABLE        = 0x00000020; // Message should only be displayed on Xbox consoles, not the web
        public const uint MSG_FLAG_TEAM_CONTEXT          = 0x00000040; // Message's sender context refers to a team ID
        public const uint MSG_FLAG_COMP_CONTEXT          = 0x00000080; // This message's sender context refers to a competition event or entity ID
        public const uint MSG_FLAG_ALTERNATE_TITLE       = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint MSG_FLAG_MARKETING             = 0x00000200; // Used on title-sent messages to indicate the message is marketing-related and opt-in settings should be checked
        public const uint MSG_FLAG_MS_MARKETING          = 0x00000400; // Used on title-sent messages to indicate the message is MS marketing-related and opt-in settings should be checked
        public const uint MSG_FLAGS_TITLE_RESERVED       = 0xFF000000; // Flags reserved for title custom messages
        // ... Internal
        public const uint MSG_FLAG_SENDER_IS_FRIEND      = 0x00800000; // Used by Notification to detect invites that should go to V1 clients, also used by clients to allow cross-title invites
        public const uint MSG_FLAG_RECV_DETAILS_NEEDED   = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint MSG_FLAG_SEND_MSG_OWNED        = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint MSG_FLAGS_RESERVED             = 0x005FFC00; // Flags reserved for future use
        // ... Flags valid in a call to send a message
        public const uint MSG_FLAGS_VALID_SEND_MASK = 
            MSG_FLAG_REQUIRED |
            MSG_FLAG_RECOMMENDED |
            MSG_FLAG_HAS_VOICE |
            MSG_FLAG_HAS_TEXT |
            MSG_FLAG_NON_EXPORTABLE |
            MSG_FLAGS_TITLE_RESERVED |
            MSG_FLAG_TEAM_CONTEXT |
            MSG_FLAG_COMP_CONTEXT |
            MSG_FLAG_MARKETING;
        // ... Flags a title is allowed to set on an already sent message
        public const uint MSG_FLAGS_TITLE_SETABLE = 
            MSG_FLAG_READ |
            MSG_FLAGS_TITLE_RESERVED; 
        // ... Flags a title is allowed to clear on an already sent message
        public const uint MSG_FLAGS_TITLE_CLEARABLE = 
            MSG_FLAGS_TITLE_RESERVED; 
        // ... Test: Flags expected in a V1 iinvite message
        public const uint MSG_FLAGS_TEST_V1INVITE_EXPECTED =
            MSG_FLAG_SENDER_IS_FRIEND;

        // Attachment Flags
        // ----------------
        // ... This attachment should not be visible when the message is displayed on the web
        public const uint MSG_ATTACHMENT_FLAG_NON_EXPORTABLE = 0x00000001; 
        // ... The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint MSG_ATTACHMENT_FLAG_DIRECTORY      = 0x00000002; 
        // ... Flags reserved for future use
        public const uint MSG_ATTACHMENT_FLAGS_RESERVED      = 0xFFFFFFFC; 

        // Message Property Types
        // ----------------------
        public const byte MSG_PROP_TYPE_NULL       =  1; // no data
        public const byte MSG_PROP_TYPE_I1         =  2; // 8-bits of data
        public const byte MSG_PROP_TYPE_I2         =  3; // 16-bits of data
        public const byte MSG_PROP_TYPE_I4         =  4; // 32-bits of data
        public const byte MSG_PROP_TYPE_I8         =  5; // 64-bits of data
        public const byte MSG_PROP_TYPE_STRING     =  6; // NULL-terminated wide character string
        public const byte MSG_PROP_TYPE_FILETIME   =  7; // time value
        public const byte MSG_PROP_TYPE_BINARY     =  8; // binary blob that fits in the message details
        public const byte MSG_PROP_TYPE_ATTACHMENT =  9; // binary blob (or directory path, depending on attachment flags) 
                                                         //  that will be uploaded to storage during XOnlineMessageSend
        public const byte MSG_PROP_TYPE_BOOL       = 10; // boolean value (1=TRUE, 0=FALSE)
        public const byte MSG_PROP_TYPE_STRING_ID  = 11; // A string ID whose text can be requested from the string service

        // Message Property IDs 
        // --------------------
        // Property IDs should adhere to the following ranges:
        // Range      Purpose
        // 0x00-0x7F  Reserved for use by titles
        // 0x80-0xBF  Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF  Reserved for use by Microsoft for properties that span all message types
        public const byte MSG_PROP_ID_BUILTIN = 0x80; // Used for properties defined by Microsoft
        public const byte MSG_PROP_ID_GLOBAL  = 0x40; // Used for properties that can span all message types

        // Message Property Tags
        // ---------------------
        // ... Global property tags, allowed in any message type
        // All message types can contain a voice attachment specified in the following properties.  All three
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_VOICE message 
        // flag can be used to test for the presence of these properties before the message details have been 
        // retrieved.
        public const ushort MSG_PROP_VOICE_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_VOICE_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_VOICE_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 3);

        // All message types can contain a text summary specified in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_TEXT message 
        // flag can be used to test for the presence of these properties before the message details have been 
        // retrieved.  The text should be 256 characters or less and may be used by Live anywhere that a text
        // summary of the message is useful, such as in a Messenger Alert, on the web, or in the Dashboard.
        public const ushort MSG_PROP_TEXT                = ((ushort)MSG_PROP_TYPE_STRING     << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_TEXT_LANGUAGE       = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 5);

        // ... Invite message properties
        public const ushort MSG_PROP_SESSION_ID          = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 1);
        public const ushort MSG_PROP_SESSION_DESCRIPTION = ((ushort)MSG_PROP_TYPE_STRING     << 8) | (MSG_PROP_ID_BUILTIN | 2);
        public const ushort MSG_PROP_SESSION_HOST_XNADDR = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_SESSION_HOST_KEY    = ((ushort)MSG_PROP_TYPE_I8         << 8) | (MSG_PROP_ID_BUILTIN | 4);

        // ... Live system message properties
        public const ushort MSG_PROP_SYSTEM_TEXT         = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Team Recruit message properties
        public const ushort MSG_PROP_TEAM_NAME           = ((ushort)MSG_PROP_TYPE_STRING << 8) | (MSG_PROP_ID_BUILTIN | 1);

        // ... Competitions message properties
        public const ushort MSG_PROP_COMP_DATASET        = ((ushort)MSG_PROP_TYPE_I4        << 8) | (MSG_PROP_ID_BUILTIN | 0x1);             
        public const ushort MSG_PROP_COMP_NAME           = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0x2);             
        public const ushort MSG_PROP_COMP_START          = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x3);             
        public const ushort MSG_PROP_COMP_ROUND          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x4);             
        public const ushort MSG_PROP_COMP_OPPONENT       = ((ushort)MSG_PROP_TYPE_STRING_ID << 8) | (MSG_PROP_ID_BUILTIN | 0x5);             
        public const ushort MSG_PROP_COMP_ADMIN          = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x6);             
        public const ushort MSG_PROP_COMP_REG_CLOSE      = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x7);             
        public const ushort MSG_PROP_COMP_PRIVATE_SLOTS  = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x8);             
        public const ushort MSG_PROP_COMP_PUBLIC_SLOTS   = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0x9);             
        public const ushort MSG_PROP_COMP_UNITS          = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xA);             
        public const ushort MSG_PROP_COMP_INTERVAL       = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xB);             
        public const ushort MSG_PROP_COMP_DAYMASK        = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_BUILTIN | 0xC);             
        public const ushort MSG_PROP_COMP_DESCRIPTION    = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xD);             
        public const ushort MSG_PROP_COMP_URL            = ((ushort)MSG_PROP_TYPE_STRING    << 8) | (MSG_PROP_ID_BUILTIN | 0xE);             
        public const ushort MSG_PROP_COMP_EVENT_ID       = ((ushort)MSG_PROP_TYPE_I8        << 8) | (MSG_PROP_ID_BUILTIN | 0x10);             
        public const ushort MSG_PROP_COMP_EVENT_START    = ((ushort)MSG_PROP_TYPE_FILETIME  << 8) | (MSG_PROP_ID_BUILTIN | 0x11);             

        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        // ----------------------------------------------------------------
        public const ushort PROP_VOICE_DATA_CODEC_WMAVOICE_V90 = 1;
        public const ushort PROP_VOICE_DATA_CODEC_SASE3200     = 2;
        // All message types can contain a photo attachment in the following properties.  Both
        // of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_PHOTO message
        // flag can be used to test for the presence of these properties before the message details have been
        // retrieved.  
        public const ushort MSG_PROP_PHOTO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT<< 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 6);
        public const ushort MSG_PROP_PHOTO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2        << 8) | (MSG_PROP_ID_GLOBAL | MSG_PROP_ID_BUILTIN | 7);
        
        public const ushort PROP_PHOTO_DATA_CODEC_PNG    = 1;

        //
        // Video Message Properties
        //
        public const ushort MSG_PROP_VIDEO_FRAME_DATA    = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 1);
        //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort MSG_PROP_VIDEO_FRAME_CODEC   = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 2);          
        public const ushort MSG_PROP_VIDEO_DATA          = ((ushort)MSG_PROP_TYPE_ATTACHMENT << 8) | (MSG_PROP_ID_BUILTIN | 3);
        public const ushort MSG_PROP_VIDEO_DATA_CODEC    = ((ushort)MSG_PROP_TYPE_I2         << 8) | (MSG_PROP_ID_BUILTIN | 4);
        public const ushort MSG_PROP_VIDEO_DATA_DURATION = ((ushort)MSG_PROP_TYPE_I4         << 8) | (MSG_PROP_ID_BUILTIN | 5);


        //
        //  HResult
        //
        public const uint E_USER_EXISTS = 0x80070524;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Achievements.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.protocol;

namespace live.server
{
    public class Achievements
    {

        public static SyncAchievementsResponse SyncAchievements(IClient client, XblUser user, uint titleId, Achievement[] alist)
        {
            METHOD.ENTER();
            SyncAchievementsRequest req = new SyncAchievementsRequest();
            req.TitleId = titleId; 
            req.UserId = user.Puid;
            req.Achievements = alist;
            SyncAchievementsResponse resp = new SyncAchievementsResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }



        public static AchievementEnumResponse EnumAchievement(IClient client, XblUser user, uint titleId, ulong friend, ushort locale, ushort start, ushort count)
        {
            METHOD.ENTER();
            AchievementEnumRequest req = new AchievementEnumRequest();
            req.TitleId = titleId; 
            req.Puid = user.Puid; 
            req.ForPuid = friend; 
            req.LocaleId = locale; 
            req.StartingIndex = start;

            AchievementEnumResponse resp = new AchievementEnumResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Catalog.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

using live.common;
using live.common.next;
using live.protocol.next;

namespace live.server.next
{
    public static class Catalog
    {
        public static uint SendRequest(
            IClient client,
            CatalogRequest reqOb,
            CatalogResponse respOb)
        {
            METHOD.ENTER();

            uint hr = client.SendRequest(null, XOService.Catalog,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            Logging.WriteHResult(hr);

            METHOD.EXIT();
            return hr;
        }

        public static CatalogResponse SendRequest(IClient client, CatalogRequest request)
        {
            METHOD.ENTER();
            CatalogResponse catalogResp = new CatalogResponse();

            uint hr = SendRequest(client, request, catalogResp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return catalogResp;
        }

        public static CatalogResponse TestConnection(IClient client, TestConnectionFilter filter)
        {
            METHOD.ENTER();
            TestConnectionRequest req = new TestConnectionRequest(filter);
            CatalogResponse resp = SendRequest(client, req);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse HelloWorld(IClient client, CatalogRequest req)
        {
            METHOD.ENTER();
            CatalogResponse resp = SendRequest(client, req);
            METHOD.EXIT();
            return resp;
        }
        /*
        public static CatalogResponse HelloWorld(IClient client, HelloWorldFilter filter)
        {
            METHOD.ENTER();
            HelloWorldRequest req = new HelloWorldRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse PurchaseHistory(IClient client, PurchaseHistoryFilter filter)
        {
            METHOD.ENTER();
            PurchaseHistoryRequest req = new PurchaseHistoryRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }
        */
        public static CatalogResponse FindCategories(IClient client, FindCategoriesFilter filter)
        {
            METHOD.ENTER();
            FindCategoriesRequest req = new FindCategoriesRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindFeaturedPodcasts(IClient client, FindFeaturedPodcastsFilter filter)
        {
            METHOD.ENTER();
            FindFeaturedPodcastsRequest req = new FindFeaturedPodcastsRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindGameOffers(IClient client, FindGameOffersFilter filter)
        {
            METHOD.ENTER();
            FindGameOffersRequest req = new FindGameOffersRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindGames(IClient client, FindGamesFilter filter)
        {
            METHOD.ENTER();
            FindGamesRequest req = new FindGamesRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindGamesFTS(IClient client, FindGamesFTSFilter filter)
        {
            METHOD.ENTER();
            FindGamesFTSRequest req = new FindGamesFTSRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindImages(IClient client, FindImagesFilter filter)
        {
            METHOD.ENTER();
            FindImagesRequest req = new FindImagesRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindMedia(IClient client, FindMediaFilter filter)
        {
            METHOD.ENTER();
            FindMediaRequest req = new FindMediaRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindMediaFTS(IClient client, FindMediaFTSFilter filter)
        {
            METHOD.ENTER();
            FindMediaFTSRequest req = new FindMediaFTSRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindMediaOffers(IClient client, FindMediaOffersFilter filter)
        {
            METHOD.ENTER();
            FindMediaOffersRequest req = new FindMediaOffersRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindPodcasts(IClient client, FindPodcastsFilter filter)
        {
            METHOD.ENTER();
            FindPodcastsRequest req = new FindPodcastsRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindPodcastsFTS(IClient client, FindPodcastsFTSFilter filter)
        {
            METHOD.ENTER();
            FindPodcastsFTSRequest req = new FindPodcastsFTSRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindRelatedMedia(IClient client, FindRelatedMediaFilter filter)
        {
            METHOD.ENTER();
            FindRelatedMediaRequest req = new FindRelatedMediaRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindVideoOffers(IClient client, FindVideoOffersFilter filter)
        {
            METHOD.ENTER();
            FindVideoOffersRequest req = new FindVideoOffersRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindVideos(IClient client, FindVideosFilter filter)
        {
            METHOD.ENTER();
            FindVideosRequest req = new FindVideosRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse FindVideosFTS(IClient client, FindVideosFTSFilter filter)
        {
            METHOD.ENTER();
            FindVideosFTSRequest req = new FindVideosFTSRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }
        /*
        public static CatalogResponse ReportConcern(IClient client, ReportConcernFilter filter)
        {
            METHOD.ENTER();
            ReportConcernRequest req = new ReportConcernRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static CatalogResponse SubmitPodcast(IClient client, SubmitPodcastFilter filter)
        {
            METHOD.ENTER();
            SubmitPodcastRequest req = new SubmitPodcastRequest(filter);
            CatalogResponse resp = new CatalogResponse();

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp;
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\proxy\CertUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.Security.Principal;
using live.common;
using System.Web.Services.Protocols;
using XOService = live.common.XOService;
using System.Net;
using System.Net.Security;

namespace live.protocol.proxy
{
    class CertUtil
    {
        public static X509Certificate GetCurrentUserCertificate(string certSubject)
        {
            // call LoadUserProfile
            IntPtr logonToken = WindowsIdentity.GetCurrent().Token;

            PROFILEINFO info = new PROFILEINFO();
            info.dwSize = Marshal.SizeOf(info);
            info.lpUserName = WindowsIdentity.GetCurrent().Name;
            info.dwFlags = 1; // P_NOUI

            if (false == WinApiLoadUserProfile(logonToken, ref info))
            {
                throw new System.ComponentModel.Win32Exception();
            }

            uint dwFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetLocalMachineCertificate(string certSubject)
        {
            uint dwFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetCertificate(uint dwFlags, string certSubject)
        {
            IntPtr hSystemStore = IntPtr.Zero;
            IntPtr hCert = IntPtr.Zero;

            try
            {
                hSystemStore = WinApiCertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                    0, IntPtr.Zero, dwFlags, "MY");

                if (hSystemStore == IntPtr.Zero)
                {
                    throw new Exception("WinApiCertOpenStore failed. Error=" +
                        Marshal.GetLastWin32Error());
                }

                hCert = WinApiCertFindCertificateInStore(hSystemStore,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0,
                    CERT_FIND_SUBJECT_STR_W, certSubject, IntPtr.Zero);

                if (hCert == IntPtr.Zero)
                {
                    throw new Exception(string.Format("Failed to find certificate '{0}'. Error={1}",
                        certSubject, Marshal.GetLastWin32Error()));
                }

                return new X509Certificate(hCert);
            }
            finally
            {
                if (hCert != IntPtr.Zero)
                    WinApiCertFreeCertificateContext(hCert);

                if (hSystemStore != IntPtr.Zero)
                {
                    if (WinApiCertCloseStore(hSystemStore, 0) == 0)
                    {
                        throw new Exception("WinApiCertCloseStore failed. Error=" + Marshal.GetLastWin32Error());
                    }
                }
            }
        }

        struct PROFILEINFO
        {
            public int dwSize;
            public int dwFlags;
            public String lpUserName;
            public String lpProfilePath;
            public String lpDefaultPath;
            public String lpServerName;
            public String lpPolicyPath;
            public IntPtr hProfile;
        }

        [DllImport("userenv.dll", EntryPoint = "LoadUserProfile", SetLastError = true, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]
        static extern bool WinApiLoadUserProfile(IntPtr hToken, ref PROFILEINFO lpProfileInfo);


        [DllImport("crypt32.dll", EntryPoint = "CryptDecodeObject",
            ExactSpelling = true, SetLastError = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern int WinApiCryptDecodeObject(
            UInt32 dwCertEncodingType,
            UInt32 structType,
            byte[] pbEncoded,
            UInt32 cbEncoded,
            UInt32 dwFlags,
            byte[] pvStructInfo,
            ref UInt32 pcbStructInfo);

        [DllImport("crypt32.dll", EntryPoint = "CertCreateCertificateContext",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertCreateCertificateContext(
            UInt32 dwCertEncodingType,
            byte[] pbCertEncoded,
            UInt32 cbCertEncoded);

        [DllImport("crypt32.dll", EntryPoint = "CertGetCertificateContextProperty",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertGetCertificateContextProperty(
            IntPtr pCertContext,
            UInt32 dwPropId,
            byte[] pvData,
            ref UInt32 pcbData);

        [DllImport("crypt32.dll", EntryPoint = "CertFreeCertificateContext",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertFreeCertificateContext(
            IntPtr pCertContext);

        [DllImport("crypt32.dll", EntryPoint = "CertOpenStore",
            SetLastError = true, ExactSpelling = true, CharSet = CharSet.Unicode,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertOpenStore(
            UInt32 storeProvider,
            UInt32 dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            UInt32 dwFlags,
            string pvPara);

        [DllImport("crypt32.dll", EntryPoint = "CertFindCertificateInStore",
            SetLastError = true, ExactSpelling = true, CharSet = CharSet.Unicode,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertFindCertificateInStore(
          IntPtr hCertStore,
          UInt32 dwCertEncodingType,
          UInt32 dwFindFlags,
          UInt32 dwFindType,
          string pvFindPara,
          IntPtr pPrevCertContext);

        [DllImport("crypt32.dll", EntryPoint = "CertCloseStore",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertCloseStore(
            IntPtr hCertStore,
            UInt32 dwFlags);

        protected const UInt32 CRYPT_ASN_ENCODING = 0x00000001;
        protected const UInt32 CERT_KEY_IDENTIFIER_PROP_ID = 20;
        protected const UInt32 RSA_CSP_PUBLICKEYBLOB = 19;
        protected const UInt32 X509_ASN_ENCODING = 0x00000001;
        protected const UInt32 PKCS_7_ASN_ENCODING = 0x00010000;
        protected const byte PUBLICKEYBLOB = 0x6;
        protected const byte CUR_BLOB_VERSION = 2;
        protected const UInt32 ALG_CLASS_SIGNATURE = (1 << 13);
        protected const UInt32 ALG_CLASS_KEY_EXCHANGE = (5 << 13);
        protected const UInt32 ALG_TYPE_RSA = (2 << 9);
        protected const UInt32 ALG_SID_RSA_ANY = 0;
        protected const UInt32 CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY);
        protected const UInt32 CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_RSA | ALG_SID_RSA_ANY);
        protected const UInt32 CERT_STORE_PROV_SYSTEM_W = 10;
        protected const Int32 CERT_SYSTEM_STORE_LOCATION_SHIFT = 16;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER = (CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE = (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_COMPARE_NAME_STR_W = 8;
        protected const Int32 CERT_COMPARE_SHIFT = 16;
        protected const UInt32 CERT_INFO_SUBJECT_FLAG = 7;
        protected const UInt32 CERT_FIND_SUBJECT_STR_W = (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | CERT_INFO_SUBJECT_FLAG);
        protected const UInt32 CERT_CLOSE_STORE_FORCE_FLAG = 0x00000001;
        protected const UInt32 CERT_CLOSE_STORE_CHECK_FLAG = 0x00000002;
        protected const UInt32 CERT_STORE_READONLY_FLAG = 0x00008000;

        public static X509Certificate GetCertForService(live.common.XOService service) 
        {
            ServiceInfo info = Config.Current.GetServiceInfo(null, service);
            if (string.IsNullOrEmpty(info.Cert)) 
            {
                return null;
            }
            string[] certParts = info.Cert.Split(':');
            if (certParts.Length != 2) 
            {
                return null;
            }
            if (certParts[0] == "mach")
            {
                return GetLocalMachineCertificate(certParts[1]);
            }
            else if (certParts[0] == "user")
            {
                return GetCurrentUserCertificate(certParts[1]);
            }
            else if (certParts[0] == "file")
            {
                return new X509Certificate(certParts[1]);
            }
            else
            {
                return null;
            }
        }

        public static void SetCertForService(live.common.XOService service, SoapHttpClientProtocol protocol)
        {
            X509Certificate cert = GetCertForService(service);
            if (cert != null)
            {
                Logging.WriteLine("DEBUG", "Got Cert: {0} ", cert.Subject);
                protocol.ClientCertificates.Add(cert);
            }
        }

        private static bool AcceptAllCerts(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {

            // using cert parameter we can have a validation logic whether we will be accepting the certificate or not.
            live.common.Logging.WriteLine(string.Format("WARNING: Got server certificate error: {0} \t{1} \t{2}", sslPolicyErrors.ToString(), cert.Subject, chain.ChainElements.Count));
            return true;
        }

        static CertUtil()
        {
            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(AcceptAllCerts);
            ServicePointManager.DefaultConnectionLimit = 220;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\protocol\proxy\TestGateway20Proxy.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.832
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 

#pragma warning disable 1591

using live.common;

namespace live.protocol.proxy {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "WebClientProxySoap", Namespace = "http://test.xbox.com/")]
    public partial class WebClientProxy : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback SendRequestOperationCompleted;

        private bool useDefaultCredentialsSetExplicitly;

        /// <remarks/>
        public WebClientProxy()
        {
            this.Url = "http://10.198.102.221/WebClientProxy.asmx";
            if ((this.IsLocalFileSystemWebService(this.Url) == true))
            {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else
            {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }

        public new string Url
        {
            get
            {
                return base.Url;
            }
            set
            {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true)
                            && (this.useDefaultCredentialsSetExplicitly == false))
                            && (this.IsLocalFileSystemWebService(value) == false)))
                {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }

        public new bool UseDefaultCredentials
        {
            get
            {
                return base.UseDefaultCredentials;
            }
            set
            {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }

        /// <remarks/>
        public event SendRequestCompletedEventHandler SendRequestCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SendRequest", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint SendRequest(ClientSettings clientSettings, TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] request, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] out byte[] response)
        {
            object[] results = this.Invoke("SendRequest", new object[] {
                        clientSettings,
                        secProv,
                        service,
                        relativeUrl,
                        httpMethod,
                        webHeaders,
                        request});
            response = ((byte[])(results[1]));
            return ((uint)(results[0]));
        }

        /// <remarks/>
        public void SendRequestAsync(ClientSettings clientSettings, TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, byte[] request)
        {
            this.SendRequestAsync(clientSettings, secProv, service, relativeUrl, httpMethod, webHeaders, request, null);
        }

        /// <remarks/>
        public void SendRequestAsync(ClientSettings clientSettings, TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, byte[] request, object userState)
        {
            if ((this.SendRequestOperationCompleted == null))
            {
                this.SendRequestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendRequestOperationCompleted);
            }
            this.InvokeAsync("SendRequest", new object[] {
                        clientSettings,
                        secProv,
                        service,
                        relativeUrl,
                        httpMethod,
                        webHeaders,
                        request}, this.SendRequestOperationCompleted, userState);
        }

        private void OnSendRequestOperationCompleted(object arg)
        {
            if ((this.SendRequestCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendRequestCompleted(this, new SendRequestCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }

        private bool IsLocalFileSystemWebService(string url)
        {
            if (((url == null)
                        || (url == string.Empty)))
            {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024)
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0)))
            {
                return true;
            }
            return false;
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://test.xbox.com/")]
    public partial class TG2SecurityProvider
    {

        private uint titleIdField;

        private CSGInfo securityInfoField;

        /// <remarks/>
        public uint TitleId
        {
            get
            {
                return this.titleIdField;
            }
            set
            {
                this.titleIdField = value;
            }
        }

        /// <remarks/>
        public CSGInfo SecurityInfo
        {
            get
            {
                return this.securityInfoField;
            }
            set
            {
                this.securityInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://test.xbox.com/")]
    public partial class CSGInfo
    {

        private uint inaSgField;

        private uint spiSgField;

        private uint ipaIField;

        private ushort ipportIField;

        private long liNonceField;

        private ulong machinePuidField;

        private uint titleIdField;

        private uint titleVersionField;

        private uint titleRegionField;

        private uint consoleRegionField;

        private uint mediaIDField;

        private ushort languageIDField;

        private uint authDataFlagsField;

        private ushort wMajorVersionField;

        private ushort wMinorVersionField;

        private ushort wBuildNumberField;

        private ushort wQFENumberField;

        private ulong userPuid0Field;

        private ulong userPuid1Field;

        private ulong userPuid2Field;

        private ulong userPuid3Field;

        private uint userFlag0Field;

        private uint userFlag1Field;

        private uint userFlag2Field;

        private uint userFlag3Field;

        private ushort wNumPrivilegesField;
        
        private uint dwPrivileges4Field;
        
        private uint dwPrivileges5Field;
        
        private uint dwPrivileges6Field;
        
        private uint dwPrivileges7Field;
        
        public uint dwPrivileges5User0;
        public uint dwPrivileges6User0;
        public uint dwPrivileges7User0;
        public uint dwPrivileges5User1;
        public uint dwPrivileges6User1;
        public uint dwPrivileges7User1;
        public uint dwPrivileges5User2;
        public uint dwPrivileges6User2;
        public uint dwPrivileges7User2;
        public uint dwPrivileges5User3;
        public uint dwPrivileges6User3;
        public uint dwPrivileges7User3;
        
        private uint dwPrivileges0Field;
        
        private uint dwPrivileges1Field;
        
        private uint dwPrivileges2Field;
        
        private uint dwPrivileges3Field;

        private ushort wNumDwordServicesField;

        private uint dwServiceID0Field;

        private uint dwServiceID1Field;

        private uint dwServiceID2Field;

        private uint dwServiceID3Field;

        private float userTrust0Field;

        private float userTrust1Field;

        private float userTrust2Field;

        private float userTrust3Field;

        private uint altTitleId0Field;

        private uint altTitleId1Field;

        private uint altTitleId2Field;

        private uint altTitleId3Field;

        private byte key00Field;

        private byte key01Field;

        private byte key02Field;

        private byte key03Field;

        private byte key04Field;

        private byte key05Field;

        private byte key06Field;

        private byte key07Field;

        private byte key08Field;

        private byte key09Field;

        private byte key10Field;

        private byte key11Field;

        private byte key12Field;

        private byte key13Field;

        private byte key14Field;

        private byte key15Field;

        private byte userExistsField;

        private ushort portField;

        private ulong clientVersionField;

        /// <remarks/>
        public uint inaSg
        {
            get
            {
                return this.inaSgField;
            }
            set
            {
                this.inaSgField = value;
            }
        }

        /// <remarks/>
        public uint SpiSg
        {
            get
            {
                return this.spiSgField;
            }
            set
            {
                this.spiSgField = value;
            }
        }

        /// <remarks/>
        public uint ipaI
        {
            get
            {
                return this.ipaIField;
            }
            set
            {
                this.ipaIField = value;
            }
        }

        /// <remarks/>
        public ushort ipportI
        {
            get
            {
                return this.ipportIField;
            }
            set
            {
                this.ipportIField = value;
            }
        }

        /// <remarks/>
        public long liNonce
        {
            get
            {
                return this.liNonceField;
            }
            set
            {
                this.liNonceField = value;
            }
        }

        /// <remarks/>
        public ulong machinePuid
        {
            get
            {
                return this.machinePuidField;
            }
            set
            {
                this.machinePuidField = value;
            }
        }

        /// <remarks/>
        public uint titleId
        {
            get
            {
                return this.titleIdField;
            }
            set
            {
                this.titleIdField = value;
            }
        }

        /// <remarks/>
        public uint titleVersion
        {
            get
            {
                return this.titleVersionField;
            }
            set
            {
                this.titleVersionField = value;
            }
        }

        /// <remarks/>
        public uint titleRegion
        {
            get
            {
                return this.titleRegionField;
            }
            set
            {
                this.titleRegionField = value;
            }
        }

        /// <remarks/>
        public uint consoleRegion
        {
            get
            {
                return this.consoleRegionField;
            }
            set
            {
                this.consoleRegionField = value;
            }
        }

        /// <remarks/>
        public uint mediaID
        {
            get
            {
                return this.mediaIDField;
            }
            set
            {
                this.mediaIDField = value;
            }
        }

        /// <remarks/>
        public ushort languageID
        {
            get
            {
                return this.languageIDField;
            }
            set
            {
                this.languageIDField = value;
            }
        }

        /// <remarks/>
        public uint authDataFlags
        {
            get
            {
                return this.authDataFlagsField;
            }
            set
            {
                this.authDataFlagsField = value;
            }
        }

        /// <remarks/>
        public ushort wMajorVersion
        {
            get
            {
                return this.wMajorVersionField;
            }
            set
            {
                this.wMajorVersionField = value;
            }
        }

        /// <remarks/>
        public ushort wMinorVersion
        {
            get
            {
                return this.wMinorVersionField;
            }
            set
            {
                this.wMinorVersionField = value;
            }
        }

        /// <remarks/>
        public ushort wBuildNumber
        {
            get
            {
                return this.wBuildNumberField;
            }
            set
            {
                this.wBuildNumberField = value;
            }
        }

        /// <remarks/>
        public ushort wQFENumber
        {
            get
            {
                return this.wQFENumberField;
            }
            set
            {
                this.wQFENumberField = value;
            }
        }

        /// <remarks/>
        public ulong userPuid0
        {
            get
            {
                return this.userPuid0Field;
            }
            set
            {
                this.userPuid0Field = value;
            }
        }

        /// <remarks/>
        public ulong userPuid1
        {
            get
            {
                return this.userPuid1Field;
            }
            set
            {
                this.userPuid1Field = value;
            }
        }

        /// <remarks/>
        public ulong userPuid2
        {
            get
            {
                return this.userPuid2Field;
            }
            set
            {
                this.userPuid2Field = value;
            }
        }

        /// <remarks/>
        public ulong userPuid3
        {
            get
            {
                return this.userPuid3Field;
            }
            set
            {
                this.userPuid3Field = value;
            }
        }

        /// <remarks/>
        public uint userFlag0
        {
            get
            {
                return this.userFlag0Field;
            }
            set
            {
                this.userFlag0Field = value;
            }
        }

        /// <remarks/>
        public uint userFlag1
        {
            get
            {
                return this.userFlag1Field;
            }
            set
            {
                this.userFlag1Field = value;
            }
        }

        /// <remarks/>
        public uint userFlag2
        {
            get
            {
                return this.userFlag2Field;
            }
            set
            {
                this.userFlag2Field = value;
            }
        }

        /// <remarks/>
        public uint userFlag3
        {
            get
            {
                return this.userFlag3Field;
            }
            set
            {
                this.userFlag3Field = value;
            }
        }

        /// <remarks/>
        public ushort wNumPrivileges
        {
            get
            {
                return this.wNumPrivilegesField;
            }
            set
            {
                this.wNumPrivilegesField = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges0
        {
            get
            {
                return this.dwPrivileges0Field;
            }
            set
            {
                this.dwPrivileges0Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges1
        {
            get
            {
                return this.dwPrivileges1Field;
            }
            set
            {
                this.dwPrivileges1Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges2
        {
            get
            {
                return this.dwPrivileges2Field;
            }
            set
            {
                this.dwPrivileges2Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges3
        {
            get
            {
                return this.dwPrivileges3Field;
            }
            set
            {
                this.dwPrivileges3Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges4
        {
            get
            {
                return this.dwPrivileges4Field;
            }
            set
            {
                this.dwPrivileges4Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges5
        {
            get
            {
                return this.dwPrivileges5Field;
            }
            set
            {
                this.dwPrivileges5Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges6
        {
            get
            {
                return this.dwPrivileges6Field;
            }
            set
            {
                this.dwPrivileges6Field = value;
            }
        }

        /// <remarks/>
        public uint dwPrivileges7
        {
            get
            {
                return this.dwPrivileges7Field;
            }
            set
            {
                this.dwPrivileges7Field = value;
            }
        }

        /// <remarks/>
        public ushort wNumDwordServices
        {
            get
            {
                return this.wNumDwordServicesField;
            }
            set
            {
                this.wNumDwordServicesField = value;
            }
        }

        /// <remarks/>
        public uint dwServiceID0
        {
            get
            {
                return this.dwServiceID0Field;
            }
            set
            {
                this.dwServiceID0Field = value;
            }
        }

        /// <remarks/>
        public uint dwServiceID1
        {
            get
            {
                return this.dwServiceID1Field;
            }
            set
            {
                this.dwServiceID1Field = value;
            }
        }

        /// <remarks/>
        public uint dwServiceID2
        {
            get
            {
                return this.dwServiceID2Field;
            }
            set
            {
                this.dwServiceID2Field = value;
            }
        }

        /// <remarks/>
        public uint dwServiceID3
        {
            get
            {
                return this.dwServiceID3Field;
            }
            set
            {
                this.dwServiceID3Field = value;
            }
        }

        /// <remarks/>
        public float userTrust0
        {
            get
            {
                return this.userTrust0Field;
            }
            set
            {
                this.userTrust0Field = value;
            }
        }

        /// <remarks/>
        public float userTrust1
        {
            get
            {
                return this.userTrust1Field;
            }
            set
            {
                this.userTrust1Field = value;
            }
        }

        /// <remarks/>
        public float userTrust2
        {
            get
            {
                return this.userTrust2Field;
            }
            set
            {
                this.userTrust2Field = value;
            }
        }

        /// <remarks/>
        public float userTrust3
        {
            get
            {
                return this.userTrust3Field;
            }
            set
            {
                this.userTrust3Field = value;
            }
        }

        /// <remarks/>
        public uint altTitleId0
        {
            get
            {
                return this.altTitleId0Field;
            }
            set
            {
                this.altTitleId0Field = value;
            }
        }

        /// <remarks/>
        public uint altTitleId1
        {
            get
            {
                return this.altTitleId1Field;
            }
            set
            {
                this.altTitleId1Field = value;
            }
        }

        /// <remarks/>
        public uint altTitleId2
        {
            get
            {
                return this.altTitleId2Field;
            }
            set
            {
                this.altTitleId2Field = value;
            }
        }

        /// <remarks/>
        public uint altTitleId3
        {
            get
            {
                return this.altTitleId3Field;
            }
            set
            {
                this.altTitleId3Field = value;
            }
        }

        /// <remarks/>
        public byte key00
        {
            get
            {
                return this.key00Field;
            }
            set
            {
                this.key00Field = value;
            }
        }

        /// <remarks/>
        public byte key01
        {
            get
            {
                return this.key01Field;
            }
            set
            {
                this.key01Field = value;
            }
        }

        /// <remarks/>
        public byte key02
        {
            get
            {
                return this.key02Field;
            }
            set
            {
                this.key02Field = value;
            }
        }

        /// <remarks/>
        public byte key03
        {
            get
            {
                return this.key03Field;
            }
            set
            {
                this.key03Field = value;
            }
        }

        /// <remarks/>
        public byte key04
        {
            get
            {
                return this.key04Field;
            }
            set
            {
                this.key04Field = value;
            }
        }

        /// <remarks/>
        public byte key05
        {
            get
            {
                return this.key05Field;
            }
            set
            {
                this.key05Field = value;
            }
        }

        /// <remarks/>
        public byte key06
        {
            get
            {
                return this.key06Field;
            }
            set
            {
                this.key06Field = value;
            }
        }

        /// <remarks/>
        public byte key07
        {
            get
            {
                return this.key07Field;
            }
            set
            {
                this.key07Field = value;
            }
        }

        /// <remarks/>
        public byte key08
        {
            get
            {
                return this.key08Field;
            }
            set
            {
                this.key08Field = value;
            }
        }

        /// <remarks/>
        public byte key09
        {
            get
            {
                return this.key09Field;
            }
            set
            {
                this.key09Field = value;
            }
        }

        /// <remarks/>
        public byte key10
        {
            get
            {
                return this.key10Field;
            }
            set
            {
                this.key10Field = value;
            }
        }

        /// <remarks/>
        public byte key11
        {
            get
            {
                return this.key11Field;
            }
            set
            {
                this.key11Field = value;
            }
        }

        /// <remarks/>
        public byte key12
        {
            get
            {
                return this.key12Field;
            }
            set
            {
                this.key12Field = value;
            }
        }

        /// <remarks/>
        public byte key13
        {
            get
            {
                return this.key13Field;
            }
            set
            {
                this.key13Field = value;
            }
        }

        /// <remarks/>
        public byte key14
        {
            get
            {
                return this.key14Field;
            }
            set
            {
                this.key14Field = value;
            }
        }

        /// <remarks/>
        public byte key15
        {
            get
            {
                return this.key15Field;
            }
            set
            {
                this.key15Field = value;
            }
        }

        /// <remarks/>
        public byte UserExists
        {
            get
            {
                return this.userExistsField;
            }
            set
            {
                this.userExistsField = value;
            }
        }

        /// <remarks/>
        public ushort port
        {
            get
            {
                return this.portField;
            }
            set
            {
                this.portField = value;
            }
        }

        /// <remarks/>
        public ulong clientVersion
        {
            get
            {
                return this.clientVersionField;
            }
            set
            {
                this.clientVersionField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://test.xbox.com/")]
    public enum XOService
    {

        /// <remarks/>
        InvalidService,

        /// <remarks/>
        PresNotification,

        /// <remarks/>
        StringService,

        /// <remarks/>
        Auto_Update,

        /// <remarks/>
        Base_Subscription,

        /// <remarks/>
        User_Account,

        /// <remarks/>
        Matchmaking,

        /// <remarks/>
        Stats,

        /// <remarks/>
        Feedback,

        /// <remarks/>
        Billing_Offering,

        /// <remarks/>
        Lists,

        /// <remarks/>
        Tous,

        /// <remarks/>
        Signature_Server,

        /// <remarks/>
        Query,

        /// <remarks/>
        Name_Resolution,

        /// <remarks/>
        Storage,

        /// <remarks/>
        Arbitration,

        /// <remarks/>
        Cron,

        /// <remarks/>
        MessagingService,

        /// <remarks/>
        Teams,

        /// <remarks/>
        NatDetection,

        /// <remarks/>
        DRM,

        /// <remarks/>
        Massive,

        /// <remarks/>
        PCLocator,

        /// <remarks/>
        Crypto,

        /// <remarks/>
        liveinfo,

        /// <remarks/>
        MaxService,

        /// <remarks/>
        Catalog = 175,

        /// <remarks/>
        WebBilling,

        /// <remarks/>
        WebAccounts,

        /// <remarks/>
        Cust,

        /// <remarks/>
        KDCSvc,

        /// <remarks/>
        signature_internal,

        /// <remarks/>
        ActiveAuthSg,

        /// <remarks/>
        User_Account_Internal
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SendRequestCompletedEventHandler(object sender, SendRequestCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendRequestCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SendRequestCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public uint Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }

        /// <remarks/>
        public byte[] response
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((byte[])(this.results[1]));
            }
        }
    }
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "FakeSGProxySoap", Namespace = "http://test.xbox.com/")]
    public partial class FakeSGProxy : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback LoadSlotOperationCompleted;

        private System.Threading.SendOrPostCallback AddXboxOperationCompleted;

        private System.Threading.SendOrPostCallback RemoveXboxOperationCompleted;

        private System.Threading.SendOrPostCallback DeadXboxOperationCompleted;

        private System.Threading.SendOrPostCallback ClearXboxesOperationCompleted;

        private System.Threading.SendOrPostCallback SetTitleOperationCompleted;

        private System.Threading.SendOrPostCallback SetAltTitlesOperationCompleted;

        private System.Threading.SendOrPostCallback SetKeyOperationCompleted;

        private System.Threading.SendOrPostCallback SetUserStateOperationCompleted;

        private System.Threading.SendOrPostCallback SetEnableStateBatchingOperationCompleted;

        private System.Threading.SendOrPostCallback SetStateEndpointOperationCompleted;

        private System.Threading.SendOrPostCallback AddUserOperationCompleted;

        private System.Threading.SendOrPostCallback RemoveUserOperationCompleted;

        private System.Threading.SendOrPostCallback GetUserCountOperationCompleted;

        private System.Threading.SendOrPostCallback ReadUserQValPacketOperationCompleted;

        private System.Threading.SendOrPostCallback GetInaSGOperationCompleted;

        private bool useDefaultCredentialsSetExplicitly;

        /// <remarks/>
        public FakeSGProxy()
        {
            this.Url = "http://10.198.102.221/FakeSGProxy.asmx";
            if ((this.IsLocalFileSystemWebService(this.Url) == true))
            {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else
            {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }

        public new string Url
        {
            get
            {
                return base.Url;
            }
            set
            {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true)
                            && (this.useDefaultCredentialsSetExplicitly == false))
                            && (this.IsLocalFileSystemWebService(value) == false)))
                {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }

        public new bool UseDefaultCredentials
        {
            get
            {
                return base.UseDefaultCredentials;
            }
            set
            {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }

        /// <remarks/>
        public event LoadSlotCompletedEventHandler LoadSlotCompleted;

        /// <remarks/>
        public event AddXboxCompletedEventHandler AddXboxCompleted;

        /// <remarks/>
        public event RemoveXboxCompletedEventHandler RemoveXboxCompleted;

        /// <remarks/>
        public event DeadXboxCompletedEventHandler DeadXboxCompleted;

        /// <remarks/>
        public event ClearXboxesCompletedEventHandler ClearXboxesCompleted;

        /// <remarks/>
        public event SetTitleCompletedEventHandler SetTitleCompleted;

        /// <remarks/>
        public event SetAltTitlesCompletedEventHandler SetAltTitlesCompleted;

        /// <remarks/>
        public event SetKeyCompletedEventHandler SetKeyCompleted;

        /// <remarks/>
        public event SetUserStateCompletedEventHandler SetUserStateCompleted;

        /// <remarks/>
        public event SetEnableStateBatchingCompletedEventHandler SetEnableStateBatchingCompleted;

        /// <remarks/>
        public event SetStateEndpointCompletedEventHandler SetStateEndpointCompleted;

        /// <remarks/>
        public event AddUserCompletedEventHandler AddUserCompleted;

        /// <remarks/>
        public event RemoveUserCompletedEventHandler RemoveUserCompleted;

        /// <remarks/>
        public event GetUserCountCompletedEventHandler GetUserCountCompleted;

        /// <remarks/>
        public event ReadUserQValPacketCompletedEventHandler ReadUserQValPacketCompleted;

        /// <remarks/>
        public event GetInaSGCompletedEventHandler GetInaSGCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/LoadSlot", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LoadSlot(ref CSGInfo sgInfo, ulong xboxId)
        {
            object[] results = this.Invoke("LoadSlot", new object[] {
                        sgInfo,
                        xboxId});
            sgInfo = ((CSGInfo)(results[0]));
        }

        /// <remarks/>
        public void LoadSlotAsync(CSGInfo sgInfo, ulong xboxId)
        {
            this.LoadSlotAsync(sgInfo, xboxId, null);
        }

        /// <remarks/>
        public void LoadSlotAsync(CSGInfo sgInfo, ulong xboxId, object userState)
        {
            if ((this.LoadSlotOperationCompleted == null))
            {
                this.LoadSlotOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLoadSlotOperationCompleted);
            }
            this.InvokeAsync("LoadSlot", new object[] {
                        sgInfo,
                        xboxId}, this.LoadSlotOperationCompleted, userState);
        }

        private void OnLoadSlotOperationCompleted(object arg)
        {
            if ((this.LoadSlotCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LoadSlotCompleted(this, new LoadSlotCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/AddXbox", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddXbox(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] key, ulong clientVersion, ClientType clientType, uint languageId)
        {
            this.Invoke("AddXbox", new object[] {
                        sgIp,
                        spi,
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion,
                        key,
                        clientVersion,
                        clientType,
                        languageId});
        }

        /// <remarks/>
        public void AddXboxAsync(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, ClientType clientType, uint languageId)
        {
            this.AddXboxAsync(sgIp, spi, xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId, null);
        }

        /// <remarks/>
        public void AddXboxAsync(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, ClientType clientType, uint languageId, object userState)
        {
            if ((this.AddXboxOperationCompleted == null))
            {
                this.AddXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddXboxOperationCompleted);
            }
            this.InvokeAsync("AddXbox", new object[] {
                        sgIp,
                        spi,
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion,
                        key,
                        clientVersion,
                        clientType,
                        languageId}, this.AddXboxOperationCompleted, userState);
        }

        private void OnAddXboxOperationCompleted(object arg)
        {
            if ((this.AddXboxCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/RemoveXbox", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveXbox(ulong xboxId)
        {
            this.Invoke("RemoveXbox", new object[] {
                        xboxId});
        }

        /// <remarks/>
        public void RemoveXboxAsync(ulong xboxId)
        {
            this.RemoveXboxAsync(xboxId, null);
        }

        /// <remarks/>
        public void RemoveXboxAsync(ulong xboxId, object userState)
        {
            if ((this.RemoveXboxOperationCompleted == null))
            {
                this.RemoveXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveXboxOperationCompleted);
            }
            this.InvokeAsync("RemoveXbox", new object[] {
                        xboxId}, this.RemoveXboxOperationCompleted, userState);
        }

        private void OnRemoveXboxOperationCompleted(object arg)
        {
            if ((this.RemoveXboxCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/DeadXbox", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeadXbox(ulong xboxId)
        {
            this.Invoke("DeadXbox", new object[] {
                        xboxId});
        }

        /// <remarks/>
        public void DeadXboxAsync(ulong xboxId)
        {
            this.DeadXboxAsync(xboxId, null);
        }

        /// <remarks/>
        public void DeadXboxAsync(ulong xboxId, object userState)
        {
            if ((this.DeadXboxOperationCompleted == null))
            {
                this.DeadXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeadXboxOperationCompleted);
            }
            this.InvokeAsync("DeadXbox", new object[] {
                        xboxId}, this.DeadXboxOperationCompleted, userState);
        }

        private void OnDeadXboxOperationCompleted(object arg)
        {
            if ((this.DeadXboxCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeadXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/ClearXboxes", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ClearXboxes()
        {
            this.Invoke("ClearXboxes", new object[0]);
        }

        /// <remarks/>
        public void ClearXboxesAsync()
        {
            this.ClearXboxesAsync(null);
        }

        /// <remarks/>
        public void ClearXboxesAsync(object userState)
        {
            if ((this.ClearXboxesOperationCompleted == null))
            {
                this.ClearXboxesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnClearXboxesOperationCompleted);
            }
            this.InvokeAsync("ClearXboxes", new object[0], this.ClearXboxesOperationCompleted, userState);
        }

        private void OnClearXboxesOperationCompleted(object arg)
        {
            if ((this.ClearXboxesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ClearXboxesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetTitle", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetTitle(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            this.Invoke("SetTitle", new object[] {
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion});
        }

        /// <remarks/>
        public void SetTitleAsync(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            this.SetTitleAsync(xboxId, titleId, titleVer, titleRegion, null);
        }

        /// <remarks/>
        public void SetTitleAsync(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, object userState)
        {
            if ((this.SetTitleOperationCompleted == null))
            {
                this.SetTitleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetTitleOperationCompleted);
            }
            this.InvokeAsync("SetTitle", new object[] {
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion}, this.SetTitleOperationCompleted, userState);
        }

        private void OnSetTitleOperationCompleted(object arg)
        {
            if ((this.SetTitleCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetTitleCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetAltTitles", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetAltTitles(ulong xboxId, uint[] altTitleIds)
        {
            this.Invoke("SetAltTitles", new object[] {
                        xboxId,
                        altTitleIds});
        }

        /// <remarks/>
        public void SetAltTitlesAsync(ulong xboxId, uint[] altTitleIds)
        {
            this.SetAltTitlesAsync(xboxId, altTitleIds, null);
        }

        /// <remarks/>
        public void SetAltTitlesAsync(ulong xboxId, uint[] altTitleIds, object userState)
        {
            if ((this.SetAltTitlesOperationCompleted == null))
            {
                this.SetAltTitlesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetAltTitlesOperationCompleted);
            }
            this.InvokeAsync("SetAltTitles", new object[] {
                        xboxId,
                        altTitleIds}, this.SetAltTitlesOperationCompleted, userState);
        }

        private void OnSetAltTitlesOperationCompleted(object arg)
        {
            if ((this.SetAltTitlesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetAltTitlesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetKey", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetKey(ulong xboxId, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] key)
        {
            this.Invoke("SetKey", new object[] {
                        xboxId,
                        key});
        }

        /// <remarks/>
        public void SetKeyAsync(ulong xboxId, byte[] key)
        {
            this.SetKeyAsync(xboxId, key, null);
        }

        /// <remarks/>
        public void SetKeyAsync(ulong xboxId, byte[] key, object userState)
        {
            if ((this.SetKeyOperationCompleted == null))
            {
                this.SetKeyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetKeyOperationCompleted);
            }
            this.InvokeAsync("SetKey", new object[] {
                        xboxId,
                        key}, this.SetKeyOperationCompleted, userState);
        }

        private void OnSetKeyOperationCompleted(object arg)
        {
            if ((this.SetKeyCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetKeyCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetUserState", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] titleData, ushort titleDataLen)
        {
            this.Invoke("SetUserState", new object[] {
                        xboxId,
                        userId,
                        matchSessionId,
                        state,
                        titleData,
                        titleDataLen});
        }

        /// <remarks/>
        public void SetUserStateAsync(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            this.SetUserStateAsync(xboxId, userId, matchSessionId, state, titleData, titleDataLen, null);
        }

        /// <remarks/>
        public void SetUserStateAsync(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen, object userState)
        {
            if ((this.SetUserStateOperationCompleted == null))
            {
                this.SetUserStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserStateOperationCompleted);
            }
            this.InvokeAsync("SetUserState", new object[] {
                        xboxId,
                        userId,
                        matchSessionId,
                        state,
                        titleData,
                        titleDataLen}, this.SetUserStateOperationCompleted, userState);
        }

        private void OnSetUserStateOperationCompleted(object arg)
        {
            if ((this.SetUserStateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserStateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetEnableStateBatching", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetEnableStateBatching(bool enable, uint intervalSeconds)
        {
            this.Invoke("SetEnableStateBatching", new object[] {
                        enable,
                        intervalSeconds});
        }

        /// <remarks/>
        public void SetEnableStateBatchingAsync(bool enable, uint intervalSeconds)
        {
            this.SetEnableStateBatchingAsync(enable, intervalSeconds, null);
        }

        /// <remarks/>
        public void SetEnableStateBatchingAsync(bool enable, uint intervalSeconds, object userState)
        {
            if ((this.SetEnableStateBatchingOperationCompleted == null))
            {
                this.SetEnableStateBatchingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetEnableStateBatchingOperationCompleted);
            }
            this.InvokeAsync("SetEnableStateBatching", new object[] {
                        enable,
                        intervalSeconds}, this.SetEnableStateBatchingOperationCompleted, userState);
        }

        private void OnSetEnableStateBatchingOperationCompleted(object arg)
        {
            if ((this.SetEnableStateBatchingCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetEnableStateBatchingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetStateEndpoint", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetStateEndpoint(string endpoint)
        {
            this.Invoke("SetStateEndpoint", new object[] {
                        endpoint});
        }

        /// <remarks/>
        public void SetStateEndpointAsync(string endpoint)
        {
            this.SetStateEndpointAsync(endpoint, null);
        }

        /// <remarks/>
        public void SetStateEndpointAsync(string endpoint, object userState)
        {
            if ((this.SetStateEndpointOperationCompleted == null))
            {
                this.SetStateEndpointOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetStateEndpointOperationCompleted);
            }
            this.InvokeAsync("SetStateEndpoint", new object[] {
                        endpoint}, this.SetStateEndpointOperationCompleted, userState);
        }

        private void OnSetStateEndpointOperationCompleted(object arg)
        {
            if ((this.SetStateEndpointCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetStateEndpointCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/AddUser", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddUser(ulong xboxId, ulong userId, uint userFlags)
        {
            this.Invoke("AddUser", new object[] {
                        xboxId,
                        userId,
                        userFlags});
        }

        /// <remarks/>
        public void AddUserAsync(ulong xboxId, ulong userId, uint userFlags)
        {
            this.AddUserAsync(xboxId, userId, userFlags, null);
        }

        /// <remarks/>
        public void