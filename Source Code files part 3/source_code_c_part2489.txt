            3024
#define IDC_TI_POSZSPIN                 3025
#define IDC_PIESLICE2                   3025
#define IDC_TEXTUNDERLINE               3025
#define IDC_TI_CLOSE                    3026
#define IDC_TEXTLEFT                    3026
#define IDC_RADSPINNER1                 3027
#define IDC_TI_FINISH                   3027
#define IDC_TEXTCENTER                  3027
#define IDC_CREATECUBE                  3028
#define IDC_TEXTRIGHT                   3028
#define IDC_CREATEBOX                   3029
#define IDC_TEXTJUSTIFIED               3029
#define IDC_FAM_STAR2                   3030
#define IDC_VERT_BASIC                  3031
#define IDC_VERT_CENTER                 3032
#define IDC_VERT_SIDES                  3033
#define IDC_RADIUSSPIN                  3034
#define IDC_MANUAL_CLIP                 3035
#define IDC_CREATEEDGE                  3036
#define IDC_VPT_PARTICLES               3036
#define IDC_CREATECENTER                3037
#define IDC_VPT_PARTICLESSPIN           3037
#define IDC_ARCFROM                     3038
#define IDC_PARTICLE_SIZE               3038
#define IDC_ARCFROMSPINNER              3039
#define IDC_PARTICLE_SIZESPIN           3039
#define IDC_ARCTO                       3040
#define IDC_PARTICLE_START              3040
#define IDC_ARCTOSPINNER                3041
#define IDC_PARTICLE_STARTSPIN          3041
#define IDC_CREATE_EEC                  3042
#define IDC_PARTICLE_LIFE               3042
#define IDC_TEXTFONT                    3042
#define IDC_CREATE_CEE                  3043
#define IDC_PARTICLE_LIFESPIN           3043
#define IDC_TEXTSIZEEDIT                3043
#define IDC_EMITTER_WIDTH               3044
#define IDC_TEXTSIZESPINNER             3044
#define IDC_EMITTER_WIDTHSPIN           3045
#define IDC_TEXTBOLD                    3045
#define IDC_TEXTKERNINGEDIT             3045
#define IDC_EMITTER_HEIGHT              3046
#define IDC_TEXTKERNINGSPINNER          3046
#define IDC_EMITTER_HEIGHTSPIN          3047
#define IDC_TEXTLEADINGEDIT             3047
#define IDC_PARTICLE_SPEED              3048
#define IDC_TEXTLEADINGSPINNER          3048
#define IDC_PARTICLE_SPEEDSPIN          3049
#define IDC_PARTICLE_VARIATION          3050
#define IDC_PARTICLE_VARIATIONSPIN      3051
#define IDC_PARTICLE_CUST               3052
#define IDC_TEXTEXAMPLE                 3053
#define IDC_PARTICLE_BIRTHRATE          3053
#define IDC_PARTICLE_BIRTHRATESPIN      3054
#define IDC_PARTICLE_MAXRATE            3055
#define IDC_NO_CROSSOVER                3056
#define IDC_PARTICLE_TUMBLE             3056
#define IDC_RND_PARTICLES               3056
#define IDC_FAR_RANGE                   3057
#define IDC_PARTICLE_TUMBLESPIN         3057
#define IDC_RND_PARTICLESSPIN           3057
#define IDC_FAR_RANGE_SPIN              3058
#define IDC_PARTICLE_SCALE              3058
#define IDC_NEAR_RANGE                  3059
#define IDC_PARTICLE_SCALESPIN          3059
#define IDC_NEAR_RANGE_SPIN             3060
#define IDC_REND_PARTICLES              3060
#define IDC_TI_ADDPOINT                 3061
#define IDC_REND_PARTICLESSPIN          3061
#define IDC_MAP_RANGE_SPIN              3062
#define IDC_GLOBAL_SET                  3063
#define IDC_CAST_SHADOWS                3064
#define IDC_ATM_OPACITY_SPIN            3064
#define IDC_ABS_MAP_BIAS                3065
#define IDC_SHADOW_MAPS                 3066
#define IDC_RAY_TRACED_SHADOWS          3067
#define IDC_LT_EFFECT_SHADCOL           3068
#define IDC_EXCLUDE_DLG                 3069
#define IDC_PROJ_MAPNAME                3070
#define IDC_ATM_COLAMT_SPIN             3070
#define IDC_PARTICLE_REND1              3071
#define IDC_TEAPART                     3071
#define IDC_PARTICLE_REND2              3072
#define IDC_PARTICLE_REND3              3073
#define ID_STATIC                       3073
#define IDC_TEA_BODY                    3074
#define IDC_TEA_HANDLE                  3075
#define IDC_BOOL_ANAME                  3075
#define IDC_TEA_SPOUT                   3076
#define IDC_MORPHTARG_NAME              3076
#define IDC_TEA_LID                     3077
#define IDC_IS_ORTHO                    3080
#define IDC_AP_FILLET                   3081
#define IDC_BARYMORPH_TARGETLEBEL       3082
#define IDC_BARYMORPH_PERCENTLABEL      3083
#define IDC_BARYMORPH_TOTAL             3084
#define IDC_ATMOS_SHADOWS               3085
#define IDC_START_RANGE1                4001
#define IDC_START_RANGE1_SPIN           4002
#define IDC_END_RANGE1                  4003
#define IDC_END_RANGE1_SPIN             4004
#define IDC_BOOL_EXTRACT_INTANCE        4005
#define IDC_BOOL_EXTRACT_COPY           4006
#define IDC_TARG_DISTANCE               4007
#define IDC_TEXT_UPDATE                 4008
#define IDC_BONES_AUTOBONE              4009
#define IDC_FOV_TYPE                    4010
#define IDC_ATT_NONE                    4020
#define IDC_ATT_INV                     4021
#define IDC_ATT_INVSQ                   4022
#define IDC_TAPE_X_AXIS                 4030
#define IDC_TAPE_Y_AXIS                 4031
#define IDC_TAPE_Z_AXIS                 4032
#define IDC_TAPE_XY_PLANE               4033
#define IDC_TAPE_YZ_PLANE               4034
#define IDC_TAPE_ZX_PLANE               4035
#define IDC_PROT_ANGLE                  4036
#define IDC_SHADPROJ_MAPNAME            4037
#define IDC_CONTRAST_T                  4038
#define IDC_DIFFSOFT_T                  4039
#define IDC_LIGHT_TYPE                  4041
#define IDC_CAM_TYPE                    4042
#define IDC_LIGHT_DECAY                 4043
#define IDC_PCAM_PLAN                   4050
#define IDC_PCAM_BOTTOM                 4051
#define IDC_PCAM_LEFT                   4052
#define IDC_PCAM_SHOW_VOLUME            4052
#define IDC_PCAM_RIGHT                  4053
#define IDC_PCAM_SHOW_ENV               4053
#define IDC_PCAM_FRONT                  4054
#define IDC_PCAM_NEAR_ENV               4054
#define IDC_PCAM_BACK                   4055
#define IDC_PCAM_NEAR_ENV_SPINNER       4055
#define IDC_PCAM_QUADRANT1              4056
#define IDC_PCAM_FAR_ENV                4056
#define IDC_PCAM_QUADRANT2              4057
#define IDC_PCAM_FAR_ENV_SPINNER        4057
#define IDC_PCAM_QUADRANT3              4058
#define IDC_PCAM_UPDATE                 4058
#define IDC_PCAM_QUADRANT4              4059
#define IDC_SHADOW_TYPE                 4059
#define IDC_PCAM_DIMETRIC15             4060
#define IDC_SHAD_MULT                   4060
#define IDC_PCAM_DIMETRIC45             4061
#define IDC_SHAD_MULT_SPIN              4061
#define IDC_USE_SHAD_COLMAP             4062
#define IDC_EMITTER_ENABLE              4063
#define IDC_TOTALFACES                  4063
#define IDC_EMITTER_CA_PHOTONS_LBL      4064
#define IDC_EMITTER_DECAY_LBL           4065
#define IDC_EMITTER_CA_PHOTONS          4066
#define IDC_EMITTER_CA_PHOTONS_SPIN     4067
#define IDC_EMITTER_ENERGY              4068
#define IDC_PCAM_LOCK_X2Z               4069
#define IDC_EMITTER_ENERGY_SPIN         4069
#define IDC_PCAM_LOCK_X2Y               4070
#define IDC_EMITTER_ENERGY_LBL          4070
#define IDC_PCAM_LOCK_Y2Z               4071
#define IDC_EMITTER_DECAY               4071
#define IDC_PCAM_ANGLE_X                4072
#define IDC_EMITTER_GI_PHOTONS_LBL      4072
#define IDC_PCAM_ANGLE_X_SPINNER        4073
#define IDC_EMITTER_GI_PHOTONS          4073
#define IDC_PCAM_ANGLE_Y                4074
#define IDC_EMITTER_GI_PHOTONS_SPIN     4074
#define IDC_PCAM_ANGLE_Y_SPINNER        4075
#define IDC_PCAM_ANGLE_Z                4076
#define IDC_PCAM_ANGLE_Z_SPINNER        4077
#define IDC_PCAM_CLIP_NEAR              4084
#define IDC_PCAM_CLIP_NEAR_SPINNER      4085
#define IDC_PCAM_CLIP_FAR               4086
#define IDC_PCAM_CLIP_FAR_SPINNER       4087
#define IDC_PCAM_SHOW_SECTION           4088
#define IDC_PCAM_FIX_HEIGHT             4089
#define IDC_PCAM_FIX_WIDTH              4090
#define IDC_PCAM_FIX_ASPECT             4091
#define IDC_PCAM_HEIGHT                 4092
#define IDC_PCAM_HEIGHT_SPINNER         4093
#define IDC_PCAM_WIDTH                  4094
#define IDC_PCAM_WIDTH_SPINNER          4095
#define IDC_PCAM_ASPECT                 4096
#define IDC_PCAM_ASPECT_SPINNER         4097
#define IDC_OBJECT_SHADOWS              4098
#define IDC_DOF_FSTOP_LBL               4099
#define IDC_DOF_ENABLE                  4100
#define IDC_DOF_FSTOP                   4101
#define IDC_DOF_FSTOP_SPIN              4102
#define IDC_GROUP_CAUSTICS              4103
#define IDC_GROUP_GLOBALILLUM           4104
#define IDS_DS_CREATE                   10008
#define IDS_DB_FREE                     10009
#define IDS_DB_BONES                    10010
#define IDS_DB_BASIC                    10011
#define IDS_DB_RING_ARRAY               10012
#define IDS_DB_SLAVECONTROL             10013
#define IDS_DB_SLAVE_CONTROL            10014
#define IDS_DB_TAPEHELPER               10015
#define IDS_DB_BONES_CLASS              10016
#define IDS_RB_TEAPOT_CLASS             10017
#define IDS_TH_TEXT_CLASS               10018
#define IDS_RB_TORUS_CLASS              10019
#define IDS_TH_TRI_PATCH_CLASS          10020
#define IDS_DB_DIRECTIONAL_CLASS        10021
#define IDS_DS_TDIRECTIONAL_CLASS       10022
#define IDS_DB_FREE_SPOT_CLASS          10023
#define IDS_DB_SLAVECONTROL_CLASS       10024
#define IDS_DB_TARGET_CLASS             10025
#define IDS_DB_PROTRACTOR               10026
#define IDS_DB_PROTHELPER_CLASS         10027
#define IDS_DB_PROT_CLASS               10028
#define IDS_DS_RINGARRAYPAR             10037
#define IDS_DS_RADIUS                   10038
#define IDS_DS_CYCLES                   10039
#define IDS_DS_AMPLITUDE                10040
#define IDS_DS_PHASE                    10041
#define IDS_CT_SURF                     10042
#define IDS_CT_CAP                      10043
#define IDS_CT_SLICE                    10044
#define IDS_DS_EXCLUDE__                10122
#define IDS_DS_INCLUDE__                10123
#define IDS_DS_LIGHTCOL                 10175
#define IDS_DB_TDIST                    20072
#define IDS_DB_MULTIPLIER               20315
#define IDS_DB_ATTENSTART               20316
#define IDS_DB_ATTENEND                 20317
#define IDS_DB_HOTSIZE                  20318
#define IDS_DB_FALLSIZE                 20319
#define IDS_DB_COLOR                    20320
#define IDS_DB_ASPECT_RATIO             20323
#define IDS_DB_TAPE_LENGTH              20326
#define IDS_DB_NRANGE                   20453
#define IDS_DB_FRANGE                   20454
#define IDS_RB_OBJECT                   30004
#define IDS_RB_PARAMETERS               30028
#define IDS_RB_ANGLE                    30029
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_LENGTH                   30038
#define IDS_RB_WIDTH                    30039
#define IDS_RB_HEIGHT                   30040
#define IDS_RB_WSEGS                    30041
#define IDS_RB_HSEGS                    30042
#define IDS_RB_LSEGS                    30043
#define IDS_RB_FOV                      30044
#define IDS_RB_RADIUS                   30045
#define IDS_RB_SEGS                     30046
#define IDS_RB_SIDES                    30047
#define IDS_RB_SMOOTH                   30048
#define IDS_RB_RED                      30049
#define IDS_RB_GREEN                    30050
#define IDS_RB_BLUE                     30051
#define IDS_RB_HOTSIZE                  30052
#define IDS_RB_TRANSFORM                30053
#define IDS_RB_BASEPARAMS               30054
#define IDS_DB_TARGET                   30055
#define IDS_DB_DOT_TARGET               30056
#define IDS_DB_OMNI                     30057
#define IDS_DB_TARGET_SPOT              30058
#define IDS_DB_DIRECTIONAL              30059
#define IDS_DB_FREE_SPOT                30060
#define IDS_DB_NONE                     30061
#define IDS_RB_OBJ_MOD                  30062
#define IDS_RB_WORLD_MOD                30063
#define IDS_DB_GENERAL_PARAMS           30064
#define IDS_DB_DIR_PARAMS               30065
#define IDS_DB_SPOT_PARAMS              30066
#define IDS_DB_SHADOW_PARAMS            30067
#define IDS_DB_SELECT_TO_FIT            30068
#define IDS_DB_OMNI_LIGHT               30069
#define IDS_DB_DIR_LIGHT                30070
#define IDS_DB_DIRECT                   30071
#define IDS_DB_FSPOT                    30072
#define IDS_DB_SPOT                     30073
#define IDS_DB_LIGHT                    30074
#define IDS_DB_TAPE                     30075
#define IDS_DB_GENERAL                  30076
#define IDS_DB_TARGET_SPOT_CLASS        30077
#define IDS_DB_TAPE_CLASS               30078
#define IDS_RB_EDITKEYINFO              30128
#define IDS_DB_OMNI_CLASS               30129
#define IDS_RB_MORPH_CLASS              30130
#define IDS_RB_SNOW_CLASS               30131
#define IDS_RB_GEOMETERIC               30157
#define IDS_RB_SHAPES                   30158
#define IDS_RB_LIGHTS                   30159
#define IDS_RB_CAMERAS                  30160
#define IDS_RB_HELPERS                  30161
#define IDS_RB_SPACEWARPS               30162
#define IDS_RB_SYSTEMS                  30163
#define IDS_DB_CAMERA                   30164
#define IDS_DB_SIMPLECAM                30165
#define IDS_DB_SIMPLECAM_CLASS          30166
#define IDS_RB_PICKOPERAND              30263
#define IDS_RB_PRIMITIVES               30264
#define IDS_PW_PRIMITIVES               30265
#define IDS_PW_CREATIONMETHOD           30266
#define IDS_PW_KEYBOARDENTRY            30267
#define IDS_PW_PARAMETERS               30268
#define IDS_PW_LENGTH                   30269
#define IDS_PW_WIDTH                    30270
#define IDS_PW_HEIGHT                   30271
#define IDS_PW_WSEGS                    30272
#define IDS_PW_LSEGS                    30273
#define IDS_PW_HSEGS                    30274
#define IDS_PW_SCALE                    30275
#define IDS_PW_RSEG                     30276
#define IDS_PW_MAPPING                  30277
#define IDS_PW_POS                      30278
#define IDS_PW_LEFTOVER                 30279
#define IDS_RB_BOOLEAN                  30475
#define IDS_RB_COMPOUNDOBJECTS          30476
#define IDS_RB_INVALIDBOOLEAN           30477
#define IDS_RB_OPERANDS                 30478
#define IDS_RB_PICKBOOLEAN              30479
#define IDS_RB_OPERANDA                 30480
#define IDS_RB_OPERANDATRANSFORM        30481
#define IDS_RB_OPERANDB                 30482
#define IDS_RB_OPERANDBTRANSFORM        30483
#define IDS_RB_OPERAND                  30484
#define IDS_RB_CUBICMORPHCONTROL        30485
#define IDS_RB_TARGETNUMBER             30486
#define IDS_RB_MORPH                    30487
#define IDS_RB_MORPHOBJECT              30488
#define IDS_RB_PICKTARGETS              30489
#define IDS_RB_CURRENTTARGETS           30490
#define IDS_RB_SPRAY                    30491
#define IDS_RB_SNOW                     30492
#define IDS_RB_PARTICLESYSTEMS          30493
#define IDS_RB_VIEWPARTICLES            30494
#define IDS_RB_DROPSIZE                 30495
#define IDS_RB_SPEED                    30496
#define IDS_RB_VARIATION                30497
#define IDS_RB_STARTTIME                30498
#define IDS_RB_LIFETIME                 30499
#define IDS_RB_BIRTHRATE                30500
#define IDS_RB_TUMBLE                   30501
#define IDS_RB_TUMBLERATE               30502
#define IDS_RB_SPHERE                   30503
#define IDS_RB_CREATIONMETHOD           30504
#define IDS_RB_KEYBOARDENTRY            30505
#define IDS_RB_HEMISPHERE               30506
#define IDS_RB_BOX                      30507
#define IDS_RB_CYLINDER                 30508
#define IDS_RB_CIRCLESEGMENTS           30509
#define IDS_RB_CAPSEGMENTS              30510
#define IDS_RB_SLICEON                  30511
#define IDS_RB_SLICEFROM                30512
#define IDS_RB_SLICETO                  30513
#define IDS_RB_GENTEXCOORDS             30514
#define IDS_RB_CONE                     30515
#define IDS_RB_RADIUS1                  30516
#define IDS_RB_RADIUS2                  30517
#define IDS_RB_TEAPOT                   30518
#define IDS_DB_TARGET_CAM               30519
#define IDS_RB_TORUS                    30520
#define IDS_RB_ROTATION2                30521
#define IDS_RB_TWIST                    30522
#define IDS_RB_HEDRA                    30523
#define IDS_RB_FAMILY                   30524
#define IDS_RB_PVALUE                   30525
#define IDS_RB_QVALUE                   30526
#define IDS_RB_PSCALE                   30527
#define IDS_RB_QSCALE                   30528
#define IDS_RB_RSCALE                   30529
#define IDS_RB_TUBE                     30530
#define IDS_RB_SEGMENTS                 30531
#define IDS_DB_FREE_CAM                 30532
#define IDS_RB_BOOLEAN_CLASS            30533
#define IDS_RB_BOX_CLASS                30534
#define IDS_DB_FREE_CLASS               30535
#define IDS_RB_MORPHOBJECT_CLASS        30536
#define IDS_RB_CUBICMORPHCONTROL_CLASS  30537
#define IDS_RB_SPHERE2                  30543
#define IDS_RB_CREATIONMETHOD2          30544
#define IDS_RB_FROM                     30545
#define IDS_RB_TO                       30546
#define IDS_RB_KEYBOARDENTRY2           30547
#define IDS_RB_HEMISPHERE2              30548
#define IDS_RB_BOX2                     30549
#define IDS_RB_CYLINDER2                30550
#define IDS_RB_CIRCLESEGMENTS2          30551
#define IDS_RB_CREATIONMETHOD3          30552
#define IDS_RB_KEYBOARDENTRY3           30553
#define IDS_RB_CIRCLESEGMENTS3          30554
#define IDS_RB_CREATIONMETHOD4          30555
#define IDS_RB_BODY                     30633
#define IDS_RB_LID                      30634
#define IDS_RB_SPOUT                    30635
#define IDS_RB_HANDLE                   30636
#define IDS_RB_HEIGHTSEGS               30639
#define IDS_RB_MAPSIZE                  30640
#define IDS_RB_MAPBIAS                  30641
#define IDS_RB_MAPRANGE                 30642
#define IDS_RB_RAYBIAS                  30643
#define IDS_RB_NEARPLANE                30644
#define IDS_RB_FARPLANE                 30645
#define IDS_RB_PICKMORPHTARGET          30657
#define IDS_RB_CREATEMORPHKEY           30658
#define IDS_RB_BOOLEANABORTED           30661
#define IDS_RB_BOOLEACOMPLETED          30662
#define IDS_RB_FLAKESIZE                30676
#define IDS_TH_RADIUS                   31033
#define IDS_TH_CIRCULAR                 31034
#define IDS_TH_SIDES                    31035
#define IDS_TH_RADIUS1                  31036
#define IDS_TH_RADIUS2                  31037
#define IDS_TH_PARAMETERS               31038
#define IDS_TH_LINE                     31079
#define IDS_TH_FROM                     31161
#define IDS_TH_TO                       31162
#define IDS_TH_DISTORTION               31163
#define IDS_TH_STARPOINTS               31164
#define IDS_TH_TURNS                    31165
#define IDS_TH_BIAS                     31166
#define IDS_TH_NEEDTWOSPLINEPOINTS      31188
#define IDS_TH_ERRORTWOCONSECUTIVE      31189
#define IDS_TH_NGON                     31259
#define IDS_TH_SPLINES                  31260
#define IDS_TH_CREATION_METHOD          31261
#define IDS_TH_KEYBOARD_ENTRY           31262
#define IDS_TH_TRI_PATCH                31263
#define IDS_TH_PATCH_GRIDS              31264
#define IDS_TH_ARC                      31265
#define IDS_TH_CIRCLE                   31266
#define IDS_TH_RECTANGLE                31267
#define IDS_TH_STAR                     31268
#define IDS_TH_DONUT                    31269
#define IDS_TH_TEXT                     31270
#define IDS_TH_HELIX                    31271
#define IDS_TH_ELLIPSE                  31272
#define IDS_TH_QUAD_PATCH               31273
#define IDS_TH_MAX_TEXT                 31274
#define IDS_TH_SIZE                     31275
#define IDS_TH_INTERPOLATION            31276
#define IDS_TH_ARC_CLASS                31277
#define IDS_TH_HEIGHT                   31278
#define IDS_TH_CIRCLE_CLASS             31279
#define IDS_TH_DIRECTION                31280
#define IDS_TH_ARIAL                    31281
#define IDS_TH_QUADPATCH                31282
#define IDS_TH_QUADPATCHOBJECT          31283
#define IDS_TH_TRIPATCH                 31284
#define IDS_TH_TRIPATCHOBJECT           31285
#define IDS_TH_HELIX_CLASS              31286
#define IDS_RB_CONE_CLASS               31287
#define IDS_RB_CYLINDER_CLASS           31288
#define IDS_TH_DONUT_CLASS              31289
#define IDS_TH_ELLIPSE_CLASS            31290
#define IDS_RB_HEDRA_CLASS              31291
#define IDS_DB_LIGHT_CLASS              31292
#define IDS_TH_NGON_CLASS               31293
#define IDS_TH_QUADPATCHOBJECT_CLASS    31294
#define IDS_RB_SPRAY_CLASS              31295
#define IDS_TH_RECTANGLE_CLASS          31296
#define IDS_DB_RING_ARRAY_CLASS         31297
#define IDS_RB_SPHERE_CLASS             31298
#define IDS_TH_LINE_CLASS               31299
#define IDS_TH_STAR_CLASS               31300
#define IDS_DB_TAPEHELPER_CLASS         31301
#define IDS_TH_TRIPATCHOBJECT_CLASS     31302
#define IDS_RB_TUBE_CLASS               31303
#define IDS_TH_QUAD_PATCH_CLASS         31304
#define IDS_TH_SIMPSPLINE               31315
#define IDS_DS_PARAMCHG                 31316
#define IDS_RB_DELETEMORPHTARG          31317
#define IDS_DB_ORTHO_WIDTH              31318
#define IDS_AP_EXTENDED                 31319
#define IDS_AP_FILLET                   31320
#define IDS_AP_FILLET1                  31321
#define IDS_AP_FILLET2                  31322
#define IDS_RB_BARYMORPHCONTROL         31323
#define IDS_DS_TDIRECTIONAL             31324
#define IDS_DS_TDIRECT                  31325
#define IDS_DS_TDIR_LIGHT               31326
#define IDS_DS_ATTENSTARTNEAR           31327
#define IDS_DS_ATTENENDNEAR             31328
#define IDS_DS_PROJ_PARAMS              31329
#define IDS_RB_EXTRACTOP                31330
#define IDS_RB_BONEPARAMS               31331
#define IDS_DS_CONTRAST                 31332
#define IDS_SM_PATCH                    31333
#define IDS_SM_EDITABLEMESH             31334
#define IDS_SM_NURBS_SURFACE            31335
#define IDS_TH_LEADING                  31336
#define IDS_TH_KERNING                  31337
#define IDS_RB_BARYMORPHCONTROL_CLASS   31338
#define IDS_TH_SCRIBE                   31339
#define IDS_DS_DIFFSOFT                 31340
#define IDS_RB_PRIMLIB                  31341
#define IDS_DS_SHADCOL                  31342
#define IDS_DS_SETTYPE                  31343
#define IDS_DS_SETCAMTYPE               31344
#define IDS_AP_SLICEON                  31345
#define IDS_AP_SLICETO                  31346
#define IDS_AP_SLICEON3                 31347
#define IDS_AP_SLICEFROM                31347
#define IDS_DECAY_NONE                  31348
#define IDS_DECAY_INVERSE               31349
#define IDS_DECAY_INVSQ                 31350
#define IDS_ATTEN_PARAM                 31351
#define IDS_PRS_ORTHOLINE_CLASS         31352
#define IDS_DECAY_RADIUS                31352
#define IDS_ATMOS_OPACITY               31353
#define IDS_ATMOS_COLAMT                31354
#define IDS_PARRALLEL_CAMERA            31355
#define IDS_PARALLEL_CAMERA_CLASS       31356
#define IDS_PCAM_CUSTOM_GROUP           31357
#define IDS_PCAM_STANDARD_GROUP         31358
#define IDS_PCAM_AXIS_ANGLE_X           31359
#define IDS_PCAM_AXIS_ANGLE_Y           31360
#define IDS_PCAM_AXIS_ANGLE_Z           31361
#define IDS_PCAM_HEIGHT                 31362
#define IDS_PCAM_WIDTH                  31363
#define IDS_PCAM_ASPECT                 31364
#define IDS_SECTION_UPDATE              31365
#define IDS_LOCK_X2Z                    31366
#define IDS_LOCK_X2Y                    31367
#define IDS_LOCK_Y2Z                    31368
#define IDS_PCAM_FIX_HEIGHT             31369
#define IDS_PCAM_FIX_WIDTH              31370
#define IDS_PCAM_FIX_ASPECT             31371
#define IDS_PARALLEL_CAMERA             31372
#define IDS_DS_PROJMAP                  31373
#define IDS_DS_SHADPROJMAP              31374
#define IDS_DS_SHAD_GEN                 31375
#define IDS_DS_SETSHADTYPE              31376
#define IDS_PW_CV                       31377
#define IDS_SHAD_DENSITY                31379
#define IDS_EMITTER                     31380
#define IDS_EMITTER_ENABLE              31381
#define IDS_EMITTER_ENERGY              31382
#define IDS_EMITTER_CA_PHOTONS          31383
#define IDS_DOF                         31384
#define IDS_DOF_ENABLE                  31385
#define IDS_DOF_FSTOP                   31386
#define IDS_TH_VIZ_TEXT                 31387
#define IDS_EMITTER_GI_PHOTONS          31388
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        198
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         4105
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\rectangl.cpp ===
/**********************************************************************
 *<
	FILE: rectangl.cpp

	DESCRIPTION:  An rectangular spline object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995
			 Fillets added 1/12/97 - Audrey Peterson

 *>	Copyright (c) 1995,1996,1997 All Rights Reserved.
 **********************************************************************/

#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"


#define MIN_LENGTH		float(0)
#define MAX_LENGTH		float( 1.0E30)
#define MIN_WIDTH		float(0)
#define MAX_WIDTH		float( 1.0E30)

#define DEF_LENGTH		float(0.0)
#define DEF_WIDTH		float(0.0)

#define CREATE_EDGE 0
#define CREATE_CENTER 1

class RectangleObjCreateCallBack;

class RectangleObject: public SimpleSpline, public IParamArray {			   
		friend class RectangleObjCreateCallBack;

	public:	
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		static float crtLength;
		static float crtWidth;
		static float crtFillet;
		
		void BuildShape(TimeValue t,BezierShape& ashape);

		RectangleObject();
		~RectangleObject();

		//  inherited virtual methods:

	    IOResult RectangleObject::Load(ILoad *iload);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_RECTANGLE); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_RECTANGLE); }		
		Class_ID ClassID() { return Class_ID(RECTANGLE_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_RECTANGLE_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class RectangleObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new RectangleObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_RECTANGLE_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(RECTANGLE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static RectangleObjClassDesc rectangleObjDesc;

ClassDesc* GetRectangleDesc() { return &rectangleObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IParamMap *RectangleObject::pmapCreate = NULL;
IParamMap *RectangleObject::pmapParam  = NULL;
IParamMap *RectangleObject::pmapTypeIn = NULL;
IObjParam *RectangleObject::ip         = NULL;
int RectangleObject::dlgCreateMeth = CREATE_EDGE;
Point3 RectangleObject::crtPos         = Point3(0,0,0);
float RectangleObject::crtLength       = 0.0f;
float RectangleObject::crtWidth        = 0.0f;
float RectangleObject::crtFillet        = 0.0f;

void RectangleObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	RectangleObject::dlgCreateMeth   = CREATE_EDGE;
	RectangleObject::crtPos          = Point3(0,0,0);
	RectangleObject::crtLength       = 0.0f;
	RectangleObject::crtWidth        = 0.0f;
	RectangleObject::crtFillet       = 0.0f;
	}

// Parameter map indices
#define PB_LENGTH		0
#define PB_WIDTH		1
#define PB_FILLET		2

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_LENGTH		2
#define PB_TI_WIDTH			3
#define PB_TI_FILLET		4

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEEDGE,IDC_CREATECENTER};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		MIN_LENGTH,MAX_LENGTH,
		SPIN_AUTOSCALE),	

	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE),

	// Fillet
	ParamUIDesc(
		PB_TI_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_FILLET,IDC_FILLETSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE)
			
	};
#define TYPEINDESC_LENGTH 4

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		MIN_LENGTH,MAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE),	
	
	// Fillet
	ParamUIDesc(
		PB_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_FILLET,IDC_FILLETSPINNER,
		MIN_WIDTH,MAX_WIDTH,
		SPIN_AUTOSCALE)	
	
	};
#define PARAMDESC_LENGTH 3


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
 };
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
 };
#define PBLOCK_LENGTH	3

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,2,0)			
	};
#define NUM_OLDVERSIONS	1	

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

class RectPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		RectPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((RectangleObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer==0) {				
				((RectangleObject*)targ)->pblock->SetValue(PB_FILLET,0,0.0f);
				}
			delete this;
			}
	};
IOResult RectangleObject::Load(ILoad *iload)
	{  	iload->RegisterPostLoadCallback(
			new RectPostLoadCallback(
				new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	return SimpleSpline::Load(iload);
	}


//--- TypeInDlgProc --------------------------------

class RectangleTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		RectangleObject *ro;

		RectangleTypeInDlgProc(RectangleObject *d) {ro=d;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL RectangleTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ro->crtLength==0.0 && ro->crtWidth==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ro->TestAFlag(A_OBJ_CREATING)) {
						ro->pblock->SetValue(PB_LENGTH,0,ro->crtLength);
						ro->pblock->SetValue(PB_WIDTH,0,ro->crtWidth);
						ro->pblock->SetValue(PB_FILLET,0,ro->crtFillet);
						}

					Matrix3 tm(1);
					tm.SetTrans(ro->crtPos);
					ro->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void RectangleObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last shape ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_RECTANGLEPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_RECTANGLEPARAM3),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_RECTANGLEPARAM2),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new RectangleTypeInDlgProc(this));
		}
	}
		
void RectangleObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	}
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

void RectangleObject::BuildShape(TimeValue t, BezierShape& ashape) {

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float length,fillet;
	float width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	pblock->GetValue(PB_FILLET, t, fillet, ivalid);
	LimitValue( length, MIN_LENGTH, MAX_LENGTH );
	LimitValue( width, MIN_WIDTH, MAX_WIDTH );
	LimitValue( fillet, MIN_WIDTH, MAX_WIDTH );
	// Delete the existing shape and create a new spline in it
	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	Spline3D *spline = ashape.NewSpline();

	// Now add all the necessary points
	// We'll add 'em as auto corners initially, have the spline package compute some vectors (because
	// I'm basically lazy and it does a great job, besides) then turn 'em into bezier corners!
	float l2 = length / 2.0f;
	float w2 = width / 2.0f;
	Point3 p = Point3(w2, l2, 0.0f);
	int pts=4;
	if (fillet>0)
	{ pts=8;
	  float cf=fillet*CIRCLE_VECTOR_LENGTH;
	  Point3 wvec=Point3(fillet,0.0f,0.0f),lvec=Point3(0.0f,fillet,0.0f);
	  Point3 cwvec=Point3(cf,0.0f,0.0f),clvec=Point3(0.0f,cf,0.0f);
	  Point3 p3=p-lvec,p2;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p3,p3-clvec,p3+clvec));
	  p=p-wvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p+cwvec,p-cwvec));
	  p=Point3(-w2,l2,0.0f);p2=p+wvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p2,p2+cwvec,p2-cwvec));
	  p=p-lvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p+clvec,p-clvec));
	  p=Point3(-w2,-l2,0.0f);p3=p+lvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p3,p3+clvec,p3-clvec));
	  p=p+wvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p-cwvec,p+cwvec));
	  p = Point3(w2, -l2, 0.0f);p3=p-wvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p3,p3-cwvec,p3+cwvec));
	  p=p+lvec;
	  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p-clvec,p+clvec));
	spline->SetClosed();
	spline->ComputeBezPoints();
	} 
	else
	{spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(-w2, l2, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(-w2, -l2, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(w2, -l2, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	spline->SetClosed();
	spline->ComputeBezPoints();
	for(int i = 0; i < 4; ++i)
		spline->SetKnotType(i, KTYPE_BEZIER_CORNER);
	}
	spline->SetClosed();
	spline->ComputeBezPoints();
	for(int i = 0; i < pts; ++i)
		spline->SetKnotType(i, KTYPE_BEZIER_CORNER);
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

RectangleObject::RectangleObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);	
	pblock->SetValue(PB_FILLET,0,crtFillet);	
 	}

RectangleObject::~RectangleObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class RectangleObjCreateCallBack: public CreateMouseCallBack {
	RectangleObject *ob;
	Point3 p0,p1;
	IPoint2 sp0,sp1;
	float w,l;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(RectangleObject *obj) { ob = obj; }
	};

int RectangleObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->suspendSnap = TRUE;
				createType = ob->dlgCreateMeth;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1 = p0 + Point3(.01,.01,.0);
				if(createType == CREATE_EDGE)
					mat.SetTrans(float(.5)*(p0+p1));
				else
					mat.SetTrans(p0);
				break;
			case 1: { 
				sp1 = m;							   
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1.z = p0.z; 
				d = p1-p0;
				w = float(fabs(d.x));
				l = float(fabs(d.y));
				if(flags & MOUSE_CTRL) {
					if(createType == CREATE_EDGE) {
						float ysign = (d.y < 0.0f) ? -1.0f : 1.0f;
						mat.SetTrans(float(.5)*(p0+Point3(p1.x,p0.y+ysign*w,0.0f)));
						}
					else {
						mat.SetTrans(p0);
						w = w * 2.0f;
						}
					ob->pblock->SetValue(PB_LENGTH,0,w);
					ob->pblock->SetValue(PB_WIDTH,0,w);
					}
				else {
					if(createType == CREATE_EDGE)
						mat.SetTrans(float(.5)*(p0+p1));
					else {
						mat.SetTrans(p0);
						w = w * 2.0f;
						l = l * 2.0f;
						}
					ob->pblock->SetValue(PB_WIDTH,0,w);
					ob->pblock->SetValue(PB_LENGTH,0,l);
					}
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				 { ob->suspendSnap = FALSE;
				return ((Length(m-sp0)<3 || Length(p1-p0)<0.1f)?CREATE_ABORT:CREATE_STOP);
					}
				}
				break;
/*			case 2:
				{ float f = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
				  float min=(w>l?w:l)/2.0f;
				  ob->pblock->SetValue(PB_FILLET,0,(f>min?min:f));
				  ob->pmapParam->Invalidate();
				  if (msg==MOUSE_POINT) 
				  {	ob->suspendSnap = FALSE;
					return CREATE_STOP;
				  }
				}
				break;*/
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static RectangleObjCreateCallBack rectangleCreateCB;

CreateMouseCallBack* RectangleObject::GetCreateMouseCallBack() {
	rectangleCreateCB.SetObj(this);
	return(&rectangleCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle RectangleObject::Clone(RemapDir& remap) {
	RectangleObject* newob = new RectangleObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL RectangleObject::ValidForDisplay(TimeValue t) {
	float length, width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	return (length == 0 || width == 0) ? FALSE : TRUE;
	}

ParamDimension *RectangleObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
		case PB_WIDTH:
		case PB_FILLET:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR RectangleObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
			return TSTR(GetString(IDS_RB_LENGTH));			
		case PB_WIDTH:
			return TSTR(GetString(IDS_RB_WIDTH));
		case PB_FILLET:
			return TSTR(GetString(IDS_AP_FILLET));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL RectangleObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL RectangleObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH: crtWidth = v; break;
		case PB_TI_FILLET: crtFillet = v; break;
		}	
	return TRUE;
	}

BOOL RectangleObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL RectangleObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL RectangleObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH: v = crtWidth; break;
		case PB_TI_FILLET: v = crtFillet; break;
		}
	return TRUE;
	}

BOOL RectangleObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\sample.cpp ===
/**********************************************************************
 *<
	FILE: sample.cpp

	DESCRIPTION:  Sample implementation

	HISTORY: created November 11 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include <props.h>
#include "dummy.h"
#include "Simpobj.h"

extern HINSTANCE hInstance;

#define RINGARRAY_CLASS_ID 0x9120
#define SLAVE_CONTROL_CLASS_ID 0x9100

// Parameter block indices
#define PB_RAD	0
#define PB_CYC	1
#define PB_AMP	2
#define PB_PHS	3

//----------------------------------------------------------------------

class RingMaster: public ReferenceTarget {
	public:
	// Object parameters
		IParamBlock *pblock;
		Tab<INode*> nodeTab;
		int numNodes;
		RingMaster();

		INode* GetSlaveNode(int i) { return nodeTab[i]; }
		void SetSlaveNode(int i, INode * node);
		void SetNum(TimeValue t, int n, BOOL notify=TRUE); 
		void SetRad(TimeValue t, float r); 
		void SetCyc(TimeValue t, float r); 
		void SetAmp(TimeValue t, float r); 
		void SetPhs(TimeValue t, float r); 
		int GetNum(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetRad(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetCyc(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetAmp(TimeValue t, Interval& valid = Interval(0,0) ); 	
		float GetPhs(TimeValue t, Interval& valid = Interval(0,0) ); 	

		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method, int id);
		void UpdateUI(TimeValue t);

		// Class vars
		static HWND hMasterParams;
		static IObjParam *iObjParams;
		static int dlgNum;
		static float dlgRadius;
		static float dlgAmplitude;
		static float dlgCycles;
		static float dlgPhase;
		static ISpinnerControl *numSpin;
		static ISpinnerControl *radSpin;
		static ISpinnerControl *ampSpin;
		static ISpinnerControl *cycSpin;
		static ISpinnerControl *phsSpin;

		// From Animatable

		int NumSubs()  { return 1; }
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return GetString(IDS_DS_RINGARRAYPAR);}		

		Class_ID ClassID() { return Class_ID(RINGARRAY_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return SYSTEM_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = GetString(IDS_DB_RING_ARRAY_CLASS); }
		void DeleteThis() { delete this; }		
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		
		void GetSystemNodes(INodeTab &nodes);

		// From Reference Target
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() { return 1;	};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
	};

Control* GetNewSlaveControl(RingMaster *master, int i);

//------------------------------------------------------

class RingMasterClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new RingMaster(); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_RING_ARRAY_CLASS); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	SClass_ID		SuperClassID() { return SYSTEM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(RINGARRAY_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static RingMasterClassDesc mcDesc;

ClassDesc* GetRingMasterDesc() { return &mcDesc; }
//------------------------------------------------------

HWND RingMaster::hMasterParams = NULL;
IObjParam *RingMaster::iObjParams;

int RingMaster::dlgNum = 	4;
float RingMaster::dlgRadius = 	100.0f;
float RingMaster::dlgAmplitude = 20.0f;
float RingMaster::dlgCycles = 	3.0f;
float RingMaster::dlgPhase = 	1.0f;

ISpinnerControl *RingMaster::numSpin;
ISpinnerControl *RingMaster::radSpin;
ISpinnerControl *RingMaster::ampSpin;
ISpinnerControl *RingMaster::cycSpin;
ISpinnerControl *RingMaster::phsSpin;


RingMaster::RingMaster() {
	ParamBlockDesc desc[] = {
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE },
		{ TYPE_FLOAT, NULL, TRUE }
		};
	MakeRefByID( FOREVER, 0, CreateParameterBlock( desc, 4 ) );	
	SetRad( TimeValue(0), dlgRadius );
	SetCyc( TimeValue(0), dlgCycles );
	SetAmp( TimeValue(0), dlgAmplitude );
	SetPhs( TimeValue(0), dlgPhase );
	numNodes = dlgNum;
	}

RefTargetHandle RingMaster::Clone(RemapDir& remap) {
	int i;
    RingMaster* newm = new RingMaster();	
	newm->ReplaceReference(0,pblock->Clone(remap));
	newm->numNodes = numNodes;
	newm->nodeTab.SetCount(numNodes);
	for (i=0; i<numNodes; i++) newm->nodeTab[i] = NULL;			
	for (i=0; i<numNodes; i++) {
		remap.PatchPointer((RefTargetHandle*)&newm->nodeTab[i],(RefTargetHandle)nodeTab[i]);
		}
	return(newm);
	}

void RingMaster::UpdateUI(TimeValue t)
	{
	if ( hMasterParams ) {
		radSpin->SetValue( GetRad(t), FALSE );
		ampSpin->SetValue( GetAmp(t), FALSE );
		cycSpin->SetValue( GetCyc(t), FALSE );
		phsSpin->SetValue( GetPhs(t), FALSE );
		numSpin->SetValue( GetNum(t), FALSE );
		radSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_RAD,t));
		ampSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_AMP,t));
		cycSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_CYC,t));
		phsSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_PHS,t));
		}
	}

void RingMaster::SetSlaveNode(int i, INode * node) {
	if (i>=nodeTab.Count()) {
		int nold = nodeTab.Count();
		nodeTab.SetCount(i+1);
		if (i+1>numNodes) 
			numNodes = i+1;
		for (int j = nold; j<i+1; j++) nodeTab[j] = NULL;
		}		
	nodeTab[i] = node;
	}

void RingMaster::GetSystemNodes(INodeTab &nodes)
	{
	for (int i=0; i<nodeTab.Count(); i++) {
		nodes.Append(1,&nodeTab[i]);
		}
	}

RefTargetHandle RingMaster::GetReference(int i)  { 
	if (i==0) return pblock;
	return NULL;
	}


void RingMaster::SetReference(int i, RefTargetHandle rtarg) {
	if (i==0)
		pblock = (IParamBlock *)rtarg; 
	}		

#define TWO_PI 6.283185307f

// This is the crux of the controller: it takes an input (parent) matrix, modifies
// it accordingly.  
void RingMaster::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method,
 int id) {
	float radius,amplitude,cycles, phase;
	radius = GetRad(t,valid);
	amplitude = GetAmp(t,valid);
	cycles = GetCyc(t,valid);
	phase = GetPhs(t,valid);
	Matrix3 tmat, *mat = (Matrix3*)val;
	tmat.IdentityMatrix();
	float ang = float(id)*TWO_PI/(float)numNodes;
	tmat.Translate(Point3(radius,0.0f,amplitude*(float)cos(cycles*ang + TWO_PI*phase)));
	tmat.RotateZ(ang);
	
	(*mat) = (method==CTRL_RELATIVE) ? tmat*(*mat) : tmat;

	// Make sure spinners track when animating and in Motion Panel
	UpdateUI(t);
	}

RefResult RingMaster::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	switch (message) {
		case REFMSG_GET_PARAM_DIM: { 
			// the ParamBlock needs info to display in the tree view
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_RAD:	gpd->dim = stdWorldDim; break;	  
				case PB_CYC:	gpd->dim = stdWorldDim; break;	  
				case PB_AMP:	gpd->dim = stdWorldDim; break;	  
				case PB_PHS:	gpd->dim = stdWorldDim; break;	  
					break;									
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			// the ParamBlock needs info to display in the tree view
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_RAD: gpn->name = GetString(IDS_DS_RADIUS);	break;
				case PB_CYC: gpn->name = GetString(IDS_DS_CYCLES);	break;
				case PB_AMP: gpn->name = GetString(IDS_DS_AMPLITUDE);	break;
				case PB_PHS: gpn->name = GetString(IDS_DS_PHASE);	break;
				}
			return REF_STOP; 
			}
		case REFMSG_TARGET_DELETED:{
			for (int i=0; i<nodeTab.Count(); i++) {
				if (hTarget==nodeTab[i]) {
					nodeTab[i] = NULL;				
					break;
					}					
				}
			}
			return REF_STOP;
		}
	return(REF_SUCCEED);
	}


class RingNumRestore: public RestoreObj {
	RingMaster *rng;
	int num;
	int redNum;
	BOOL attached;
	INodeTab svNodes;
	public:
		RingNumRestore::RingNumRestore(RingMaster *ringm, int n); 
		~RingNumRestore() {}
		void Restore(int isUndo);
		void Redo();
		TSTR Description() { return TSTR("RingNumRestore"); }
	};

RingNumRestore::RingNumRestore(RingMaster *ringm, int n) { 
	rng = ringm; 
	num = rng->numNodes; 
	//DebugPrint(" RingNumRestore, num = %d, n = %d  \n",num,n);
	if (rng->nodeTab.Count()==rng->numNodes) {
		attached = TRUE;
		if (n<rng->numNodes) {
			for (int i=n; i<rng->numNodes; i++)
				svNodes.Append(1,&rng->nodeTab[i]);
			}
		}
	else attached = FALSE;
	}

void RingNumRestore::Restore(int isUndo) {
	redNum = rng->nodeTab.Count();
	//DebugPrint("Restore, num= %d \n",num);
	if (attached) {
		if (num>redNum) {
			// add on nodes
			for (int i=0; i<num-redNum; i++)
				rng->nodeTab.Append(1,&svNodes[i]);
			}
		else {
			for (int i=num; i<redNum; i++)
				svNodes.Append(1,&rng->nodeTab[i]);
			rng->nodeTab.SetCount(num);
			}	
		}
	rng->numNodes = num;
	if (rng->hMasterParams) 
		RingMaster::numSpin->SetValue(rng->numNodes, FALSE );
	rng->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void RingNumRestore::Redo() {	
	if (attached) {
		rng->nodeTab.SetCount(redNum);
		if (redNum>rng->numNodes) {
			for (int i=num; i<redNum; i++)
				rng->nodeTab[i] = svNodes[i-num];
			}			
		}
	rng->numNodes = redNum;
	if (rng->hMasterParams) 
	    RingMaster::numSpin->SetValue(rng->numNodes, FALSE );
	rng->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

//--------------------------------------------------
void RingMaster::SetNum(TimeValue t, int n, BOOL notify) { 
	if (n==numNodes) return;
	if (n<1) return;
	//DebugPrint("SetNum %d \n",n);
	int oldNumNodes = numNodes;
	if (theHold.Holding())
		theHold.Put(new RingNumRestore(this, n));
	if (nodeTab.Count()>0) {
		if (n<numNodes) {
			// remove nodes;
			for (int i=numNodes-1; i>=n; i--) {
				INode* node = nodeTab[i];
				if (node) {
					if (node->Selected()) {
						// Dont want to delete selected nodes
						n = i+1;
						numSpin->SetValue( n, TRUE );
						break;
						}
					node->Delete(t,TRUE);
					nodeTab[i] = NULL;
					}
				numNodes = i;
				}
			nodeTab.SetCount(n);
			}
		else {
			nodeTab.SetCount(n);
			for (int i=numNodes; i<n; i++)
				nodeTab[i] = NULL;
			// add nodes;
			if (nodeTab[0]==NULL) {
				n++;
				numSpin->SetValue( n, TRUE );
				}
			else for (int i=numNodes; i<n; i++) {
				Object * obj = nodeTab[0]->GetObjectRef();
				assert(obj);
				INode *newNode = iObjParams->CreateObjectNode(obj);
				Control* slave = GetNewSlaveControl(this,i);
				newNode->SetTMController(slave);
				newNode->FlagForeground(t,FALSE);
				INode *par = nodeTab[0]->GetParentNode();
				assert(par);
			    par->AttachChild(newNode);
				SetSlaveNode(i,newNode);
				}
			}
		}
	numNodes = n;
	if (notify)
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

int RingMaster::GetNum(TimeValue t, Interval& valid ) { 	
	return numNodes;
	}


//--------------------------------------------------
void RingMaster::SetRad(TimeValue t, float r) { 
	pblock->SetValue( PB_RAD, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetRad(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_RAD, t, f, valid );
	return f;
	}

//--------------------------------------------------
void RingMaster::SetCyc(TimeValue t, float r) { 
	pblock->SetValue( PB_CYC, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetCyc(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_CYC, t, f, valid );
	return f;
	}

//--------------------------------------------------
void RingMaster::SetAmp(TimeValue t, float r) { 
	pblock->SetValue( PB_AMP, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetAmp(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_AMP, t, f, valid );
	return f;
	}

//--------------------------------------------------
void RingMaster::SetPhs(TimeValue t, float r) { 
	pblock->SetValue( PB_PHS, t, r );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float RingMaster::GetPhs(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_PHS, t, f, valid );
	return f;
	}

//--------------------------------------------------


BOOL CALLBACK MasterParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	RingMaster *mc = (RingMaster *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !mc && message != WM_INITDIALOG ) return FALSE;
	
	assert(mc->iObjParams);
	switch ( message ) {
		case WM_INITDIALOG:
			mc = (RingMaster *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)mc );
			SetDlgFont( hDlg, mc->iObjParams->GetAppHFont() );
			
			mc->radSpin  = GetISpinner(GetDlgItem(hDlg,IDC_RADSPINNER));
			mc->cycSpin  = GetISpinner(GetDlgItem(hDlg,IDC_CYCSPINNER));
			mc->ampSpin  = GetISpinner(GetDlgItem(hDlg,IDC_AMPSPINNER));
			mc->phsSpin  = GetISpinner(GetDlgItem(hDlg,IDC_PHSSPINNER));
			mc->numSpin  = GetISpinner(GetDlgItem(hDlg,IDC_NUMSPINNER));

			mc->radSpin->SetLimits( 0.0f, 500.0f, FALSE );
			mc->cycSpin->SetLimits( 0.0f, 10.0f, FALSE );
			mc->ampSpin->SetLimits( 0.0f, 500.0f, FALSE );
			mc->phsSpin->SetLimits( -1000.0f, 1000.0f, FALSE );
			mc->numSpin->SetLimits( 1, 200, FALSE );

			mc->radSpin->SetScale(float(0.1) );
			mc->ampSpin->SetScale(float(0.1) );
			mc->phsSpin->SetScale(float(0.1) );
			mc->numSpin->SetScale(float(0.1) );

			mc->radSpin->SetValue( mc->GetRad(mc->iObjParams->GetTime()), FALSE );
			mc->cycSpin->SetValue( mc->GetCyc(mc->iObjParams->GetTime()), FALSE );
			mc->ampSpin->SetValue( mc->GetAmp(mc->iObjParams->GetTime()), FALSE );
			mc->phsSpin->SetValue( mc->GetPhs(mc->iObjParams->GetTime()), FALSE );
			mc->numSpin->SetValue( mc->GetNum(mc->iObjParams->GetTime()), FALSE );

			mc->radSpin->LinkToEdit( GetDlgItem(hDlg,IDC_RADIUS), EDITTYPE_POS_UNIVERSE );			
			mc->cycSpin->LinkToEdit( GetDlgItem(hDlg,IDC_CYCLES), EDITTYPE_FLOAT );			
			mc->ampSpin->LinkToEdit( GetDlgItem(hDlg,IDC_AMPLITUDE), EDITTYPE_FLOAT );			
			mc->phsSpin->LinkToEdit( GetDlgItem(hDlg,IDC_PHASE), EDITTYPE_FLOAT );			
			mc->numSpin->LinkToEdit( GetDlgItem(hDlg,IDC_NUMNODES), EDITTYPE_INT );			
			
			return FALSE;	// DB 2/27

		case WM_DESTROY:
			ReleaseISpinner( mc->radSpin );
			ReleaseISpinner( mc->cycSpin );
			ReleaseISpinner( mc->ampSpin );
			ReleaseISpinner( mc->phsSpin );
			ReleaseISpinner( mc->numSpin );
			mc->radSpin = NULL;
			mc->cycSpin = NULL;
			mc->ampSpin = NULL;
			mc->phsSpin = NULL;
			mc->numSpin = NULL;
			return FALSE;

		case CC_SPINNER_CHANGE:	{
			if (!theHold.Holding()) theHold.Begin();
			TimeValue t = mc->iObjParams->GetTime();
			switch ( LOWORD(wParam) ) {
				case IDC_RADSPINNER: 
					mc->SetRad(t,  mc->radSpin->GetFVal() );  
					mc->radSpin->SetKeyBrackets(mc->pblock->KeyFrameAtTime(PB_RAD,t));
					break;
				case IDC_CYCSPINNER: 
					mc->SetCyc(t,  mc->cycSpin->GetFVal() );  
					mc->cycSpin->SetKeyBrackets(mc->pblock->KeyFrameAtTime(PB_CYC,t));
					break;
				case IDC_AMPSPINNER: 
					mc->SetAmp(t,  mc->ampSpin->GetFVal() );  
					mc->ampSpin->SetKeyBrackets(mc->pblock->KeyFrameAtTime(PB_AMP,t));
					break;
				case IDC_PHSSPINNER: 
					mc->SetPhs(t,  mc->phsSpin->GetFVal() );  
					mc->phsSpin->SetKeyBrackets(mc->pblock->KeyFrameAtTime(PB_PHS,t));
					break;
				case IDC_NUMSPINNER: 
					mc->SetNum(t,  mc->numSpin->GetIVal() );  
					break;
				}
			assert(mc->iObjParams);
			mc->iObjParams->RedrawViews(t, REDRAW_INTERACTIVE, mc);
			return TRUE;

			}
		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			mc->iObjParams->RedrawViews(mc->iObjParams->GetTime(), REDRAW_END, mc);
			return TRUE;

		case WM_MOUSEACTIVATE:
			mc->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			mc->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:			
			return FALSE;

		default:
			return FALSE;
		}
	}

void RingMaster::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	iObjParams = ip;
	
	if ( !hMasterParams ) {
		hMasterParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SAMPLEPARAM),
				MasterParamDialogProc,
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this );		
		ip->RegisterDlgWnd(hMasterParams);
		
	} else {
		SetWindowLong( hMasterParams, GWL_USERDATA, (LONG)this );		

		// Init the dialog to our values.
		radSpin->SetValue(GetRad(ip->GetTime()),FALSE);
		cycSpin->SetValue(GetCyc(ip->GetTime()),FALSE);
		ampSpin->SetValue(GetAmp(ip->GetTime()),FALSE);
		phsSpin->SetValue(GetPhs(ip->GetTime()),FALSE);
		numSpin->SetValue(GetNum(ip->GetTime()),FALSE);
		}
	}
		
void RingMaster::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	if (hMasterParams==NULL) 
		return;
	dlgRadius   = radSpin->GetFVal();
	dlgAmplitude   = ampSpin->GetFVal();
	dlgCycles   = cycSpin->GetFVal();
	dlgPhase   = phsSpin->GetFVal();
	dlgNum   = numSpin->GetIVal();
	
	if ( flags&END_EDIT_REMOVEUI ) {		
		ip->UnRegisterDlgWnd(hMasterParams);
		ip->DeleteRollupPage(hMasterParams);
		hMasterParams = NULL;
		}
	else {		
		SetWindowLong( hMasterParams, GWL_USERDATA, 0 );
		}
	
	iObjParams = NULL;
	}

#define NUMNODES_CHUNK 0x100
#define NODE_ID_CHUNK 0x110

// IO
IOResult RingMaster::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(NUMNODES_CHUNK);
	isave->Write(&numNodes,sizeof(numNodes), &nb);
	isave->EndChunk();
	if (numNodes>0) {
		isave->BeginChunk(NODE_ID_CHUNK);
		for (int i=0; i<numNodes; i++) {
			ULONG id = isave->GetRefID(nodeTab[i]);
			isave->Write(&id,sizeof(ULONG), &nb);
			}
		isave->EndChunk();
		}
	return IO_OK;
	}

IOResult RingMaster::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NUMNODES_CHUNK: {
				res = iload->Read(&numNodes,sizeof(numNodes), &nb);
				nodeTab.SetCount(numNodes);
				for (int i=0; i<numNodes; i++) nodeTab[i] = NULL;
				}
				break;
			case NODE_ID_CHUNK:
				for (int i=0; i<numNodes; i++) {
					ULONG id;
					iload->Read(&id,sizeof(ULONG), &nb);
					if (id!=0xffffffff)
						iload->RecordBackpatch(id,(void**)&nodeTab[i]);
					}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

//-------------------------------------------------------------
class SlaveControl : public Control {
	public:		
		RingMaster *master;
		ULONG id;

		SlaveControl(BOOL loading=FALSE) { master = NULL; id = 0; }
		SlaveControl(const SlaveControl& ctrl);
		SlaveControl(const RingMaster* m, int i);
		void SetID( ULONG i) { id = i;}
		virtual ~SlaveControl() {}	
		SlaveControl& operator=(const SlaveControl& ctrl);

		// From Control
		void Copy(Control *from) {}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		virtual BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		BOOL IsReplaceable() {return FALSE;}
		BOOL CanCopyAnim() {return FALSE;}

		// From Animatable
		void* GetInterface(ULONG id);
		int NumSubs()  { return master->NumSubs(); }
		Animatable* SubAnim(int i) { return master->SubAnim(i); }
		TSTR SubAnimName(int i) { return master->SubAnimName(i); }
		Class_ID ClassID() { return Class_ID(SLAVE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = GetString(IDS_DB_SLAVECONTROL_CLASS); }
		void DeleteThis() { delete this; }		
		int IsKeyable(){ return 0;}
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev) { assert(master); master->BeginEditParams(ip,flags,prev); } 
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next) { assert(master); master->EndEditParams(ip,flags,next); } 
		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// From ReferenceTarget
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() { return 1; };	
		RefTargetHandle GetReference(int i)  { assert(i==0); return master; }
		void SetReference(int i, RefTargetHandle rtarg) { assert(i==0); master = (RingMaster *)rtarg; }		
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
	};



class SlaveControlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new SlaveControl(); }
	const TCHAR *	ClassName() { return GetString(IDS_DB_SLAVE_CONTROL); }
	SClass_ID		SuperClassID() { return CTRL_MATRIX3_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SLAVE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};

static SlaveControlClassDesc slvDesc;

ClassDesc* GetSlaveControlDesc() { return &slvDesc; }

Control* GetNewSlaveControl(RingMaster *master, int i) {
	return new SlaveControl(master,i);
	}

SlaveControl::SlaveControl(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	}

SlaveControl::SlaveControl(const RingMaster* m, int i) {
	id = i;
    MakeRefByID( FOREVER, 0, (ReferenceTarget *)m);
	}

RefTargetHandle SlaveControl::Clone(RemapDir& remap) {
	SlaveControl *sl = new SlaveControl;
	sl->id = id;
	sl->ReplaceReference(0, remap.CloneRef(master));
	return sl;
	}

SlaveControl& SlaveControl::operator=(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	return (*this);
	}

void SlaveControl::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method) {
	assert(master);
	master->GetValue(t,val,valid,method,id);	
	}

void SlaveControl::SetValue(TimeValue t, void *val, int commit, GetSetMethod method) { }

void* SlaveControl::GetInterface(ULONG id) {
	if (id==I_MASTER) 
		return (void *)master;
	else 
		return NULL;
	}

// IO
#define SLAVE_ID_CHUNK 0x200
IOResult SlaveControl::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(SLAVE_ID_CHUNK);
	isave->Write(&id,sizeof(id), &nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult SlaveControl::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SLAVE_ID_CHUNK:
				res = iload->Read(&id,sizeof(id), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

//----------------------------------------------------------------------


class RingMasterCreationManager : public MouseCallBack, ReferenceMaker {
	public:
		CreateMouseCallBack *createCB;	
		INode *node0;
		RingMaster *theMaster;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		IPoint2 pt0;
		Point3 center;
		BOOL attachedToNode;
		int lastPutCount;

		void CreateNewMaster();
			
		int ignoreSelectionChange;

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		RingMasterCreationManager()
			{
			ignoreSelectionChange = FALSE;
			}
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};

#define CID_BONECREATE	CID_USER + 1

class RingMasterCreateMode : public CommandMode {
		RingMasterCreationManager proc;
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		int Class() { return CREATE_COMMAND; }
		int ID() { return CID_BONECREATE; }
		MouseCallBack *MouseProc(int *numPoints) { *numPoints = 100000; return &proc; }
		ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
// mjm - begin - 3.2.99
		void EnterMode() { SetCursor( LoadCursor( hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR) ) ); }
		void ExitMode() { SetCursor( LoadCursor(NULL, IDC_ARROW) ); }
// mjm - end
		BOOL IsSticky() { return FALSE; }
	};

static RingMasterCreateMode theRingMasterCreateMode;

//RingMasterCreationManager::RingMasterCreationManager( IObjCreate *ioc, ClassDesc *desc )
void RingMasterCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	createCB        = NULL;
	node0			= NULL;
	theMaster 		= NULL;
	attachedToNode = FALSE;
	CreateNewMaster();
	}

void RingMasterCreationManager::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case 0: node0 = (INode *)rtarg; break;
		default: assert(0); 
		}
	}

RefTargetHandle RingMasterCreationManager::GetReference(int i) { 
	switch(i) {
		case 0: return (RefTargetHandle)node0;
		default: assert(0); 
		}
	return NULL;
	}

//RingMasterCreationManager::~RingMasterCreationManager
void RingMasterCreationManager::End()
	{
	if (theMaster) {
		theMaster->EndEditParams( (IObjParam*)createInterface, 
	                    	          TRUE/*destroy*/, NULL );
		if ( !attachedToNode ) {
			delete theMaster;
			theMaster = NULL;
			// DS 8/21/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
		} else if ( node0 ) {
			 // Get rid of the references.
			DeleteAllRefsFromMe();
			}
		theMaster = NULL; //JH 9/15/97
		}	
	}

RefResult RingMasterCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if (theMaster) {
				// this will set node0 ==NULL;
				DeleteAllRefsFromMe();
				goto endEdit;
				}
			else
				return REF_SUCCEED;  //JH 9.15.97 
			// fall through

		case REFMSG_TARGET_DELETED:
			if (theMaster) {
				endEdit:
				theMaster->EndEditParams( (IObjParam*)createInterface, FALSE/*destroy*/,NULL );
				theMaster = NULL;
				node0 = NULL;
				CreateNewMaster();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void RingMasterCreationManager::CreateNewMaster()
	{
	theMaster = new RingMaster();
	
	// Start the edit params process
	theMaster->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE,NULL );
	lastPutCount = theHold.GetGlobalPutCount();
	}

#define DUMSZ 20.0f
#define BOXSZ 20.0f

static BOOL needToss;

int RingMasterCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
	{	
	int res;
	INode *newNode,*dummyNode;	
	float r;
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );


	switch ( msg ) {
		case MOUSE_POINT:
				{
				if (point==0) {
					pt0 = m;	

					assert(theMaster);

					mat.IdentityMatrix();
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}
					if (createInterface->IsCPEdgeOnInView()) { 
						return FALSE;
						}
					if ( attachedToNode ) {
				   		// send this one on its way
				   		theMaster->EndEditParams( (IObjParam*)createInterface,0,NULL );
						
						// Get rid of the references.
						DeleteAllRefsFromMe();

						// new object
						CreateNewMaster();   // creates theMaster
						}

					needToss = theHold.GetGlobalPutCount()!=lastPutCount;

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();
					center = vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
					mat.SetTrans(center);

					// Create a dummy object & node
					DummyObject *dumObj = (DummyObject *)createInterface->
						CreateInstance(HELPER_CLASS_ID,Class_ID(DUMMY_CLASS_ID,0)); 			
					assert(dumObj);					
					dummyNode = createInterface->CreateObjectNode(dumObj);
					dumObj->SetBox(Box3(Point3(-DUMSZ,-DUMSZ,-DUMSZ),Point3(DUMSZ,DUMSZ,DUMSZ)));

					// make a box object
					GenBoxObject *ob = (GenBoxObject *)createInterface->
						CreateInstance(GEOMOBJECT_CLASS_ID,Class_ID(BOXOBJ_CLASS_ID,0));
					ob->SetParams(BOXSZ,BOXSZ,BOXSZ,1,1,1,FALSE); 

					// Make a bunch of nodes, hook the box object to and a
					// slave controller of the master control to each
					for (int i=0; i<theMaster->numNodes; i++) {
						newNode = createInterface->CreateObjectNode(ob);
						SlaveControl* slave = new SlaveControl(theMaster,i);
						newNode->SetTMController(slave);
						dummyNode->AttachChild(newNode);
						theMaster->SetSlaveNode(i,newNode);
						}

					// select the dummy node.
					attachedToNode = TRUE;

					// Reference the node so we'll get notifications.
				    MakeRefByID( FOREVER, 0, theMaster->GetSlaveNode(0) );
					theMaster->SetRad(TimeValue(0),0.0f);
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
					createInterface->SetNodeTMRelConstPlane(dummyNode, mat);
					res = TRUE;
					}
				else {
					// select a node so if go into modify branch, see params 
					ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( theMaster->GetSlaveNode(0) );
					ignoreSelectionChange = FALSE;
					theHold.Accept(IDS_DS_CREATE);
					res = FALSE;
					}
 				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_NORMAL,theMaster);  
				}
				break;
		case MOUSE_MOVE:
			if (node0) {
				r = (float)fabs(vpx->SnapLength(vpx->GetCPDisp(center,Point3(0,1,0),pt0,m)));
				theMaster->SetRad(0,r);
				theMaster->radSpin->SetValue(r, FALSE );
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_NORMAL,theMaster);
				}
			res = TRUE;
			break;

// mjm - 3.2.99 - begin
		case MOUSE_FREEMOVE:
			SetCursor( LoadCursor( hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR) ) );
			break;
// mjm - end

		case MOUSE_PROPCLICK:
			// right click while between creations
			createInterface->RemoveMode(NULL);
			break;

		case MOUSE_ABORT:
			assert(theMaster);
			theMaster->EndEditParams( (IObjParam*)createInterface, 0,NULL );
			theHold.Cancel();  // undo the changes
			// DS 8/21/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (needToss) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
			DeleteAllRefsFromMe();
			CreateNewMaster();	
			createInterface->RedrawViews(createInterface->GetTime(),REDRAW_END,theMaster); 
			attachedToNode = FALSE;
			res = FALSE;						
			break;
		}
	
	createInterface->ReleaseViewport(vpx); 
	return res;
	}

int RingMasterClassDesc::BeginCreate(Interface *i)
	{
	IObjCreate *iob = i->GetIObjCreate();
	
	theRingMasterCreateMode.Begin( iob, this );
	iob->PushCommandMode( &theRingMasterCreateMode );
	
	return TRUE;
	}

int RingMasterClassDesc::EndCreate(Interface *i)
	{
	theRingMasterCreateMode.End();
	i->RemoveMode( &theRingMasterCreateMode );
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\sphere.cpp ===
/**********************************************************************
 *<
	FILE: sphere.cpp

	DESCRIPTION:  Sphere object, Revised implementation

	CREATED BY: Rolf Berteig

	HISTORY: created 10/10/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"
#include "notify.h"

class SphereObject : public GenSphere, public IParamArray {
	public:			
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static int dlgSegments;
		static int dlgCreateMeth;
		static int dlgSmooth,dlgSlice;
		static Point3 crtPos;		
		static float crtRadius,crtSliceFrom,crtSliceTo;
		static IObjParam *ip;
		IParamBlock *temppb;
		// mjm - 3.19.99 - ensure accurate matIDs and smoothing groups
		int lastSquash;
		BOOL lastNoHemi;

		SphereObject();		
		~SphereObject();		
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_SPHERE); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		BOOL IsParamSurface() {return TRUE;}
		Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);

		// From GeomObject
		int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		
		// Animatable methods		
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(SPHERE_CLASS_ID,0); } 
		
		// From ReferenceTarget
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
				
		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

		// From GenSphere
		void SetParams(float rad, int segs, BOOL smooth=TRUE, BOOL genUV=TRUE,
			 float hemi=0.0f, BOOL squash=FALSE, BOOL recenter=FALSE);
		void PreSaveOld(); 
		void PostSaveOld(); 
	};


// Misc stuff
#define MAX_SEGMENTS	200
#define MIN_SEGMENTS	4

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float(1.0E30)

#define MIN_SMOOTH		0
#define MAX_SMOOTH		1

#define DEF_SEGMENTS	32	// 16
#define DEF_RADIUS		float(0.0)

#define SMOOTH_ON	1
#define SMOOTH_OFF	0

#define MIN_SLICE	float(-1.0E30)
#define MAX_SLICE	float( 1.0E30)


//--- ClassDescriptor and class vars ---------------------------------

// The class descriptor for sphere
class SphereClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SphereObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_SPHERE_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SPHERE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
	void			ResetClassParams(BOOL fileReset);
	};

static SphereClassDesc sphereDesc;
extern ClassDesc* GetSphereDesc() { return &sphereDesc; }


// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

int SphereObject::dlgSegments       = DEF_SEGMENTS;
int SphereObject::dlgCreateMeth     = 1; // create_radius
int SphereObject::dlgSmooth         = SMOOTH_ON;
IParamMap *SphereObject::pmapCreate = NULL;
IParamMap *SphereObject::pmapParam  = NULL;
IParamMap *SphereObject::pmapTypeIn = NULL;
IObjParam *SphereObject::ip         = NULL;
Point3 SphereObject::crtPos         = Point3(0,0,0);
float SphereObject::crtRadius       = 0.0f;
float SphereObject::crtSliceFrom       = 0.0f;
float SphereObject::crtSliceTo       = 0.0f;
int SphereObject::dlgSlice          = 0;

void SphereClassDesc::ResetClassParams(BOOL fileReset)
	{
	SphereObject::dlgSegments    = DEF_SEGMENTS;
	SphereObject::dlgCreateMeth  = 1; // create_radius
	SphereObject::dlgSmooth      = SMOOTH_ON;
	SphereObject::crtPos         = Point3(0,0,0);
	SphereObject::crtRadius      = 0.0f;
	SphereObject::dlgSlice          = 0;
	SphereObject::crtSliceFrom    = 0.0f;
	SphereObject::crtSliceTo    = 0.0f;
	}


//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS	0
#define PB_SEGS		1
#define PB_SMOOTH	2
#define PB_HEMI		3
#define PB_SQUASH	4
#define PB_RECENTER	5
#define PB_GENUVS	6
#define PB_SLICEON		7
#define PB_SLICEFROM	8
#define PB_SLICETO		9

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)	
	};
#define TYPEINDESC_LENGH 2


//
//
// Parameters

static int squashIDs[] = {IDC_HEMI_CHOP,IDC_HEMI_SQUASH};

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Segments
	ParamUIDesc(
		PB_SEGS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Smooth
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),

	// Hemisphere
	ParamUIDesc(
		PB_HEMI,
		EDITTYPE_FLOAT,
		IDC_HEMISPHERE,IDC_HEMISPHERESPINNER,
		0.0f,1.0f,
		0.005f),

	// Chop/squash
	ParamUIDesc(PB_SQUASH,TYPE_RADIO,squashIDs,2),

	// Gen Slice
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SC_SLICEON),			

	// Pie slice from
	ParamUIDesc(
		PB_SLICEFROM,
		EDITTYPE_FLOAT,
		IDC_SC_SLICE1,IDC_SC_SLICE1SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Pie slice to
	ParamUIDesc(
		PB_SLICETO,
		EDITTYPE_FLOAT,
		IDC_SC_SLICE2,IDC_SC_SLICE2SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Recenter
	ParamUIDesc(PB_RECENTER,TYPE_SINGLECHEKBOX,IDC_HEMI_RECENTER),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 10


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_BOOL, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 } };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_BOOL, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
};

#define PBLOCK_LENGTH	10

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0),
	ParamVersionDesc(descVer1,6,1),
	ParamVersionDesc(descVer2,7,2)
	};
#define NUM_OLDVERSIONS	3

// Current version
#define CURRENT_VERSION	3
static ParamVersionDesc curVersion(descVer3,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class SphereTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		SphereObject *so;

		SphereTypeInDlgProc(SphereObject *s) {so=s;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SphereTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (so->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (so->TestAFlag(A_OBJ_CREATING)) {
						so->pblock->SetValue(PB_RADIUS,0,so->crtRadius);
						}

					Matrix3 tm(1);
					tm.SetTrans(so->crtPos);
					so->suspendSnap = FALSE;
					so->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

//--- ParamDlgProc --------------------------------
void TurnSpinner(HWND hWnd,int SpinNum,BOOL ison)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	if (ison) spin2->Enable();else spin2->Disable();
	ReleaseISpinner(spin2);

};

class SphereParamDlgProc : public ParamMapUserDlgProc {
	public:
		SphereObject *so;
		HWND thishWnd;

		SphereParamDlgProc(SphereObject *s) {so=s;thishWnd=NULL;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void SphereParamDlgProc::Update(TimeValue t)
{ if (!thishWnd) return;
  int ison;
  so->pblock->GetValue(PB_SLICEON,0,ison,FOREVER);
  TurnSpinner(thishWnd,IDC_SC_SLICE1SPIN,ison);
  TurnSpinner(thishWnd,IDC_SC_SLICE2SPIN,ison);
}

BOOL SphereParamDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{ thishWnd=hWnd;
	switch (msg) {
		case WM_INITDIALOG:
			Update(t);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SC_SLICEON: {
					int ison;
					so->pblock->GetValue(PB_SLICEON,0,ison,FOREVER);
					TurnSpinner(hWnd,IDC_SC_SLICE1SPIN,ison);
					TurnSpinner(hWnd,IDC_SC_SLICE2SPIN,ison);
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}



static void NotifyPreSaveOld(void *param, NotifyInfo *info) {
	SphereObject *mt = (SphereObject *)param;
	mt->PreSaveOld();
	}

static void NotifyPostSaveOld(void *param, NotifyInfo *info) {
	SphereObject *mt = (SphereObject *)param;
	mt->PostSaveOld();
	}

//--- Sphere methods -------------------------------


SphereObject::SphereObject() : lastSquash(-1), lastNoHemi(FALSE)
{
	SetAFlag(A_PLUGIN1);
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer3, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	temppb = NULL;
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGS,0,dlgSegments);	
	pblock->SetValue(PB_SQUASH,0,0);
	pblock->SetValue(PB_SLICEON,0,dlgSlice);
	pblock->SetValue(PB_SLICEFROM,0,crtSliceFrom);
	pblock->SetValue(PB_SLICETO,0,crtSliceTo);
	RegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
	RegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);
}

SphereObject::~SphereObject() {
	UnRegisterNotification(NotifyPreSaveOld, (void *)this, NOTIFY_FILE_PRE_SAVE_OLD);
	UnRegisterNotification(NotifyPostSaveOld, (void *)this, NOTIFY_FILE_POST_SAVE_OLD);
	}

void SphereObject::PreSaveOld() { 
	if (GetSavingVersion()==2000) {
		temppb = pblock;
		pblock =  UpdateParameterBlock(descVer3,PBLOCK_LENGTH,temppb, descVer2,7,2);
		}
	}

void SphereObject::PostSaveOld() { 
	if (temppb) {
		pblock->DeleteThis();
		pblock = temppb;
		temppb = NULL;
		}
	}


#define NEWMAP_CHUNKID	0x0100

IOResult SphereObject::Load(ILoad *iload) 
	{
	ClearAFlag(A_PLUGIN1);

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

IOResult SphereObject::Save(ISave *isave)
	{
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
 	return IO_OK;
	}

void SphereObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last sphere ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPHEREPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPHEREPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SPHEREPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new SphereTypeInDlgProc(this));
		}
	if(pmapParam) {
		// A callback for the type in.
		pmapParam->SetUserDlgProc(new SphereParamDlgProc(this));
		}
	}
		
void SphereObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SEGS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	}

Point3 SphereObject::GetSurfacePoint(
		TimeValue t, float u, float v,Interval &iv)
	{
	float rad;
	pblock->GetValue(PB_RADIUS, t, rad, iv);
	Point3 pos;	
	v -= 0.5f;
	float ar = (float)cos(v*PI);
	pos.x = rad * float(cos(u*TWOPI)) * ar;
	pos.y = rad * float(sin(u*TWOPI)) * ar;
	pos.z = rad * float(sin(v*PI));
	return pos;
	}

void SphereObject::SetParams(float rad, int segs, BOOL smooth, BOOL genUV,
	 float hemi, BOOL squash, BOOL recenter) {
	pblock->SetValue(PB_RADIUS,0, rad);				
	pblock->SetValue(PB_HEMI,0, hemi);				
	pblock->SetValue(PB_SEGS,0, segs);				
	pblock->SetValue(PB_SQUASH,0, squash);				
	pblock->SetValue(PB_SMOOTH,0, smooth);				
	pblock->SetValue(PB_RECENTER,0, recenter);				
	pblock->SetValue(PB_GENUVS,0, genUV);				
	}			   

BOOL SphereObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void SphereObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

float uval[3]={1.0f,0.0f,1.0f};
void SphereObject::BuildMesh(TimeValue t)
	{
	Point3 p;	
	int ix,na,nb,nc,nd,jx,kx;
	int nf=0,nv=0;
	float delta, delta2;
	float a,alt,secrad,secang,b,c;
	int segs, smooth;
	float radius;
	float hemi;
	BOOL noHemi = FALSE;	
	int squash;
	int recenter;
	BOOL genUVs = TRUE;
	float startAng = 0.0f;
	float pie1,pie2;int doPie;
	if (TestAFlag(A_PLUGIN1)) startAng = HALFPI;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	pblock->GetValue(PB_RADIUS, t, radius, ivalid);
	pblock->GetValue(PB_SEGS, t, segs, ivalid);
	pblock->GetValue(PB_SMOOTH, t, smooth, ivalid);
	pblock->GetValue(PB_HEMI, t, hemi, ivalid);
	pblock->GetValue(PB_SQUASH, t, squash, ivalid);
	pblock->GetValue(PB_RECENTER, t, recenter, ivalid);
	pblock->GetValue(PB_GENUVS, t, genUVs, ivalid);
	pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
	pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	LimitValue(segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(smooth, MIN_SMOOTH, MAX_SMOOTH);
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(hemi, 0.0f, 1.0f);

	float totalPie(0.0f);
	if (doPie) doPie = 1;
	else doPie = 0;
	if (doPie)
	{ pie2+=startAng;pie1+=startAng;
	  while (pie1 < pie2) pie1 += TWOPI;
	  while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	  if (pie1==pie2) totalPie = TWOPI;
	  else totalPie = pie1-pie2;	
	}

	if (hemi<0.00001f) noHemi = TRUE;
	if (hemi>=1.0f) hemi = 0.9999f;
	hemi = (1.0f-hemi) * PI;
	float basedelta=2.0f*PI/(float)segs;
	delta2=(doPie?totalPie/(float)segs:basedelta);
	if (!noHemi && squash) {
		delta  = 2.0f*hemi/float(segs-2);
	} else {
		delta  = basedelta;
		}

	int rows;
	if (noHemi || squash) {
		rows = (segs/2-1);
	} else {
		rows = int(hemi/delta) + 1;
		}
	int realsegs=(doPie?segs+2:segs);
	int nverts = rows * realsegs + 2;
	int nfaces = rows * realsegs * 2;
	if (doPie) 
	{ startAng=pie2;segs+=1;
	  if (!noHemi) {nfaces-=2;nverts-=1;}
	}
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	int lastvert=nverts-1;

	// mjm - 3.19.99 - ensure accurate matIDs and smoothing groups
	if (lastSquash != squash || lastNoHemi != noHemi)
	{
		lastSquash = squash;
		lastNoHemi = noHemi;
		mesh.InvalidateStrips();
	}

	// Top vertex 
	mesh.setVert(nv, 0.0f, 0.0f, radius);
	nv++;

	// Middle vertices 
	alt=delta;
	for(ix=1; ix<=rows; ix++) {		
		if (!noHemi && ix==rows) alt = hemi;
		a = (float)cos(alt)*radius;		
		secrad = (float)sin(alt)*radius;
		secang = startAng; //0.0f
		for(jx=0; jx<segs; ++jx) {
			b = (float)cos(secang)*secrad;
			c = (float)sin(secang)*secrad;
			mesh.setVert(nv++,b,c,a);
			secang+=delta2;
			}
		if (doPie &&(noHemi ||(ix<rows))) mesh.setVert(nv++,0.0f,0.0f,a);
		alt+=delta;		
		}

	/* Bottom vertex */
	if (noHemi) {
		mesh.setVert(nv++, 0.0f, 0.0f,-radius);
		}
	else {
		a = (float)cos(hemi)*radius;
		mesh.setVert(nv++, 0.0f, 0.0f, a);
		}

	BOOL issliceface;
	// Now make faces 
	if (doPie) segs++;

	// Make top conic cap
	for(ix=1; ix<=segs; ++ix) {
		issliceface=(doPie && (ix>=segs-1));
		nc=(ix==segs)?1:ix+1;
		mesh.faces[nf].setEdgeVisFlags(1,1,1);
		if ((issliceface)&&(ix==segs-1))
		{	mesh.faces[nf].setSmGroup(smooth?4:0);
			mesh.faces[nf].setMatID(2);
		}
		else if ((issliceface)&&(ix==segs))
		{	mesh.faces[nf].setSmGroup(smooth?8:0);
			mesh.faces[nf].setMatID(3);
		}
		else
		{	mesh.faces[nf].setSmGroup(smooth?1:0);
			mesh.faces[nf].setMatID(1); // mjm - 5.5.99 - rollback change - should be fixed in later release
//			mesh.faces[nf].setMatID(0); // mjm - 3.2.99 - was set to 1
		}
		mesh.faces[nf].setVerts(0, ix, nc);
		nf++;
		}

	/* Make midsection */
	int lastrow=rows-1,lastseg=segs-1,almostlast=lastseg-1;
	BOOL weirdpt=doPie && !noHemi,weirdmid=weirdpt && (rows==2);
	for(ix=1; ix<rows; ++ix) {
		jx=(ix-1)*segs+1;
		for(kx=0; kx<segs; ++kx) {
			issliceface=(doPie && (kx>=almostlast));

			na = jx+kx;
			nb = na+segs;
			nb = (weirdmid &&(kx==lastseg)? lastvert:na+segs);
			if ((weirdmid) &&(kx==almostlast)) nc=lastvert; else
			nc = (kx==lastseg)? jx+segs: nb+1;
			nd = (kx==lastseg)? jx : na+1;
			
			mesh.faces[nf].setEdgeVisFlags(1,1,0);

			if ((issliceface)&&((kx==almostlast-2)||(kx==almostlast)))
			{	mesh.faces[nf].setSmGroup(smooth?4:0);
				mesh.faces[nf].setMatID(2);
			}
			else if((issliceface)&&((kx==almostlast-1)||(kx==almostlast+1)))
			{	mesh.faces[nf].setSmGroup(smooth?8:0);
				mesh.faces[nf].setMatID(3);
			}
			else
			{	mesh.faces[nf].setSmGroup(smooth?1:0);
				mesh.faces[nf].setMatID(1); // mjm - 5.5.99 - rollback change - should be fixed in later release
//				mesh.faces[nf].setMatID(0); // mjm - 3.2.99 - was set to 1
			}

			mesh.faces[nf].setVerts(na,nb,nc);
			nf++;

			mesh.faces[nf].setEdgeVisFlags(0,1,1);

			if ((issliceface)&&((kx==almostlast-2)||(kx==almostlast)))
			{	mesh.faces[nf].setSmGroup(smooth?4:0);
				mesh.faces[nf].setMatID(2);
			}
			else if((issliceface)&&((kx==almostlast-1)||(kx==almostlast+1)))
			{	mesh.faces[nf].setSmGroup(smooth?8:0);
				mesh.faces[nf].setMatID(3);
			}
			else
			{	mesh.faces[nf].setSmGroup(smooth?1:0);
				mesh.faces[nf].setMatID(1); // mjm - 5.5.99 - rollback change - should be fixed in later release
//				mesh.faces[nf].setMatID(0); // mjm - 3.2.99 - was set to 1
			}

			mesh.faces[nf].setVerts(na,nc,nd);
			nf++;
			}
	 	}

	// Make bottom conic cap
	na = mesh.getNumVerts()-1;
	int botsegs=(weirdpt?segs-2:segs);
	jx = (rows-1)*segs+1;lastseg=botsegs-1;
	for(ix=0; ix<botsegs; ++ix) {
		issliceface=(doPie && (ix>=botsegs-2));
		nc = ix + jx;
		nb = (!weirdpt && (ix==lastseg)?jx:nc+1);
		mesh.faces[nf].setEdgeVisFlags(1,1,1);

		if ((issliceface)&&(noHemi)&&(ix==botsegs-2))
		{	mesh.faces[nf].setSmGroup(smooth?4:0);
			mesh.faces[nf].setMatID(2);
		}
		else if ((issliceface)&&(noHemi)&&(ix==botsegs-1))
		{	mesh.faces[nf].setSmGroup(smooth?8:0);
			mesh.faces[nf].setMatID(3);
		}
		else if ((!issliceface)&&(noHemi))
		{	mesh.faces[nf].setSmGroup(smooth?1:0);
			mesh.faces[nf].setMatID(1); // mjm - 5.5.99 - rollback change - should be fixed in later release
//			mesh.faces[nf].setMatID(0); // mjm - 3.2.99 - was set to 1
		}
		else if (!noHemi)
		{	mesh.faces[nf].setSmGroup(smooth?2:0);
			mesh.faces[nf].setMatID(0); // mjm - 5.5.99 - rollback change - should be fixed in later release
//			mesh.faces[nf].setMatID(1); // mjm - 3.2.99 - was set to 0
		}
//		else
//		{	mesh.faces[nf].setSmGroup(0);
//			mesh.faces[nf].setMatID(noHemi?1:0); // mjm - 5.5.99 - rollback change - should be fixed in later release
//			mesh.faces[nf].setMatID(noHemi?0:1); // mjm - 3.2.99 - was commented out but set to 1:0
//		}

		mesh.faces[nf].setVerts(na, nb, nc);

		nf++;
		}

	// Put the flat part of the hemisphere at z=0
	if (recenter) {
		float shift = (float)cos(hemi) * radius;
		for (ix=0; ix<mesh.getNumVerts(); ix++) {
			mesh.verts[ix].z -= shift;
			}
		}

	if (genUVs) {
		int tvsegs=segs;
		int tvpts=(doPie?segs+1:segs); 
		int ntverts = (rows+2)*(tvpts+1);
//		if (doPie) {ntverts-=6; if (weirdpt) ntverts-3;}
		mesh.setNumTVerts(ntverts);
		mesh.setNumTVFaces(nfaces);
		nv = 0;
		delta  = basedelta;  // make the texture squash too
		alt = 0.0f; // = delta;
		int dsegs=(doPie?3:0),midsegs=tvpts-dsegs,m1=midsegs+1,t1=tvpts+1;
		for(ix=0; ix < rows+2; ix++) {		
		//	if (!noHemi && ix==rows) alt = hemi;		
			secang = 0.0f; //angle;
			float yang=1.0f-alt/PI;
			for(jx=0; jx <= midsegs; ++jx) {
				mesh.setTVert(nv++, secang/TWOPI, yang, 0.0f);
				secang += delta2;
				}
			for (jx=0;jx<dsegs;jx++) mesh.setTVert(nv++,uval[jx],yang,0.0f);
			alt += delta;		
			}

		nf = 0;dsegs=(doPie?2:0),midsegs=segs-dsegs;
		// Make top conic cap
		for(ix=0; ix<midsegs; ++ix) {
			mesh.tvFace[nf++].setTVerts(ix,ix+t1,ix+t1+1);
		} ix=midsegs+1;int topv=ix+1;
		for (jx=0;jx<dsegs;jx++) 
		{ mesh.tvFace[nf++].setTVerts(topv,ix+t1,ix+t1+1);ix++;
		}
		int cpt;
		/* Make midsection */
		for(ix=1; ix<rows; ++ix) {
			cpt=ix*t1;
			for(kx=0; kx<tvsegs; ++kx) {
				if (kx==midsegs) cpt++;
				na = cpt+kx;
				nb = na+t1;
				nc = nb+1;
				nd = na+1;
				assert(nc<ntverts);
				assert(nd<ntverts);
				mesh.tvFace[nf++].setTVerts(na,nb,nc);
				mesh.tvFace[nf++].setTVerts(na,nc,nd);
				}
			}
		// Make bottom conic cap
		int lastv=rows*t1,jx=lastv+t1;
		if (weirdpt) dsegs=0;
		for (int j1=lastv; j1<lastv+midsegs; j1++) {
			mesh.tvFace[nf++].setTVerts(jx,j1+1,j1);jx++;
			}j1=lastv+midsegs+1;topv=j1+t1+1;
		for (ix=0;ix<dsegs;ix++) 
		{ mesh.tvFace[nf++].setTVerts(topv,j1+1,j1);j1++;
		}
		assert(nf==nfaces);
		}
	else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

// Triangular patch layout:
//
//   A---> ac ----- ca <---C
//   |                    / 
//   |                  /
//   v    i1    i3    /
//   ab            cb
//
//   |           /
//   |    i2   /
// 
//   ba     bc
//   ^     /
//   |   /
//   | /
//   B
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

// Vector length for unit circle
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

static void BuildSpherePatch(PatchMesh& amesh, float radius, int smooth, BOOL textured)
	{
	Point3 p;	
	int np=0,nv=0;
	
	int nverts = 6;
	int nvecs = 48;
	int npatches = 8;
	amesh.setNumVerts(nverts);
	amesh.setNumTVerts(textured ? 13 : 0);
	amesh.setNumVecs(nvecs);
	amesh.setNumPatches(npatches);
	amesh.setNumTVPatches(textured ? npatches : 0);

	Point3 v0(0.0f, 0.0f, radius);		// Top
	Point3 v1(0.0f, 0.0f, -radius);		// Bottom
	Point3 v2(0.0f, -radius, 0.0f);		// Front
	Point3 v3(radius, 0.0f, 0.0f);		// Right
	Point3 v4(0.0f, radius, 0.0f);		// Back
	Point3 v5(-radius, 0.0f, 0.0f);		// Left

	// Create the vertices.
	amesh.verts[0].flags = PVERT_COPLANAR;
	amesh.verts[1].flags = PVERT_COPLANAR;
	amesh.verts[2].flags = PVERT_COPLANAR;
	amesh.verts[3].flags = PVERT_COPLANAR;
	amesh.verts[4].flags = PVERT_COPLANAR;
	amesh.verts[5].flags = PVERT_COPLANAR;
	amesh.setVert(0, v0);
	amesh.setVert(1, v1);
	amesh.setVert(2, v2);
	amesh.setVert(3, v3);
	amesh.setVert(4, v4);
	amesh.setVert(5, v5);

	if(textured) {
		amesh.setTVert(0, UVVert(0.125f,1.0f,0.0f));
		amesh.setTVert(1, UVVert(0.375f,1.0f,0.0f));
		amesh.setTVert(2, UVVert(0.625f,1.0f,0.0f));
		amesh.setTVert(3, UVVert(0.875f,1.0f,0.0f));
		amesh.setTVert(4, UVVert(0.0f,0.5f,0.0f));
		amesh.setTVert(5, UVVert(0.25f,0.5f,0.0f));
		amesh.setTVert(6, UVVert(0.5f,0.5f,0.0f));
		amesh.setTVert(7, UVVert(0.75f,0.5f,0.0f));
		amesh.setTVert(8, UVVert(1.0f,0.5f,0.0f));
		amesh.setTVert(9, UVVert(0.125f,0.0f,0.0f));
		amesh.setTVert(10, UVVert(0.375f,0.0f,0.0f));
		amesh.setTVert(11, UVVert(0.625f,0.0f,0.0f));
		amesh.setTVert(12, UVVert(0.875f,0.0f,0.0f));

		amesh.getTVPatch(0).setTVerts(3,7,8);
		amesh.getTVPatch(1).setTVerts(0,4,5);
		amesh.getTVPatch(2).setTVerts(1,5,6);
		amesh.getTVPatch(3).setTVerts(2,6,7);
		amesh.getTVPatch(4).setTVerts(12,8,7);
		amesh.getTVPatch(5).setTVerts(9,5,4);
		amesh.getTVPatch(6).setTVerts(10,6,5);
		amesh.getTVPatch(7).setTVerts(11,7,6);
		}

	// Create the edge vectors
	float vecLen = CIRCLE_VECTOR_LENGTH * radius;
	Point3 xVec(vecLen, 0.0f, 0.0f);
	Point3 yVec(0.0f, vecLen, 0.0f);
	Point3 zVec(0.0f, 0.0f, vecLen);
	amesh.setVec(0, v0 - yVec);
	amesh.setVec(2, v0 + xVec);
	amesh.setVec(4, v0 + yVec);
	amesh.setVec(6, v0 - xVec);
	amesh.setVec(8, v1 - yVec);
	amesh.setVec(10, v1 + xVec);
	amesh.setVec(12, v1 + yVec);
	amesh.setVec(14, v1 - xVec);
	amesh.setVec(9, v2 - zVec);
	amesh.setVec(16, v2 + xVec);
	amesh.setVec(1, v2 + zVec);
	amesh.setVec(23, v2 - xVec);
	amesh.setVec(11, v3 - zVec);
	amesh.setVec(18, v3 + yVec);
	amesh.setVec(3, v3 + zVec);
	amesh.setVec(17, v3 - yVec);
	amesh.setVec(13, v4 - zVec);
	amesh.setVec(20, v4 - xVec);
	amesh.setVec(5, v4 + zVec);
	amesh.setVec(19, v4 + xVec);
	amesh.setVec(15, v5 - zVec);
	amesh.setVec(22, v5 - yVec);
	amesh.setVec(7, v5 + zVec);
	amesh.setVec(21, v5 + yVec);
	
	// Create the patches
	amesh.MakeTriPatch(np++, 0, 0, 1, 2, 16, 17, 3, 3, 2, 24, 25, 26, smooth);
	amesh.MakeTriPatch(np++, 0, 2, 3, 3, 18, 19, 4, 5, 4, 27, 28, 29, smooth);
	amesh.MakeTriPatch(np++, 0, 4, 5, 4, 20, 21, 5, 7, 6, 30, 31, 32, smooth);
	amesh.MakeTriPatch(np++, 0, 6, 7, 5, 22, 23, 2, 1, 0, 33, 34, 35, smooth);
	amesh.MakeTriPatch(np++, 1, 10, 11, 3, 17, 16, 2, 9, 8, 36, 37, 38, smooth);
	amesh.MakeTriPatch(np++, 1, 12, 13, 4, 19, 18, 3, 11, 10, 39, 40, 41, smooth);
	amesh.MakeTriPatch(np++, 1, 14, 15, 5, 21, 20, 4, 13, 12, 42, 43, 44, smooth);
	amesh.MakeTriPatch(np++, 1, 8, 9, 2, 23, 22, 5, 15, 14, 45, 46, 47, smooth);

	// Create all the interior vertices and make them non-automatic
	float chi = 0.5893534f * radius;

	int interior = 24;
	amesh.setVec(interior++, Point3(chi, -chi, radius)); 
	amesh.setVec(interior++, Point3(chi, -radius, chi)); 
	amesh.setVec(interior++, Point3(radius, -chi, chi)); 

	amesh.setVec(interior++, Point3(chi, chi, radius)); 
	amesh.setVec(interior++, Point3(radius, chi, chi)); 
	amesh.setVec(interior++, Point3(chi, radius, chi)); 

	amesh.setVec(interior++, Point3(-chi, chi, radius)); 
	amesh.setVec(interior++, Point3(-chi, radius, chi)); 
	amesh.setVec(interior++, Point3(-radius, chi, chi)); 

	amesh.setVec(interior++, Point3(-chi, -chi, radius)); 
	amesh.setVec(interior++, Point3(-radius, -chi, chi)); 
	amesh.setVec(interior++, Point3(-chi, -radius, chi)); 

	amesh.setVec(interior++, Point3(chi, -chi, -radius)); 
	amesh.setVec(interior++, Point3(radius, -chi, -chi)); 
	amesh.setVec(interior++, Point3(chi, -radius, -chi)); 

	amesh.setVec(interior++, Point3(chi, chi, -radius)); 
	amesh.setVec(interior++, Point3(chi, radius, -chi)); 
	amesh.setVec(interior++, Point3(radius, chi, -chi)); 

	amesh.setVec(interior++, Point3(-chi, chi, -radius)); 
	amesh.setVec(interior++, Point3(-radius, chi, -chi)); 
	amesh.setVec(interior++, Point3(-chi, radius, -chi)); 

	amesh.setVec(interior++, Point3(-chi, -chi, -radius)); 
	amesh.setVec(interior++, Point3(-chi, -radius, -chi)); 
	amesh.setVec(interior++, Point3(-radius, -chi, -chi)); 

	for(int i = 0; i < 8; ++i)
		amesh.patches[i].SetAuto(FALSE);

	// Finish up patch internal linkages (and bail out if it fails!)
	assert(amesh.buildLinkages());

	// Calculate the interior bezier points on the PatchMesh's patches
	amesh.computeInteriors();
	amesh.InvalidateGeomCache();
	}


#ifndef NO_NURBS

Object *
BuildNURBSSphere(float radius, float hemi, BOOL recenter, BOOL genUVs, BOOL doPie, float pie1, float pie2)
{
	NURBSSet nset;

	Point3 center(0,0,0);
	Point3 northAxis(0,0,1);
	Point3 refAxis(0,-1,0);

	if (recenter)
		center = Point3(0.0, 0.0, -cos((1.0f-hemi) * PI) * radius);

	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	surf->SetTextureUVs(0, 0, Point2(0.0f, hemi));
	surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	surf->SetTextureUVs(0, 2, Point2(1.0f, hemi));
	surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	surf->FlipNormals(TRUE);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_SPHERE));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);

	float startAngleU = 0.0f;
	float endAngleU = TWOPI;
	pie1 += HALFPI;
	pie2 += HALFPI;
	if (doPie && pie1 != pie2) {
		float sweep = TWOPI - (pie2-pie1);
		if (sweep > TWOPI) sweep -= TWOPI;
		refAxis = Point3(Point3(1,0,0) * RotateZMatrix(pie2));
		endAngleU = sweep;
		if (fabs(endAngleU) < 1e-5) endAngleU = TWOPI;
	}
	if (hemi == 0.0f && (!doPie || endAngleU == TWOPI)) {
		GenNURBSSphereSurface(radius, center, northAxis, Point3(0,-1,0),
						-PI, PI, -HALFPI, HALFPI,
						FALSE, *surf);
	} else if (hemi > 0.0f && (!doPie || endAngleU == TWOPI)) {
		GenNURBSSphereSurface(radius, center, northAxis, Point3(0,-1,0),
						-PI, PI, -HALFPI + (hemi * PI), HALFPI,
						FALSE, *surf);
		// now cap it
		NURBSCapSurface *cap0 = new NURBSCapSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0);
		cap0->SetEdge(0);
		cap0->FlipNormals(TRUE);
		cap0->Renderable(TRUE);
		char sname[80];
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
		cap0->SetName(sname);
	} else {
		float startAngleV = -HALFPI + (hemi * PI);
		float endAngleV = HALFPI;
		GenNURBSSphereSurface(radius, center, northAxis, refAxis,
						startAngleU, endAngleU, startAngleV, endAngleV,
						TRUE, *surf);
#define F(s1, s2, s1r, s1c, s2r, s2c) \
		fuse.mSurf1 = (s1); \
		fuse.mSurf2 = (s2); \
		fuse.mRow1 = (s1r); \
		fuse.mCol1 = (s1c); \
		fuse.mRow2 = (s2r); \
		fuse.mCol2 = (s2c); \
		nset.mSurfFuse.Append(1, &fuse);

		NURBSFuseSurfaceCV fuse;

		// pole(s)
		for (int f = 1; f < surf->GetNumVCVs(); f++) {
			if (hemi <= 0.0f) {
				// south pole
				F(0, 0, 0, 0, 0, f);
			}
			//north pole
			F(0, 0, surf->GetNumUCVs()-1, 0, surf->GetNumUCVs()-1, f);
		}

		NURBSCVSurface *s0 = (NURBSCVSurface*)nset.GetNURBSObject(0);
		int numU, numV;
		s0->GetNumCVs(numU, numV);


		if (doPie && endAngleU > 0.0f && endAngleU < TWOPI) {
			// next the two pie slices
			for (int c = 0; c < 2; c++) {
				NURBSCVSurface *s = new NURBSCVSurface();
				nset.AppendObject(s);
				// we'll be cubic in on direction and match the sphere in the other
				s->SetUOrder(s0->GetUOrder());
				int numKnots = s0->GetNumUKnots();
				s->SetNumUKnots(numKnots);
				for (int i = 0; i < numKnots; i++)
					s->SetUKnot(i, s0->GetUKnot(i));

				s->SetVOrder(4);
				s->SetNumVKnots(8);
				for (i = 0; i < 4; i++) {
					s->SetVKnot(i, 0.0);
					s->SetVKnot(i+4, 1.0);
				}

				s->SetNumCVs(numU, 4);
				for (int v = 0; v < 4; v++) {
					for (int u = 0; u < numU; u++) {
						if (v == 0) { // outside edge
							if (c == 0) {
								s->SetCV(u, v, *s0->GetCV(u, 0));
								F(0, 1, u, 0, u, v);
							} else {
								s->SetCV(u, v, *s0->GetCV(u, numV-1));
								F(0, 2, u, numV-1, u, v);
							}
						} else
						if (v == 3) { // center axis
							Point3 p(0.0f, 0.0f, s0->GetCV(u, 0)->GetPosition(0).z);
							NURBSControlVertex ncv;
							ncv.SetPosition(0, p);
							ncv.SetWeight(0, 1.0f);
							s->SetCV(u, v, ncv);
							F(1, c+1, u, 3, u, v);
						} else {
							Point3 center(0.0f, 0.0f, s0->GetCV(u, 0)->GetPosition(0).z);
							Point3 edge;
							if (c == 0)
								edge = Point3(s0->GetCV(u, 0)->GetPosition(0));
							else
								edge = Point3(s0->GetCV(u, numV-1)->GetPosition(0));
							NURBSControlVertex ncv;
							ncv.SetPosition(0, center + ((edge - center)*(float)v/3.0f));
							ncv.SetWeight(0, 1.0f);
							s->SetCV(u, v, ncv);
						}
					}
				}
				s->SetGenerateUVs(genUVs);

				s->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
				s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
				s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
				s->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

				if (c == 0)
					s->FlipNormals(FALSE);
				else
					s->FlipNormals(TRUE);
				s->Renderable(TRUE);
				sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_SLICE), c+1);
				s->SetName(sname);
			}
		}

		if (hemi > 0.0f) {
			// Cap -- we will always have slices since we
			// handle the non-slice cases with cap surfaces

			NURBSCVSurface *s = new NURBSCVSurface();
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(1.0f, 1.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));

			s->FlipNormals(TRUE);
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%01", bname, GetString(IDS_CT_CAP));
			s->SetName(sname);
			int cap = nset.AppendObject(s);

			// we'll be cubic in on direction and match the sphere in the other
			s->SetUOrder(4);
			s->SetNumUKnots(8);
			for (int i = 0; i < 4; i++) {
				s->SetUKnot(i, 0.0);
				s->SetUKnot(i+4, 1.0);
			}

			s->SetVOrder(s0->GetVOrder());
			s->SetNumVKnots(s0->GetNumVKnots());
			for (i = 0; i < s->GetNumVKnots(); i++)
				s->SetVKnot(i, s0->GetVKnot(i));

			s->SetNumCVs(4, numV);

			Point3 bot;
			if (recenter)
				bot = Point3(0,0,0);
			else
				bot = Point3(0.0, 0.0, cos((1.0-hemi) * PI)*radius);
			for (int v = 0; v < numV; v++) {
				Point3 edge = s0->GetCV(0, v)->GetPosition(0);
				double w = s0->GetCV(0, v)->GetWeight(0);
				for (int u = 0; u < 4; u++) {
					NURBSControlVertex ncv;
					ncv.SetPosition(0, bot + ((edge - bot)*((float)u/3.0f)));
					ncv.SetWeight(0, w);
					s->SetCV(u, v, ncv);
					if (u == 3) {
						// fuse the cap to the sphere
						F(cap, 0, 3, v, 0, v);
					}
					if (u == 1 || u == 2) {
						// fuse the ends to the slices
						if (v == 0) {
							F(cap, 1, u, v, 0, u);
						}
						if (v == numV-1) {
							F(cap, 2, u, v, 0, u);
						}
					}
				}

				if (v > 0) {
					// fuse the center degeneracy
					F(cap, cap, 0, 0, 0, v);
				}
			}
		}
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}


#endif

Object* SphereObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius;
		int smooth, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildSpherePatch(ob->patch,radius,smooth,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 
#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius, hemi;
		int recenter, genUVs;
		float pie1, pie2;
		BOOL doPie;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEMI,t,hemi,valid);	
		pblock->GetValue(PB_RECENTER,t,recenter,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
		pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
		pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
		Object *ob = BuildNURBSSphere(radius, hemi, recenter,genUVs, doPie, pie1, pie2);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
		
	}
#endif

#ifdef DESIGN_VER
	if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		float radius, hemi;
		int recenter, genUVs, sides;
		float pie1, pie2;
		BOOL doPie;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_HEMI,t,hemi,valid);	
		pblock->GetValue(PB_SEGS,t,sides,valid);
		pblock->GetValue(PB_RECENTER,t,recenter,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
		pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
		pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
		int smooth;
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);
		if (radius < 0.0f) radius = 0.0f;
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = cacheptr->createSphere(radius, sides, smooth);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif
	else{
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int SphereObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==patchObjectClassID || obtype==defObjectClassID ||
		obtype==triObjectClassID) {
		return 1;
	}
#ifndef NO_NURBS
    else if (obtype == EDITABLE_SURF_CLASS_ID)
        return 1;
#endif

#ifdef DESIGN_VER
	else if (obtype == GENERIC_AMSOLID_CLASS_ID)
		return 1;
#endif
	else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}


void SphereObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}

class SphereObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	SphereObject *ob;
	Point3 p0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(SphereObject *obj) {ob = obj;}
	};

int SphereObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1,center;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				ob->pblock->SetValue(PB_RADIUS,0,0.0f);
				ob->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {
					r = Length(p1-p0);
					mat.SetTrans(p0);
					}
				else {
					center = (p0+p1)/float(2);
					mat.SetTrans(center);
					r = Length(center-p0);
					} 
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f)?CREATE_ABORT:CREATE_STOP;
					}
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static SphereObjCreateCallBack sphereCreateCB;

CreateMouseCallBack* SphereObject::GetCreateMouseCallBack() 
	{
	sphereCreateCB.SetObj(this);
	return(&sphereCreateCB);
	}


BOOL SphereObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}



// From ParamArray
BOOL SphereObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL SphereObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		}	
	return TRUE;
	}

BOOL SphereObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		}
	return TRUE;
	}

BOOL SphereObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


// From GeomObject
int SphereObject::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
	{
	int smooth, recenter;
	pblock->GetValue(PB_SMOOTH,t,smooth,FOREVER);
	pblock->GetValue(PB_RECENTER,t,recenter,FOREVER);	
	float hemi;
	pblock->GetValue(PB_HEMI,t,hemi,FOREVER);
	if (!smooth || hemi!=0.0f || recenter) {
		return SimpleObject::IntersectRay(t,ray,at,norm);
		}	
	
	float r;
	float a, b, c, ac4, b2, at1, at2;
	float root;
	BOOL neg1, neg2;

	pblock->GetValue(PB_RADIUS,t,r,FOREVER);

	a = DotProd(ray.dir,ray.dir);
	b = DotProd(ray.dir,ray.p) * 2.0f;
	c = DotProd(ray.p,ray.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return 0;

	// We want the smallest positive root
	root = float(sqrt(b2-ac4));
	at1 = (-b + root) / (2.0f * a);
	at2 = (-b - root) / (2.0f * a);
	neg1 = at1<0.0f;
	neg2 = at2<0.0f;
	if (neg1 && neg2) return 0;
	else
	if (neg1 && !neg2) at = at2;
	else 
	if (!neg1 && neg2) at = at1;
	else
	if (at1<at2) at = at1;
	else at = at2;
	
	norm = Normalize(ray.p + at*ray.dir);

	return 1;
	}

void SphereObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *SphereObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		case PB_HEMI:
			return stdNormalizedDim;
		case PB_SEGS:
			return stdSegmentsDim;			
		case PB_SMOOTH:
			return stdNormalizedDim;			
		case PB_SLICEFROM: return stdAngleDim;
		case PB_SLICETO: return stdAngleDim;
		default:
			return defaultDim;
		}
	}

TSTR SphereObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return TSTR(GetString(IDS_RB_RADIUS));			
		case PB_HEMI:
			return GetString(IDS_RB_HEMISPHERE);
		case PB_SEGS:
			return TSTR(GetString(IDS_RB_SEGS));			
		case PB_SMOOTH:
			return TSTR(GetString(IDS_RB_SMOOTH));			
		case PB_SLICEON: return TSTR(GetString(IDS_AP_SLICEON));
		case PB_SLICEFROM: return TSTR(GetString(IDS_AP_SLICEFROM));
		case PB_SLICETO: return TSTR(GetString(IDS_AP_SLICETO));
		default:
			return TSTR(_T(""));
		}
	}

RefTargetHandle SphereObject::Clone(RemapDir& remap) 
	{
	SphereObject* newob = new SphereObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\star.cpp ===
/**********************************************************************
 *<
	FILE: star.cpp

	DESCRIPTION:  A Spline based star object

	CREATED BY: Christer Janson
	            Autodesk European Developer Support

	HISTORY: Created 22 October 1995
             Based on the file ngon.cpp by Tom Hudson
			 Fillets added 1/12/97 - Audrey Peterson

 *>	Copyright (c) 1995,1996,1997 All Rights Reserved.
 **********************************************************************/

#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
// This is based on the simple spline object...
#include "simpspl.h"

#define MIN_POINTS		3
#define MAX_POINTS		100

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)

#define MIN_DIST		float(-180)
#define MAX_DIST		float(180)

#define DEF_POINTS		6

#define DEF_RADIUS1		float(0.0)
#define DEF_RADIUS2		float(0.0)
#define DEF_DIST		float(0.0)
const float PI180=0.0174532f;
#define CIRCLE_VECTOR_LENGTH 0.5517861843f

class StarObjCreateCallBack;

class StarObject: public SimpleSpline, public IParamArray {			   
		friend class StarObjCreateCallBack;

	public:
		// Class vars
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgPoints;
		static float dlgDistortion;
		static Point3 crtPos;		
		static float crtRadius1;
		static float crtRadius2;
		static float crtFillet1;
		static float crtFillet2;

		void BuildShape(TimeValue t,BezierShape& ashape);

		StarObject();
		~StarObject();

		//  inherited virtual methods:

		IOResult StarObject::Load(ILoad *iload);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_STAR); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_STAR); }		
		Class_ID ClassID() { return Class_ID(STAR_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_STAR_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

//------------------------------------------------------

class StarObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new StarObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_STAR_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(STAR_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static StarObjClassDesc starObjDesc;

ClassDesc* GetStarDesc() { return &starObjDesc; }

// in ccj.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for star class.
IParamMap *StarObject::pmapParam  = NULL;
IParamMap *StarObject::pmapTypeIn = NULL;
IObjParam *StarObject::ip         = NULL;
int StarObject::dlgPoints         = DEF_POINTS;
float StarObject::dlgDistortion   = DEF_DIST;
Point3 StarObject::crtPos         = Point3(0,0,0);
float StarObject::crtRadius1      = 0.0f;
float StarObject::crtRadius2      = 0.0f;
float StarObject::crtFillet1      = 0.0f;
float StarObject::crtFillet2      = 0.0f;

void StarObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	StarObject::dlgPoints       = DEF_POINTS;
	StarObject::dlgDistortion   = DEF_DIST;
	StarObject::crtPos          = Point3(0,0,0);
	StarObject::crtRadius1      = 0.0f;
	StarObject::crtRadius2      = 0.0f;
	StarObject::crtFillet1      = 0.0f;
	StarObject::crtFillet2      = 0.0f;
	}

// Parameter map indices
#define PB_RADIUS1		0
#define PB_RADIUS2		1
#define PB_POINTS		2
#define PB_DISTORT		3
#define PB_FILLET1		4
#define PB_FILLET2		5

// Non-parameter block indices
#define PB_TI_POS			0
#define PB_TI_RADIUS1		1
#define PB_TI_RADIUS2		2
#define PB_TI_FILLET1		3
#define PB_TI_FILLET2		4

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),

	// Fillet1
	ParamUIDesc(
		PB_TI_FILLET1,
		EDITTYPE_UNIVERSE,
		IDC_AP_FILLET,IDC_AP_FILLETSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),

	// Fillet2
	ParamUIDesc(
		PB_TI_FILLET2,
		EDITTYPE_UNIVERSE,
		IDC_AP_FILLET2,IDC_AP_FILLETSPINNER2,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	};
#define TYPEINDESC_LENGTH 5

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius 1
	ParamUIDesc(
		PB_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RAD1SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Radius 2
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Points
	ParamUIDesc(
		PB_POINTS,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_POINTS,(float)MAX_POINTS,
		(float)1),
	
	// Distortion
	ParamUIDesc(
		PB_DISTORT,
		EDITTYPE_FLOAT,
		IDC_DISTORT,IDC_DISTORTSPINNER,
		MIN_DIST,MAX_DIST,
		SPIN_AUTOSCALE),

	// Fillet1
	ParamUIDesc(
		PB_FILLET1,
		EDITTYPE_UNIVERSE,
		IDC_AP_FILLET,IDC_AP_FILLETSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),

	// Fillet2
	ParamUIDesc(
		PB_FILLET2,
		EDITTYPE_UNIVERSE,
		IDC_AP_FILLET2,IDC_AP_FILLETSPINNER2,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	};
#define PARAMDESC_LENGTH 6


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },		
	{ TYPE_INT, NULL, TRUE, 2 },		
	{ TYPE_FLOAT, NULL, TRUE, 3 },
 };		
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },		
	{ TYPE_INT, NULL, TRUE, 2 },		
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },	  //Fillet1
	{ TYPE_FLOAT, NULL, TRUE, 5 },    //Fillet2
 };		
#define PBLOCK_LENGTH	6

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,4,0)			
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class StarPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		StarPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((StarObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer==0) {				
				((StarObject*)targ)->pblock->SetValue(PB_FILLET1,0,0.0f);
				((StarObject*)targ)->pblock->SetValue(PB_FILLET2,0,0.0f);
				}
			delete this;
			}
	};
IOResult StarObject::Load(ILoad *iload)
	{  	iload->RegisterPostLoadCallback(
			new StarPostLoadCallback(
				new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	return SimpleSpline::Load(iload);
	}


class StarTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		StarObject *so;

		StarTypeInDlgProc(StarObject *s) {so=s;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL StarTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (so->crtRadius1==0.0 && so->crtRadius2==0.0) return TRUE;
					
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (so->TestAFlag(A_OBJ_CREATING)) {
						so->pblock->SetValue(PB_RADIUS1,0,so->crtRadius1);
						so->pblock->SetValue(PB_RADIUS2,0,so->crtRadius2);
						so->pblock->SetValue(PB_FILLET1,0,so->crtFillet1);
						so->pblock->SetValue(PB_FILLET2,0,so->crtFillet2);
						}

					Matrix3 tm(1);
					tm.SetTrans(so->crtPos);
					so->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void StarObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {
		
		// Left over from last star ceated
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_STARPARAM2),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_STARPARAM1),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new StarTypeInDlgProc(this));
		}
	}
		
void StarObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_POINTS,ip->GetTime(),dlgPoints,FOREVER);
	pblock->GetValue(PB_DISTORT,ip->GetTime(),dlgDistortion,FOREVER);	
	}

void StarObject::BuildShape(TimeValue t, BezierShape& ashape) {

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float radius1, radius2, distortion,fillet1,fillet2;
	int points;
	pblock->GetValue(PB_RADIUS1, t, radius1, ivalid);
	pblock->GetValue(PB_RADIUS2, t, radius2, ivalid);
	pblock->GetValue(PB_POINTS, t, points, ivalid);
	pblock->GetValue(PB_DISTORT, t, distortion, ivalid);
	pblock->GetValue(PB_FILLET1, t, fillet1, ivalid);
	pblock->GetValue(PB_FILLET2, t, fillet2, ivalid);

	Point3 p;								// The actual point
	float angle;							// Angle of the current point

	LimitValue( radius1, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	LimitValue( distortion, MIN_DIST, MAX_DIST );
	LimitValue( points, MIN_POINTS, MAX_POINTS );
	LimitValue( fillet1, MIN_RADIUS, MAX_RADIUS );
	LimitValue( fillet2, MIN_RADIUS, MAX_RADIUS );

	// Delete the existing shape and create a new spline in it
	ashape.NewShape();

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	Spline3D *spline = ashape.NewSpline();

	float distort=PI180*distortion,PIpts=PI/(float)points;
	// Now add all the necessary points
	for(int ix=0; ix<(2*points); ++ix) 
	{ if (ix%2) 	// Points for radius 1
		{ 	angle = PI * (float)ix / (float)points;
			p.x = (float)cos(angle) * radius1;
			p.y = (float)sin(angle) * radius1;
			p.z = 0.0f;
			if (fillet1>0.0f)
			{ float theta1,theta2,stheta1,stheta2,ctheta1,ctheta2;
			  theta1=angle-PIpts;
			  theta2=angle+PIpts;
			  stheta1=(float)sin(theta1);stheta2=(float)sin(theta2);
			  ctheta1=(float)cos(theta1);ctheta2=(float)cos(theta2);
			  Point3 plast,pnext;
			  plast=Point3(radius2*ctheta1,radius2*stheta1,0.0f);
			  pnext=Point3(radius2*ctheta2,radius2*stheta2,0.0f);
			  Point3 n1=Normalize(plast-p)*fillet1,n2=Normalize(pnext-p)*fillet1;
			  Point3 nk1=n1*CIRCLE_VECTOR_LENGTH,nk2=n2*CIRCLE_VECTOR_LENGTH;
			  Point3 p1=p+n1,p2=p+n2;
			  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p1,p1+nk1,p1-nk1));
			  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p2,p2-nk2,p2+nk2));
			} else	spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p,p));
		}
		else  // Points for radius 2 with optional angular offset
		{	angle = PIpts * (float)ix + distort;
			p.x = (float)cos(angle) * radius2;
			p.y = (float)sin(angle) * radius2;
			p.z = 0.0f;
			if (fillet2>0.0f)
			{ float theta1,theta2,stheta1,stheta2,ctheta1,ctheta2;
			  theta1=angle-PIpts-distort;
			  theta2=angle+PIpts+distort;
			  stheta1=(float)sin(theta1);stheta2=(float)sin(theta2);
			  ctheta1=(float)cos(theta1);ctheta2=(float)cos(theta2);
			  Point3 plast,pnext;
			  plast=Point3(radius1*ctheta1,radius1*stheta1,0.0f);
			  pnext=Point3(radius1*ctheta2,radius1*stheta2,0.0f);
			  Point3 n1=Normalize(plast-p)*fillet2,n2=Normalize(pnext-p)*fillet2;
			  Point3 nk1=n1*CIRCLE_VECTOR_LENGTH,nk2=n2*CIRCLE_VECTOR_LENGTH;
			  Point3 p1=p+n1,p2=p+n2;
			  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p1,p1+nk1,p1-nk1));
			  spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p2,p2-nk2,p2+nk2));
			} else	spline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,p,p,p));
		}
	}
	spline->SetClosed();
	spline->ComputeBezPoints();
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

StarObject::StarObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	
	pblock->SetValue(PB_RADIUS1,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);
	pblock->SetValue(PB_FILLET1,0,crtFillet1);
	pblock->SetValue(PB_FILLET2,0,crtFillet2);
	pblock->SetValue(PB_POINTS,0,dlgPoints);
	pblock->SetValue(PB_DISTORT,0,dlgDistortion);
 	}

StarObject::~StarObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	UnReadyInterpParameterBlock();
	}

class StarObjCreateCallBack: public CreateMouseCallBack {
	StarObject *ob;
	Point3 p[2];
	IPoint2 cPt,sp1,sp2;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(StarObject *obj) { ob = obj; }
	};

int StarObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				cPt = m;
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform
				ob->pblock->SetValue(PB_RADIUS1,0,0.01f);
				ob->pblock->SetValue(PB_RADIUS2,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1: 
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				
				r = Length(p[1]-p[0]);
				
				ob->pblock->SetValue(PB_RADIUS1,0,r);
				ob->pblock->SetValue(PB_RADIUS2,0,r/2.0f);
				ob->pmapParam->Invalidate();

				// If Radius 1 is zero we abort creation
				if ((msg==MOUSE_POINT) && (Length(m-cPt)<3 || Length(p[1]-p[0])<0.1f)) {
					return CREATE_ABORT;
					}

				break;
			case 2: 
				sp1=m;
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				
				r = Length(p[1]-p[0]);
				
				ob->pblock->SetValue(PB_RADIUS2,0,r);
				ob->pmapParam->Invalidate();

				// Radius 2 can be 0, do not abort creation here
				  if (msg==MOUSE_POINT) 
				  {	ob->suspendSnap = FALSE;
					return CREATE_STOP;
				  }
				break;
/*			case 3: 
				{ sp2 = m;							   
				  float f = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
				  ob->pblock->SetValue(PB_FILLET1,0,f);
				  ob->pmapParam->Invalidate();
				}
				break;
			case 4: 
				{ float f = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp2,m));
				  ob->pblock->SetValue(PB_FILLET2,0,f);
				  ob->pmapParam->Invalidate();
				  if (msg==MOUSE_POINT) 
				  {	ob->suspendSnap = FALSE;
					return CREATE_STOP;
				  }
				}
				break;*/
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static StarObjCreateCallBack starCreateCB;

CreateMouseCallBack* StarObject::GetCreateMouseCallBack() {
	starCreateCB.SetObj(this);
	return(&starCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle StarObject::Clone(RemapDir& remap) {
	StarObject* newob = new StarObject();
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL StarObject::ValidForDisplay(TimeValue t) {
	float radius1, radius2;
	pblock->GetValue(PB_RADIUS1, t, radius1, ivalid);
	pblock->GetValue(PB_RADIUS2, t, radius2, ivalid);
	return (radius1 == 0.0f && radius2 == 0.0f) ? FALSE : TRUE;
	}

ParamDimension *StarObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
		case PB_RADIUS2:
		case PB_FILLET1:
		case PB_FILLET2:
			return stdWorldDim;			
		case PB_POINTS:
			return stdSegmentsDim;			
		default:
			return defaultDim;
		}
	}

TSTR StarObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS1:
			return TSTR(GetString(IDS_TH_RADIUS1));
		case PB_RADIUS2:
			return TSTR(GetString(IDS_TH_RADIUS2));
		case PB_FILLET1:
			return TSTR(GetString(IDS_AP_FILLET1));
		case PB_FILLET2:
			return TSTR(GetString(IDS_AP_FILLET2));
		case PB_POINTS:
			return TSTR(GetString(IDS_TH_STARPOINTS));
		case PB_DISTORT:
			return TSTR(GetString(IDS_TH_DISTORTION));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL StarObject::SetValue(int i, TimeValue t, int v) 
	{
	return TRUE;
	}

BOOL StarObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		case PB_TI_FILLET1: crtFillet1 = v; break;
		case PB_TI_FILLET2: crtFillet2 = v; break;
		}	
	return TRUE;
	}

BOOL StarObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL StarObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	return TRUE;
	}

BOOL StarObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		case PB_TI_FILLET1: v = crtFillet1; break;
		case PB_TI_FILLET2: v = crtFillet2; break;
		}
	return TRUE;
	}

BOOL StarObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\spline.cpp ===
/**********************************************************************
 *<
	FILE: spline.cpp

	DESCRIPTION:  A spline object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 23 February 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "splshape.h"
#include "linshape.h"
#include "iparamm.h"
#include "evrouter.h"
#include "simpspl.h"	// Here for loading old files

// Knot type indexes for creation and a handy lookup table

#define INDEX_CORNER 0
#define INDEX_SMOOTH 1
#define INDEX_BEZIER 2
static int KnotTypeTable[] = { KTYPE_CORNER, KTYPE_AUTO, KTYPE_BEZIER };

#define DEF_RENDERABLE FALSE
#define DEF_THICKNESS 1.0f
#define DEF_GENUVS FALSE

class SplineObject;

class SplineObjCreateCallBack: public CreateMouseCallBack {
	SplineObject *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		int override(int mode) { return CLICK_DOWN_POINT; }		// Override the mouse manager's mode!
		void SetObj(SplineObject *obj);
	};

class SplineObject: public SplineShape, public IParamArray {			   
	friend class SplineObjCreateCallBack;
	friend BOOL CALLBACK SplineParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend class SplineTypeInDlgProc;
	friend class BackspaceUser;

	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static Point3 crtPos;		
		static int crtInitialType;
		static int crtDragType;
		static Spline3D TIspline;	// Type-in construction spline
		static BOOL useTI;			// If TRUE, constructor copies TIspline into our work spline & resets this
		static int dlgSteps;
		static int dlgShapeSteps;
		static BOOL dlgOptimize;
		static float dlgThickness;
		static BOOL dlgGenUVs;
		static BOOL dlgRenderable;
#ifdef DESIGN_VER
        static int crtOrthoInitType;
        static int crtOrthoDragType;
#endif

		// Pointer to the create callback
		SplineObjCreateCallBack *ccb;

		// Flag set when initial creation is complete.
		BOOL createDone;

		// Special flag for loading old files -- Temporarily sets up refs
		BOOL loadingOldFile;

		// Old interpolation parameter block (used when loading old files)
		IParamBlock *nullpblock;	// Old one not used
		IParamBlock *ipblock;	// Interpolation parameter block

		// Flag to suspend snapping -- Used during creation
		BOOL suspendSnap;

		SplineObject();
		~SplineObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_TH_LINE); }
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_LINE); }		
		Class_ID ClassID() { return Class_ID(SPLINE3D_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_LINE_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		int RemapRefOnLoad(int iref);

		void DeleteThis();

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void AssignSpline(Spline3D *s);
		void FlushTypeInSpline() { TIspline.NewSpline(); useTI = FALSE; }
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		BOOL ValidForDisplay(TimeValue t);

		void CenterPivot(IObjParam *ip);

		// From SplineShape (Editable Spline)
		Object* ConvertToType(TimeValue t, Class_ID obtype);

		// From ISplineSelect, ISplineOps, etc.  These are pure virtual, but SplineShape implements them so bounce to it.  JBW 2/1/99
		void StartCommandMode(splineCommandMode mode) { SplineShape::StartCommandMode(mode); }
		void ButtonOp(splineButtonOp opcode) { SplineShape::ButtonOp(opcode); }
		DWORD GetSelLevel() { return SplineShape::GetSelLevel(); }
		void SetSelLevel(DWORD level) { SplineShape::SetSelLevel(level); }
		void LocalDataChanged() { SplineShape::LocalDataChanged(); }
		BitArray GetVertSel() { return SplineShape::GetVertSel(); }
		BitArray GetSegmentSel() { return SplineShape::GetSegmentSel(); }
		BitArray GetSplineSel() { return SplineShape::GetSplineSel(); }
		void SetVertSel(BitArray &set, ISplineSelect *imod, TimeValue t) { SplineShape::SetVertSel(set, imod, t); }
		void SetSegmentSel(BitArray &set, ISplineSelect *imod, TimeValue t) { SplineShape::SetSegmentSel(set, imod, t); }
		void SetSplineSel(BitArray &set, ISplineSelect *imod, TimeValue t) { SplineShape::SetSplineSel(set, imod, t); }
		GenericNamedSelSetList& GetNamedVertSelList() { return SplineShape::GetNamedVertSelList(); }
		GenericNamedSelSetList& GetNamedSegmentSelList() { return SplineShape::GetNamedSegmentSelList(); }
		GenericNamedSelSetList& GetNamedSplineSelList() { return SplineShape::GetNamedSplineSelList(); }

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};				

//------------------------------------------------------

class SplineObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SplineObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_LINE_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SPLINE3D_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static SplineObjClassDesc splineObjDesc;

ClassDesc* GetSplineDesc() { return &splineObjDesc; }

#ifdef DESIGN_VER
class OrthoSplineObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {
                        SplineObject *so = new SplineObject;
                        if (so != NULL)
                            so->shape.dispFlags |= DISP_SPLINES_ORTHOG;
                        return so;
                        }
    const TCHAR *	ClassName() { return GetString(IDS_PRS_ORTHOLINE_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(0x640f7dd1, 0x6b164fdc); }
	const TCHAR* 	Category() { return GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static OrthoSplineObjClassDesc orthoSplineObjDesc;

ClassDesc* GetOrthoSplineDesc() { return &orthoSplineObjDesc; }
#endif

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for spline class.
int SplineObject::dlgSteps     = DEF_STEPS;
int SplineObject::dlgShapeSteps = DEF_STEPS;
BOOL SplineObject::dlgOptimize = DEF_OPTIMIZE;
float SplineObject::dlgThickness = DEF_THICKNESS;
BOOL SplineObject::dlgGenUVs = DEF_GENUVS;
BOOL SplineObject::dlgRenderable = DEF_RENDERABLE;
IParamMap *SplineObject::pmapCreate = NULL;
IParamMap *SplineObject::pmapTypeIn = NULL;
IObjParam *SplineObject::ip         = NULL;
Point3 SplineObject::crtPos         = Point3(0,0,0);
int SplineObject::crtInitialType    = INDEX_CORNER;
#ifndef DESIGN_VER
int SplineObject::crtDragType       = INDEX_BEZIER;
#else
int SplineObject::crtDragType       = INDEX_CORNER;
#endif
#ifdef DESIGN_VER
int SplineObject::crtOrthoInitType  = INDEX_CORNER;
int SplineObject::crtOrthoDragType  = INDEX_CORNER;
#endif

// Type-in creation statics:
Spline3D SplineObject::TIspline;
BOOL SplineObject::useTI            = FALSE;

void SplineObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	SplineObject::crtPos         = Point3(0,0,0);
	SplineObject::crtInitialType = INDEX_CORNER;
#ifdef DESIGN_VER
	SplineObject::crtDragType    = INDEX_CORNER;
#else
	SplineObject::crtDragType    = INDEX_BEZIER;
#endif
	SplineObject::useTI          = FALSE;
	SplineObject::dlgSteps       = DEF_STEPS;
	SplineObject::dlgShapeSteps  = DEF_STEPS;
	SplineObject::dlgOptimize    = DEF_OPTIMIZE;
	SplineObject::dlgThickness   = DEF_THICKNESS;
	SplineObject::dlgGenUVs      = DEF_GENUVS;
	SplineObject::dlgRenderable  = DEF_RENDERABLE;
#ifdef DESIGN_VER
    SplineObject::crtOrthoInitType  = INDEX_CORNER;
    SplineObject::crtOrthoDragType  = INDEX_CORNER;
#endif
	}

#ifdef DESIGN_VER
void OrthoSplineObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	SplineObject::crtPos         = Point3(0,0,0);
	SplineObject::crtInitialType = INDEX_CORNER;
	SplineObject::crtDragType    = INDEX_CORNER;
	SplineObject::useTI          = FALSE;
	SplineObject::dlgSteps       = DEF_STEPS;
	SplineObject::dlgShapeSteps  = DEF_STEPS;
	SplineObject::dlgOptimize    = DEF_OPTIMIZE;
	SplineObject::dlgThickness   = DEF_THICKNESS;
	SplineObject::dlgGenUVs      = DEF_GENUVS;
	SplineObject::dlgRenderable  = DEF_RENDERABLE;
    SplineObject::crtOrthoInitType  = INDEX_CORNER;
    SplineObject::crtOrthoDragType  = INDEX_CORNER;
	}
#endif

// Parameter map indices
#define PB_DUMMY		0	// Not actually used!

// Non-parameter block indices
#define PB_INITIALTYPE		0
#define PB_DRAGTYPE			1
#define PB_TI_POS			2
// next two only for DESIGN_VER -- OrthoLine feature
#define PB_O_INITIALTYPE    3
#define PB_O_DRAGTYPE       4

//
//
// Creation Parameters

static int initialTypeIDs[] = {IDC_ICORNER,IDC_ISMOOTH};
static int dragTypeIDs[] = {IDC_DCORNER,IDC_DSMOOTH,IDC_DBEZIER};

static ParamUIDesc descCreate[] = {
	// Initial point type	
	ParamUIDesc(PB_INITIALTYPE,TYPE_RADIO,initialTypeIDs,2),
	// Dragged point type
	ParamUIDesc(PB_DRAGTYPE,TYPE_RADIO,dragTypeIDs,3)
	};
static ParamUIDesc descOrthoCreate[] = {
	// Initial point type	
	ParamUIDesc(PB_O_INITIALTYPE,TYPE_RADIO,initialTypeIDs,2),
	// Dragged point type
	ParamUIDesc(PB_O_DRAGTYPE,TYPE_RADIO,dragTypeIDs,3)
	};
#define CREATEDESC_LENGTH 2

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE)
	
	};
#define TYPEINDESC_LENGTH 1

//--- TypeInDlgProc --------------------------------

class SplineTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		SplineObject *ob;

		SplineTypeInDlgProc(SplineObject *n) {ob=n;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SplineTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	static Point3 previous;
	switch (msg) {
		case WM_DESTROY:
			ob->suspendSnap = FALSE;
			ob->FlushTypeInSpline();
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_ADDPOINT: {
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					ob->suspendSnap = TRUE;
					// If first point, start up the new object
					if(ob->TIspline.KnotCount() == 0) {
						Matrix3 tm(1);
						previous = ob->crtPos;
						SplineObject *newob = (SplineObject *)ob->ip->NonMouseCreate(tm);
						newob->TIspline.AddKnot(SplineKnot(KnotTypeTable[ob->crtInitialType],LTYPE_CURVE,ob->crtPos,ob->crtPos,ob->crtPos));
						// Stuff the spline into the shape
						while(newob->shape.SplineCount())
							newob->shape.DeleteSpline(0);
						Spline3D *spline = newob->shape.NewSpline();
						*spline = newob->TIspline;
						newob->shape.UpdateSels();	// Make sure it readies the selection set info
						newob->shape.InvalidateGeomCache();
						return TRUE;
						}					
					if(ob->TIspline.KnotCount() > 0 && ob->crtPos == previous) {
						ob->ip->DisplayTempPrompt(GetString(IDS_TH_ERRORTWOCONSECUTIVE));
						Beep(800, 100);
						return TRUE;
						}
					previous = ob->crtPos;
					ob->TIspline.AddKnot(SplineKnot(KnotTypeTable[ob->crtInitialType],LTYPE_CURVE,ob->crtPos,ob->crtPos,ob->crtPos));
					// Stuff the revised spline into the shape
					while(ob->shape.SplineCount())
						ob->shape.DeleteSpline(0);
					Spline3D *spline = ob->shape.NewSpline();
					*spline = ob->TIspline;
					ob->shape.UpdateSels();	// Make sure it readies the selection set info
					ob->shape.InvalidateGeomCache();
					ob->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
					return TRUE;
					}
				case IDC_TI_CLOSE:
					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					if(ob->TIspline.KnotCount() > 1) {
						ob->TIspline.SetClosed();

						common_finish:
						ob->suspendSnap = FALSE;
						ob->TIspline.ComputeBezPoints();
						ob->AssignSpline(&ob->TIspline);
						ob->CenterPivot(ob->ip);

						// Zero out the type-in spline
						ob->FlushTypeInSpline();
						return TRUE;
						}
					else {
						ob->ip->DisplayTempPrompt(GetString(IDS_TH_NEEDTWOSPLINEPOINTS));
						Beep(500, 100);
						}
					break;
				case IDC_TI_FINISH:
					if(ob->TIspline.KnotCount() > 1)
						goto common_finish;
					else {
						ob->ip->DisplayTempPrompt(GetString(IDS_TH_NEEDTWOSPLINEPOINTS));
						Beep(500, 100);
						}
					break;
				}
			break;	
		}
	return FALSE;
	}

void SplineObject::CenterPivot(IObjParam *ip) {
	// Find the center of the knot points
	Point3 composite(0,0,0);
	Spline3D *spline = shape.splines[0];
	int knots = spline->KnotCount();
	for(int i = 0; i < knots; ++i)
		composite += spline->GetKnotPoint(i);
	composite /= (float)knots;
	// Translate the entire spline to this new center
	Matrix3 xlate = TransMatrix(-composite);
	spline->Transform(&xlate);
	shape.InvalidateGeomCache();
	// Set the new matrix center
	Matrix3 tm(1);
	tm.SetTrans(composite);
	// Assign the revised transform
	ip->NonMouseCreateFinish(tm);
	}

void SplineObject::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SplineShape::BeginEditParams(ip,flags,prev);
	// This shouldn't be necessary, but the ip is getting hosed after the previous call!
	this->ip = ip;

	if (pmapCreate) {

        // Left over from last one created
        pmapCreate->SetParamBlock(this);
        pmapTypeIn->SetParamBlock(this);
    } else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
                (shape.dispFlags & DISP_SPLINES_ORTHOG) ?
                                                descOrthoCreate : descCreate,
                CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPLINEPARAM1),
				GetString(IDS_TH_CREATION_METHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPLINEPARAM2),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}
		}

    if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new SplineTypeInDlgProc(this));
		}
	}
		
void SplineObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	if(TIspline.KnotCount()) {
		if(TIspline.KnotCount() == 1) {
			Spline3D *spline = shape.splines[0];
			Point3 p = spline->GetKnotPoint(0);
			spline->AddKnot(SplineKnot(KnotTypeTable[crtInitialType],LTYPE_CURVE,p,p,p));
			shape.UpdateSels();	// Make sure it readies the selection set info
			shape.InvalidateGeomCache();
			}
		CenterPivot(ip);
		suspendSnap = FALSE;
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
		FlushTypeInSpline();		
		}

	SplineShape::EndEditParams(ip,flags,next);

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}
	// Save these values in class variables so the next object created will inherit them.
	dlgSteps = steps;
	dlgShapeSteps = shape.steps;
	dlgOptimize = shape.optimize;
	dlgThickness = GetThickness();
	dlgRenderable = GetRenderable();
	dlgGenUVs = GetGenUVs();
	}

SplineObject::SplineObject() : SplineShape() 
	{
	ccb = NULL;
	createDone = FALSE;
	loadingOldFile = FALSE;
	suspendSnap = FALSE;
	nullpblock = NULL;
	ipblock = NULL;
	if(useTI) {
		AssignSpline(&TIspline);
		FlushTypeInSpline();
		}
	steps = dlgSteps;
	shape.steps = dlgShapeSteps;
	shape.optimize = dlgOptimize;
	SetRenderable(dlgRenderable);
	SetThickness(dlgThickness);	// Not in param block -- In ShapeObject
	SetGenUVs(dlgGenUVs);
	}

SplineObject::~SplineObject()
	{
	if(ccb)
		ccb->SetObj(NULL);
	DeleteAllRefsFromMe();
	}

class BackspaceUser : public EventUser {
	SplineObject *ob;
	public:
		void Notify();
		void SetObj(SplineObject *obj) { ob = obj; }
	};

void BackspaceUser::Notify() {
	Spline3D *spline = ob->shape.GetSpline(0);
	if(spline->KnotCount() > 2) {
		// Tell the spline we just backspaced to remove the last point
		spline->Create(NULL, -1, 0, 0, IPoint2(0,0), NULL,ob->ip);
		ob->shape.InvalidateGeomCache();
		ob->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
		ob->ip->RedrawViews(ob->ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}

static BackspaceUser pBack;

void SplineObjCreateCallBack::SetObj(SplineObject *obj) {
	ob = obj;
	}

int SplineObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	// If the callback is being turned off, punt!
	if(msg == MOUSE_UNINIT)
		return TRUE;
	// If the object we're part of is gone, punt!
	if(!ob)
		return TRUE;

#ifdef _OSNAP
		if(msg == MOUSE_FREEMOVE)
		{
			vpt->SnapPreview(m,m,NULL,SNAP_IN_3D);
			return TRUE;
		}
#endif

	if(ob->createDone) {
		ob->suspendSnap = FALSE;
		return CREATE_STOP;
		}
	if(point == 0) {
		ob->suspendSnap = TRUE;
		pBack.SetObj(ob);
		backspaceRouter.Register(&pBack);
		ob->shape.NewShape();
#ifdef DESIGN_VER
        if (ob->shape.dispFlags & DISP_SPLINES_ORTHOG)
		    ob->shape.NewSpline(KnotTypeTable[ob->crtOrthoInitType],
                                KnotTypeTable[ob->crtOrthoDragType]);
        else
#endif
		    ob->shape.NewSpline(KnotTypeTable[ob->crtInitialType],
                                KnotTypeTable[ob->crtDragType]);
		ob->FlushTypeInSpline();	// Also get rid of the type-in spline, which we aren't using
		}
	Spline3D *theSpline = ob->shape.GetSpline(0);
	if(!theSpline) {
		assert(0);
		return FALSE;
		}
	int res = theSpline->Create(vpt,msg,point,flags,m,NULL,ob->ip);
	switch(res) {
		case CREATE_ABORT:
			ob->suspendSnap = FALSE;
			ob->createDone = TRUE;
			backspaceRouter.UnRegister(&pBack);
			return res;
		case CREATE_STOP:
			ob->suspendSnap = FALSE;
			ob->createDone = TRUE;
			if(theSpline->KnotCount() == 0) {
				backspaceRouter.UnRegister(&pBack);
				return CREATE_ABORT;
				}
			// Find the center of the knot points
			Point3 composite(0,0,0);
			for(int i = 0; i < theSpline->KnotCount(); ++i)
				composite += theSpline->GetKnotPoint(i);
			composite /= (float)theSpline->KnotCount();
			// Translate the entire spline to this new center
			Matrix3 xlate = TransMatrix(-composite);
			theSpline->Transform(&xlate);
			// Set the new matrix center
			mat.SetTrans(composite * mat);
			backspaceRouter.UnRegister(&pBack);
			break;
		}
	ob->shape.UpdateSels();	// Make sure it readies the selection set info
	ob->shape.InvalidateGeomCache();
	ob->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	return res;
	}

static SplineObjCreateCallBack splineCreateCB;

CreateMouseCallBack* SplineObject::GetCreateMouseCallBack() {
	splineCreateCB.SetObj(this);
	ccb = &splineCreateCB;
	return(&splineCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle SplineObject::Clone(RemapDir& remap) {
	SplineObject* newob = new SplineObject();
	newob->SplineShapeClone(this);
	return(newob);
	}

ParamDimension *SplineObject::GetParameterDim(int pbIndex) 
	{
//	switch (pbIndex) {
//		}
	return defaultDim;
	}

TSTR SplineObject::GetParameterName(int pbIndex) 
	{
//	switch (pbIndex) {
//		}
	return TSTR(_T(""));
	}

void SplineObject::AssignSpline(Spline3D *s) {
	shape.NewShape();
	*(shape.NewSpline()) = *s;
	shape.UpdateSels();
	shape.InvalidateGeomCache();
	}

// From ParamArray
BOOL SplineObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_INITIALTYPE: crtInitialType = v; break;
		case PB_DRAGTYPE: crtDragType = v; break;
#ifdef DESIGN_VER
		case PB_O_INITIALTYPE: crtOrthoInitType = v; break;
		case PB_O_DRAGTYPE: crtOrthoDragType = v; break;
#endif
		}		
	return TRUE;
	}

BOOL SplineObject::SetValue(int i, TimeValue t, float v)
	{
//	switch (i) {				
//		}	
	return TRUE;
	}

BOOL SplineObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL SplineObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_INITIALTYPE: v = crtInitialType; break;
		case PB_DRAGTYPE: v = crtDragType; break;
#ifdef DESIGN_VER
		case PB_O_INITIALTYPE: v = crtOrthoInitType; break;
		case PB_O_DRAGTYPE: v = crtOrthoDragType; break;
#endif
		}
	return TRUE;
	}

BOOL SplineObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
//	switch (i) {		
//		}
	return TRUE;
	}

BOOL SplineObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}

#define DISP_NODEFAULTCOLOR (1<<12)
#define COMP_NODEFAULTCOLOR (1<<10)

int SplineObject::Display(TimeValue t, INode *inode, ViewExp *vpt, int flags) {
	if(!ValidForDisplay(t))
		return 0;

	BOOL ticksSet = FALSE;
	if(!drawTicks && suspendSnap) {
		drawTicks = TRUE;
		ticksSet = TRUE;
		}

	SplineShape::Display(t, inode, vpt, flags);

	// Turn off the ticks if we set 'em
	if(ticksSet)
		drawTicks = FALSE;

	return(0);
	}

BOOL SplineObject::ValidForDisplay(TimeValue t) {
	if(shape.SplineCount() == 0)
		return FALSE;
	return (shape.GetSpline(0)->KnotCount() > 1) ? TRUE : FALSE;
	}

// We're based on the SplineShape object, but the conversion to an editable spline
// should turn us into a general SplineShape, not the Line object that we are.
// If asked to turn into a SplineShape, we'll do the conversion, otherwise, we'll
// let the SplineShape code do the work, which may mean just returning a pointer
// to ourself.
Object* SplineObject::ConvertToType(TimeValue t, Class_ID obtype) {
#ifdef OLDCODE // TH 6/24/99 Removed this, it was wreaking havoc in the pipeline
	if (obtype == splineShapeClassID) {
		SplineShape* newob = new SplineShape;
		// Gotta copy the ShapeObject parts
		newob->CopyBaseData(*this);
		theHold.Suspend();	// TH 4/9/99
		*newob = *this;
		theHold.Resume();	// TH 4/9/99
		newob->SetChannelValidity(TOPO_CHAN_NUM,ConvertValidity(t));
		newob->SetChannelValidity(GEOM_CHAN_NUM,ConvertValidity(t));
		return newob;
		}
#endif
	return SplineShape::ConvertToType(t, obtype);
	}

int SplineObject::NumRefs() {
	if(loadingOldFile)
		return 2;
	return SplineShape::NumRefs();
	}

RefTargetHandle SplineObject::GetReference(int i) {
//DebugPrint("GetReference(%d):",i);
	if(loadingOldFile) {
		if(i == 0) {
//DebugPrint("%p [nullpblock]\n",nullpblock);
			return nullpblock;
			}
//DebugPrint("%p [ipblock]\n",ipblock);
		return ipblock;
		}
//DebugPrint("%p [SS]\n",SplineShape::GetReference(i));
	return SplineShape::GetReference(i);
	}

void SplineObject::SetReference(int i, RefTargetHandle rtarg) {
//SClass_ID scid = rtarg->SuperClassID();
//Class_ID cid = rtarg->ClassID();
//DebugPrint("SetReference(%d, %p) SC:%X CID:%X:%X --",i, rtarg, scid, cid.PartA(), cid.PartB());
	if(loadingOldFile) {
		if(i == 0) {
//DebugPrint(" [nullpblock]\n");
			nullpblock = (IParamBlock*)rtarg;
			return;
			}
//DebugPrint(" [ipblock]\n");
		ipblock=(IParamBlock*)rtarg;
//int nparams = ipblock->NumParams();
//DebugPrint("pblock params:%d\n",nparams);
//for(int p = 0; p < nparams; ++p)
//  DebugPrint("Param %d type %d\n", p, ipblock->GetParameterType(p));
		return;					   
		}
//DebugPrint(" [SS]\n");
	SplineShape::SetReference(i, rtarg);
	}		

int SplineObject::RemapRefOnLoad(int iref) {
//DebugPrint("SO RemapRefOnLoad called (%d)",iref);
	if(loadingOldFile) {
//DebugPrint("Loading old, left as is\n");
		return iref;
		}
	return SplineShape::RemapRefOnLoad(iref);
	}

void SplineObject::DeleteThis() {
	if(ccb)
		ccb->SetObj(NULL);
	delete this;
	}

// IO
#define OLD_SPLINE_CHUNK 0x1000
#define NEW_SPLINE_CHUNK 0x2000

IOResult SplineObject::Save(ISave *isave) {
	isave->BeginChunk(NEW_SPLINE_CHUNK);
	SplineShape::Save(isave);
	isave->EndChunk();
	return IO_OK;
	}

class SplinePostLoadCallback : public PostLoadCallback {
	public:
		SplineObject *so;
		SplinePostLoadCallback(SplineObject *s) {so=s;}
		void proc(ILoad *iload) {
			int steps, optimize, adaptive;
			if(so->ipblock) {
				so->ipblock->GetValue(IPB_STEPS, 0, steps, FOREVER);
				so->ipblock->GetValue(IPB_OPTIMIZE, 0, optimize, FOREVER);
				so->ipblock->GetValue(IPB_ADAPTIVE, 0, adaptive, FOREVER);
				so->steps = so->shape.steps = steps;
				so->shape.optimize = optimize;
				if(adaptive)
					so->shape.steps = -1;
				}
			so->DeleteReference(0);
			so->DeleteReference(1);
			so->loadingOldFile = FALSE;
			delete this;
			}
	};

IOResult  SplineObject::Load(ILoad *iload) {
	IOResult res;
	loadingOldFile = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case OLD_SPLINE_CHUNK: {	// Pre-2.0 line object chunk
				loadingOldFile = TRUE;
				iload->RegisterPostLoadCallback(new SplinePostLoadCallback(this));
				shape.NewShape();
				Spline3D *s = shape.NewSpline();
				res = s->Load(iload);
				iload->SetObsolete();
				shape.UpdateSels();
				shape.InvalidateGeomCache();
				}
				break;
			case NEW_SPLINE_CHUNK:
				SplineShape::Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\tapehelp.h ===
/**********************************************************************
 *<
	FILE: tapehelp.h

	DESCRIPTION:  Defines a Measuring Tape Helper Class

	CREATED BY: Don Brittain

	HISTORY: created 8 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __TAPEHELP__H__ 

#define __TAPEHELP__H__

#include <float.h>
#define MIN_TAPE_LEN	0.0f
#define MAX_TAPE_LEN	999999.0f
// mjm - 1.19.99 - changed to address a complaint that the ui clamp on length values was too low.
// how high is high enough? -- any higher begin to risk float overflow in code areas such as scene rendering
//#define MAX_TAPE_LEN	99999.0f


class TapeHelpCreateCallBack;

class TapeHelpObject: public HelperObject 
{
	friend class TapeHelpObjCreateCallBack;
	friend BOOL CALLBACK TapeHelpParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend void resetTapeParams();
	
	// Class vars
	static Mesh mesh;
	static short meshBuilt;
	static HWND hTapeHelpParams;
	static IObjParam *iObjParams;
	static ISpinnerControl *lengthSpin;
	static float dlgLength;
	static short dlgSpecLen;

	// Object parameters		
	IParamBlock *pblock;
	short enable;
	short editting;
	short specLenState;
	float lastDist;
	Point3 dirPt;

	Interval ivalid;

	//  inherited virtual methods for Reference-management
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message );
	void BuildMesh();
	void UpdateUI(TimeValue t);
	void GetMat(TimeValue t, INode* inod, ViewExp *vpt, Matrix3& mat);
	void GetLinePoints(TimeValue t, Point3* q, float len);
	int DrawLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing );

public:
	TapeHelpObject();
	~TapeHelpObject();

	void SetLength( TimeValue t,float len );
	float GetLength( TimeValue t, Interval& valid = Interval(0,0) );
	void SetSpecLen(int onOff);
	int GetSpecLen(void)	{ return specLenState; }
	void Enable(int enab) { enable = enab; }

	//  inherited virtual methods:

	// From BaseObject
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack();
	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	TCHAR *GetObjectName() { return GetString(IDS_DB_TAPE); }

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s) { s = GetString(IDS_DB_TAPE); }
	Interval ObjectValidity();
	Interval ObjectValidity(TimeValue time);
	int DoOwnSelectHilite() { return 1; }

	// From GeomObject
	int IntersectRay(TimeValue t, Ray& r, float& at);
	void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

	// Animatable methods
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return Class_ID(TAPEHELP_CLASS_ID,0); }  
	void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_TAPEHELPER_CLASS)); }

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i) { return pblock; }
	TSTR SubAnimName(int i) { return TSTR(GetString(IDS_RB_PARAMETERS));}

	// From ref
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	int NumRefs() {return 1;}
	RefTargetHandle GetReference(int i) {return pblock;}
	void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
};				


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\tapehelp.cpp ===
/**********************************************************************
 *<
	FILE: tapehelp.cpp

	DESCRIPTION:  A measuring tape helper implementation

	CREATED BY: Don Brittain

	HISTORY: created 8 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "target.h"
#include "tapehelp.h"

// Parameter block indices
#define PB_LENGTH	0

//------------------------------------------------------

class TapeHelpClassDesc:public ClassDesc 
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TapeHelpObject; }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	const TCHAR *	ClassName() { return GetString(IDS_DB_TAPE_CLASS); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID 		ClassID() { return Class_ID(TAPEHELP_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetTapeParams(); }
};

static TapeHelpClassDesc tapeHelpDesc;

ClassDesc* GetTapeHelpDesc() { return &tapeHelpDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for measuring tape class.
Mesh TapeHelpObject::mesh;
short TapeHelpObject::meshBuilt=0;
HWND TapeHelpObject::hTapeHelpParams = NULL;
IObjParam *TapeHelpObject::iObjParams;
ISpinnerControl *TapeHelpObject::lengthSpin = NULL;
float TapeHelpObject::dlgLength = 100.0f;
short TapeHelpObject::dlgSpecLen = FALSE;

void resetTapeParams() 
{
	TapeHelpObject::dlgLength = 100.0f;
	TapeHelpObject::dlgSpecLen = FALSE;
}

BOOL CALLBACK TapeHelpParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	TapeHelpObject *th = (TapeHelpObject *)GetWindowLong( hDlg, GWL_USERDATA );	
	if ( !th && message != WM_INITDIALOG ) return FALSE;

	switch ( message ) {
		case WM_INITDIALOG:
			th = (TapeHelpObject *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)th );
			SetDlgFont( hDlg, th->iObjParams->GetAppHFont() );
			
			th->lengthSpin = GetISpinner(GetDlgItem(hDlg,IDC_LENSPINNER));
			th->lengthSpin->SetLimits( MIN_TAPE_LEN, MAX_TAPE_LEN, FALSE );
			th->lengthSpin->SetScale( 0.5f );
			if(th->specLenState)
				th->lengthSpin->SetValue( th->GetLength(th->iObjParams->GetTime()), FALSE );
			else
				th->lengthSpin->SetValue( th->lastDist, FALSE );
			th->lengthSpin->LinkToEdit( GetDlgItem(hDlg,IDC_LENGTH), EDITTYPE_UNIVERSE );
						
			CheckDlgButton( hDlg, IDC_SPEC_LEN, th->specLenState );
			EnableWindow(GetDlgItem(hDlg, IDC_LENGTH), th->specLenState);
			EnableWindow(GetDlgItem(hDlg, IDC_LENSPINNER), th->specLenState);

			return FALSE;			

		case WM_DESTROY:
			ReleaseISpinner( th->lengthSpin );
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;

		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();
			switch ( LOWORD(wParam) ) {
				case IDC_LENSPINNER:
					th->SetLength( th->iObjParams->GetTime(), th->lengthSpin->GetFVal() );
					th->lengthSpin->SetKeyBrackets(th->pblock->KeyFrameAtTime(PB_LENGTH,th->iObjParams->GetTime()));
					th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_INTERACTIVE);
					break;
				}
			return TRUE;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_END);
			return TRUE;

		case WM_MOUSEACTIVATE:
			th->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			th->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:			
			switch( LOWORD(wParam) ) {
				case IDC_SPEC_LEN:					
					th->SetSpecLen( IsDlgButtonChecked( hDlg, IDC_SPEC_LEN ) );
					EnableWindow(GetDlgItem(hDlg, IDC_LENGTH), th->specLenState);
					EnableWindow(GetDlgItem(hDlg, IDC_LENSPINNER), th->specLenState);					
					th->iObjParams->RedrawViews(th->iObjParams->GetTime());
					break;
				}
			return FALSE;

		default:
			return FALSE;
	}
}



void TapeHelpObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	iObjParams = ip;
	editting = TRUE;
	
	if ( !hTapeHelpParams ) {
		hTapeHelpParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_TAPEHELPER),
				TapeHelpParamDialogProc, 
				GetString(IDS_RB_PARAMETERS), 
				(LPARAM)this );	

		ip->RegisterDlgWnd(hTapeHelpParams);

	} 
	else {
		SetWindowLong( hTapeHelpParams, GWL_USERDATA, (LONG)this );
		
		// Init the dialog to our values.
		SetSpecLen( IsDlgButtonChecked(hTapeHelpParams,IDC_SPEC_LEN) );
		if(specLenState)
			lengthSpin->SetValue( GetLength(ip->GetTime()), FALSE );
		else 
			lengthSpin->SetValue( lastDist, FALSE );
	}
}
		
void TapeHelpObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
	editting = FALSE;

	if(specLenState)
		dlgLength = GetLength(ip->GetTime());
	dlgSpecLen = IsDlgButtonChecked(hTapeHelpParams, IDC_SPEC_LEN);

	if ( flags&END_EDIT_REMOVEUI ) {		
		ip->UnRegisterDlgWnd(hTapeHelpParams);
		ip->DeleteRollupPage(hTapeHelpParams);
		hTapeHelpParams = NULL;				
	} 
	else {
		SetWindowLong( hTapeHelpParams, GWL_USERDATA, 0 );
	}
	
	iObjParams = NULL;
}


void TapeHelpObject::BuildMesh()
{
	if(meshBuilt)
		return;
	int nverts = 5;
	int nfaces = 6;
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	float d =  5.0f;
	float h = 10.0f;

	mesh.setVert(0, Point3(  -d, -d, 0.0f ));
	mesh.setVert(1, Point3(   d, -d, 0.0f ));
	mesh.setVert(2, Point3(   d,  d, 0.0f ));
	mesh.setVert(3, Point3(  -d,  d, 0.0f ));
	mesh.setVert(4, Point3(0.0f,0.0f, -h  ));
	mesh.faces[0].setVerts(0, 3, 1);
	mesh.faces[0].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setVerts(3, 2, 1);
	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setVerts(0, 1, 4);
	mesh.faces[2].setEdgeVisFlags(1,1,1);
	mesh.faces[3].setVerts(1, 2, 4);
	mesh.faces[3].setEdgeVisFlags(1,1,1);
	mesh.faces[4].setVerts(2, 3, 4);
	mesh.faces[4].setEdgeVisFlags(1,1,1);
	mesh.faces[5].setVerts(3, 0, 4);
	mesh.faces[5].setEdgeVisFlags(1,1,1);
#if 0
	// whoops- rotate 180 about x to get it facing the right way
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.RotateX(DegToRad(180.0));
	for (int i=0; i<nverts; i++)
		mesh.getVert(i) = mat*mesh.getVert(i);
#endif
	mesh.buildNormals();
	mesh.EnableEdgeList(1);
	meshBuilt = 1;
}

#define RadToDegDbl	(180.0 / 3.141592653589793)

static void DisplayPlaneAngle(HWND hDlg, int id, Point3 &dirPt, Point3 &planePt)
{
	float len, cosAng;
	TCHAR buf[32];

	if(len = Length(planePt)) {
		cosAng = DotProd(planePt, dirPt) / len;
		if(cosAng > 0.99999f)	// beyond float accuracy!
			SetDlgItemText(hDlg, id, _T("0"));
		else {
			_stprintf(buf, "%g", acos((double)cosAng) * RadToDegDbl);
			SetDlgItemText(hDlg, id, buf);
		}
	}
	else
		SetDlgItemText(hDlg, id, _T("90"));
}

void TapeHelpObject::UpdateUI(TimeValue t)
{
	if ( hTapeHelpParams &&	GetWindowLong(hTapeHelpParams,GWL_USERDATA)==(LONG)this ) {
		if(specLenState) {
			lengthSpin->SetValue( GetLength(t), FALSE );
			lengthSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_LENGTH,t));
		}
		else 
			lengthSpin->SetValue( lastDist, FALSE );
	}
	float dirLen = Length(dirPt);
	if(dirLen) {
		TCHAR buf[32];
		
		_stprintf(buf, "%g", acos((double)dirPt.x) * RadToDegDbl);
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_X_AXIS, buf);
		_stprintf(buf, "%g", acos((double)dirPt.y) * RadToDegDbl);
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_Y_AXIS, buf);
		_stprintf(buf, "%g", acos((double)dirPt.z) * RadToDegDbl);
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_Z_AXIS, buf);

		Point3 planePt = dirPt;
		planePt.z = 0.0f;
		DisplayPlaneAngle(hTapeHelpParams, IDC_TAPE_XY_PLANE, dirPt, planePt);
		planePt = dirPt;
		planePt.x = 0.0f;
		DisplayPlaneAngle(hTapeHelpParams, IDC_TAPE_YZ_PLANE, dirPt, planePt);
		planePt = dirPt;
		planePt.y = 0.0f;
		DisplayPlaneAngle(hTapeHelpParams, IDC_TAPE_ZX_PLANE, dirPt, planePt);
	}
	else {
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_X_AXIS, _T(""));
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_Y_AXIS, _T(""));
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_Z_AXIS, _T(""));
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_XY_PLANE, _T(""));
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_YZ_PLANE, _T(""));
		SetDlgItemText(hTapeHelpParams, IDC_TAPE_ZX_PLANE, _T(""));
	}
}


TapeHelpObject::TapeHelpObject() : HelperObject() 
{
	ParamBlockDesc desc[] = {
		{ TYPE_FLOAT, NULL, TRUE } };

	// RB: Need to make a reference to the parameter block!
	MakeRefByID( FOREVER, 0, CreateParameterBlock( desc, 1 ));
	//pblock = CreateParameterBlock( desc, 1 );

	enable = 0;
	editting = 0;
	lastDist = 0.0f;
	SetLength( TimeValue(0), dlgLength );
	specLenState = dlgSpecLen;
	BuildMesh();
	dirPt.x = dirPt.y = dirPt.z = 0.0f;	
}

TapeHelpObject::~TapeHelpObject()
{
	DeleteAllRefsFromMe();
	pblock = NULL;
}


void TapeHelpObject::SetLength( TimeValue t, float len )
{
	pblock->SetValue( PB_LENGTH, t, len );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

float TapeHelpObject::GetLength( TimeValue t, Interval& valid )
{
	float f;
	pblock->GetValue( PB_LENGTH, t, f, valid );
	return f;
}

void TapeHelpObject::SetSpecLen( int onOff) 
{
	specLenState = onOff;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

class TapeHelpObjCreateCallBack: public CreateMouseCallBack 
{
	TapeHelpObject *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TapeHelpObject *obj) { ob = obj; }
	};

int TapeHelpObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{
	ob->enable = 1;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		#ifdef _3D_CREATE
			mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_3D) );
		#else
			mat.SetTrans( vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE) );
		#endif
		if (point==1 && msg==MOUSE_POINT) 
			return 0;
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
}

static TapeHelpObjCreateCallBack tapeHelpCreateCB;

CreateMouseCallBack* TapeHelpObject::GetCreateMouseCallBack() 
{
	tapeHelpCreateCB.SetObj(this);
	return(&tapeHelpCreateCB);
}

static int GetTargetPoint(TimeValue t, INode *inode, Point3& p) 
{
	Matrix3 tmat;
	if (inode->GetTargetTM(t,tmat)) {
		p = tmat.GetTrans();
		return 1;
	}
	return 0;
}

void TapeHelpObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm) 
{
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
}

void TapeHelpObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
{
	box = mesh.getBoundingBox(tm);
}

void TapeHelpObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) 
{
	Matrix3 m = inode->GetObjectTM(t);
	Point3 pt;
	Point3 q[4];
	float scaleFactor = vpt->GetVPWorldWidth(m.GetTrans())/(float)360.0;
	box = mesh.getBoundingBox();
	box.Scale(scaleFactor);

	float d;
	if (GetTargetPoint(t,inode,pt)){
		d = Length(m.GetTrans()-pt)/Length(inode->GetObjectTM(t).GetRow(2));
		box += Point3(float(0),float(0),-d);
	}
	if(GetSpecLen()) {
		GetLinePoints(t, q, GetLength(t) );
		box += q[0];
		box += q[1];
	}
}

void TapeHelpObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
	int i, nv;
	Matrix3 tm;
	float dtarg;
	Point3 pt;
	Point3 q[2];
	GetMat(t,inode,vpt,tm);
	nv = mesh.getNumVerts();
	box.Init();
	for (i=0; i<nv; i++) 
		box += tm*mesh.getVert(i);
	if (GetTargetPoint(t,inode,pt)) {
		tm = inode->GetObjectTM(t);
		dtarg = Length(tm.GetTrans()-pt)/Length(tm.GetRow(2));
		box += tm*Point3(float(0),float(0),-dtarg);
	}
	if(GetSpecLen()) {
		GetLinePoints(t, q, GetLength(t) );
		box += tm * q[0];
		box += tm * q[1];
	}
}

void TapeHelpObject::GetLinePoints(TimeValue t, Point3* q, float len) 
{
	q[0] = Point3( 0.0f, 0.0f, 0.0f);				
	q[1] = Point3( 0.0f, 0.0f, -len);				
}

// From BaseObject
int TapeHelpObject::DrawLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing ) 
{
	Matrix3 tm = inode->GetObjectTM(t);
	gw->setTransform(tm);
	Point3 pt,v[3];
	if (GetTargetPoint(t,inode,pt)) {
		float den = Length(tm.GetRow(2));
		float dist = (den!=0)?Length(tm.GetTrans()-pt)/den : 0.0f;
		if(!inode->IsFrozen() && drawing)
			gw->setColor( LINE_COLOR, GetUIColor(COLOR_TAPE_OBJ));
		if (drawing) {
			if(specLenState) {
				GetLinePoints(t, v, GetLength(t) );
				if(drawing == -1)
					v[1] = 0.9f * v[1];
			}
			else {
				v[0] = Point3(0,0,0);
				if(drawing == -1)	// hit-testing!  Shorten the line so target can be picked
					v[1] = Point3(0.0f, 0.0f, -0.9f * dist);
				else
					v[1] = Point3(0.0f, 0.0f, -dist);
			}
			gw->polyline( 2, v, NULL, NULL, FALSE, NULL );	
		}
	}
	return gw->checkHitCode();
}

int TapeHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) 
{
	HitRegion hitRegion;
	DWORD	savedLimits;
	int res;
	Matrix3 m;
	if (!enable) return  0;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	// if we get a hit on the mesh, we're done
	gw->clearHitCode();
	if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
		return TRUE;
	// if not, check the target line, and set the pair flag if it's hit
	// this special case only works with point selection
	if(type != HITTYPE_POINT)
		return 0;
	// don't let line be active if only looking at selected stuff and target isn't selected
	if((flags & HIT_SELONLY) && !inode->GetTarget()->Selected() )
		return 0;
	gw->clearHitCode();
	if(res = DrawLine(t,inode,gw,-1))
		inode->SetTargetNodePair(1);
	gw->setRndLimits(savedLimits);
	return res;
}

void TapeHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) 
{
	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();	
   	
		gw->setTransform(tm);

		Matrix3 invPlane = Inverse(snap->plane);

		Point2 fp = Point2((float)p->x, (float)p->y);
		IPoint3 screen3;
		Point2 screen2;

		// Get the two endpoints
		Point3 pt,v[2];
		if (GetTargetPoint(t,inode,pt)) {
			float den = Length(tm.GetRow(2));
			float dist = (den!=0)?Length(tm.GetTrans()-pt)/den : 0.0f;
			if(specLenState)
				GetLinePoints(t, v, GetLength(t) );
			else {
				v[0] = Point3(0,0,0);
				v[1] = Point3(0.0f, 0.0f, -dist);
			}

			for(int i = 0; i < 2; ++i) {
				Point3 thePoint = v[i];

				// If constrained to the plane, make sure this point is in it!
				if(snap->snapType == SNAP_2D || snap->flags & SNAP_IN_PLANE) {
					Point3 test = thePoint * tm * invPlane;
					if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
						return;
				}

				gw->wTransPoint(&thePoint,&screen3);
				screen2.x = (float)screen3.x;
				screen2.y = (float)screen3.y;
				// Are we within the snap radius?
				int len = (int)Length(screen2 - fp);
				if(len <= snap->strength) {
					// Is this priority better than the best so far?
					if(snap->vertPriority < snap->priority) {
						snap->priority = snap->vertPriority;
						snap->bestWorld = thePoint * tm;
						snap->bestScreen = screen2;
						snap->bestDist = len;
					}
					else if(len < snap->bestDist) {
						snap->priority = snap->vertPriority;
						snap->bestWorld = thePoint * tm;
						snap->bestScreen = screen2;
						snap->bestDist = len;
					}
				}
			}
		}
	}
}

int TapeHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = gw->getMaterial();

	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, GetUIColor(COLOR_TAPE_OBJ));
	mesh.render( gw, mtl, NULL, COMP_ALL);	
	DrawLine(t,inode,gw,1);
	gw->setRndLimits(rlim);
	if(editting && !specLenState) {
		Point3 pt;
		Matrix3 tm = inode->GetObjectTM(t);
		GetTargetPoint(t,inode,pt);
		float den = Length(tm.GetRow(2));
		float dist = (den!=0)?Length(tm.GetTrans()-pt)/den : 0.0f;
		lengthSpin->SetValue( lastDist = dist, FALSE );
	}
	if(editting) {
		float len;
		m.NoTrans();
		dirPt = m * Point3(0,0,1);
		if(len = Length(dirPt))
			dirPt *= 1.0f/len;
		UpdateUI(iObjParams->GetTime());
	}
	return(0);
}


// From GeomObject
int TapeHelpObject::IntersectRay(TimeValue t, Ray& r, float& at) { return(0); }

//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult TapeHelpObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			if (iObjParams) UpdateUI(iObjParams->GetTime());
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case 0:
					gpd->dim = stdWorldDim;
					break;				
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case 0:
					gpn->name = TSTR(GetString(IDS_DB_TAPE_LENGTH));
					break;												
			}
			return REF_STOP; 
		}
	}
	return(REF_SUCCEED);
}

ObjectState TapeHelpObject::Eval(TimeValue time){
	return ObjectState(this);
	}

Interval TapeHelpObject::ObjectValidity(TimeValue time) {
	Interval ivalid;
	ivalid.SetInfinite();
	GetLength(time, ivalid);
	UpdateUI(time);
	return ivalid;	
	}

RefTargetHandle TapeHelpObject::Clone(RemapDir& remap) 
{
	TapeHelpObject* newob = new TapeHelpObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->specLenState = specLenState;
	newob->ivalid.SetEmpty();
	newob->enable = enable;
	return(newob);
}


class TapeHelpCreationManager : public MouseCallBack, ReferenceMaker 
{
	private:
		CreateMouseCallBack *createCB;	
		INode *tapeNode,*targNode;
		TapeHelpObject *tapeObject;
		TargetObject *targObject;
		int attachedToNode;
		int lastPutCount;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		IPoint2 pt0;
		int ignoreSelectionChange;

		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)tapeNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { tapeNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		TapeHelpCreationManager()	{ ignoreSelectionChange = FALSE; }
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
};


#define CID_TAPEOBJCREATE	CID_USER + 5

class TapeHelpCreateMode : public CommandMode 
{
	TapeHelpCreationManager proc;
public:
	void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
	void End() { proc.End(); }

	int Class() { return CREATE_COMMAND; }
	int ID() { return CID_TAPEOBJCREATE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints = 1000000; return &proc; }
	ChangeForegroundCallback *ChangeFGProc() { return CHANGE_FG_SELECTED; }
	BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
	void EnterMode() { SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR))); }
	void ExitMode() { SetCursor(LoadCursor(NULL, IDC_ARROW)); }
	BOOL IsSticky() { return FALSE; }
};

static TapeHelpCreateMode theTapeHelpCreateMode;

//TapeHelpCreationManager::TapeHelpCreationManager( IObjCreate *ioc, ClassDesc *desc )
void TapeHelpCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB		= NULL;
	tapeNode		= NULL;
	targNode		= NULL;
	tapeObject		= NULL;
	targObject		= NULL;
	CreateNewObject();
}

//TapeHelpCreationManager::~TapeHelpCreationManager
void TapeHelpCreationManager::End()
{
	if ( tapeObject ) {
		tapeObject->ClearAFlag(A_OBJ_LONG_CREATE);

		tapeObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		
		if ( !attachedToNode ) {
			// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...			
			theHold.Suspend(); 
			delete tapeObject;
			tapeObject = NULL;
			theHold.Resume();
			// RB 7/28/97: If something has been put on the undo stack since this object was created, we have to flush the undo stack.
			if (theHold.GetGlobalPutCount()!=lastPutCount) {
				GetSystemSetting(SYSSET_CLEAR_UNDO);
				}
		} 
		else if ( tapeNode ) {
			 // Get rid of the reference.
			DeleteReference(0);  // sets tapeNode = NULL
		}
	}	
}

RefResult TapeHelpCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
			}
		 	if ( tapeObject && tapeNode==hTarget ) {
				// this will set tapeNode== NULL;
				DeleteReference(0);
				goto endEdit;
			}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if ( tapeObject && tapeNode==hTarget ) {
				endEdit:
				tapeObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				tapeObject  = NULL;				
				tapeNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
			}
			else if (targNode==hTarget) {
				targNode = NULL;
				targObject = NULL;
			}
			break;		
	}
	return REF_SUCCEED;
}


void TapeHelpCreationManager::CreateNewObject()
	{
	tapeObject = (TapeHelpObject*)cDesc->Create();
	lastPutCount = theHold.GetGlobalPutCount();

	// Start the edit params process
	if ( tapeObject ) {

		tapeObject->SetAFlag(A_OBJ_LONG_CREATE);
		tapeObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
		}	
	}

static BOOL needToss;
			
int TapeHelpCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
{	
	int res;
	TSTR targName;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					pt0 = m;
					assert( tapeObject );					
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					// if helpers were hidden by category, re-display them
					GetCOREInterface()->SetHideByCategoryFlags(
							GetCOREInterface()->GetHideByCategoryFlags() & ~HIDE_HELPERS);

					if ( attachedToNode ) {
				   		// send this one on its way
				   		tapeObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						
						// Get rid of the reference.
						if (tapeNode)
							DeleteReference(0);

						// new object
						CreateNewObject();   // creates tapeObject
						}

					needToss = theHold.GetGlobalPutCount()!=lastPutCount;

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					tapeNode = createInterface->CreateObjectNode( tapeObject);
					attachedToNode = TRUE;
					assert( tapeNode );					
					createCB = tapeObject->GetCreateMouseCallBack();					
					createInterface->SelectNode( tapeNode );
					
					// Create target object and node
					targObject = new TargetObject;
					targObject->SetAFlag(A_OBJ_LONG_CREATE);
					assert(targObject);
					targNode = createInterface->CreateObjectNode( targObject);
					assert(targNode);
					targName = tapeNode->GetName();
					targName += GetString(IDS_DB_DOT_TARGET);
					targNode->SetName(targName);

					// hook up camera to target using lookat controller.
					createInterface->BindToTarget(tapeNode,targNode);

					// Reference the new node so we'll get notifications.
					MakeRefByID( FOREVER, 0, tapeNode);

					// Position camera and target at first point then drag.
					mat.IdentityMatrix();
					//mat[3] = vpx->GetPointOnCP(m);
					#ifdef _3D_CREATE
						mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
					#else
						mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
					#endif
					createInterface->SetNodeTMRelConstPlane(tapeNode, mat);
					createInterface->SetNodeTMRelConstPlane(targNode, mat);
					tapeObject->Enable(1);

				   	ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( targNode,0);
				   	ignoreSelectionChange = FALSE;
					res = TRUE;
					break;
					
				case 1:
					if (Length(m-pt0)<2)
						goto abort;
					//mat[3] = vpx->GetPointOnCP(m);
					#ifdef _3D_CREATE
						mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
					#else
						mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
					#endif
					createInterface->SetNodeTMRelConstPlane(targNode, mat);
				   	ignoreSelectionChange = TRUE;
				   	createInterface->SelectNode( tapeNode);
				   	ignoreSelectionChange = FALSE;
					
					createInterface->RedrawViews(createInterface->GetTime());  

				    theHold.Accept(IDS_DS_CREATE);	 
					targObject->ClearAFlag(A_OBJ_LONG_CREATE);

					res = FALSE;	// We're done
					break;
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
			#ifdef _3D_CREATE
				mat.SetTrans( vpx->SnapPoint(m,m,NULL,SNAP_IN_3D) );
			#else
				mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
			#endif
			createInterface->SetNodeTMRelConstPlane(targNode, mat);
			createInterface->RedrawViews(createInterface->GetTime());	   
			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
			#ifdef _OSNAP
			//Snap Preview
				#ifdef _3D_CREATE
					vpx->SnapPreview(m,m,NULL, SNAP_IN_3D);
				#else
					vpx->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
				#endif
			#endif
			break;

	    case MOUSE_PROPCLICK:
			// right click while between creations
			createInterface->RemoveMode(NULL);
			break;
		
		case MOUSE_ABORT:
			abort:
			assert( tapeObject );
			tapeObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
			theHold.Cancel();	 // deletes both the camera and target.
			// Toss the undo stack if param changes have been made
			if (needToss) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
			tapeNode = NULL;			
			targNode = NULL;	 	
			createInterface->RedrawViews(createInterface->GetTime()); 
			CreateNewObject();	
			attachedToNode = FALSE;
			res = FALSE;						
		}
	
	done:
	createInterface->ReleaseViewport(vpx); 
	return res;
}

int TapeHelpClassDesc::BeginCreate(Interface *i)
{
	IObjCreate *iob = i->GetIObjCreate();
	
	//iob->SetMouseProc( new TapeHelpCreationManager(iob,this), 1000000 );

	theTapeHelpCreateMode.Begin( iob, this );
	iob->PushCommandMode( &theTapeHelpCreateMode );
	
	return TRUE;
}

int TapeHelpClassDesc::EndCreate(Interface *i)
{
	
	theTapeHelpCreateMode.End();
	i->RemoveMode( &theTapeHelpCreateMode );

	return TRUE;
}


#define TAPE_SPEC_LEN_CHUNK		0x2680

// IO
IOResult TapeHelpObject::Save(ISave *isave) 
{
	if (specLenState) {
		isave->BeginChunk(TAPE_SPEC_LEN_CHUNK);
		isave->EndChunk();
	}
	return IO_OK;
}

IOResult TapeHelpObject::Load(ILoad *iload) 
{
	IOResult res;
	enable = TRUE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case TAPE_SPEC_LEN_CHUNK:
				specLenState = 1;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\target.h ===
/**********************************************************************
 *<
	FILE: target.h

	DESCRIPTION:  Defines a Target Object Class

	CREATED BY: Dan Silva

	HISTORY: created 11 January 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __TARGET__H__ 

#define __TARGET__H__

class TargetObject: public GeomObject {			   
	friend class TargetObjectCreateCallBack;
	friend BOOL CALLBACK TargetParamDialogProc( HWND hDlg, UINT message, 
		WPARAM wParam, LPARAM lParam );
	
		// Mesh cache
		static HWND hSimpleCamParams;
		static IObjParam* iObjParams;		
		static Mesh mesh;		
		static int meshBuilt;

		void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
		void BuildMesh();

	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

	public:
		TargetObject();

		//  inherited virtual methods:

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_DB_TARGET); }

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_DB_TARGET); }
		ObjectHandle ApplyTransform(Matrix3& matrix);
		int UsesWireColor() { return 0; }
		int IsRenderable() { return 0; }

		// From GeomObject
		int IntersectRay(TimeValue t, Ray& r, float& at);
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

		// From Animatable 
		void DeleteThis() {
			 delete this; 
			 }
		Class_ID ClassID() { return Class_ID(TARGET_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_TARGET_CLASS)); }
		int IsKeyable(){ return 1;}
		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		// From ref.h
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\tea_util.h ===
#define DEGREE				3
#define DUCK_COUNT			306
#define PATCH_COUNT			32

#define FIRST_BODY_PATCH	0
#define FIRST_HANDLE_PATCH	16
#define FIRST_SPOUT_PATCH	20
#define FIRST_LID_PATCH		24

#define BODY_PATCHES		16
#define HANDLE_PATCHES		4
#define SPOUT_PATCHES		4
#define LID_PATCHES			8

typedef struct {
    float    x,y,z;
} Teapoint;

typedef enum {
    GenAll,
    ShareAll,
    ShareBegin,
    ShareBeginSingularityEnd,
    GenSingularityBegin
} EdgeType;

typedef struct {
    /* first the connectivity data */
    int patch0, edge0,  // which patch,
        patch1, edge1,  // which edge,
        patch2, edge2,  // does this patch use from another
        patch3, edge3;

    EdgeType    first, center, last; // how to build edges or center verts

	float bU, bV, eU, eV;
} TeaEdges;

typedef struct {
	int *left,
		*top,
		*right,
		*bottom;
} TeaShare;

extern Teapoint verts[];
extern int patches[PATCH_COUNT][4][4];
extern TeaEdges edges[PATCH_COUNT];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\teapatch.cpp ===
#include <stdlib.h>
#include "tea_util.h"

#pragma warning(disable: 4244)

/*
* The comments on patches number the quadrants looking down 
* with the spout at 12 o'clock
*/
int patches[32][4][4] = {
    {{0, 1, 2, 3},             /*  0:  top rim 12 -> 3 */
     {4, 5, 6, 7},
     {8, 9, 10, 11},
     {12, 13, 14, 15}},

    {{3, 16, 17, 18},          /*  1:  top rim 3 -> 6 */
     {7, 19, 20, 21},
     {11, 22, 23, 24},
     {15, 25, 26, 27}},

    {{18, 28, 29, 30},         /*  2:  top rim 6 -> 9 */
     {21, 31, 32, 33},
     {24, 34, 35, 36},
     {27, 37, 38, 39}},

    {{30, 40, 41, 0},          /*  3:  top rim 9 ->12 */
     {33, 42, 43, 4},
     {36, 44, 45, 8},
     {39, 46, 47, 12}},

    {{12, 13, 14, 15},         /*  4:  Top Body 12 -> 3 */
     {48, 49, 50, 51},
     {52, 53, 54, 55},
     {56, 57, 58, 59}},

    {{15, 25, 26, 27},         /*  5:  Top Body 3 -> 6 */
     {51, 60, 61, 62},
     {55, 63, 64, 65},
     {59, 66, 67, 68}},

    {{27, 37, 38, 39},         /*  6:  Top Body 6 -> 9 */
     {62, 69, 70, 71},
     {65, 72, 73, 74},
     {68, 75, 76, 77}},

    {{39, 46, 47, 12},         /*  7:  Top Body 9 -> 12 */
     {71, 78, 79, 48},
     {74, 80, 81, 52},
     {77, 82, 83, 56}},

    {{56, 57, 58, 59},         /*  8:  Bottom Body 12 -> 3 */
     {84, 85, 86, 87},
     {88, 89, 90, 91},
     {92, 93, 94, 95}},

    {{59, 66, 67, 68},         /*  9:  Bottom Body 3 -> 6 */
     {87, 96, 97, 98},
     {91, 99, 100, 101},
     {95, 102, 103, 104}},

    {{68, 75, 76, 77},         /* 10:  Bottom Body 6 -> 9 */
     {98, 105, 106, 107},
     {101, 108, 109, 110},
     {104, 111, 112, 113}},

    {{ 77,  82,  83, 56},      /* 11:  Bottom Body 9 -> 12 */
     {107, 114, 115, 84},
     {110, 116, 117, 88},
     {113, 118, 119, 92}},


    {{ 92,  93,  94,  95},     /* 12: Bottom 12 -> 3 */
     {274, 303, 302, 296},
     {278, 305, 304, 299},
     {269, 269, 269, 269}},

    {{95,  102, 103, 104},     /* 13: Bottom 3 -> 6 */
     {296, 295, 294, 287},
     {299, 298, 297, 290},
     {269, 269, 269, 269}},

    {{104, 111, 112, 113},     /* 14: Bottom 6 -> 9 */
     {287, 286, 285, 277},
     {290, 289, 288, 281},
     {269, 269, 269, 269}},

    {{113, 118, 119,  92},     /* 15: Bottom 9 -> 12 */
     {277, 276, 275, 274},
     {281, 280, 279, 278},
     {269, 269, 269, 269}},





    {{120, 121, 122, 123},     /* 16:  Top Handle RIGHT */
     {124, 125, 126, 127},
     {128, 129, 130, 131},
     {132, 133, 134, 135}},

    {{123, 136, 137, 120},     /* 17:  Top Handle LEFT */
     {127, 138, 139, 124},
     {131, 140, 141, 128},
     {135, 142, 143, 132}},

    {{132, 133, 134, 135},     /* 18:  Bottom Handle RIGHT */
     {144, 145, 146, 147},
     {148, 149, 150, 151},
     {68, 152, 153, 154}},

    {{135, 142, 143, 132},     /* 19:  Bottom Handle LEFT */
     {147, 155, 156, 144},
     {151, 157, 158, 148},
     {154, 159, 160, 68}},





    {{161, 162, 163, 164},     /* 20:  Spout Body RIGHT */
     {165, 166, 167, 168},
     {169, 170, 171, 172},
     {173, 174, 175, 176}},

    {{164, 177, 178, 161},     /* 21:  Spout Body LEFT */
     {168, 179, 180, 165},
     {172, 181, 182, 169},
     {176, 183, 184, 173}},

    {{173, 174, 175, 176},     /* 22:  Spout Tip RIGHT */
     {185, 186, 187, 188},
     {189, 190, 191, 192},
     {193, 194, 195, 196}},

    {{176, 183, 184, 173},     /* 23:  Spout Tip LEFT */
     {188, 197, 198, 185},
     {192, 199, 200, 189},
     {196, 201, 202, 193}},




    {{203, 203, 203, 203},     /* 24:  Lid Handle 12 -> 3 */
     {206, 207, 208, 209},
     {210, 210, 210, 210},
     {211, 212, 213, 214}},

    {{203, 203, 203, 203},     /* 25:  Lid Handle 3 -> 6 */
     {209, 216, 217, 218},
     {210, 210, 210, 210},
     {214, 219, 220, 221}},

    {{203, 203, 203, 203},     /* 26:  Lid Handle 6 -> 9 */
     {218, 223, 224, 225},
     {210, 210, 210, 210},
     {221, 226, 227, 228}},

    {{203, 203, 203, 203},     /* 27:  Lid Handle 9 -> 12 */
     {225, 229, 230, 206},
     {210, 210, 210, 210},
     {228, 231, 232, 211}},

    {{211, 212, 213, 214},     /* 28: Lid 12 -> 3 */
     {233, 234, 235, 236},
     {237, 238, 239, 240},
     {241, 242, 243, 244}},

    {{214, 219, 220, 221},     /* 29: Lid 3 -> 6 */
     {236, 245, 246, 247},
     {240, 248, 249, 250},
     {244, 251, 252, 253}},

    {{221, 226, 227, 228},     /* 30: Lid 6 -> 9 */
     {247, 254, 255, 256},
     {250, 257, 258, 259},
     {253, 260, 261, 262}},

    {{228, 231, 232, 211},     /* 31: Lid 9 -> 12 */
     {256, 263, 264, 233},
     {259, 265, 266, 237},
     {262, 267, 268, 241}}
};

TeaEdges
edges[PATCH_COUNT] = {
    {                           /*  0:  top rim 12 -> 3 */
        -1,     -1,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        GenAll, GenAll, GenAll,
		2.0f, 2.0f, 1.0f, 1.9f
    },
    {                           /*  1:  top rim 3 -> 6 */
        0,      2,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        ShareAll, GenAll, GenAll,
		1.0f, 2.0f, 0.0f, 1.9f
    },
    {                           /*  2:  top rim 6 -> 9 */
        1,      2,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        ShareAll, GenAll, GenAll,
		2.0f, 2.0f, 1.0f, 1.9f
    },
    {                           /*  3:  top rim 9 ->12 */
        2,      2,
        -1,     -1,
        0,      0,
        -1,     -1,
        ShareAll, GenAll, ShareAll,
		1.0f, 2.0f, 0.0f, 1.9f
    },

    {                           /*  4:  Top Body 12 -> 3 */
        0,      0,
        -1,     -1,
        -1,     -1,
        0,      1,
        ShareBegin, ShareBegin, ShareBegin,
		2.0f, 1.9f, 1.0f, 1.0f
    },
    {                           /*  5:  Top Body 3 -> 6 */
        4,      2,
        -1,     -1,
        -1,     -1,
        1,      1,
        ShareAll, ShareBegin, ShareBegin,
		1.0f, 1.9f, 0.0f, 1.0f
    },
    {                           /*  6:  Top Body 6 -> 9 */
        5,      2,
        -1,     -1,
        -1,     -1,
        2,      1,
        ShareAll, ShareBegin, ShareBegin,
		2.0f, 1.9f, 1.0f, 1.0f
    },
    {                           /*  7:  Top Body 9 -> 12 */
        6,      2,
        -1,     -1,
        4,      0,
        3,      1,
        ShareAll, ShareBegin, ShareAll,
		1.0f, 1.9f, 0.0f, 1.0f
    },

    {                           /*  8:  Bottom Body 12 -> 3 */
        4,      0,
        -1,     -1,
        -1,     -1,
        4,      1,
        ShareBegin, ShareBegin, ShareBegin,
		2.0f, 1.0f, 1.0f, 0.4f
    },
    {                           /*  9:  Bottom Body 3 -> 6 */
        8,      2,
        -1,     -1,
        -1,     -1,
        5,      1,
        ShareAll, ShareBegin, ShareBegin,
		1.0f, 1.0f, 0.0f, 0.4f
    },
    {                           /* 10:  Bottom Body 6 -> 9 */
        9,      2,
        -1,     -1,
        -1,     -1,
        6,      1,
        ShareAll, ShareBegin, ShareBegin,
		2.0f, 1.0f, 1.0f, 0.4f
    },
    {                           /* 11:  Bottom Body 9 -> 12 */
        10,     2,
        -1,     -1,
        8,      0,
        7,      1,
        ShareAll, ShareBegin, ShareAll,
		1.0f, 1.0f, 0.0f, 0.4f
    },

    {                           /* 12: Bottom 12 -> 3 */
        8,      0,
        -1,     -1,
        -1,     -1,
        8,      1,
        ShareBegin, ShareBeginSingularityEnd, ShareBeginSingularityEnd,
		2.0f, 0.4f, 1.0f, 0.0f
    },
    {                           /* 13: Bottom 3 -> 6 */
        12,     2,
        -1,     -1,
        -1,     -1,
        9,      1,
        ShareAll, ShareBeginSingularityEnd, ShareBeginSingularityEnd,
		1.0f, 0.4f, 0.0f, 0.0f
    },
    {                           /* 14: Bottom 6 -> 9 */
        13,     2,
        -1,     -1,
        -1,     -1,
        10,     1,
        ShareAll, ShareBeginSingularityEnd, ShareBeginSingularityEnd,
		2.0f, 0.4f, 1.0f, 0.0f
    },
    {                           /* 15: Bottom 9 -> 12 */
        14,     2,
        -1,     -1,
        12,     0,
        11,     1,
        ShareAll, ShareBeginSingularityEnd, ShareAll,
		1.0f, 0.4f, 0.0f, 0.0f
    },





    {                           /* 16:  Top Handle RIGHT */
        -1,     -1,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        GenAll, GenAll, GenAll,
		1.0f, 1.0f, 0.5f, 0.5f
    },
    {                           /* 17:  Top Handle LEFT */
        16,     2,
        -1,     -1,
        16,     0,
        -1,     -1,
        ShareAll, GenAll, ShareAll,
		0.5f, 1.0f, 0.0f, 0.5f
    },
    {                           /* 18:  Bottom Handle RIGHT */
        16,     0,
        -1,     -1,
        -1,     -1,
        16,     1,
        ShareBegin, ShareBegin, ShareBegin,
		1.0f, 0.5f, 0.5f, 0.0f
    },
    {                           /* 19:  Bottom Handle LEFT */
        18,     2,
        -1,     -1,
        18,     0,
        17,     1,
        ShareAll, ShareBegin, ShareAll,
		0.5f, 0.5f, 0.0f, 0.0f
	},




    {                           /* 20:  Spout Body RIGHT */
        -1, -1,
        -1, -1,
        -1, -1,
        -1, -1,
        GenAll, GenAll, GenAll,
		0.5f, 0.0f, 1.0f, 0.9f
    },
    {                           /* 21:  Spout Body LEFT */
        20,     2,
        -1,     -1,
        20,     0,
        -1,     -1,
        ShareAll, GenAll, ShareAll,
		0.0f, 0.0f, 0.5f, 0.9f
    },
    {                           /* 22:  Spout Tip RIGHT */
        20,     0,
        -1,     -1,
        -1,     -1,
        20,     1,
        ShareBegin, ShareBegin, ShareBegin,
		0.5f, 0.9f, 1.0f, 1.0f
    },
    {                           /* 23:  Spout Tip LEFT */
        22,     2,
        -1,     -1,
        22,     0,
        21,     1,
        ShareAll, ShareBegin, ShareAll,
  		0.0f, 0.9f, 0.5f, 1.0f
    },





        
    {                           /* 24:  Lid Handle 12 -> 3 */
        -1,     -1,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        GenAll, GenSingularityBegin, GenSingularityBegin,
		1.0f, 1.0f, 0.5f, 0.0f
    },
    {                           /* 25:  Lid Handle 3 -> 6 */
        24,     2,
        -1,     -1,
        -1,     -1,
        -1,     -1,
        ShareAll, GenSingularityBegin, GenSingularityBegin,
		0.5f, 1.0f, 0.0f, 0.0f
    },
    {                           /* 26:  Lid Handle 6 -> 9 */
        25,     2,
        -1,     -1,
        -1,     -1,
        -1, -1,
        ShareAll, GenSingularityBegin, GenSingularityBegin,
		1.0f, 1.0f, 0.5f, 0.0f
    },
    {                           /* 27:  Lid Handle 9 -> 12 */
        26,     2,
        -1,     -1,
        24,     0,
        -1,     -1,
        ShareAll, GenSingularityBegin, ShareAll,
		0.5f, 1.0f, 0.0f, 0.0f
    },

    {                           /* 28: Lid 12 -> 3 */
        24,     0,
        -1,     -1,
        -1,     -1,
        24,     1,
        ShareBegin, ShareBegin, ShareBegin,
		1.0f, 1.0f, 0.5f, 0.0f
    },
    {                           /* 29: Lid 3 -> 6 */                            
        28,     2,
        -1,     -1,
        -1,     -1,
        25,     1,
        ShareAll, ShareBegin, ShareBegin,
		0.5f, 1.0f, 0.0f, 0.0f
    },
    {                           /* 30: Lid 6 -> 9 */
        29,     2,
        -1,     -1,
        -1,     -1,
        26,     1,
        ShareAll, ShareBegin, ShareBegin,
		1.0f, 1.0f, 0.5f, 0.0f
    },
    {                           /* 31: Lid 9 -> 12 */
        30,     2,
        -1,     -1,
        28,     0,
        27,     1,
        ShareAll, ShareBegin, ShareAll,
		0.5f, 1.0f, 0.0f, 0.0f
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\target.cpp ===
/**********************************************************************
 *<
	FILE: target.cpp

	DESCRIPTION:  A Target object implementation

	CREATED BY: Dan Silva

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "prim.h"
#include "camera.h"
#include "target.h"

//------------------------------------------------------

class TargetObjectClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new TargetObject; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_TARGET); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID( TARGET_CLASS_ID, 0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES);  }
	};

static TargetObjectClassDesc targetObjDesc;

ClassDesc* GetTargetObjDesc() { return &targetObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IObjParam *TargetObject::iObjParams;
Mesh TargetObject::mesh;		
int TargetObject::meshBuilt=0;


BOOL CALLBACK TargetParamDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	return 0;
	}


void TargetObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)	{}
		
void TargetObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )	{}

class TargetObjectCreateCallBack: public CreateMouseCallBack {
	TargetObject *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TargetObject *obj) { ob = obj; }
	};

int TargetObjectCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 c;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				c = vpt->GetPointOnCP(m);
				mat.SetTrans(c);
				return CREATE_STOP;
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
	}

static TargetObjectCreateCallBack boxCreateCB;

CreateMouseCallBack* TargetObject::GetCreateMouseCallBack() {
	boxCreateCB.SetObj(this);
	return(&boxCreateCB);
	}


static void MakeQuad(Face *f, int a, int b , int c , int d, int sg) {
	f[0].setVerts( a, b, c);
	f[0].setSmGroup(sg);
	f[0].setEdgeVisFlags(1,1,0);
	f[1].setVerts( c, d, a);
	f[1].setSmGroup(sg);
	f[1].setEdgeVisFlags(1,1,0);
	}

#define sz float(4.0)
void TargetObject::BuildMesh()
	{
	int nverts = 8;
	int nfaces = 12;
	Point3 va(-sz,-sz,-sz);
	Point3 vb( sz, sz, sz);
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);

	mesh.setVert(0, Point3( va.x, va.y, va.z));
	mesh.setVert(1, Point3( vb.x, va.y, va.z));
	mesh.setVert(2, Point3( va.x, vb.y, va.z));
	mesh.setVert(3, Point3( vb.x, vb.y, va.z));
	mesh.setVert(4, Point3( va.x, va.y, vb.z));
	mesh.setVert(5, Point3( vb.x, va.y, vb.z));
	mesh.setVert(6, Point3( va.x, vb.y, vb.z));
	mesh.setVert(7, Point3( vb.x, vb.y, vb.z));

	MakeQuad(&(mesh.faces[ 0]), 0,2,3,1,  1);
	MakeQuad(&(mesh.faces[ 2]), 2,0,4,6,  2);
	MakeQuad(&(mesh.faces[ 4]), 3,2,6,7,  4);
	MakeQuad(&(mesh.faces[ 6]), 1,3,7,5,  8);
	MakeQuad(&(mesh.faces[ 8]), 0,1,5,4, 16);
	MakeQuad(&(mesh.faces[10]), 4,5,7,6, 32);
	mesh.buildNormals();
	mesh.EnableEdgeList(1);
	}

TargetObject::TargetObject() : GeomObject() {
	if (!meshBuilt) {
		BuildMesh();
		meshBuilt = 1;
		}
	}

void TargetObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm) {
	tm = inode->GetObjectTM(t);
	tm.NoScale();
	float scaleFactor = vpt->NonScalingObjectSize()*vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
	if (scaleFactor!=(float)1.0)
		tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
	}

void TargetObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	box = mesh.getBoundingBox(tm);
	}

void TargetObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ){
	Matrix3 m = inode->GetObjectTM(t);
	float scaleFactor = vpt->GetVPWorldWidth(m.GetTrans())/(float)360.0;
	box = mesh.getBoundingBox();
	box.Scale(scaleFactor);
	}

void TargetObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	int i,nv;
	Matrix3 m;
	GetMat(t,inode,vpt,m);
	nv = mesh.getNumVerts();
	box.Init();
	for (i=0; i<nv; i++) 
		box += m*mesh.getVert(i);
	}


// From BaseObject
int TargetObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	HitRegion hitRegion;
	DWORD savedLimits;
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	if(mesh.select( gw, gw->getMaterial(), &hitRegion, flags & HIT_ABORTONHIT ))
		return TRUE;
	gw->setRndLimits( savedLimits );
	return FALSE;

#if 0
	gw->setHitRegion(&hitRegion);
	gw->clearHitCode();
	gw->fWinMarker(&pt, HOLLOW_BOX_MRKR);
	return gw->checkHitCode();
#endif

	}

void TargetObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();	
		gw->setTransform(tm);

		Matrix3 invPlane = Inverse(snap->plane);

		Point2 fp = Point2((float)p->x, (float)p->y);
		IPoint3 screen3;
		Point2 screen2;

		Point3 thePoint(0,0,0);
		// If constrained to the plane, make sure this point is in it!
		if(snap->snapType == SNAP_2D || snap->flags & SNAP_IN_PLANE) {
			Point3 test = thePoint * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
			}
		gw->wTransPoint(&thePoint,&screen3);
		screen2.x = (float)screen3.x;
		screen2.y = (float)screen3.y;
		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			else
			if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			}
		}
	}

int TargetObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen() && inode->GetLookatNode()) {
		const ObjectState& os = inode->GetLookatNode()->EvalWorldState(t);
		Object* ob = os.obj;
		if ((ob!=NULL) && (ob->SuperClassID()==LIGHT_CLASS_ID))
			gw->setColor( LINE_COLOR, GetUIColor(COLOR_LIGHT_OBJ));
		else
			gw->setColor( LINE_COLOR, GetUIColor(COLOR_CAMERA_OBJ));
		}
	mesh.render( gw, gw->getMaterial(), NULL, COMP_ALL);	

//	gw->fWinMarker(&pt,HOLLOW_BOX_MRKR);
	return(0);
	}

// From Object
ObjectHandle TargetObject::ApplyTransform(Matrix3& matrix){
	return(ObjectHandle(this));
	}

// From GeomObject
int TargetObject::IntersectRay(TimeValue t, Ray& r, float& at) {
	return(0); 
	}

ObjectHandle TargetObject::CreateTriObjRep(TimeValue t) {
	return(NULL);
	}

//
// Reference Managment:
//


// This is only called if the object MAKES references to other things.
RefResult TargetObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	return(REF_SUCCEED);
	}

ObjectState TargetObject::Eval(TimeValue time) {
	return ObjectState(this);
	}

RefTargetHandle TargetObject::Clone(RemapDir& remap) {
	TargetObject* newob = new TargetObject();
	return(newob);
	}


// IO
IOResult TargetObject::Save(ISave *isave) {
	return IO_OK;
	}

IOResult  TargetObject::Load(ILoad *iload) {
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\teavert.cpp ===
#include "tea_util.h"

#pragma warning(disable: 4244)
#pragma warning(disable: 4305)

Teapoint verts[] = {
    {1.4,       0.0,        2.4},               /* 0 */
    {1.4,       -0.784,     2.4},
    {0.784,     -1.4,       2.4},
    {0.0,       -1.4,       2.4},
    {1.3375,    0.0,        2.53125},
    {1.3375,    -0.749,     2.53125},
    {0.749,     -1.3375,    2.53125},
    {0.0,       -1.3375,    2.53125},
    {1.4375,    0.0,        2.53125},
    {1.4375,    -0.805,     2.53125},
    {0.805,     -1.4375,    2.53125},           /* 10 */
    {0.0,       -1.4375,    2.53125},
    {1.5,       0.0,        2.4},
    {1.5,       -0.84,      2.4},
    {0.84,      -1.5,       2.4},
    {0.0,       -1.5,       2.4},
    {-0.874,    -1.4,       2.4},
    {-1.4,      -0.784,     2.4},
    {-1.4,      0.0,        2.4},
    {-0.749,    -1.3375,    2.53125},
    {-1.3375,   -0.749,     2.53125},           /* 20 */
    {-1.3375,   0.0,        2.53125},
    {-0.805,    -1.4375,    2.53125},
    {-1.4375,   -0.805,     2.53125},
    {-1.4375,   0.0,        2.53125},
    {-0.84,     -1.5,       2.4},
    {-1.5,      -0.84,      2.4},
    {-1.5,      0.0,        2.4},
    {-1.4,      0.784,      2.4},
    {-0.784,    1.4,        2.4},
    {0.0,       1.4,        2.4},               /* 30 */
    {-1.3375,   0.749,      2.53125},
    {-0.749,    1.3375,     2.53125},
    {0.0,       1.3375,     2.53125},
    {-1.4375,   0.805,      2.53125},
    {-0.805,    1.4375,     2.53125},
    {0.0,       1.4375,     2.53125},
    {-1.5,      0.84,       2.4},
    {-0.84,     1.5,        2.4},
    {0.0,       1.5,        2.4},
    {0.784,     1.4,        2.4},               /* 40 */
    {1.4,       0.784,      2.4},
    {0.749,     1.3375,     2.53125},
    {1.3375,    0.749,      2.53125},
    {0.805,     1.4375,     2.53125},
    {1.4375,    0.805,      2.53125},
    {0.84,      1.5,        2.4},
    {1.5,       0.84,       2.4},
    {1.75,      0.0,        1.875},
    {1.75,      -0.98,      1.875},
    {0.98,      -1.75,      1.875},             /* 50 */
    {0.0,       -1.75,      1.875},
    {2.0,       0.0,        1.35},
    {2.0,       -1.12,      1.35},
    {1.12,      -2.0,       1.35},
    {0.0,       -2.0,       1.35},
    {2.0,       0.0,        0.9},
    {2.0,       -1.12,      0.9},
    {1.12,      -2.0,       0.9},
    {0.0,       -2.0,       0.9},
    {-0.98,     -1.75,      1.875},             /* 60 */
    {-1.75,     -0.98,      1.875},
    {-1.75,     0.0,        1.875},
    {-1.12,     -2.0,       1.35},
    {-2.0,      -1.12,      1.35},
    {-2.0,      0.0,        1.35},
    {-1.12,     -2.0,       0.9},
    {-2.0,      -1.12,      0.9},
    {-2.0,      0.0,        0.9},
    {-1.75,     0.98,       1.875},
    {-0.98,     1.75,       1.875},             /* 70 */
    {0.0,       1.75,       1.875},
    {-2.0,      1.12,       1.35},
    {-1.12,     2.0,        1.35},
    {0.0,       2.0,        1.35},
    {-2.0,      1.12,       0.9},
    {-1.12,     2.0,        0.9},
    {0.0,       2.0,        0.9},
    {0.98,      1.75,       1.875},
    {1.75,      0.98,       1.875},
    {1.12,      2.0,        1.35},              /* 80 */
    {2.0,       1.12,       1.35},
    {1.12,      2.0,        0.9},
    {2.0,       1.12,       0.9},
    {2.0,       0.0,        0.45},
    {2.0,       -1.12,      0.45},
    {1.12,      -2.0,       0.45},
    {0.0,       -2.0,       0.45},
    {1.5,       0.0,        0.225},
    {1.5,       -0.84,      0.225},
    {0.84,      -1.5,       0.225},             /* 90 */
    {0.0,       -1.5,       0.225},
    {1.5,       0.0,        0.15},
    {1.5,       -0.84,      0.15},
    {0.84,      -1.5,       0.15},
    {0.0,       -1.5,       0.15},
    {-1.12,     -2.0,       0.45},
    {-2.0,      -1.12,      0.45},
    {-2.0,      0.0,        0.45},
    {-0.84,     -1.5,       0.225},
    {-1.5,      -0.84,      0.225},             /* 100 */
    {-1.5,      0.0,        0.225},
    {-0.84,     -1.5,       0.15},
    {-1.5,      -0.84,      0.15},
    {-1.5,      0.0,        0.15},
    {-2.0,      1.12,       0.45},
    {-1.12,     2.0,        0.45},
    {0.0,       2.0,        0.45},
    {-1.5,      0.84,       0.225},
    {-0.84,     1.5,        0.225},
    {0.0,       1.5,        0.225},             /* 110 */
    {-1.5,      0.84,       0.15},
    {-0.84,     1.5,        0.15},
    {0.0,       1.5,        0.15},
    {1.12,      2.0,        0.45},
    {2.0,       1.12,       0.45},
    {0.84,      1.5,        0.225},
    {1.5,       0.84,       0.225},
    {0.84,      1.5,        0.15},
    {1.5,       0.84,       0.15},
    {-1.6,      0.0,        2.025},             /* 120 */
    {-1.6,      -0.3,       2.025},
    {-1.5,      -0.3,       2.25},
    {-1.5,      0.0,        2.25},
    {-2.3,      0.0,        2.025},
    {-2.3,      -0.3,       2.025},
    {-2.5,      -0.3,       2.25},
    {-2.5,      0.0,        2.25},
    {-2.7,      0.0,        2.025},
    {-2.7,      -0.3,       2.025},
    {-3.0,      -0.3,       2.25},              /* 130 */
    {-3.0,      0.0,        2.25},
    {-2.7,      0.0,        1.8},
    {-2.7,      -0.3,       1.8},
    {-3.0,      -0.3,       1.8},
    {-3.0,      0.0,        1.8},
    {-1.5,      0.3,        2.25},
    {-1.6,      0.3,        2.025},
    {-2.5,      0.3,        2.25},
    {-2.3,      0.3,        2.025},
    {-3.0,      0.3,        2.25},              /* 140 */
    {-2.7,      0.3,        2.025},
    {-3.0,      0.3,        1.8},
    {-2.7,      0.3,        1.8},
    {-2.7,      0.0,        1.575},
    {-2.7,      -0.3,       1.575},
    {-3.0,      -0.3,       1.35},
    {-3.0,      0.0,        1.35},
    {-2.5,      0.0,        1.125},
    {-2.5,      -0.3,       1.125},
    {-2.65,     -0.3,       0.9375},            /* 150 */
    {-2.65,     0.0,        0.9375},
    {-2.0,      -0.3,       0.9},
    {-1.9,      -0.3,       0.6},
    {-1.9,      0.0,        0.6},
    {-3.0,      0.3,        1.35},
    {-2.7,      0.3,        1.575},
    {-2.65,     0.3,        0.9375},
    {-2.5,      0.3,        1.125},
    {-1.9,      0.3,        0.6},
    {-2.0,      0.3,        0.9},               /* 160 */
    {1.7,       0.0,        1.425},
    {1.7,       -0.66,      1.425},
    {1.7,       -0.66,      0.6},
    {1.7,       0.0,        0.6},
    {2.6,       0.0,        1.425},
    {2.6,       -0.66,      1.425},
    {3.1,       -0.66,      0.825},
    {3.1,       0.0,        0.825},
    {2.3,       0.0,        2.1},
    {2.3,       -0.25,      2.1},               /* 170 */
    {2.4,       -0.25,      2.025},
    {2.4,       0.0,        2.025},
    {2.7,       0.0,        2.4},
    {2.7,       -0.25,      2.4},
    {3.3,       -0.25,      2.4},
    {3.3,       0.0,        2.4},
    {1.7,       0.66,       0.6},
    {1.7,       0.66,       1.425},
    {3.1,       0.66,       0.825},
    {2.6,       0.66,       1.425},             /* 180 */
    {2.4,       0.25,       2.025},
    {2.3,       0.25,       2.1},
    {3.3,       0.25,       2.4},
    {2.7,       0.25,       2.4},
    {2.8,       0.0,        2.475},
    {2.8,       -0.25,      2.475},
    {3.525,     -0.25,      2.49375},
    {3.525,     0.0,        2.49375},
    {2.9,       0.0,        2.475},
    {2.9,       -0.15,      2.475},             /* 190 */
    {3.45,      -0.15,      2.5125},
    {3.45,      0.0,        2.5125},
    {2.8,       0.0,        2.4},
    {2.8,       -0.15,      2.4},
    {3.2,       -0.15,      2.4},
    {3.2,       0.0,        2.4},
    {3.525,     0.25,       2.49375},
    {2.8,       0.25,       2.475},
    {3.45,      0.15,       2.5125},
    {2.9,       0.15,       2.475},             /* 200 */
    {3.2,       0.15,       2.4},
    {2.8,       0.15,       2.4},
    {0.0,       0.0,        3.15},
    {0.0,       -0.002,     3.15},
    {0.002,     0.0,        3.15},
    {0.8,       0.0,        3.15},
    {0.8,       -0.45,      3.15},
    {0.45,      -0.8,       3.15},
    {0.0,       -0.8,       3.15},
    {0.0,       0.0,        2.85},              /* 210 */
    {0.2,       0.0,        2.7},
    {0.2,       -0.112,     2.7},
    {0.112,     -0.2,       2.7},
    {0.0,       -0.2,       2.7},
    {-0.002,    0.0,        3.15},
    {-0.45,     -0.8,       3.15},
    {-0.8,      -0.45,      3.15},
    {-0.8,      0.0,        3.15},
    {-0.112,    -0.2,       2.7},
    {-0.2,      -0.112,     2.7},               /* 220 */
    {-0.2,      0.0,        2.7},
    {0.0,       0.002,      3.15},
    {-0.8,      0.45,       3.15},
    {-0.45,     0.8,        3.15},
    {0.0,       0.8,        3.15},
    {-0.2,      0.112,      2.7},
    {-0.112,    0.2,        2.7},
    {0.0,       0.2,        2.7},
    {0.45,      0.8,        3.15},
    {0.8,       0.45,       3.15},              /* 230 */
    {0.112,     0.2,        2.7},
    {0.2,       0.112,      2.7},
    {0.4,       0.0,        2.55},
    {0.4,       -0.224,     2.55},
    {0.224,     -0.4,       2.55},
    {0.0,       -0.4,       2.55},
    {1.3,       0.0,        2.55},
    {1.3,       -0.728,     2.55},
    {0.728,     -1.3,       2.55},
    {0.0,       -1.3,       2.55},              /* 240 */
    {1.3,       0.0,        2.4},
    {1.3,       -0.728,     2.4},
    {0.728,     -1.3,       2.4},
    {0.0,       -1.3,       2.4},
    {-0.224,    -0.4,       2.55},
    {-0.4,      -0.224,     2.55},
    {-0.4,      0.0,        2.55},
    {-0.728,    -1.3,       2.55},
    {-1.3,      -0.728,     2.55},
    {-1.3,      0.0,        2.55},              /* 250 */
    {-0.728,    -1.3,       2.4},
    {-1.3,      -0.728,     2.4},
    {-1.3,      0.0,        2.4},
    {-0.4,      0.224,      2.55},
    {-0.224,    0.4,        2.55},
    {0.0,       0.4,        2.55},
    {-1.3,      0.728,      2.55},
    {-0.728,    1.3,        2.55},
    {0.0,       1.3,        2.55},
    {-1.3,      0.728,      2.4},               /* 260 */
    {-0.728,    1.3,        2.4},
    {0.0,       1.3,        2.4},
    {0.224,     0.4,        2.55},
    {0.4,       0.224,      2.55},
    {0.728,     1.3,        2.55},
    {1.3,       0.728,      2.55},
    {0.728,     1.3,        2.4},
    {1.3,       0.728,      2.4},
    {0.0,       0.0,        0.0},
    {1.5,       0.0,        0.15},              /* 270 */
    {1.5,       0.84,       0.15},
    {0.84,      1.5,        0.15},
    {0.0,       1.5,        0.15},
    {1.5,       0.0,        0.075},
    {1.5,       0.84,       0.075},
    {0.84,      1.5,        0.075},
    {0.0,       1.5,        0.075},
    {1.425,     0.0,        0.0},
    {1.425,     0.798,      0.0},
    {0.798,     1.425,      0.0},               /* 280 */
    {0.0,       1.425,      0.0},
    {-0.84,     1.5,        0.15},
    {-1.5,      0.84,       0.15},
    {-1.5,      0.0,        0.15},
    {-0.84,     1.5,        0.075},
    {-1.5,      0.84,       0.075},
    {-1.5,      0.0,        0.075},
    {-0.798,    1.425,      0.0},
    {-1.425,    0.798,      0.0},
    {-1.425,    0.0,        0.0},               /* 290 */
    {-1.5,      -0.84,      0.15},
    {-0.84,     -1.5,       0.15},
    {0.0,       -1.5,       0.15},
    {-1.5,      -0.84,      0.075},
    {-0.84,     -1.5,       0.075},
    {0.0,       -1.5,       0.075},
    {-1.425,    -0.798,     0.0},
    {-0.798,    -1.425,     0.0},
    {0.0,       -1.425,     0.0},
    {0.84,      -1.5,       0.15},              /* 300 */
    {1.5,       -0.84,      0.15},
    {0.84,      -1.5,       0.075},
    {1.5,       -0.84,      0.075},
    {0.798,     -1.425,     0.0},
    {1.425,     -0.798,     0.0}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\text.cpp ===
/**********************************************************************
 *<
	FILE: text.cpp

	DESCRIPTION:  A text spline object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 1 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "prim.h" 
#include "splshape.h"
#include "iparamm.h"
#include "bezfont.h"
// This is based on the simple spline object...
#include "simpspl.h"
#include "istdplug.h"

// Update this on every major MAX release
#define TEXT_VERSION_NUMBER 2

#define MIN_SIZE		float(0)
#define MAX_SIZE		float( 1.0E30)
#define MIN_KERNING		float(-1.0E30)
#define MAX_KERNING		float( 1.0E30)
#define MIN_LEADING		float(-1.0E30)
#define MAX_LEADING		float( 1.0E30)

#define DEF_SIZE		float(0.0)

#define swab(v) ((((v)&0xFF) << 8) + (((v) >> 8) &0xFF))

class TextObjCreateCallBack;

class CharShape {
	public:
		int index;
		BOOL keep;
		float width;
		BezierShape shape;
		CharShape() { index = -1; keep = FALSE; width = 0.0f; }
		CharShape(int i);
		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};

CharShape::CharShape(int i) {
	index=i;
	keep = TRUE;
	width = 0.0f;
	}

#define CS_INDEX_CHUNK		0x1000
#define CS_WIDTH_CHUNK		0x1010
#define CS_SHAPE_CHUNK		0x1020
#define CS_FONT_TRUETYPE	0x1030

IOResult CharShape::Save(ISave *isave) {
	ULONG nb;

	isave->BeginChunk(CS_INDEX_CHUNK);
	isave->Write(&index,sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(CS_WIDTH_CHUNK);
	isave->Write(&width,sizeof(float), &nb);
	isave->EndChunk();

	isave->BeginChunk(CS_SHAPE_CHUNK);
	shape.Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

IOResult CharShape::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CS_INDEX_CHUNK:
				res = iload->Read(&index,sizeof(int), &nb);
				break;
			case CS_WIDTH_CHUNK:
				res = iload->Read(&width,sizeof(float), &nb);
				break;
			case CS_SHAPE_CHUNK:
				res = shape.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

typedef Tab<CharShape *> CharShapeTab;

// TextObject flags
#define TEXTOBJ_BOLD		(1<<0)	// No longer used
//#define TEXTOBJ_ITALIC		(1<<1)
//#define TEXTOBJ_UNDERLINE		(1<<2)
// RB: 3/01/96 -- moved to istdplug.h

class TextObject: public SimpleSpline, public IParamArray, public ITextObject {
		friend class TextObjCreateCallBack;

	public:
		// We cache our hierarchy so that updates are quicker
		BOOL organized;
		ShapeHierarchy cachedHier;

		// This flag allows us to create text consistent with MAX 1.x versions
		BOOL textVersion;

		// Keep UI update from causing redraw
//		BOOL updatingUI;

		// Manual update?
		BOOL manualUpdate;
		BOOL doUpdate;

		DWORD textFlags;	// See above
		int textAlignment;
		BOOL baselineAligned;
		// Here is the font our text is using, along with a handle to the font (supplied by the
		// MAX Bezier Font Manager
		TSTR fontName;
		BEZFONTHANDLE fontHandle;
		DWORD fontFlags;
		BezFontInfo fontInfo;		// Only valid if fontHandle > 0
		// This is the user's string
		TSTR string;
		// This holds the bezier form of our text string in its normalized
		// size.  When called upon to BuildShape, we scale this according to the
		// size parameter and stuff it into the SimpleSpline's shape.
		BezierShape textShape;
		BOOL textShapeValid;
		// The specific parameters used for the cached shape
		float tsSize, tsKerning, tsLeading;
		// Cached character shapes
		CharShapeTab chShapes;
				
		// Class vars
		static TextObject *editObj;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		static float dlgSize;
		static float dlgKerning;
		static float dlgLeading;
		static TSTR dlgFont;
		static TSTR dlgString;
		static BOOL dlgItalic;
		static BOOL dlgUnderline;
		static BOOL dlgAlignment;

		void BuildShape(TimeValue t,BezierShape& ashape);

		TextObject();
		~TextObject();

		//  inherited virtual methods:

		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return ::GetString(IDS_TH_TEXT); }
		void InitNodeName(TSTR& s) { s = ::GetString(IDS_TH_TEXT); }		
		Class_ID ClassID() { return Class_ID(TEXT_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(::GetString(IDS_TH_TEXT_CLASS)); }
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		BOOL ValidForDisplay(TimeValue t);
		void UpdateShape(TimeValue t);
		Interval ObjectValidity(TimeValue t);
		void* GetInterface(ULONG id);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		void SetSize(TimeValue t, float s);
		float GetSize(TimeValue t, Interval& valid = Interval(0,0));
		void SetKerning(TimeValue t, float s);
		float GetKerning(TimeValue t, Interval& valid = Interval(0,0));
		void SetLeading(TimeValue t, float s);
		float GetLeading(TimeValue t, Interval& valid = Interval(0,0));

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }

		// Our very own methods!
		
		// This returns TRUE if it's OK to change the text string or font style
		BOOL CanChange();
		
		// This takes our string and uses the MAX Bezier Font system to build
		// the normalized-size shape object
		void ConstructTextShape(float size, float kerning, float leading);
		void InvalidateTextShape();

		// Change the font to the given name and style
		BOOL ChangeFont(TSTR name, DWORD flags);

		// RB: Changes the text to the given string
		BOOL ChangeText(TSTR string);

		// Enable/Disable text controls
		void MaybeDisableControls();				

		// Flush the cached characters
		void FlushCharCache();

		// Update the character shape cache and return the number of items cached
		int UpdateCharCache();

		// Override this because we're not as simple as the usual SimpleSpline
		ShapeHierarchy &OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL);

		// Functions for getting/setting styles
		BOOL GetItalic() { return (textFlags & TEXTOBJ_ITALIC) ? TRUE : FALSE; }
		BOOL GetUnderline() { return (textFlags & TEXTOBJ_UNDERLINE) ? TRUE : FALSE; }
		void SetItalic(BOOL sw);
		void SetUnderline(BOOL sw);

		// Functions for getting/setting alignment
		BOOL SetAlignment(int type);
		int GetAlignment() { return textAlignment; }

		// RB
		TSTR GetFont() {return fontName;}
		TSTR GetString() {return string;}

		void UpdateUI(BOOL needRedraw);

		// Convert text object's flags to equivalent font flags
		DWORD FontFlagsFromTextFlags();

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};				

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
TextObject *TextObject::editObj   = NULL;
IParamMap *TextObject::pmapParam  = NULL;
IObjParam *TextObject::ip         = NULL;
Point3 TextObject::crtPos         = Point3(0,0,0);
float TextObject::dlgSize         = 100.0f;
float TextObject::dlgKerning      = 0.0f;
float TextObject::dlgLeading      = 0.0f;
TSTR TextObject::dlgFont;
TSTR TextObject::dlgString;
BOOL TextObject::dlgItalic        = FALSE;
BOOL TextObject::dlgUnderline     = FALSE;
BOOL TextObject::dlgAlignment     = FALSE;

//------------------------------------------------------

class TextObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TextObject; }
	const TCHAR *	ClassName() { return ::GetString(IDS_TH_TEXT_CLASS); }
	SClass_ID		SuperClassID() { return SHAPE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TEXT_CLASS_ID,0); }
	const TCHAR* 	Category() { return ::GetString(IDS_TH_SPLINES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static TextObjClassDesc textObjDesc;

ClassDesc* GetTextDesc() {
	// Take advantage of this to load our initial strings
	static BOOL loaded = FALSE;
	if(!loaded) {
		loaded = TRUE;
		textObjDesc.ResetClassParams(FALSE);
		}
	return &textObjDesc;
	}

void TextObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	TextObject::crtPos         = Point3(0,0,0);
	TextObject::dlgSize        = 100.0f;
	TextObject::dlgKerning     = 0.0f;
	TextObject::dlgLeading     = 0.0f;
	TextObject::dlgFont        = TSTR(::GetString(IDS_TH_ARIAL));
#ifdef DESIGN_VER
	TextObject::dlgString      = TSTR(::GetString(IDS_TH_VIZ_TEXT));
#else
	TextObject::dlgString      = TSTR(::GetString(IDS_TH_MAX_TEXT));
#endif
	TextObject::dlgItalic      = FALSE;
	TextObject::dlgUnderline   = FALSE;
	TextObject::dlgAlignment   = TEXTOBJ_LEFT;
	}

// Parameter map indices
#define PB_SIZE		0
#define PB_KERNING	1
#define PB_LEADING	2

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_LENGTH		2
#define PB_TI_WIDTH			3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Size
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_UNIVERSE,
		IDC_TEXTSIZEEDIT,IDC_TEXTSIZESPINNER,
		MIN_SIZE,MAX_SIZE,
		SPIN_AUTOSCALE),	
	
	// Kerning
	ParamUIDesc(
		PB_KERNING,
		EDITTYPE_UNIVERSE,
		IDC_TEXTKERNINGEDIT,IDC_TEXTKERNINGSPINNER,
		MIN_KERNING,MAX_KERNING,
		SPIN_AUTOSCALE),
	
	// Leading
	ParamUIDesc(
		PB_LEADING,
		EDITTYPE_UNIVERSE,
		IDC_TEXTLEADINGEDIT,IDC_TEXTLEADINGSPINNER,
		MIN_LEADING,MAX_LEADING,
		SPIN_AUTOSCALE)
	};
#define PARAMDESC_LENGTH 3

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 } };		

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 } };		
#define PBLOCK_LENGTH	3

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,2,0),
	ParamVersionDesc(descVer1,1,1)
	};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	2
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);

static HIMAGELIST hTextButtons = NULL;

class DeleteTextButtonResources {
	public:
		~DeleteTextButtonResources() {
			ImageList_Destroy(hTextButtons);
			}
	};
static DeleteTextButtonResources	theTBDelete;

static void LoadTextButtonResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;

	hTextButtons = ImageList_Create(14, 15, TRUE, 10, 0);
	hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_TEXT_BUTTONS));
	hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_TEXT_MASKBUTTONS));
	ImageList_Add(hTextButtons,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	}

class ListBoxFiller : public BezFontEnumProc {
	public:
		HWND control;
		ListBoxFiller(HWND d, int c) { control=GetDlgItem(d, c); }
		BOOL CALLBACK Entry(BezFontInfo &info, LPARAM userInfo);
	};

BOOL CALLBACK ListBoxFiller::Entry(BezFontInfo &info, LPARAM userInfo) {
	if(!control)
		return FALSE;	// Can't use 'em anyway...
	SendMessage(control, CB_ADDSTRING, 0, (LPARAM)info.name.data());
	return TRUE;	// Keep on enumeratin'!	
	}

void TextObject::MaybeDisableControls() {
	if(pmapParam && editObj == this) {
		HWND hDlg = pmapParam->GetHWnd();
		EnableWindow(GetDlgItem(hDlg,IDC_TEXTENTRY),CanChange() ? TRUE : FALSE);
		ICustButton *but = GetICustButton(GetDlgItem(hDlg,IDC_TEXT_UPDATE));
		but->Enable((IsDlgButtonChecked(hDlg,IDC_TEXT_MANUAL_UPDATE)) ? TRUE : FALSE);
		ReleaseICustButton(but);
		}
	}

static void StuffFontName(HWND hDlg, TextObject *ob) {
	int thisFont = SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)ob->fontName.data());
	if(thisFont != CB_ERR) {
		SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_SETCURSEL, thisFont, 0);
		}
	else {
		SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_SETCURSEL, (WPARAM)-1, 0);
		SetDlgItemText(hDlg, IDC_TEXTFONT, (LPCTSTR)ob->fontName.data());
		}
	}

static void UpdateAlignment(HWND hDlg, TextObject *ob, int type = -1) {
	if(type >= 0)
		ob->SetAlignment(type);
	else
		type = ob->GetAlignment();
	ICustButton *but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTLEFT));
	but->SetCheck((type==TEXTOBJ_LEFT) ? TRUE : FALSE);
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTCENTER));
	but->SetCheck((type==TEXTOBJ_CENTER) ? TRUE : FALSE);
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTRIGHT));
	but->SetCheck((type==TEXTOBJ_RIGHT) ? TRUE : FALSE);
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTJUSTIFIED));
	but->SetCheck((type==TEXTOBJ_JUSTIFIED) ? TRUE : FALSE);
	ReleaseICustButton(but);
	}

// This dialog proc handles special fields within the rollup panel
class TextParamDialogProc : public ParamMapUserDlgProc {
	public:
		TextObject *text;
		TextParamDialogProc(TextObject *t) { text=t; }
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
		void Update(TimeValue t);
	};

BOOL TextParamDialogProc::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam) {
	ICustButton *but;
	
	switch ( msg ) {
		case WM_INITDIALOG: {
			LoadTextButtonResources();
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTITALIC));
			but->SetType(CBT_CHECK);
			but->SetCheck((text->textFlags & TEXTOBJ_ITALIC) ? TRUE : FALSE);
			but->SetImage( hTextButtons, 1,1,4,4, 14, 15);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTUNDERLINE));
			but->SetType(CBT_CHECK);
			but->SetCheck((text->textFlags & TEXTOBJ_UNDERLINE) ? TRUE : FALSE);
			but->SetImage( hTextButtons, 2,2,5,5, 14, 15);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTLEFT));
			but->SetType(CBT_CHECK);
			but->SetImage( hTextButtons, 6,6,6,6, 14, 15);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTCENTER));
			but->SetType(CBT_CHECK);
			but->SetImage( hTextButtons, 7,7,7,7, 14, 15);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTRIGHT));
			but->SetType(CBT_CHECK);
			but->SetImage( hTextButtons, 8,8,8,8, 14, 15);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTJUSTIFIED));
			but->SetType(CBT_CHECK);
			but->SetImage( hTextButtons, 9,9,9,9, 14, 15);
			ReleaseICustButton(but);
			UpdateAlignment(hWnd, text);

			CheckDlgButton( hWnd, IDC_TEXT_MANUAL_UPDATE, text->manualUpdate);

			// TH 6/1/99 -- Flush the font list
			SendMessage(GetDlgItem(hWnd,IDC_TEXTFONT), CB_RESETCONTENT, 0, (LPARAM)0);

			// Load up the listbox with the available fonts...
			// ... And the active font
			ListBoxFiller filler(hWnd, IDC_TEXTFONT);
			theBezFontManager.EnumerateFonts(filler, 0);

			// See if the current font is present in the list
			StuffFontName(hWnd, text);

			// Stuff the current text into the edit field
			SendMessage(GetDlgItem(hWnd,IDC_TEXTENTRY), WM_SETTEXT, 0, (LPARAM)text->string.data());
			
			// Disable the rest of the controls if can't change...
			text->MaybeDisableControls();
			}			
			return FALSE;	// DB 2/27

		case WM_DESTROY:
			return FALSE;

		case WM_COMMAND: {
			BOOL needRedraw = FALSE;			
			switch( LOWORD(wParam) ) {				
				case IDC_TEXTITALIC:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTITALIC));
							text->SetItalic(but->IsChecked());
							ReleaseICustButton(but);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTUNDERLINE:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							but = GetICustButton(GetDlgItem(hWnd,IDC_TEXTUNDERLINE));
							text->SetUnderline(but->IsChecked());
							ReleaseICustButton(but);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTLEFT:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							UpdateAlignment(hWnd, text, TEXTOBJ_LEFT);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTCENTER:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							UpdateAlignment(hWnd, text, TEXTOBJ_CENTER);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTRIGHT:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							UpdateAlignment(hWnd, text, TEXTOBJ_RIGHT);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTJUSTIFIED:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							UpdateAlignment(hWnd, text, TEXTOBJ_JUSTIFIED);
							needRedraw = TRUE;
							break;
						}
					break;
				case IDC_TEXTFONT: {
					switch(HIWORD(wParam)) {
						case CBN_SETFOCUS:
							DisableAccelerators();					
							break;
						case CBN_KILLFOCUS:
							EnableAccelerators();
							break;
						case CBN_SELCHANGE: {
							int selection = SendDlgItemMessage(hWnd, IDC_TEXTFONT, CB_GETCURSEL, 0, 0);
							if(selection != CB_ERR) {
								int fontNameLength = SendDlgItemMessage(hWnd, IDC_TEXTFONT, CB_GETLBTEXTLEN, selection, 0);
								TSTR work;
								work.Resize(fontNameLength+1);
								SendDlgItemMessage(hWnd, IDC_TEXTFONT, CB_GETLBTEXT, selection, (LPARAM)work.data());
								if(text->ChangeFont(work, text->FontFlagsFromTextFlags())) {
									text->textVersion = TEXT_VERSION_NUMBER;
									text->baselineAligned = TRUE;
									}
								// Stuff back in whatever font the object has now!
								SendDlgItemMessage(hWnd, IDC_TEXTFONT, WM_SETTEXT, 0, (LPARAM)text->fontName.data());
								text->MaybeDisableControls();
								text->ip->RedrawViews(text->ip->GetTime(),REDRAW_INTERACTIVE);
								}
							}
							break;
						}
					}
					break;
				case IDC_TEXTENTRY:
					switch(HIWORD(wParam)) {
						case EN_SETFOCUS:
							DisableAccelerators();					
							break;
						case EN_KILLFOCUS:
							EnableAccelerators();
							break;
						case EN_CHANGE: {
							int len = SendDlgItemMessage(hWnd, IDC_TEXTENTRY, WM_GETTEXTLENGTH, 0, 0);
							TSTR temp;
							temp.Resize(len+1);
							SendDlgItemMessage(hWnd, IDC_TEXTENTRY, WM_GETTEXT, len+1, (LPARAM)temp.data());
							text->string = temp;
//							if(!text->updatingUI)
								needRedraw = TRUE;
							}
							break;
						}
					break;
				case IDC_TEXT_MANUAL_UPDATE:
					text->manualUpdate = IsDlgButtonChecked(hWnd, IDC_TEXT_MANUAL_UPDATE);
					text->MaybeDisableControls();
					if(text->manualUpdate)
						needRedraw = TRUE;
					break;
				case IDC_TEXT_UPDATE:
					switch HIWORD(wParam) {
						case BN_CLICKED:
							text->doUpdate = TRUE;
							needRedraw = TRUE;
							break;
						}
					break;
				}
			if(needRedraw) {
				text->InvalidateTextShape();
				text->ip->RedrawViews(text->ip->GetTime(),REDRAW_INTERACTIVE);
				}
			return FALSE;
			}

		default:
			return FALSE;
		}
	}

void TextParamDialogProc::Update(TimeValue t) {
	DebugPrint("Updating dialog proc\n");
	}

// RB: 3-01-96
void* TextObject::GetInterface(ULONG id)
	{
	if (id==I_TEXTOBJECT) return (ITextObject*)this;
	else return Object::GetInterface(id); 
	}

void TextObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleSpline::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	editObj  = this;

	if (pmapParam) {
		// Left over from last one ceated
		pmapParam->SetParamBlock(pblock);

		// Init the dialog to our values.
		string = dlgString; 
//		UpdateUI(ip->GetTime());
	} else {
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_TEXTPARAM),
			::GetString(IDS_TH_PARAMETERS),
			0);
		}
	if(pmapParam)
		pmapParam->SetUserDlgProc(new TextParamDialogProc(this));
	
	// Open the font
	ChangeFont(fontName, FontFlagsFromTextFlags());

	// Maybe disable the text controls if the font isn't available
	MaybeDisableControls();
	}
		
void TextObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	HWND hDlg = pmapParam->GetHWnd();
	// Save these values in class variables so the next object created will inherit them.
	int selection = SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_GETCURSEL, 0, 0);
	if(selection != CB_ERR) {
		int fontNameLength = SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_GETLBTEXTLEN, selection, 0);
		dlgFont.Resize(fontNameLength+1);
		SendDlgItemMessage(hDlg, IDC_TEXTFONT, CB_GETLBTEXT, selection, (LPARAM)dlgFont.data());
		}
	pblock->GetValue(PB_SIZE,ip->GetTime(),dlgSize,FOREVER);
	pblock->GetValue(PB_KERNING,ip->GetTime(),dlgKerning,FOREVER);
	pblock->GetValue(PB_LEADING,ip->GetTime(),dlgLeading,FOREVER);
	int len = SendDlgItemMessage(hDlg, IDC_TEXTENTRY, WM_GETTEXTLENGTH, 0, 0);
	dlgString.Resize(len+1);
	SendDlgItemMessage(hDlg, IDC_TEXTENTRY, WM_GETTEXT, len+1, (LPARAM)dlgString.data());
	ICustButton *but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTITALIC));
	dlgItalic = but->IsChecked();
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTUNDERLINE));
	dlgUnderline = but->IsChecked();
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTLEFT));
	if(but->IsChecked())
		dlgAlignment = TEXTOBJ_LEFT;
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTCENTER));
	if(but->IsChecked())
		dlgAlignment = TEXTOBJ_CENTER;
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTRIGHT));
	if(but->IsChecked())
		dlgAlignment = TEXTOBJ_RIGHT;
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hDlg,IDC_TEXTJUSTIFIED));
	if(but->IsChecked())
		dlgAlignment = TEXTOBJ_JUSTIFIED;
	ReleaseICustButton(but);

	SimpleSpline::EndEditParams(ip,flags,next);
	this->ip = NULL;
	editObj  = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		}
	
	// Close the font we were using
	if(fontHandle) {
		theBezFontManager.CloseFont(fontHandle);
		fontHandle = 0;
		}
	}

void TextObject::BuildShape(TimeValue t, BezierShape& ashape) {
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float size, kerning, leading;
	pblock->GetValue(PB_SIZE, t, size, ivalid);
	LimitValue( size, MIN_SIZE, MAX_SIZE );
	pblock->GetValue(PB_KERNING, t, kerning, ivalid);
	pblock->GetValue(PB_LEADING, t, leading, ivalid);

	// Make sure our source shape is updated
	ConstructTextShape(size, kerning, leading);

	// Delete the existing shape and copy our text spline into it
	ashape.NewShape();

	ashape = textShape;

	// Get parameters from SimpleSpline and place them in the BezierShape
	int steps;
	BOOL optimize,adaptive;
	ipblock->GetValue(IPB_STEPS, t, steps, ivalid);
	ipblock->GetValue(IPB_OPTIMIZE, t, optimize, ivalid);
	ipblock->GetValue(IPB_ADAPTIVE, t, adaptive, ivalid);
	ashape.steps = adaptive ? -1 : steps;
	ashape.optimize = optimize;

	// Now add all the necessary points
	ashape.UpdateSels();	// Make sure it readies the selection set info
	ashape.InvalidateGeomCache();
	}

void TextObject::UpdateUI(BOOL needRedraw)
	{
	if(pmapParam && (editObj == this)) {
		HWND hTextParams = pmapParam->GetHWnd();
		if(hTextParams) {
			StuffFontName(hTextParams, this);
			TCHAR oldString[256];
			SendMessage(GetDlgItem(hTextParams,IDC_TEXTENTRY), WM_GETTEXT, 255, (LPARAM)oldString);
			TSTR os(oldString);
			if(!(os == string))
				SendMessage(GetDlgItem(hTextParams,IDC_TEXTENTRY), WM_SETTEXT, 0, (LPARAM)string.data());
			ICustButton *but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTITALIC));
			but->SetCheck((textFlags & TEXTOBJ_ITALIC) ? TRUE : FALSE);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTUNDERLINE));
			but->SetCheck((textFlags & TEXTOBJ_UNDERLINE) ? TRUE : FALSE);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTLEFT));
			but->SetCheck((textAlignment == TEXTOBJ_LEFT) ? TRUE : FALSE);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTCENTER));
			but->SetCheck((textAlignment == TEXTOBJ_CENTER) ? TRUE : FALSE);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTRIGHT));
			but->SetCheck((textAlignment == TEXTOBJ_RIGHT) ? TRUE : FALSE);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hTextParams,IDC_TEXTJUSTIFIED));
			but->SetCheck((textAlignment == TEXTOBJ_JUSTIFIED) ? TRUE : FALSE);
			ReleaseICustButton(but);
//			InvalidateUI();
			}
		else
			assert(0);
		}
	if(needRedraw) {
		InvalidateTextShape();
//		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}

TextObject::TextObject() : SimpleSpline() 
	{
	ReadyInterpParameterBlock();		// Build the interpolations parameter block in SimpleSpline
	MakeRefByID(FOREVER, USERPBLOCK, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	string = dlgString;
//DebugPrint("Created new TextObject @%p\n",this);
	fontName = dlgFont;
	fontFlags = 0;
	textFlags = (dlgItalic ? TEXTOBJ_ITALIC : 0) | (dlgUnderline ? TEXTOBJ_UNDERLINE : 0);
	fontHandle = 0;
	textShapeValid = FALSE;
	organized = FALSE;
	textAlignment = dlgAlignment;
	manualUpdate = FALSE;
	doUpdate = FALSE;
	textVersion = TEXT_VERSION_NUMBER;
	baselineAligned = TRUE;

	pblock->SetValue(PB_SIZE,0,dlgSize);
	pblock->SetValue(PB_KERNING,0,dlgKerning);
	pblock->SetValue(PB_LEADING,0,dlgLeading);
 	}

TextObject::~TextObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	if(fontHandle) {
		theBezFontManager.CloseFont(fontHandle);
		fontHandle = 0;
		}
	UnReadyInterpParameterBlock();
	}

class TextObjCreateCallBack: public CreateMouseCallBack {
	TextObject *ob;
	Point3 p0,p1;
	IPoint2 sp1;
	int createType;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TextObject *obj) { ob = obj; }
	};

int TextObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
			vpt->SnapPreview(m,m,NULL, snapdim);
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				break;
			case 1:
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}

	return TRUE;
	}

static TextObjCreateCallBack textCreateCB;

CreateMouseCallBack* TextObject::GetCreateMouseCallBack() {
	textCreateCB.SetObj(this);
	return(&textCreateCB);
	}

//
// Reference Managment:
//

RefTargetHandle TextObject::Clone(RemapDir& remap) {
	TextObject* newob = new TextObject();
	newob->textVersion = textVersion;
	newob->manualUpdate = manualUpdate;
	newob->doUpdate = doUpdate;
	newob->textFlags = textFlags;
	newob->textAlignment = textAlignment;
	newob->baselineAligned = baselineAligned;
	newob->fontName = fontName;
	newob->fontFlags = fontFlags;
	newob->string = string;
	for(int i = 0; i < chShapes.Count(); ++i) {
		CharShape *cs = new CharShape;
		*cs = *chShapes[i];
		newob->chShapes.Append(1, &cs);
		}
	newob->SimpleSplineClone(this);
	newob->ReplaceReference(USERPBLOCK,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}

BOOL TextObject::ValidForDisplay(TimeValue t) {
	float size;
	pblock->GetValue(PB_SIZE, t, size, ivalid);
	return (size == 0) ? FALSE : TRUE;
	}

void TextObject::UpdateShape(TimeValue t) {
	if ( ivalid.InInterval(t) )
		return;
	BuildShape(t, shape);
	}

Interval TextObject::ObjectValidity(TimeValue time) {
	UpdateShape(time);
//	UpdateUI(time);
	return ivalid;	
	}

ParamDimension *TextObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIZE:
		case PB_KERNING:
		case PB_LEADING:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR TextObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIZE:
			return TSTR(::GetString(IDS_TH_SIZE));
		case PB_KERNING:
			return TSTR(::GetString(IDS_TH_KERNING));
		case PB_LEADING:
			return TSTR(::GetString(IDS_TH_LEADING));
		default:
			return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL TextObject::SetValue(int i, TimeValue t, int v) 
	{
//	switch (i) {
//		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
//		}		
	return TRUE;
	}

BOOL TextObject::SetValue(int i, TimeValue t, float v)
	{
//	switch (i) {				
//		case PB_TI_LENGTH: crtLength = v; break;
//		case PB_TI_WIDTH: crtWidth = v; break;
//		}	
	return TRUE;
	}

BOOL TextObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
//	switch (i) {
//		case PB_TI_POS: crtPos = v; break;
//		}		
	return TRUE;
	}

BOOL TextObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
//	switch (i) {
//		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
//		}
	return TRUE;
	}

BOOL TextObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
//	switch (i) {		
//		case PB_TI_LENGTH: v = crtLength; break;
//		case PB_TI_WIDTH: v = crtWidth; break;
//		}
	return TRUE;
	}

BOOL TextObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
//	switch (i) {		
//		case PB_TI_POS: v = crtPos; break;		
//		}
	return TRUE;
	}

void TextObject::SetSize( TimeValue t, float s) 
	{
	pblock->SetValue( PB_SIZE, t, s );
	ShapeInvalid();
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float TextObject::GetSize( TimeValue t, Interval& valid )
	{
	float f;
	pblock->GetValue( PB_SIZE, t, f, valid );
	return f;
	}

void TextObject::SetKerning( TimeValue t, float s) 
	{
	pblock->SetValue( PB_KERNING, t, s );
	ShapeInvalid();
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float TextObject::GetKerning( TimeValue t, Interval& valid )
	{
	float f;
	pblock->GetValue( PB_KERNING, t, f, valid );
	return f;
	}

void TextObject::SetLeading( TimeValue t, float s) 
	{
	pblock->SetValue( PB_LEADING, t, s );
	ShapeInvalid();
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float TextObject::GetLeading( TimeValue t, Interval& valid )
	{
	float f;
	pblock->GetValue( PB_LEADING, t, f, valid );
	return f;
	}

BOOL TextObject::CanChange() {
	return (fontHandle > 0) ? TRUE : FALSE;
	}

class TextLine {
	public:
		BezierShape *shapes;
		int *chars;
		IntTab *chpoly;
		float *widths;
		float *yoffs;
		TextLine(int lines) {
			shapes = new BezierShape [lines];
			chpoly = new IntTab [lines];
			widths = new float [lines];
			yoffs = new float [lines];
			for(int l=0; l < lines; ++l) {
				widths[l] = 0.0f;
				yoffs[l] = 0.0f;
				}
			}
		~TextLine() {
			delete [] shapes;
			delete [] chpoly;
			delete [] widths;
			delete [] yoffs;
			}
		void Underline(int line, float xoffset, float yoffset, float scaleFactor);
	};

void TextLine::Underline(int line, float xoffset, float yoffset, float scaleFactor) {
	Spline3D *spline = shapes[line].NewSpline();

	// Now add all the necessary points
	// We'll add 'em as auto corners initially, have the spline package compute some vectors (because
	// I'm basically lazy and it does a great job, besides) then turn 'em into bezier corners!
	float x1 = 0.0f;
	float y1 = -50.0f * scaleFactor + yoffset;		// Drop it below the baseline a bit
	float x2 = xoffset;
	float y2 = -100.0f * scaleFactor + yoffset;
	Point3 p = Point3(x1, y1, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(x1, y2, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(x2, y2, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	p = Point3(x2, y1, 0.0f);
	spline->AddKnot(SplineKnot(KTYPE_CORNER,LTYPE_CURVE,p,p,p));
	spline->SetClosed();
	spline->ComputeBezPoints();
	for(int i = 0; i < 4; ++i)
		spline->SetKnotType(i, KTYPE_BEZIER_CORNER);
	shapes[line].UpdateSels();
	}

void TextObject::ConstructTextShape(float size, float kerning, float leading) {
	int i;
	if(!doUpdate && manualUpdate && pmapParam && pmapParam->GetParamBlock() == pblock)
		return;
	doUpdate = FALSE;
	if(textShapeValid && size==tsSize && kerning==tsKerning && leading==tsLeading)
		return;
//DebugPrint("Constructing textShape, font:[%s]\n",fontName.data());

	// Remember the parameters used for this cached shape
	tsSize = size;
	tsKerning = kerning;
	tsLeading = leading;

	// Get the scaling factor
	float scaleFactor = size / 1000.0f;

	textShape.NewShape();

	// Now update our cached shapes if we have a valid font
	// This only occurs when the UI is up (i.e. in create/modify branch).
	// The rest of the time we rely on the cached characters
	if(fontHandle)
		UpdateCharCache();

	int cacheCount = chShapes.Count();

	int chars = string.Length();
//DebugPrint("String: [%s] %d chars\n",string.data(), chars);
	float xoffset = 0.0f, yoffset = 0.0f;
	// Find out how many lines we have and how many characters in each line
	int lines = 1;
	for(i = 0; i < chars; ++i) {
		UINT index;
		if (isleadbyte(string[i])) {
			union {
				unsigned char b[2];
				unsigned short c;
			} dbcs;
			dbcs.b[0] = string[i];
			dbcs.b[1] = string[++i];
			index = swab(dbcs.c);
		} else {
			index = (UCHAR)string[i];
		}

		if(index == 13)
			lines++;
		}
	// Now load the lines into the work shapes, recording the width of each line's
	// characters and the widest line
	TextLine tLines(lines);
	float widest = -100.0f;
	int line = 0, widestLine;
	for(i = 0; i < chars; ++i) {
		UINT index;
		if (isleadbyte(string[i])) {
			union {
				unsigned char b[2];
				unsigned short c;
			} dbcs;
			dbcs.b[0] = string[i];
			dbcs.b[1] = string[++i];
			index = swab(dbcs.c);
		} else {
			index = (UCHAR)string[i];
		}

		if(index == 13) {
			tLines.widths[line] = xoffset;
			tLines.yoffs[line] = yoffset;
			if(xoffset > widest) {
				widest = xoffset;
				widestLine = line;
				}
			line++;
			xoffset = 0.0f;
			yoffset -= (size + leading);
			continue;
			}
		if(index == 10)
			continue;
		for(int j = 0; j < cacheCount; ++j) {
			if((UINT)chShapes[j]->index == index) {
				// Build a transform to move the shape into position and scale it
				Matrix3 tm(1);
				// Add a shear transform if it's italic!
				if(textFlags & TEXTOBJ_ITALIC) {
					Point3 r2 = tm.GetRow(1);
					r2.x = 0.3f;
					tm.SetRow(1, r2);
					}
				tm *= ScaleMatrix(Point3(scaleFactor, scaleFactor, 1.0f));
				tm *= TransMatrix(Point3(xoffset, yoffset, 0.0f));
				BezierShape shape = chShapes[j]->shape;
				shape.Transform(tm);
				tLines.shapes[line] += shape;
				int chix = tLines.shapes[line].SplineCount();
				tLines.chpoly[line].Append(1, &chix);
				xoffset += chShapes[j]->width * scaleFactor + kerning;
				break;
				}
			}
		}
	// Update width if leftover
	if(xoffset) {
		tLines.widths[line] = xoffset;
		tLines.yoffs[line] = yoffset;
		if(xoffset > widest) {
			widest = xoffset;
			widestLine = line;
			}
		}
	// Do justification if needed
	if(textAlignment == TEXTOBJ_JUSTIFIED) {
		for(line = 0; line < lines; ++line) {
			if(line != widestLine) {
				int chars = tLines.chpoly[line].Count();
				if(chars > 1) {
					int spaces = chars - 1;
					float increment = (widest - tLines.widths[line]) / (float)spaces;
					float offset = increment;
					for(int space = 0; space < spaces; ++space,offset+=increment) {
						Matrix3 tm=TransMatrix(Point3(offset, 0.0f, 0.0f));
						for(int i = tLines.chpoly[line][space]; i < tLines.chpoly[line][space+1]; ++i) {
							tLines.shapes[line].GetSpline(i)->Transform(&tm);
							}
						}
					}
				}
			}
		}
	// Handle underlining if necessary
	if(textFlags & TEXTOBJ_UNDERLINE) {
		for(line = 0; line < lines; ++line) {
			if(textAlignment == TEXTOBJ_JUSTIFIED)
				tLines.Underline(line, widest, tLines.yoffs[line], scaleFactor);
			else
				tLines.Underline(line, tLines.widths[line], tLines.yoffs[line], scaleFactor);
			}
		}
	// Toss 'em all into the output shape with alignment
	for(i = 0; i < lines; ++i) {
		Matrix3 tm(1);
		switch(textAlignment) {
			case TEXTOBJ_LEFT:
				break;	// No action required
			case TEXTOBJ_CENTER:
				tm = TransMatrix(Point3((widest - tLines.widths[i]) / 2.0f, 0.0f, 0.0f));
				break;
			case TEXTOBJ_RIGHT:
				tm = TransMatrix(Point3(widest - tLines.widths[i], 0.0f, 0.0f));
				break;
			case TEXTOBJ_JUSTIFIED: 
				break;
			}
		tLines.shapes[i].Transform(tm);
		textShape += tLines.shapes[i];
		}
	textShape.InvalidateGeomCache();

	// Center up the shape
	Box3 shapeBox = textShape.GetBoundingBox();
	Point3 textCenter = shapeBox.Center();
	Matrix3 centerTM = TransMatrix(-Point3(textCenter.x, baselineAligned ? 0.0f : textCenter.y, 0.0f));
	textShape.Transform(centerTM);
	textShape.InvalidateGeomCache();

	textShapeValid = TRUE;
	}

void TextObject::InvalidateTextShape() {
	textShapeValid = FALSE;
	organized = FALSE;
	ShapeInvalid();
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

DWORD TextObject::FontFlagsFromTextFlags() {
	DWORD f = 0;
	return f;
	}

// Returns TRUE if font actually changed

BOOL TextObject::ChangeFont(TSTR name, DWORD flags) {
	if(!name.Length())
		return FALSE;
	if(name == fontName && flags == fontFlags && fontHandle > 0)
		return FALSE;				// If it's the same, forget it!
	BEZFONTHANDLE newHandle = theBezFontManager.OpenFont(name, flags);
	if(!newHandle) {
		return FALSE;
		}
	if(fontHandle)
		theBezFontManager.CloseFont(fontHandle);
	fontHandle = newHandle;
	if(name != fontName || flags != fontFlags) {
		fontName = name;
		fontFlags = flags;
		FlushCharCache();	// The cached characters are no longer valid!
		}
	theBezFontManager.GetFontInfo(fontName, fontInfo);
	InvalidateTextShape();
	return TRUE;
	}

BOOL TextObject::ChangeText(TSTR string)
	{
	if (CanChange()) {
		this->string = string;
		InvalidateTextShape();
		return TRUE;
	} else {
		return FALSE;
		}
	}

void TextObject::FlushCharCache() {
	int chars = chShapes.Count();
	for(int i = 0; i < chars; ++i)
		delete chShapes[i];
	chShapes.Delete(0, chars);
	}

int TextObject::UpdateCharCache() {
	int chars = chShapes.Count();
	int strChars = string.Length();
	int i,j;
	for(i = 0; i < chars; ++i) {
		CharShape *cs = chShapes[i];
		cs->keep = FALSE;
		int index = cs->index;
		for(j = 0; j < strChars; ++j) {
			if(index == string[i])
				cs->keep = TRUE;
			}
		}
	// Get rid of the ones we don't need anymore
	for(i = chars-1; i >= 0; --i) {
		if(!chShapes[i]->keep) {
			delete chShapes[i];
			chShapes.Delete(i, 1);
			chars--;
			}
		}
	// Now add in the ones we DO need
	for(i = 0; i < strChars; ++i) {
		UINT index;
		if (isleadbyte(string[i])) {
			union {
				unsigned char b[2];
				unsigned short c;
			} dbcs;
			dbcs.b[0] = string[i];
			dbcs.b[1] = string[++i];
			index = swab(dbcs.c);
		} else {
			index = (UCHAR)string[i];
		}
		BOOL add = TRUE;
		for(j = 0; j < chars; ++j) {
			if(index == (UINT)chShapes[j]->index) {
				add = FALSE;
				break;
				}
			}
		if(add) {
			CharShape *s = new CharShape(index);
			if(!theBezFontManager.BuildCharacter(fontHandle, index, 1000.0f, s->shape, s->width, textVersion))
				s->width = 300.0f;	// Fake it if the character isn't there
			chShapes.Append(1, &s, 5);
			chars++;
			}
		}
//DebugPrint("Character cache updated: %d entries\n",chShapes.Count());
	organized = FALSE;
	return chShapes.Count();
	}

ShapeHierarchy &TextObject::OrganizeCurves(TimeValue t, ShapeHierarchy *hier) {
	UpdateShape(t);
	if(!organized) {
		shape.OrganizeCurves(t, &cachedHier);
		organized = TRUE;
		}
	if(hier)
		*hier = cachedHier;
	return cachedHier;
	}

class TextFlagsRestore : public RestoreObj {
	public:
		TextObject *text;
		DWORD oldFlags;
		DWORD newFlags;
		TextFlagsRestore(TextObject *t, DWORD f) { text=t; oldFlags=t->textFlags; newFlags=f; }
		void Restore(int isUndo) { text->textFlags = oldFlags; text->UpdateUI(TRUE); }
		void Redo() { text->textFlags = newFlags; text->UpdateUI(TRUE); }
		int Size() { return 1; }
		TSTR Description() { return TSTR(_T("text flags restore")); }
	};

void TextObject::SetItalic(BOOL sw) {
	DWORD flags;
	if(sw)
		flags = textFlags | TEXTOBJ_ITALIC;
	else
		flags = textFlags & ~TEXTOBJ_ITALIC;
	theHold.Begin();
	if(theHold.Holding())
		theHold.Put(new TextFlagsRestore(this, flags));
	theHold.Accept(::GetString(IDS_DS_PARAMCHG));
	textFlags = flags;
	}

void TextObject::SetUnderline(BOOL sw) {
	DWORD flags;
	if(sw)
		flags = textFlags | TEXTOBJ_UNDERLINE;
	else
		flags = textFlags & ~TEXTOBJ_UNDERLINE;
	theHold.Begin();
	if(theHold.Holding())
		theHold.Put(new TextFlagsRestore(this, flags));
	theHold.Accept(::GetString(IDS_DS_PARAMCHG));
	textFlags = flags;
	}

class TextAlignRestore : public RestoreObj {
	public:
		TextObject *text;
		DWORD oldAlign;
		DWORD newAlign;
		TextAlignRestore(TextObject *t, int a) { text=t; oldAlign=t->textAlignment; newAlign=a; }
		void Restore(int isUndo) { text->textAlignment = oldAlign; text->UpdateUI(TRUE); }
		void Redo() { text->textAlignment = newAlign; text->UpdateUI(TRUE); }
		int Size() { return 1; }
		TSTR Description() { return TSTR(_T("text align restore")); }
	};
BOOL TextObject::SetAlignment(int type) {
	switch(type) {
		case TEXTOBJ_LEFT:
		case TEXTOBJ_CENTER:
		case TEXTOBJ_RIGHT:
		case TEXTOBJ_JUSTIFIED:
			theHold.Begin();
			if(theHold.Holding())
				theHold.Put(new TextAlignRestore(this, type));
			theHold.Accept(::GetString(IDS_DS_PARAMCHG));
			textAlignment = type;
			return TRUE;
		}
	return FALSE;
	}

#define FONTNAME_CHUNK	 		0x1000
#define STRING_CHUNK 			0x1010
#define OLD_TEXT_CHUNK			0x1020	// Was cached text shape	-- OBSOLETE!!
#define CHARSHAPE_CHUNK			0x1030	// cached character shape
#define BOLD_CHUNK				0x1040	// No longer used!
#define ITALIC_CHUNK			0x1050
#define UNDERLINE_CHUNK			0x1060
#define FONT_BOLD_CHUNK			0x1070	// No longer used!
#define ALIGNMENT_CHUNK			0x1080
#define SIMPLESPLINE_DATA_CHUNK	0x2000
#define TEXT_VERSION_CHUNK		0x2010	// If not present, it's 1.x
#define BASELINE_ALIGNED_CHUNK	0x2020

IOResult TextObject::Save(ISave *isave) {
	ULONG nb;
	int bytes;

	isave->BeginChunk(FONTNAME_CHUNK);
	bytes = fontName.Length() + 1;
	isave->Write(&bytes,sizeof(int), &nb);
	isave->Write(fontName.data(),bytes, &nb);
	isave->EndChunk();

	isave->BeginChunk(STRING_CHUNK);
	bytes = string.Length() + 1;
	isave->Write(&bytes,sizeof(int), &nb);
	isave->Write(string.data(),bytes, &nb);
	isave->EndChunk();

	for(int i = 0; i < chShapes.Count(); ++i) { 
		isave->BeginChunk(CHARSHAPE_CHUNK);
		chShapes[i]->Save(isave);
		isave->EndChunk();
		}

	if(textFlags & TEXTOBJ_ITALIC) {
		isave->BeginChunk(ITALIC_CHUNK);
		isave->EndChunk();
		}
	if(textFlags & TEXTOBJ_UNDERLINE) {
		isave->BeginChunk(UNDERLINE_CHUNK);
		isave->EndChunk();
		}
 	if(baselineAligned) {
		isave->BeginChunk(BASELINE_ALIGNED_CHUNK);
		isave->EndChunk();
		}

	isave->BeginChunk(ALIGNMENT_CHUNK);
	isave->Write(&textAlignment, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(SIMPLESPLINE_DATA_CHUNK);
	SimpleSpline::Save(isave);
	isave->EndChunk();

	isave->BeginChunk(TEXT_VERSION_CHUNK);
	isave->Write(&textVersion, sizeof(int), &nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult TextObject::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	int bytes;
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	textFlags = 0;
	textVersion = 1;	// The default text version number
	baselineAligned = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case FONTNAME_CHUNK:
				res = iload->Read(&bytes,sizeof(int), &nb);
				fontName.Resize(bytes-1);
				res = iload->Read(fontName.data(), bytes,&nb);
				break;
			case STRING_CHUNK:
				res = iload->Read(&bytes,sizeof(int), &nb);
				string.Resize(bytes-1);
				res = iload->Read(string.data(), bytes, &nb);
				break;
			case CHARSHAPE_CHUNK: {
				CharShape *cs = new CharShape;
				chShapes.Append(1, &cs);
				res = cs->Load(iload);
				}
				break;
			case OLD_TEXT_CHUNK:
				iload->SetObsolete();
				break;
			case ITALIC_CHUNK:
				textFlags |= TEXTOBJ_ITALIC;
				break;
			case UNDERLINE_CHUNK:
				textFlags |= TEXTOBJ_UNDERLINE;
				break;
			case ALIGNMENT_CHUNK:
				res = iload->Read(&textAlignment, sizeof(int), &nb);
				break;
			case SIMPLESPLINE_DATA_CHUNK:
				res = SimpleSpline::Load(iload);
				break;
			case TEXT_VERSION_CHUNK:
				res = iload->Read(&textVersion, sizeof(int), &nb);
				break;
			case BASELINE_ALIGNED_CHUNK:
				baselineAligned = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\tripatch.cpp ===
/**********************************************************************
 *<
	FILE: tripatch.cpp

	DESCRIPTION:  A triangular patch object implementation

	CREATED BY: Tom Hudson

	HISTORY: created 6 July 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "surf_api.h"
#include "tessint.h"
#include "MeshDelta.h"

#define TRIPATCH_CLASS_ID 0x1fff

// Parameter block indices
#define PB_LENGTH	0
#define PB_WIDTH	1
#define PB_TEXTURE	2

// Non-parameter block indices
#define PB_TI_POS			0
#define PB_TI_LENGTH		1
#define PB_TI_WIDTH			2

class TriPatchCreateCallBack;

#define BMIN_LENGTH		float(0)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)

#define BDEF_DIM		float(0)

class TriPatchObject: public GeomObject, public IParamArray  {			   
	friend class TriPatchCreateCallBack;
	friend BOOL CALLBACK TriPatchParamDialogProc( HWND hDlg, UINT message, 
		WPARAM wParam, LPARAM lParam );
	
	public:
		// Object parameters		
		IParamBlock *pblock;
		Interval ivalid;
		int creating;

		// Class vars
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static BOOL dlgTexture;
		static Point3 crtPos;		
		static float crtWidth, crtLength;
		static TriPatchObject *editOb;

		// Caches
		PatchMesh patch;

		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
		void BuildPatch(TimeValue t,PatchMesh& amesh);
		void GetBBox(TimeValue t, Matrix3 &tm, Box3& box);

		TriPatchObject();
		~TriPatchObject();

		void InvalidateUI();
		void PatchMeshInvalid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:		

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		void PrepareMesh(TimeValue t);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags, Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next );
		TCHAR *GetObjectName() { return GetString(IDS_TH_TRIPATCH); }

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_TH_TRIPATCH); }		
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		
		// From GeomObject
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vxt, Box3& box );
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );

		PatchMesh& GetPatchMesh(TimeValue t);
		void UpdatePatchMesh(TimeValue t);

		// Animatable methods
		void DeleteThis() { delete this; }
		void FreeCaches(); 
		Class_ID ClassID() { return Class_ID( TRIPATCH_CLASS_ID, 0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_TH_TRIPATCHOBJECT_CLASS)); }		
		
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_TH_PARAMETERS));}		
		int IsKeyable() { return 1;}
		BOOL BypassTreeView() { return FALSE; }

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

		// IO
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		// Automatic texture support
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
	};				

//------------------------------------------------------

class TriPatchClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TriPatchObject; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_TRI_PATCH_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TRIPATCH_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_PATCH_GRIDS);  }
	void			ResetClassParams(BOOL fileReset);
	};

static TriPatchClassDesc triPatchDesc;

ClassDesc* GetTriPatchDesc() { return &triPatchDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for tri patch class.
IParamMap *TriPatchObject::pmapParam  = NULL;
IParamMap *TriPatchObject::pmapTypeIn = NULL;
IObjParam *TriPatchObject::ip;
BOOL TriPatchObject::dlgTexture = FALSE;
Point3 TriPatchObject::crtPos         = Point3(0,0,0);		
float TriPatchObject::crtWidth        = 0.0f; 
float TriPatchObject::crtLength       = 0.0f;
TriPatchObject *TriPatchObject::editOb = NULL;

void TriPatchClassDesc::ResetClassParams(BOOL fileReset)
	{
	TriPatchObject::dlgTexture = FALSE;
	TriPatchObject::crtWidth   = 0.0f; 
	TriPatchObject::crtLength  = 0.0f;
	TriPatchObject::crtPos     = Point3(0,0,0);
	}

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	

	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),
			
	};
#define TYPEINDESC_LENGTH 3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	
		
	// Gen UVs
	ParamUIDesc(PB_TEXTURE,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 3


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
 };
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 4 },
 };
#define PBLOCK_LENGTH	3

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,2,0)			
	};
#define NUM_OLDVERSIONS	1	

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class TriPatchTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		TriPatchObject *ob;

		TriPatchTypeInDlgProc(TriPatchObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL TriPatchTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {					
					if (ob->crtLength==0.0) return TRUE;
					if (ob->crtWidth==0.0) return TRUE;

					// Return focus to the top spinner
					SetFocus(GetDlgItem(hWnd, IDC_TI_POSX));
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_LENGTH,0,ob->crtLength);
						ob->pblock->SetValue(PB_WIDTH,0,ob->crtWidth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);					
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void TriPatchObject::BeginEditParams( IObjParam *ip, ULONG flags, Animatable *prev )
	{
	editOb = this;
	this->ip = ip;
	
	if (pmapTypeIn && pmapParam) {
		
		// Left over from last shape ceated
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TRIPATCHPARAM2),
				GetString(IDS_TH_KEYBOARD_ENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_TRIPATCHPARAM),
			GetString(IDS_TH_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new TriPatchTypeInDlgProc(this));
		}
	}
		
void TriPatchObject::EndEditParams( IObjParam *ip, ULONG flags, Animatable *next )
	{
	editOb = NULL;
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_TEXTURE,ip->GetTime(),dlgTexture,FOREVER);	
	}

PatchMesh &TriPatchObject::GetPatchMesh(TimeValue t) {
	UpdatePatchMesh(t);
	return patch;
	}

void TriPatchObject::UpdatePatchMesh(TimeValue t) {
	if ( ivalid.InInterval(t) ) {
		return;
		}
	BuildPatch(t,patch);
	}

void TriPatchObject::FreeCaches() {
	ivalid.SetEmpty();
	patch.FreeAll();
	}

// Triangular patch layout:
//
//   A---> ac ----- ca <---C
//   |                    / 
//   |                  /
//   v    i1    i3    /
//   ab            cb
//
//   |           /
//   |    i2   /
// 
//   ba     bc
//   ^     /
//   |   /
//   | /
//   B
//
// vertices ( a b c d ) are in counter clockwise order when viewed from 
// outside the surface

#define MAKEVEC(vec, p1, p2) { patch.setVec(vec, p1 + (p2 - p1) / 3.0f); patch.setVec(vec+1, p2 - (p2 - p1) / 3.0f); }

void TriPatchObject::BuildPatch(TimeValue t,PatchMesh& amesh)
	{
	int nverts = 4;
	int nvecs = 16;
	float l, w;
	int tex;
	
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	pblock->GetValue( PB_LENGTH, t, l, ivalid );
	pblock->GetValue( PB_WIDTH, t, w, ivalid );
	pblock->GetValue( PB_TEXTURE, t, tex, ivalid );

	amesh.setNumVerts(nverts);
	amesh.setNumTVerts(tex ? nverts : 0);
	amesh.setNumVecs(nvecs);
	amesh.setNumPatches(2);
	amesh.setNumTVPatches(tex ? 2 : 0);

	Point3 v0 = Point3(-w, -l, 0.0f) / 2.0f;   
	Point3 v1 = v0 + Point3(w, 0.0f, 0.0f);
	Point3 v2 = v0 + Point3(w, l, 0.0f);
	Point3 v3 = v0 + Point3(0.0f, l, 0.0f);

	// Create the vertices.
	amesh.verts[0].flags = PVERT_COPLANAR;
	amesh.verts[1].flags = PVERT_COPLANAR;
	amesh.verts[2].flags = PVERT_COPLANAR;
	amesh.verts[3].flags = PVERT_COPLANAR;
	if(tex) {
		amesh.setTVert(0, UVVert(0,0,0));
		amesh.setTVert(1, UVVert(1,0,0));
		amesh.setTVert(2, UVVert(1,1,0));
		amesh.setTVert(3, UVVert(0,1,0));
		}
	amesh.setVert(0, v0);
	amesh.setVert(1, v1);
	amesh.setVert(2, v2);
	amesh.setVert(3, v3);

	// Create the vectors
	MAKEVEC(0, v0, v1);
	MAKEVEC(2, v1, v2);
	MAKEVEC(4, v2, v3);
	MAKEVEC(6, v3, v0);
	MAKEVEC(8, v3, v1);

	// Create patches.
	amesh.MakeTriPatch(0, 0, 0, 1, 1, 9, 8, 3, 6, 7, 10, 11, 12, 1);
	amesh.MakeTriPatch(1, 1, 2, 3, 2, 4, 5, 3, 8, 9, 13, 14, 15, 1);
	Patch &p1 = amesh.patches[0];
	Patch &p2 = amesh.patches[1];
	if(tex) {
		amesh.getTVPatch(0).setTVerts(0,1,3);
		amesh.getTVPatch(1).setTVerts(1,2,3);
		}

	// Finish up patch internal linkages (and bail out if it fails!)
	assert(amesh.buildLinkages());

	// Calculate the interior bezier points on the PatchMesh's patches
	amesh.computeInteriors();

	amesh.InvalidateGeomCache();

	// Tell the PatchMesh it just got changed
	amesh.InvalidateMesh();
	}


TriPatchObject::TriPatchObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);
	pblock->SetValue(PB_TEXTURE,0,dlgTexture);

	ivalid.SetEmpty();
	creating = 0;	
	}

TriPatchObject::~TriPatchObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}

class TriPatchCreateCallBack: public CreateMouseCallBack {
	TriPatchObject *ob;
	Point3 p0,p1;
	IPoint2 sp0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TriPatchObject *obj) { ob = obj; }
	};

int TriPatchCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				ob->creating = 1;	// tell object we're building it so we can disable snapping to itself
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				ob->pblock->SetValue(PB_WIDTH,0,0.0f);
				ob->pblock->SetValue(PB_LENGTH,0,0.0f);
				p1 = p0 + Point3(0.01f,0.01f,0.0f);
				mat.SetTrans(float(.5)*(p0+p1));				
				break;
			case 1:
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(float(.5)*(p0+p1));
				d = p1-p0;
				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pmapParam->Invalidate();										
				if (msg==MOUSE_POINT) {
					ob->creating = 0;
					return (Length(m-sp0)<3) ? CREATE_ABORT: CREATE_STOP;
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		ob->creating = 0;
		return CREATE_ABORT;
		}

	return TRUE;
	}

static TriPatchCreateCallBack patchCreateCB;

CreateMouseCallBack* TriPatchObject::GetCreateMouseCallBack() {
	patchCreateCB.SetObj(this);
	return(&patchCreateCB);
	}


// From BaseObject
int TriPatchObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {	
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
   	
	UpdatePatchMesh(t);
	gw->setTransform(inode->GetObjectTM(t));

	MakeHitRegion(hitRegion, type, crossing, 4, p);
	return patch.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT );
	}

void TriPatchObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	if(creating)	// If creating this one, don't try to snap to it!
		return;

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	
   	
	UpdatePatchMesh(t);
	gw->setTransform(tm);

	patch.snap( gw, snap, p, tm );
	}

int TriPatchObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 tm;
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(inode->GetObjectTM(t));
	UpdatePatchMesh(t);
	if(!(gw->getRndMode() & GW_BOX_MODE)) {
		PrepareMesh(t);
		Mesh& mesh = patch.GetMesh();
		if(mesh.getNumVerts()) {
			mesh.render( gw, inode->Mtls(),
				(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
				COMP_ALL | (inode->Selected()?COMP_OBJSELECTED:0), inode->NumMtls());	
			}
		}
	patch.render( gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
		COMP_ALL | (inode->Selected()?COMP_OBJSELECTED:0), inode->NumMtls());	
	return(0);
	}

//////////////////////////////////  MESH WELDER ////////////////////
static void
WeldMesh(Mesh *mesh, float thresh)
{
	if (thresh == 0.0f)
		thresh = (float)1e-30; // find only the coincident ones	BitArray vset, eset;
	BitArray vset;
	vset.SetSize(mesh->numVerts);
	vset.SetAll();
	MeshDelta md;
	md.WeldByThreshold(*mesh, vset, thresh);
	md.Apply(*mesh);
}


typedef int (* GTess)(void *obj, SurfaceType type, Matrix3 *otm, Mesh *mesh,
							TessApprox *tess, TessApprox *disp, View *view,
							Mtl* mtl, BOOL dumpMiFile, BOOL splitMesh);
static GTess psGTessFunc = NULL;

// This function get the function to do GAP Tessellation from
// tessint.dll.  This is required because of the link order between
// core.dll and tessint.dll and gmi.dll.  -- Charlie Thaeler
static void
GetGTessFunction()
{
    if (psGTessFunc)
        return;
    // Get the library handle for tessint.dll
    HINSTANCE hInst = NULL;
	hInst = LoadLibraryEx(_T("tessint.dll"), NULL, 0);
    assert(hInst);

    psGTessFunc = (GTess)GetProcAddress(hInst, _T("GapTessellate"));
	assert(psGTessFunc);
}

Mesh* TriPatchObject::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete) {
	UpdatePatchMesh(t);
	TessApprox tess = patch.GetProdTess();
	if (tess.type == TESS_SET) {
		needDelete = FALSE;
		patch.InvalidateMesh(); // force this...
		// temporarlily set the view tess to prod tess
		TessApprox tempTess = patch.GetViewTess();
		patch.SetViewTess(tess);
		PrepareMesh(t);
		patch.SetViewTess(tempTess);
		return &patch.mesh;
	} else {
		Mesh *nmesh = new Mesh/*(mesh)*/;
		Matrix3 otm = inode->GetObjectTM(t);

		Box3 bbox;
		GetDeformBBox(t, bbox);
		tess.merge *= Length(bbox.Width())/1000.0f;
		TessApprox disp = patch.GetDispTess();
		disp.merge *= Length(bbox.Width())/1000.0f;

		GetGTessFunction();
		(*psGTessFunc)(&patch, BEZIER_PATCH, &otm, nmesh, &tess, &disp, &view, inode->GetMtl(), FALSE, FALSE);
		if (tess.merge > 0.0f && patch.GetProdTessWeld())
			WeldMesh(nmesh, tess.merge);
		needDelete = TRUE;
		return nmesh;
	}
}

void TriPatchObject::PrepareMesh(TimeValue t) {
	UpdatePatchMesh(t);
	patch.PrepareMesh();
	}

// From GeomObject
int TriPatchObject::IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) {
	PrepareMesh(t);	// Turn it into a mesh
	return patch.IntersectRay(r, at, norm);
	}

ObjectHandle TriPatchObject::CreateTriObjRep(TimeValue t) {
	TriObject *tri = CreateNewTriObject();
	PrepareMesh(t);	// Turn it into a mesh
	tri->GetMesh() = patch.GetMesh();	// Place it into the TriObject
	return(ObjectHandle(tri));
	}

void TriPatchObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel )
	{
	UpdatePatchMesh(t);
	patch.GetDeformBBox(box, tm, useSel);
	}

void TriPatchObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) {
	GetDeformBBox(t,box);
	}

void TriPatchObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box )
	{
	Box3	patchBox;

	Matrix3 mat = inode->GetObjectTM(t);
	
	GetLocalBoundBox(t,inode,vpt,patchBox);
	box.Init();
	for(int i = 0; i < 8; i++)
		box += mat * patchBox[i];
	}

//
// Reference Managment:
//

//
// Reference Managment:
//

ParamDimension *TriPatchObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:return stdWorldDim;
		case PB_WIDTH: return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR TriPatchObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH: return TSTR(GetString(IDS_RB_LENGTH));
		case PB_WIDTH:  return TSTR(GetString(IDS_RB_WIDTH));
		default: return TSTR(_T(""));
		}
	}

// From ParamArray
BOOL TriPatchObject::SetValue(int i, TimeValue t, int v) 
	{
	return TRUE;
	}

BOOL TriPatchObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH:  crtWidth = v; break;
		}	
	return TRUE;
	}

BOOL TriPatchObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL TriPatchObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	return TRUE;
	}

BOOL TriPatchObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {				
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH:  v = crtWidth; break;
		}
	return TRUE;
	}

BOOL TriPatchObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}

void TriPatchObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

RefResult TriPatchObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			PatchMeshInvalid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}



ObjectState TriPatchObject::Eval(TimeValue time){
	return ObjectState(this);
	}

Interval TriPatchObject::ObjectValidity(TimeValue t) {
	UpdatePatchMesh(t);
	return ivalid;	
	}

int TriPatchObject::CanConvertToType(Class_ID obtype) {
	if (obtype==patchObjectClassID || obtype==defObjectClassID || 
		obtype==mapObjectClassID || obtype==triObjectClassID
#ifndef NO_NURBS
		|| obtype==EDITABLE_SURF_CLASS_ID
#endif
        ) {
		return 1;
		}
	return 0;
	}

Object* TriPatchObject::ConvertToType(TimeValue t, Class_ID obtype) {
	if(obtype == patchObjectClassID || obtype == defObjectClassID || obtype == mapObjectClassID) {
		PatchObject *ob;
		UpdatePatchMesh(t);
		ob = new PatchObject();	
		ob->patch = patch;
		ob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return ob;
		}

	if(obtype == triObjectClassID) {
		TriObject *ob = CreateNewTriObject();
		PrepareMesh(t);
		ob->GetMesh() = patch.GetMesh();
		ob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return ob;
		}
#ifndef NO_NURBS
	if (obtype==EDITABLE_SURF_CLASS_ID) {
		PatchObject *pob;
		UpdatePatchMesh(t);
		pob = new PatchObject();	
		pob->patch = patch;
		Object *ob = BuildEMObjectFromPatchObject(pob);
		delete pob;
		ob->SetChannelValidity(TOPO_CHAN_NUM, ObjectValidity(t));
		ob->SetChannelValidity(GEOM_CHAN_NUM, ObjectValidity(t));
		return ob;
		}
#endif
	return NULL;
	}

RefTargetHandle TriPatchObject::Clone(RemapDir& remap) {
	TriPatchObject* newob = new TriPatchObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}

#define GRID_MAPPING_CHUNK 0x1000

// IO
class TriPatchPostLoadCallback : public PostLoadCallback {
	public:
		BOOL tex;
		ParamBlockPLCB *cb;
		TriPatchPostLoadCallback(ParamBlockPLCB *c) {cb=c; tex=FALSE;}
		void proc(ILoad *iload) {
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (tex) {				
				((TriPatchObject*)targ)->pblock->SetValue(PB_TEXTURE,0,1);
				}
			delete this;
			}
	};

IOResult  TriPatchObject::Load(ILoad *iload) {
	TriPatchPostLoadCallback *plcb = new TriPatchPostLoadCallback(new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	iload->RegisterPostLoadCallback(plcb);
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case GRID_MAPPING_CHUNK:
				plcb->tex = TRUE;	// Deal with this old switch after loading
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

BOOL TriPatchObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_TEXTURE, 0, genUVs, v);
	return genUVs; 
	}

void TriPatchObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_TEXTURE,0, sw);				
	InvalidateUI();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\torus.cpp ===
/**********************************************************************
 *<
	FILE: torus.cpp

	DESCRIPTION:  Defines a Test Object Class

	CREATED BY: Dan Silva
	MODIFIED BY: Rolf Berteig

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"

class TorusObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgSegments, dlgSides;		
		static int dlgCreateMeth;
		static int dlgSmooth;	
		static float dlgRadius2;	
		static Point3 crtPos;		
		static float crtRadius1;
		static float crtRadius2;	
	
		TorusObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		BOOL IsParamSurface() {return TRUE;}
		Point3 GetSurfacePoint(TimeValue t, float u, float v,Interval &iv);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_TORUS); }

		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID( TORUS_CLASS_ID,0); }  
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
	};

// segments  = sides
// lsegments = segments

#define MIN_SEGMENTS	3
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_PIESLICE	float(-1.0E30)
#define MAX_PIESLICE	float( 1.0E30)

#define DEF_SEGMENTS 	24
#define DEF_SIDES		12

#define DEF_RADIUS		(0.1f)
#define DEF_RADIUS2   	(10.0f)

#define SMOOTH_STRIPES	3
#define SMOOTH_ON		2
#define SMOOTH_SIDES	1
#define SMOOTH_OFF		0


//--- ClassDescriptor and class vars ---------------------------------

class TorusClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TorusObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_TORUS_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TORUS_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
	void            ResetClassParams(BOOL fileReset);
	};

static TorusClassDesc torusDesc;

ClassDesc* GetTorusDesc() { return &torusDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IObjParam *TorusObject::ip         = NULL;
int TorusObject::dlgSegments       = DEF_SEGMENTS;
int TorusObject::dlgSides          = DEF_SIDES;
int TorusObject::dlgCreateMeth     = 1; // create_radius
int TorusObject::dlgSmooth         = SMOOTH_ON;
float TorusObject::dlgRadius2      = DEF_RADIUS2;
IParamMap *TorusObject::pmapCreate = NULL;
IParamMap *TorusObject::pmapTypeIn = NULL;
IParamMap *TorusObject::pmapParam  = NULL;
Point3 TorusObject::crtPos         = Point3(0,0,0);
float TorusObject::crtRadius1      = 0.0f;
float TorusObject::crtRadius2      = DEF_RADIUS2;

void TorusClassDesc::ResetClassParams(BOOL fileReset)
	{
	TorusObject::dlgSegments    = DEF_SEGMENTS;
	TorusObject::dlgSides       = DEF_SIDES;
	TorusObject::dlgCreateMeth  = 1; // create_radius
	TorusObject::dlgSmooth      = SMOOTH_ON;
	TorusObject::dlgRadius2     = DEF_RADIUS2;
	TorusObject::crtPos         = Point3(0,0,0);
	TorusObject::crtRadius1     = 0.0f;
	TorusObject::crtRadius2     = DEF_RADIUS2;
	}


//--- Parameter map/block descriptors -------------------------------

// Parameter map indices
#define PB_RADIUS		0
#define PB_RADIUS2		1
#define PB_ROTATION		2
#define PB_TWIST		3
#define PB_SEGMENTS		4
#define PB_SIDES		5
#define PB_SMOOTH		6
#define PB_SLICEON		7
#define PB_PIESLICE1	8
#define PB_PIESLICE2	9
#define PB_GENUVS		10

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGH 3


//
//
// Parameters

static int smoothIDs[] = {IDC_SMOOTH_NONE,IDC_SMOOTH_SIDES,IDC_SMOOTH_ALL,IDC_SMOOTH_STRIPES};

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Radius
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Rotation
	ParamUIDesc(
		PB_ROTATION,
		EDITTYPE_FLOAT,
		IDC_TORUS_ROT,IDC_TORUS_ROTSPIN,
		MIN_PIESLICE,MAX_PIESLICE,
		0.5f,
		stdAngleDim),	

	// Twist
	ParamUIDesc(
		PB_TWIST,
		EDITTYPE_FLOAT,
		IDC_TORUS_TWIST,IDC_TORUS_TWISTSPIN,
		MIN_PIESLICE,MAX_PIESLICE,
		0.5f,
		stdAngleDim),	

	// Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Smooth	
	ParamUIDesc(PB_SMOOTH,TYPE_RADIO,smoothIDs,4),

		// Slice on
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SLICEON),	

	// Pie slice from
	ParamUIDesc(
		PB_PIESLICE1,
		EDITTYPE_FLOAT,
		IDC_PIESLICE1,IDC_PIESLICESPIN1,
		MIN_PIESLICE,MAX_PIESLICE,
		0.5f,
		stdAngleDim),	

	// Pie slice to
	ParamUIDesc(
		PB_PIESLICE2,
		EDITTYPE_FLOAT,
		IDC_PIESLICE2,IDC_PIESLICESPIN2,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 11


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, FALSE, 10 } };

#define PBLOCK_LENGTH	11

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,5,0),
	ParamVersionDesc(descVer1,9,1),
	ParamVersionDesc(descVer2,10,2)
	};
#define NUM_OLDVERSIONS	3

// Current version
static ParamVersionDesc curVersion(descVer3,PBLOCK_LENGTH,3);
#define CURRENT_VERSION	3


//--- TypeInDlgProc --------------------------------

class TorusTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		TorusObject *ob;

		TorusTypeInDlgProc(TorusObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL TorusTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ob->crtRadius1==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius1);
						ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);
					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Torus methods -------------------------------


TorusObject::TorusObject()
	{
	SetAFlag(A_PLUGIN1);
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer3, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGMENTS,0,dlgSegments);
	pblock->SetValue(PB_SIDES,0,dlgSides);	
	pblock->SetValue(PB_RADIUS,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);	
	}

#define NEWMAP_CHUNKID	0x0100

IOResult TorusObject::Load(ILoad *iload) 
	{
	ClearAFlag(A_PLUGIN1);

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

IOResult TorusObject::Save(ISave *isave)
	{
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
 	return IO_OK;
	}

void TorusObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam && pmapTypeIn) {
		
		// Left over from last Torus ceated		
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TORUSPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			
			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TORUSPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_TORUSPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new TorusTypeInDlgProc(this));
		}
	}
		
void TorusObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
	pblock->GetValue(PB_SEGMENTS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	pblock->GetValue(PB_RADIUS2,ip->GetTime(),dlgRadius2,FOREVER);		
	}


Point3 TorusObject::GetSurfacePoint(
		TimeValue t, float u, float v,Interval &iv)
	{
	float radius,radius2;
	pblock->GetValue(PB_RADIUS,t,radius,iv);
	pblock->GetValue(PB_RADIUS2,t,radius2,iv);	
	float ang = (1.0f-u)*TWOPI, ang2 = v*TWOPI;
	float sinang  = (float)sin(ang);
	float cosang  = (float)cos(ang);		
	float sinang2 = (float)sin(ang2);
	float cosang2 = (float)cos(ang2);
	float rt = radius+radius2*cosang2;
	Point3 p;
	p.x = rt*cosang;
	p.y = -rt*sinang;
	p.z = radius2*sinang2;
	return p;
	}

BOOL TorusObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void TorusObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}


void TorusObject::BuildMesh(TimeValue t)
	{
	Point3 p;
	int ix,na,nb,nc,nd,jx,kx;
	int nf=0,nv=0;
	float delta,ang;
	float delta2,ang2;
	int sides,segs,smooth;
	float radius,radius2, rotation;
	float sinang,cosang, sinang2,cosang2,rt;
	float twist, pie1, pie2, totalPie, startAng = 0.0f;
	int doPie  = TRUE;	
	int genUVs = TRUE;	

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;	
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_RADIUS2,t,radius2,ivalid);
	pblock->GetValue(PB_ROTATION,t,rotation,ivalid);
	pblock->GetValue(PB_TWIST,t,twist,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,segs,ivalid);
	pblock->GetValue(PB_SIDES,t,sides,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);
	pblock->GetValue(PB_PIESLICE1,t,pie1,ivalid);
	pblock->GetValue(PB_PIESLICE2,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	LimitValue( segs, MIN_SEGMENTS, MAX_SEGMENTS );
	LimitValue( sides, MIN_SIDES, MAX_SIDES );	

	// We do the torus backwards from the cylinder
	pie1 = -pie1;
	pie2 = -pie2;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;	
	
	if (doPie) {
		delta    = totalPie/(float)(segs-1);
		startAng = pie2;
	} else {
		delta = (float)2.0*PI/(float)segs;
		}
	
	delta2 = (float)2.0*PI/(float)sides;
	
	if (TestAFlag(A_PLUGIN1)) startAng -= HALFPI;

	int nverts;
	int nfaces;
	if (doPie) {
		nverts = sides*segs + 2;
		nfaces = 2*sides*segs;
	} else {
		nverts = sides*segs;
		nfaces = 2*sides*segs;
		}
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth);
	if (genUVs) {
		if (doPie) {
			mesh.setNumTVerts((sides+1)*segs+2);
			mesh.setNumTVFaces(2*sides*segs);
		} else {
			mesh.setNumTVerts((sides+1)*(segs+1));
			mesh.setNumTVFaces(2*sides*segs);
			}
	} else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		}

	ang = startAng;

	// make verts
	for(ix=0; ix<segs; ix++) {
		sinang = (float)sin(ang);
		cosang = (float)cos(ang);
		ang2 = rotation + twist * float(ix+1)/float(segs);
		for (jx = 0; jx<sides; jx++) {
			sinang2 = (float)sin(ang2);
			cosang2 = (float)cos(ang2);
			rt = radius+radius2*cosang2;
			p.x = rt*cosang;
			p.y = -rt*sinang;
			p.z = radius2*sinang2;	
			mesh.setVert(nv++, p);
			ang2 += delta2;
			}	
		ang += delta;
		}
	
	if (doPie) {
		p.x = radius * (float)cos(startAng);
		p.y = -radius * (float)sin(startAng);
		p.z = 0.0f;
		mesh.setVert(nv++, p);

		ang -= delta;
		p.x = radius * (float)cos(ang);
		p.y = -radius * (float)sin(ang);
		p.z = 0.0f;
		mesh.setVert(nv++, p);
		}
	
	// Make faces

	/* Make midsection */
	for(ix=0; ix<segs-doPie; ++ix) {
		jx=ix*sides;
		for (kx=0; kx<sides; ++kx) {
			na = jx+kx;
			nb = (ix==(segs-1))?kx:na+sides;
			nd = (kx==(sides-1))? jx : na+1;
			nc = nb+nd-na;

			DWORD grp = 0;
			if (smooth==SMOOTH_SIDES) {
				if (kx==sides-1 && (sides&1)) {
					grp = (1<<2);
				} else {
					grp = (kx&1) ? (1<<0) : (1<<1);
					}
			} else 
			if (smooth==SMOOTH_STRIPES) {
				if (ix==segs-1 && (segs&1)) {
					grp = (1<<2);
				} else {
					grp = (ix&1) ? (1<<0) : (1<<1);
					}
			} else 
			if (smooth > 0) {
				grp = 1;
				}

			mesh.faces[nf].setEdgeVisFlags(0,1,1);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setMatID(0);
			mesh.faces[nf++].setVerts( na,nc,nb);

			mesh.faces[nf].setEdgeVisFlags(1,1,0);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setMatID(0);
			mesh.faces[nf++].setVerts(na,nd,nc);
			}
	 	}

	if (doPie) {		
		na = nv -2;
		for(ix=0; ix<sides; ++ix) {
			nb = ix;
			nc = (ix==(sides-1))?0:ix+1;
			mesh.faces[nf].setEdgeVisFlags(0,1,0);
			mesh.faces[nf].setSmGroup((1<<3));
			mesh.faces[nf].setMatID(1);
			mesh.faces[nf++].setVerts(na,nc,nb);
			}
		
		na = nv -1;
		jx = sides*(segs-1);
		for(ix=0; ix<sides; ++ix) {
			nb = jx+ix;
			nc = (ix==(sides-1))?jx:nb+1;
			mesh.faces[nf].setEdgeVisFlags(0,1,0);
			mesh.faces[nf].setSmGroup((1<<3));
			mesh.faces[nf].setMatID(2);
			mesh.faces[nf++].setVerts(na,nb,nc);
			}
		}

	
	// UVWs -------------------
	
	if (genUVs) {
		nv=0;
		for(ix=0; ix<=segs-doPie; ix++) {
			for (jx=0; jx<=sides; jx++) {
				mesh.setTVert(nv++,float(jx)/float(sides),float(ix)/float(segs),0.0f);
				}
			}
		int pie1, pie2;
		if (doPie) {
			pie1 = nv;
			mesh.setTVert(nv++,0.5f,1.0f,0.0f);
			pie2 = nv;
			mesh.setTVert(nv++,0.5f,0.0f,0.0f);
			}				
		
		nf=0;
		for(ix=0; ix<segs-doPie; ix++) {
			na = ix*(sides+1);
			nb = (ix+1)*(sides+1);
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(na,nb+1,nb);
				mesh.tvFace[nf++].setTVerts(na,na+1,nb+1);
				na++;
				nb++;
				}
			}
		if (doPie) {						
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(pie1,jx+1,jx);				
				}			
			nb = (sides+1)*(segs-1);
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(pie2,nb,nb+1);
				nb++;
				}
			}
		}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

#define Tang(vv,ii) ((vv)*4+(ii))

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_FACT8	0.265202f
#define CIRCLE_FACT4	0.5517861843f

void BuildTorusPatch(
		TimeValue t, PatchMesh &patch, 
		float radius1, float radius2, int genUVs)
	{
	int segs = 8, sides = 4;
	int nverts = segs * sides;
	int nvecs = segs*sides*8;
	int npatches = segs * sides;
	patch.setNumVerts(nverts);
	patch.setNumTVerts(genUVs ? (segs + 1) * (sides + 1) : 0);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);	
	patch.setNumTVPatches(genUVs ? npatches : 0);
	int ix=0, jx=0, kx=sides*segs*4, i, j;
	float ang1 = 0.0f, delta1 = TWOPI/float(segs);
	float ang2 = 0.0f, delta2 = TWOPI/float(sides);	
	float circleLenIn = CIRCLE_FACT8*(radius1-radius2);
	float circleLenOut = CIRCLE_FACT8*(radius1+radius2);
	float circleLenMid = CIRCLE_FACT4*radius2;
	float circleLen;
	float sinang1, cosang1, sinang2, cosang2, rt, u;
	Point3 p, v;
	DWORD a, b, c, d;

	for (i=0; i<segs; i++) {
		sinang1 = (float)sin(ang1);
		cosang1 = (float)cos(ang1);
		ang2 = 0.0f;
		for (j=0; j<sides; j++) {			
			sinang2 = (float)sin(ang2);
			cosang2 = (float)cos(ang2);
			rt = radius1+radius2*cosang2;
			
			// Vertex
			p.x = rt*cosang1;
			p.y = rt*sinang1;
			p.z = radius2*sinang2;	
			patch.setVert(ix, p);
			
			// Tangents			
			u = (cosang2+1.0f)/2.0f;
			circleLen = u*circleLenOut + (1.0f-u)*circleLenIn;

			v.x = -sinang1*circleLen;
			v.y = cosang1*circleLen;
			v.z = 0.0f;
			patch.setVec(jx++,patch.verts[ix] + v);
			
			v.x = sinang1*circleLen;
			v.y = -cosang1*circleLen;
			v.z = 0.0f;
			patch.setVec(jx++,patch.verts[ix] + v);
			
			v.x = -sinang2*cosang1*circleLenMid;
			v.y = -sinang2*sinang1*circleLenMid;
			v.z = cosang2*circleLenMid;
			patch.setVec(jx++,patch.verts[ix] + v);
			
			v.x = sinang2*cosang1*circleLenMid;
			v.y = sinang2*sinang1*circleLenMid;
			v.z = -cosang2*circleLenMid;
			patch.setVec(jx++,patch.verts[ix] + v);			

			// Build the patch
			a = ((i+1)%segs)*sides + (j+1)%sides;
			b = i*sides + (j+1)%sides;
			c = i*sides + j;			
			d = ((i+1)%segs)*sides + j;
			
			patch.patches[ix].SetType(PATCH_QUAD);
			patch.patches[ix].setVerts(a, b, c, d);
			patch.patches[ix].setVecs(
				Tang(a,1),Tang(b,0),Tang(b,3),Tang(c,2),
				Tang(c,0),Tang(d,1),Tang(d,2),Tang(a,3));
			patch.patches[ix].setInteriors(kx, kx+1, kx+2, kx+3);
			patch.patches[ix].smGroup = 1;

			kx += 4;
			ix++;
			ang2 += delta2;
			}		
		ang1 += delta1;
		}	

	if(genUVs) {
		int tv = 0;
		int tvp = 0;
		float fsegs = (float)segs;
		float fsides = (float)sides;
		for (i=0; i<=segs; i++) {
			float u = (float)i / fsegs;
			for (j=0; j<=sides; j++,++tv) {
				float v = (float)j / fsides;
				patch.setTVert(tv, UVVert(1.0f-u, v, 0.0f));
				if(j < sides && i < segs)
					patch.getTVPatch(tvp++).setTVerts(tv, tv+1, tv+sides+2, tv+sides+1);
				}		
			}	
		}
			
	assert(patch.buildLinkages());
	patch.computeInteriors();
	patch.InvalidateGeomCache();
	}



#ifndef NO_NURBS

Object *
BuildNURBSTorus(float radius, float radius2, BOOL sliceon, float pie1, float pie2, BOOL genUVs)
{
	NURBSSet nset;

	Point3 origin(0,0,0);
	Point3 symAxis(0,0,1);
	Point3 refAxis(0,1,0);

	float startAngle = 0.0f;
	float endAngle = TWOPI;
	if (sliceon && pie1 != pie2) {
		float sweep = pie2-pie1;
		if (sweep <= 0.0f) sweep += TWOPI;
		refAxis = Point3(Point3(0,1,0) * RotateZMatrix(pie1));
		endAngle = sweep;
	}


	// first the main surface
	NURBSCVSurface *surf = new NURBSCVSurface();
	nset.AppendObject(surf);
	surf->SetGenerateUVs(genUVs);

	surf->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
	surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
	surf->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	surf->FlipNormals(TRUE);
	surf->Renderable(TRUE);
	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_TORUS));
	sprintf(sname, "%s%s", bname, GetString(IDS_CT_SURF));
	surf->SetName(sname);

	if (sliceon && pie1 != pie2) {
		GenNURBSTorusSurface(radius, radius2, origin, symAxis, refAxis,
						startAngle, endAngle, -PI, PI, TRUE, *surf);
		// now create caps on the ends
		NURBSCapSurface *cap0 = new NURBSCapSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0);
		cap0->SetEdge(2);
		cap0->FlipNormals(FALSE);
		cap0->Renderable(TRUE);
		char sname[80];
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
		cap0->SetName(sname);

		NURBSCapSurface *cap1 = new NURBSCapSurface();
		nset.AppendObject(cap1);
		cap1->SetGenerateUVs(genUVs);
		cap1->SetParent(0);
		cap1->SetEdge(3);
		cap1->FlipNormals(TRUE);
		cap1->Renderable(TRUE);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 1);
		cap1->SetName(sname);
	} else {
		GenNURBSTorusSurface(radius, radius2, origin, symAxis, refAxis,
						startAngle, endAngle, -PI, PI, FALSE, *surf);
    }


	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}
#endif


Object* TorusObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius1, radius2;
		int genUVs;
		pblock->GetValue(PB_RADIUS,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildTorusPatch(t,ob->patch,radius1,radius2,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 

#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius, radius2, pie1, pie2;
		int sliceon, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSTorus(radius, radius2, sliceon, pie1, pie2, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
		
	}
#endif

#ifdef DESIGN_VER
	if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		float radius1, radius2, pie1, pie2;
		int sliceon, genUVs, sides, segs;
		pblock->GetValue(PB_RADIUS,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		pblock->GetValue(PB_SIDES,t,sides,valid);
		pblock->GetValue(PB_SEGMENTS,t,segs,valid);
		int smooth;
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res = cacheptr->createTorus(radius1, radius2, sides, segs, smooth);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif

	else {
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int TorusObject::CanConvertToType(Class_ID obtype)
	{
#ifdef DESIGN_VER
	if(obtype == GENERIC_AMSOLID_CLASS_ID)
		return 1;
#endif
	if (obtype==patchObjectClassID || obtype==defObjectClassID ||
		obtype==triObjectClassID) {
		return 1;
    }

#ifndef NO_NURBS
    if (obtype==EDITABLE_SURF_CLASS_ID) {
        return 1;
	} 
#endif

    return SimpleObject::CanConvertToType(obtype);
	}

void TorusObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}


class TorusObjCreateCallBack: public CreateMouseCallBack {
	TorusObject *ob;	
	Point3 p0, p1, p2;
	IPoint2 sp0,sp1,sp2;	
	float oldRad2;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TorusObject *obj) { ob = obj; }
	};



int TorusObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r, r2;
	Point3 center;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif
	
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				ob->pblock->SetValue(PB_RADIUS,0,0.0f);				
				oldRad2 = ob->crtRadius2;
				ob->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p1-p0) - ob->crtRadius2;
					mat.SetTrans(p0);
				} else {
					// diameter
					Point3 center = (p0+p1)/float(2);
					r = Length(center-p0) - ob->crtRadius2;
					mat.SetTrans(center);  // Modify Node's transform
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					if (Length(m-sp0)<3 || Length(p1-p0)<0.1f)
						return CREATE_ABORT;
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}				
				break;
			
			case 2:					
				center = mat.GetTrans();
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				mat.SetTrans(center);

				#ifdef _3D_CREATE	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif

				r   = Length(p1-p0);
				r2  = Length(p2-p0);

				ob->crtRadius2 = (float)fabs(r-r2)/2.0f;
				ob->pblock->SetValue(PB_RADIUS,0,(r2+r)/2);
				ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
				ob->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p2.y-p0.y,p2.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		ob->crtRadius2 = oldRad2;
		return CREATE_ABORT;
		}

	return TRUE;
	}


static TorusObjCreateCallBack torusCreateCB;

CreateMouseCallBack* TorusObject::GetCreateMouseCallBack() {
	torusCreateCB.SetObj(this);
	return(&torusCreateCB);
	}

BOOL TorusObject::OKtoDisplay(TimeValue t) 
	{
	return TRUE;
	}


// From ParamArray
BOOL TorusObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL TorusObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		}	
	return TRUE;
	}

BOOL TorusObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL TorusObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL TorusObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		}
	return TRUE;
	}

BOOL TorusObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void TorusObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *TorusObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:		return stdWorldDim;
		case PB_RADIUS2:	return stdWorldDim;
		case PB_ROTATION:	return stdAngleDim;
		case PB_TWIST:		return stdAngleDim;
		case PB_SEGMENTS:	return stdSegmentsDim;
		case PB_SIDES:		return stdSegmentsDim;
		case PB_SMOOTH:		return stdNormalizedDim;
		case PB_SLICEON:	return stdNormalizedDim;
		case PB_PIESLICE1:	return stdAngleDim;
		case PB_PIESLICE2:	return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR TorusObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:		return TSTR(GetString(IDS_RB_RADIUS1));		
		case PB_RADIUS2:	return TSTR(GetString(IDS_RB_RADIUS2));
		case PB_ROTATION:	return TSTR(GetString(IDS_RB_ROTATION2));
		case PB_TWIST:		return TSTR(GetString(IDS_RB_TWIST));
		case PB_SEGMENTS:	return TSTR(GetString(IDS_RB_SEGS));					
		case PB_SIDES:		return TSTR(GetString(IDS_RB_SIDES));
		case PB_SMOOTH:		return TSTR(GetString(IDS_RB_SMOOTH));
		case PB_SLICEON:	return TSTR(GetString(IDS_RB_SLICEON));
		case PB_PIESLICE1:	return TSTR(GetString(IDS_RB_SLICETO));
		case PB_PIESLICE2:	return TSTR(GetString(IDS_RB_SLICEFROM));		
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle TorusObject::Clone(RemapDir& remap) 
	{
	TorusObject* newob = new TorusObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\teapot.cpp ===
/*****************************************************************************
 *<
	FILE: teapot.cpp

	DESCRIPTION:  Teapot object, Revised implementation

	CREATED BY: Charles Thaeler

        BASED ON : Sphere_C

	HISTORY: created 12/4/95

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
#include "prim.h"
#include "iparamm.h"
#include "simpobj.h"
#include "surf_api.h"
#include "tea_util.h"

// The teapot object class definition.  It is derived from SimpleObject and
// IParamArray.  SimpleObject is the class to derive objects from which have 
// geometry are renderable, and represent themselves using a mesh.  
// IParamArray is used as part of the Parameter Map scheme used to manage
// the user interface parameters.
class TeapotObject : public SimpleObject, public IParamArray {
	public:			
		// Class vars
		// There is only one set of these variables shared by all instances
		// of this class.  This is OK because there is only one Teapot
		// being edited at a time.
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static int dlgSegments;
		static int dlgCreateMeth;
		static int dlgSmooth;
        static int crtTeapart; // this is being kept for revisioning purposes
		static int dlgBody;
		static int dlgHandle;
		static int dlgSpout;
		static int dlgLid;
		static int dlgUVs;
		static Point3 crtPos;		
		static float crtRadius;
		// This is the Interface pointer into MAX.  It is used to call
		// functions implemented in MAX itself.  
		static IObjParam *ip;

		TeapotObject();

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
			
		// This method allows the plug-in to provide MAX with a procedure
		// to manage user input from the mouse during creation of the 
		// Teapot object.
		CreateMouseCallBack* GetCreateMouseCallBack();
		// This method is called when the user may edit the Teapots
		// parameters.
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		// Called when the user is done editing the Teapots parameters.
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		// This is the name that appears in the history list (modifier stack).
		TCHAR *GetObjectName() { return GetString(IDS_RB_TEAPOT); }
		
		// From GeomObject 
		int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		
		// Animatable methods
		// Deletes the instance from memory.		
		void DeleteThis() {delete this;}
		// This returns the unique ClassID of the Teapot procedural object.
		Class_ID ClassID() { 
			return Class_ID(TEAPOT_CLASS_ID1,TEAPOT_CLASS_ID2); } 
		
		// From ReferenceTarget
		// Called by MAX when the teapot is being loaded from disk.
		IOResult Load(ILoad *iload);
				
		// From IParamArray
		// These methods provide MAX with access to the class variables
		// used by the parameter map.
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		// This method builds the mesh representation at the specified time.
		void BuildMesh(TimeValue t);
		// This method returns a flag to indicate if it is OK to 
		// display the object at the time passed.
		BOOL OKtoDisplay(TimeValue t);
		// This method informs the system that the user interface
		// controls need to be updated to reflect the current time.
		void InvalidateUI();
		// Returns the 'dimension' for the parameter whose index is
		// passed.  This is the type and order of magnitude of the 
		// parameter.
		ParamDimension *GetParameterDim(int pbIndex);
		// Returns the name of the parameter whose index is passed.
		TSTR GetParameterName(int pbIndex);
	};


// Misc stuff
#define MAX_SEGMENTS	64
#define MIN_SEGMENTS	1

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float(1.0E30)

#define MIN_SMOOTH		0
#define MAX_SMOOTH		2

#define DEF_SEGMENTS	4
#define DEF_RADIUS		float(0.0)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0

#define POT_BODY		1
#define POT_HANDLE		1
#define POT_SPOUT		1
#define POT_LID			1
#define POT_UVS			0
#define OLD_POT_BOTH    0
#define OLD_POT_BODY    1
#define OLD_POT_LID     2
#define FIXED_OLD_VER   -1


//--- Parameter map/block descriptors -------------------------------
// The parameter map descriptors define the properties of a parameter
// such as the type (spinner, radio button, check box, etc.), which
// resource ID they refer to, and which index into the virtual array
// they use.

// Parameter block indices
#define PB_RADIUS		0
#define PB_SEGS			1
#define PB_SMOOTH		2
#define PB_TEAPART      3
#define PB_TEA_BODY		4
#define PB_TEA_HANDLE	5
#define PB_TEA_SPOUT	6
#define PB_TEA_LID		7
#define PB_GENUVS		8

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1

//
//
// Type in

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE)	
	};
#define TYPEINDESC_LENGH 2

//
//
// Parameters
static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS,IDC_RADSPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	
	
	// Segments
	ParamUIDesc(
		PB_SEGS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Smooth
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),

    // Parts
 	ParamUIDesc(PB_TEAPART,     TYPE_SINGLECHEKBOX,IDC_TEAPART), // Obsolete but needed for versioning
 	ParamUIDesc(PB_TEA_BODY,	TYPE_SINGLECHEKBOX,IDC_TEA_BODY),
	ParamUIDesc(PB_TEA_HANDLE,	TYPE_SINGLECHEKBOX,IDC_TEA_HANDLE),
	ParamUIDesc(PB_TEA_SPOUT,	TYPE_SINGLECHEKBOX,IDC_TEA_SPOUT),
	ParamUIDesc(PB_TEA_LID,		TYPE_SINGLECHEKBOX,IDC_TEA_LID),

	// Generate Texture Mapping
	ParamUIDesc(PB_GENUVS,		TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),

	};
#define PARAMDESC_LENGH 9


// The parameter block descriptor defines the type of value represented
// by the parameter (int, float, Color...) and if it is animated or not.

// This class requires these values to be initialized:
// { - ParameterType, 
//   - Not Used, must be set to NULL, 
//   - Flag which indicates if the parameter is animatable,
//   - ID of the parameter used to match a corresponding ID in the 
//     other version of the parameter
//  }

// This one is the oldest version.
static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },		
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 } };

// This is the older version.
static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 } };

// This is the current version.
static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_BOOL, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_BOOL, NULL, TRUE, 4 },
	{ TYPE_BOOL, NULL, TRUE, 5 },
	{ TYPE_BOOL, NULL, TRUE, 6 },
	{ TYPE_BOOL, NULL, TRUE, 7 },
	{ TYPE_BOOL, NULL, FALSE, 8 } };
#define PBLOCK_LENGTH	9

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,1),
	ParamVersionDesc(descVer1,4,2)
	};
#define NUM_OLDVERSIONS	2

// Current version
#define CURRENT_VERSION	3
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class TeapotTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		TeapotObject *so;

		TeapotTypeInDlgProc(TeapotObject *s) {so=s;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,
			WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

// This is the method called when the user clicks on the Create button
// in the Keyboard Entry rollup.  It was registered as the dialog proc
// for this button by the SetUserDlgProc() method called from 
// BeginEditParams().
BOOL TeapotTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,
			WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (so->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (so->TestAFlag(A_OBJ_CREATING)) {
						so->pblock->SetValue(PB_RADIUS,0,so->crtRadius);
						}

					Matrix3 tm(1);
					tm.SetTrans(so->crtPos);
					so->ip->NonMouseCreate(tm);
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Teapot methods -------------------------------

// Constructor
TeapotObject::TeapotObject()
{
	// Create the parameter block and make a reference to it.
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer2, PBLOCK_LENGTH, 
		CURRENT_VERSION));
	assert(pblock);

	// Initialize the default values.
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGS,0,dlgSegments);	
    pblock->SetValue(PB_TEAPART,	0,  crtTeapart);
    pblock->SetValue(PB_TEA_BODY,	0,  dlgBody);
    pblock->SetValue(PB_TEA_HANDLE,	0,  dlgHandle);
    pblock->SetValue(PB_TEA_SPOUT,	0,  dlgSpout);
    pblock->SetValue(PB_TEA_LID,	0,  dlgLid);
    pblock->SetValue(PB_GENUVS,		0,  dlgUVs);
}

// Called by MAX when the Teapot object is loaded from disk.
IOResult TeapotObject::Load(ILoad *iload) 
{	
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
}

// This method is called by the system when the user needs 
// to edit the objects parameters in the command panel.  
void TeapotObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	// We subclass off SimpleObject so we must call its
	// BeginEditParams() method first.
	SimpleObject::BeginEditParams(ip,flags,prev);
	// Save the interface pointer.
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Teapot ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			// Here we create each new rollup page in the command panel
			// using our descriptors.
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TEAPOTPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TEAPOTPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_TEAPOTPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		// This handles processing the Create button in the 
		// Keyboard Entry rollup page.
		pmapTypeIn->SetUserDlgProc(new TeapotTypeInDlgProc(this));
		}
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void TeapotObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		// Remove the rollup pages from the command panel.
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object 
	// created will inherit them.
	pblock->GetValue(PB_SEGS,		ip->GetTime(),dlgSegments,	FOREVER);
	pblock->GetValue(PB_SMOOTH,		ip->GetTime(),dlgSmooth,	FOREVER);	
    pblock->GetValue(PB_TEA_BODY,	ip->GetTime(),dlgBody,		FOREVER);
    pblock->GetValue(PB_TEA_HANDLE,	ip->GetTime(),dlgHandle,	FOREVER);
    pblock->GetValue(PB_TEA_SPOUT,	ip->GetTime(),dlgSpout,		FOREVER);
    pblock->GetValue(PB_TEA_LID,	ip->GetTime(),dlgLid,		FOREVER);
    pblock->GetValue(PB_GENUVS,		ip->GetTime(),dlgUVs,		FOREVER);
	}


static void blend_vector(Teapoint d0,Teapoint d1,Teapoint d2,Teapoint d3,
						 float t, Teapoint *result);

static int
GetShare(TeaShare shares[], int patch, int edge, int vert)
{
int *verts;
 
    switch (edge) {
    case 0:
        verts = shares[patch].left;
        break;
    case 1:
        verts = shares[patch].top;
        break;
    case 2:
        verts = shares[patch].right;
        break;
    case 3:
        verts = shares[patch].bottom;
        break;
    }
    return verts[vert];
}

static void
display_curve(int * patch_array, TeaShare shares[],
			  Teapoint d0, Teapoint d1, Teapoint d2, Teapoint d3, int steps,
			  Mesh& amesh, int *nvert, int patch, int row)
{
float    t,		/* t varies on 0.0 -> 1.0 */
         step;
int      i;
Teapoint temp;
TeaEdges *edge = &edges[patch];

    step = (float)1.0 / steps;
    t = step;

	if (row == 0) {
		switch (edge->first) {
		case GenAll:				// Generate all
		case GenSingularityBegin:	// in row 0 all these are the same
			/* the first point IS d0 so we don't need to calculate it */
			amesh.setVert(*nvert, d0.x, d0.y, d0.z);
			patch_array[row * (steps + 1)] = *nvert;
			(*nvert)++;

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}

			/* the last vertex IS d3 so we don't need to calculate it */
			amesh.setVert(*nvert, d3.x, d3.y, d3.z);
			patch_array[row * (steps + 1) + steps] = *nvert;
			(*nvert)++;
			break;
		case ShareBegin:
			patch_array[row * (steps + 1)] = GetShare(shares, edge->patch0, edge->edge0, steps);

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}

			/* the last vertex IS d3 so we don't need to calculate it */
			amesh.setVert(*nvert, d3.x, d3.y, d3.z);
			patch_array[row * (steps + 1) + steps] = *nvert;
			(*nvert)++;
			break;
		case ShareAll:  // This should never happen with the current data
			for (i = 0; i <= steps; i++)
				patch_array[row * (steps + 1) + i] = GetShare(shares, edge->patch0, edge->edge0, i);
			break;
		default:
			assert(0);
			break;
		}
	} else {
		EdgeType et;
		if (row < steps)
			et = edge->center;
		else
			et = edge->last;
		switch (et) {
		case GenAll:				// Generate all
			/* the first point IS d0 so we don't need to calculate it */
			amesh.setVert(*nvert, d0.x, d0.y, d0.z);
			patch_array[row * (steps + 1)] = *nvert;
			(*nvert)++;

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}

			/* the last vertex IS d3 so we don't need to calculate it */
			amesh.setVert(*nvert, d3.x, d3.y, d3.z);
			patch_array[row * (steps + 1) + steps] = *nvert;
			(*nvert)++;
			break;

		case GenSingularityBegin:	// generate all vertices except the first which
									// is a singularity from the first row
			patch_array[row * (steps + 1)] = patch_array[0];

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}

			/* the last vertex IS d3 so we don't need to calculate it */
			amesh.setVert(*nvert, d3.x, d3.y, d3.z);
			patch_array[row * (steps + 1) + steps] = *nvert;
			(*nvert)++;
			break;
		case ShareAll:			/* this should only happen as the last row */
			for (i = 0; i <= steps; i++)
				patch_array[row * (steps + 1) + i] = GetShare(shares, edge->patch2, edge->edge2, i);
			break;
		case ShareBegin:
			patch_array[row * (steps + 1)] = GetShare(shares, edge->patch3, edge->edge3, row);

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}

			/* the last vertex IS d3 so we don't need to calculate it */
			amesh.setVert(*nvert, d3.x, d3.y, d3.z);
			patch_array[row * (steps + 1) + steps] = *nvert;
			(*nvert)++;
			break;
		case ShareBeginSingularityEnd:
			patch_array[row * (steps + 1)] = GetShare(shares, edge->patch3, edge->edge3, row);

			/* no interior vertices are shared */
			for (i = 1; i < steps; i++) {
				blend_vector(d0, d1, d2, d3, t, &temp);
				amesh.setVert(*nvert, temp.x, temp.y, temp.z);
				patch_array[row * (steps + 1) + i] = *nvert;
				(*nvert)++;
				t += step;
			}
	
			patch_array[row * (steps + 1) + steps] = patch_array[steps];
			break;
		default:
			assert(0);
			break;
		}
	}
}


static void
blend_vector(Teapoint d0,Teapoint d1,Teapoint d2,Teapoint d3, float t,
 Teapoint *result)
{
    result->x = d0.x * (1.0f - t)*(1.0f - t)*(1.0f - t) +
                d1.x * 3.0f * t * (1.0f - t)*(1.0f - t) +
                d2.x * 3.0f * t*t          *(1.0f - t) +
                d3.x *        t*t*t;
    result->y = d0.y * (1.0f - t)*(1.0f - t)*(1.0f - t) +
                d1.y * 3.0f * t * (1.0f - t)*(1.0f - t) +
                d2.y * 3.0f * t*t           *(1.0f - t) +
                d3.y *        t*t*t;
    result->z = d0.z * (1.0f - t)*(1.0f - t)*(1.0f - t) +
                d1.z * 3.0f * t * (1.0f - t)*(1.0f - t) +
                d2.z * 3.0f * t*t           *(1.0f - t) +
                d3.z *        t*t*t;
}


static void
display_patch(TeaShare shares[], int patch, int steps, Mesh& amesh, int *nvert, int *nface,
			int smooth, int genUVs, int *uv_vert, int *uv_face)
{
	float    t,step;
	Teapoint    d0,d1,d2,d3;
	int start_vert, *patch_array;

	patch_array = (int *)malloc(sizeof(int) * (steps + 1) * (steps + 1));

    step = 1.0f / steps;
    t = 0.0f;
	start_vert = *nvert;

	for (int i = 0; i <= steps; i++) {
        blend_vector(verts[patches[patch][0][0]],
                     verts[patches[patch][0][1]],
                     verts[patches[patch][0][2]],
                     verts[patches[patch][0][3]],t,&d0);    
        blend_vector(verts[patches[patch][1][0]],
                     verts[patches[patch][1][1]],
                     verts[patches[patch][1][2]],
                     verts[patches[patch][1][3]],t,&d1);    
        blend_vector(verts[patches[patch][2][0]],
                     verts[patches[patch][2][1]],
                     verts[patches[patch][2][2]],
                     verts[patches[patch][2][3]],t,&d2);    
        blend_vector(verts[patches[patch][3][0]],
                     verts[patches[patch][3][1]],
                     verts[patches[patch][3][2]],
                     verts[patches[patch][3][3]],t,&d3);    
        display_curve(patch_array, shares, d0,d1,d2,d3,steps, amesh, nvert, patch, i);

        t += step;
    }

	/* now that we have generated all the vertices we can save the edges */
	for (i = 0; i <= steps; i++) {
		shares[patch].left[i] = patch_array[i];					/* "left" edge */
        shares[patch].top[i] = patch_array[i*(steps+1)+steps];	/* "top" edge */
		shares[patch].right[i] = patch_array[steps*(steps+1)+i];	/* "right" edge */
        shares[patch].bottom[i] = patch_array[i*(steps+1)];		/* "bottom" edge */
	}

	/* now it's time to add the faces */
	for (int x = 0; x < steps; x++) {
		for (int y = 0; y < steps; y++) {
			int va, vb, vc, vd;

			va = patch_array[x * (steps + 1) + y];
			vb = patch_array[(x+1) * (steps + 1) + y];

			vd = patch_array[x * (steps + 1) + (y+1)];
			vc = patch_array[(x+1) * (steps + 1) + (y+1)];

#ifdef NO_DEGENERATE_POLYS
            if (va != vb && va != vc && vc != vb) {
#endif                
                amesh.faces[*nface].setEdgeVisFlags(1, 1, 0);
                amesh.faces[*nface].setVerts(va, vb, vc);
                amesh.faces[*nface].setSmGroup(smooth);
                (*nface)++;
#ifdef NO_DEGENERATE_POLYS
			}
#endif

#ifdef NO_DEGENERATE_POLYS
            if (vc != vd && vc != va && va != vd) {
#endif
                amesh.faces[*nface].setEdgeVisFlags(1, 1, 0);
                amesh.faces[*nface].setVerts(vc, vd, va);
                amesh.faces[*nface].setSmGroup(smooth);
                (*nface)++;
#ifdef NO_DEGENERATE_POLYS
            }
#endif
		}
	}


	// Now the UVs
	if (genUVs) {
		int base_vert = *uv_vert;
		float u, v,
				bU = edges[patch].bU, eU = edges[patch].eU,
				bV = edges[patch].bV, eV = edges[patch].eV,
				dU = (eU - bU)/float(steps),
				dV = (eV - bV)/float(steps);
		u = bU;
		for (int x = 0; x <= steps; x++) {
			v = bV;
			for (int y = 0; y <= steps; y++) {
				amesh.setTVert((*uv_vert)++, u, v, 0.0f);
				v += dV;
			}
			u += dU;
		}
		int na, nb;
		for(int ix=0; ix<steps; ix++) {
			na = base_vert + (ix * (steps + 1));
			nb = base_vert + (ix + 1) * (steps + 1);

			for (int jx=0; jx<steps; jx++) {
                int vva = patch_array[ix * (steps + 1) + jx];
                int vvb = patch_array[(ix+1) * (steps + 1) + jx];
                
                int vvd = patch_array[ix * (steps + 1) + (jx+1)];
                int vvc = patch_array[(ix+1) * (steps + 1) + (jx+1)];
                
#ifdef NO_DEGENERATE_POLYS
                if (vva != vvb && vva != vvc && vvc != vvb)
#endif
                    amesh.tvFace[(*uv_face)++].setTVerts(na,nb,nb+1);
#ifdef NO_DEGENERATE_POLYS
                if (vvc != vvd && vvc != vva && vva != vvd)
#endif
                    amesh.tvFace[(*uv_face)++].setTVerts(nb+1,na+1,na);
				na++;
				nb++;
			}
		}
	}

	free(patch_array);
}


BOOL TeapotObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void TeapotObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}



// Builds the mesh representation for the Teapot based on the
// state of it's parameters at the time requested.
void TeapotObject::BuildMesh(TimeValue t)
{

	int segs, smooth,
		body, handle, spout, lid, genUVs,
		cverts = 0, nvert = 0,
		cfaces = 0, nface = 0,
		uv_verts = 0, nuv_vert = 0,
		uv_faces = 0, nuv_face = 0,
		index, i, oldpart;
	float radius;

	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	pblock->GetValue(PB_RADIUS,		t, radius, ivalid);
	pblock->GetValue(PB_SEGS,		t, segs, ivalid);
	pblock->GetValue(PB_SMOOTH,		t, smooth, ivalid);
	pblock->GetValue(PB_TEA_BODY,	t, body, ivalid);
	pblock->GetValue(PB_TEA_HANDLE,	t, handle, ivalid);
	pblock->GetValue(PB_TEA_SPOUT,	t, spout, ivalid);
	pblock->GetValue(PB_TEA_LID,	t, lid, ivalid);
	pblock->GetValue(PB_GENUVS,		t, genUVs, ivalid);
    pblock->GetValue(PB_TEAPART,    t, oldpart, ivalid);
    switch (oldpart) {
    case OLD_POT_BOTH:
        body = handle = spout = lid = 1;
        pblock->SetValue(PB_TEAPART,	t,  FIXED_OLD_VER);
        pblock->SetValue(PB_TEA_BODY,	t,  body);
        pblock->SetValue(PB_TEA_HANDLE,	t,  handle);
        pblock->SetValue(PB_TEA_SPOUT,	t,  spout);
        pblock->SetValue(PB_TEA_LID,	t,  lid);
        break;
    case OLD_POT_BODY:
        body = handle = spout = 1;
        lid = 0;
        pblock->SetValue(PB_TEAPART,	t,  FIXED_OLD_VER);
        pblock->SetValue(PB_TEA_BODY,	t,  body);
        pblock->SetValue(PB_TEA_HANDLE,	t,  handle);
        pblock->SetValue(PB_TEA_SPOUT,	t,  spout);
        pblock->SetValue(PB_TEA_LID,	t,  lid);
        break;
    case OLD_POT_LID:
        body = handle = spout = 0;
        lid = 1;
        pblock->SetValue(PB_TEAPART,	t,  FIXED_OLD_VER);
        pblock->SetValue(PB_TEA_BODY,	t,  body);
        pblock->SetValue(PB_TEA_HANDLE,	t,  handle);
        pblock->SetValue(PB_TEA_SPOUT,	t,  spout);
        pblock->SetValue(PB_TEA_LID,	t,  lid);
        break;
    case FIXED_OLD_VER:
        break;
    }

	LimitValue(segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(smooth, MIN_SMOOTH, MAX_SMOOTH);
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(body, 0, 1);
	LimitValue(handle, 0, 1);
	LimitValue(spout, 0, 1);
	LimitValue(lid, 0, 1);
	LimitValue(genUVs, 0, 1);
	
//	int *patch_array = (int *)malloc(sizeof(int) * (segs + 1) * (segs + 1));

	TeaShare shares[PATCH_COUNT]; /* make an array to hold sharing data */
	for (index = 0; index < PATCH_COUNT; index++) {
        shares[index].left =   (int *)malloc(sizeof(int) * (segs + 1));
        shares[index].top =    (int *)malloc(sizeof(int) * (segs + 1));
        shares[index].right =  (int *)malloc(sizeof(int) * (segs + 1));
        shares[index].bottom = (int *)malloc(sizeof(int) * (segs + 1));
	}

	if (body) {
		cverts += (segs - 1) * (segs - 1) * 16 +
					segs * 16 + (segs - 1) * 16 + 1;
#ifdef NO_DEGENERATE_POLYS
		cfaces += segs * segs * BODY_PATCHES * 2 - 4 * segs;
#else
		cfaces += segs * segs * BODY_PATCHES * 2;
#endif
		if (genUVs) {
			uv_verts += (segs + 1) * (segs + 1) * BODY_PATCHES;
#ifdef NO_DEGENERATE_POLYS
			uv_faces += segs * segs * BODY_PATCHES * 2 - 4 * segs;
#else
			uv_faces += segs * segs * BODY_PATCHES * 2;
#endif
		}
	}
	if (handle) {
		cverts += (segs + 1) * segs * 2 + segs * segs * 2;
		cfaces += segs * segs * HANDLE_PATCHES * 2;
			if (genUVs) {
			uv_verts += (segs + 1) * (segs + 1) * HANDLE_PATCHES;
			uv_faces += segs * segs * HANDLE_PATCHES * 2;
		}
	}
	if (spout) {
		cverts += (segs + 1) * segs * 2 + segs * segs * 2;
		cfaces += segs * segs * SPOUT_PATCHES * 2;
			if (genUVs) {
			uv_verts += (segs + 1) * (segs + 1) * SPOUT_PATCHES;
			uv_faces += segs * segs * SPOUT_PATCHES * 2;
		}
	}
	if (lid) {
		cverts += (segs - 1) * (segs - 1) * 8 +
					segs * 8 + (segs - 1) * 8 + 1;
#ifdef NO_DEGENERATE_POLYS
		cfaces += segs * segs * LID_PATCHES * 2 - 4 * segs;
#else
		cfaces += segs * segs * LID_PATCHES * 2;
#endif
			if (genUVs) {
			uv_verts += (segs + 1) * (segs + 1) * LID_PATCHES;
#ifdef NO_DEGENERATE_POLYS
			uv_faces += segs * segs * LID_PATCHES * 2 - 4 * segs;
#else
			uv_faces += segs * segs * LID_PATCHES * 2;
#endif
		}
	}

	mesh.setNumVerts(cverts);
	mesh.setNumFaces(cfaces);
	mesh.setSmoothFlags(smooth != 0);
	mesh.setNumTVerts(uv_verts);
	mesh.setNumTVFaces(uv_faces);

  	if (body) {
		for (index = FIRST_BODY_PATCH, i = 0; i < BODY_PATCHES; i++, index++)
			display_patch(shares, index, segs, mesh, &nvert, &nface, smooth, genUVs, &nuv_vert, &nuv_face);
	}
	if (handle) {
		for (index = FIRST_HANDLE_PATCH, i = 0; i < HANDLE_PATCHES; i++, index++)
			display_patch(shares, index, segs, mesh, &nvert, &nface, smooth, genUVs, &nuv_vert, &nuv_face);
	}
	if (spout) {
		for (index = FIRST_SPOUT_PATCH, i = 0; i < SPOUT_PATCHES; i++, index++)
			display_patch(shares, index, segs, mesh, &nvert, &nface, smooth, genUVs, &nuv_vert, &nuv_face);
	}
	if (lid) {
		for (index = FIRST_LID_PATCH, i = 0; i < LID_PATCHES; i++, index++)
			display_patch(shares, index, segs, mesh, &nvert, &nface, smooth, genUVs, &nuv_vert, &nuv_face);
	}

	/* scale about 0,0,0 by radius / 2 (the teapot is generated 2x) */
	for (int c = 0; c < mesh.getNumVerts(); c++) {
#ifdef CENTER_ZERO
		mesh.verts[c].z -= 1.2;
#endif
		mesh.verts[c].x *= (radius / (float)2.0);
		mesh.verts[c].y *= (radius / (float)2.0);
		mesh.verts[c].z *= (radius / (float)2.0);
	}

	/* Clean up */
	for (index = 0; index < PATCH_COUNT; index++) {
		free(shares[index].left);
		free(shares[index].top);
		free(shares[index].right);
		free(shares[index].bottom);
	}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
}

// Declare a class derived from CreateMouseCallBack to handle
// the user input during the creation phase of the Teapot.
class TeapotObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	TeapotObject *ob;
	Point3 p0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
			Matrix3& mat);
		void SetObj(TeapotObject *obj) {ob = obj;}
	};

// This is the method that actually handles the user input
// during the Teapot creation.
int TeapotObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, 
	int flags, IPoint2 m, Matrix3& mat ) {

	float r;
	Point3 p1,center;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

		if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {
					r = Length(p1-p0);
					mat.SetTrans(p0);
					}
				else {
					center = (p0+p1)/float(2);
					mat.SetTrans(center);
					r = Length(center-p0);
					} 
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {										
					return (Length(m-sp0)<3 || Length(p1-p0)<0.1f)?CREATE_ABORT:CREATE_STOP;
					}
				break;					   
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}

// A single instance of the callback object.
static TeapotObjCreateCallBack teapotCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack* TeapotObject::GetCreateMouseCallBack() 
	{
	teapotCreateCB.SetObj(this);
	return(&teapotCreateCB);
	}


// Return TRUE if it is OK to display the mesh at the time requested,
// return FALSE otherwise.
BOOL TeapotObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}

// From ParamArray
// These methods allow the parameter map to access our class variables.
// Based on the virtual array index passed in we set or get the 
// variable requested.
BOOL TeapotObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL TeapotObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		}	
	return TRUE;
	}

BOOL TeapotObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL TeapotObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL TeapotObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		}
	return TRUE;
	}

BOOL TeapotObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


// From GeomObject
int TeapotObject::IntersectRay(
		TimeValue t, Ray& ray, float& at, Point3& norm)
	{
	int smooth;
	pblock->GetValue(PB_SMOOTH,t,smooth,FOREVER);
	if (!smooth) {
		return SimpleObject::IntersectRay(t,ray,at,norm);
		}	
	
	BuildMesh(t);

	return mesh.IntersectRay(ray, at, norm);
	}

// This method is called when the user interface controls need to be
// updated to reflect new values because of the user moving the time
// slider.  Here we simply call a method of the parameter map to 
// handle this for us.
void TeapotObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

// This method returns the dimension of the parameter requested.
// This dimension describes the type and magnitude of the value
// stored by the parameter.
ParamDimension *TeapotObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return stdWorldDim;			
		case PB_SEGS:
			return stdSegmentsDim;			
		case PB_SMOOTH:
		case PB_TEA_BODY:
		case PB_TEA_HANDLE:
		case PB_TEA_SPOUT:
		case PB_TEA_LID:
		case PB_GENUVS:
			return stdNormalizedDim;			
		default:
			return defaultDim;
		}
	}

// This method returns the name of the parameter requested.
TSTR TeapotObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:
			return GetString(IDS_RB_RADIUS);
		case PB_SEGS:
			return GetString(IDS_RB_SEGMENTS);
		case PB_SMOOTH:
			return GetString(IDS_RB_SMOOTH);
		case PB_TEA_BODY:
			return GetString(IDS_RB_BODY);
		case PB_TEA_HANDLE:
			return GetString(IDS_RB_HANDLE);
		case PB_TEA_SPOUT:
			return GetString(IDS_RB_SPOUT);
		case PB_TEA_LID:
			return GetString(IDS_RB_LID);
		case PB_GENUVS:
			return GetString(IDS_RB_GENTEXCOORDS);
		default:
			return TSTR(_T(""));
		}
	}

// Make a copy of the Teapot object parameter block.
RefTargetHandle TeapotObject::Clone(RemapDir& remap) 
	{
	TeapotObject* newob = new TeapotObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}


static int
isCorner(int x, int y)
{
    if ((x == 0 && y == 0) ||
        (x == 3 && y == 3) ||
        (x == 0 && y == 3) ||
        (x == 3 && y == 0))
        return TRUE;
    return FALSE;
}

static void
setVV(PatchMesh &patch, int patch_array[4][4], int p, int x, int y, float radius,
      int *ix, int *jx)
{
 	Point3 pnt;
 		
    pnt.x = verts[patches[p][x][y]].x * radius;
    pnt.y = verts[patches[p][x][y]].y * radius;
    pnt.z = verts[patches[p][x][y]].z * radius;
    if (isCorner(x, y)) {
        patch_array[x][y] = *ix; // save it
        patch.setVert((*ix)++, pnt);
    } else {
        patch_array[x][y] = *jx; // save it
        patch.setVec((*jx)++, pnt);
    }
}

static void
BuildTeapotPart(int base_patch, int num_patchs, PatchMesh &patch, int *in_ix, int *in_jx,
        int *in_patch, float radius, TeaShare shares[], int genUVs)
{
    int ix = *in_ix,
        jx = *in_jx,
        bpatch = *in_patch;

    for (int i = 0; i < num_patchs; i++) {
        int x, y;
        int p = base_patch + i;
	 	int bvert = ix, bvec = jx;
    	int patch_array[4][4];
		if (genUVs) {
			int tv = (bpatch+i) * 4;
			patch.setTVert(tv+0, UVVert(edges[p].eU, edges[p].bV, 0.0f));
			patch.setTVert(tv+1, UVVert(edges[p].eU, edges[p].eV, 0.0f));
			patch.setTVert(tv+2, UVVert(edges[p].bU, edges[p].eV, 0.0f));
			patch.setTVert(tv+3, UVVert(edges[p].bU, edges[p].bV, 0.0f));
			patch.getTVPatch(bpatch+i).setTVerts(tv+3,tv+0,tv+1,tv+2);
		}

        for (x = 0; x < 4; x++) {
            for (y = 0; y < 4; y++) {
                switch((y == 0 ? edges[p].first : (y == 3 ? edges[p].last : edges[p].center))) {
                case GenAll:
                    setVV(patch, patch_array, p, x, y, radius, &ix, &jx);
                    break;
                case GenSingularityBegin:
                    if (x == 0 && y >= 1) { // the first point is common (must gen. 1st tangent)
                        if (y == 3) { // corner
							patch_array[x][y] = patch_array[0][0];
						} else { // tangent
							if (y == 1) {
#if 0
								if (edges[p].first == ShareAll)
									patch_array[x][y] = GetShare(shares, p-1, 3, y);
								else
#endif
									setVV(patch, patch_array, p, x, y, radius, &ix, &jx);
							} else
								patch_array[x][y] = patch_array[0][1];
						}
                    } else {
                        setVV(patch, patch_array, p, x, y, radius, &ix, &jx);
					}
                    break;
                case ShareBeginSingularityEnd:
                    if (x == 0) {
                        patch_array[x][y] = GetShare(shares, edges[p].patch3, edges[p].edge3, y);
                    } else if (x == 3 && y > 1) {
                        if (y == 3)
							patch_array[x][y] = patch_array[3][0]; // corner
						else
							patch_array[x][y] = patch_array[3][1]; // tangent
                    } else {
                        setVV(patch, patch_array, p, x, y, radius, &ix, &jx);
					}
                    break;
                case ShareBegin:
                    if (x == 0) {
                        patch_array[x][y] = GetShare(shares, edges[p].patch3, edges[p].edge3, y);
                    } else {
                        setVV(patch, patch_array, p, x, y, radius, &ix, &jx);
                    }
                    break;
                case ShareAll: // this seems to work look CAREFULLY before changing
                    if (y == 0)
                        patch_array[x][y] = GetShare(shares, edges[p].patch0, edges[p].edge0, x);
                    else
                        patch_array[x][y] = GetShare(shares, edges[p].patch2, edges[p].edge2, x);
                    break;
                default:
                    assert(0); // we should never get here
                }
            }
        }

		/* now that we have generated all the vertices we can save the edges */
		for (int j = 0; j <  4; j++) {
			shares[p].left[j] =   patch_array[j][0];
			shares[p].top[j] =    patch_array[3][j];
			shares[p].right[j] =  patch_array[j][3];
			shares[p].bottom[j] = patch_array[0][j];
		}

		// Build the patches
		patch.patches[bpatch + i].SetType(PATCH_QUAD);
		patch.patches[bpatch + i].setVerts(patch_array[0][0],
                                           patch_array[0][3],
                                           patch_array[3][3],
                                           patch_array[3][0]);
		patch.patches[bpatch + i].setVecs(patch_array[0][1], patch_array[0][2],
                                          patch_array[1][3], patch_array[2][3],
                                          patch_array[3][2], patch_array[3][1],
                                          patch_array[2][0], patch_array[1][0]);
		patch.patches[bpatch + i].setInteriors(patch_array[1][1],
                                               patch_array[1][2],
                                               patch_array[2][2],
                                               patch_array[2][1]);
		patch.patches[bpatch + i].smGroup = 1;
		patch.patches[bpatch + i].SetAuto(FALSE);
    }

    *in_ix = ix;
    *in_jx = jx;
    *in_patch += num_patchs;
}
 
void BuildTeapotPatch(PatchMesh &patch, float radius,
		            int body, int handle, int spout, int lid, int genUVs)
{
	int nverts = 0;
	int nvecs = 0;
	int npatches = 0;
	int ntvpatches = 0;
	int ntvverts = 0;
    int bpatch = 0;
	int ix = 0;
    int jx = 0;

	if (body) {
        nverts += 17;
        nvecs += 132;
		ntvverts += 64;
        npatches += BODY_PATCHES;
		ntvpatches += BODY_PATCHES;
	}
	if (handle) {
        nverts += 6;
        nvecs += 36;
		ntvverts += 16;
        npatches += HANDLE_PATCHES;
		ntvpatches += HANDLE_PATCHES;
	}
	if (spout) {
        nverts += 6;
        nvecs += 36;
		ntvverts += 16;
        npatches += SPOUT_PATCHES;
		ntvpatches += SPOUT_PATCHES;
	}
	if (lid) {
        nverts += 9;
        nvecs += 68;
		ntvverts += 32;
        npatches += LID_PATCHES;
		ntvpatches += LID_PATCHES;
	}

	patch.setNumVerts(nverts);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);
	patch.setNumTVerts(genUVs ? ntvverts : 0);
	patch.setNumTVPatches(genUVs ? ntvpatches : 0);

	TeaShare shares[PATCH_COUNT]; /* make an array to hold sharing data */
    for (int c = 0; c < PATCH_COUNT; c++) {
        shares[c].left =   (int *)malloc(4 * sizeof(int));
        shares[c].top =    (int *)malloc(4 * sizeof(int));
        shares[c].right =  (int *)malloc(4 * sizeof(int));
        shares[c].bottom = (int *)malloc(4 * sizeof(int));
    }

	if (body)
        BuildTeapotPart(FIRST_BODY_PATCH, BODY_PATCHES, patch, &ix, &jx,
			&bpatch, radius/2.0f, shares, genUVs);
 	if (handle)
        BuildTeapotPart(FIRST_HANDLE_PATCH, HANDLE_PATCHES, patch, &ix, &jx,
			&bpatch, radius/2.0f, shares, genUVs);
	if (spout)
        BuildTeapotPart(FIRST_SPOUT_PATCH, SPOUT_PATCHES, patch, &ix, &jx,
			&bpatch, radius/2.0f, shares, genUVs);
	if (lid)
        BuildTeapotPart(FIRST_LID_PATCH, LID_PATCHES, patch, &ix, &jx,
			&bpatch, radius/2.0f, shares, genUVs);

	for (c = 0; c < PATCH_COUNT; c++) {
		free(shares[c].left);
		free(shares[c].top);
		free(shares[c].right);
		free(shares[c].bottom);
	}

    assert(patch.buildLinkages());
	patch.InvalidateGeomCache();
}


Point3 Tbody[] = {	Point3(0.0,    0.0, 0.0),
					Point3(0.4000, 0.0, 0.0),
					Point3(0.6600, 0.0, 0.0155),
					Point3(0.7620, 0.0, 0.0544),
					Point3(0.7445, 0.0, 0.0832),
					Point3(0.8067, 0.0, 0.1225),
					Point3(1.0186, 0.0, 0.3000),
					Point3(1.0153, 0.0, 0.6665),
					Point3(0.7986, 0.0, 1.120),
					Point3(0.7564, 0.0, 1.210),
					Point3(0.7253, 0.0, 1.265),
					Point3(0.6788, 0.0, 1.264),
					Point3(0.7056, 0.0, 1.200)};

Point3 Tlid[] = {	Point3(0.0,    0.0, 1.575),
					Point3(0.1882, 0.0, 1.575),
					Point3(0.1907, 0.0, 1.506),
					Point3(0.1443, 0.0, 1.473),
					Point3(0.0756, 0.0, 1.390),
					Point3(0.0723, 0.0, 1.336),
					Point3(0.3287, 0.0, 1.283),
					Point3(0.6531, 0.0, 1.243),
					Point3(0.6500, 0.0, 1.200)};

#ifndef NO_NURBS

void
BuildNURBSBody(NURBSSet& nset, float radius, int genUVs)
{
	Point3 scale(radius, radius, radius);

	double knots[] = {	0.0, 0.0, 0.0, 0.0,
						0.1, 0.2, 0.3, 0.4,
						0.5, 0.6, 0.7, 0.8, 0.9,
						1.0, 1.0, 1.0, 1.0};

	NURBSCVCurve *c = new NURBSCVCurve();
	c->SetOrder(4);
	c->SetNumKnots(17);
	c->SetNumCVs(13);
	for (int k = 0; k < 17; k++)
		c->SetKnot(k, knots[k]);
	for (int i = 0; i < 13; i++) {
		NURBSControlVertex ncv;
		ncv.SetPosition(0, Tbody[i] * ScaleMatrix(scale));
		ncv.SetWeight(0, 1.0f);
		c->SetCV(i, ncv);
	}
	c->SetNSet(&nset);
	int p1 = nset.AppendObject(c);

	NURBSLatheSurface *s = new NURBSLatheSurface();

	s->SetParent(p1);
	Matrix3 mat = TransMatrix(Point3(0, 0, 0));
	s->SetAxis(0, mat);
    s->SetName(GetString(IDS_RB_TEAPOT));
    s->FlipNormals(FALSE);
	s->SetGenerateUVs(genUVs);
	s->Renderable(TRUE);
	s->SetTextureUVs(0, 0, Point2(0.0, 0.0));
	s->SetTextureUVs(0, 1, Point2(0.0, 2.0));
	s->SetTextureUVs(0, 2, Point2(4.0, 0.0));
	s->SetTextureUVs(0, 3, Point2(4.0, 2.0));
	s->SetNSet(&nset);
	nset.AppendObject(s);
}


void
BuildNURBSLid(NURBSSet& nset, float radius, int genUVs)
{
	Point3 scale(radius, radius, radius);
	double knots[] = {	0.0, 0.0, 0.0, 0.0,
						1.0/6.0, 1.0/3.0, 0.5,
						2.0/3.0, 5.0/6.0,
						1.0, 1.0, 1.0, 1.0};
	NURBSCVCurve *c = new NURBSCVCurve();
	c->SetOrder(4);
	c->SetNumKnots(13);
	c->SetNumCVs(9);
	for (int k = 0; k < 13; k++)
		c->SetKnot(k, knots[k]);
	for (int i = 0; i < 9; i++) {
		NURBSControlVertex ncv;
		ncv.SetPosition(0, Tlid[i] * ScaleMatrix(scale));
		ncv.SetWeight(0, 1.0f);
		c->SetCV(i, ncv);
	}
	c->SetNSet(&nset);
	int p1 = nset.AppendObject(c);

	NURBSLatheSurface *s = new NURBSLatheSurface();
	Matrix3 mat = TransMatrix(Point3(0, 0, 0));
	s->SetAxis(0, mat);
	s->SetParent(p1);
    s->SetName(GetString(IDS_RB_TEAPOT));
    s->FlipNormals(TRUE);
	s->SetGenerateUVs(genUVs);
	s->Renderable(TRUE);
	s->SetTextureUVs(0, 0, Point2(0.0, 2.0));
	s->SetTextureUVs(0, 1, Point2(0.0, 0.0));
	s->SetTextureUVs(0, 2, Point2(2.0, 2.0));
	s->SetTextureUVs(0, 3, Point2(2.0, 0.0));
	nset.AppendObject(s);
}

#define F(s1, s2, s1r, s1c, s2r, s2c) \
	fuse.mSurf1 = (s1); \
	fuse.mSurf2 = (s2); \
	fuse.mRow1 = (s1r); \
	fuse.mCol1 = (s1c); \
	fuse.mRow2 = (s2r); \
	fuse.mCol2 = (s2c); \
	nset.mSurfFuse.Append(1, &fuse);

void
BuildNURBSPart(NURBSSet& nset, int firstPatch, int numPatches, int *bpatch, float radius, int genUVs)
{
	Point3 scale(radius, radius, radius);

	for (int face = 0; face < numPatches; face++) {
		NURBSCVSurface *s = new NURBSCVSurface();
		nset.AppendObject(s);
		int bp = *bpatch + face;

		s->SetUOrder(4);
		s->SetVOrder(4);
		s->SetNumUKnots(8);
		s->SetNumVKnots(8);
		for (int i = 0; i < 4; i++) {
			s->SetUKnot(i, 0.0);
			s->SetUKnot(i+4, 1.0);
			s->SetVKnot(i, 0.0);
			s->SetVKnot(i+4, 1.0);
		}
		s->SetNumCVs(4, 4);
		s->FlipNormals(TRUE);

		int pnum = firstPatch + face;
		for (int r = 0; r < 4; r++) {
			for (int c = 0; c < 4; c++) {
				Teapoint *tp = &verts[patches[pnum][r][c]];
				NURBSControlVertex ncv;
				ncv.SetPosition(0, Point3(tp->x, tp->y, tp->z) * ScaleMatrix(scale));
				ncv.SetWeight(0, 1.0f);
				s->SetCV(r, c, ncv);
			}
		}

		s->SetGenerateUVs(genUVs);

		s->SetTextureUVs(0, 0, Point2(edges[pnum].bU, edges[pnum].bV));
		s->SetTextureUVs(0, 1, Point2(edges[pnum].bU, edges[pnum].eV));
		s->SetTextureUVs(0, 2, Point2(edges[pnum].eU, edges[pnum].bV));
		s->SetTextureUVs(0, 3, Point2(edges[pnum].eU, edges[pnum].eV));
	}

	// Now for fusing
	NURBSFuseSurfaceCV fuse;
	int s = *bpatch;
	// fuse the seams
	for (int u = 0; u < ((NURBSCVSurface*)nset.GetNURBSObject(s))->GetNumUCVs(); u++) {
		F(s,   s+1, u, 0, u, ((NURBSCVSurface*)nset.GetNURBSObject(s+1))->GetNumVCVs()-1);
		F(s+1, s,   u, 0, u, ((NURBSCVSurface*)nset.GetNURBSObject(s  ))->GetNumVCVs()-1);
		F(s+2, s+3, u, 0, u, ((NURBSCVSurface*)nset.GetNURBSObject(s+3))->GetNumVCVs()-1);
		F(s+3, s+2, u, 0, u, ((NURBSCVSurface*)nset.GetNURBSObject(s+2))->GetNumVCVs()-1);
	}

	// fuse the middles
	for (int v = 1; v < ((NURBSCVSurface*)nset.GetNURBSObject(s))->GetNumVCVs(); v++) {
		F(s,   s+2, ((NURBSCVSurface*)nset.GetNURBSObject(s  ))->GetNumUCVs()-1, v, 0, v);
		F(s+1, s+3, ((NURBSCVSurface*)nset.GetNURBSObject(s+1))->GetNumUCVs()-1, v, 0, v);
	}


	*bpatch += numPatches;
}

Object* BuildNURBSTeapot(float radius, int body, int handle, int spout, int lid, int genUVs)
{
	int numpat = 0;

	if (body)
		numpat += 1;
	if (handle)
		numpat += HANDLE_PATCHES;
	if (spout)
		numpat += SPOUT_PATCHES;
	if (lid)
		numpat += 1;

	NURBSSet nset;
	
	int bpatch = 0;

 	if (handle)
        BuildNURBSPart(nset, FIRST_HANDLE_PATCH, HANDLE_PATCHES, &bpatch, radius/2.0f, genUVs);
	if (spout)
        BuildNURBSPart(nset, FIRST_SPOUT_PATCH, SPOUT_PATCHES, &bpatch, radius/2.0f, genUVs);
	if (body)
        BuildNURBSBody(nset, radius, genUVs);
	if (lid)
        BuildNURBSLid(nset, radius, genUVs);

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

#endif

Object* TeapotObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius;
		int body, handle, spout, lid, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_TEA_BODY,t,body,valid);	
		pblock->GetValue(PB_TEA_HANDLE,t,handle,valid);	
		pblock->GetValue(PB_TEA_SPOUT,t,spout,valid);	
		pblock->GetValue(PB_TEA_LID,t,lid,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);	
		PatchObject *ob = new PatchObject();
		BuildTeapotPatch(ob->patch,radius, body, handle, spout, lid, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->SetChannelValidity(TEXMAP_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 

#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius;
		int body, handle, spout, lid, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius,valid);
		pblock->GetValue(PB_TEA_BODY,t,body,valid);	
		pblock->GetValue(PB_TEA_HANDLE,t,handle,valid);	
		pblock->GetValue(PB_TEA_SPOUT,t,spout,valid);	
		pblock->GetValue(PB_TEA_LID,t,lid,valid);	
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);	
		Object *ob = BuildNURBSTeapot(radius, body, handle, spout, lid, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->SetChannelValidity(TEXMAP_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	}
#endif
    return SimpleObject::ConvertToType(t,obtype);
	}

int TeapotObject::CanConvertToType(Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype==patchObjectClassID) {
		return 1;
#else
	if (obtype==patchObjectClassID || obtype==EDITABLE_SURF_CLASS_ID) {
		return 1;
#endif
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

void TeapotObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}

// See the Advanced Topics section on DLL Functions and Class Descriptors
// for more information.
/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class TeapotClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 1; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) { return new TeapotObject; }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return GetString(IDS_RB_TEAPOT_CLASS); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return Class_ID(TEAPOT_CLASS_ID1,TEAPOT_CLASS_ID2); }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
	
	void ResetClassParams(BOOL fileReset);
	};

// Declare a static instance of the class descriptor.
static TeapotClassDesc teapotDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetTeapotDesc() { return &teapotDesc; }

// Initialize the class vars
int TeapotObject::dlgSegments       = DEF_SEGMENTS;
int TeapotObject::dlgCreateMeth     = 1; // create_radius
int TeapotObject::dlgSmooth         = SMOOTH_ON;
IParamMap *TeapotObject::pmapCreate = NULL;
IParamMap *TeapotObject::pmapParam  = NULL;
IParamMap *TeapotObject::pmapTypeIn = NULL;
IObjParam *TeapotObject::ip         = NULL;
Point3 TeapotObject::crtPos         = Point3(0,0,0);
float TeapotObject::crtRadius       = 0.0f;
int TeapotObject::crtTeapart        = FIXED_OLD_VER;
int TeapotObject::dlgBody			= POT_BODY;
int TeapotObject::dlgHandle			= POT_HANDLE;
int TeapotObject::dlgSpout			= POT_SPOUT;
int TeapotObject::dlgLid			= POT_LID;
int TeapotObject::dlgUVs			= POT_UVS;

void TeapotClassDesc::ResetClassParams(BOOL fileReset)
	{
	TeapotObject::dlgSegments       = DEF_SEGMENTS;
	TeapotObject::dlgCreateMeth     = 1; // create_radius
	TeapotObject::dlgSmooth         = SMOOTH_ON;
	TeapotObject::crtPos            = Point3(0,0,0);
	TeapotObject::crtRadius         = 0.0f;
	TeapotObject::crtTeapart        = FIXED_OLD_VER;
	TeapotObject::dlgBody			= POT_BODY;
	TeapotObject::dlgHandle			= POT_HANDLE;
	TeapotObject::dlgSpout			= POT_SPOUT;
	TeapotObject::dlgLid			= POT_LID;
	TeapotObject::dlgUVs			= POT_UVS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\gridhelp.h ===
/**********************************************************************
 *<
	FILE: gridhelp.h

	DESCRIPTION:  Defines a Grid Helper Object Class

	CREATED BY: Tom Hudson

	HISTORY: created 31 January 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __GRIDHELP__H__ 

#define __GRIDHELP__H__

#include "iparamm.h"

#ifndef MAX_FLOAT
#define MAX_FLOAT ((float)1.0e20)
#endif

class GridHelpObjCreateCallBack;
class VIZGridHelpObjCreateCallback;

#define BMIN_LENGTH		float(0)
#define BMAX_LENGTH		MAX_FLOAT
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		MAX_FLOAT
#define BMIN_GRID		float(0)
#define BMAX_GRID		MAX_FLOAT

#define BDEF_DIM		float(0)

#define GRID_COLOR_GRAY		0
#define GRID_COLOR_OBJECT	1
#define GRID_COLOR_HOME		2
#define GRID_COLOR_HOME_INT	3
#define GRID_MAX_COLORS		4


class GridHelpObject: public ConstObject, public IParamArray {			   
	public:
		// Object parameters		
		IParamBlock *pblock;
		int gridColor;
		int constPlane;

		// Offset
		Matrix3	myTM;

		Interval ivalid;

		// Class vars
		static GridHelpObject *editOb;
		static IParamMap *pmapParam;
		static IObjParam *iObjParams;
		static int dlgGridColor;
		
	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
		void BuildMesh(TimeValue t,Mesh& amesh);
		void UpdateMesh(TimeValue t);
		void UpdateUI(TimeValue t);
		void GetBBox(TimeValue t, Matrix3 &tm, Box3& box);
		int Select(TimeValue t, INode *inode, GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit );
		void FixConstructionTM(Matrix3 &tm, ViewExp *vpt);

		GridHelpObject();
		~GridHelpObject();

		void SetGrid( TimeValue t,float grid );
		float GetGrid( TimeValue t, Interval& valid = Interval(0,0) );

		void SetColor(int c);
		int GetColor(void)	{ return gridColor; }
		
		void InvalidateGrid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:

		// From ConstObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = TSTR(GetString(IDS_DB_GRID_NODENAME)); }
		int UsesWireColor() { return 1; }
		ObjectHandle ApplyTransform(Matrix3& matrix);
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);

		// From HelperObject
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

		// From ConstObject
		void GetConstructionTM( TimeValue t, INode* inode, ViewExp *vpt, Matrix3 &tm );	// Get the transform for this view
		void SetConstructionPlane(int p, BOOL notify=TRUE);
		int  GetConstructionPlane(void)			{ return constPlane; }
		Point3 GetSnaps( TimeValue t );		// Get snaps
		void SetSnaps(TimeValue t, Point3 p);
		Point3 GetExtents(TimeValue t);
		void SetExtents(TimeValue t, Point3 p);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(GRIDHELP_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_GRIDHELPER)); }
		int IsKeyable(){ return 1;}
		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);		

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }
	};				

// Here's an alternative construction grid to be used by VIZ
class VIZGridHelpObject: public ConstObject, public IParamArray {
	//factory method
	static VIZGridHelpObject* CreateImplicitGridObject();
private:
	bool m_implicit;
	public:
		// Object parameters		
		IParamBlock *pblock;
		int gridColor;
		int constPlane;

		// Offset
		Matrix3	myTM;

		Interval ivalid;

		// Class vars
		static VIZGridHelpObject *editOb;
		static IParamMap *pmapParam;
		static IObjParam *iObjParams;
		static int dlgGridColor;
		
	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
		void BuildMesh(TimeValue t,Mesh& amesh);
		void UpdateMesh(TimeValue t);
		void UpdateUI(TimeValue t);
		void GetBBox(TimeValue t, Matrix3 &tm, Box3& box);
		int Select(TimeValue t, INode *inode, GraphicsWindow *gw, Material *ma, HitRegion *hr, int abortOnHit );
		void FixConstructionTM(Matrix3 &tm, ViewExp *vpt);

		VIZGridHelpObject();
		~VIZGridHelpObject();

		void SetGrid( TimeValue t,float grid );
		float GetGrid( TimeValue t, Interval& valid = Interval(0,0) );

		void SetColor(int c);
		int GetColor(void)	{ return gridColor; }
		
		void InvalidateGrid() { ivalid.SetEmpty(); }

		//  inherited virtual methods:

		// From ConstObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = TSTR(GetString(IDS_DB_GRID_NODENAME)); }
		int UsesWireColor() { return 1; }
		ObjectHandle ApplyTransform(Matrix3& matrix);
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);

		// From HelperObject
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

		// From ConstObject
		void GetConstructionTM( TimeValue t, INode* inode, ViewExp *vpt, Matrix3 &tm );	// Get the transform for this view
		void SetConstructionPlane(int p, BOOL notify=TRUE);
		int  GetConstructionPlane(void)			{ return constPlane; }
		Point3 GetSnaps( TimeValue t );		// Get snaps
		void SetSnaps(TimeValue t, Point3 p);
		Point3 GetExtents(TimeValue t);
		void SetExtents(TimeValue t, Point3 p);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(GRIDHELP_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_GRIDHELPER)); }
		int IsKeyable(){ return 1;}
		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);		

		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);

		void InvalidateUI() { if (pmapParam) pmapParam->Invalidate(); }


	};				

#endif // __GRIDHELP__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\gridhelp.cpp ===
/**********************************************************************
 *<
	FILE: gridhelp.cpp

	DESCRIPTION:  A grid helper implementation

	CREATED BY: Tom Hudson (based on Dan Silva's Object implementations)

	HISTORY: created 31 January 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "helpers.h"
#include "gridhelp.h"

// Parameter block indices
#define PB_LENGTH		0
#define PB_WIDTH		1
#define PB_GRID			2

#define PBLOCK_LENGTH 3

//------------------------------------------------------

class GridHelpObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GridHelpObject; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_GRID_CLASS); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(GRIDHELP_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};

static GridHelpObjClassDesc gridHelpObjDesc;

ClassDesc* GetGridHelpDesc() { return &gridHelpObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for grid class.
GridHelpObject *GridHelpObject::editOb = NULL;
IParamMap *GridHelpObject::pmapParam = NULL;
IObjParam *GridHelpObject::iObjParams = NULL;
int GridHelpObject::dlgGridColor = GRID_COLOR_GRAY;

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	
	
	// Grid
	ParamUIDesc(
		PB_GRID,
		EDITTYPE_UNIVERSE,
		IDC_GRID,IDC_GRIDSPINNER,
		BMIN_GRID,BMAX_GRID,
		SPIN_AUTOSCALE),	
	
	};
#define PARAMDESC_LENGTH 3

int MaxCoord(Point3 p)
{
	int best = 0;
	if(fabs(p.x)<fabs(p.y))
		best = 1;
	switch(best)
	{
	case 0:
		if(fabs(p.x)<fabs(p.z))
			best = 2;
		break;
	case 1:
		if(fabs(p.y)<fabs(p.z))
			best = 2;
		break;
	}
	return best;
}

int MostOrthogonalPlane( Matrix3& tmConst, ViewExp *vpt)
{
	int plane =  GRID_PLANE_TOP;

	Matrix3 tm,tmv, itmv;
	vpt->GetAffineTM(tm );  
	tmv = tmConst*tm;   // CP to view transform.
	itmv = Inverse(tmv);
	Point3 viewz = itmv.GetRow(2);
	switch(MaxCoord(viewz))
	{
		bool dir;
	case 0:
		dir = viewz.x>0.0f;
		plane = dir?GRID_PLANE_LEFT:GRID_PLANE_RIGHT;
		break;
	case 1:
		dir = viewz.y>0.0f;
		plane = dir?GRID_PLANE_BACK:GRID_PLANE_FRONT;
		break;
	case 2:
		dir = viewz.z<0.0f;
		plane = dir?GRID_PLANE_BOTTOM:GRID_PLANE_TOP;
		break;
	}

	return plane;
}

void GridHelpObject::FixConstructionTM(Matrix3 &tm, ViewExp *vpt)
{
	int plane = GRID_PLANE_TOP;

	if(vpt->GetGridType() < 0)
	{//JH 10/03/98 extending this to fix the construction plane to the most orthogonal plane
		//when the view is orthographic
#ifdef DESIGN_VER //JH 2/19/99 Removing this for shiva
		if( !(vpt->IsPerspView() || vpt->GetViewCamera() || (vpt->GetViewType() == VIEW_ISO_USER)))
		{
			plane = MostOrthogonalPlane(tm, vpt);
		}
		else
#endif
			plane = constPlane; //Original behavior for all non-grid views
	}
	else
		plane = vpt->GetGridType();

	if(plane == GRID_PLANE_BOTTOM)
		tm.PreRotateX(3.1415926f);	
	else if(plane == GRID_PLANE_RIGHT)
		tm.PreRotateY(3.1415926f/2.0f);
	else if(plane == GRID_PLANE_LEFT)
		tm.PreRotateY(-3.1415926f/2.0f);
	else if(plane == GRID_PLANE_FRONT)
		tm.PreRotateX(3.1415926f/2.0f);
	else if(plane == GRID_PLANE_BACK)
		tm.PreRotateX(-3.1415926f/2.0f);
}

class GridDlgProc : public ParamMapUserDlgProc {
	public:
		GridHelpObject *go;
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetObject(GridHelpObject *ob) { go = ob; }
		void DeleteThis() {}
	};

BOOL GridDlgProc::DlgProc( TimeValue t, IParamMap *map, HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	switch ( message ) {
		case WM_INITDIALOG:
			CheckRadioButton(hDlg, IDC_GRID_GRAY_COLOR, IDC_GRID_HOME_INTENSITY, IDC_GRID_GRAY_COLOR+go->GetColor());
			CheckRadioButton(hDlg, IDC_GRID_XY_PLANE, IDC_GRID_ZX_PLANE, IDC_GRID_XY_PLANE+go->GetConstructionPlane() % 3);
			return FALSE;			

		case WM_COMMAND:			
			switch( LOWORD(wParam) ) {
				case IDC_GRID_GRAY_COLOR:
				case IDC_GRID_OBJECT_COLOR:
				case IDC_GRID_HOME_COLOR:
				case IDC_GRID_HOME_INTENSITY:
					go->SetColor(LOWORD(wParam) - IDC_GRID_GRAY_COLOR);
					go->iObjParams->RedrawViews(t,REDRAW_END);
					break;
				case IDC_GRID_XY_PLANE:
				case IDC_GRID_YZ_PLANE:
				case IDC_GRID_ZX_PLANE:
					go->SetConstructionPlane(LOWORD(wParam) - IDC_GRID_XY_PLANE);
					go->iObjParams->RedrawViews(t,REDRAW_END);
					break;
				}
			return FALSE;
		default:
			return FALSE;
		}
	}

GridDlgProc theGridProc;

void GridHelpObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	editOb = this;
	iObjParams = ip;
	if (pmapParam) {
		// Left over from last one created
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_GRIDPARAM),
			GetString(IDS_DB_PARAMETERS),
			0);
		}
	theGridProc.SetObject(this);
	pmapParam->SetUserDlgProc(&theGridProc);
	}
		
void GridHelpObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	editOb = NULL;
	if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_HOME_INTENSITY ))
		dlgGridColor = GRID_COLOR_HOME_INT;
	else if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_HOME_COLOR ))
		dlgGridColor = GRID_COLOR_HOME;
	else if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_OBJECT_COLOR ))
		dlgGridColor = GRID_COLOR_OBJECT;
	else
		dlgGridColor = GRID_COLOR_GRAY;

	if (flags&END_EDIT_REMOVEUI ) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		}
	iObjParams = NULL;
	theGridProc.SetObject(NULL);
	}

void GridHelpObject::UpdateMesh(TimeValue t) {
	if ( ivalid.InInterval(t) )
		return;
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float length, width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	}

void GridHelpObject::UpdateUI(TimeValue t)
	{
	if ( editOb==this ) {
		CheckRadioButton(pmapParam->GetHWnd(), IDC_GRID_GRAY_COLOR, IDC_GRID_HOME_INTENSITY,
				IDC_GRID_GRAY_COLOR + GetColor());
		CheckRadioButton(pmapParam->GetHWnd(), IDC_GRID_XY_PLANE, IDC_GRID_ZX_PLANE,
				IDC_GRID_XY_PLANE + GetConstructionPlane() % 3);
		}
	}

ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, TRUE,10  },
	{ TYPE_FLOAT, NULL, TRUE,11 } };

ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 } };

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,12,0)	
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

GridHelpObject::GridHelpObject() : ConstObject() 
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_LENGTH,0,BDEF_DIM);
	pblock->SetValue(PB_WIDTH,0,BDEF_DIM);
	pblock->SetValue(PB_GRID,0,(float)10.0);

	InvalidateGrid();
	myTM.IdentityMatrix();

	gridColor = dlgGridColor;
	constPlane = GRID_PLANE_TOP;
	}

GridHelpObject::~GridHelpObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}


void GridHelpObject::SetGrid( TimeValue t, float len )
	{
	pblock->SetValue( PB_GRID, t, len );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GridHelpObject::SetColor( int c )
	{
	gridColor = c % GRID_MAX_COLORS;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void GridHelpObject::SetConstructionPlane( int p, BOOL notify )
	{
	constPlane = p;
	if(notify)
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float GridHelpObject::GetGrid( TimeValue t, Interval& valid )
	{
	float f;
	pblock->GetValue( PB_GRID, t, f, valid );
	return f;
	}

class GridHelpObjCreateCallBack: public CreateMouseCallBack {
	GridHelpObject *ob;
	Point3 p0,p1;
	IPoint2 sp1, sp0;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(GridHelpObject *obj) { ob = obj; }
	};

int GridHelpObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				p1 = p0 + Point3(.01,.01,0.0);
				mat.SetTrans(float(.5)*(p0+p1));				
				break;
			case 1:
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(float(.5)*(p0+p1));
				d = p1-p0;
				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)) );
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)) );
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if (Length(sp1-sp0) < 4) return CREATE_ABORT;
					else return CREATE_STOP;					
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
	}

static GridHelpObjCreateCallBack gridHelpCreateCB;

CreateMouseCallBack* GridHelpObject::GetCreateMouseCallBack() {
	gridHelpCreateCB.SetObj(this);
	return(&gridHelpCreateCB);
	}

	
void GridHelpObject::GetBBox(TimeValue t,  Matrix3& tm, Box3& box) {	
	float length, width;
	Point2 vert[2];
		
	pblock->GetValue(PB_LENGTH, t, length, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);

	vert[0].x = -width/float(2);
	vert[0].y = -length/float(2);
	vert[1].x = width/float(2);
	vert[1].y = length/float(2);

	box.Init();	
	box += tm * Point3( vert[0].x, vert[0].y, (float)0 );
	box += tm * Point3( vert[1].x, vert[0].y, (float)0 );
	box += tm * Point3( vert[0].x, vert[1].y, (float)0 );
	box += tm * Point3( vert[1].x, vert[1].y, (float)0 );
	box += tm * Point3( vert[0].x, vert[0].y, (float)0.1 );
	box += tm * Point3( vert[1].x, vert[0].y, (float)0.1 );
	box += tm * Point3( vert[0].x, vert[1].y, (float)0.1 );
	box += tm * Point3( vert[1].x, vert[1].y, (float)0.1 );
	}

void GridHelpObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) {
	Matrix3 tm = myTM;
	FixConstructionTM(tm, vpt);
	GetBBox(t,tm,box);
	}

void GridHelpObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	GetBBox(t,tm,box);
	}

// Get the transform for this view
void GridHelpObject::GetConstructionTM( TimeValue t, INode* inode, ViewExp *vpt, Matrix3 &tm ) {
	tm = inode->GetObjectTM(t);
	FixConstructionTM(tm, vpt);
	}

// Get snap values
Point3 GridHelpObject::GetSnaps( TimeValue t ) {	
	float snap = GetGrid(t);
	return Point3(snap,snap,snap);
	}

void GridHelpObject::SetSnaps(TimeValue t, Point3 p)
{
	SetGrid(t, p.x);
}

Point3 GridHelpObject::GetExtents(TimeValue t)
{
	float x, y;
	pblock->GetValue(PB_LENGTH, t, x, FOREVER);
	pblock->GetValue(PB_WIDTH, t, y, FOREVER);
	return Point3(x, y, 0.0f);	
}
		
void GridHelpObject::SetExtents(TimeValue t, Point3 p)
{
	pblock->SetValue(PB_LENGTH, t, p.x);
	pblock->SetValue(PB_WIDTH, t, p.y);
}


int GridHelpObject::Select(TimeValue t, INode *inode, GraphicsWindow *gw, Material *mtl, HitRegion *hr, int abortOnHit ) {
	DWORD	savedLimits;
	Matrix3 tm;
	float width, w2, height, h2;
	pblock->GetValue(PB_LENGTH, t, height, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);
	if ( width==0 || height==0 )
		return 0;

	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->setHitRegion(hr);
	gw->clearHitCode();
	gw->setMaterial(*mtl);

	w2 = width / (float)2;
	h2 = height / (float)2;
		
	Point3 pt[3];

	if(!inode->IsActiveGrid()) {

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( -w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );

		if((hr->type != POINT_RGN) && !hr->crossing) {	// window select needs *every* face to be enclosed
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
				
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( w2, -h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( w2, -h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, (float)0, (float)0.0);
		pt[1] = Point3( w2, (float)0, (float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( (float)0, -h2,(float)0.0);
		pt[1] = Point3( (float)0, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}
		}
	else {
		float grid = GetGrid(t);
		int xSteps = (int)floor(w2 / grid);
		int ySteps = (int)floor(h2 / grid);
		float minX = (float)-xSteps * grid;
		float maxX = (float)xSteps * grid;
		float minY = (float)-ySteps * grid;
		float maxY = (float)ySteps * grid;
		float x,y;
		int ix;

		// Adjust steps for whole range
		xSteps *= 2;
		ySteps *= 2;

		// First, the vertical lines
		pt[0].y = minY;
		pt[0].z = (float)0;
		pt[1].y = maxY;
		pt[1].z = (float)0;

		for(ix=0,x=minX; ix<=xSteps; x+=grid,++ix) {
			pt[0].x = pt[1].x = x;
			gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
			if((hr->type != POINT_RGN) && !hr->crossing) {
				if(gw->checkHitCode())
					gw->clearHitCode();
				else
					return FALSE;
				}
			
			if ( abortOnHit ) {
				if(gw->checkHitCode()) {
					gw->setRndLimits(savedLimits);
					return TRUE;
					}
				}
   			}

		// Now, the horizontal lines
		pt[0].x = minX;
		pt[0].z = (float)0;
		pt[1].x = maxX;
		pt[1].z = (float)0;

		for(ix=0,y=minY; ix<=ySteps; y+=grid,++ix) {
			pt[0].y = pt[1].y = y;
			gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
			if((hr->type != POINT_RGN) && !hr->crossing) {
				if(gw->checkHitCode())
					gw->clearHitCode();
				else
					return FALSE;
				}
			
			if ( abortOnHit ) {
				if(gw->checkHitCode()) {
					gw->setRndLimits(savedLimits);
					return TRUE;
					}
				}
			}
		}

	if((hr->type != POINT_RGN) && !hr->crossing)
		return TRUE;
	return gw->checkHitCode();	
	}

// From BaseObject
int GridHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm;	
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();

   	tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	UpdateMesh(t);
	gw->setTransform(tm);

	MakeHitRegion(hitRegion, type, crossing, 4, p);
	return Select(t, inode, gw, mtl, &hitRegion, flags & HIT_ABORTONHIT );
	}

static float GridCoord(float v, float g) {
	float r = (float)(int((fabs(v)+0.5f*g)/g))*g;	
	return v<0.0f ? -r : r;
	}			

void GridHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *info, IPoint2 *p, ViewExp *vpt) {
	Matrix3 invPlane = Inverse(info->plane);

	// If this isn't the current grid object, forget it!
	if(!inode->IsActiveGrid())
		return;

	Matrix3 tm = inode->GetObjectTM(t);
	FixConstructionTM(tm, vpt);
	GraphicsWindow *gw = vpt->getGW();	

	UpdateMesh(t);
	gw->setTransform(tm);

	Point2 fp = Point2((float)p->x, (float)p->y);

	// Don't bother snapping unless the grid intersection priority is at least as important as what we have so far
	if(info->gIntPriority > 0 && info->gIntPriority <= info->priority) {
		// Find where it lies on the plane
		Point3 local = vpt->GetPointOnCP(*p);
		// Get the grid size
		float grid = GetGrid(t);
		// Snap it to the grid
		Point3 snapped = Point3(GridCoord(local.x,grid),GridCoord(local.y,grid),0.0f);
		// If constrained to the plane, make sure this point is in it!
		if(info->snapType == SNAP_2D || info->flags & SNAP_IN_PLANE) {
			Point3 test = snapped * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				goto testLines;
			}
		// Now find its screen location...
		Point2 screen2;
		IPoint3 pt3;
		gw->wTransPoint(&snapped,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;
		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= info->strength) {
			// Is this priority better than the best so far?
			if(info->gIntPriority < info->priority) {
				info->priority = info->gIntPriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			else
			if(len < info->bestDist) {
				info->priority = info->gIntPriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			}
		}
	// Don't bother snapping unless the grid line priority is at least as important as what we have so far
	testLines:
	if(info->gLinePriority > 0 && info->gLinePriority <= info->priority) {
		// Find where it lies on the plane
		Point3 local = vpt->GetPointOnCP(*p);
		// Get the grid size
		float grid = GetGrid(t);
		// Snap it to the grid axes
		float xSnap = GridCoord(local.x,grid);
		float ySnap = GridCoord(local.y,grid);
		float xDist = (float)fabs(xSnap - local.x);
		float yDist = (float)fabs(ySnap - local.y);
		Point3 snapped;
		// Which one is closer?
		if(xDist < yDist)
			snapped = Point3(xSnap,local.y,0.0f);
		else
			snapped = Point3(local.x,ySnap,0.0f);
		// If constrained to the plane, make sure this point is in it!
		if(info->snapType == SNAP_2D || info->flags & SNAP_IN_PLANE) {
			Point3 test = snapped * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
			}
		// Now find its screen location...
		Point2 screen2;
		IPoint3 pt3;
		gw->wTransPoint(&snapped,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;
		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= info->strength) {
			// Is this priority better than the best so far?
			if(info->gLinePriority < info->priority) {
				info->priority = info->gLinePriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			else
			if(len < info->bestDist) {
				info->priority = info->gLinePriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			}
		}		
	}

int GridHelpObject::IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm)
	{
	if (r.dir.z==0.0f) return FALSE;

	at = -r.p.z/r.dir.z;
	norm = Point3(0,0,1);
	return TRUE;
	}


// This (viewport intensity) should be a globally accessible variable!
#define VPT_INTENS ((float)0.62)

// SECSTART is the fraction of the viewport intensity where the secondary lines start
#define SECSTART ((float)0.75)
static int dotted_es[2] = {GW_EDGE_INVIS, GW_EDGE_INVIS};

int GridHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {

	Matrix3 tm;
	float width, w2, height, h2;
	pblock->GetValue(PB_LENGTH, t, height, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);
	if ( width==0 || height==0 )
		return 0;

	w2 = width / (float)2;
	h2 = height / (float)2;
		
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = gw->getMaterial();
	bool gw_dot_support = (gw->getRndLimits() & (GW_POLY_EDGES | GW_WIREFRAME))?true:false;
	int *es = (IsTransient() && gw_dot_support)?dotted_es:NULL;

   	tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	UpdateMesh(t);		
	gw->setTransform(tm);

	Point3 pt[3];

	float grid = GetGrid(t);
	int xSteps = (int)floor(w2 / grid);
	int ySteps = (int)floor(h2 / grid);
	BOOL badGrid = (xSteps > 200 || ySteps > 200) ? TRUE : FALSE;
	if(!inode->IsActiveGrid() || badGrid) {
		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( -w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( w2, -h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( w2, -h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( -w2, h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		if(badGrid) {
			pt[0] = Point3( -w2, -h2, (float)0.0);
			pt[1] = Point3( w2, h2, (float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );

			pt[0] = Point3( w2, -h2,(float)0.0);
			pt[1] = Point3( -w2, h2,(float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}
		else {
			pt[0] = Point3( -w2, (float)0, (float)0.0);
			pt[1] = Point3( w2, (float)0, (float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );

			pt[0] = Point3( (float)0, -h2,(float)0.0);
			pt[1] = Point3( (float)0, h2,(float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}
		}
	else {	// Active grid representation
		float minX = (float)-xSteps * grid;
		float maxX = (float)xSteps * grid;
		float minY = (float)-ySteps * grid;
		float maxY = (float)ySteps * grid;
		float x,y;
		int ix;
		int selected = inode->Selected();
		float priBrite = VPT_INTENS * SECSTART;

		// Adjust steps for whole range
		xSteps *= 2;
		ySteps *= 2;

		// First, the vertical lines
		pt[0].y = minY;
		pt[0].z = (float)0;
		pt[1].y = maxY;
		pt[1].z = (float)0;

		Point3 dspClr1, dspClr2;
		DWORD rgb;
		switch(gridColor) {
		case GRID_COLOR_GRAY:
			dspClr2 = Point3(0,0,0);
			dspClr1 = Point3(priBrite, priBrite, priBrite);
			break;
		case GRID_COLOR_OBJECT:
			rgb = inode->GetWireColor();
			dspClr2 = Point3(GetRValue(rgb)/255.0f, GetGValue(rgb)/255.0f, GetBValue(rgb)/255.0f);
			dspClr1 = (Point3(1,1,1) + dspClr2) / 2.0f;
			break;
		case GRID_COLOR_HOME:
			dspClr2 = GetUIColor(COLOR_GRID);
			dspClr1 = (Point3(1,1,1) + dspClr2) / 2.0f;
			break;
		case GRID_COLOR_HOME_INT:
			dspClr1 = GetUIColor(COLOR_GRID_INTENS);
			if(dspClr1.x < 0.0f) {	// means "invert"
				dspClr1 = Point3(1,1,1) + dspClr1;
				dspClr2 = Point3(0.8f,0.8f,0.8f);
			}
			else
				dspClr2 = Point3(0,0,0);
			break;
		}

		if(!selected && !inode->IsFrozen())
//			gw->setColor( LINE_COLOR, priBrite, priBrite, priBrite );
			gw->setColor( LINE_COLOR, dspClr1 );

		for(ix=0,x=minX; ix<=xSteps; x+=grid,++ix) {
			pt[0].x = pt[1].x = x;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
   			}

		// Draw origin line if not selected
		if(!selected && !inode->IsFrozen()) {
//			gw->setColor( LINE_COLOR, (float)0, (float)0, (float)0 );
			gw->setColor( LINE_COLOR, dspClr2 );
			pt[0].x = pt[1].x = 0.0f;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Now, the horizontal lines
		pt[0].x = minX;
		pt[0].z = 0.0f;
		pt[1].x = maxX;
		pt[1].z = 0.0f;

		if(!selected && !inode->IsFrozen())
			gw->setColor( LINE_COLOR, dspClr1 );

		for(ix=0,y=minY; ix<=ySteps; y+=grid,++ix) {
			pt[0].y = pt[1].y = y;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Draw origin line if not selected
		if(!selected && !inode->IsFrozen()) {
			gw->setColor( LINE_COLOR, dspClr2 );
			pt[0].y = pt[1].y = 0.0f;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Inform the viewport about the smallest grid scale
		vpt->SetGridSize(grid);
		}

	return(0);
	}

// From Object
ObjectHandle GridHelpObject::ApplyTransform(Matrix3& matrix){
	// RB	
	myTM = myTM * matrix;

	return(ObjectHandle(this));
	}

// From ConstObject

ObjectHandle GridHelpObject::CreateTriObjRep(TimeValue t) {
	return NULL;
	}

//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult GridHelpObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	switch (message) {
		case REFMSG_CHANGE:
			InvalidateGrid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ObjectState GridHelpObject::Eval(TimeValue time){
	return ObjectState(this);
	}

Interval GridHelpObject::ObjectValidity(TimeValue time) {
	UpdateMesh(time);
	UpdateUI(time);
	return ivalid;	
	}


int GridHelpObject::CanConvertToType(Class_ID obtype) {
	return 0;
	}

Object* GridHelpObject::ConvertToType(TimeValue t, Class_ID obtype) {
	return NULL;
	}

RefTargetHandle GridHelpObject::Clone(RemapDir& remap) {
	GridHelpObject* newob = new GridHelpObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->InvalidateGrid();
	newob->myTM = myTM;
	newob->gridColor = gridColor;
	newob->constPlane = constPlane;
	return(newob);
	}


#define TM_CHUNK	0x2100
#define COLOR_CHUNK	0x2110
#define PLANE_CHUNK	0x2120

// IO
IOResult GridHelpObject::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(TM_CHUNK);
	isave->Write(&myTM,sizeof(Matrix3), &nb);
	isave->EndChunk();

	isave->BeginChunk(COLOR_CHUNK);
	isave->Write(&gridColor, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(PLANE_CHUNK);
	isave->Write(&constPlane, sizeof(int), &nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult  GridHelpObject::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	gridColor = GRID_COLOR_GRAY;
	constPlane = GRID_PLANE_TOP;
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case TM_CHUNK:
				res = iload->Read(&myTM,sizeof(Matrix3), &nb);
				break;
			case COLOR_CHUNK:
				res = iload->Read(&gridColor, sizeof(int), &nb);
				break;
			case PLANE_CHUNK:
				res = iload->Read(&constPlane, sizeof(int), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

ParamDimension *GridHelpObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
		case PB_WIDTH:
		case PB_GRID:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR GridHelpObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
			return TSTR(GetString(IDS_TH_LENGTH));
		case PB_WIDTH:
			return TSTR(GetString(IDS_TH_WIDTH));
		case PB_GRID:
			return TSTR(GetString(IDS_DB_GRID));
		default:
			return TSTR(_T(""));
		}
	}

Animatable* GridHelpObject::SubAnim(int i) {
	return pblock;
	}

TSTR GridHelpObject::SubAnimName(int i) {
	return TSTR(GetString(IDS_DB_PARAMETERS));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\tube.cpp ===
/**********************************************************************
 *<
	FILE: tube.cpp

	DESCRIPTION:  A tube object

	CREATED BY: Rolf Berteig

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "prim.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"

class TubeObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static int dlgSegments, dlgCapSegments, dlgSides;		
		static int dlgCreateMeth;
		static int dlgSmooth;	
		static float dlgRadius2;	
		static Point3 crtPos;		
		static float crtRadius1;
		static float crtRadius2;	
		static float crtHeight;

		TubeObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
			
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_TUBE);}

		// Animatable methods		
		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(TUBE_CLASS_ID,0);}
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
	};

// segments  = sides
// lsegments = segments

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		1
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_PIESLICE	float(-1.0E30)
#define MAX_PIESLICE	float( 1.0E30)

#define DEF_SEGMENTS 	18	// 24
#define DEF_SIDES		5	// 1
#define DEF_CAPSEGMENTS	1

#define DEF_RADIUS		(0.1f)
#define DEF_RADIUS2   	(10.0f)

#define SMOOTH_ON		1
#define SMOOTH_SIDES	1
#define SMOOTH_OFF		0


//--- ClassDescriptor and class vars ---------------------------------

class TubeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TubeObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_TUBE_CLASS);}
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TUBE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_PRIMITIVES); }
	void            ResetClassParams(BOOL fileReset);
	};

static TubeClassDesc tubeDesc;

ClassDesc* GetTubeDesc() { return &tubeDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for sphere class.
IObjParam *TubeObject::ip         = NULL;
int TubeObject::dlgSegments       = DEF_SEGMENTS;
int TubeObject::dlgCapSegments    = DEF_CAPSEGMENTS;
int TubeObject::dlgSides          = DEF_SIDES;
int TubeObject::dlgCreateMeth     = 1; // create_radius
int TubeObject::dlgSmooth         = SMOOTH_ON;
float TubeObject::dlgRadius2      = DEF_RADIUS2;
IParamMap *TubeObject::pmapCreate = NULL;
IParamMap *TubeObject::pmapTypeIn = NULL;
IParamMap *TubeObject::pmapParam  = NULL;
Point3 TubeObject::crtPos         = Point3(0,0,0);
float TubeObject::crtRadius1      = 0.0f;
float TubeObject::crtRadius2      = 0.0f;
float TubeObject::crtHeight       = 0.0f;

void TubeClassDesc::ResetClassParams(BOOL fileReset)
	{
	TubeObject::dlgSegments    = DEF_SEGMENTS;
	TubeObject::dlgCapSegments = DEF_CAPSEGMENTS;
	TubeObject::dlgSides       = DEF_SIDES;
	TubeObject::dlgCreateMeth  = 1; // create_radius
	TubeObject::dlgSmooth      = SMOOTH_ON;
	TubeObject::dlgRadius2     = DEF_RADIUS2;
	TubeObject::crtPos         = Point3(0,0,0);
	TubeObject::crtRadius1     = 0.0f;
	TubeObject::crtRadius2     = 0.0f;
	TubeObject::crtHeight      = 0.0f;
	}


//--- Parameter map/block descriptors -------------------------------

// Parameter map indices
#define PB_RADIUS		0
#define PB_RADIUS2		1
#define PB_HEIGHT		2
#define PB_SEGMENTS		3
#define PB_CAPSEGMENTS	4
#define PB_SIDES		5
#define PB_SMOOTH		6
#define PB_SLICEON		7
#define PB_PIESLICE1	8
#define PB_PIESLICE2	9
#define PB_GENUVS		10

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3
#define PB_TI_HEIGHT		4

//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_TI_POSX,IDC_TI_POSXSPIN,
		IDC_TI_POSY,IDC_TI_POSYSPIN,
		IDC_TI_POSZ,IDC_TI_POSZSPIN,
		-99999999.0f,99999999.0f,
		SPIN_AUTOSCALE),
	
	// Radius 1
	ParamUIDesc(
		PB_TI_RADIUS1,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Radius 2
	ParamUIDesc(
		PB_TI_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGH 4


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS1,IDC_RADSPINNER1,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Radius
	ParamUIDesc(
		PB_RADIUS2,
		EDITTYPE_UNIVERSE,
		IDC_RADIUS2,IDC_RAD2SPINNER,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LENGTH,IDC_LENSPINNER,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),	

	// Segments
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SEGMENTS,IDC_SEGSPINNER,
		(float)3,(float)MAX_SEGMENTS,
		0.1f),
	
	// Cap Segments
	ParamUIDesc(
		PB_CAPSEGMENTS,
		EDITTYPE_INT,
		IDC_CAPSEGMENTS,IDC_CAPSEGSPINNER,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SIDES,IDC_SIDESPINNER,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Smooth	
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OBSMOOTH),

	// Slice on
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SLICEON),	

	// Pie slice from
	ParamUIDesc(
		PB_PIESLICE1,
		EDITTYPE_FLOAT,
		IDC_PIESLICE1,IDC_PIESLICESPIN1,
		MIN_PIESLICE,MAX_PIESLICE,
		0.5f,
		stdAngleDim),	

	// Pie slice to
	ParamUIDesc(
		PB_PIESLICE2,
		EDITTYPE_FLOAT,
		IDC_PIESLICE2,IDC_PIESLICESPIN2,
		MIN_PIESLICE,MAX_PIESLICE,		
		0.5f,
		stdAngleDim),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),
	};
#define PARAMDESC_LENGH 11


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 },
	{ TYPE_BOOL, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 } };

#define PBLOCK_LENGTH	11

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,10,0),
	ParamVersionDesc(descVer1,11,1)	
	};
#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class TubeTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		TubeObject *ob;

		TubeTypeInDlgProc(TubeObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL TubeTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_TI_CREATE: {
					if (ob->crtRadius1==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius1);
						ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);
					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Tube methods -------------------------------


TubeObject::TubeObject()
	{	
	SetAFlag(A_PLUGIN1);
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
	pblock->SetValue(PB_SEGMENTS,0,dlgSegments);
	pblock->SetValue(PB_CAPSEGMENTS,0,dlgCapSegments);
	pblock->SetValue(PB_SIDES,0,dlgSides);	
	pblock->SetValue(PB_RADIUS,0,crtRadius1);
	pblock->SetValue(PB_RADIUS2,0,crtRadius2);	
	pblock->SetValue(PB_HEIGHT,0,crtHeight);	
	}

#define NEWMAP_CHUNKID	0x0100

IOResult TubeObject::Load(ILoad *iload) 
	{	
	ClearAFlag(A_PLUGIN1);

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

IOResult TubeObject::Save(ISave *isave)
	{
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
 	return IO_OK;
	}

void TubeObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam && pmapTypeIn) {
		
		// Left over from last Tube ceated		
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TUBEPARAM1),
				GetString(IDS_RB_CREATIONMETHOD),
				0);

			
			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_TUBEPARAM3),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_TUBEPARAM2),
			GetString(IDS_RB_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new TubeTypeInDlgProc(this));
		}
	}
		
void TubeObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
	pblock->GetValue(PB_SEGMENTS,ip->GetTime(),dlgSegments,FOREVER);
	pblock->GetValue(PB_CAPSEGMENTS,ip->GetTime(),dlgCapSegments,FOREVER);
	pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
	pblock->GetValue(PB_RADIUS2,ip->GetTime(),dlgRadius2,FOREVER);		
	}

BOOL TubeObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void TubeObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				

	}

void TubeObject::BuildMesh(TimeValue t)
	{
	Point3 p;
	int ix,na,nb,nc,nd,jx,kx;
	int nf=0,nv=0;
	float delta,ang;	
	int sides,segs,smooth,capsegs, ssides;
	float radius,radius2, temp;
	float sinang,cosang, height;
	float pie1, pie2, totalPie, startAng = 0.0f;
	int doPie = TRUE;	
	int genUVs = TRUE;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;	
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_RADIUS2,t,radius2,ivalid);	
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,segs,ivalid);
	pblock->GetValue(PB_CAPSEGMENTS,t,capsegs,ivalid);
	pblock->GetValue(PB_SIDES,t,ssides,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);
	pblock->GetValue(PB_PIESLICE1,t,pie1,ivalid);
	pblock->GetValue(PB_PIESLICE2,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);		
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	LimitValue( segs, MIN_SEGMENTS, MAX_SEGMENTS );
	LimitValue( capsegs, MIN_SEGMENTS, MAX_SEGMENTS );
	LimitValue( ssides, MIN_SIDES, MAX_SIDES );	
	doPie = doPie ? 1 : 0;

	// We do the torus backwards from the cylinder
	temp = -pie1;
	pie1 = -pie2;
	pie2 = temp;	

	// Flip parity when radi are swaped or height is negative
	if ((radius<radius2 || height<0) && !(radius<radius2&&height<0)) {
		temp    = radius;
		radius  = radius2;
		radius2 = temp;
		}	

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;	
	
	if (doPie) {
		delta    = totalPie/(float)(segs-1);
		startAng = pie2;
	} else {
		delta = (float)2.0*PI/(float)segs;
		}	

	sides = 2*(ssides+capsegs);

	if (TestAFlag(A_PLUGIN1)) startAng -= HALFPI;

	int nverts;
	int nfaces;
	if (doPie) {
		nverts = sides*segs + 2;
		nfaces = 2*sides*segs;
	} else {
		nverts = sides*segs;
		nfaces = 2*sides*segs;
		}
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	if (genUVs) {
		if (doPie) {
			mesh.setNumTVerts((sides+1)*segs+2);
			mesh.setNumTVFaces(2*sides*segs);
		} else {
			mesh.setNumTVerts((sides+1)*(segs+1));
			mesh.setNumTVFaces(2*sides*segs);
			}
	} else {
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		}

	ang = startAng;

	// make verts
	for(ix=0; ix<segs; ix++) {
		sinang = (float)sin(ang);
		cosang = (float)cos(ang);				
		
		// Radius 1
		for (jx = 0; jx<ssides; jx++) {
			p.x = radius*cosang;
			p.y = -radius*sinang;
			p.z = float(jx)/float(ssides) * height;
			mesh.setVert(nv++, p);
			}
		
		// Top		
		for (jx = 0; jx<capsegs; jx++) {
			float u = float(jx)/float(capsegs);
			p.x = (u*radius2 + (1.0f-u)*radius) * cosang;
			p.y = -(u*radius2 + (1.0f-u)*radius) * sinang;
			p.z = height;
			mesh.setVert(nv++, p);
			}
		
		// Radius 2
		for (jx = 0; jx<ssides; jx++) {
			p.x = radius2*cosang;
			p.y = -radius2*sinang;
			p.z = (1.0f-float(jx)/float(ssides)) * height;
			mesh.setVert(nv++, p);
			}
		
		// Bottom
		for (jx = 0; jx<capsegs; jx++) {
			float u = float(jx)/float(capsegs);
			p.x = (u*radius + (1.0f-u)*radius2) * cosang;
			p.y = -(u*radius + (1.0f-u)*radius2) * sinang;
			p.z = 0.0f;
			mesh.setVert(nv++, p);
			}
		
		ang += delta;
		}
	
	if (doPie) {
		float averag = (radius + radius2) / 2.0f;
		p.x = averag * (float)cos(startAng);
		p.y = -averag * (float)sin(startAng);
		p.z = height/2.0f;
		mesh.setVert(nv++, p);

		ang -= delta;
		p.x = averag * (float)cos(ang);
		p.y = -averag * (float)sin(ang);
		p.z = height/2.0f;
		mesh.setVert(nv++, p);
		}
	
	// Make faces

	/* Make midsection */
	for(ix=0; ix<segs-doPie; ++ix) {
		jx=ix*sides;
		for (kx=0; kx<sides; ++kx) {
			na = jx+kx;
			nb = (ix==(segs-1))?kx:na+sides;
			nd = (kx==(sides-1))? jx : na+1;
			nc = nb+nd-na;
			
			DWORD grp =  0;
			int mtlid = 0;
			if  (kx<ssides) {
				mtlid = 2;
				grp = (1<<1);
				}
			else if (kx<ssides+capsegs) {
				mtlid = 0;
				grp = (1<<2);
				}
			else if (kx<2*ssides+capsegs) {
				mtlid = 3;
				grp = (1<<1);
				}
			else {
				mtlid = 1;
				grp = (1<<2);
				}

			if (!smooth) grp = 0;

			mesh.faces[nf].setEdgeVisFlags(0,1,1);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setMatID(mtlid);
			mesh.faces[nf++].setVerts( na,nc,nb);

			mesh.faces[nf].setEdgeVisFlags(1,1,0);
			mesh.faces[nf].setSmGroup(grp);
			mesh.faces[nf].setMatID(mtlid);
			mesh.faces[nf++].setVerts(na,nd,nc);
			}
	 	}

	if (doPie) {		
		na = nv -2;
		for(ix=0; ix<sides; ++ix) {
			nb = ix;
			nc = (ix==(sides-1))?0:ix+1;
			mesh.faces[nf].setEdgeVisFlags(0,1,0);
			mesh.faces[nf].setSmGroup((1<<0));
			mesh.faces[nf].setMatID(4);
			mesh.faces[nf++].setVerts(na,nc,nb);
			}
		
		na = nv -1;
		jx = sides*(segs-1);
		for(ix=0; ix<sides; ++ix) {
			nb = jx+ix;
			nc = (ix==(sides-1))?jx:nb+1;
			mesh.faces[nf].setEdgeVisFlags(0,1,0);
			mesh.faces[nf].setSmGroup((1<<0));
			mesh.faces[nf].setMatID(5);
			mesh.faces[nf++].setVerts(na,nb,nc);
			}
		}

	// UVWs -------------------
	
	if (genUVs) {
		nv=0;
		for(ix=0; ix<=segs-doPie; ix++) {
			for (jx=0; jx<=sides; jx++) {
				mesh.setTVert(nv++,float(jx)/float(sides),float(ix)/float(segs),0.0f);
				}
			}
		int pie1, pie2;
		if (doPie) {
			pie1 = nv;
			mesh.setTVert(nv++,0.5f,1.0f,0.0f);
			pie2 = nv;
			mesh.setTVert(nv++,0.5f,0.0f,0.0f);
			}				
		
		nf=0;
		for(ix=0; ix<segs-doPie; ix++) {
			na = ix*(sides+1);
			nb = (ix+1)*(sides+1);
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(na,nb+1,nb);
				mesh.tvFace[nf++].setTVerts(na,na+1,nb+1);
				na++;
				nb++;
				}
			}
		if (doPie) {						
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(pie1,jx+1,jx);				
				}			
			nb = (sides+1)*(segs-1);
			for (jx=0; jx<sides; jx++) {
				mesh.tvFace[nf++].setTVerts(pie2,nb,nb+1);
				nb++;
				}
			}
		}

	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

#define CIRCLE_FACT	0.5517861843f
#define Tang(vv,ii) ((vv)*4+(ii))

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

void BuildTubePatch(
		PatchMesh &patch, 
		float radius1, float radius2, float height, int genUVs)
	{
	if (radius1<radius2) {
		float temp = radius1;
		radius1 = radius2;
		radius2 = temp;
		}
	int nverts = 16;
	int nvecs = 128;
	int npatches = 16;
	patch.setNumVerts(nverts);	
	patch.setNumTVerts(genUVs ? 25 : 0);
	patch.setNumVecs(nvecs);
	patch.setNumPatches(npatches);
	patch.setNumTVPatches(genUVs ? npatches : 0);
	float ocircleLen = radius1*CIRCLE_FACT;
	float icircleLen = radius2*CIRCLE_FACT;
	float radLen = (radius1-radius2)/3.0f;
	float heightLen = height/3.0f;
	int i;
	DWORD a, b, c, d;

	// Base
	patch.setVert(0, radius1, 0.0f, 0.0f);
	patch.setVert(1, radius2, 0.0f, 0.0f);
	patch.setVert(2, 0.0f, radius1, 0.0f);
	patch.setVert(3, 0.0f, radius2, 0.0f);
	patch.setVert(4, -radius1, 0.0f, 0.0f);
	patch.setVert(5, -radius2, 0.0f, 0.0f);
	patch.setVert(6, 0.0f, -radius1, 0.0f);	
	patch.setVert(7, 0.0f, -radius2, 0.0f);

	// Top
	patch.setVert(8, radius1, 0.0f, height);
	patch.setVert(9, radius2, 0.0f, height);
	patch.setVert(10, 0.0f, radius1, height);
	patch.setVert(11, 0.0f, radius2, height);
	patch.setVert(12, -radius1, 0.0f, height);
	patch.setVert(13, -radius2, 0.0f, height);
	patch.setVert(14, 0.0f, -radius1, height);	
	patch.setVert(15, 0.0f, -radius2, height);

	Point3 ovecs[] = {
		Point3(0.0f, ocircleLen, 0.0f),		
		Point3(-ocircleLen, 0.0f, 0.0f),
		Point3(0.0f, -ocircleLen, 0.0f),
		Point3(ocircleLen, 0.0f, 0.0f),
		};
	Point3 rovecs[] = {
		Point3(0.0f, radLen, 0.0f),		
		Point3(-radLen, 0.0f, 0.0f),
		Point3(0.0f, -radLen, 0.0f),
		Point3(radLen, 0.0f, 0.0f),
		};

	Point3 ivecs[] = {
		Point3(0.0f, icircleLen, 0.0f),
		Point3(icircleLen, 0.0f, 0.0f),
		Point3(0.0f, -icircleLen, 0.0f),
		Point3(-icircleLen, 0.0f, 0.0f),
		};
	Point3 rivecs[] = {
		Point3(0.0f, radLen, 0.0f),
		Point3(radLen, 0.0f, 0.0f),
		Point3(0.0f, -radLen, 0.0f),
		Point3(-radLen, 0.0f, 0.0f),
		};

	// Tangents
	int ix=0;
	for (i=0; i<4; i++) {		
		patch.setVec(ix++,patch.verts[i*2] + ovecs[i]);
		patch.setVec(ix++,patch.verts[i*2] + rovecs[(i+1)%4]);
		patch.setVec(ix++,patch.verts[i*2] + ovecs[(i+2)%4]);
		patch.setVec(ix++,patch.verts[i*2] + Point3(0.0f,0.0f,heightLen));

		patch.setVec(ix++,patch.verts[i*2+1] + ivecs[(4-i)%4]);
		patch.setVec(ix++,patch.verts[i*2+1] + rivecs[((4-i)%4+1)%4]);
		patch.setVec(ix++,patch.verts[i*2+1] + ivecs[((4-i)%4+2)%4]);
		patch.setVec(ix++,patch.verts[i*2+1] + Point3(0.0f,0.0f,heightLen));
		}
	for (i=0; i<4; i++) {		
		patch.setVec(ix++,patch.verts[i*2+8] + ovecs[i]);
		patch.setVec(ix++,patch.verts[i*2+8] + rovecs[(i+1)%4]);
		patch.setVec(ix++,patch.verts[i*2+8] + ovecs[(i+2)%4]);
		patch.setVec(ix++,patch.verts[i*2+8] + Point3(0.0f,0.0f,-heightLen));
															
		patch.setVec(ix++,patch.verts[i*2+9] + ivecs[(4-i)%4]);
		patch.setVec(ix++,patch.verts[i*2+9] + rivecs[((4-i)%4+1)%4]);
		patch.setVec(ix++,patch.verts[i*2+9] + ivecs[((4-i)%4+2)%4]);
		patch.setVec(ix++,patch.verts[i*2+9] + Point3(0.0f,0.0f,-heightLen));
		}	
	
	// Patches
	int px = 0;
	for (i=0; i<4; i++) {
		a = i*2+8;
		b = i*2;
		c = (i*2+2)%8;
		d = (i*2+2)%8+8;
		patch.patches[px].SetType(PATCH_QUAD);
		patch.patches[px].setVerts(a, b, c, d);
		patch.patches[px].setVecs(
			Tang(a,3),Tang(b,3),Tang(b,0),Tang(c,2),
			Tang(c,3),Tang(d,3),Tang(d,2),Tang(a,0));
		patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
		patch.patches[px].smGroup = 1;
//watje 3-17-99 to support patch matids
		patch.patches[px].setMatID(2);

		ix+=4;
		px++;
		}
	for (i=0; i<4; i++) {
		a = (i*2+1+2)%8+8;
		b = (i*2+1+2)%8;
		c = i*2+1;
		d = i*2+1+8;				
		patch.patches[px].SetType(PATCH_QUAD);
		patch.patches[px].setVerts(a, b, c, d);
		patch.patches[px].setVecs(
			Tang(a,3),Tang(b,3),Tang(b,2),Tang(c,0),
			Tang(c,3),Tang(d,3),Tang(d,0),Tang(a,2));
		patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
		patch.patches[px].smGroup = 1;
//watje 3-17-99 to support patch matids
		patch.patches[px].setMatID(3);
		ix+=4;
		px++;
		}
	
	for (i=0; i<4; i++) {
		a = i*2+1;
		b = (i*2+3)%8;
		c = (i*2+2)%8;
		d = (i*2);
		patch.patches[px].SetType(PATCH_QUAD);
		patch.patches[px].setVerts(a, b, c, d);
		patch.patches[px].setVecs(
			Tang(a,0),Tang(b,2),Tang(b,1),Tang(c,1),
			Tang(c,2),Tang(d,0),Tang(d,1),Tang(a,1));
		patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
		patch.patches[px].smGroup = 2;
//watje 3-17-99 to support patch matids
		patch.patches[px].setMatID(1);

		ix+=4;
		px++;
		}
	for (i=0; i<4; i++) {
		a = (i*2+3)%8 + 8;
		b = i*2+1 + 8;
		c = (i*2) + 8;
		d = (i*2+2)%8 + 8;		
		patch.patches[px].SetType(PATCH_QUAD);
		patch.patches[px].setVerts(a, b, c, d);
		patch.patches[px].setVecs(
			Tang(a,2),Tang(b,0),Tang(b,1),Tang(c,1),
			Tang(c,0),Tang(d,2),Tang(d,1),Tang(a,1));
		patch.patches[px].setInteriors(ix, ix+1, ix+2, ix+3);
		patch.patches[px].smGroup = 2;
//watje 3-17-99 to support patch matids
		patch.patches[px].setMatID(0);

		ix+=4;
		px++;
		}
	
	if(genUVs) {
		patch.setTVert(0, UVVert(0.0f, 0.5f, 0.0f));
		patch.setTVert(1, UVVert(0.0f, 0.25f, 0.0f));
		patch.setTVert(2, UVVert(0.25f, 0.5f, 0.0f));
		patch.setTVert(3, UVVert(0.25f, 0.25f, 0.0f));
		patch.setTVert(4, UVVert(0.5f, 0.5f, 0.0f));
		patch.setTVert(5, UVVert(0.5f, 0.25f, 0.0f));
		patch.setTVert(6, UVVert(0.75f, 0.5f, 0.0f));
		patch.setTVert(7, UVVert(0.75f, 0.25f, 0.0f));
		patch.setTVert(8, UVVert(1.0f, 0.5f, 0.0f));
		patch.setTVert(9, UVVert(1.0f, 0.25f, 0.0f));

		patch.setTVert(10, UVVert(0.0f, 0.75f, 0.0f));
		patch.setTVert(11, UVVert(0.0f, 1.0f, 0.0f));
		patch.setTVert(12, UVVert(0.25f, 0.75f, 0.0f));
		patch.setTVert(13, UVVert(0.25f, 1.0f, 0.0f));
		patch.setTVert(14, UVVert(0.5f, 0.75f, 0.0f));
		patch.setTVert(15, UVVert(0.5f, 1.0f, 0.0f));
		patch.setTVert(16, UVVert(0.75f, 0.75f, 0.0f));
		patch.setTVert(17, UVVert(0.75f, 1.0f, 0.0f));
		patch.setTVert(18, UVVert(1.0f, 0.75f, 0.0f));
		patch.setTVert(19, UVVert(1.0f, 1.0f, 0.0f));

		patch.setTVert(20, UVVert(0.0f, 0.0f, 0.0f));
		patch.setTVert(21, UVVert(0.25f, 0.0f, 0.0f));
		patch.setTVert(22, UVVert(0.5f, 0.0f, 0.0f));
		patch.setTVert(23, UVVert(0.75f, 0.0f, 0.0f));
		patch.setTVert(24, UVVert(1.0f, 0.0f, 0.0f));

		patch.getTVPatch(0).setTVerts(10,0,2,12);
		patch.getTVPatch(1).setTVerts(12,2,4,14);
		patch.getTVPatch(2).setTVerts(14,4,6,16);
		patch.getTVPatch(3).setTVerts(16,6,8,18);
		patch.getTVPatch(4).setTVerts(21,3,1,20);
		patch.getTVPatch(5).setTVerts(22,5,3,21);
		patch.getTVPatch(6).setTVerts(23,7,5,22);
		patch.getTVPatch(7).setTVerts(24,9,7,23);
		patch.getTVPatch(8).setTVerts(1,3,2,0);
		patch.getTVPatch(9).setTVerts(3,5,4,2);
		patch.getTVPatch(10).setTVerts(5,7,6,4);
		patch.getTVPatch(11).setTVerts(7,9,8,6);
		patch.getTVPatch(12).setTVerts(13,11,10,12);
		patch.getTVPatch(13).setTVerts(15,13,12,14);
		patch.getTVPatch(14).setTVerts(17,15,14,16);
		patch.getTVPatch(15).setTVerts(19,17,16,18);
		}
			
	assert(patch.buildLinkages());
	patch.computeInteriors();
	patch.InvalidateGeomCache();
	}


#ifndef NO_NURBS

Object *
BuildNURBSTube(float radius1, float radius2, float height,
				BOOL sliceon, float pie1, float pie2, BOOL genUVs)
{
	BOOL flip = FALSE;

	if (radius1 < radius2)
		flip = !flip;

	if (height < 0.0f)
		flip = !flip;

	NURBSSet nset;

	Point3 origin(0,0,0);
	Point3 symAxis(0,0,1);
	Point3 refAxis(0,1,0);
	float startAngle = 0.0f;
	float endAngle = TWOPI;
	pie1 += HALFPI;
	pie2 += HALFPI;
	if (sliceon && pie1 != pie2) {
		float sweep = TWOPI - (pie2-pie1);
		if (sweep > TWOPI) sweep -= TWOPI;
		refAxis = Point3(Point3(1,0,0) * RotateZMatrix(pie2));
		endAngle = sweep;
	}


	// first the main surfaces
	NURBSCVSurface *s0 = new NURBSCVSurface();
	nset.AppendObject(s0);
	NURBSCVSurface *s1 = new NURBSCVSurface();
	nset.AppendObject(s1);

	s0->SetGenerateUVs(genUVs);
	s1->SetGenerateUVs(genUVs);

	s0->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
	s0->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	s0->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
	s0->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	s1->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
	s1->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
	s1->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
	s1->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

	s0->FlipNormals(!flip);
	s1->FlipNormals(flip);

	s0->Renderable(TRUE);
	s1->Renderable(TRUE);

	char bname[80];
	char sname[80];
	strcpy(bname, GetString(IDS_RB_TUBE));
	sprintf(sname, "%s%s01", bname, GetString(IDS_CT_SURF));
	s0->SetName(sname);

	sprintf(sname, "%s%s02", bname, GetString(IDS_CT_SURF));
	s1->SetName(sname);

	if (sliceon && pie1 != pie2) {
		// since GenNURBSCylinderSurface() returns a surface with more CVs
		// if it's larger we need to generate a single surface and make the
		// other one based on it but scaling the CVs based on the radius
		// ratio.
		float radius = (radius1 > radius2) ? radius1 : radius2;

		GenNURBSCylinderSurface(radius, height, origin, symAxis, refAxis,
						startAngle, endAngle, TRUE, *s0);
		GenNURBSCylinderSurface(radius, height, origin, symAxis, refAxis,
						startAngle, endAngle, TRUE, *s1);

		if (radius1 > radius2) {
			s0->MatID(3);
			s1->MatID(4);
		} else {
			s0->MatID(4);
			s1->MatID(3);
		}

		if (radius1 > radius2) {
			double scale = radius2/radius1;
			Matrix3 mat = ScaleMatrix(Point3(scale, scale, 1.0));
			int numU, numV;
			s1->GetNumCVs(numU, numV);
			for (int u = 0; u < numU; u++) {
				for (int v = 0; v < numV; v++) {
					Point3 pos = s1->GetCV(u, v)->GetPosition(0);
					Point3 npos = pos * mat;
					s1->GetCV(u, v)->SetPosition(0, npos);
				}
			}
		} else {
			double scale = radius1/radius2;
			Matrix3 mat = ScaleMatrix(Point3(scale, scale, 1.0));
			int numU, numV;
			s0->GetNumCVs(numU, numV);
			for (int u = 0; u < numU; u++) {
				for (int v = 0; v < numV; v++) {
					Point3 pos = s0->GetCV(u, v)->GetPosition(0);
					Point3 npos = pos * mat;
					s0->GetCV(u, v)->SetPosition(0, npos);
				}
			}
		}


#define F(s1, s2, s1r, s1c, s2r, s2c) \
		fuse.mSurf1 = (s1); \
		fuse.mSurf2 = (s2); \
		fuse.mRow1 = (s1r); \
		fuse.mCol1 = (s1c); \
		fuse.mRow2 = (s2r); \
		fuse.mCol2 = (s2c); \
		nset.mSurfFuse.Append(1, &fuse);

		NURBSFuseSurfaceCV fuse;

		// next the two caps
		for (int c = 0; c < 2; c++) {
			Point3 cen;
			if (c == 0)
				cen = Point3(0,0,0);
			else
				cen = Point3(0.0f, 0.0f, height);
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll be cubic in on direction and match the sphere in the other
			s->SetUOrder(4);
			s->SetNumUKnots(8);
			for (int i = 0; i < 4; i++) {
				s->SetUKnot(i, 0.0);
				s->SetUKnot(i+4, 1.0);
			}

			s->SetVOrder(s0->GetVOrder());
			s->SetNumVKnots(s0->GetNumVKnots());
			for (i = 0; i < s->GetNumVKnots(); i++)
				s->SetVKnot(i, s0->GetVKnot(i));

			int numU, numV;
			s0->GetNumCVs(numU, numV);
			s->SetNumCVs(4, numV);

			for (int v = 0; v < numV; v++) {
				Point3 in_edge, out_edge;
				if (c == 0) {
					in_edge = s0->GetCV(0, v)->GetPosition(0);
					out_edge = s1->GetCV(0, v)->GetPosition(0);
				} else {
					in_edge = s0->GetCV(s0->GetNumUCVs()-1, v)->GetPosition(0);
					out_edge = s1->GetCV(s1->GetNumUCVs()-1, v)->GetPosition(0);
				}
				NURBSControlVertex ncv;
				ncv.SetWeight(0, s0->GetCV(0, v)->GetWeight(0));
				for (int u = 0; u < 4; u++) {
					ncv.SetPosition(0, in_edge + ((out_edge - in_edge)*((float)u/3.0f)));
					s->SetCV(u, v, ncv);
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 1, Point2(1.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(0.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(1.0f, 0.0f));

			if (c == 0) {
				s->FlipNormals(flip);
				s->MatID(2);
			} else {
				s->FlipNormals(!flip);
				s->MatID(1);
			}
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), c+1);
			s->SetName(sname);
		}

		NURBSCVSurface *s2 = (NURBSCVSurface *)nset.GetNURBSObject(2);
		NURBSCVSurface *s3 = (NURBSCVSurface *)nset.GetNURBSObject(3);

		// next the two pie slices
		for (c = 0; c < 2; c++) {
			NURBSCVSurface *s = new NURBSCVSurface();
			nset.AppendObject(s);
			// we'll match the tube in one dimension and the caps in the other.
			s->SetUOrder(s0->GetUOrder());
			int numKnots = s0->GetNumUKnots();
			s->SetNumUKnots(numKnots);
			for (int i = 0; i < numKnots; i++)
				s->SetUKnot(i, s0->GetUKnot(i));

			s->SetVOrder(s2->GetUOrder());
			numKnots = s2->GetNumUKnots();
			s->SetNumVKnots(numKnots);
			for (i = 0; i < numKnots; i++)
				s->SetVKnot(i, s2->GetUKnot(i));

			int s0u, s0v, s1u, s1v, s2u, s2v, s3u, s3v;
			s0->GetNumCVs(s0u, s0v);
			s1->GetNumCVs(s1u, s1v);
			s2->GetNumCVs(s2u, s2v);
			s3->GetNumCVs(s3u, s3v);
			int uNum = s0u, vNum = s2u;
			s->SetNumCVs(uNum, vNum);

			for (int v = 0; v < vNum; v++) {
				for (int u = 0; u < uNum; u++) {
					// we get get the ends from the caps and the edge from the main sheet
					if (u == 0) {  // bottom
						if (c == 0) {
							s->SetCV(u, v, *s2->GetCV(v, 0));
						} else {
							s->SetCV(u, v, *s2->GetCV(v, s2v-1));
						}
					} else if (u == uNum-1) { // top
						if (c == 0) {
							s->SetCV(u, v, *s3->GetCV(v, 0));
						} else {
							s->SetCV(u, v, *s3->GetCV(v, s3v-1));
						}
					} else { // middle
						// get x and y from a cap and z from the main sheet.
						Point3 p;
						if (c == 0)
							p = Point3(s2->GetCV(v, 0)->GetPosition(0).x,
										s2->GetCV(v, 0)->GetPosition(0).y,
										s0->GetCV(u, s0v-1)->GetPosition(0).z);
						else
							p = Point3(s2->GetCV(v, s2v-1)->GetPosition(0).x,
										s2->GetCV(v, s2v-1)->GetPosition(0).y,
										s0->GetCV(u, s0v-1)->GetPosition(0).z);
						NURBSControlVertex ncv;
						ncv.SetPosition(0, p);
						ncv.SetWeight(0, 1.0f);
						s->SetCV(u, v, ncv);
					}
				}
			}
			s->SetGenerateUVs(genUVs);

			s->SetTextureUVs(0, 0, Point2(0.0f, 0.0f));
			s->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			s->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			s->SetTextureUVs(0, 3, Point2(1.0f, 1.0f));

			if (c == 0) {
				s->FlipNormals(flip);
				s->MatID(6);
			} else {
				s->FlipNormals(!flip);
				s->MatID(5);
			}
			s->Renderable(TRUE);
			sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_SLICE), c+1);
			s->SetName(sname);
		}

		NURBSCVSurface *s4 = (NURBSCVSurface *)nset.GetNURBSObject(4);
		NURBSCVSurface *s5 = (NURBSCVSurface *)nset.GetNURBSObject(5);

		// Fuse the edges
		for (int v = 0; v < s0->GetNumVCVs(); v++) {
			F(0, 2, 0, v, 0, v);
			F(0, 3, s0->GetNumUCVs()-1, v, 0, v);
			F(1, 2, 0, v, s2->GetNumUCVs()-1, v);
			F(1, 3, s1->GetNumUCVs()-1, v, s3->GetNumUCVs()-1, v);
		}
		// Now the caps
		for (int u = 0; u < s4->GetNumUCVs(); u++) {
			F(4, 0, u, 0, u, 0);
			F(4, 1, u, s4->GetNumVCVs()-1, u, 0);
			F(5, 0, u, 0, u, s0->GetNumVCVs()-1);
			F(5, 1, u, s4->GetNumVCVs()-1, u, s0->GetNumVCVs()-1);
		}
		for (v = 1; v < s4->GetNumVCVs()-1; v++) {
			F(4, 2, 0, v, v, 0);
			F(4, 3, s4->GetNumUCVs()-1, v, v, 0);
			F(5, 2, 0, v, v, s2->GetNumVCVs()-1);
			F(5, 3, s5->GetNumUCVs()-1, v, v, s3->GetNumVCVs()-1);
		}
	} else {
		GenNURBSCylinderSurface(radius1, height, origin, symAxis, refAxis,
						startAngle, endAngle, FALSE, *s0);
		GenNURBSCylinderSurface(radius2, height, origin, symAxis, refAxis,
						startAngle, endAngle, FALSE, *s1);

		if (radius1 > radius2) {
			s0->MatID(3);
			s1->MatID(4);
		} else {
			s0->MatID(4);
			s1->MatID(3);
		}

		char sname[80];
		// now 4 iso curves 
		NURBSIsoCurve *iso_0_0 = new NURBSIsoCurve();
		nset.AppendObject(iso_0_0);
		iso_0_0->SetParent(0);
		iso_0_0->SetDirection(FALSE);
		iso_0_0->SetTrim(FALSE);
		iso_0_0->SetParam(0, 0.0);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
		iso_0_0->SetName(sname);

		NURBSIsoCurve *iso_0_1 = new NURBSIsoCurve();
		nset.AppendObject(iso_0_1);
		iso_0_1->SetParent(0);
		iso_0_1->SetDirection(FALSE);
		iso_0_1->SetTrim(FALSE);
		iso_0_1->SetParam(0, 1.0);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 1);
		iso_0_1->SetName(sname);

		NURBSIsoCurve *iso_1_0 = new NURBSIsoCurve();
		nset.AppendObject(iso_1_0);
		iso_1_0->SetParent(1);
		iso_1_0->SetDirection(FALSE);
		iso_1_0->SetTrim(FALSE);
		iso_1_0->SetParam(0, 0.0);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 2);
		iso_1_0->SetName(sname);

		NURBSIsoCurve *iso_1_1 = new NURBSIsoCurve();
		nset.AppendObject(iso_1_1);
		iso_1_1->SetParent(1);
		iso_1_1->SetDirection(FALSE);
		iso_1_1->SetTrim(FALSE);
		iso_1_1->SetParam(0, 1.0);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 3);
		iso_1_1->SetName(sname);

		// now 2 ruled surfaces
		NURBSRuledSurface *cap0 = new NURBSRuledSurface();
		nset.AppendObject(cap0);
		cap0->SetGenerateUVs(genUVs);
		cap0->SetParent(0, 2);
		cap0->SetParent(1, 4);
		cap0->FlipNormals(!flip);
		cap0->Renderable(TRUE);
		cap0->MatID(2);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 0);
		cap0->SetName(sname);

		NURBSRuledSurface *cap1 = new NURBSRuledSurface();
		nset.AppendObject(cap1);
		cap1->SetGenerateUVs(genUVs);
		cap1->SetParent(0, 3);
		cap1->SetParent(1, 5);
		cap1->FlipNormals(flip);
		cap1->Renderable(TRUE);
		cap1->MatID(1);
		sprintf(sname, "%s%s%02d", bname, GetString(IDS_CT_CAP), 1);
		cap1->SetName(sname);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *ob = CreateNURBSObject(NULL, &nset, mat);
	return ob;
}

extern Object *BuildNURBSCylinder(float radius, float height,
				BOOL sliceon, float pie1, float pie2, BOOL genUVs);

#endif

Object* TubeObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype == patchObjectClassID) {
		Interval valid = FOREVER;
		float radius1, radius2, height;
		int genUVs;
		pblock->GetValue(PB_RADIUS,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		PatchObject *ob = new PatchObject();
		BuildTubePatch(ob->patch,radius1,radius2,height,genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	}
#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float radius1, radius2, height, pie1, pie2;
		int sliceon, genUVs;
		pblock->GetValue(PB_RADIUS,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		Object *ob;
		if (radius1 == 0.0f || radius2 == 0.0f) {
			float radius;
			if (radius1 == 0.0f) radius = radius2;
			else radius = radius1;
			ob = BuildNURBSCylinder(radius, height,
				sliceon, pie1 - HALFPI, pie2 - HALFPI, genUVs);
		} else
			ob = BuildNURBSTube(radius1, radius2, height, sliceon, pie1, pie2, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	}
#endif

#ifdef DESIGN_VER
	if (obtype == GENERIC_AMSOLID_CLASS_ID)
	{
		Interval valid = FOREVER;
		float radius1, radius2, height, pie1, pie2;
		int sliceon, genUVs, sides;
		pblock->GetValue(PB_RADIUS,t,radius1,valid);
		pblock->GetValue(PB_RADIUS2,t,radius2,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);	
		pblock->GetValue(PB_PIESLICE1,t,pie1,valid);	
		pblock->GetValue(PB_PIESLICE2,t,pie2,valid);	
		pblock->GetValue(PB_SLICEON,t,sliceon,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		pblock->GetValue(PB_SEGMENTS,t,sides,valid);
		int smooth;
		pblock->GetValue(PB_SMOOTH,t,smooth,valid);
		if (radius1 < 0.0f) radius1 = 0.0f;
		if (radius2 < 0.0f) radius2 = 0.0f;
		Object* solid = (Object*)CreateInstance(GEOMOBJECT_CLASS_ID, GENERIC_AMSOLID_CLASS_ID);
		assert(solid);
		if(solid)
		{
			IGeomImp* cacheptr = (IGeomImp*)(solid->GetInterface(I_GEOMIMP));
			assert(cacheptr);
			if(cacheptr)
			{
				bool res;
				if (radius1 == 0.0f || radius2 == 0.0f) {
					float radius;
					if (radius1 == 0.0f) radius = radius2;
					else radius = radius1;
					res = cacheptr->createCylinder(height, radius, sides, smooth);
				}
				else
					res = cacheptr->createPipe(height, radius1, radius2, sides);
				solid->ReleaseInterface(I_GEOMIMP, cacheptr);
				if(res)
					return solid;
				else 
				{
					solid->DeleteMe();
				}
			}
		}
		return NULL;
	}
#endif
	else {
		return SimpleObject::ConvertToType(t,obtype);
		}
	}

int TubeObject::CanConvertToType(Class_ID obtype)
	{
#ifdef DESIGN_VER
	if(obtype == GENERIC_AMSOLID_CLASS_ID)
		return 1;
#endif
	if (obtype==patchObjectClassID || obtype==defObjectClassID
		|| obtype==triObjectClassID) {
		return 1;
	}
#ifndef NO_NURBS
    if (obtype == EDITABLE_SURF_CLASS_ID )
        return 1;
#endif

    return SimpleObject::CanConvertToType(obtype);
	}
	

void TubeObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}


class TubeObjCreateCallBack: public CreateMouseCallBack {
	TubeObject *ob;	
	Point3 p0, p1, p2;
	IPoint2 sp0,sp1,sp2;	
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(TubeObject *obj) { ob = obj; }
	};



int TubeObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 center;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				ob->pblock->SetValue(PB_RADIUS,0,0.0f);
				ob->pblock->SetValue(PB_RADIUS2,0,0.0f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.1f);
				ob->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				sp1 = m;							   
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p1-p0);
					mat.SetTrans(p0);
				} else {
					// diameter
					Point3 center = (p0+p1)/float(2);
					r = Length(center-p0);
					mat.SetTrans(center);  // Modify Node's transform
					}

				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					if (Length(m-sp0)<3 || Length(p1-p0)<0.1f)
						return CREATE_ABORT;
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pblock->SetValue(PB_RADIUS2,0,r+0.1f);
				ob->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}				
				break;
			
			case 2:									
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp2 = m;							   
				#ifdef _3D_CREATE	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif

				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p2-p0);
					mat.SetTrans(p0);
				} else {
					// diameter
					Point3 center = (p2+p0)/float(2);
					r = Length(center-p0);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS2,0,r);
				ob->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p2.y-p0.y,p2.x-p0.x);					
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}
				
				break;					   
			
			case 3:
				{
				float h = vpt->SnapLength(vpt->GetCPDisp(p2,Point3(0,0,1),sp2,m));
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}

	return TRUE;
	}


static TubeObjCreateCallBack tubeCreateCB;

CreateMouseCallBack* TubeObject::GetCreateMouseCallBack() {
	tubeCreateCB.SetObj(this);
	return(&tubeCreateCB);
	}

BOOL TubeObject::OKtoDisplay(TimeValue t) 
	{
	return TRUE;
	}


// From ParamArray
BOOL TubeObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL TubeObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS1: crtRadius1 = v; break;
		case PB_TI_RADIUS2: crtRadius2 = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL TubeObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL TubeObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL TubeObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS1: v = crtRadius1; break;
		case PB_TI_RADIUS2: v = crtRadius2; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL TubeObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void TubeObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *TubeObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:		return stdWorldDim;
		case PB_RADIUS2:	return stdWorldDim;		
		case PB_HEIGHT:		return stdWorldDim;
		case PB_SEGMENTS:	return stdSegmentsDim;
		case PB_CAPSEGMENTS:return stdSegmentsDim;
		case PB_SIDES:		return stdSegmentsDim;
		case PB_SMOOTH:		return stdNormalizedDim;
		case PB_SLICEON:	return stdNormalizedDim;
		case PB_PIESLICE1:	return stdAngleDim;
		case PB_PIESLICE2:	return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR TubeObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS:		return GetString(IDS_RB_RADIUS1);
		case PB_RADIUS2:	return GetString(IDS_RB_RADIUS2);
		case PB_HEIGHT:		return GetString(IDS_RB_HEIGHT);
		case PB_CAPSEGMENTS:return GetString(IDS_RB_CAPSEGMENTS);
		case PB_SEGMENTS:	return GetString(IDS_RB_SIDES);
		case PB_SIDES:		return GetString(IDS_RB_HEIGHTSEGS);
		case PB_SMOOTH:		return GetString(IDS_RB_SMOOTH);
		case PB_SLICEON:	return GetString(IDS_RB_SLICEON);
		case PB_PIESLICE1:	return GetString(IDS_RB_SLICEFROM);
		case PB_PIESLICE2:	return GetString(IDS_RB_SLICETO);
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle TubeObject::Clone(RemapDir& remap) 
	{
	TubeObject* newob = new TubeObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\helpers.cpp ===
/**********************************************************************
 *<
	FILE: helpers.cpp

	DESCRIPTION:   DLL implementation of primitives

	CREATED BY: Dan Silva

	HISTORY: created 12 December 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "helpers.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,L"PRIM.DLL: DllMain",L"Helpers",MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RB_DEFHELPERS); }


#ifndef DESIGN_VER
/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 2;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetGridHelpDesc();
		case 1: return GetPointHelpDesc();
		//case 2: return GetTapeHelpDesc();
		//case 3: return GetLineHelpDesc();
		default: return 0;
		}

	}
#else
/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 2;}

//VIZ will use a different grid helper
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
//		case 0: return GetVIZGridHelpDesc();
		case 0: return GetGridHelpDesc();
		case 1: return GetPointHelpDesc();
		//case 2: return GetTapeHelpDesc();
		//case 3: return GetLineHelpDesc();
		default: return 0;
		}

	}

#endif

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}


TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\gridhelp2.cpp ===
/**********************************************************************
 *<
	FILE: gridhelp2.cpp

	DESCRIPTION:  An alternative grid helper implementation

	CREATED BY: John Hutchinson (based on Tom Hudson (based on Dan Silva's Object implementations))

	HISTORY: 10/05/98

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "helpers.h"
#include "gridhelp.h"
#include <assert.h>

extern int MostOrthogonalPlane( Matrix3& tmConst, ViewExp *vpt);
extern int MaxCoord(Point3 p);

// Parameter block indices
#define PB_LENGTH		0
#define PB_WIDTH		1
#define PB_GRID			2

#define PBLOCK_LENGTH 3

//------------------------------------------------------

class VIZGridHelpObjClassDesc:public ClassDesc {
	static ulong m_cid1;
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new VIZGridHelpObject; }
	const TCHAR *	ClassName() { return GetString(IDS_JH_GRID2_CLASS); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(m_cid1,0); }
	const TCHAR* 	Category() { return _T("");  }
	};

//ulong VIZGridHelpObjClassDesc::m_cid1 = 0x3bba4077;
ulong VIZGridHelpObjClassDesc::m_cid1 = GRIDHELP_CLASS_ID;
static VIZGridHelpObjClassDesc gridHelpObjDesc;

ClassDesc* GetVIZGridHelpDesc() { return &gridHelpObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variable for grid class.
VIZGridHelpObject *VIZGridHelpObject::editOb = NULL;
IParamMap *VIZGridHelpObject::pmapParam = NULL;
IObjParam *VIZGridHelpObject::iObjParams = NULL;
int VIZGridHelpObject::dlgGridColor = GRID_COLOR_GRAY;
//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LENGTHEDIT,IDC_LENSPINNER,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_WIDTHEDIT,IDC_WIDTHSPINNER,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	
	
	// Grid
	ParamUIDesc(
		PB_GRID,
		EDITTYPE_UNIVERSE,
		IDC_GRID,IDC_GRIDSPINNER,
		BMIN_GRID,BMAX_GRID,
		SPIN_AUTOSCALE),	
	
	};
#define PARAMDESC_LENGTH 3


void VIZGridHelpObject::FixConstructionTM(Matrix3 &tm, ViewExp *vpt)
{
	int plane = GRID_PLANE_TOP;

	if(vpt->GetGridType() < 0)
	{//JH 10/03/98 extending this to fix the construction plane to the most orthogonal plane
		//when the view is orthographic
		if( !(vpt->IsPerspView() || vpt->GetViewCamera() || (vpt->GetViewType() == VIEW_ISO_USER)))
		{
			plane = MostOrthogonalPlane(tm, vpt);
		}
		else
			plane = constPlane; //Original behavior for all non-grid views
	}
	else
		plane = vpt->GetGridType();

	if(plane == GRID_PLANE_BOTTOM)
		tm.PreRotateX(3.1415926f);	
	else if(plane == GRID_PLANE_RIGHT)
		tm.PreRotateY(3.1415926f/2.0f);
	else if(plane == GRID_PLANE_LEFT)
		tm.PreRotateY(-3.1415926f/2.0f);
	else if(plane == GRID_PLANE_FRONT)
		tm.PreRotateX(3.1415926f/2.0f);
	else if(plane == GRID_PLANE_BACK)
		tm.PreRotateX(-3.1415926f/2.0f);
}

class VIZGridDlgProc : public ParamMapUserDlgProc {
	public:
		VIZGridHelpObject *go;
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void SetObject(VIZGridHelpObject *ob) { go = ob; }
		void DeleteThis() {}
	};

BOOL VIZGridDlgProc::DlgProc( TimeValue t, IParamMap *map, HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	switch ( message ) {
		case WM_INITDIALOG:
			CheckRadioButton(hDlg, IDC_GRID_GRAY_COLOR, IDC_GRID_HOME_INTENSITY, IDC_GRID_GRAY_COLOR+go->GetColor());
			CheckRadioButton(hDlg, IDC_GRID_XY_PLANE, IDC_GRID_ZX_PLANE, IDC_GRID_XY_PLANE+go->GetConstructionPlane() % 3);
			return FALSE;			

		case WM_COMMAND:			
			switch( LOWORD(wParam) ) {
				case IDC_GRID_GRAY_COLOR:
				case IDC_GRID_OBJECT_COLOR:
				case IDC_GRID_HOME_COLOR:
				case IDC_GRID_HOME_INTENSITY:
					go->SetColor(LOWORD(wParam) - IDC_GRID_GRAY_COLOR);
					go->iObjParams->RedrawViews(t,REDRAW_END);
					break;
				case IDC_GRID_XY_PLANE:
				case IDC_GRID_YZ_PLANE:
				case IDC_GRID_ZX_PLANE:
					go->SetConstructionPlane(LOWORD(wParam) - IDC_GRID_XY_PLANE);
					go->iObjParams->RedrawViews(t,REDRAW_END);
					break;
				}
			return FALSE;
		default:
			return FALSE;
		}
	}

VIZGridDlgProc theVIZGridProc;

void VIZGridHelpObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
	{
	editOb = this;
	iObjParams = ip;
	if (pmapParam) {
		// Left over from last one created
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_GRIDPARAM2),
			GetString(IDS_DB_PARAMETERS),
			0);
		}
	theVIZGridProc.SetObject(this);
	pmapParam->SetUserDlgProc(&theVIZGridProc);
	}
		
void VIZGridHelpObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
	{
	editOb = NULL;
	if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_HOME_INTENSITY ))
		dlgGridColor = GRID_COLOR_HOME_INT;
	else if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_HOME_COLOR ))
		dlgGridColor = GRID_COLOR_HOME;
	else if(IsDlgButtonChecked(pmapParam->GetHWnd(), IDC_GRID_OBJECT_COLOR ))
		dlgGridColor = GRID_COLOR_OBJECT;
	else
		dlgGridColor = GRID_COLOR_GRAY;

	if (flags&END_EDIT_REMOVEUI ) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		}
	iObjParams = NULL;
	theVIZGridProc.SetObject(NULL);
	}

void VIZGridHelpObject::UpdateMesh(TimeValue t) {
	if ( ivalid.InInterval(t) )
		return;
	// Start the validity interval at forever and whittle it down.
	ivalid = FOREVER;
	float length, width;
	pblock->GetValue(PB_LENGTH, t, length, ivalid);
	pblock->GetValue(PB_WIDTH, t, width, ivalid);
	}

void VIZGridHelpObject::UpdateUI(TimeValue t)
	{
	if ( editOb==this ) {
		CheckRadioButton(pmapParam->GetHWnd(), IDC_GRID_GRAY_COLOR, IDC_GRID_HOME_INTENSITY,
				IDC_GRID_GRAY_COLOR + GetColor());
		CheckRadioButton(pmapParam->GetHWnd(), IDC_GRID_XY_PLANE, IDC_GRID_ZX_PLANE,
				IDC_GRID_XY_PLANE + GetConstructionPlane() % 3);
		}
	}


ParamBlockDescID descVer[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 } };

// Array of old versions
//static ParamVersionDesc versions[] = {};
#define NUM_OLDVERSIONS	0

// Current version
#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(descVer,PBLOCK_LENGTH,CURRENT_VERSION);

VIZGridHelpObject* VIZGridHelpObject::CreateImplicitGridObject()
{
	VIZGridHelpObject* grid = new VIZGridHelpObject();
	grid->m_implicit = true;
	grid->pblock->SetValue(PB_LENGTH,0,BDEF_DIM);
	grid->pblock->SetValue(PB_WIDTH,0,BDEF_DIM);
	grid->pblock->SetValue(PB_GRID,0,(float)10.0);
	return grid;
}

VIZGridHelpObject::VIZGridHelpObject() : ConstObject() 
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_LENGTH,0,BDEF_DIM);
	pblock->SetValue(PB_WIDTH,0,BDEF_DIM);
	pblock->SetValue(PB_GRID,0,(float)10.0);

	InvalidateGrid();
	myTM.IdentityMatrix();

	gridColor = dlgGridColor;
	constPlane = GRID_PLANE_TOP;
	}

VIZGridHelpObject::~VIZGridHelpObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}


void VIZGridHelpObject::SetGrid( TimeValue t, float len )
	{
	pblock->SetValue( PB_GRID, t, len );
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void VIZGridHelpObject::SetColor( int c )
	{
	gridColor = c % GRID_MAX_COLORS;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void VIZGridHelpObject::SetConstructionPlane( int p, BOOL notify )
	{
	constPlane = p;
	if(notify)
		NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

float VIZGridHelpObject::GetGrid( TimeValue t, Interval& valid )
	{
	float f;
	pblock->GetValue( PB_GRID, t, f, valid );
	return f;
	}

class VIZGridHelpObjCreateCallBack: public CreateMouseCallBack {
	INode *igNode;
	VIZGridHelpObject *ob;
	Point3 p0,p1;
	IPoint2 sp1, sp0;
	public:
		VIZGridHelpObjCreateCallBack(){igNode = NULL;}
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(VIZGridHelpObject *obj) { ob = obj; }
	};

int VIZGridHelpObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 d;

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				p1 = p0 + Point3(.01,.01,0.0);
				mat.SetTrans(p0);				
				break;
			case 1:
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				d = p1-p0;
				ob->pblock->SetValue(PB_WIDTH,0,d.Length() );
				ob->pblock->SetValue(PB_LENGTH,0,d.Length() );
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if (Length(sp1-sp0) < 4) return CREATE_ABORT;
					else return CREATE_STOP;					
					}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;

	return TRUE;
	}

static VIZGridHelpObjCreateCallBack vizgridHelpCreateCB;

CreateMouseCallBack* VIZGridHelpObject::GetCreateMouseCallBack() {
	vizgridHelpCreateCB.SetObj(this);
	return(&vizgridHelpCreateCB);
	}

	
void VIZGridHelpObject::GetBBox(TimeValue t,  Matrix3& tm, Box3& box) {	
	float length, width;
	Point2 vert[2];
		
	pblock->GetValue(PB_LENGTH, t, length, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);

	vert[0].x = -width/float(2);
	vert[0].y = -length/float(2);
	vert[1].x = width/float(2);
	vert[1].y = length/float(2);

	box.Init();	
	box += tm * Point3( vert[0].x, vert[0].y, (float)0 );
	box += tm * Point3( vert[1].x, vert[0].y, (float)0 );
	box += tm * Point3( vert[0].x, vert[1].y, (float)0 );
	box += tm * Point3( vert[1].x, vert[1].y, (float)0 );
	box += tm * Point3( vert[0].x, vert[0].y, (float)0.1 );
	box += tm * Point3( vert[1].x, vert[0].y, (float)0.1 );
	box += tm * Point3( vert[0].x, vert[1].y, (float)0.1 );
	box += tm * Point3( vert[1].x, vert[1].y, (float)0.1 );
	}

void VIZGridHelpObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) {
	Matrix3 tm = myTM;
	FixConstructionTM(tm, vpt);
	GetBBox(t,tm,box);
	}

void VIZGridHelpObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	GetBBox(t,tm,box);
	}

// Get the transform for this view
void VIZGridHelpObject::GetConstructionTM( TimeValue t, INode* inode, ViewExp *vpt, Matrix3 &tm ) {
	tm = inode->GetObjectTM(t);
	FixConstructionTM(tm, vpt);
	}

// Get snap values
Point3 VIZGridHelpObject::GetSnaps( TimeValue t ) {	
	float snap = GetGrid(t);
	return Point3(snap,snap,snap);
	}

void VIZGridHelpObject::SetSnaps(TimeValue t, Point3 p)
{
	SetGrid(t, p.x);
}

Point3 VIZGridHelpObject::GetExtents(TimeValue t)
{
	float x, y;
	pblock->GetValue(PB_LENGTH, t, x, FOREVER);
	pblock->GetValue(PB_WIDTH, t, y, FOREVER);
	return Point3(x, y, 0.0f);	
}
		
void VIZGridHelpObject::SetExtents(TimeValue t, Point3 p)
{
	pblock->SetValue(PB_LENGTH, t, p.x);
	pblock->SetValue(PB_WIDTH, t, p.y);
}



int VIZGridHelpObject::Select(TimeValue t, INode *inode, GraphicsWindow *gw, Material *mtl, HitRegion *hr, int abortOnHit ) {
	DWORD	savedLimits;
	Matrix3 tm;
	float width, w2, height, h2;
	pblock->GetValue(PB_LENGTH, t, height, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);
	if ( width==0 || height==0 )
		return 0;

	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->setHitRegion(hr);
	gw->clearHitCode();
	gw->setMaterial(*mtl);

	w2 = width / (float)2;
	h2 = height / (float)2;
		
	Point3 pt[3];

	if(!inode->IsActiveGrid()) {

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( -w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );

		if((hr->type != POINT_RGN) && !hr->crossing) {	// window select needs *every* face to be enclosed
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
				
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( w2, -h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( w2, -h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( -w2, (float)0, (float)0.0);
		pt[1] = Point3( w2, (float)0, (float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}

		pt[0] = Point3( (float)0, -h2,(float)0.0);
		pt[1] = Point3( (float)0, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
		if((hr->type != POINT_RGN) && !hr->crossing) {
			if(gw->checkHitCode())
				gw->clearHitCode();
			else
				return FALSE;
			}
			
		if ( abortOnHit ) {
			if(gw->checkHitCode()) {
				gw->setRndLimits(savedLimits);
				return TRUE;
				}
			}
		}
	else {
		float grid = GetGrid(t);
		int xSteps = (int)floor(w2 / grid);
		int ySteps = (int)floor(h2 / grid);
		float minX = (float)-xSteps * grid;
		float maxX = (float)xSteps * grid;
		float minY = (float)-ySteps * grid;
		float maxY = (float)ySteps * grid;
		float x,y;
		int ix;

		// Adjust steps for whole range
		xSteps *= 2;
		ySteps *= 2;

		// First, the vertical lines
		pt[0].y = minY;
		pt[0].z = (float)0;
		pt[1].y = maxY;
		pt[1].z = (float)0;

		for(ix=0,x=minX; ix<=xSteps; x+=grid,++ix) {
			pt[0].x = pt[1].x = x;
			gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
			if((hr->type != POINT_RGN) && !hr->crossing) {
				if(gw->checkHitCode())
					gw->clearHitCode();
				else
					return FALSE;
				}
			
			if ( abortOnHit ) {
				if(gw->checkHitCode()) {
					gw->setRndLimits(savedLimits);
					return TRUE;
					}
				}
   			}

		// Now, the horizontal lines
		pt[0].x = minX;
		pt[0].z = (float)0;
		pt[1].x = maxX;
		pt[1].z = (float)0;

		for(ix=0,y=minY; ix<=ySteps; y+=grid,++ix) {
			pt[0].y = pt[1].y = y;
			gw->polyline( 2, pt, NULL, NULL, FALSE, NULL );
		
			if((hr->type != POINT_RGN) && !hr->crossing) {
				if(gw->checkHitCode())
					gw->clearHitCode();
				else
					return FALSE;
				}
			
			if ( abortOnHit ) {
				if(gw->checkHitCode()) {
					gw->setRndLimits(savedLimits);
					return TRUE;
					}
				}
			}
		}

	if((hr->type != POINT_RGN) && !hr->crossing)
		return TRUE;
	return gw->checkHitCode();	
	}

// From BaseObject
int VIZGridHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm;	
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();

   	tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	UpdateMesh(t);
	gw->setTransform(tm);

	MakeHitRegion(hitRegion, type, crossing, 4, p);
	return Select(t, inode, gw, mtl, &hitRegion, flags & HIT_ABORTONHIT );
	}

static float GridCoord(float v, float g) {
	float r = (float)(int((fabs(v)+0.5f*g)/g))*g;	
	return v<0.0f ? -r : r;
	}			

void VIZGridHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *info, IPoint2 *p, ViewExp *vpt) {
	Matrix3 invPlane = Inverse(info->plane);

	// If this isn't the current grid object, forget it!
	if(!inode->IsActiveGrid())
		return;

	Matrix3 tm = inode->GetObjectTM(t);
	FixConstructionTM(tm, vpt);
	GraphicsWindow *gw = vpt->getGW();	

	UpdateMesh(t);
	gw->setTransform(tm);

	Point2 fp = Point2((float)p->x, (float)p->y);

	// Don't bother snapping unless the grid intersection priority is at least as important as what we have so far
	if(info->gIntPriority > 0 && info->gIntPriority <= info->priority) {
		// Find where it lies on the plane
		Point3 local = vpt->GetPointOnCP(*p);
		// Get the grid size
		float grid = GetGrid(t);
		// Snap it to the grid
		Point3 snapped = Point3(GridCoord(local.x,grid),GridCoord(local.y,grid),0.0f);
		// If constrained to the plane, make sure this point is in it!
		if(info->snapType == SNAP_2D || info->flags & SNAP_IN_PLANE) {
			Point3 test = snapped * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				goto testLines;
			}
		// Now find its screen location...
		Point2 screen2;
		IPoint3 pt3;
		gw->wTransPoint(&snapped,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;
		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= info->strength) {
			// Is this priority better than the best so far?
			if(info->gIntPriority < info->priority) {
				info->priority = info->gIntPriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			else
			if(len < info->bestDist) {
				info->priority = info->gIntPriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			}
		}
	// Don't bother snapping unless the grid line priority is at least as important as what we have so far
	testLines:
	if(info->gLinePriority > 0 && info->gLinePriority <= info->priority) {
		// Find where it lies on the plane
		Point3 local = vpt->GetPointOnCP(*p);
		// Get the grid size
		float grid = GetGrid(t);
		// Snap it to the grid axes
		float xSnap = GridCoord(local.x,grid);
		float ySnap = GridCoord(local.y,grid);
		float xDist = (float)fabs(xSnap - local.x);
		float yDist = (float)fabs(ySnap - local.y);
		Point3 snapped;
		// Which one is closer?
		if(xDist < yDist)
			snapped = Point3(xSnap,local.y,0.0f);
		else
			snapped = Point3(local.x,ySnap,0.0f);
		// If constrained to the plane, make sure this point is in it!
		if(info->snapType == SNAP_2D || info->flags & SNAP_IN_PLANE) {
			Point3 test = snapped * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
			}
		// Now find its screen location...
		Point2 screen2;
		IPoint3 pt3;
		gw->wTransPoint(&snapped,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;
		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= info->strength) {
			// Is this priority better than the best so far?
			if(info->gLinePriority < info->priority) {
				info->priority = info->gLinePriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			else
			if(len < info->bestDist) {
				info->priority = info->gLinePriority;
				info->bestWorld = snapped * tm;
				info->bestScreen = screen2;
				info->bestDist = len;
				}
			}
		}		
	}

int VIZGridHelpObject::IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm)
	{
	if (r.dir.z==0.0f) return FALSE;

	at = -r.p.z/r.dir.z;
	norm = Point3(0,0,1);
	return TRUE;
	}


// This (viewport intensity) should be a globally accessible variable!
#define VPT_INTENS ((float)0.62)

// SECSTART is the fraction of the viewport intensity where the secondary lines start
#define SECSTART ((float)0.75)
static int dotted_es[2] = {GW_EDGE_INVIS, GW_EDGE_INVIS};

int VIZGridHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	//JH turnign off the grid display when it's active mostly cause it conflicts 
	//with the "other" display 
	if(inode == GetCOREInterface()->GetActiveGrid() && !IsTransient())
		return 0;

	Matrix3 tm;
	float width, w2, height, h2;
	pblock->GetValue(PB_LENGTH, t, height, FOREVER);
	pblock->GetValue(PB_WIDTH, t, width, FOREVER);
	if ( width==0 || height==0 )
		return 0;

	w2 = width / (float)2;
	h2 = height / (float)2;
		
	GraphicsWindow *gw = vpt->getGW();
	DWORD gw_dot_support = gw->getRndLimits();
	gw_dot_support &= (GW_POLY_EDGES | GW_WIREFRAME);
	int *es = (IsTransient() && gw_dot_support)?dotted_es:NULL;
	Material *mtl = gw->getMaterial();


   	tm = myTM * (inode->GetObjectTM(t));
	FixConstructionTM(tm, vpt);
	UpdateMesh(t);		
	gw->setTransform(tm);


	Point3 pt[3];

	float grid = GetGrid(t);
	int xSteps = (int)floor(w2 / grid);
	int ySteps = (int)floor(h2 / grid);
	BOOL badGrid = (xSteps > 200 || ySteps > 200) ? TRUE : FALSE;
	if(!inode->IsActiveGrid() || badGrid) {
		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( -w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( w2, -h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( -w2, -h2,(float)0.0);
		pt[1] = Point3( w2, -h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		pt[0] = Point3( -w2, h2,(float)0.0);
		pt[1] = Point3( w2, h2,(float)0.0);
		gw->polyline( 2, pt, NULL, NULL, FALSE, es );

		if(badGrid) {
			pt[0] = Point3( -w2, -h2, (float)0.0);
			pt[1] = Point3( w2, h2, (float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );

			pt[0] = Point3( w2, -h2,(float)0.0);
			pt[1] = Point3( -w2, h2,(float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}
		else {
			pt[0] = Point3( -w2, (float)0, (float)0.0);
			pt[1] = Point3( w2, (float)0, (float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );

			pt[0] = Point3( (float)0, -h2,(float)0.0);
			pt[1] = Point3( (float)0, h2,(float)0.0);
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}
		}
	else {	// Active grid representation
		float minX = (float)-xSteps * grid;
		float maxX = (float)xSteps * grid;
		float minY = (float)-ySteps * grid;
		float maxY = (float)ySteps * grid;
		float x,y;
		int ix;
		int selected = inode->Selected();
		float priBrite = VPT_INTENS * SECSTART;

		// Adjust steps for whole range
		xSteps *= 2;
		ySteps *= 2;

		// First, the vertical lines
		pt[0].y = minY;
		pt[0].z = (float)0;
		pt[1].y = maxY;
		pt[1].z = (float)0;

		Point3 dspClr1, dspClr2;
		DWORD rgb;
		switch(gridColor) {
		case GRID_COLOR_GRAY:
			dspClr2 = Point3(0,0,0);
			dspClr1 = Point3(priBrite, priBrite, priBrite);
			break;
		case GRID_COLOR_OBJECT:
			rgb = inode->GetWireColor();
			dspClr2 = Point3(GetRValue(rgb)/255.0f, GetGValue(rgb)/255.0f, GetBValue(rgb)/255.0f);
			dspClr1 = (Point3(1,1,1) + dspClr2) / 2.0f;
			break;
		case GRID_COLOR_HOME:
			dspClr2 = GetUIColor(COLOR_GRID);
			dspClr1 = (Point3(1,1,1) + dspClr2) / 2.0f;
			break;
		case GRID_COLOR_HOME_INT:
			dspClr1 = GetUIColor(COLOR_GRID_INTENS);
			if(dspClr1.x < 0.0f) {	// means "invert"
				dspClr1 = Point3(1,1,1) + dspClr1;
				dspClr2 = Point3(0.8f,0.8f,0.8f);
			}
			else
				dspClr2 = Point3(0,0,0);
			break;
		}

		if(!selected)// && !inode->IsFrozen())
//			gw->setColor( LINE_COLOR, priBrite, priBrite, priBrite );
			gw->setColor( LINE_COLOR, dspClr1 );

		for(ix=0,x=minX; ix<=xSteps; x+=grid,++ix) {
			pt[0].x = pt[1].x = x;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
   			}

		// Draw origin line if not selected
		if(!selected) {// && !inode->IsFrozen()) {
//			gw->setColor( LINE_COLOR, (float)0, (float)0, (float)0 );
			gw->setColor( LINE_COLOR, dspClr2 );
			pt[0].x = pt[1].x = 0.0f;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Now, the horizontal lines
		pt[0].x = minX;
		pt[0].z = 0.0f;
		pt[1].x = maxX;
		pt[1].z = 0.0f;

		if(!selected)// && !inode->IsFrozen())
			gw->setColor( LINE_COLOR, dspClr1 );

		for(ix=0,y=minY; ix<=ySteps; y+=grid,++ix) {
			pt[0].y = pt[1].y = y;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Draw origin line if not selected
		if(!selected) {// && !inode->IsFrozen()) {
			gw->setColor( LINE_COLOR, dspClr2 );
			pt[0].y = pt[1].y = 0.0f;
			gw->polyline( 2, pt, NULL, NULL, FALSE, es );
			}

		// Inform the viewport about the smallest grid scale
		vpt->SetGridSize(grid);
		}

	return(0);
	}

// From Object
ObjectHandle VIZGridHelpObject::ApplyTransform(Matrix3& matrix){
	// RB	
	myTM = myTM * matrix;

	return(ObjectHandle(this));
	}

// From ConstObject

ObjectHandle VIZGridHelpObject::CreateTriObjRep(TimeValue t) {
	return NULL;
	}

//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult VIZGridHelpObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	switch (message) {
		case REFMSG_CHANGE:
			InvalidateGrid();
			if (editOb==this) InvalidateUI();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ObjectState VIZGridHelpObject::Eval(TimeValue time){
	return ObjectState(this);
	}

Interval VIZGridHelpObject::ObjectValidity(TimeValue time) {
	UpdateMesh(time);
	UpdateUI(time);
	return ivalid;	
	}


int VIZGridHelpObject::CanConvertToType(Class_ID obtype) {
	return 0;
	}

Object* VIZGridHelpObject::ConvertToType(TimeValue t, Class_ID obtype) {
	return NULL;
	}

RefTargetHandle VIZGridHelpObject::Clone(RemapDir& remap) {
	VIZGridHelpObject* newob = new VIZGridHelpObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->InvalidateGrid();
	newob->myTM = myTM;
	newob->gridColor = gridColor;
	newob->constPlane = constPlane;
	return(newob);
	}


#define TM_CHUNK	0x2100
#define COLOR_CHUNK	0x2110
#define PLANE_CHUNK	0x2120

// IO
IOResult VIZGridHelpObject::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(TM_CHUNK);
	isave->Write(&myTM,sizeof(Matrix3), &nb);
	isave->EndChunk();

	isave->BeginChunk(COLOR_CHUNK);
	isave->Write(&gridColor, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(PLANE_CHUNK);
	isave->Write(&constPlane, sizeof(int), &nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult  VIZGridHelpObject::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	gridColor = GRID_COLOR_GRAY;
	constPlane = GRID_PLANE_TOP;
//	iload->RegisterPostLoadCallback(
//		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case TM_CHUNK:
				res = iload->Read(&myTM,sizeof(Matrix3), &nb);
				break;
			case COLOR_CHUNK:
				res = iload->Read(&gridColor, sizeof(int), &nb);
				break;
			case PLANE_CHUNK:
				res = iload->Read(&constPlane, sizeof(int), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

ParamDimension *VIZGridHelpObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
		case PB_WIDTH:
		case PB_GRID:
			return stdWorldDim;			
		default:
			return defaultDim;
		}
	}

TSTR VIZGridHelpObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:
			return TSTR(GetString(IDS_TH_LENGTH));
		case PB_WIDTH:
			return TSTR(GetString(IDS_TH_WIDTH));
		case PB_GRID:
			return TSTR(GetString(IDS_DB_GRID));
		default:
			return TSTR(_T(""));
		}
	}

Animatable* VIZGridHelpObject::SubAnim(int i) {
	return pblock;
	}

TSTR VIZGridHelpObject::SubAnimName(int i) {
	return TSTR(GetString(IDS_DB_PARAMETERS));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\helpers.h ===
/**********************************************************************
 *<
	FILE: helpers.h

	DESCRIPTION: Helper object header file

	CREATED BY: Tom Hudson

	HISTORY: Created 31 January 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __HELPERS__H
#define __HELPERS__H

#include "Max.h"
#include "resource.h"

TCHAR *GetString(int id);

#define LINEHELP_CLASS_ID 0x02012


extern ClassDesc* GetGridHelpDesc();
extern ClassDesc* GetTapeHelpDesc();
extern ClassDesc* GetLineHelpDesc();
extern ClassDesc* GetPointHelpDesc();
extern ClassDesc* GetVIZGridHelpDesc();

#endif // __HELPERS__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\pthelp.cpp ===
/**********************************************************************
 *<
	FILE: pthelp.cpp

	DESCRIPTION:  A point helper implementation

	CREATED BY: 

	HISTORY: created 14 July 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "helpers.h"

//------------------------------------------------------

#define AXIS_LENGTH 20.0f

void AxisViewportRect(ViewExp *vpt, const Matrix3 &tm, float length, Rect *rect);
void DrawAxis(ViewExp *vpt, const Matrix3 &tm, float length, BOOL sel=FALSE, BOOL frozen=FALSE);
Box3 GetAxisBox(ViewExp *vpt, const Matrix3 &tm,float length,int resetTM);

class PointHelpObject: public HelperObject {
	public:			
		// Class vars
		static HWND hParams;
		static IObjParam *iObjParams;
		static int dlgShowAxis;
		static float dlgAxisLength;

		// Snap suspension flag (TRUE during creation only)
		BOOL suspendSnap;
					
		// Params
		BOOL showAxis;
		float axisLength;
 		int extDispFlags;

		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );		
	
		PointHelpObject();
		~PointHelpObject();
		
		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		void SetExtendedDisplay(int flags);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_DB_POINT); }
		ObjectHandle ApplyTransform(Matrix3& matrix) {return this;}
		Interval ObjectValidity(TimeValue t) {return FOREVER;}
		int CanConvertToType(Class_ID obtype) {return FALSE;}
		Object* ConvertToType(TimeValue t, Class_ID obtype) {assert(0);return NULL;}		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		int DoOwnSelectHilite()	{ return 1; }

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(POINTHELP_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_POINTHELPER_CLASS)); }
		int IsKeyable(){ return 0;}
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
	};				


// class variable for point class.
HWND PointHelpObject::hParams = NULL;
IObjParam *PointHelpObject::iObjParams;

int PointHelpObject::dlgShowAxis = TRUE;
float PointHelpObject::dlgAxisLength = AXIS_LENGTH;

void resetPointParams() 
{
	PointHelpObject::dlgShowAxis = TRUE;
	PointHelpObject::dlgAxisLength = AXIS_LENGTH;
}


class PointHelpObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new PointHelpObject; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_POINT_CLASS); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(POINTHELP_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetPointParams(); }
	};

static PointHelpObjClassDesc pointHelpObjDesc;

ClassDesc* GetPointHelpDesc() { return &pointHelpObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;


BOOL CALLBACK PointParamProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	PointHelpObject *po = (PointHelpObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!po && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG: {
			po = (PointHelpObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			CheckDlgButton(hWnd,IDC_SHOWAXIS,po->showAxis);
			
			ISpinnerControl *spin = 
				GetISpinner(GetDlgItem(hWnd,IDC_AXISLENGHSPIN));
			spin->SetLimits(10,1000,FALSE);
			spin->SetScale(0.1f);
			spin->SetValue(po->axisLength,FALSE);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_AXISLENGTH),EDITTYPE_FLOAT);
			ReleaseISpinner(spin);
			return FALSE;
			}

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl*)lParam;
			po->axisLength = spin->GetFVal();
			po->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
			po->iObjParams->RedrawViews(po->iObjParams->GetTime());
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SHOWAXIS:
					po->showAxis = IsDlgButtonChecked(hWnd,IDC_SHOWAXIS);
					po->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
					po->iObjParams->RedrawViews(po->iObjParams->GetTime());
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	
	return TRUE;
	} 

void PointHelpObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	iObjParams = ip;
	if (!hParams) {
		hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_POINTPARAM),
				PointParamProc, 
				GetString(IDS_DB_PARAMETERS), 
				(LPARAM)this );
		ip->RegisterDlgWnd(hParams);
	} else {
		SetWindowLong(hParams,GWL_USERDATA,(LONG)this);
		CheckDlgButton(hParams,IDC_SHOWAXIS,showAxis);
		ISpinnerControl *spin = 
			GetISpinner(GetDlgItem(hParams,IDC_AXISLENGHSPIN));
		spin->SetValue(axisLength,FALSE);
		ReleaseISpinner(spin);
		}
	}
		
void PointHelpObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	dlgShowAxis = IsDlgButtonChecked(hParams, IDC_SHOWAXIS );
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hParams,IDC_AXISLENGHSPIN));
	dlgAxisLength = spin->GetFVal();
	ReleaseISpinner(spin);
	if (flags&END_EDIT_REMOVEUI) {
		ip->UnRegisterDlgWnd(hParams);
		ip->DeleteRollupPage(hParams);
		hParams = NULL;
	} else {
		SetWindowLong(hParams,GWL_USERDATA,0);
		}
	iObjParams = NULL;
	}


PointHelpObject::PointHelpObject()
	{	
	showAxis = dlgShowAxis;
	axisLength = dlgAxisLength;
	suspendSnap = FALSE;
	}

PointHelpObject::~PointHelpObject()
	{	
	}

class PointHelpObjCreateCallBack: public CreateMouseCallBack {
	PointHelpObject *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(PointHelpObject *obj) { ob = obj; }
	};

int PointHelpObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {	

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				#ifdef _3D_CREATE	
					mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_3D));
				#else	
					mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
				#endif
				break;
			case 1:
				#ifdef _3D_CREATE	
					mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_3D));
				#else	
					mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
				#endif
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return 0;
					}
				break;			
			}
	} else 
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}
	return 1;
	}

static PointHelpObjCreateCallBack pointHelpCreateCB;

CreateMouseCallBack* PointHelpObject::GetCreateMouseCallBack() {
	pointHelpCreateCB.SetObj(this);
	return(&pointHelpCreateCB);
	}

void PointHelpObject::SetExtendedDisplay(int flags)
	{
	extDispFlags = flags;
	}

void PointHelpObject::GetLocalBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) 
	{
	Matrix3 tm(1);
	tm.SetTrans(inode->GetObjectTM(t).GetTrans());
	if(showAxis)
		box = GetAxisBox(vpt,tm,showAxis?axisLength:0.0f, TRUE);
	else
		box = Box3(Point3(0,0,0), Point3(0,0,0));
	}

void PointHelpObject::GetWorldBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 tm;
	tm = inode->GetObjectTM(t);
	if(!(extDispFlags & EXT_DISP_ZOOM_EXT) && showAxis)
		box = GetAxisBox(vpt,tm,showAxis?axisLength:0.0f, FALSE);
	else
		box = Box3(tm.GetTrans(), tm.GetTrans());
	}


// From BaseObject
int PointHelpObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm(1);	
	HitRegion hitRegion;
	DWORD	savedLimits;
	Point3 pt(0,0,0);

	vpt->getGW()->setTransform(tm);
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();

   	tm = inode->GetObjectTM(t);		
	MakeHitRegion(hitRegion, type, crossing, 4, p);

	gw->setRndLimits(((savedLimits = gw->getRndLimits())|GW_PICK)&~GW_ILLUM);
	gw->setHitRegion(&hitRegion);
	gw->clearHitCode();

	if (showAxis) {
		DrawAxis(vpt,tm,axisLength);
		}
	vpt->getGW()->setTransform(tm);
	vpt->getGW()->marker(&pt,X_MRKR);

	gw->setRndLimits(savedLimits);
	
	if((hitRegion.type != POINT_RGN) && !hitRegion.crossing)
		return TRUE;
	return gw->checkHitCode();
	}

void PointHelpObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{
	if(suspendSnap)
		return;

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	
	gw->setTransform(tm);

	Matrix3 invPlane = Inverse(snap->plane);

	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Point2 fp = Point2((float)p->x, (float)p->y);
		Point2 screen2;
		IPoint3 pt3;

		Point3 thePoint(0,0,0);
		// If constrained to the plane, make sure this point is in it!
		if(snap->snapType == SNAP_2D || snap->flags & SNAP_IN_PLANE) {
			Point3 test = thePoint * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
			}
		gw->wTransPoint(&thePoint,&pt3);
		screen2.x = (float)pt3.x;
		screen2.y = (float)pt3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			else
			if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			}
		}
	}


int PointHelpObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 tm(1);
	Point3 pt(0,0,0);
	vpt->getGW()->setTransform(tm);
	tm = inode->GetObjectTM(t);		
	if (showAxis) {
		DrawAxis(vpt,tm,axisLength,inode->Selected(),inode->IsFrozen());
		}
	vpt->getGW()->setTransform(tm);
	if(!inode->IsFrozen())
		vpt->getGW()->setColor(LINE_COLOR,GetUIColor(COLOR_POINT_OBJ));
	vpt->getGW()->marker(&pt,X_MRKR);
	return(0);
	}



//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult PointHelpObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	return(REF_SUCCEED);
	}

ObjectState PointHelpObject::Eval(TimeValue time){
	return ObjectState(this);
	}

RefTargetHandle PointHelpObject::Clone(RemapDir& remap) {
	PointHelpObject* newob = new PointHelpObject();	
	newob->showAxis = showAxis;
	newob->axisLength = axisLength;
	return(newob);
	}


#define SHOW_AXIS_CHUNK		0x0100
#define AXIS_LENGTH_CHUNK	0x0110

IOResult PointHelpObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case SHOW_AXIS_CHUNK:
				res = iload->Read(&showAxis,sizeof(showAxis),&nb);
				break;
			case AXIS_LENGTH_CHUNK:
				res = iload->Read(&axisLength,sizeof(axisLength),&nb);
				break;
			}

		res = iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	
	return IO_OK;
	}

IOResult PointHelpObject::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(SHOW_AXIS_CHUNK);
	isave->Write(&showAxis,sizeof(showAxis),&nb);
	isave->EndChunk();

	isave->BeginChunk(AXIS_LENGTH_CHUNK);
	isave->Write(&axisLength,sizeof(axisLength),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}


/*--------------------------------------------------------------------*/
// 
// Stole this from scene.cpp
// Probably couldn't hurt to make an API...
//
//


void Text( ViewExp *vpt, TCHAR *str, Point3 &pt )
	{	
	vpt->getGW()->text( &pt, str );	
	}

static void DrawAnAxis( ViewExp *vpt, Point3 axis )
	{
	Point3 v1, v2, v[3];	
	v1 = axis * (float)0.9;
	if ( axis.x != 0.0 || axis.y != 0.0 ) {
		v2 = Point3( axis.y, -axis.x, axis.z ) * (float)0.1;
	} else {
		v2 = Point3( axis.x, axis.z, -axis.y ) * (float)0.1;
		}
	
	v[0] = Point3(0.0,0.0,0.0);
	v[1] = axis;
	vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );	
	v[0] = axis;
	v[1] = v1+v2;
	vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );
	v[0] = axis;
	v[1] = v1-v2;
	vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );
	}

#define ZFACT (float).005;

void DrawAxis( ViewExp *vpt, const Matrix3 &tm, float length, BOOL sel, BOOL frozen )
	{
	Matrix3 tmn = tm;
	float zoom;
	int limits;	

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	
	tmn.Scale( Point3(zoom,zoom,zoom) );
	vpt->getGW()->setTransform( tmn );	

	limits = vpt->getGW()->getRndLimits();
	vpt->getGW()->setRndLimits( limits & ~GW_Z_BUFFER );

	if (sel) {
		vpt->getGW()->setColor( TEXT_COLOR, GetUIColor(COLOR_SELECTION) );
		vpt->getGW()->setColor( LINE_COLOR, GetUIColor(COLOR_SELECTION) );
	} else if (!frozen) {
		vpt->getGW()->setColor( TEXT_COLOR, GetUIColor(COLOR_POINT_AXES) );
		vpt->getGW()->setColor( LINE_COLOR, GetUIColor(COLOR_POINT_AXES) );
		}
	
	Text( vpt, _T("x"), Point3(length,0.0f,0.0f) ); 
	DrawAnAxis( vpt, Point3(length,0.0f,0.0f) );	
	
	Text( vpt, _T("y"), Point3(0.0f,length,0.0f) ); 
	DrawAnAxis( vpt, Point3(0.0f,length,0.0f) );	
	
	Text( vpt, _T("z"), Point3(0.0f,0.0f,length) ); 
	DrawAnAxis( vpt, Point3(0.0f,0.0f,length) );	
	
	vpt->getGW()->setRndLimits( limits );
	}

Box3 GetAxisBox(ViewExp *vpt, const Matrix3 &tm,float length,int resetTM)
	{
	Matrix3 tmn = tm;
	Box3 box;
	float zoom;

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	if (zoom==0.0f) zoom = 1.0f;
//	tmn.Scale(Point3(zoom,zoom,zoom));
	length *= zoom;
	if(resetTM)
		tmn.IdentityMatrix();

	box += Point3(0.0f,0.0f,0.0f) * tmn;
	box += Point3(length,0.0f,0.0f) * tmn;
	box += Point3(0.0f,length,0.0f) * tmn;
	box += Point3(0.0f,0.0f,length) * tmn;	
	box += Point3(-length/5.f,0.0f,0.0f) * tmn;
	box += Point3(0.0f,-length/5.f,0.0f) * tmn;
	box += Point3(0.0f,0.0f,-length/5.0f) * tmn;
	box.EnlargeBy(10.0f/zoom);
	return box;
	}


inline void EnlargeRectIPoint3( RECT *rect, IPoint3& pt )
	{
	if ( pt.x < rect->left )   rect->left   = pt.x;
	if ( pt.x > rect->right )  rect->right  = pt.x;
	if ( pt.y < rect->top )    rect->top    = pt.y;
	if ( pt.y > rect->bottom ) rect->bottom = pt.y;
	}

// This is a guess - need to find real w/h.
#define FONT_HEIGHT	11
#define FONT_WIDTH  9	


static void AxisRect( GraphicsWindow *gw, Point3 axis, Rect *rect )
	{
	Point3 v1, v2, v;	
	IPoint3 iv;
	v1 = axis * (float)0.9;
	if ( axis.x != 0.0 || axis.y != 0.0 ) {
		v2 = Point3( axis.y, -axis.x, axis.z ) * (float)0.1;
	} else {
		v2 = Point3( axis.x, axis.z, -axis.y ) * (float)0.1;
		}
	v = axis;
	gw->wTransPoint( &v, &iv );
	EnlargeRectIPoint3( rect, iv);

	iv.x += FONT_WIDTH;
	iv.y -= FONT_HEIGHT;
	EnlargeRectIPoint3( rect, iv);

	v = v1+v2;
	gw->wTransPoint( &v, &iv );
	EnlargeRectIPoint3( rect, iv);
	v = v1-v2;
	gw->wTransPoint( &v, &iv );
	EnlargeRectIPoint3( rect, iv);
	}


void AxisViewportRect(ViewExp *vpt, const Matrix3 &tm, float length, Rect *rect)
	{
	Matrix3 tmn = tm;
	float zoom;
	IPoint3 wpt;
	Point3 pt;
	GraphicsWindow *gw = vpt->getGW();

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	
	tmn.Scale( Point3(zoom,zoom,zoom) );
	gw->setTransform( tmn );	
	pt = Point3(0.0f, 0.0f, 0.0f);
	gw->wTransPoint( &pt, &wpt );
	rect->left = rect->right  = wpt.x;
	rect->top  = rect->bottom = wpt.y;

	AxisRect( gw, Point3(length,0.0f,0.0f),rect );	
	AxisRect( gw, Point3(0.0f,length,0.0f),rect );	
	AxisRect( gw, Point3(0.0f,0.0f,length),rect );	

	rect->right  += 2;
	rect->bottom += 2;
	rect->left   -= 2;
	rect->top    -= 2;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\grid\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by grid.rc
//
#define IDS_PIVOT                       1
#define IDS_GRID_INT                    1
#define IDS_BBOX                        2
#define IDS_GRID_EDGES                  2
#define IDS_LIB_DESCRIPTION             3
#define IDB_ICONS                       101
#define IDB_MASK                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Objects\Helpers\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by helpers.rc
//
#define IDS_DB_GRID                     1
#define IDS_DB_GENERAL                  2
#define IDS_DB_PARAMETERS               3
#define IDS_DB_POINT                    4
#define IDS_DB_POINTHELPER              5
#define IDS_DS_PARAMCHG                 6
#define IDS_DB_LINE                     7
#define IDS_DB_LINEHELPER               8
#define IDS_DB_GRID_CLASS               9
#define IDS_DB_POINTHELPER_CLASS        10
#define IDS_DB_POINT_CLASS              11
#define IDS_TH_LENGTH                   12
#define IDS_TH_WIDTH                    13
#define IDS_DB_GRID_NODENAME            14
#define IDS_DB_GRIDHELPER               15
#define IDS_RB_DEFHELPERS               16
#define IDS_JH_GRID2_CLASS              17
#define IDB_SPINNER                     102
#define IDC_SPINNERCUR                  103
#define IDD_GRIDRENDER                  109
#define IDD_BOXPARAM                    110
#define IDD_POINTPARAM                  110
#define IDD_TAPEHELPER                  111
#define IDD_GRIDPARAM                   116
#define IDD_GRIDPARAM2                  117
#define IDC_SEGSPINNER                  1004
#define IDC_RADSPINNER                  1005
#define IDC_LENGTH                      1007
#define IDC_LENSPINNER                  1008
#define IDC_WIDTH                       1009
#define IDC_WIDTHEDIT                   1009
#define IDC_LENSPINNER2                 1009
#define IDC_HEIGHT                      1010
#define IDC_GRIDSPINNER                 1010
#define IDC_SEGS                        1010
#define IDC_AXISLENGTH                  1010
#define IDC_WIDTHSPINNER                1011
#define IDC_THICKSPINNER                1011
#define IDC_LENSPINNER3                 1011
#define IDC_GRID                        1012
#define IDC_THICK                       1012
#define IDC_SNAPSPINNER                 1013
#define IDC_MINSUBDIV                   1013
#define IDC_SNAP                        1014
#define IDC_MINSUBDIVSPINNER            1014
#define IDC_OXSPINNER                   1015
#define IDC_MAJOR                       1015
#define IDC_ORIENTX                     1016
#define IDC_MAJORSPINNER                1016
#define IDC_OYSPINNER                   1017
#define IDC_ORIENTY                     1018
#define IDC_OZSPINNER                   1019
#define IDC_ORIENTZ                     1020
#define IDC_MATCHOBJ                    1040
#define IDC_MATCHSURF                   1041
#define IDC_DIVS                        1042
#define IDC_DIVSPINNER                  1043
#define IDC_HEIGHTSPINNER               1044
#define IDC_AXISLENGHSPIN               1044
#define IDC_ACTIVATE                    1045
#define IDC_SHOWAXIS                    1046
#define IDC_SPEC_LEN                    1047
#define IDC_TICKMARKS                   1048
#define IDC_LENGTHEDIT                  1049
#define IDC_GRID_GRAY_COLOR             1050
#define IDC_LENGTHEDIT2                 1050
#define IDC_GRID_OBJECT_COLOR           1051
#define IDC_LENGTHEDIT3                 1051
#define IDC_GRID_HOME_COLOR             1052
#define IDC_GRID_HOME_INTENSITY         1053
#define IDC_GRID_XY_PLANE               1054
#define IDC_GRID_YZ_PLANE               1055
#define IDC_GRID_ZX_PLANE               1056
#define IDC_CHECK_ALLPLANES             1057
#define IDC_CHECK_AUTOSIZE              1058
#define IDC_CHECK_SUBDIVISION           1059
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1059
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\pivot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pivot.rc
//
#define IDS_PIVOT                       1
#define IDS_BBOX                        2
#define IDS_LIB_DESCRIPTION             3
#define IDB_ICONS                       101
#define IDB_MASK                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\grid\data.h ===
/*****************************************************************************
 *<
	FILE: data.h

	DESCRIPTION:  Marker data for the grid snap

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/

//DAta for the markers
static IPoint3 mark0verts[5]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(5,      5,      0)
};

static int mark0es[5]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\grid\grid.cpp ===
/*****************************************************************************
 *<
	FILE: grid.cpp

	DESCRIPTION:  Snaps to grids

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
// The main MAX include file.
#include "max.h"

//master include file for osnaps
#include "osnapapi.h"

#include "data.h"
#include "resource.h"

#define SUBCOUNT 2
#define NOSUB -1
#define INT_SUB 0
#define EDGE_SUB 1
#define SMALLVALUE	(float)1.0e-10		//for use in fixing bug #162291


// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

TCHAR *GetString(int id);


class gridSnap : public Osnap {

private:
	OsnapMarker markerdata[SUBCOUNT];
	TSTR name[SUBCOUNT];
	HBITMAP tools;
	HBITMAP masks;

public:

	gridSnap();//constructor
	virtual ~gridSnap();

	virtual int numsubs(){return SUBCOUNT;} //the number of subsnaps this guy has
	virtual TSTR *snapname(int index); // the snaps name to be displayed in the UI
	virtual boolean ValidInput(SClass_ID scid, Class_ID cid); 
	Class_ID ClassID() { return GRID_OSNAP_CLASS_ID; }

	virtual OsnapMarker *GetMarker(int index){return &(markerdata[index]);} 
	virtual HBITMAP getTools(){return tools;} 
	virtual HBITMAP getMasks(){return masks;} 
	virtual WORD AccelKey(int index); //virtual key codes
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t);
	virtual WORD HiliteMode(){return HILITE_CROSSHAIR;}
};



TSTR *gridSnap::snapname(int index)
{
	return &name[index];
}


WORD gridSnap::AccelKey(int index)
{
	switch (index)
	{
	case INT_SUB:
		return 0x4F;
		break;
	case EDGE_SUB:
		return 0x42;
		break;
	default:
		return 0;
	}
}


gridSnap::gridSnap()
{
	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));
	name[INT_SUB]= TSTR(GetString(IDS_GRID_INT));
	name[EDGE_SUB]= TSTR(GetString(IDS_GRID_EDGES));
	markerdata[0]=OsnapMarker(5,mark0verts,mark0es);
	markerdata[1]=OsnapMarker(5,mark0verts,mark0es);
}

gridSnap::~gridSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}

boolean gridSnap::ValidInput(SClass_ID scid, Class_ID cid){
/*	boolean c_ok = FALSE, sc_ok = FALSE;
	sc_ok |= (scid == HELPER_CLASS_ID)? TRUE : FALSE;
	c_ok |= (cid == Class_ID(GRIDHELP_CLASS_ID,0))? TRUE : FALSE; 
	return sc_ok && c_ok;*/
	return theman->GetNode()->IsRootNode();
}

float GridCoord(float v, float g)
{
//	assert(g != 0.0f);

	if (g == 0.0f)
			g = SMALLVALUE;
	float vwork = (float)floor((fabs(v)+0.5f*g)/g)*g;	
	return (v < 0.0f) ? -vwork : vwork;
}			

#define PESRP_THRESH 50
int Screendist(IOsnapManager *theman, Point3 pt1, Point3 pt2)
{
	//computes the distance between two world points in screen space
	IPoint3 screen1_3, screen2_3;
	IPoint2 screen1, screen2;
	theman->wTranspoint(&pt1, &screen1_3);
	theman->wTranspoint(&pt2, &screen2_3);
	screen1.x = screen1_3.x;
	screen1.y = screen1_3.y;
	screen2.x = screen2_3.x;
	screen2.y = screen2_3.y;

	return Length(screen1-screen2);
}

BOOL NotTooDistant(IOsnapManager *theman, Point3 pt, float gridsize)
{
	//determiens if the nearest neighboring grid point is resolvable with 
	// an aperture of PERSP_THRESH
	Point3 xadd, yadd;
	xadd = pt + Point3(gridsize, 0.0f, 0.0f);
	yadd = pt + Point3(0.0f, gridsize, 0.0f);
	int xdist, ydist;
	xdist = Screendist(theman, pt, xadd );
	ydist = Screendist(theman, pt, yadd);
	float measure1 = min(xdist/(float)(xdist + ydist), ydist/(float)(xdist + ydist));
	int measure = xdist * ydist;
	if(measure > PESRP_THRESH )
		return TRUE;
	else 
		return FALSE;
}

static BOOL clipgrid(Point3 wp, ViewExp *vpt)
{
	if(!vpt->IsPerspView())
		return TRUE;
	float minx, miny, maxx, maxy;
	vpt->GetGridDims(&minx, &maxx, &miny, &maxy);
	if(wp.x > minx && wp.x < maxx && wp.y > miny && wp.y < maxy)
		return TRUE;
	else 
		return FALSE;
}



void gridSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{	
	HitMesh *hitmesh;
	ViewExp *vpt = theman->GetVpt();

	//local copy of the cursor position
	Point2 fp = Point2((float)p->x, (float)p->y);

	BOOL got_one= FALSE;
	//Get point on the consttruction plane 
	Point3 local_cp = vpt->GetPointOnCP(*p);
	Point3 world_snapped;

	Matrix3 tmconst;
	vpt->GetConstructionTM( tmconst );


	// Get the grid size
	float grid = theman->GetVpt()->GetGridSize();
//	Matrix3 tm = theman->GetNode()->GetObjectTM(t);
//	Point3 local = Inverse(tm) * world;


	//Compute all the hit point candidates
	if(	GetActive(INT_SUB))
	{
		Point3 intsnapped = Point3(GridCoord(local_cp.x,grid),GridCoord(local_cp.y,grid),0.0f);
		world_snapped = tmconst * intsnapped;//now in world space
		if(CheckPotentialHit(&world_snapped,0, fp))
		{
			got_one = TRUE;
			hitmesh = new HitMesh(5);

			hitmesh->setVert(0,tmconst * Point3(intsnapped.x,intsnapped.y - grid,0.0f));
			hitmesh->setVert(1,tmconst * Point3(intsnapped.x,intsnapped.y + grid,0.0f));
			hitmesh->setVert(2,tmconst * Point3(intsnapped.x-grid,intsnapped.y,0.0f));
			hitmesh->setVert(3,tmconst * Point3(intsnapped.x + grid,intsnapped.y,0.0f));

			//now register a hit with the osnap manager
			//possibly screen for proximity to the foreground
//			if(1)//(NotTooDistant(theman, world_snapped, grid))
			if(clipgrid(world_snapped, vpt))
				theman->RecordHit(new OsnapHit(world_snapped, this, INT_SUB, hitmesh));
			else 
				delete hitmesh;
		}
	}


	if(	GetActive(EDGE_SUB) && !got_one)
	{
		BOOL snapx = FALSE;
		float xSnap = GridCoord(local_cp.x,grid);
		float ySnap = GridCoord(local_cp.y,grid);
		float xDist = (float)fabs(xSnap - local_cp.x);
		float yDist = (float)fabs(ySnap - local_cp.y);
		Point3 esnapped;

		// Which one is closer?
		if(xDist < yDist)
		{
			snapx = TRUE;
			esnapped = Point3(xSnap,local_cp.y,0.0f);
		}
		else
		{
			esnapped = Point3(local_cp.x,ySnap,0.0f);
		}

		world_snapped = tmconst * esnapped;//now in world space

		if (CheckPotentialHit(&world_snapped,0, fp))
		{
			hitmesh = new HitMesh(3);
			got_one = TRUE;
			if(snapx)
			{
				hitmesh->setVert(0,tmconst * Point3(esnapped.x,esnapped.y - grid,0.0f));
				hitmesh->setVert(1,tmconst * Point3(esnapped.x,esnapped.y + grid,0.0f));
			}
			else
			{
				hitmesh->setVert(0,tmconst * Point3(esnapped.x - grid, esnapped.y,0.0f));
				hitmesh->setVert(1,tmconst * Point3(esnapped.x + grid, esnapped.y,0.0f));
			}

			if(clipgrid(world_snapped, vpt))
				theman->RecordHit(new OsnapHit(world_snapped, this, EDGE_SUB, hitmesh));
			else
				delete hitmesh;
		}
	}

}


//static gridSnap thegridSnap;

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}


/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class OsnapClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 0; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) {return new gridSnap();}
//	void *			Create(OsnapManager *pman) { return new gridSnap(pman); }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return _T("gridSnap"); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return GRID_OSNAP_CLASS_ID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return _T(""); }
	};

// Declare a static instance of the class descriptor.
static OsnapClassDesc sampDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSampDesc() { return &sampDesc; }

/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSampDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\pivot\pivot.cpp ===
/*****************************************************************************
 *<
	FILE: pivot.cpp

	DESCRIPTION:  Snaps to pivots

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
// The main MAX include file.
#include "max.h"

//master include file for osnaps
#include "osnapapi.h"

#include "data.h"
#include "resource.h"

#define SUBCOUNT 2
#define NOSUB -1
#define PIV_SUB 0
#define BBOX_SUB 1

typedef Tab<Point3> Point3Tab;

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

TCHAR *GetString(int id);

#define PIVOT_OSNAP_CLASS_ID Class_ID(0x24960fd5, 0x343a4913)

class PivotSnap : public Osnap {

private:
	OsnapMarker markerdata[SUBCOUNT];
	TSTR name[SUBCOUNT];
	HBITMAP tools;
	HBITMAP masks;

public:

	PivotSnap();//constructor
	virtual ~PivotSnap();

	virtual int numsubs(){return SUBCOUNT;} //the number of subsnaps this guy has
	virtual TSTR *snapname(int index); // the snaps name to be displayed in the UI
	virtual boolean ValidInput(SClass_ID scid, Class_ID cid);// supports anything 
	Class_ID ClassID() { return PIVOT_OSNAP_CLASS_ID; }

	virtual OsnapMarker *GetMarker(int index){return &(markerdata[index]);} 
	virtual HBITMAP getTools(){return tools;} 
	virtual HBITMAP getMasks(){return masks;} 
	virtual WORD HiliteMode(){return HILITE_BOX;}
	virtual WORD AccelKey(int index); //virtual key codes
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t);
};



TSTR *PivotSnap::snapname(int index){
	return &name[index];
}


WORD PivotSnap::AccelKey(int index){
	switch (index){
	case PIV_SUB:
		return 0x4F;
		break;
	case BBOX_SUB:
		return 0x42;
		break;
	default:
		return 0;
	}
}


PivotSnap::PivotSnap()
{
	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));
	name[PIV_SUB]= TSTR(GetString(IDS_PIVOT));
	name[BBOX_SUB]= TSTR(GetString(IDS_BBOX));
	markerdata[0]=OsnapMarker(5,mark0verts,mark0es);
	markerdata[1]=OsnapMarker(13,mark1verts,mark1es);
};

PivotSnap::~PivotSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}

boolean PivotSnap::ValidInput(SClass_ID scid, Class_ID cid){

	//JH 6/17/99
	//The implementation of the snap manager assumes that any nodes which record hits
	//will still be around when the scenetraversal ends. With the introduction of autogrid
	//this assumption is clearly wrong since the temporary grid object comes and goes.
	//The short term fix is to avoid snapping to these grid objects.
	if(theman->GetNode() == GetCOREInterface()->GetActiveGrid())
		return FALSE;


	boolean c_ok = FALSE, sc_ok = FALSE;
	sc_ok |= (scid == GEOMOBJECT_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == SHAPE_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == CAMERA_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == LIGHT_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == HELPER_CLASS_ID)? TRUE : FALSE;
//	c_ok |= (cid == Class_ID(0xe44f10b3,0))? TRUE : FALSE; 
	return sc_ok;
}

static BOOL EssentiallyEmpty(Box3 &box)
{
	Point3 p2(0.01f,0.01f,0.01f);
	Point3 p1(-0.01f,-0.01f,-0.01f);
	if(box.pmin == p1 && box.pmax == p2)
		return TRUE;
	return FALSE;
}

void PivotSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{	
	// This snap computes the bounding box points of a node as 
	// well as the pivot point

	//local copy of the cursor position
	Point2 fp = Point2((float)p->x, (float)p->y);

	//In this snap mode we actually need to get a pointer to the node so that we 
	// can check for WSM's and compute the pivot point
	INode *inode = theman->GetNode();
	Matrix3 atm; //This will hold the nodes tm before WSMs

	//See if this guys has any spacewarps applied
	BOOL wsm = (BOOL) inode->GetProperty(PROPID_HAS_WSM);

	//If it does then we'll need to get a meaningful tm as follows
	if(wsm)
		atm = inode->GetObjTMBeforeWSM(t);

	//get the node's bounding box
	Box3 box;
	box.Init();
	pobj->GetDeformBBox(t, box, NULL );

	if(EssentiallyEmpty(box))
		pobj->GetLocalBoundBox(t, inode, theman->GetVpt() , box);

		//We need a hitmesh which shows the bounding box of the node
	//This automatic variable gets passed to the hitmesh copy constructor
	// in every case
	HitMesh thehitmesh, *phitmesh;
	thehitmesh.setNumVerts(8);
	for(int jj = 0;jj<8;++jj)
		thehitmesh.setVert(jj,box[jj]);


	BOOL got_one= FALSE;

	//Compute all the hit point candidates
	if(	GetActive(PIV_SUB))
	{
		got_one = FALSE;
		Point3 *pivpt;

		if(wsm)
			pivpt = new Point3(atm.GetTrans() - inode->GetObjOffsetPos());
		else
			pivpt = new Point3(-inode->GetObjOffsetPos());

		//Make a hitmesh
		phitmesh = new HitMesh(thehitmesh);

		//now register a hit with the osnap manager
		theman->RecordHit(new OsnapHit(*pivpt, this, PIV_SUB, phitmesh));
	}

	if(	GetActive(BBOX_SUB))
	{

		//set up our highlight mesh
		for(int ii = 0;ii<8;++ii)
		{
			phitmesh = new HitMesh(thehitmesh);

			theman->RecordHit(new OsnapHit(box[ii], this, BBOX_SUB, phitmesh));
		}
	}


};


//static PivotSnap thePivotSnap;

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class OsnapClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 0; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) {return new PivotSnap();}
//	void *			Create(OsnapManager *pman) { return new PivotSnap(pman); }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return _T("PivotSnap"); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return PIVOT_OSNAP_CLASS_ID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return _T(""); }
	};

// Declare a static instance of the class descriptor.
static OsnapClassDesc sampDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSampDesc() { return &sampDesc; }

/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSampDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\pivot\data.h ===
/*****************************************************************************
 *<
	FILE: data.h

	DESCRIPTION:  Marker data for the pivot snap

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/

//DAta for the markers
static IPoint3 mark0verts[5]=
{ 
 IPoint3(0,      5,      0),
 IPoint3(0,      0,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(0,      0,      0)
};

static int mark0es[5]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};


static IPoint3 mark1verts[13]=
{ 
 IPoint3(0,      5,      0),
 IPoint3(-2,     5,      0),
 IPoint3(2,      5,      0),
 IPoint3(5,      5,      0),

 IPoint3(5,     2,      0),
 IPoint3(5,      -2,      0),
 IPoint3(5,      -5,      0),

 IPoint3(2,     -5,      0),
 IPoint3(-2,      -5,      0),
 IPoint3(-5,      -5,      0),

 IPoint3(-5,     -2,      0),
 IPoint3(-5,      2,      0),
 IPoint3(-5,      5,      0)
};

static int mark1es[13]=
{
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\shape1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shape1.rc
//
#define IDS_ACC_VERT                    1
#define IDS_ACC_END                     2
#define IDS_ACC_EDGE                    3
#define IDS_ACC_MID                     4
#define IDS_VERT                        5
#define IDS_ARC                         5
#define IDS_END                         6
#define IDS_PERP                        6
#define IDS_EDGE                        7
#define IDS_TAN                         7
#define IDS_MID                         8
#define IDS_INT                         8
#define IDS_LIB_DESCRIPTION             8
#define IDB_BITMAP1                     101
#define IDB_ICONS                       105
#define IDB_MASK                        106
#define IDB_TOOLS                       290
#define IDB_MASKS                       291

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\sphere\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sphere.rc
//
#define IDS_CENTER                      1
#define IDS_QUAD                        2
#define IDS_LIB_DESCRIPTION             3
#define IDB_BITMAP1                     101
#define IDB_MASK                        104
#define IDB_ICONS                       105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\shape1\shape.cpp ===
/*****************************************************************************
 *<
	FILE: Shape.cpp

	DESCRIPTION:  Implementation of an Osnap for ShapeObjects
					Provides perpendicular and tangent snapping

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
// The main MAX include file.
#include "max.h"
//some other classes 
#include "polyshp.h"
#include "splshape.h"
#include "tab.h"

#include <assert.h>
#include <float.h>

//master include file for osnaps
#include "osnapapi.h"

#include "resource.h"
#include "data.h"


#define SUBCOUNT 2
#define NOSUB -1
#define PERP_SUB 0
#define TAN_SUB 1

#define TAN_TOLERANCE 0.001

//flags for extended perpendiculars
#define NEG	0
#define POS 1
#define BOTH 2

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;


//some prototypes
Point3 *PerpToSeg(const Point3 k, const Point3 l, const Point3 m, const BOOL extend = FALSE, const int extdir = -1);

Point3 *TanToSeg(const Point3 k, const Point3 l, const Point3 m);

TCHAR *GetString(int id);

#define SHAPE1_SNAP_CLASS_ID Class_ID(0x1f120de7, 0x30bc716f)

class ShapeSnap : public Osnap {
private:
	boolean active[SUBCOUNT];
	TSTR name[SUBCOUNT];
	OsnapMarker markerdata[SUBCOUNT];
	HBITMAP tools;
	HBITMAP masks;
	float paramval;

public:

	ShapeSnap();//constructor
	virtual ~ShapeSnap();

	virtual int numsubs(){return SUBCOUNT;} //the number of subsnaps this guy has
	virtual TSTR *snapname(int index); // the snaps name to be displayed in the UI
	virtual boolean ValidInput(SClass_ID scid, Class_ID cid);// the type of object that it recognizes SPHERE_CLASS_ID 
	Class_ID ClassID() { return SHAPE1_SNAP_CLASS_ID; }

	virtual OsnapMarker *GetMarker(int index){return &(markerdata[index]);} // single object might contain subsnaps
	virtual HBITMAP getTools(){return tools;} // single object might contain subsnaps
	virtual HBITMAP getMasks(){return masks;} // single object might contain subsnaps
	virtual WORD AccelKey(int index);
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t);

	void PointsOnPolyLine_Tan(PolyLine& pline,  const Point3& relpoint);
	void PointsOnPolyShape_Tan(const PolyShape& pshape,  const Point3& relpoint);
	void PointsOnPolyLine_Perp(PolyLine& pline, const Point3& relpoint);
	void PointsOnPolyShape_Perp(const PolyShape& pshape, const Point3& relpoint);

};


TSTR *ShapeSnap::snapname(int index){
	return &(name[index]);
}



ShapeSnap::ShapeSnap(){ //constructor
	active[PERP_SUB] = FALSE;
	active[TAN_SUB] = FALSE;

	name[PERP_SUB] = TSTR( GetString(IDS_PERP));
	name[TAN_SUB] = TSTR( GetString(IDS_TAN));

	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));

	markerdata[0]=OsnapMarker(8,mark0verts,mark0es);
	markerdata[1]=OsnapMarker(11,mark1verts,mark1es);

	paramval = 0.5f;

};

ShapeSnap::~ShapeSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}


boolean ShapeSnap::ValidInput(SClass_ID scid, Class_ID cid){
	boolean c_ok = FALSE, sc_ok = FALSE;
	sc_ok |= (scid == SHAPE_CLASS_ID)? TRUE : FALSE;
//	c_ok |= (cid == Class_ID(SPLINESHAPE_CLASS_ID,0))? TRUE : FALSE; 
//	c_ok |= (cid == Class_ID(PATCHOBJ_CLASS_ID,0))? TRUE : FALSE; 
	return sc_ok;
}


WORD ShapeSnap::AccelKey(int index){
	switch (index){
/*	case ARC_SUB:
		return 0x41;
		break;
	*/
	case PERP_SUB:
		return 0x50;
		break;
	case TAN_SUB:
		return 0x54;
		break;
	default:
		return 0;
	}
}

Point3 *PerpToSeg(const Point3 k, const Point3 l, const Point3 m, const BOOL extend, const int extflag)
{
	Point3 mk(m-k), lk(l-k);
	if(Length(mk^lk) < FLT_EPSILON)
		return NULL; //colinear TODO optimize
	float s = DotProd(mk,lk)/DotProd(lk,lk);
	
	//	if (s<0.0f || s>1.0f)
	if ((s<0.0f || s>1.0f) && !extend)
		return NULL;
	if(extflag == POS && s<0.0f)
		return NULL;
	if(extflag == NEG && s>1.0f)
		return NULL;

	// we're ok so return the computed point
	return new Point3(k + (s * lk));
}

Point3 *TanToSeg(const Point3 k, const Point3 l, const Point3 m)
{
	Point3 mk(m-k), lk(l-k);
//	if(Length(mk^lk) < TAN_TOLERANCE)
	float costheta = (float)fabs(DotProd(mk,lk)/sqrt(DotProd(lk,lk) * DotProd(mk,mk)));
	if (1.0f - costheta < TAN_TOLERANCE)
		return new Point3(k);
	else 
		return NULL;
}


void ShapeSnap::PointsOnPolyLine_Perp(PolyLine& pline, const Point3& relpoint)
{
	BOOL open = !pline.IsClosed();
	Point3 *ppoint;
	PolyPt *p1 = pline.pts;
	PolyPt *p2 = p1 + 1;
	int segs = pline.Verts()-1;
//watje 3-7-99 fix to handle hidden spline segs
	BOOL vis = TRUE;
	for (int i=0; i<segs; ++i, p1++, p2++)
	{
		BOOL extend = open && (segs==1 || i==0 || i==segs-1)?TRUE:FALSE;
		int look = -1;
		
		// if we need to look for an extended perpendicular,
		// figure out if we should look beyond the end of the last segment
		// or before the beginning of the first
		// or possibly look both ways in the case of a single segment poly
		if(extend){
			if(segs == 1)
				look = BOTH;
			else if(i==0)
				look = NEG;
			else if(i==segs-1)
				look = POS;
		}

		PolyPt ppt = pline.pts[i];
		if (ppt.flags & POLYPT_VISEDGE)
			vis = TRUE;
		else if (ppt.flags & POLYPT_INVIS_EDGE)
			vis = FALSE;
		if (vis)
			if(ppoint = PerpToSeg(p1->p,p2->p,relpoint,extend,look))
				theman->RecordHit(new OsnapHit(*ppoint, this, PERP_SUB, NULL));
//			AddCandidate(ppoint);
	}
	
	//if this guy is closed, check the closing segment
	if (!open)
		if (vis)
			if(ppoint = PerpToSeg(pline.pts->p,p1->p,relpoint))
				theman->RecordHit(new OsnapHit(*ppoint, this, PERP_SUB, NULL));
}

void ShapeSnap::PointsOnPolyLine_Tan(PolyLine& pline, const Point3& relpoint)
{
	Point3 *ppoint;
	PolyPt *p1 = pline.pts;
	PolyPt *p2 = p1 + 1;
	int segs = pline.Verts()-1;
//watje 3-7-99 fix to handle hidden spline segs
	BOOL vis = TRUE;

	for (int i=0; i<segs; ++i, p1++, p2++)
		{
		PolyPt ppt = pline.pts[i];
		if (ppt.flags & POLYPT_VISEDGE)
			vis = TRUE;
		else if (ppt.flags & POLYPT_INVIS_EDGE)
			vis = FALSE;
		if (vis)
			if(ppoint = TanToSeg(p1->p,p2->p,relpoint))
				theman->RecordHit(new OsnapHit(*ppoint, this, TAN_SUB, NULL));
		}
	
	if (pline.IsClosed())
		if (vis)
			if(ppoint = TanToSeg(pline.pts->p,p1->p,relpoint))
				theman->RecordHit(new OsnapHit(*ppoint, this, TAN_SUB, NULL));
}

void ShapeSnap::PointsOnPolyShape_Perp(const PolyShape& pshape, const Point3& relpoint)
{
	for(int i=0;i<pshape.numLines;++i)
		PointsOnPolyLine_Perp(pshape.lines[i], relpoint);
}

void ShapeSnap::PointsOnPolyShape_Tan(const PolyShape& pshape, const Point3& relpoint)
{
	for(int i=0;i<pshape.numLines;++i)
		PointsOnPolyLine_Tan(pshape.lines[i], relpoint);
}


void ShapeSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{	
	if(!theman->OKForRelativeSnap())
		return;
	Point3 relpoint(theman->GetRefPoint());//the last point the user clicked.
	int flags = 0;
	int savedLimits;

// relpoint should really be returned in the active node's space
	Matrix3 tm = theman->GetNode()->GetObjectTM(t);

//transform the relative point into the node's coordinate system
	relpoint = Inverse(tm) * relpoint;

//save the point that was passed in 
	Point2 fp = Point2((float)p->x, (float)p->y);
	IPoint2 ifp = IPoint2((int)p->x, (int)p->y);

//Check if we're even hitting the shape, if not return
	HitRegion hr;
	hr.type = POINT_RGN;
	hr.epsilon = theman->GetSnapStrength();
	hr.pt.x = p->x;
	hr.pt.y = p->y;

	ViewExp *vpt = theman->GetVpt();
	GraphicsWindow *gw = vpt->getGW();

	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->setHitRegion(&hr);
	gw->clearHitCode();

	if(0 == pobj->HitTest(t, theman->GetNode(), HITTYPE_POINT, TRUE, flags & HIT_ABORTONHIT, &ifp, vpt)) 
		return;

	//Now convert this into a splineshape 
//	SplineShape *splobj;
//	if(pobj->CanConvertToType(splineShapeClassID))
//		splobj = (SplineShape *)pobj->ConvertToType(t, splineShapeClassID);
//	else return;
//	assert(splobj);
	Point3Tab thepoints;

	if(	GetActive(PERP_SUB))
	{
		//Now compute the points on the splines and do the snapping	
		PolyShape pshp;
		((ShapeObject *)pobj)->MakePolyShape(t, pshp, -1, FALSE);
//		splobj->GetShape().MakePolyShape(pshp, -1, FALSE);
		PointsOnPolyShape_Perp(pshp, relpoint); 
	}

	if(	GetActive(TAN_SUB)) //Tangent snapping
	{
		//Now compute the points on the splines and do the snapping	
		PolyShape pshp;
		((ShapeObject *)pobj)->MakePolyShape(t, pshp, PSHAPE_BUILTIN_STEPS, FALSE);
//		splobj->GetShape().MakePolyShape(pshp, PSHAPE_BUILTIN_STEPS, FALSE);
		PointsOnPolyShape_Tan(pshp, relpoint); 
	}
//	if(splobj != pobj)
//		splobj->DeleteThis();
}



TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class ShapeClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 0; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) {return new ShapeSnap();}
//	void *			Create(OsnapManager *pman) { return new ShapeSnap(pman); }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return _T("ShapeSnap"); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return SHAPE1_SNAP_CLASS_ID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return _T(""); }
	};

// Declare a static instance of the class descriptor.
static ShapeClassDesc sampDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSampDesc() { return &sampDesc; }

/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSampDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\sphere\sphere.cpp ===
/*****************************************************************************
 *<
	FILE: sphere.cpp

	DESCRIPTION:  An example object snap
				  This plugin will respond to spheres and supports two subsnaps:
				  quadrant and center. Center being the (0,0,0) point in object space. 
				  The quadrants are the points (+-r,0,0),(0,+-r,0),(0,0,+-r) in object space.
				  Note that the snap points are computed in object space and that the plugin
				  need not worry about the node tm. 

	CREATED BY: John Hutchinson		

	HISTORY: created 6/17/97

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
// The main MAX include file.
#include "max.h"

//master include file for osnaps
#include "osnapapi.h"

//#include "data.h"
#include "resource.h"

//include the header file which defines the class to which we're gonna snap
#include "simpobj.h"

//An osnap can support multiple subsnaps. The following constants are for discriminating
//between them. In this case we'll have two. 
#define SUBCOUNT 2
#define NOSUB -1
#define CENTER_SUB 0
#define QUAD_SUB 1

//typedef Tab<Point3> Point3Tab;

// This is the DLL instance handle passed in when the plug-in is 
// loaded at startup.
HINSTANCE hInstance;

TCHAR *GetString(int id);

#define SPHERE_OSNAP_CLASS_ID Class_ID(0x12b51e31, 0x232101d2)

class SphereSnap : public Osnap {

private:
//	OsnapMarker markerdata[SUBCOUNT];
	TSTR name[SUBCOUNT]; //A local array of our subsnap names 
	HBITMAP tools; //a handle to the bitmaps
	HBITMAP masks; // a handle to the masks

public:

	SphereSnap();//constructor
	virtual ~SphereSnap();

	virtual int numsubs(){return SUBCOUNT;} //the number of subsnaps this guy has
	virtual TSTR *snapname(int index); // the snaps name to be displayed in the UI
	virtual TCHAR* Category(){return _T("How To");}
	Class_ID ClassID() { return SPHERE_OSNAP_CLASS_ID; }

	virtual boolean ValidInput(SClass_ID scid, Class_ID cid);// supports anything 

	virtual OsnapMarker *GetMarker(int index){return NULL;} 
	virtual HBITMAP getTools(){return tools;} 
	virtual HBITMAP getMasks(){return masks;} 
	virtual WORD AccelKey(int index); //virtual key codes
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t);
};



TSTR *SphereSnap::snapname(int index){
	return &name[index];
}


WORD SphereSnap::AccelKey(int index){
	switch (index){
	case CENTER_SUB:
		return 0x4F;
		break;
	case QUAD_SUB:
		return 0x42;
		break;
	default:
		return 0;
	}
}


SphereSnap::SphereSnap()
{
	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));
	name[CENTER_SUB]= TSTR(GetString(IDS_CENTER));
	name[QUAD_SUB]= TSTR(GetString(IDS_QUAD));
};

SphereSnap::~SphereSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}

boolean SphereSnap::ValidInput(SClass_ID scid, Class_ID cid){
	boolean c_ok = FALSE, sc_ok = FALSE;
	sc_ok |= (scid == GEOMOBJECT_CLASS_ID)? TRUE : FALSE;
	c_ok |= (cid == Class_ID(SPHERE_CLASS_ID,0))? TRUE : FALSE; 
	return sc_ok && c_ok;
}


void SphereSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{	
	// This snap computes the center of spheres as well as it's quadrants 

	//local copy of the cursor position
	Point2 fp = Point2((float)p->x, (float)p->y);



	BOOL got_one= FALSE;

	//Check if the center snap is turned on.
	//If so compute the center
	if(	GetActive(CENTER_SUB))
	{
		//The center in object space is just the object space origin
		Point3 centerpt(0.0f, 0.0f, 0.0f);

		//now register a hit with the osnap manager
		if(CheckPotentialHit(&centerpt,0,fp))
			//CheckPotentialHit returns TRUE if the point is within snapstrength
			//of the cursor position
			theman->RecordHit(new OsnapHit(centerpt, this, CENTER_SUB, NULL));
	}


	//check if the quad sub is turned on, if so compute the points
	if(	GetActive(QUAD_SUB))
	{
		Point3 thepoints[6];//we compute six quadrants
	
		// get some parametric data from the sphere
		// Notice that the cast is safe because we would not be in this
		// method if the node had not satisfied our ValidInput method. 
		float radius;
		((GenSphere *)pobj)->pblock->GetValue(0,t,radius,FOREVER);

		// set up the points to which we snap, in this case six
		// notice that these are in object space
		thepoints[0] = Point3(0.0f,0.0f,radius);
		thepoints[1] = Point3(0.0f,radius,0.0f);
		thepoints[2] = Point3(radius,0.0f,0.0f);
		thepoints[3] = Point3(0.0f,0.0f,-radius);
		thepoints[4] = Point3(0.0f,-radius,0.0f);
		thepoints[5] = Point3(-radius,0.0f,0.0f);

		for(int ii = 0;ii<6;++ii)
		{
			if(CheckPotentialHit(thepoints,ii,fp))
				theman->RecordHit(new OsnapHit(thepoints[ii], this, QUAD_SUB, NULL));
		}
	}


};




TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class OsnapClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 0; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) {return new SphereSnap();}
//	void *			Create(OsnapManager *pman) { return new SphereSnap(pman); }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return _T("SphereSnap"); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return SPHERE_OSNAP_CLASS_ID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return _T("How To"); }
	};

// Declare a static instance of the class descriptor.
static OsnapClassDesc sampDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSampDesc() { return &sampDesc; }

/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSampDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\xmesh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xmesh.rc
//
#define IDS_ACC_VERT                    1
#define IDS_ACC_END                     2
#define IDS_ACC_EDGE                    3
#define IDS_ACC_MID                     4
#define IDS_VERT                        5
#define IDS_END                         6
#define IDS_EDGE                        7
#define IDS_MID                         8
#define IDS_FACE                        9
#define IDS_C_FACE                      10
#define IDS_LIB_DESCRIPTION             11
#define IDB_BITMAP1                     101
#define IDB_ICONS                       111
#define IDB_MASK                        112
#define IDB_TOOLS                       290
#define IDB_MASKS                       291

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\shape1\data.h ===
/******************************************************************************
	FILE: data.h

	DESCRIPTION:  Marker data for the shape snap

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/

//DAta for the markers
static IPoint3 mark0verts[8]=
{ 
 IPoint3(-5,     0,      0),
 IPoint3(0,     0,      0),
 IPoint3(0,     -5,      0),
 IPoint3(-5,     -5,      0),
 IPoint3(-5,     5,      0),
 IPoint3(-5,     -5,      0),
 IPoint3(0,     -5,      0),
 IPoint3(5,     -5,      0)
};

static int mark0es[8]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};


static IPoint3 mark1verts[11]=
{ 
 IPoint3(-5,      5,      0),
 IPoint3(0,      5,      0),
 IPoint3(3,      2,      0),
 IPoint3(4,      0,      0),
 IPoint3(3,      -2,      0),
 IPoint3(0,     -4,      0),
 IPoint3(-3,      -2,      0),
 IPoint3(-4,      0,      0),
 IPoint3(-3,      2,      0),
 IPoint3(0,      5,      0),
 IPoint3(5,      5,      0)
};

static int mark1es[11]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\xmesh\data.h ===
/******************************************************************************
	FILE: data.h

	DESCRIPTION:  Marker data for the xmesh snap

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/

//DAta for the one and only marker
static IPoint3 mark0verts[4]=
{ 
 IPoint3(-5,      0,      0),
 IPoint3(5,      0,      0),
 IPoint3(0,      -5,      0),
 IPoint3(0,      5,      0)
};

static int mark0es[4]=
{
	GW_EDGE_VIS,
	GW_EDGE_SKIP,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};


static IPoint3 mark1verts[6]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(5,      5,      0),
 IPoint3(0,      0,      0)
};

static int mark1es[6]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};

static IPoint3 mark2verts[5]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(5,      5,      0)
};

static int mark2es[5]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};

static IPoint3 mark3verts[6]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0),
 IPoint3(5,      5,      0),
 IPoint3(-5,      -5,      0)
};

static int mark3es[6]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};

static IPoint3 mark4verts[4]=
{ 
 IPoint3(5,      -5,      0),
 IPoint3(0,      5,      0),
 IPoint3(-5,      -5,      0),
 IPoint3(5,      -5,      0)
};

static int mark4es[4]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};

static IPoint3 mark5verts[4]=
{ 
 IPoint3(5,      5,      0),
 IPoint3(-5,      5,      0),
 IPoint3(0,      -5,      0),
 IPoint3(5,      5,      0)
};

static int mark5es[4]=
{
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS,
	GW_EDGE_VIS
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Osnap\xmesh\xmesh.cpp ===
/*****************************************************************************
 *<
	FILE: xmesh.cpp

	DESCRIPTION:  Sample Implementation of an Osnap for geomobjects

	CREATED BY: John Hutchinson		

	HISTORY: created 12/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 *****************************************************************************/
// The main MAX include file.
#include "max.h"

//master include file for osnaps
#include "osnapapi.h"

#include "mesh.h"
#include "meshacc.h"
#include "polyshp.h"

#include "data.h"
#include "resource.h"

#include "dummy.h"

#include <assert.h>

#define SUBCOUNT 6 // the number of snaps this has
#define NOSUB -1
#define VERT_SUB 0
#define END_SUB 1
#define EDGE_SUB 2
#define MID_SUB 3
#define FACE_SUB 4
#define C_FACE_SUB 5

#define EPSILON 0.0001f

#define BIT1	1
#define BIT2	2

HINSTANCE hInstance;

// Special structure for recording edge snap

typedef struct {
	Point3 from;
	Point3 to;
	float distance;
	} BestEdge;


TCHAR *GetString(int id);

#define XMESH_SNAP_CLASS_ID Class_ID(0x52256183, 0x106b5fda)

class XmeshSnap : public Osnap {
private:
	OsnapMarker markerdata[SUBCOUNT];
	TSTR name[SUBCOUNT];
	HBITMAP tools;
	HBITMAP masks;
	HitRegion hr;

public:

	XmeshSnap();//constructor
	virtual ~XmeshSnap();

	virtual int numsubs(){return SUBCOUNT;} //the number of subsnaps this guy has
	virtual TSTR *snapname(int index); // the snaps name to be displayed in the UI
	virtual boolean ValidInput(SClass_ID scid, Class_ID cid);// the type of object that it recognizes SPHERE_CLASS_ID 
	Class_ID ClassID() { return XMESH_SNAP_CLASS_ID; }

	virtual OsnapMarker *GetMarker(int index){return &(markerdata[index]);} // single object might contain subsnaps
	virtual HBITMAP getTools(){return tools;} 
	virtual HBITMAP getMasks(){return masks;} 
	virtual WORD AccelKey(int index);
	virtual void Snap(Object* pobj, IPoint2 *p, TimeValue t);
	virtual Point3 ReEvaluate(TimeValue t, OsnapHit *hit, Object *pobj);

	void SnapToEdge(GraphicsWindow *gw, Mesh *m, int ifrom,int ito, Point2 cursor,BestEdge *best);
	void SnapToEdge(GraphicsWindow *gw, PolyLine &line, int ifrom,int ito, Point2 cursor,BestEdge *best);

};

TSTR *XmeshSnap::snapname(int index){
	return &(name[index]);
}


//Some hit subclasses

//A hit class for vertices
class VertexHit : public OsnapHit {
	friend class XmeshSnap;
public:
	VertexHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int topoindex);
	OsnapHit *clone();
private:
	int vertindex;
};

VertexHit::VertexHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int topoindex)  : OsnapHit(p3, s, sub, m)
{
	vertindex = topoindex;
}

OsnapHit *VertexHit::clone()
{
	return new VertexHit(*this);
}

//A hit class for edges
class EdgeHit : public OsnapHit {
	friend class XmeshSnap;
public:
	EdgeHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int ifrom, int ito, float pct);
	~EdgeHit(){};
	OsnapHit *clone();

private:
	int m_ifrom;
	int m_ito;
	float m_pct;
};

EdgeHit::EdgeHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int ifrom, int ito, float pct)  : OsnapHit(p3, s, sub, m)
{
	m_pct = pct;
	m_ifrom = ifrom;
	m_ito = ito;
}

OsnapHit *EdgeHit::clone()
{
	return new EdgeHit(*this);
}

//A hit class for faces
class FaceHit : public OsnapHit {
	friend class XmeshSnap;
public:
	FaceHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int topoindex, Point3& bary);
	OsnapHit *clone();
private:
	int m_faceindex;
	Point3 m_bary;
};

FaceHit::FaceHit(Point3 p3, Osnap* s, int sub, HitMesh *m, int topoindex, Point3& bary)  : OsnapHit(p3, s, sub, m)
{
	m_faceindex = topoindex;
	m_bary = bary;
}

OsnapHit *FaceHit::clone()
{
	return new FaceHit(*this);
}


XmeshSnap::XmeshSnap(){ //constructor

	name[END_SUB] = TSTR( GetString(IDS_END));
	name[EDGE_SUB] = TSTR( GetString(IDS_EDGE));
	name[VERT_SUB] = TSTR( GetString(IDS_VERT));
	name[MID_SUB] = TSTR( GetString(IDS_MID));
	name[FACE_SUB] = TSTR( GetString(IDS_FACE));
	name[C_FACE_SUB] = TSTR( GetString(IDS_C_FACE));

	tools = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_ICONS));
	masks = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK));

	markerdata[0]=OsnapMarker(4,mark0verts,mark0es);
	markerdata[1]=OsnapMarker(6,mark1verts,mark1es);
	markerdata[2]=OsnapMarker(5,mark2verts,mark2es);
	markerdata[3]=OsnapMarker(6,mark3verts,mark3es);
	markerdata[4]=OsnapMarker(4,mark4verts,mark4es);
	markerdata[5]=OsnapMarker(4,mark5verts,mark5es);
};

XmeshSnap::~XmeshSnap()
{
	DeleteObject(tools);
	DeleteObject(masks);
}

boolean XmeshSnap::ValidInput(SClass_ID scid, Class_ID cid){
	boolean c_ok = FALSE, sc_ok = FALSE;
	sc_ok |= (scid == GEOMOBJECT_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == SHAPE_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == CAMERA_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == LIGHT_CLASS_ID)? TRUE : FALSE;
	sc_ok |= (scid == HELPER_CLASS_ID)? TRUE : FALSE;
//	c_ok |= (cid == Class_ID(0xe44f10b3,0))? TRUE : FALSE; 
	return sc_ok;
}

WORD XmeshSnap::AccelKey(int index){
	switch (index){
	case VERT_SUB:
		return 0x56;
		break;
	case END_SUB:
		return 0x45;
		break;
	case EDGE_SUB:
		return 0x47;
		break;
	case MID_SUB:
		return 0x4d;
		break;
	case FACE_SUB:
		return 0x46;
		break;
	case C_FACE_SUB:
		return 0x43;
		break;
	default:
		return 0;
	}
}


// This is from GraphicsGems II, p10 (Jack C. Morrison)
// Squared distance from point p to line a->b 
static float DistPointToLine(Point2 p, Point2 a, Point2 b) {
	float x1 = b.x - a.x;
	float y1 = b.y - a.y;
	float a2 = (p.y-a.y)*x1-(p.x-a.x)*y1; // 2* area of triangle abp
	return (float)sqrt(a2*a2/(x1*x1+y1*y1));
	}

static float DistPointToLine(Point2 p, Point3 a, Point3 b) {
	float x1 = b.x - a.x;
	float y1 = b.y - a.y;
	float a2 = (p.y-a.y)*x1-(p.x-a.x)*y1; // 2* area of triangle abp
	return (float)sqrt(a2*a2/(x1*x1+y1*y1));
	}

#define EDGETOL 0.0001

// Checks if the cursor point is closer to the given edge than to any previous edge
void XmeshSnap::SnapToEdge(GraphicsWindow *gw, Mesh *m, int ifrom,int ito,Point2 cursor,BestEdge *best)
{

	Point3 from = m->getVert(ifrom);
	Point3 to = m->getVert(ito);

	float edgelen;
	Point3 xyz[3];
	xyz[0] = from;
	xyz[1] = to;
	gw->clearHitCode();
	gw->polyline(2, xyz, NULL/*clr*/, NULL/* tex*/, 0/*open*/, NULL);
	if(gw->checkHitCode())
	{
		// Potential hit -- Make sure of its real distance and that it isn't past the end of the line
		Point3 sf,st;
		gw->transPoint(&from,&sf);
		gw->transPoint(&to,&st);
		float ybias = (float)gw->getWinSizeY() - 1.0f;
		Point2 sf2(sf.x, /*ybias - */sf.y);
		Point2 st2(st.x, /*ybias - */st.y);
		if((edgelen = Length(st2 - sf2)) < EDGETOL )
			return;

		float distance = DistPointToLine(cursor,sf2,st2);
//		float distance = DistPointToLine(cursor,sf,st);
		if(distance > ceil(best->distance))
			return;
		else
		{
			// Now make sure it isn't past the endpoints of the line!
			Point2 pa,ab,pb,ba;

			// Note the following Kludge:
			// The cursor point may have been converted	to Ipoint2 and back so that the 
			// cursor representation of an endpoint may fail the following test without 
			// taking the floor of these endpoints
			sf2.x = (float)floor(sf2.x);
			sf2.y = (float)floor(sf2.y);
			st2.x = (float)floor(st2.x);
			st2.y = (float)floor(st2.y);

			if((edgelen = Length(st2 - sf2)) < EDGETOL )
				return;

			pa = sf2 - cursor;
			ab = st2 - sf2;
			pb = st2 - cursor;
			ba = sf2 - st2;
//			Before the kludge
//			if((pa.x * ab.x + pa.y * ab.y) < 0.0f && (pb.x * ba.x + pb.y * ba.y) < 0.0f)
//			The equality should take care of coincident case
			if((pa.x * ab.x + pa.y * ab.y) <= 0.0f && (pb.x * ba.x + pb.y * ba.y) <= 0.0f)
			{
				best->distance = distance;
				best->from = from;
				best->to = to;

				//add the candidate points based on the active subsnaps
				 if(GetActive(EDGE_SUB))
				 {	
					HitMesh *hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);

					float dap = Length(cursor - sf2);
					assert(Length(st2 - sf2)>=0.0f);
					float pct = (float)sqrt(fabs(dap*dap - distance*distance)) / Length(st2 - sf2);
					Point3 cand;
					float pctout = gw->interpWorld(&xyz[0],&xyz[1],pct,&cand);
//					AddCandidate(new Point3(cand),EDGE_SUB,2,from,to);
					theman->RecordHit(new EdgeHit(cand, this, EDGE_SUB, hitmesh, ifrom, ito, pct));
				 }
				 if(GetActive(END_SUB))
				 {
//					 AddCandidate(new Point3(xyz[0]),END_SUB,2,from,to);
//					 AddCandidate(new Point3(xyz[1]),END_SUB,2,from,to);
					HitMesh *hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);

					theman->RecordHit(new VertexHit(from, this, END_SUB, hitmesh, ifrom));

					hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);
					theman->RecordHit(new VertexHit(to, this, END_SUB, hitmesh, ito));
				 }
				 if(GetActive(MID_SUB))
				 { 
					HitMesh *hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);

					Point3 mid=((xyz[0]+xyz[1])/2.0f);
//					AddCandidate(new Point3(mid),MID_SUB,2,from,to);
					theman->RecordHit(new EdgeHit(mid, this, MID_SUB, hitmesh, ifrom, ito, 0.5f));
				 }
			}
		}
	}
}


void FindEnclosingKnots(PolyLine &line,const int ifrom,const int ito, int *pa, int *pb)
{
	*pa = ifrom;
	*pb = ito;
	while(line.pts[*pb].flags & POLYPT_INTERPOLATED)
	{
		(*pb)++;
		if(*pb > (line.numPts - 1))
		{
			if(line.IsClosed())
				*pb = 0;
			else
				assert(0);//the last point should have been a knot
		}

	}
	while(line.pts[*pa].flags & POLYPT_INTERPOLATED && *pa>0)
		(*pa)--;
}


//This version works on splines
void XmeshSnap::SnapToEdge(GraphicsWindow *gw, PolyLine &line, int ifrom,int ito, Point2 cursor,BestEdge *best)
{
	PolyPt ppt1 = line.pts[ifrom];
	PolyPt ppt2 = line.pts[ito];

	Point3 from =ppt1.p;
	Point3 to = ppt2.p;

	float edgelen;
	Point3 xyz[3];
	xyz[0] = from;
	xyz[1] = to;
	gw->clearHitCode();
	gw->polyline(2, xyz, NULL/*clr*/, NULL/* tex*/, 0/*open*/, NULL);
	if(gw->checkHitCode())
	{
		// Potential hit -- Make sure of its real distance and that it isn't past the end of the line
		Point3 sf,st;
		gw->transPoint(&from,&sf);
		gw->transPoint(&to,&st);
		float ybias = (float)gw->getWinSizeY() - 1.0f;
		Point2 sf2(sf.x, /*ybias - */sf.y);
		Point2 st2(st.x, /*ybias - */st.y);
		if((edgelen = Length(st2 - sf2)) < EDGETOL )
			return;

		float distance = DistPointToLine(cursor,sf2,st2);
//		float distance = DistPointToLine(cursor,sf,st);
		if(distance > ceil(best->distance))
			return;
		else
		{
			// Now make sure it isn't past the endpoints of the line!
			Point2 pa,ab,pb,ba;

			// Note the following Kludge:
			// The cursor point may have been converted	to Ipoint2 and back so that the 
			// cursor representation of an endpoint may fail the following test without 
			// taking the floor of these endpoints
			sf2.x = (float)floor(sf2.x);
			sf2.y = (float)floor(sf2.y);
			st2.x = (float)floor(st2.x);
			st2.y = (float)floor(st2.y);

			if((edgelen = Length(st2 - sf2)) < EDGETOL )
				return;

			pa = sf2 - cursor;
			ab = st2 - sf2;
			pb = st2 - cursor;
			ba = sf2 - st2;
//			Before the kludge
//			if((pa.x * ab.x + pa.y * ab.y) < 0.0f && (pb.x * ba.x + pb.y * ba.y) < 0.0f)
//			The equality should take care of coincident case
			if((pa.x * ab.x + pa.y * ab.y) <= 0.0f && (pb.x * ba.x + pb.y * ba.y) <= 0.0f)
			{
				best->distance = distance;
				best->from = from;
				best->to = to;

				//add the candidate points based on the active subsnaps
				 if(GetActive(EDGE_SUB))
				 {	
					HitMesh *hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);

					float dap = Length(cursor - sf2);
					assert(Length(st2 - sf2)>=0.0f);
					float pct = (float)sqrt(fabs(dap*dap - distance*distance)) / Length(st2 - sf2);
					Point3 cand;
					float pctout = gw->interpWorld(&xyz[0],&xyz[1],pct,&cand);
//					AddCandidate(new Point3(cand),EDGE_SUB,2,from,to);
					theman->RecordHit(new EdgeHit(cand, this, EDGE_SUB, hitmesh, ifrom, ito, pct));
				 }
				 if(GetActive(END_SUB))
				 {
					int a, b;
					BOOL closure = FALSE;
					FindEnclosingKnots(line,ifrom,ito, &a, &b);
					if(b == 0)
					{
						b = line.numPts - 1;
						closure = TRUE;
					}
					assert(b>=a);//should always be ordered now
					int segs = b-a;
					int size = segs + 2 + (closure?1:0);
					assert(size>2);

					HitMesh *hitmesha = new HitMesh(size);
					HitMesh *hitmeshb = new HitMesh(size);
					for(int i = 0; i<=segs; i++)//segs + 1 vertices 
					{
						Point3 curpt = line.pts[a + i].p;
						hitmesha->setVert(i, curpt);
						hitmeshb->setVert(i, curpt);
					}
					if(closure)
					{
						hitmesha->setVert(segs + 1, line.pts[0].p);
						hitmeshb->setVert(segs + 1, line.pts[0].p);
						b=0;
					}

					theman->RecordHit(new VertexHit(line.pts[a].p, this, END_SUB, hitmesha, ifrom));

					theman->RecordHit(new VertexHit(line.pts[b].p, this, END_SUB, hitmeshb, ito));
				 }
				 if(GetActive(MID_SUB))
				 { 
					HitMesh *hitmesh = new HitMesh(3);
					hitmesh->setVert(0, from);
					hitmesh->setVert(1, to);

					Point3 mid=((xyz[0]+xyz[1])/2.0f);
//					AddCandidate(new Point3(mid),MID_SUB,2,from,to);
					theman->RecordHit(new EdgeHit(mid, this, MID_SUB, hitmesh, ifrom, ito, 0.5f));
				 }
			}
		}
	}
}

//10/20/99
//added code to allow hits on backfacing faces
static BOOL IntersectFaces(const Ray& ray,Mesh *m, Point3& point, int& findex, Point3& retbary, int backcull)
{
	float at = (float)9.99999e+30; //some silly large number. mdl 4/24/98
	BOOL first = FALSE;
	int faceCt = m->getNumFaces();
	Face *face = m->faces;

	for(int i=0; i<faceCt; ++i, ++face) 
		{	
			DWORD *v;
			Point3 v0,v1,v2,n,norm,bary,p;
			if(face->Hidden())
				continue;
			float rn,d,a;
			v = face->getAllVerts();
			v0 = m->verts[face->v[0]];
			v1 = m->verts[face->v[1]];
			v2 = m->verts[face->v[2]];
			n  = Normalize((v1-v0)^(v2-v1));
			
			// See if the ray intersects the plane (backfaced)
			rn = DotProd(ray.dir,n);
			if (backcull && (rn > -EPSILON)) continue;
			
			// Use a point on the plane to find d
			d = DotProd(v0,n);

			// Find the point on the ray that intersects the plane
			a = (d - DotProd(ray.p,n)) / rn;

			// Must be positive...
			if (a < 0.0f) continue;

			// Must be closer than the closest at so far
			if (first) {
				if (a > at) continue;
				}

			// The point on the ray and in the plane.
			p = ray.p + a*ray.dir;

			bary = m->BaryCoords(i,p);

			// barycentric coordinates must sum to 1 and each component must
			// be in the range 0-1
			if (bary.x<0.0f || bary.x>1.0f || bary.y<0.0f || bary.y>1.0f || bary.z<0.0f || bary.z>1.0f) continue;
			if (fabs(bary.x + bary.y + bary.z - 1.0f) > EPSILON) continue;

			// Hit!
			first = TRUE;
			norm  = n;
			at    = a;
			findex = i;
			point = p;
			retbary = bary;
		}// endfor
	return first;
}

void XmeshSnap::Snap(Object* pobj, IPoint2 *p, TimeValue t)
{
	//this osnap snaps to topological features common to meshes and splines

	//local copy of the cursor position
	Point2 fp = Point2((float)p->x, (float)p->y);

	//JH 5/9/99
	//suspend the hold since we may be amking temporary objects
	bool wasHolding = false;
	if(theHold.Holding())
	{
		wasHolding = true;
		theHold.Suspend();
	}

	//if it's a spline we'll get a poly shape from it
	PolyShape vertshape;

	//if it's a tri we'll use the following
	TriObject* ptri = NULL;
	Mesh* m = NULL;
	int vertCt;
	char* sv;
	BOOL meshsnapdata ;
	BOOL del = FALSE;
	MeshAccess *maccess = NULL;

	if (pobj->SuperClassID() == SHAPE_CLASS_ID) {
		((ShapeObject *)pobj)->MakePolyShape(t, vertshape, PSHAPE_BUILTIN_STEPS,0);
	}

	
	//convert this object to a triobject if it isn't already one
	else if (pobj->IsSubClassOf(triObjectClassID)) {
		ptri = (TriObject *) pobj;
		m = &ptri->GetMesh();
	}
/*	else if (pobj->IsSubClassOf(Class_ID(DUMMY_CLASS_ID,0))) {
		DummyObject *pdummy = (DummyObject *) pobj;
		m = pdummy->mesh;
		del = FALSE;
	}
*/

	else if(pobj->CanConvertToType(triObjectClassID)){
		ptri = (TriObject *) pobj->ConvertToType(t, Class_ID(TRIOBJ_CLASS_ID,0));
		m= &ptri->GetMesh();
		del = TRUE;
	}
	else
	{
		if(wasHolding)
		{
			theHold.Resume();
			wasHolding = false;//silly since we're gonna return
		}
		return;
	}


	if(m)//we've got a mesh
	{
	maccess = new MeshAccess(m);
	// Build the snap data structures
//	int templimits = m_hitgw->getRndLimits();
//	m_hitgw->setRndLimits(templimits /*| GW_WIREFRAME*/ | ~GW_BACKCULL);
	meshsnapdata = maccess->BuildSnapData(m_hitgw,TRUE,TRUE);
//	m_hitgw->setRndLimits(templimits );

	// Set usable flag in snapV structure
	sv = maccess->GetsnapV();
	vertCt = m->getNumVerts();
	}

	// do the vertex snapping if its active	
	if(GetActive(VERT_SUB)) {
		Point3 screen3;
		Point2 screen2;
		Point3 vert;
  
		if(vertshape.numLines)
		{
			for(int i = 0; i< vertshape.numLines; i++)
			{
				PolyLine line = vertshape.lines[i];
				BOOL vis = TRUE;

				for(int k = 0; k< line.numPts; k++)
				{
					PolyPt ppt = line.pts[k];
					PolyPt ppt1;
					PolyPt ppt2;
					vis = TRUE;

					if (k ==0)
						{
						if (line.IsClosed())
							{
							ppt1 = line.pts[0];
							ppt2 = line.pts[line.numPts-1];
							if ( (ppt1.flags & POLYPT_INVIS_EDGE) &&
								 (ppt2.flags & POLYPT_INVIS_EDGE) )
								vis = FALSE;

							}
						else
							{
							ppt1 = line.pts[0];
							if (ppt1.flags & POLYPT_INVIS_EDGE)
								vis = FALSE;
							}


						}
/*
					else if (k==(line.numPts-1))
						{
						if (line.IsClosed())
							{
							ppt1 = line.pts[0];
							ppt2 = line.pts[line.numPts-2];
							if ( (ppt1.flags & POLYPT_INVIS_EDGE) &&
								 (ppt2.flags & POLYPT_INVIS_EDGE) )
								vis = FALSE;

							}
						else
							{
							ppt1 = line.pts[k];
							if (ppt1.flags & POLYPT_INVIS_EDGE)
								vis = FALSE;
							}

						}
*/					else

						{
						ppt1 = line.pts[k-1	];
						ppt2 = line.pts[k	];
						if ((ppt1.flags & POLYPT_INVIS_EDGE) &&
							(ppt2.flags & POLYPT_INVIS_EDGE) )
							vis = FALSE;
						}

					if (vis)
						if (CheckPotentialHit(&(ppt.p),0, fp))
							theman->RecordHit(new VertexHit(ppt.p, this, VERT_SUB, NULL, i));
				}
			}
		}
		else if(m && meshsnapdata)//must be a bone fide mesh
		{
			for(int i = 0; i < vertCt; ++i)
			{
				if(!sv[i] || m->vertHide[i])
					continue;
				if (CheckPotentialHit(m->verts,i, fp))
					theman->RecordHit(new VertexHit(m->verts[i], this, VERT_SUB, NULL, i));
			}
		}

	}

	// do the edge snapping if its active	
	if(GetActive(EDGE_SUB) || GetActive(END_SUB) || GetActive(MID_SUB)) {
		Point2 cursor;
		BOOL got_one = FALSE;

		cursor.x = (float)p->x;
		cursor.y = (float)p->y;

	 	hr.type = POINT_RGN;
		hr.epsilon = theman->GetSnapStrength();
		hr.pt.x = p->x;
		hr.pt.y = p->y;

		int savedlimits = m_hitgw->getRndLimits();
		m_hitgw->setRndLimits((savedlimits | GW_PICK) & ~GW_ILLUM);
		m_hitgw->setHitRegion(&hr);
		m_hitgw->clearHitCode();

		// Zip thru the visible edges and see if we get a snap
		// puts the best edge found into the bestedge structure
		int i;
		BestEdge best;
		best.distance = 9999.0f;	// Reset to ridiculous distance

		if(m && meshsnapdata)
		{
			int faceCt = m->getNumFaces();
			char *f = maccess->GetsnapF();
			DWORD *v;
			Face *face = m->faces;

			sv = maccess->GetsnapV();

			//10/20/99 Allow snapping to invisible edges when shown
			int all_edges = m_hitgw->getRndLimits() & GW_ALL_EDGES;

			for(i=0; i<faceCt; i++,f++,face++) {
				if(*f && !face->Hidden()) {
					v = face->getAllVerts();
					if((*f & 1) && (all_edges || face->getEdgeVis(0)))
						if(sv[v[0]] & sv[v[1]] & BIT1 )
							SnapToEdge(m_hitgw,m, v[0],v[1],cursor,&best);
					if((*f & 2) && (all_edges || face->getEdgeVis(1)))
						if(sv[v[1]] & sv[v[2]] & BIT1 )
							SnapToEdge(m_hitgw,m, v[1],v[2],cursor,&best);
					if((*f & 4) && (all_edges || face->getEdgeVis(2)))
						if(sv[v[2]] & sv[v[0]] & BIT1 )
							SnapToEdge(m_hitgw,m, v[2],v[0],cursor,&best);
					}
				}
		}
		//special code for handling splines
//		else if(!gotsdata)
		else if(vertshape.numLines)
		{
			for(i = 0; i< vertshape.numLines; i++)
			{
				PolyLine line = vertshape.lines[i];
				BOOL vis = TRUE;

				for(int k = 0; k< line.numPts - 1; k++)
				{
					PolyPt ppt = line.pts[k];
					if (ppt.flags & POLYPT_VISEDGE)
						vis = TRUE;
					else if (ppt.flags & POLYPT_INVIS_EDGE)
						vis = FALSE;

					if (vis)
						SnapToEdge(m_hitgw, line, k, k+1,cursor,&best);
				}
				if(line.IsClosed())
				{
					PolyPt ppt = line.pts[k];
					if (ppt.flags & POLYPT_VISEDGE)
						vis = TRUE;
					else if (ppt.flags & POLYPT_INVIS_EDGE)
						vis = FALSE;
					if (vis)
						SnapToEdge(m_hitgw, line, k, 0,cursor,&best);
				}

			}
		}

/* Now done in snaptoedge
		//now zip through the candidates record them with the manager
		HitMesh *hitmesh;
		for(int j = 0; j< NumCandidates(); j++)
		{
			hitmesh = new HitMesh;
			GetCandidateMesh(j,hitmesh);
			theman->RecordHit(new MeshHit(*GetCandidatePoint(j), this, GetCandidateType(j), hitmesh));
		}
*/

		m_hitgw->setRndLimits(savedlimits);
//		ClearCandidates();
	}



	// do the face snapping if its active	
	if(m && meshsnapdata && (GetActive(FACE_SUB) || GetActive(C_FACE_SUB))) {
		Point2 cursor;
		Matrix3 itm = Inverse(theman->GetObjectTM());

		cursor.x = (float)p->x;
		cursor.y = (float)p->y;

		//compute a ray for intersecting with the faces of the mesh
		Ray ray;
		theman->GetVpt()->MapScreenToWorldRay(float(cursor.x), float(cursor.y),ray);
		// Transform the rays into the ref coord system space
		ray.p = itm * ray.p;
		ray.dir = VectorTransform( itm, ray.dir );

		// Intersect the cursor with the faces of the mesh
		int bestindex;
		Point3 p;
		Face *face = m->faces;
		Point3 bary;

		BOOL gotone = IntersectFaces(ray,m,p,bestindex,bary, m_hitgw->getRndLimits() & GW_BACKCULL);

		if(gotone)
		{//got a face hit
			HitMesh *hitmesh;

			// We got a face
			Point3 screen3,mspoint;
			Point2 screen,screen2;
			Point3 p0,p1,p2;
			
			//get the vertices of the winning face
			p0 = m->verts[m->faces[bestindex].v[0]];
			p1 = m->verts[m->faces[bestindex].v[1]];
			p2 = m->verts[m->faces[bestindex].v[2]];


			if(GetActive(FACE_SUB))
				mspoint = p;
			else if(GetActive(C_FACE_SUB))
			{
				mspoint = (p0 + p1 + p2)/3.0f;
				bary.x=bary.y=bary.z=0.333333333f;
			}


			hitmesh = new HitMesh(5);
			hitmesh->setVert(0, p0);
			hitmesh->setVert(1, p1);
			hitmesh->setVert(2, p2);
			hitmesh->setVert(3, p0);

			theman->RecordHit(new FaceHit(mspoint, this, GetActive(FACE_SUB)?FACE_SUB:C_FACE_SUB, hitmesh, bestindex, bary));
		}//end gotone

	}// endif FACE STUFF

	if(del) 
	{
		ptri->DeleteAllRefsFromMe();//may reference a controller but no one should reference it.
		ptri->DeleteThis();
	}

	if(wasHolding)
	{
		theHold.Resume();
		wasHolding = false;//silly since we're gonna return
	}

	if(maccess)
		delete maccess;
		
};

void interp_line(Point3 *pt1, Point3* pt2, float sParam, Point3* interpPt)
{
if(interpPt)
		*interpPt = (*pt1 + (*pt2 - *pt1) * sParam);
}



Point3 XmeshSnap::ReEvaluate(TimeValue t, OsnapHit * hit, Object * pobj)
{
	Mesh* m;

	//JH 5/9/99
	//suspend the hold since we may be amking temporary objects
	bool wasHolding = false;
	if(theHold.Holding())
	{
		wasHolding = true;
		theHold.Suspend();
	}

	//convert this object to a triobject if it isn't already one
	BOOL del = TRUE;
	TriObject* ptri = NULL;
	if (pobj->IsSubClassOf(triObjectClassID)) {
		ptri = (TriObject *) pobj;
		m = &ptri->GetMesh();
		del = FALSE;
	}
/*	else if (pobj->IsSubClassOf(Class_ID(DUMMY_CLASS_ID,0))) {
		DummyObject *pdummy = (DummyObject *) pobj;
		m = pdummy->mesh;
		del = FALSE;
	}
*/	
	else if(pobj->CanConvertToType(triObjectClassID)){
//		HCURSOR modecursor = GetCursor(); //save the active command mode's cursor
		ptri = (TriObject *) pobj->ConvertToType(t, Class_ID(TRIOBJ_CLASS_ID,0));
		m= &ptri->GetMesh();
//		SetCursor(modecursor);//Fixed the bug in polyshape::MakeCap
	}

	Point3 objpoint;

	switch(hit->GetSubsnap())
	{
	case VERT_SUB:
	case END_SUB:
		objpoint = m->getVert(((VertexHit *)hit)->vertindex);
		break;
	case EDGE_SUB:
	case MID_SUB:
		interp_line(m->getVertPtr(((EdgeHit *)hit)->m_ifrom),m->getVertPtr(((EdgeHit *)hit)->m_ito),((EdgeHit *)hit)->m_pct,&objpoint);
		break;
	case FACE_SUB:
	case C_FACE_SUB:
		{
			Point3 bary = ((FaceHit *)hit)->m_bary; 
			int f = ((FaceHit *)hit)->m_faceindex;
			objpoint = m->verts[m->faces[f].v[0]] * bary.x +
				    m->verts[m->faces[f].v[1]] * bary.y +
					m->verts[m->faces[f].v[2]] * bary.z;
		}
		break;
	default:
		break;
	}

	if(del) 
	{
		ptri->DeleteAllRefsFromMe();//may reference a controller but no one should reference it.
		ptri->DeleteThis();
	}

	if(wasHolding)
	{
		theHold.Resume();
		wasHolding = false;//silly since we're gonna return
	}
	return objpoint;
}


TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}


/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/

class OsnapClassDesc:public ClassDesc {
	public:
	// The IsPublic() method should return TRUE if the plug-in can be picked
	// and assigned by the user. Some plug-ins may be used privately by other
	// plug-ins implemented in the same DLL and should not appear in lists for
	// user to choose from, so these plug-ins would return FALSE.
	int 			IsPublic() { return 0; }
	// This is the method that actually creates a new instance of
	// a plug-in class.  By having the system call this method,
	// the plug-in may use any memory manager it wishes to 
	// allocate its objects.  The system calls the correspoding 
	// DeleteThis() method of the plug-in to free the memory.  Our 
	// implementations use 'new' and 'delete'.
	void *			Create(BOOL loading = FALSE) {return new XmeshSnap();}
//	void *			Create(OsnapManager *pman) { return new XmeshSnap(pman); }
	// This is used for debugging purposes to give the class a 
	// displayable name.  It is also the name that appears on the button
	// in the MAX user interface.
	const TCHAR *	ClassName() { return _T("XmeshSnap"); }
	// The system calls this method at startup to determine the type of object
	// this is.  In our case, we're a geometric object so we return 
	// GEOMOBJECT_CLASS_ID.  The possible options are defined in PLUGAPI.H
	SClass_ID		SuperClassID() { return OSNAP_CLASS_ID; }
	// The system calls this method to retrieve the unique
	// class id for this object.
	Class_ID		ClassID() { 
		return XMESH_SNAP_CLASS_ID; }
	// The category is selected
	// in the bottom most drop down list in the create branch.
	// If this is set to be an exiting category (i.e. "Primatives", ...) then
	// the plug-in will appear in that category. If the category doesn't
	// yet exists then it is created.  We use the new How To category for
	// all the example plug-ins in the How To sections.
	const TCHAR* 	Category() { return _T(""); }
	};

// Declare a static instance of the class descriptor.
static OsnapClassDesc sampDesc;
// This function returns the address of the descriptor.  We call it from 
// the LibClassDesc() function, which is called by the system when loading
// the DLLs at startup.
ClassDesc* GetSampDesc() { return &sampDesc; }

/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/
// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int LibNumberClasses() {return 1;}

// This function return the ith class descriptor
__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetSampDesc();		
		default: return 0;
		}
	}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\approxui.cpp ===
/**********************************************************************
 *<
	FILE: approxui.cpp

	DESCRIPTION: Editable Triangle Mesh Displacment Approximation code

	CREATED BY: Charlie Thaeler

	HISTORY: created 8 December 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "pack1.h"
#include "triobjed.h"




class AdvParams {
public:
	TessSubdivStyle mStyle;
	int mMin, mMax;
	int mTris;
};
static AdvParams sParams;

static ISpinnerControl* psUSpin = NULL;
static ISpinnerControl* psEdgeSpin = NULL;
static ISpinnerControl* psDistSpin = NULL;
static ISpinnerControl* psAngSpin = NULL;

void EditTriObject::UpdateApproxUI () {
	if (!hApprox) return;
	TessApprox tapprox = DisplacmentApprox ();
	BOOL dosubdiv = DoSubdivisionDisplacment ();
	BOOL splitMesh = SplitMeshForDisplacement ();
	CheckDlgButton( hApprox, IDC_DO_SUBDIV, dosubdiv);
	CheckDlgButton( hApprox, IDC_SPLITMESH, splitMesh);
	if (!dosubdiv) {
		EnableWindow( GetDlgItem(hApprox, IDC_SPLITMESH), FALSE);

		EnableWindow( GetDlgItem(hApprox, IDC_ADVANCED), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_VIEW_DEP), FALSE);

		EnableWindow( GetDlgItem(hApprox, IDC_PRESET1), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_PRESET2), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_PRESET3), FALSE);

		EnableWindow( GetDlgItem(hApprox, IDC_TESS_REGULAR), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_SPATIAL), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_CURV), FALSE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_LDA), FALSE);
		psUSpin->Disable();
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		return;
	}
	EnableWindow( GetDlgItem(hApprox, IDC_SPLITMESH), TRUE);

    EnableWindow( GetDlgItem(hApprox, IDC_ADVANCED), FALSE);
    EnableWindow( GetDlgItem(hApprox, IDC_TESS_VIEW_DEP), FALSE);
	CheckDlgButton( hApprox, IDC_TESS_REGULAR, FALSE);
	CheckDlgButton( hApprox, IDC_TESS_SPATIAL, FALSE);
	CheckDlgButton( hApprox, IDC_TESS_CURV, FALSE);
	CheckDlgButton( hApprox, IDC_TESS_LDA, FALSE);

	psUSpin->Enable();
	psEdgeSpin->Enable();
	psDistSpin->Enable();
	psAngSpin->Enable();

	EnableWindow( GetDlgItem(hApprox, IDC_PRESET1), TRUE);
	EnableWindow( GetDlgItem(hApprox, IDC_PRESET2), TRUE);
	EnableWindow( GetDlgItem(hApprox, IDC_PRESET3), TRUE);

	EnableWindow( GetDlgItem(hApprox, IDC_TESS_REGULAR), TRUE);
	EnableWindow( GetDlgItem(hApprox, IDC_TESS_SPATIAL), TRUE);
	EnableWindow( GetDlgItem(hApprox, IDC_TESS_CURV), TRUE);
	EnableWindow( GetDlgItem(hApprox, IDC_TESS_LDA), TRUE);

	psUSpin->SetValue(tapprox.u, FALSE);
	psEdgeSpin->SetValue(tapprox.edge, FALSE);
	psDistSpin->SetValue(tapprox.dist, FALSE);
	psAngSpin->SetValue(tapprox.ang, FALSE);

	switch(tapprox.type) {
	case TESS_REGULAR:
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		CheckDlgButton( hApprox, IDC_TESS_REGULAR, TRUE);
		break;
	case TESS_SPATIAL:
        EnableWindow( GetDlgItem(hApprox, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_VIEW_DEP), TRUE);
		psUSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		CheckDlgButton( hApprox, IDC_TESS_SPATIAL, TRUE);
		break;
	case TESS_CURVE:
        EnableWindow( GetDlgItem(hApprox, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_VIEW_DEP), TRUE);
		psEdgeSpin->Disable();
		psUSpin->Disable();
		CheckDlgButton( hApprox, IDC_TESS_CURV, TRUE);
		break;
	case TESS_LDA:
        EnableWindow( GetDlgItem(hApprox, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hApprox, IDC_TESS_VIEW_DEP), TRUE);
		psUSpin->Disable();
		CheckDlgButton( hApprox, IDC_TESS_LDA, TRUE);
		break;
	}
}

class UIApproxRestore : public RestoreObj {
public:		
	EditTriObject *mpEO;
	TessApprox mApprox, mApproxR;
	bool mDoSubdiv, mDoSubdivR;
	bool mSplitMesh, mSplitMeshR;

    UIApproxRestore(EditTriObject *pEO);

    void Restore(int isUndo);
    void Redo();
};

UIApproxRestore::UIApproxRestore(EditTriObject *pEO)
{
	mpEO = pEO;
	mApprox = pEO->DisplacmentApprox();
	mDoSubdiv = pEO->DoSubdivisionDisplacment();
	mSplitMesh = pEO->SplitMeshForDisplacement();
}

void
UIApproxRestore::Restore(int isUndo)
{
	if (isUndo) {
		mApproxR = mpEO->DisplacmentApprox();
		mDoSubdiv = mpEO->DoSubdivisionDisplacment();
		mSplitMeshR = mpEO->SplitMeshForDisplacement();
	}
	mpEO->DisplacmentApprox() = mApprox;
	mpEO->DoSubdivisionDisplacment() = mDoSubdiv;
	mpEO->SplitMeshForDisplacement() = mSplitMesh;
	if (mpEO->hApprox) mpEO->UpdateApproxUI ();
}

void
UIApproxRestore::Redo()
{
	mpEO->DisplacmentApprox() = mApproxR;
	mpEO->DoSubdivisionDisplacment() = mDoSubdivR;
	mpEO->SplitMeshForDisplacement() = mSplitMeshR;
	if (mpEO->hApprox) mpEO->UpdateApproxUI ();
}






#define MAX_F 1000.0f
BOOL CALLBACK AdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

BOOL CALLBACK
DispApproxDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	EditTriObject *eo = (EditTriObject*)GetWindowLong(hWnd,GWL_USERDATA);


	switch (msg) {
	case WM_INITDIALOG: {
		eo = (EditTriObject*)lParam;
		eo->hApprox = hWnd;
		SetWindowLong(hWnd, GWL_USERDATA, lParam);
		psUSpin = SetupIntSpinner( hWnd, IDC_TESS_U_SPINNER, IDC_TESS_U, 1, 100,
									eo->DisplacmentApprox().u);
		psEdgeSpin = SetupFloatSpinner( hWnd, IDC_TESS_EDGE_SPINNER, IDC_TESS_EDGE, 0.0f, MAX_F,
									eo->DisplacmentApprox().edge);
		psDistSpin = SetupFloatSpinner( hWnd, IDC_TESS_DIST_SPINNER, IDC_TESS_DIST, 0.0f, MAX_F,
									eo->DisplacmentApprox().dist);
		psAngSpin =  SetupFloatSpinner( hWnd, IDC_TESS_ANG_SPINNER,  IDC_TESS_ANG, 0.0f, 180.0f,
									eo->DisplacmentApprox().ang);
		CheckDlgButton(hWnd, IDC_TESS_VIEW_DEP, eo->DisplacmentApprox().view);
		eo->UpdateApproxUI ();
		break; }

	case CC_SPINNER_BUTTONDOWN:
		theHold.Begin();
		theHold.Put(new UIApproxRestore(eo));
		break;


    case CC_SPINNER_CHANGE:
		if (!HIWORD(wParam)) {
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
		}
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_U_SPINNER:
			eo->DisplacmentApprox().u = psUSpin->GetIVal();
			break;
		case IDC_TESS_EDGE_SPINNER:
			eo->DisplacmentApprox().edge = psEdgeSpin->GetFVal();
			break;
		case IDC_TESS_DIST_SPINNER:
			eo->DisplacmentApprox().dist = psDistSpin->GetFVal();
			break;
		case IDC_TESS_ANG_SPINNER:
			eo->DisplacmentApprox().ang = psAngSpin->GetFVal();
			break;
		}
  		if (!HIWORD(wParam)) {
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
		}
      break;

	case CC_SPINNER_BUTTONUP:
		if (HIWORD(wParam)) {
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
		} else {
			theHold.Cancel();
		}
		break;

    case WM_COMMAND:
		switch ( LOWORD(wParam) ) {

		case IDC_DO_SUBDIV:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DoSubdivisionDisplacment() = IsDlgButtonChecked(hWnd, IDC_DO_SUBDIV)?true:false;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_SPLITMESH:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->SplitMeshForDisplacement() = IsDlgButtonChecked(hWnd, IDC_SPLITMESH)?true:false;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_PRESET1:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->SetDisplacmentApproxToPreset(0);
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_PRESET2:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->SetDisplacmentApproxToPreset(1);
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_PRESET3:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->SetDisplacmentApproxToPreset(2);
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;

		case IDC_TESS_REGULAR:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DisplacmentApprox().type = TESS_REGULAR;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_TESS_SPATIAL:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DisplacmentApprox().type = TESS_SPATIAL;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_TESS_CURV:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DisplacmentApprox().type = TESS_CURVE;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;
		case IDC_TESS_LDA:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DisplacmentApprox().type = TESS_LDA;
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			eo->UpdateApproxUI ();
			break;

		case IDC_TESS_VIEW_DEP:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(eo));
			eo->DisplacmentApprox().view = IsDlgButtonChecked(hWnd, IDC_TESS_VIEW_DEP);
			theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
			break;
		case IDC_ADVANCED: {
			sParams.mStyle = eo->DisplacmentApprox().subdiv;
			sParams.mMin = eo->DisplacmentApprox().minSub;
			sParams.mMax = eo->DisplacmentApprox().maxSub;
			sParams.mTris = eo->DisplacmentApprox().maxTris;
			int retval = eo->ip ? DialogBoxParam( hInstance,
						MAKEINTRESOURCE(IDD_DISP_APPROX_ADV),
						eo->ip->GetMAXHWnd(), AdvParametersDialogProc, (LPARAM)eo) : FALSE;
			if (retval == 1) {
				BOOL confirm = FALSE;
				if ((sParams.mStyle == SUBDIV_DELAUNAY && sParams.mTris > 200000) ||
					(sParams.mStyle != SUBDIV_DELAUNAY && sParams.mMax > 5)) {
					// warning!
					TSTR title = GetString(IDS_ADV_DISP_APPROX_WARNING_TITLE),
						warning = GetString(IDS_ADV_DISP_APPROX_WARNING);
					if (eo->ip && (MessageBox(eo->ip->GetMAXHWnd(), warning, title,
						MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 ) == IDYES))
						confirm = TRUE;
 
				} else
					confirm = TRUE;
				if (confirm) {
					theHold.Begin();
					theHold.Put(new UIApproxRestore(eo));
					eo->DisplacmentApprox().subdiv = sParams.mStyle;
					eo->DisplacmentApprox().minSub = sParams.mMin;
					eo->DisplacmentApprox().maxSub = sParams.mMax;
					eo->DisplacmentApprox().maxTris = sParams.mTris;
					theHold.Accept(GetString(IDS_DISP_APPROX_CHANGE));
				}
			}
			break; }
		}
        break;

		
	case WM_DESTROY:
		if( psUSpin ) {
			ReleaseISpinner(psUSpin);
			psUSpin = NULL;
		}
		if( psEdgeSpin ) {
			ReleaseISpinner(psEdgeSpin);
			psEdgeSpin = NULL;
		}
		if( psDistSpin ) {
			ReleaseISpinner(psDistSpin);
			psDistSpin = NULL;
		}
		if( psAngSpin ) {
			ReleaseISpinner(psAngSpin);
			psAngSpin = NULL;
		}
        break;
	default:
		return FALSE;
	}
	return TRUE;
}

static ISpinnerControl* psMinSpin = NULL;
static ISpinnerControl* psMaxSpin = NULL;
static ISpinnerControl* psMaxTrisSpin = NULL;
// this max matches the MI max.
#define MAX_SUBDIV 7

static BOOL initing = FALSE; // this is a hack but CenterWindow causes bad commands

BOOL CALLBACK
AdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg) {
    case WM_INITDIALOG: {
		initing = TRUE;
        CenterWindow(hDlg, GetCOREInterface()->GetMAXHWnd());
		initing = FALSE;
		psMinSpin = SetupIntSpinner( hDlg, IDC_TESS_MIN_REC_SPINNER, IDC_TESS_MIN_REC, 0, sParams.mMax, sParams.mMin);
		psMaxSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_REC_SPINNER, IDC_TESS_MAX_REC, sParams.mMin, MAX_SUBDIV, sParams.mMax);
		psMaxTrisSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_TRIS_SPINNER, IDC_TESS_MAX_TRIS, 0, 2000000, sParams.mTris);
		switch (sParams.mStyle) {
		case SUBDIV_GRID:
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case SUBDIV_TREE:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case SUBDIV_DELAUNAY:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			psMinSpin->Disable();
			psMaxSpin->Disable();
			psMaxTrisSpin->Enable();
			break;
		}
		break; }

    case WM_COMMAND:
		if (initing) return FALSE;
		switch ( LOWORD(wParam) ) {
		case IDOK:
			EndDialog(hDlg, 1);
			break;
		case IDCANCEL:
			EndDialog(hDlg, 0);
			break;
		case IDC_GRID:
			sParams.mStyle = SUBDIV_GRID;
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case IDC_TREE:
			sParams.mStyle = SUBDIV_TREE;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case IDC_DELAUNAY:
			sParams.mStyle = SUBDIV_DELAUNAY;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			psMinSpin->Disable();
			psMaxSpin->Disable();
			psMaxTrisSpin->Enable();
			break;
		}
		break;

    case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_MIN_REC_SPINNER:
			sParams.mMin = psMinSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_REC_SPINNER:
			sParams.mMax = psMaxSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_TRIS_SPINNER:
			sParams.mTris = psMaxTrisSpin->GetIVal();
			break;
		}
		break;

	case WM_DESTROY:
		if( psMinSpin ) {
			ReleaseISpinner(psMinSpin);
			psMinSpin = NULL;
		}
		if( psMaxSpin ) {
			ReleaseISpinner(psMaxSpin);
			psMaxSpin = NULL;
		}
		if( psMaxTrisSpin ) {
			ReleaseISpinner(psMaxTrisSpin);
			psMaxTrisSpin = NULL;
		}
		break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\pack1.h ===
/**********************************************************************
 *<
	FILE: pack1.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY:

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __PACK1__H
#define __PACK1__H

#include "Max.h"
#include "resource.h"

TCHAR *GetString(int id);

extern ClassDesc* GetEditTriObjectDesc();

extern HINSTANCE hInstance;
extern int enabled;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\pack1.cpp ===
/**********************************************************************
 *<
	FILE: pack1.cpp

	DESCRIPTION:   Some extra goodies

	CREATED BY: Rolf Berteig

	HISTORY: created 4 March 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "pack1.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;
int enabled = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		
		// See if the editable mesh is enabled
		enabled = GetSystemSetting(SYSSET_ENABLE_EDITABLEMESH);

		// MAXontrols
		InitCustomControls(hInstance);
		
		// initialize Chicago controls
		InitCommonControls();

		// Register us as the editable tri object.
		if (enabled) {
			RegisterEditTriObjDesc(GetEditTriObjectDesc());
			}
		}	

	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to MAX
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetEditTriObjectDesc();
		default: return 0;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\triobjed.cpp ===
/**********************************************************************
 *<
	FILE: triobjed.cpp

	DESCRIPTION:   Editable Triangle Mesh Object

	CREATED BY: Rolf Berteig

	HISTORY: created 4 March 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "pack1.h"
#include "triobjed.h"
#include "nsclip.h"
#include "macrorec.h"

//--- Class descriptor/Class vars -------------------------------

class EditTriObjectClassDesc : public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) {return new EditTriObject;}
	const TCHAR *	ClassName() {return GetString(IDS_SCA_BASE_MESH);}
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(EDITTRIOBJ_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(IDS_BASE_OBJECTS);}
	void			ResetClassParams(BOOL fileReset);
	int NumShortcutTables() { return 1; }
	ShortcutTable*  GetShortcutTable(int i) { return GetEMeshShortcuts(); }
};

static EditTriObjectClassDesc editTriObjectDesc;
ClassDesc* GetEditTriObjectDesc() {return &editTriObjectDesc;}

HWND				EditTriObject::hSel        = NULL;
HWND				EditTriObject::hAR			= NULL;
HWND				EditTriObject::hGeom        = NULL;
HWND				EditTriObject::hApprox         = NULL;
HWND				EditTriObject::hSurf		= NULL;
Interface *			EditTriObject::ip              = NULL;
EditTriObject *		EditTriObject::editObj = NULL;
MoveModBoxCMode*    EditTriObject::moveMode        = NULL;
RotateModBoxCMode*  EditTriObject::rotMode 	       = NULL;
UScaleModBoxCMode*  EditTriObject::uscaleMode      = NULL;
NUScaleModBoxCMode* EditTriObject::nuscaleMode     = NULL;
SquashModBoxCMode*  EditTriObject::squashMode      = NULL;
SelectModBoxCMode*  EditTriObject::selectMode      = NULL;
WeldVertCMode*      EditTriObject::weldVertMode    = NULL;
CreateVertCMode*	EditTriObject::createVertMode  = NULL;
CreateFaceCMode*	EditTriObject::createFaceMode   = NULL;
TurnEdgeCMode*		EditTriObject::turnEdgeMode    = NULL;
DivideEdgeCMode*	EditTriObject::divideEdgeMode  = NULL;
AttachPickMode*		EditTriObject::attachPickMode  = NULL;
ExtrudeCMode*		EditTriObject::extrudeMode     = NULL;
BevelCMode*			EditTriObject::bevelMode     = NULL;
ChamferCMode * EditTriObject::chamferMode = NULL;
FlipNormCMode*      EditTriObject::flipMode        = NULL;
CutEdgeCMode *      EditTriObject::cutEdgeMode    = NULL;
DivideFaceCMode *	EditTriObject::divideFaceMode = NULL;
float               EditTriObject::normScale       = -1.0f;
BOOL                EditTriObject::selByVert       = FALSE;
BOOL                EditTriObject::inBuildFace     = FALSE;
BOOL                EditTriObject::inCutEdge     = FALSE;
BOOL                EditTriObject::faceUIValid     = FALSE;
BOOL				EditTriObject::inExtrude    = FALSE;
BOOL				EditTriObject::inBevel = FALSE;
BOOL				EditTriObject::inChamfer = FALSE;
int					EditTriObject::extType = MESH_EXTRUDE_CLUSTER;
BOOL                EditTriObject::ignoreBackfaces = FALSE;
BOOL                EditTriObject::ignoreVisEdge   = FALSE;
BOOL				EditTriObject::rsSel = TRUE;
BOOL				EditTriObject::rsAR = FALSE;
BOOL				EditTriObject::rsGeom = TRUE;
BOOL				EditTriObject::rsApprox = FALSE;
BOOL				EditTriObject::rsSurf = TRUE;
int                 EditTriObject::pickBoxSize     = DEF_PICKBOX_SIZE;
int                 EditTriObject::weldBoxSize     = DEF_PICKBOX_SIZE;
int                 EditTriObject::attachMat       = ATTACHMAT_IDTOMAT;
BOOL                EditTriObject::condenseMat     = FALSE;
bool                EditTriObject::sliceSplit = FALSE;
bool                EditTriObject::cutRefine = TRUE;
Quat               EditTriObject::sliceRot(0.0f,0.0f,0.0f,1.0f);
Point3            EditTriObject::sliceCenter(0.0f,0.0f,0.0f);
bool				EditTriObject::sliceMode = FALSE;
float				EditTriObject::sliceSize = 100.0f;
TempMoveRestore * EditTriObject::tempMove = NULL;

void EditTriObjectClassDesc::ResetClassParams (BOOL fileReset) {
	EditTriObject::normScale = -1.0f;
	EditTriObject::selByVert = FALSE;
	EditTriObject::inBuildFace = FALSE;
	EditTriObject::inCutEdge = FALSE;
	EditTriObject::inExtrude = FALSE;
	EditTriObject::inBevel = FALSE;
	EditTriObject::inChamfer = FALSE;
	EditTriObject::extType = MESH_EXTRUDE_CLUSTER;
	EditTriObject::ignoreBackfaces = FALSE;
	EditTriObject::ignoreVisEdge = FALSE;
	EditTriObject::rsSel = TRUE;
	EditTriObject::rsAR = FALSE;
	EditTriObject::rsGeom = TRUE;
	EditTriObject::rsApprox = TRUE;
	EditTriObject::rsSurf = TRUE;
	EditTriObject::pickBoxSize = DEF_PICKBOX_SIZE;
	EditTriObject::weldBoxSize = DEF_PICKBOX_SIZE;
	EditTriObject::attachMat = ATTACHMAT_IDTOMAT;
	EditTriObject::condenseMat = FALSE;
	EditTriObject::sliceSplit = FALSE;
	EditTriObject::cutRefine = TRUE;
	ResetEditableMeshUI();
}

static int hitLevel[] = {0, SUBHIT_VERTS,SUBHIT_EDGES,SUBHIT_FACES,
								SUBHIT_FACES, SUBHIT_FACES};

//--- EditTriObject methods ----------------------------------

EditTriObject::EditTriObject() {
	tempData = NULL;
	falloff = DEF_FALLOFF;
	pinch = 0.0f;
	bubble = 0.0f;
	selLevel = SL_OBJECT;
	GetMesh().selLevel = MESH_OBJECT;
	GetMesh().dispFlags = 0;
	affectRegion = FALSE;
	edgeIts = 0;
	useEdgeDist = FALSE;
	arIgBack = FALSE;
	arValid.SetEmpty();
	etFlags = 0;
	theHold.Suspend(); // DS 1/16/98
	MakeRefByID (FOREVER, ET_MASTER_CONTROL_REF, NewDefaultMasterPointController());
	theHold.Resume();	// DS 1/16/98
}

EditTriObject::~EditTriObject() {
	if (tempData) delete tempData;
	theHold.Suspend ();
	DeleteAllRefsFromMe ();
	theHold.Resume ();
}

RefTargetHandle EditTriObject::Clone(RemapDir& remap) {
	EditTriObject *ntri = new EditTriObject;
	ntri->mesh = mesh;
	ntri->mDispApprox = mDispApprox;
	ntri->mSubDivideDisplacement = mSubDivideDisplacement;
	ntri->mSplitMesh = mSplitMesh;
	ntri->mDisableDisplacement = mDisableDisplacement;
	for (int i=0; i<cont.Count(); i++) {
		if (cont[i] == NULL) continue;
		ntri->MakeRefByID (FOREVER, ET_VERT_BASE_REF + i, cont[i]->Clone (remap));
	}
	return ntri;
}

BOOL EditTriObject::IsSubClassOf(Class_ID classID) {
	return classID==ClassID() || classID==triObjectClassID;	
}

int EditTriObject::GetSubobjectLevel() {
	return selLevel;
}

void EditTriObject::SetSubobjectLevel(int level) {
	selLevel = level;
	switch (selLevel) {
	case SL_OBJECT:
		GetMesh().selLevel = MESH_OBJECT;
		GetMesh().dispFlags = 0;
		break;
	case SL_VERTEX:
		GetMesh().selLevel = MESH_VERTEX;
		if (ip && ip->GetShowEndResult()) GetMesh().dispFlags = 0;
		else GetMesh().dispFlags = DISP_VERTTICKS|DISP_SELVERTS;
		break;
	case SL_EDGE:
		GetMesh().selLevel = MESH_EDGE;
		GetMesh().dispFlags = DISP_SELEDGES;
		break;
	default:
		GetMesh().selLevel = MESH_FACE;
		if (selLevel==SL_FACE) GetMesh().dispFlags = DISP_SELFACES;
		else GetMesh().dispFlags = DISP_SELPOLYS;
		break;
	}
	InvalidateTempData (PART_SUBSEL_TYPE);
	if (hSel) RefreshSelType ();
	InvalidateNumberSelected ();
	if (ip) ip->RedrawViews (ip->GetTime());
}

bool CheckNodeSelection (Interface *ip, INode *inode) {
	if (!ip) return FALSE;
	if (!inode) return FALSE;
	int i, nct = ip->GetSelNodeCount();
	for (i=0; i<nct; i++) if (ip->GetSelNode (i) == inode) return TRUE;
	return FALSE;
}

int EditTriObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {	
	if (!ip) return 0;
	if (editObj != this) return 0;
	// Set up GW
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 tm = inode->GetObjectTM(t);
	if (!ip->GetShowEndResult()) return 0;
	if (selLevel == SL_OBJECT) return 0;

	DWORD savedLimits = gw->getRndLimits();
	gw->setRndLimits((savedLimits & ~GW_ILLUM) | GW_ALL_EDGES);
	gw->setTransform(tm);

	// We need to draw a "gizmo" version of the mesh:
	Point3 colSel=GetSubSelColor();
	Point3 colTicks=GetUIColor (COLOR_VERT_TICKS);
	Point3 colGiz=GetUIColor(COLOR_GIZMOS);
	Point3 colGizSel=GetUIColor(COLOR_SEL_GIZMOS);
	gw->setColor (LINE_COLOR, colGiz);
	Mesh & mesh = GetMesh();
	AdjEdgeList *ae = TempData()->AdjEList ();
	Point3 rp[3];
	int i, ect = ae->edges.Count();
	int es[3];
	for (i=0; i<ect; i++) {
		MEdge & me = ae->edges[i];
		if (me.Hidden (mesh.faces)) continue;
		if (me.Visible (mesh.faces)) {
			es[0] = GW_EDGE_VIS;
		} else {
			if (selLevel < SL_EDGE) continue;
			if (selLevel > SL_FACE) continue;
			es[0] = GW_EDGE_INVIS;
		}
		if (selLevel == SL_EDGE) {
			if (ae->edges[i].Selected (mesh.faces, mesh.edgeSel)) gw->setColor (LINE_COLOR, colGizSel);
			else gw->setColor (LINE_COLOR, colGiz);
		}
		if (selLevel >= SL_FACE) {
			if (ae->edges[i].AFaceSelected (mesh.faceSel)) gw->setColor (LINE_COLOR, colGizSel);
			else gw->setColor (LINE_COLOR, colGiz);
		}
		rp[0] = mesh.verts[me.v[0]];
		rp[1] = mesh.verts[me.v[1]];
		gw->polyline (2, rp, NULL, NULL, FALSE, es);
	}
	if (selLevel == SL_VERTEX) {
		float *ourvw = NULL;
		if (affectRegion) {
			ourvw = TempData()->VSWeight (useEdgeDist, edgeIts, arIgBack, falloff, pinch, bubble)->Addr(0);
		}
		for (i=0; i<mesh.numVerts; i++) {
			if (mesh.vertHide[i]) continue;

			if (mesh.vertSel[i]) gw->setColor (LINE_COLOR, colSel);
			else {
				if (ourvw) gw->setColor (LINE_COLOR, SoftSelectionColor(ourvw[i]));
				else gw->setColor (LINE_COLOR, colTicks);
			}

			if(getUseVertexDots()) gw->marker (&(mesh.verts[i]), getVertexDotType() ? DOT_MRKR : SM_DOT_MRKR);
			else gw->marker (&(mesh.verts[i]), PLUS_SIGN_MRKR);
		}
	}
	if (inBuildFace && (editObj==this)) {
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SUBSELECTION));
		createFaceMode->proc.DrawEstablishedFace (gw);
	}

	gw->setRndLimits(savedLimits);
	return 0;	
}

void EditTriObject::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	if (!ip || editObj != this) return;
	box.Init();
	Matrix3 tm = inode->GetObjectTM(t);

	if (ip->GetShowEndResult() && (selLevel != SL_OBJECT)) {
		// We need to draw a "gizmo" version of the mesh:
		Mesh & mesh = GetMesh();
		box = mesh.getBoundingBox (&tm);
	}
}

int EditTriObject::Display (TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	TriObject::Display (t, inode, vpt, flags);
	if (!CheckNodeSelection (ip, inode)) return 0;
	GraphicsWindow *gw = vpt->getGW();
	Matrix3 tm = inode->GetObjectTM(t);
	int savedLimits;

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);

	if (sliceMode) {
		// Draw rectangle representing slice plane.
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));

		Point3 rp[5];
		Matrix3 rotMatrix;
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rp[0] = Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
		rp[1] = Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[2] = Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[3] = Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
		gw->polyline (4, rp, NULL, NULL, TRUE, NULL);
	}

	if (inBuildFace && (editObj==this)) {
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SUBSELECTION));
		createFaceMode->proc.DrawEstablishedFace (gw);
	}

	gw->setRndLimits(savedLimits);
	return 0;
}

void EditTriObject::GetWorldBoundBox (TimeValue t, INode* inode, ViewExp* vp, Box3& box ) {
	TriObject::GetWorldBoundBox (t, inode, vp, box);
	if (!sliceMode) return;
	if (!CheckNodeSelection (ip, inode)) return;
	Matrix3 tm = inode->GetObjectTM(t);
	Matrix3 rotMatrix;
	sliceRot.MakeMatrix (rotMatrix);
	rotMatrix.SetTrans (sliceCenter);
	rotMatrix *= tm;
	box += Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
	box += Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
	box += Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
	box += Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
}

void EditTriObject::GetLocalBoundBox (TimeValue t, INode* inode, ViewExp* vp, Box3& box ) {
	TriObject::GetLocalBoundBox (t, inode, vp, box);
	if (!sliceMode) return;
	if (!CheckNodeSelection (ip, inode)) return;
	Matrix3 rotMatrix;
	sliceRot.MakeMatrix (rotMatrix);
	rotMatrix.SetTrans (sliceCenter);
	box += Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
	box += Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
	box += Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
	box += Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
}

int EditTriObject::HitTest (TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	Interval valid;
	int savedLimits, res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	
	// Setup GW
	MakeHitRegion(hr,type, crossing, pickBoxSize, p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);

	if (ignoreBackfaces) gw->setRndLimits(gw->getRndLimits() |  GW_BACKCULL);
	else gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
	gw->clearHitCode();	

	if (sliceMode && CheckNodeSelection (ip, inode)) {
		Point3 rp[5];
		Matrix3 rotMatrix;
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rp[0] = Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
		rp[1] = Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[2] = Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[3] = Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
		gw->polyline (4, rp, NULL, NULL, TRUE, NULL);
		if (gw->checkHitCode()) {
			vpt->LogHit (inode, mc, gw->getHitDistance(), 0, NULL);
			res = 1;
		}
		gw->setRndLimits (savedLimits);
		return res;
	}

	SubObjHitList hitList;
	MeshSubHitRec *rec;
	DWORD hitLev = hitLevel[selLevel];
	int localSelByVert = selByVert;
	if (cutEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (turnEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideFaceMode == ip->GetCommandMode()) localSelByVert = FALSE;

	if (inBuildFace || localSelByVert) hitLev = SUBHIT_VERTS;
	else if (inCutEdge) hitLev = SUBHIT_EDGES;

	if (hitLev == SUBHIT_VERTS) {
		BitArray oldHide;
		if (ignoreBackfaces) {
			BOOL flip = mat.Parity();
			oldHide = GetMesh().vertHide;
			BitArray faceBack;
			faceBack.SetSize (GetMesh().numFaces);
			faceBack.ClearAll ();
			for (int i=0; i<GetMesh().numFaces; i++) {
				DWORD *vv = GetMesh().faces[i].v;
				IPoint3 A[3];
				for (int j=0; j<3; j++) gw->wTransPoint (&(GetMesh().verts[vv[j]]), &(A[j]));
				IPoint3 d1 = A[1] - A[0];
				IPoint3 d2 = A[2] - A[0];
				if (flip) {
					if ((d1^d2).z > 0) continue;
				} else {
					if ((d1^d2).z < 0) continue;
				}
				for (j=0; j<3; j++) GetMesh().vertHide.Set (vv[j]);
				faceBack.Set (i);
			}
			for (i=0; i<GetMesh().numFaces; i++) {
				if (faceBack[i]) continue;
				DWORD *vv = GetMesh().faces[i].v;
				for (int j=0; j<3; j++) GetMesh().vertHide.Clear (vv[j]);
			}
			GetMesh().vertHide |= oldHide;
		}
		DWORD thisFlags = flags | hitLev;
		if ((selLevel != SL_VERTEX) && localSelByVert) thisFlags |= SUBHIT_USEFACESEL;
		res = GetMesh().SubObjectHitTest(gw, gw->getMaterial(), &hr, thisFlags, hitList);
		if (ignoreBackfaces) GetMesh().vertHide = oldHide;
	} else {
		res = GetMesh().SubObjectHitTest(gw, gw->getMaterial(), &hr, flags|hitLev, hitList);
	}

	rec = hitList.First();
	while (rec) {
		vpt->LogHit(inode,mc,rec->dist,rec->index,NULL);
		rec = rec->Next();
	}

	gw->setRndLimits(savedLimits);	
	return res;
}

void EditTriObject::SelectSubComponent (HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert) {
	if (selLevel == SL_OBJECT) return;
	if (!ip) return;
	if (sliceMode) return;
	ip->ClearCurNamedSelSet ();
	TimeValue t = ip->GetTime();
	EndExtrude (t, FALSE);	// STEVE: necessary?
	EndBevel (t, FALSE);	// STEVE: necessary?
	int localSelByVert = selByVert;
	if (cutEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (turnEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideFaceMode == ip->GetCommandMode()) localSelByVert = FALSE;

	AdjFaceList *af=NULL;
	AdjEdgeList *ae=NULL;
	BitArray nsel;
	HitRecord *hr;
	if (selLevel>=SL_POLY) af = TempData()->AdjFList();
	if (localSelByVert) ae = TempData()->AdjEList();

	switch (selLevel) {
	case SL_VERTEX:
		nsel = GetMesh().vertSel;
		nsel.SetSize (GetMesh().numVerts, TRUE);
		for (hr=hitRec; hr!=NULL; hr = hr->Next()) {
			nsel.Set (hr->hitInfo, invert ? !GetMesh().vertSel[hr->hitInfo] : selected);
			if (!all) break;
		}
		SetVertSel (nsel, this, t);
		// JBW: macro-recorder
		macroRecorder->FunctionCall(_T("select"), 1, 0, mr_index, mr_prop, _T("verts"), mr_reftarg, this, mr_bitarray, &GetMesh().vertSel);
		break;

	case SL_EDGE:
		nsel = GetMesh().edgeSel;
		for (hr=hitRec; hr != NULL; hr=hr->Next()) {
			if (localSelByVert) {
				DWORDTab & list = ae->list[hr->hitInfo];
				for (int i=0; i<list.Count(); i++) {
					MEdge & me = ae->edges[list[i]];
					for (int j=0; j<2; j++) {
						if (me.f[j] == UNDEFINED) continue;
						DWORD ei = GetMesh().faces[me.f[j]].GetEdgeIndex (me.v[0], me.v[1]);
						if (ei>2) continue;
						ei += me.f[j]*3;
						nsel.Set (ei, invert ? !GetMesh().edgeSel[ei] : selected);
					}
				}
			} else {
				nsel.Set (hr->hitInfo, invert ? !nsel[hr->hitInfo] : selected);
			}
			if (!all) break;
		}
		SetEdgeSel (nsel, this, t);
		// JBW: macro-recorder
		macroRecorder->FunctionCall(_T("select"), 1, 0, mr_index, mr_prop, _T("edges"), mr_reftarg, this, mr_bitarray, &GetMesh().edgeSel);
		break;

	case SL_FACE:
		nsel = GetMesh().faceSel;
		for (hr=hitRec; hr != NULL; hr = hr->Next()) {
			if (localSelByVert) {
				DWORDTab & list = ae->list[hr->hitInfo];
				for (int i=0; i<list.Count(); i++) {
					MEdge & me = ae->edges[list[i]];
					for (int j=0; j<2; j++) {
						if (me.f[j] == UNDEFINED) continue;
						nsel.Set (me.f[j], invert ? !GetMesh().faceSel[me.f[j]] : selected);
					}
				}
			} else {
				nsel.Set (hr->hitInfo, invert ? !GetMesh().faceSel[hr->hitInfo] : selected);
			}
			if (!all) break;
		}
		SetFaceSel (nsel, this, t);

		// JBW: macro-recorder
		macroRecorder->FunctionCall(_T("select"), 1, 0, mr_index, mr_prop, _T("faces"), mr_reftarg, this, mr_bitarray, &GetMesh().faceSel);
		break;

	case SL_POLY:
	case SL_ELEMENT:
		nsel.SetSize (GetMesh().getNumFaces());
		for (hr=hitRec; hr != NULL; hr=hr->Next()) {
			if (!localSelByVert) {
				if (selLevel==SL_ELEMENT) GetMesh().ElementFromFace (hr->hitInfo, nsel, af);
				else GetMesh().PolyFromFace (hr->hitInfo, nsel, GetPolyFaceThresh(), ignoreVisEdge, af);
			} else {
				DWORDTab & list = ae->list[hr->hitInfo];
				for (int i=0; i<list.Count(); i++) {
					MEdge & me = ae->edges[list[i]];
					for (int j=0; j<2; j++) {
						if (me.f[j] == UNDEFINED) continue;
						if (selLevel==SL_ELEMENT) GetMesh().ElementFromFace (me.f[j], nsel, af);
						else GetMesh().PolyFromFace (me.f[j], nsel, GetPolyFaceThresh(), ignoreVisEdge, af);
					}
				}
			}
			if (!all) break;
		}
		if (invert) nsel ^= GetMesh().faceSel;
		else {
			if (selected) nsel |= GetMesh().faceSel;
			else nsel = GetMesh().faceSel & ~nsel;
		}
		SetFaceSel (nsel, this, t);

		// JBW: macro-recorder
		macroRecorder->FunctionCall(_T("select"), 1, 0, mr_index, mr_prop, _T("faces"), mr_reftarg, this, mr_bitarray, &GetMesh().faceSel);
		break;
	};
	LocalDataChanged();
}

void EditTriObject::ClearSelection(int sl) {
	if (sliceMode) return;
	BitArray sel;
	switch (sl) {
	case SL_OBJECT: return;
	case SL_VERTEX:
		sel.SetSize (GetMesh().getNumVerts());
		sel.ClearAll ();
		SetVertSel (sel, this, ip->GetTime());
		break;
	case SL_EDGE:
		sel.SetSize (GetMesh().getNumFaces()*3);
		sel.ClearAll();
		SetEdgeSel (sel, this, ip->GetTime());
		break;
	default:
		sel.SetSize (GetMesh().getNumFaces());
		sel.ClearAll ();
		SetFaceSel (sel, this, ip->GetTime());
		break;
	}
	LocalDataChanged ();
}

void EditTriObject::SelectAll(int sl) {
	if (sl == SL_OBJECT) return;
	if (sliceMode) return;
	BitArray sel;
	switch (sl) {
	case SL_VERTEX: 
		sel.SetSize (GetMesh().numVerts);
		sel.SetAll();
		SetVertSel (sel, this, ip->GetTime());
		break;
	case SL_EDGE:   
		sel.SetSize (GetMesh().numFaces*3);
		sel.SetAll(); 
		SetEdgeSel (sel, this, ip->GetTime());
		break;
	default:
		sel.SetSize (GetMesh().numFaces);
		sel.SetAll(); 
		SetFaceSel (sel, this, ip->GetTime());
		break;
	}
	LocalDataChanged ();
}

void EditTriObject::InvertSelection(int sl) {
	if (sl == SL_OBJECT) return;
	if (sliceMode) return;
	BitArray sel;
	switch (sl) {
	case SL_VERTEX: 
		sel = ~GetMesh().vertSel;
		SetVertSel (sel, this, ip->GetTime());
		break;
	case SL_EDGE:
		sel = ~GetMesh().edgeSel;
		SetEdgeSel (sel, this, ip->GetTime());
		break;
	default:
		sel = ~GetMesh().faceSel; 
		SetFaceSel (sel, this, ip->GetTime());
		break;
	}
	LocalDataChanged ();
}

BOOL EditTriObject::SelectSubAnim(int subNum) {
	if (!subNum) return FALSE;	// cannot select master point controller.
	subNum--;
	if (subNum >= GetMesh().numVerts) return FALSE;

	BOOL add = GetKeyState(VK_CONTROL)<0;
	BOOL sub = GetKeyState(VK_MENU)<0;
	BitArray nvs;

	if (add || sub) {
		nvs = GetMesh().vertSel;
		nvs.SetSize (GetMesh().numVerts, TRUE);
		if (sub) nvs.Clear (subNum);
		else nvs.Set (subNum);
	} else {
		nvs.SetSize (GetMesh().numVerts);
		nvs.ClearAll ();
		nvs.Set (subNum);
	}

	if (ip) SetVertSel (nvs, this, ip->GetTime());
	else SetVertSel (nvs, this, TimeValue(0));
	LocalDataChanged ();
	return TRUE;
}

void EditTriObject::ActivateSubobjSel (int level, XFormModes& modes) {
	// Register or unregister delete key notification
	if (selLevel==SL_OBJECT && level!=SL_OBJECT) ip->RegisterDeleteUser(this);
	if (selLevel!=SL_OBJECT && level==SL_OBJECT) ip->UnRegisterDeleteUser(this);

	if ((selLevel != level) && ((level<SL_FACE) || (selLevel<SL_FACE))) {
		ExitAllCommandModes (level == SL_OBJECT);
	}

	// Set the meshes level
	SetSubobjectLevel(level);

	if (level == SL_EDGE) GetMesh().InvalidateEdgeList();

	// Fill in modes with our sub-object modes
	if (level!=SL_OBJECT)
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);

	// Setup named selection sets
	if (level != SL_OBJECT) {
		GenericNamedSelSetList &set = GetSelSet();
		ip->ClearSubObjectNamedSelSets();
		for (int i=0; i<set.Count(); i++) {
			ip->AppendSubObjectNamedSelSet(*(set.names[i]));
		}
	}
	ip->PipeSelLevelChanged();
	UpdateNamedSelDropDown ();
	InvalidateTempData (PART_TOPO|PART_GEOM|PART_SELECT|PART_SUBSEL_TYPE);
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);
}

GenericNamedSelSetList &EditTriObject::GetSelSet() {
	return selSet[namedSetLevel[selLevel]];
}

void EditTriObject::GetSubObjectCenters(SubObjAxisCallback *cb,
										TimeValue t, INode *node,ModContext *mc) {
	Matrix3 tm = node->GetObjectTM(t);

	if (sliceMode) {
		cb->Center (sliceCenter*tm, 0);
		return;
	}

	if (selLevel == SL_OBJECT) return;
	if (selLevel == SL_VERTEX) {
		BitArray sel = GetMesh().VertexTempSel();
		Point3 cent(0,0,0);
		int ct=0;
		for (int i=0; i<GetMesh().getNumVerts(); i++) {
			if (sel[i]) {
				cent += GetMesh().verts[i];
				ct++;
			}
		}
		if (ct) {
			cent /= float(ct);			
			cb->Center(cent*tm,0);
		}
		return;
	}

	Tab<Point3> *centers = TempData()->ClusterCenters((selLevel==SL_EDGE) ? MESH_EDGE : MESH_FACE);
	for (int i=0; i<centers->Count(); i++) cb->Center((*centers)[i]*tm,i);
}

void EditTriObject::GetSubObjectTMs (SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc) {	
	Matrix3 tm, otm = node->GetObjectTM(t);

	if (sliceMode) {
		Matrix3 rotMatrix(1);
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rotMatrix *= otm;
		cb->TM (rotMatrix, 0);
		return;
	}

	switch (selLevel) {
	case SL_OBJECT:
		break;

	case SL_VERTEX:
		if (ip->GetCommandMode()->ID()==CID_SUBOBJMOVE) {
			Tab<Point3> * vnorms = TempData()->VertexNormals ();
			Matrix3 otm = node->GetObjectTM(t);			
			for (int i=0; i<vnorms->Count(); i++) {
				if (!GetMesh().vertSel[i]) continue;
				Point3 n = VectorTransform (otm, (*vnorms)[i]);
				n = Normalize(n);
				MatrixFromNormal (n, tm);
				tm.SetTrans(GetMesh().verts[i]*otm);
				cb->TM(tm,i);
			}
		} else {
			if (GetMesh().vertSel.NumberSet()==0) return;
			Point3 norm;
			Point3 cent(0,0,0);
			int ct=0;
			
			// Comute average face normal
			norm = AverageSelVertNormal(GetMesh());

			// Compute center of selection
			for (int i=0; i<GetMesh().getNumVerts(); i++) {
				if (GetMesh().vertSel[i]) {
					cent += GetMesh().verts[i];
					ct++;
				}
			}
			if (ct) cent /= float(ct);
			cent = cent * otm;
			norm = Normalize(VectorTransform(otm,norm));
			Matrix3 mat;
			MatrixFromNormal(norm,mat);
			mat.SetTrans(cent);
			cb->TM(mat,0);
		}
		break;

	case SL_EDGE:
		int i, ct;
		ct = TempData()->ClusterNormals(MESH_EDGE)->Count();
		for (i=0; i<ct; i++) {
			tm = TempData()->ClusterTM (i) * otm;
			cb->TM(tm,i);
		}
		break;

	default:
		ct = TempData()->ClusterNormals(MESH_FACE)->Count();
		for (i=0; i<ct; i++) {
			tm = TempData()->ClusterTM (i) * otm;
			cb->TM(tm,i);
		}
		break;
	}
}

void EditTriObject::ShowEndResultChanged (BOOL showEndResult) {
	if ((!ip) || (editObj != this)) return;
	if ((selLevel == SL_VERTEX) || inBuildFace) {
		if (showEndResult) GetMesh().dispFlags = 0;
		else GetMesh().dispFlags = DISP_VERTTICKS | DISP_SELVERTS;
	}
	NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
}

// --- Restore objects ---------------------------------------------

// Not a real restore object:
TempMoveRestore::TempMoveRestore (EditTriObject *em) {
	init.SetCount (em->GetMesh().numVerts);
	if (init.Count()) memcpy (init.Addr(0), em->GetMesh().verts, init.Count()*sizeof(Point3));
	active.SetSize (em->GetMesh().numVerts);
	active.ClearAll ();
}

void TempMoveRestore::Restore (EditTriObject *em) {
	if (!init.Count()) return;
	memcpy (em->GetMesh().verts, init.Addr(0), init.Count()*sizeof(Point3));
}

MeshSelRestore::MeshSelRestore(EditTriObject *et) {
	this->et = et;
	selLevel    = et->selLevel;
	switch (selLevel) {
	case SL_VERTEX: undo = et->GetMesh().vertSel; break;
	case SL_EDGE:   undo = et->GetMesh().edgeSel; break;
	default:   undo = et->GetMesh().faceSel; break;
	}
}

MeshSelRestore::MeshSelRestore(EditTriObject *et, int selLev) {
	this->et = et;
	selLevel = selLev;
	switch (selLevel) {
	case SL_VERTEX: undo = et->GetMesh().vertSel; break;
	case SL_EDGE:   undo = et->GetMesh().edgeSel; break;
	default:   undo = et->GetMesh().faceSel; break;
	}
}

void MeshSelRestore::Restore(int isUndo) {
	switch (selLevel) {
	case SL_VERTEX: 
		redo = et->GetMesh().vertSel; 
		et->GetMesh().vertSel = undo;
		break;
	case SL_EDGE:   
		redo = et->GetMesh().edgeSel;
		et->GetMesh().edgeSel = undo;
		break;
	default:
		redo = et->GetMesh().faceSel; 
		et->GetMesh().faceSel = undo;
		break;
	}
	et->LocalDataChanged();
}

void MeshSelRestore::Redo() {
	switch (selLevel) {
	case SL_VERTEX:
		et->GetMesh().vertSel = redo;
		break;
	case SL_EDGE:   			
		et->GetMesh().edgeSel = redo;
		break;
	default:
		et->GetMesh().faceSel = redo;
		break;
	}
	et->LocalDataChanged();
}

MeshVertRestore::MeshVertRestore(EditTriObject *et) {
	this->et = et;
	undo.SetCount(et->GetMesh().getNumVerts());
	for (int i=0; i<et->GetMesh().getNumVerts(); i++) undo[i] = et->GetMesh().verts[i];
	rvData = NULL;
	int vdNum = et->GetMesh().vdSupport.GetSize();
	if (!vdNum) {
		uvData = NULL;
		return;
	}
	uvdSupport = et->GetMesh().vdSupport;
	uvData = new PerData[vdNum];
	for (i=0; i<vdNum; i++) uvData[i] = et->GetMesh().vData[i];
}

void MeshVertRestore::Restore(int isUndo) {
	int i, vdNum;
	if (isUndo) {
		redo.SetCount(et->GetMesh().getNumVerts());
		if (redo.Count()) memcpy (redo.Addr(0), et->GetMesh().verts, redo.Count()*sizeof(Point3));
		vdNum = et->GetMesh().vdSupport.GetSize();
		if (vdNum && !rvData) {
			rvdSupport = et->GetMesh().vdSupport;
			rvData = new PerData[vdNum];
			for (i=0; i<vdNum; i++) rvData[i] = et->GetMesh().vData[i];
		}
	}
	et->GetMesh().setNumVerts(undo.Count());
	if (undo.Count()) memcpy (et->GetMesh().verts, undo.Addr(0), undo.Count()*sizeof(Point3));
	et->GetMesh().setNumVData (vdNum = uvdSupport.GetSize());
	if (vdNum) {
		et->GetMesh().vdSupport = uvdSupport;
		for (i=0; i<vdNum; i++) et->GetMesh().vData[i] = uvData[i];
	}
	et->GetMesh().InvalidateGeomCache();
	et->InvalidateTempData (PART_GEOM);
	et->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
}

void MeshVertRestore::Redo() {
	int i, vdNum;
	et->GetMesh().setNumVerts(redo.Count());
	if (redo.Count()) memcpy (et->GetMesh().verts, redo.Addr(0), redo.Count()*sizeof(Point3));
	et->GetMesh().setNumVData (vdNum = rvdSupport.GetSize());
	if (vdNum) {
		et->GetMesh().vdSupport = rvdSupport;
		for (i=0; i<vdNum; i++) et->GetMesh().vData[i] = rvData[i];
	}
	et->GetMesh().InvalidateGeomCache();
	et->InvalidateTempData (PART_GEOM);
	et->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
}

MeshTopoRestore::MeshTopoRestore(EditTriObject *et, DWORD chan) {
	this->et = et;
	channels = chan|PART_SELECT;
	if (channels & PART_TOPO) channels |= PART_GEOM;
	umesh.DeepCopy (&(et->GetMesh()), channels);
	umesh.numFaces = et->GetMesh().numFaces;	// protects against PART_VERT_COLOR without PART_TOPO.
	ucont = et->cont;
	undone = FALSE;
}

void MeshTopoRestore::Restore(int isUndo) {
	if (!undone) {
		undone = TRUE;
		// Save for redo
		rmesh.DeepCopy (&(et->GetMesh()), channels);
		rmesh.numFaces = et->GetMesh().numFaces;	// protects against PART_VERT_COLOR without PART_TOPO.
		rcont = et->cont;
	}

	et->GetMesh().DeepCopy (&umesh, channels);
	// RK: 05/07/99 Can't just copy the cont tab, has to call 
	// SetPtCont() on every controller to restore master controller properly	
	// RK:5/11/99 -- Replaced it with much shorter ReplaceContArray()
	et->ReplaceContArray(ucont);
	//et->cont = ucont;	
	
	et->LocalDataChanged (channels);
	et->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
}

void MeshTopoRestore::Redo() {
	if (!undone) return;
	et->GetMesh().DeepCopy (&rmesh, channels);
	// RK: 05/07/99 Can't just copy the cont tab, has to call 
	// SetPtCont() on every controller to restore master controller properly
	// RK:5/11/99 -- Replaced it with much shorter ReplaceContArray()
	et->ReplaceContArray(rcont);
	//et->cont = rcont;	
	et->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	et->LocalDataChanged (channels);
}

MeshVertHideRestore::MeshVertHideRestore(EditTriObject *et) {
	this->et = et;
	undo = et->GetMesh().vertHide;
}

void MeshVertHideRestore::Restore(int isUndo) {
	redo = et->GetMesh().vertHide;
	et->GetMesh().vertHide = undo;
	et->NotifyDependents(FOREVER, DISP_ATTRIB_CHANNEL, REFMSG_CHANGE);
}

void MeshVertHideRestore::Redo() {
	et->GetMesh().vertHide = redo;
	et->NotifyDependents(FOREVER, DISP_ATTRIB_CHANNEL, REFMSG_CHANGE);
}

MeshFaceHideRestore::MeshFaceHideRestore(EditTriObject *et) {
	this->et = et;
	undo.SetSize(et->GetMesh().getNumFaces());
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) undo.Set(i,et->GetMesh().faces[i].Hidden());
}

void MeshFaceHideRestore::Restore(int isUndo) {
	redo.SetSize(et->GetMesh().getNumFaces());
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) {
		redo.Set(i,et->GetMesh().faces[i].Hidden());
		et->GetMesh().faces[i].SetHide(undo[i]);
	}
	et->GetMesh().InvalidateTopologyCache();
	et->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

void MeshFaceHideRestore::Redo() {
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) et->GetMesh().faces[i].SetHide(redo[i]);
	et->GetMesh().InvalidateTopologyCache();
	et->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

MeshFaceMatRestore::MeshFaceMatRestore(EditTriObject *et) {
	this->et = et;
	undo.SetCount(et->GetMesh().getNumFaces());
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) undo[i] = et->GetMesh().faces[i].getMatID();
}

void MeshFaceMatRestore::Restore(int isUndo) {
	redo.SetCount(et->GetMesh().getNumFaces());
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) {
		redo[i] = et->GetMesh().faces[i].getMatID();
		et->GetMesh().faces[i].setMatID(undo[i]);
	}
	et->InvalidateSurfaceUI();
	et->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

void MeshFaceMatRestore::Redo() {
	for (int i=0; i<et->GetMesh().getNumFaces(); i++) et->GetMesh().faces[i].setMatID(undo[i]);
	et->InvalidateSurfaceUI();
	et->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

//--- Saving/Loading --------------------------------

#define VSELSET_CHUNK			0x2845
#define FSELSET_CHUNK			0x2846
#define ESELSET_CHUNK			0x2847
#define SELSET_SET_CHUNK		0x2849
#define SELSET_NAME_CHUNK		0x2850
#define SELSETS_CHUNK			0x3001
#define VERTCOUNT_CHUNKID		0x3002
#define GENSELSET_ID_CHUNK     0x3003
#define GENSELSET_CHUNK     0x3004
#define AR_CHUNK  0x4020
#define FALLOFF_CHUNK 0x4024
#define PINCH_CHUNK 0x4025
#define BUBBLE_CHUNK 0x4026
#define EDIST_CHUNK 0x402c
#define EDGE_ITS_CHUNK 0x402d
#define IG_BACK_CHUNK 0x4030
#define ETOBJ_FLAGS_CHUNK 0x4034
#define ETOBJ_SELLEVEL_CHUNK 0x4038
#define ETOBJ_REF_VERSION_CHUNK  0x403b

// Old pre-3.0 named selection sets:
class NamedSelSetList {
public:
	Tab<BitArray*> sets;
	Tab<TSTR*>	   names;
	int Count() {return sets.Count();}
	IOResult Load(ILoad *iload);
};

IOResult NamedSelSetList::Load(ILoad *iload) {
	IOResult res;
	BitArray *set=NULL;
	TSTR *name=NULL;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case SELSET_SET_CHUNK:
			set = new BitArray();
			res = set->Load(iload);
			sets.Append (1, &set);
			break;

		case SELSET_NAME_CHUNK:
			TCHAR *ptr;				
			iload->ReadWStringChunk(&ptr);
			name = new TSTR(ptr);
			names.Append (1, &name);
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}
	return IO_OK;
}

/*  No longer used:
IOResult NamedSelSetList::Save(ISave *isave) {
	for (int i=0; i<sets.Count(); i++) {
		isave->BeginChunk(SELSET_SET_CHUNK);
		sets[i]->Save(isave);
		isave->EndChunk();

		isave->BeginChunk(SELSET_NAME_CHUNK);
		isave->WriteWString(*names[i]);
		isave->EndChunk();
	}
	return IO_OK;
}
*/

IOResult EditTriObject::Load(ILoad *iload) {
	ulong nb;
	IOResult res;
	loadRefVersion = 0;
	bool selLevLoaded = FALSE;

	if (iload->PeekNextChunkID()==SELSETS_CHUNK) {
		NamedSelSetList oldVSelSet, oldESelSet, oldFSelSet;
		iload->OpenChunk();
		while (IO_OK==(res=iload->OpenChunk())) {
			switch(iload->CurChunkID()) {
			case VSELSET_CHUNK:
				res = oldVSelSet.Load(iload);
				break;
			case FSELSET_CHUNK:
				res = oldFSelSet.Load(iload);
				break;
			case ESELSET_CHUNK:
				res = oldESelSet.Load(iload);
				break;
			}
			iload->CloseChunk();
			if (res!=IO_OK) return res;
		}
		iload->CloseChunk();
		int i, ct;
		if (ct=oldVSelSet.Count()) {
			selSet[NS_VERTEX].names.SetCount (ct);
			selSet[NS_VERTEX].sets.SetCount (ct);
			selSet[NS_VERTEX].ids.SetCount (ct);
			for (i=0; i<ct; i++) {
				selSet[NS_VERTEX].names[i] = oldVSelSet.names[i];
				selSet[NS_VERTEX].sets[i] = oldVSelSet.sets[i];
				selSet[NS_VERTEX].ids[i] = (DWORD) i;
				oldVSelSet.names[i] = NULL;
				oldVSelSet.sets[i] = NULL;
			}
		}
		if (ct=oldFSelSet.Count()) {
			selSet[NS_FACE].names.SetCount (ct);
			selSet[NS_FACE].sets.SetCount (ct);
			selSet[NS_FACE].ids.SetCount (ct);
			for (i=0; i<ct; i++) {
				selSet[NS_FACE].names[i] = oldFSelSet.names[i];
				selSet[NS_FACE].sets[i] = oldFSelSet.sets[i];
				selSet[NS_FACE].ids[i] = (DWORD) i;
				oldFSelSet.names[i] = NULL;
				oldFSelSet.sets[i] = NULL;
			}
		}
		if (ct=oldESelSet.Count()) {
			selSet[NS_EDGE].names.SetCount (ct);
			selSet[NS_EDGE].sets.SetCount (ct);
			selSet[NS_EDGE].ids.SetCount (ct);
			for (i=0; i<ct; i++) {
				selSet[NS_EDGE].names[i] = oldESelSet.names[i];
				selSet[NS_EDGE].sets[i] = oldESelSet.sets[i];
				selSet[NS_EDGE].ids[i] = (DWORD) i;
				oldESelSet.names[i] = NULL;
				oldESelSet.sets[i] = NULL;
			}
		}
	}

	while (iload->PeekNextChunkID() == GENSELSET_ID_CHUNK) {
		int which;
		iload->OpenChunk();
		res = iload->Read(&which, sizeof(int), &nb);
		iload->CloseChunk ();
		if (res!=IO_OK) return res;

		if (iload->PeekNextChunkID() != GENSELSET_CHUNK) break;
		iload->OpenChunk ();
		res = selSet[which].Load(iload);
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}

	if (iload->PeekNextChunkID()==VERTCOUNT_CHUNKID) {		
		int ct;
		iload->OpenChunk();
		iload->Read(&ct,sizeof(ct),&nb);
		iload->CloseChunk();
		AllocContArray(ct);
		for (int i=0; i<ct; i++) SetPtCont(i, NULL);
	}

	if (iload->PeekNextChunkID () == AR_CHUNK) {
		iload->OpenChunk ();
		if ((res = iload->Read (&affectRegion, sizeof(int), &nb)) != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == FALLOFF_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&falloff, sizeof(float), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == PINCH_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&pinch, sizeof(float), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == BUBBLE_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&bubble, sizeof(float), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == EDIST_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&useEdgeDist, sizeof(int), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == EDGE_ITS_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&edgeIts, sizeof(int), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == IG_BACK_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&arIgBack, sizeof(int), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == ETOBJ_FLAGS_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&etFlags, sizeof(DWORD), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	if (iload->PeekNextChunkID() == ETOBJ_SELLEVEL_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read (&selLevel, sizeof(DWORD), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
		selLevLoaded = TRUE;
	}

	if (iload->PeekNextChunkID() == ETOBJ_REF_VERSION_CHUNK) {
		iload->OpenChunk ();
		res = iload->Read(&loadRefVersion,sizeof(int), &nb);
		if (res != IO_OK) return res;
		iload->CloseChunk ();
	}

	IOResult ret = TriObject::Load (iload);
	if (!selLevLoaded) {
		switch (GetMesh().selLevel) {
		case MESH_OBJECT: selLevel = SL_OBJECT; break;
		case MESH_VERTEX: selLevel = SL_VERTEX; break;
		case MESH_EDGE: selLevel = SL_EDGE; break;
		case MESH_FACE: selLevel = SL_POLY; break;
		}
	}
	return ret;
}

IOResult EditTriObject::Save(ISave *isave) {	
	int ct = cont.Count();
	ulong nb;

	for (int j=0; j<3; j++) {
		if (!selSet[j].Count()) continue;
		isave->BeginChunk(GENSELSET_ID_CHUNK);
		isave->Write (&j, sizeof(j), &nb);
		isave->EndChunk ();
		isave->BeginChunk (GENSELSET_CHUNK);
		selSet[j].Save(isave);
		isave->EndChunk();
	}
	
	if (ct) {
		isave->BeginChunk(VERTCOUNT_CHUNKID);
		isave->Write(&ct,sizeof(ct),&nb);
		isave->EndChunk();
	}

	isave->BeginChunk (AR_CHUNK);
	isave->Write (&affectRegion, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (FALLOFF_CHUNK);
	isave->Write (&falloff, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (PINCH_CHUNK);
	isave->Write (&pinch, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (BUBBLE_CHUNK);
	isave->Write (&bubble, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (EDIST_CHUNK);
	isave->Write (&useEdgeDist, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (EDGE_ITS_CHUNK);
	isave->Write (&edgeIts, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (IG_BACK_CHUNK);
	isave->Write (&arIgBack, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (ETOBJ_FLAGS_CHUNK);
	isave->Write (&etFlags, sizeof(DWORD), &nb);
	isave->EndChunk();

	isave->BeginChunk (ETOBJ_SELLEVEL_CHUNK);
	isave->Write (&selLevel, sizeof(DWORD), &nb);
	isave->EndChunk ();

	isave->BeginChunk (ETOBJ_REF_VERSION_CHUNK);
	int refVersion = 1;
	isave->Write (&refVersion, sizeof(int), &nb);
	isave->EndChunk ();

	return TriObject::Save(isave);
}

void EditTriObject::ActivateSubSelSet(TSTR &setName) {
	if (selLevel == SL_OBJECT) return;

	BitArray *sset;
	int nsl = namedSetLevel[selLevel];
	sset = selSet[nsl].GetSet(setName);
	if (sset==NULL) return;
	theHold.Begin ();
	SetSel (nsl, *sset, this, ip->GetTime());
	LocalDataChanged ();
	theHold.Accept (GetString (IDS_EM_SELECT));
}

void EditTriObject::NewSetFromCurSel(TSTR &setName) {
	if (selLevel == SL_OBJECT) return;
	BitArray *sset;
	int nsl = namedSetLevel[selLevel];
	sset = selSet[nsl].GetSet(setName);
	if (sset) *sset = GetSel (nsl);
	else selSet[nsl].AppendSet (GetSel(nsl), 0, setName);
}

void EditTriObject::RemoveSubSelSet(TSTR &setName) {
	GenericNamedSelSetList &set = GetSelSet();
	BitArray *ssel = set.GetSet(setName);
	if (ssel) {
		if (theHold.Holding()) theHold.Put (new DeleteSetRestore (setName, &set, this));
		set.RemoveSet (setName);
	}
	ip->ClearCurNamedSelSet();
}

void EditTriObject::SetupNamedSelDropDown() {
	// Setup named selection sets
	if (selLevel == SL_OBJECT) return;
	GenericNamedSelSetList &set = GetSelSet();
	ip->ClearSubObjectNamedSelSets();
	for (int i=0; i<set.Count(); i++) ip->AppendSubObjectNamedSelSet(*(set.names[i]));
}

void EditTriObject::UpdateNamedSelDropDown () {
	if (!ip) return;
	DWORD nsl = namedSetLevel[selLevel];
	GenericNamedSelSetList & ns = selSet[nsl];
	for (int i=0; i<ns.Count(); i++) {
		if (*(ns.sets[i]) == GetSel (nsl)) break;
	}
	if (i<ns.Count()) ip->SetCurNamedSelSet (*(ns.names[i]));
}

int EditTriObject::NumNamedSelSets() {
	GenericNamedSelSetList &set = GetSelSet();
	return set.Count();
}

TSTR EditTriObject::GetNamedSelSetName(int i) {
	GenericNamedSelSetList &set = GetSelSet();
	return *set.names[i];
}

void EditTriObject::SetNamedSelSetName(int i,TSTR &newName) {
	GenericNamedSelSetList &set = GetSelSet();
	if (theHold.Holding()) theHold.Put(new SetNameRestore(i,&set,this));
	*set.names[i] = newName;
}

void EditTriObject::NewSetByOperator (TSTR &newName,Tab<int> &sets,int op) {
	GenericNamedSelSetList &set = GetSelSet();
	BitArray bits = *set.sets[sets[0]];

	for (int i=1; i<sets.Count(); i++) {
		switch (op) {
		case NEWSET_MERGE:
			bits |= *set.sets[sets[i]];
			break;

		case NEWSET_INTERSECTION:
			bits &= *set.sets[sets[i]];
			break;

		case NEWSET_SUBTRACT:
			bits &= ~(*set.sets[sets[i]]);
			break;
		}
	}
	
	set.AppendSet(bits,0,newName);
	if (theHold.Holding()) theHold.Put(new AppendSetRestore(&set,this));
	if (!bits.NumberSet()) RemoveSubSelSet(newName);
}

void EditTriObject::NSCopy() {
	if (selLevel == SL_OBJECT) return;
	int index = SelectNamedSet();
	if (index<0) return;
	if (!ip) return;
	int nsl = namedSetLevel[selLevel];
	GenericNamedSelSetList & setList = selSet[nsl];
	MeshNamedSelClip *clip = new MeshNamedSelClip(*(setList.names[index]));
	BitArray *bits = new BitArray(*setList.sets[index]);
	clip->sets.Append(1,&bits);
	SetMeshNamedSelClip (clip, namedClipLevel[selLevel]);

	// Enable the paste button
	if (hSel) {
		ICustButton *but;
		but = GetICustButton(GetDlgItem(hSel, IDC_PASTE_NS));
		but->Enable();
		ReleaseICustButton(but);
	}
}

void EditTriObject::NSPaste() {
	if (selLevel==SL_OBJECT) return;
	int nsl = namedSetLevel[selLevel];
	MeshNamedSelClip *clip = GetMeshNamedSelClip(namedClipLevel[selLevel]);
	if (!clip) return;
	TSTR name = clip->name;
	if (!GetUniqueSetName(name)) return;

	theHold.Begin ();
	GenericNamedSelSetList & setList = selSet[nsl];
	setList.AppendSet (*clip->sets[0], 0, name);
	if (theHold.Holding()) theHold.Put(new AppendSetRestore(&setList,this));
	ActivateSubSelSet(name);
	theHold.Accept (GetString (IDS_PASTE_NS));
	ip->SetCurNamedSelSet(name);
	SetupNamedSelDropDown();
}

static BOOL CALLBACK PickSetNameDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name;
	ICustEdit *edit;
	TCHAR buf[256];

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
		edit->SetText(*name);
		ReleaseICustEdit(edit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->GetText(buf,256);
			*name = TSTR(buf);
			ReleaseICustEdit(edit);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

BOOL EditTriObject::GetUniqueSetName(TSTR &name) {
	while (1) {
		GenericNamedSelSetList & setList = selSet[namedSetLevel[selLevel]];

		BOOL unique = TRUE;
		for (int i=0; i<setList.Count(); i++) {
			if (name==*setList.names[i]) {
				unique = FALSE;
				break;
			}
		}
		if (unique) break;

		if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			ip->GetMAXHWnd(), PickSetNameDlgProc, (LPARAM)&name)) return FALSE;
		if (!ip) return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK PickSetDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
	case WM_INITDIALOG:	{
		GenericNamedSelSetList *setList = (GenericNamedSelSetList *)lParam;
		for (int i=0; i<setList->Count(); i++) {
			int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
				(LPARAM)(TCHAR*)*(setList->names[i]));
			SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
		}
		break;
	}

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_NS_LIST:
			if (HIWORD(wParam)!=LBN_DBLCLK) break;
			// fall through

		case IDOK:
			int sel;
			sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
			if (sel!=LB_ERR) {
				int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
				EndDialog(hWnd,res);
				break;
			}
			// fall through

		case IDCANCEL:
			EndDialog(hWnd,-1);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

int EditTriObject::SelectNamedSet() {
	GenericNamedSelSetList & setList = selSet[namedSetLevel[selLevel]];
	return DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		ip->GetMAXHWnd(), PickSetDlgProc, (LPARAM)&setList);
}

class NamedSetSizeIncrease : public RestoreObj {
public:
	// STEVE: should this be a reference?
	EditTriObject *et;
	int nsl;
	int oldsize, increase;
	NamedSetSizeIncrease () { et=NULL; }
	NamedSetSizeIncrease (EditTriObject *eto, int n, int old, int inc) { et=eto; nsl=n; oldsize=old; increase=inc; }
	void Restore (int isUndo) { et->selSet[nsl].SetSize (oldsize); }
	void Redo () { et->selSet[nsl].SetSize (oldsize+increase); }
	int GetSize () { return 3*sizeof(int) + sizeof (void *); }
	TSTR Description () { return _T("Named Selection Set Size Increase"); }
};

void EditTriObject::IncreaseNamedSetSize (int nsl, int oldsize, int increase) {
	if (increase == 0) return;
	if (selSet[nsl].Count() == 0) return;
	if (theHold.Holding())
		theHold.Put (new NamedSetSizeIncrease (this, nsl, oldsize, increase));
	selSet[nsl].SetSize (oldsize + increase);
}

class NamedSetDelete : public RestoreObj {
public:
	// STEVE: should this be a reference?
	EditTriObject *et;
	int nsl;
	Tab<BitArray *> oldSets;
	BitArray del;

	NamedSetDelete (EditTriObject *eto, int n, BitArray &d);
	~NamedSetDelete ();
	void Restore (int isUndo);
	void Redo () { et->selSet[nsl].DeleteSetElements (del, (nsl==NS_EDGE) ? 3 : 1); }
	int GetSize () { return 3*sizeof(int) + sizeof (void *); }
	TSTR Description () { return _T("Named Selection Set Subset Deletion"); }
};

NamedSetDelete::NamedSetDelete (EditTriObject *eto, int n, BitArray &d) {
	et = eto;
	nsl = n;
	del = d;
	oldSets.SetCount (et->selSet[nsl].Count());
	for (int i=0; i<et->selSet[nsl].Count(); i++) {
		oldSets[i] = new BitArray;
		(*oldSets[i]) = (*(et->selSet[nsl].sets[i]));
	}
}

NamedSetDelete::~NamedSetDelete () {
	for (int i=0; i<oldSets.Count(); i++) delete oldSets[i];
}

void NamedSetDelete::Restore (int isUndo) {
	int i, max = oldSets.Count();
	if (et->selSet[nsl].Count() < max) max = et->selSet[nsl].Count();
	for (i=0; i<max; i++) *(et->selSet[nsl].sets[i]) = *(oldSets[i]);
}

void EditTriObject::DeleteNamedSetArray (int nsl, BitArray &del) {
	if (del.NumberSet() == 0) return;
	if (selSet[nsl].Count() == 0) return;
	selSet[nsl].Alphabetize ();
	if (theHold.Holding()) 
		theHold.Put (new NamedSetDelete (this, nsl, del));
	selSet[nsl].DeleteSetElements (del, (nsl==NS_EDGE) ? 3 : 1);
}

void EditTriObject::CreateContArray() {
	if (cont.Count()) return;
	AllocContArray (mesh.getNumVerts());
	for (int i=0; i<cont.Count(); i++) SetPtCont(i, NULL);
}

void EditTriObject::SynchContArray(int nv) {
	int i, cct = cont.Count();
	if (!cct) return;
	if (cct == nv) return;
	if (masterCont) masterCont->SetNumSubControllers(nv, TRUE);
	if (cct>nv) {
		cont.Delete (nv, cct-nv);
		return;
	}
	cont.Resize (nv);
	Control *dummy=NULL;
	for (i=cct; i<nv; i++) cont.Append (1, &dummy);
}

void EditTriObject::AllocContArray(int count) {
	cont.SetCount (count);
	if (masterCont) masterCont->SetNumSubControllers (count);
}

void EditTriObject::ReplaceContArray(Tab<Control *> &nc) {
	AllocContArray (nc.Count());
	for(int i=0; i<nc.Count(); i++) SetPtCont (i, nc[i]);
}

// Current ref version is 1.
// Old version (0) had no MasterPointController, just the array of point controllers themselves.
int EditTriObject::RemapRefOnLoad(int iref) {
	if (loadRefVersion == 0) return iref+1;
	return iref;
}

RefTargetHandle EditTriObject::GetReference(int i) {	
	if (i <= ET_MASTER_CONTROL_REF) return masterCont;
	if (i >= (cont.Count() + ET_VERT_BASE_REF)) return NULL;
	return cont[i - ET_VERT_BASE_REF];
}

void EditTriObject::SetReference(int i, RefTargetHandle rtarg) {
	if(i == ET_MASTER_CONTROL_REF) {
		masterCont = (MasterPointControl*)rtarg;
		if (masterCont) masterCont->SetNumSubControllers(cont.Count());
	} else {
		if(i < (mesh.getNumVerts() + ET_VERT_BASE_REF)) {
			if (!cont.Count()) CreateContArray();
			SetPtCont(i - ET_VERT_BASE_REF, (Control*)rtarg); 
		}
	}
}

TSTR EditTriObject::SubAnimName(int i) {
	if (i == ET_MASTER_CONTROL_REF) return GetString(IDS_MASTERCONT);
	TSTR buf;
	if(i < (cont.Count() + ET_VERT_BASE_REF))
		buf.printf(GetString(IDS_RB_POINTNUM), i+1-ET_VERT_BASE_REF);
	return buf;
}

void EditTriObject::DeletePointConts(BitArray &set) {
	if (!cont.Count()) return;

	BOOL deleted = FALSE;
	Tab<Control*> nc;
	nc.SetCount(cont.Count());
	int ix=0;
	for (int i=0; i<cont.Count(); i++) {
		if (!set[i]) nc[ix++] = cont[i];
		else deleted = TRUE;
	}
	nc.SetCount(ix);
	nc.Shrink();
	ReplaceContArray(nc);
}

void EditTriObject::PlugControllersSel(TimeValue t,BitArray &set) {
	BOOL res = FALSE;
	if (!Animating() || t==0) return;
	for (int i=0; i<GetMesh().getNumVerts(); i++) if (set[i] && PlugControl(t,i)) res = TRUE;
	if (res) NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
}

BOOL EditTriObject::PlugControl(TimeValue t,int i) {
	if (!Animating() || t==0) return FALSE;
	if (!cont.Count()) CreateContArray();
	if (cont[i]) return FALSE;

	MakeRefByID (FOREVER, i + ET_VERT_BASE_REF, NewDefaultPoint3Controller());
	SuspendAnimate();
	AnimateOff();
	theHold.Suspend ();
	cont[i]->SetValue (t, &GetMesh().verts[i]);
	theHold.Resume ();
	ResumeAnimate ();
	masterCont->SetSubController (i, cont[i]); 
	return TRUE;
}

void EditTriObject::SetPtCont (int i, Control *c) {
	cont[i]=c;
	if (masterCont/* && c*/) masterCont->SetSubController(i, c);
}

void EditTriObject::SetPointAnim (TimeValue t, int i, Point3 pt) {
	if (cont.Count() && cont[i]) cont[i]->SetValue(t,&pt);
	else GetMesh().verts[i] = pt;
}

void EditTriObject::InvalidateDistances () {
	InvalidateAffectRegion ();
	if (!tempData) return;
	tempData->InvalidateDistances ();
}

void EditTriObject::InvalidateAffectRegion () {
	arValid = NEVER;
	if (!tempData) return;
	tempData->InvalidateAffectRegion ();
}

ObjectState EditTriObject::Eval(TimeValue time) {	
	if (!geomValid.InInterval(time)) {
		arValid = NEVER;
		geomValid = FOREVER;
		for (int i=0; i<cont.Count(); i++) {
			if (cont[i]) cont[i]->GetValue(time,&GetMesh().verts[i],geomValid);
		}
		InvalidateTempData (PART_GEOM);
	}
	
	if (!arValid.InInterval (time)) {
		arValid = geomValid;
		if (affectRegion) {
			GetMesh().SupportVSelectionWeights ();
			float *vsw = GetMesh().getVSelectionWeights();
			float * myVSW = TempData()->VSWeight (useEdgeDist, edgeIts, arIgBack,
				falloff, pinch, bubble)->Addr(0);
			memcpy (vsw, myVSW, GetMesh().getNumVerts()*sizeof(float));
		} else {
			GetMesh().freeVSelectionWeights ();
		}
	}

	// RB 7/11/97: There's no reason for any of the other intervals
	// to be anything but FOREVER. There are some cases where they
	// can end up as an instant point in time
	topoValid   = FOREVER;
	texmapValid = FOREVER;
	selectValid = FOREVER;
	vcolorValid = FOREVER;

	return ObjectState(this);
}

RefResult EditTriObject::NotifyRefChanged (Interval changeInt, RefTargetHandle hTarget,
										   PartID& partID, RefMessage message) {
	switch (message) {
	case REFMSG_CHANGE:
		geomValid.SetEmpty();
		break;
	}
	return REF_SUCCEED;
}

BOOL EditTriObject::CloneVertCont(int from, int to) {	
	if (cont.Count() && cont[from]) {
		RemapDir *remap = NewRemapDir();
		ReplaceReference(to,remap->CloneRef(cont[from]));
		remap->DeleteThis();
		return TRUE;
	}
	return FALSE;
}

BOOL EditTriObject::AssignController (Animatable *control, int subAnim) {
	ReplaceReference (subAnim, (Control*)control);
	if (subAnim==ET_MASTER_CONTROL_REF) {
		int n = cont.Count();
		masterCont->SetNumSubControllers(n);
		for (int i=0; i<n; i++) if (cont[i]) masterCont->SetSubController(i,cont[i]);
	}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	return TRUE;
}

#ifdef _SUBMTLASSIGNMENT
// CCJ 1/19/98
// Return the sub object material assignment interface
// This is used by the node when assigning materials.
// If an open face selection mode is active, the material
// will be assigned to the selected faces only.
// A multi/sub-object material is created and the material
// is assigned to the matierial ID created for the selected
// faces.
void* EditTriObject::GetInterface(ULONG id) {
	switch (id)
	{
		case I_SUBMTLAPI: return (ISubMtlAPI*)this;
		case I_MESHSELECT: return (IMeshSelect*)this;
		case I_MESHSELECTDATA: return (IMeshSelectData*)this;
		case I_MESHDELTAUSER: return (MeshDeltaUser*)this;
		case I_MESHDELTAUSERDATA: return (MeshDeltaUserData*)this;
	}
	//JH 3/8/99
	//This previously called Object"s implementation
	//Now that kenny has an implementation in triObject, we can't skip it
	return TriObject::GetInterface(id);
}

// Return a material ID that is currently not used by the object.
// If the current face selection share once single MtlDI that is not
// used by any other faces, you should use it.
MtlID EditTriObject::GetNextAvailMtlID(ModContext* mc) {
	int mtlID = GetSelFaceUniqueMtlID(mc);

	if (mtlID == -1) {
		int i;
		BitArray b;
		mtlID = GetMesh().numFaces;
		b.SetSize(GetMesh().numFaces, FALSE);
		b.ClearAll();
		for (i=0; i<GetMesh().numFaces; i++) {
			int mid = GetMesh().faces[i].getMatID();
			if (mid < GetMesh().numFaces) {
				b.Set(mid);
				}
			}

		for (i=0; i<GetMesh().numFaces; i++) {
			if (!b[i]) {
				mtlID = i;
				break;
				}
			}
		}

	return (MtlID)mtlID;
	}

// Indicate if you are active in the modifier panel and have an 
// active face selection
BOOL EditTriObject::HasFaceSelection(ModContext* mc) {
	// Are we the edited object?
	if (ip == NULL)  return FALSE;
	// Is Face selection active?
	if (selLevel < SL_FACE) return FALSE;
	return (GetMesh().faceSel.NumberSet() > 0);
}

// Set the selected faces to the specified material ID.
// If bResetUnsel is TRUE, then you should set the remaining
// faces material ID's to 0
void EditTriObject::SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel) {
	if (theHold.Holding() && !TestAFlag(A_HELD)) theHold.Put(new MeshFaceMatRestore(this));

	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		if (GetMesh().faceSel[i]) GetMesh().setFaceMtlIndex(i, id);
		else if (bResetUnsel) GetMesh().setFaceMtlIndex(i, 0);
	}

	InvalidateSurfaceUI();
	GetMesh().InvalidateGeomCache();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
}

// Return the material ID of the selected face(s).
// If multiple faces are selected they should all have the same MtlID -
// otherwise you should return -1.
// If faces other than the selected share the same material ID, then 
// you should return -1.
int EditTriObject::GetSelFaceUniqueMtlID(ModContext* mc) {
	int	i;
	int	mtlID;

	mtlID = GetSelFaceAnyMtlID(mc);

	if (mtlID == -1) return mtlID;
	for (i=0; i<GetMesh().numFaces; i++) {
		if (GetMesh().faceSel[i]) continue;
		if (GetMesh().faces[i].getMatID() != mtlID) continue;
		mtlID = -1;
		break;
	}

	return mtlID;
}

// Return the material ID of the selected face(s).
// If multiple faces are selected they should all have the same MtlID,
// otherwise you should return -1.
int EditTriObject::GetSelFaceAnyMtlID(ModContext* mc) {
	int				mtlID = -1;
	BOOL			bGotFirst = FALSE;
	int				i;

	for (i=0; i<GetMesh().numFaces; i++) {
		if (!GetMesh().faceSel[i]) continue;
		if (bGotFirst) {
			if (mtlID != GetMesh().faces[i].getMatID()) {
				mtlID = -1;
				break;
			}
		} else {
			mtlID = GetMesh().faces[i].getMatID();
			bGotFirst = TRUE;
		}
	}

	return mtlID;
}

// Return the highest MtlID used by the object.
int EditTriObject::GetMaxMtlID(ModContext* mc) {
	MtlID mtlID = 0;
	for (int i=0; i<GetMesh().numFaces; i++) mtlID = max(mtlID, GetMesh().faces[i].getMatID());
	return mtlID;
}

#endif // _SUBMTLASSIGNMENT

void EditTriObject::LocalDataChanged () {
	InvalidateNumberSelected ();
	InvalidateSurfaceUI ();
	InvalidateTempData (PART_SELECT);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip) {
		ip->RedrawViews(ip->GetTime());
		UpdateNamedSelDropDown();
	}
}

void EditTriObject::SetSelLevel (DWORD lev) {
	switch (lev) {
	case IMESHSEL_OBJECT:
		selLevel = SL_OBJECT;
		break;
	case IMESHSEL_VERTEX:
		selLevel = SL_VERTEX;
		break;
	case IMESHSEL_EDGE:
		selLevel = SL_EDGE;
		break;
	default:
		if (selLevel < SL_FACE) selLevel = SL_POLY;
		break;
	}
	if (ip) ip->SetSubObjectLevel (selLevel);
	else InvalidateTempData (PART_SUBSEL_TYPE);
}

DWORD EditTriObject::GetSelLevel () {
	switch (selLevel) {
	case SL_OBJECT: return IMESHSEL_OBJECT;
	case SL_VERTEX: return IMESHSEL_VERTEX;
	case SL_EDGE: return IMESHSEL_EDGE;
	}
	return IMESHSEL_FACE;
}

BitArray EditTriObject::GetSel (int nsl) {
	switch (nsl) {
	case NS_VERTEX: return GetMesh().vertSel;
	case NS_EDGE: return GetMesh().edgeSel;
	}
	return GetMesh().faceSel;
}

void EditTriObject::SetVertSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	if (ip) ip->ClearCurNamedSelSet();
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (this, SL_VERTEX));
	GetMesh().vertSel = set;
	if (GetMesh().vertSel.GetSize() != GetMesh().numVerts) GetMesh().vertSel.SetSize (GetMesh().numVerts, TRUE);
	GetMesh().vertSel &= ~GetMesh().vertHide;
}

void EditTriObject::SetFaceSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	if (ip) ip->ClearCurNamedSelSet();
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (this, SL_FACE));
	GetMesh().faceSel = set;
	if (GetMesh().faceSel.GetSize() != GetMesh().numFaces) GetMesh().faceSel.SetSize (GetMesh().numFaces, TRUE);
	DeselectHiddenFaces (GetMesh());
}

void EditTriObject::SetEdgeSel(BitArray &set, IMeshSelect *imod, TimeValue t) {
	if (ip) ip->ClearCurNamedSelSet();
	if (theHold.Holding()) theHold.Put (new MeshSelRestore (this, SL_EDGE));
	GetMesh().edgeSel = set;
	if (GetMesh().edgeSel.GetSize() != GetMesh().numFaces*3) GetMesh().edgeSel.SetSize (GetMesh().numFaces*3, TRUE);
	DeselectHiddenEdges (GetMesh());
}

void EditTriObject::SetSel (int nsl, BitArray & set, IMeshSelect *imod, TimeValue t) {
	switch (nsl) {
	case NS_VERTEX: SetVertSel (set, imod, t); return;
	case NS_EDGE: SetEdgeSel (set, imod, t); return;
	}
	SetFaceSel (set, imod, t);
}

void EditTriObject::LocalDataChanged (DWORD parts) {
	BOOL sel = (parts & PART_SELECT) ? TRUE : FALSE;
	BOOL topo = (parts & PART_TOPO) ? TRUE : FALSE;
	InvalidateTempData (parts);
	if (sel) InvalidateNumberSelected ();
	if (topo|sel) InvalidateSurfaceUI ();
	if (topo) SynchContArray(GetMesh().numVerts);
	NotifyDependents(FOREVER, parts, REFMSG_CHANGE);
}

void EditTriObject::ApplyMeshDelta (MeshDelta & md, MeshDeltaUser *mdu, TimeValue t) {
	if (Animating() && t) {
		BOOL addedCont = FALSE;
		for (int i=0; i<md.vMove.Count(); i++) if (PlugControl(t, md.vMove[i].vid)) addedCont = TRUE;
		if (addedCont) NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}
	DWORD partsChanged = md.PartsChanged ();
	if (theHold.Holding() && !TestAFlag (A_HELD)) {
		if (partsChanged & (PART_TOPO|PART_TEXMAP|PART_VERTCOLOR)) theHold.Put (new MeshTopoRestore (this, partsChanged));
		else {
			if (partsChanged & PART_GEOM) theHold.Put (new MeshVertRestore (this));
			if (partsChanged & PART_SELECT) theHold.Put (new MeshSelRestore (this));
		}
	}
	for (int i=0; i<md.vMove.Count(); i++) {
		DWORD j = md.vMove[i].vid;
		Point3 pt = GetMesh().verts[j] + md.vMove[i].dv;
		if (cont.Count() && cont[j]) cont[j]->SetValue (t, &pt);
	}
	int nv;
	if (nv = md.vCreate.Count() + md.vClone.Count()) {
		SynchContArray (GetMesh().numVerts+nv);
		IncreaseNamedSetSize (NS_VERTEX, GetMesh().numVerts, nv);
	}
	if (md.fCreate.Count()) {
		IncreaseNamedSetSize (NS_EDGE, GetMesh().numFaces*3, md.fCreate.Count()*3);
		IncreaseNamedSetSize (NS_FACE, GetMesh().numFaces, md.fCreate.Count());
	}
	md.Apply (GetMesh());
	if (md.vDelete.NumberSet()) {
		DeletePointConts (md.vDelete);
		NotifyDependents (FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		DeleteNamedSetArray (NS_VERTEX, md.vDelete);
	}
	if (md.fDelete.NumberSet()) {
		DeleteNamedSetArray (NS_EDGE, md.fDelete);
		DeleteNamedSetArray (NS_FACE, md.fDelete);
	}
	mdu->LocalDataChanged (partsChanged);
}

MeshTempData *EditTriObject::TempData () {
	if (!tempData) tempData = new MeshTempData(&(GetMesh()));
	return tempData;
}

void EditTriObject::InvalidateTempData (PartID parts) {
	if (!tempMove) {
		if (tempData) tempData->Invalidate (parts);
		if (parts & (PART_TOPO|PART_GEOM|PART_SELECT|PART_SUBSEL_TYPE))
			InvalidateAffectRegion ();
	}
	if (parts & PART_TOPO) GetMesh().InvalidateTopologyCache();
	if (parts & PART_GEOM) GetMesh().InvalidateGeomCache ();
}

static int dragRestored;

void EditTriObject::DragMoveInit () {
	if (tempMove) delete tempMove;
	tempMove = new TempMoveRestore (this);
	dragRestored = TRUE;
}

void EditTriObject::DragMoveRestore () {
	if (!tempMove) return;
	if (dragRestored) return;
	tempMove->Restore (this);
	dragRestored = TRUE;
	LocalDataChanged (PART_GEOM);
}

void EditTriObject::DragMove (MeshDelta & md, MeshDeltaUser *mdu) {
	if (!tempMove) {
		ApplyMeshDelta (md, mdu, ip ? ip->GetTime() : TimeValue(0));
		return;
	}
	// only care about vMove.
	for (int i=0; i<md.vMove.Count(); i++) {
		DWORD j = md.vMove[i].vid;
		tempMove->active.Set (j);
		GetMesh().verts[j] += md.vMove[i].dv;
	}
	if (theHold.Holding ()) theHold.Put (new CueLocalRestore(this));
	dragRestored = FALSE;
	mdu->LocalDataChanged (PART_GEOM);
}

void EditTriObject::DragMoveAccept (TimeValue t) {
	if (!tempMove) return;
	if (!tempMove->active.NumberSet()) {
		delete tempMove;
		tempMove = NULL;
		return;
	}
	if (Animating() && t) {
		BOOL addedCont = FALSE;
		for (int i=0; i<tempMove->active.GetSize(); i++) {
			if (!tempMove->active[i]) continue;
			if (!PlugControl(t,i)) continue;
			addedCont = TRUE;
			cont[i]->SetValue (0, tempMove->init[i]);
		}
		if (addedCont) NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}
	if (cont.Count()) {
		for (int i=0; i<tempMove->active.GetSize(); i++) {
			if (!tempMove->active[i]) continue;
			if (cont[i]) cont[i]->SetValue (t, GetMesh().verts + i);
		}
	}
	if (theHold.Holding()) {
		MeshVertRestore *mvr = new MeshVertRestore(this);
		memcpy (mvr->undo.Addr(0), tempMove->init.Addr(0), GetMesh().numVerts*sizeof(Point3));
		theHold.Put (mvr);
	}
	delete tempMove;
	tempMove = NULL;
	dragRestored = TRUE;
	if (tempData) {
		tempData->Invalidate (PART_GEOM);
		InvalidateAffectRegion ();
		if (affectRegion) NotifyDependents (FOREVER, PART_SELECT, REFMSG_CHANGE);
	}
}

void EditTriObject::DragMoveClear () {
	if (tempMove) delete tempMove;
	tempMove=NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pack1.rc
//
#define IDD_SEL_NAMEDSET                106
#define IDD_PASTE_NAMEDSET              107
#define IDD_CREATECURVE                 108
#define IDD_DETACH                      109
#define IDD_ATTACH_MATS                 110
#define IDC_EXTRUDECUR                  112
#define IDC_ADDVERTCUR                  119
#define IDC_BEVELCUR                    120
#define IDC_VCHAMFERCUR                 121
#define IDR_ACCELERATORS                122
#define IDC_ECHAMFERCUR                 122
#define IDB_SELTYPES                    123
#define IDB_SELMASK                     124
#define IDD_EM_SELECTBYMAT              137
#define IDD_EM_SELECTBYSMOOTH           143
#define IDD_EDTRI_SELECT                144
#define IDD_EDTRI_GEOM                  145
#define IDD_EDTRI_SURF_VERT             146
#define IDD_EDTRI_SURF_EDGE             147
#define IDD_EDTRI_SURF_FACE             148
#define IDD_CLONE                       149
#define IDD_EXPLODE                     150
#define IDD_DISP_APPROX_ADV             413
#define IDC_IGNORE_VISEDGE              1004
#define IDC_IGNORE_BACKFACES            1005
#define IDC_NS_LIST                     1007
#define IDC_SET_NAME                    1008
#define IDC_DETACH_ELEM                 1011
#define IDC_DETACH_NAMELABEL            1012
#define IDC_NUMSEL_LABEL                1013
#define IDC_DETACH_CLONE                1013
#define IDC_WHATEVER                    1014
#define IDC_VERT_COLOR                  1015
#define IDC_CURVE_NAME                  1016
#define IDC_CURVE_SMOOTH                1017
#define IDC_CURVE_LINEAR                1018
#define IDC_CURVE_IGNOREHIDDEN          1019
#define IDC_TESSELLATE                  1027
#define IDC_EXTRUDEAMOUNT               1033
#define IDC_EXTRUDESPINNER              1034
#define IDC_PLANARSPINNER               1035
#define IDC_VERT_SELG                   1035
#define IDC_OUTLINEAMOUNT               1035
#define IDC_TES_EDGE                    1036
#define IDC_TES_CENTER                  1037
#define IDC_TENSIONSPINNER              1038
#define IDC_TENSION                     1039
#define IDC_EXTRUDE                     1040
#define IDC_PLANAR                      1041
#define IDC_BEVEL                       1041
#define IDC_OUTLINESPINNER              1042
#define IDC_MAKEPLANAR                  1043
#define IDC_SELTYPE                     1045
#define IDC_ANGLETHRESHSPIN             1046
#define IDC_ALIGNCONST                  1051
#define IDC_ANGLETHRESH                 1052
#define IDC_REMOVE_ISO_VERTS            1053
#define IDC_CREATE_CURVE                1054
#define IDC_DETACH_NAME                 1055
#define IDC_SPLIT                       1056
#define IDC_REFINE                      1057
#define IDC_CUT                         1058
#define IDC_SLICEPLANE                  1059
#define IDC_SLICE                       1060
#define IDC_TES_TEXT                    1061
#define IDC_EXP_TEXT                    1062
#define IDC_PIXELS_TEXT                 1063
#define IDC_SMOOTH_GRP1                 1064
#define IDC_SMOOTH_GRP2                 1065
#define IDC_SMOOTH_GRP3                 1066
#define IDC_SMOOTH_GRP4                 1067
#define IDC_SMOOTH_GRP5                 1068
#define IDC_SMOOTH_GRP6                 1069
#define IDC_SMOOTH_GRP7                 1070
#define IDC_SMOOTH_GRP8                 1071
#define IDC_SMOOTH_GRP9                 1072
#define IDC_SMOOTH_GRP10                1073
#define IDC_SMOOTH_GRP11                1074
#define IDC_SMOOTH_GRP12                1075
#define IDC_SMOOTH_GRP13                1076
#define IDC_SMOOTH_GRP14                1077
#define IDC_SMOOTH_GRP15                1078
#define IDC_SMOOTH_GRP16                1079
#define IDC_SMOOTH_GRP17                1080
#define IDC_SMOOTH_GRP18                1081
#define IDC_SMOOTH_GRP19                1082
#define IDC_SMOOTH_GRP20                1083
#define IDC_SMOOTH_GRP21                1084
#define IDC_SMOOTH_GRP22                1085
#define IDC_DELETE                      1086
#define IDC_SMOOTH_GRP23                1086
#define IDC_FALLOFF                     1086
#define IDC_FALLOFFSPIN                 1087
#define IDC_SMOOTH_GRP24                1087
#define IDC_PINCHSPIN                   1088
#define IDC_T_THR_SPIN                  1088
#define IDC_SMOOTH_GRP25                1088
#define IDC_SMOOTH_GRP26                1089
#define IDC_PINCH                       1089
#define IDC_SMOOTH_GRP27                1090
#define IDC_BUBBLESPIN                  1090
#define IDC_SMOOTH_GRP28                1091
#define IDC_BUBBLE                      1091
#define IDC_SMOOTH_GRP29                1092
#define IDC_NEARLABEL                   1092
#define IDC_TESS_U_SPINNER              1092
#define IDC_SMOOTH_GRP30                1093
#define IDC_FARLEFTLABEL                1093
#define IDC_SMOOTH_GRP31                1094
#define IDC_FARRIGHTLABEL               1094
#define IDC_SMOOTH_GRP32                1095
#define IDC_AR_GRAPH                    1095
#define IDC_VERT_SELRSPIN               1096
#define IDC_E_ITER_SPIN                 1096
#define IDC_VERT_SELGSPIN               1097
#define IDC_TESS_U                      1097
#define IDC_VERT_SELBSPIN               1098
#define IDC_TESS_DIST_SPINNER           1112
#define IDC_EXTYPE_A                    1115
#define IDC_EXTYPE_B                    1116
#define IDC_CLONE_NAME                  1116
#define IDC_TESS_DIST                   1116
#define IDC_EXPLODE_NAME                1118
#define IDC_EXPLODE_NAMELABEL           1120
#define IDC_TESS_ANG_SPINNER            1120
#define IDC_CLONE_OBJ                   1121
#define IDC_CLONE_ELEM                  1122
#define IDC_DO_SUBDIV                   1123
#define IDC_TESS_ANG                    1125
#define IDC_SPLITMESH                   1126
#define IDC_WEIGHT_LABEL                1128
#define IDC_TESS_EDGE_SPINNER           1130
#define IDC_TESS_MIN_REC_SPINNER        1131
#define IDC_TESS_MAX_REC_SPINNER        1132
#define IDC_TESS_MAX_TRIS_SPINNER       1133
#define IDC_TESS_EDGE                   1134
#define IDC_TESS_MIN_REC                1135
#define IDC_TESS_MAX_REC                1136
#define IDC_TESS_MAX_TRIS               1137
#define IDD_DISP_APPROX                 1142
#define IDC_TESS_SPATIAL                1144
#define IDC_TESS_CURV                   1145
#define IDD_EDTRI_AFFECTREGION          1145
#define IDC_TESS_VIEW_DEP               1146
#define IDC_TESS_LDA                    1147
#define IDC_SMOOTH_AUTO                 1196
#define IDC_NORMAL_FLIP                 1197
#define IDC_NORMAL_UNIFY                1198
#define IDC_NORMAL_SHOW                 1199
#define IDC_SELECT_BYID                 1200
#define IDC_CLEARSELECTION              1200
#define IDC_SELECTBYSMOOTH              1201
#define IDC_SMOOTH_CLEAR                1202
#define IDC_NORMAL_FLIPMODE             1204
#define IDC_SEL_BYVERT                  1256
#define IDC_VERT_SELBYCOLOR             1257
#define IDC_GRID                        1288
#define IDC_TREE                        1289
#define IDC_VERT_SELCOLOR               1316
#define IDC_EXPLODE                     1328
#define IDC_ADVANCED                    1328
#define IDC_CREATE                      1329
#define IDC_DETACH                      1330
#define IDC_WELDTOVERT                  1332
#define IDC_VERT_SELR                   1334
#define IDC_SMOOTH_THRESHSPIN           1335
#define IDC_SMOOTH_THRESH               1336
#define IDC_NORMAL_SCALESPIN            1337
#define IDC_NORMAL_SCALE                1338
#define IDC_MAT_IDSPIN                  1339
#define IDC_MAT_ID                      1340
#define IDC_AFFECT_REGION               1341
#define IDC_TESS_REGULAR                1342
#define IDC_E_DIST                      1345
#define IDC_COLLAPSE                    1347
#define IDC_E_ITER                      1348
#define IDC_HIDE                        1349
#define IDC_UNHIDEALL                   1350
#define IDC_COPY_NS                     1351
#define IDC_PASTE_NS                    1352
#define IDC_SELECT_OPEN                 1355
#define IDC_EXP_OBJECTS                 1377
#define IDC_EXP_ELEMENTS                1378
#define IDC_OBJ_ATTACH                  1379
#define IDC_FALLOFF_LABEL               1381
#define IDC_PINCH_LABEL                 1382
#define IDC_BUBBLE_LABEL                1383
#define IDC_DELAUNAY                    1416
#define IDC_PRESET3                     1425
#define IDC_PRESET2                     1427
#define IDC_PRESET1                     1429
#define IDC_W_THR                       1431
#define IDC_T_THR                       1435
#define IDC_VERT_SELB                   1436
#define IDC_DIVIDE                      1449
#define IDC_ALIGNVIEW                   1450
#define IDC_EDGE_TURN                   1481
#define IDC_EDGE_VIS                    1482
#define IDC_EDGE_INVIS                  1483
#define IDC_EDGE_AUTO                   1484
#define IDC_WELD                        1584
#define IDC_W_THR_SPIN                  1685
#define IDC_AE_SET                      1739
#define IDC_AR_BACK                     1740
#define IDC_AE_CLEAR                    1741
#define IDC_AE_SETCLEAR                 1742
#define IDC_EM_WEIGHT                   1749
#define IDC_EM_WEIGHTSPIN               1750
#define IDS_OBJECT                      30004
#define IDS_VERTEX                      30011
#define IDS_FACE                        30012
#define IDS_EDGE                        30013
#define IDS_RB_EDITOBJECT               30017
#define IDS_RB_DELETEVERT               30211
#define IDS_RB_DELETEFACE               30212
#define IDS_RB_ADDVERTS                 30213
#define IDS_RB_ATTACHOBJECT             30214
#define IDS_RB_FACECOLLAPSE             30215
#define IDS_RB_MAKEPLANAR               30216
#define IDS_RB_BUILDFACE                30217
#define IDS_RB_HIDEFACE                 30218
#define IDS_RB_UNHIDEALLFACES           30219
#define IDS_RB_EDGEVISIBLE              30220
#define IDS_RB_EDGEINVISIBLE            30221
#define IDS_RB_AUTOEDGE                 30222
#define IDS_RB_EDGEDIVIDE               30223
#define IDS_RB_EDGETURN                 30224
#define IDS_RB_DELETEEDGE               30225
#define IDS_RB_COLLAPSEEDGE             30226
#define IDS_RB_CLONE                    30227
#define IDS_RB_TESSELLATE               30228
#define IDS_RB_DELETEISOLATED           30229
#define IDS_RB_SETSMOOTHGROUP           30280
#define IDS_RB_ASSIGNMATID              30281
#define IDS_RB_FLIPNORMALS              30282
#define IDS_RB_UNIFYNORMALS             30283
#define IDS_RB_AUTOSMOOTH               30284
#define IDS_RB_SELECTBYMATID            30285
#define IDS_RB_SELECTBYSMOOTH           30286
#define IDS_RB_HIDEVERT                 30294
#define IDS_RB_COLLAPSE                 30630
#define IDS_RB_WELDVERTS                30631
#define IDS_RB_NOVERTSTOWELD            30680
#define IDS_RB_DUPFACEWARNING           30687
#define IDS_RB_EXPLODE                  30688
#define IDS_RB_EXTRUDE                  30689
#define IDS_DS_MOVE                     30690
#define IDS_RB_DOCREATENEWOBJECT        30691
#define IDS_RB_MULTIATTACH              30692
#define IDS_RB_ATTACH                   30693
#define IDS_RB_BREAKVERTS               30694
#define IDS_RB_DELETEISO                30695
#define IDS_RB_ALIGNTOCONST             30696
#define IDS_RB_ALIGNTOVIEW              30697
#define IDS_RB_POINTNUM                 30698
#define IDS_RB_NUMVERTSELP              30699
#define IDS_RB_NUMVERTSEL               30700
#define IDS_RB_NUMFACESELP              30701
#define IDS_RB_NUMFACESEL               30702
#define IDS_RB_NUMEDGESELP              30703
#define IDS_RB_NUMEDGESEL               30704
#define IDS_RB_VERTEXCOLOR              30705
#define IDS_RB_SETVERTCOLOR             30706
#define IDS_RB_CREATECURVE              30707
#define IDS_RB_NOEDGESSELECTED          30708
#define IDS_RB_SHAPE                    30709
#define IDS_RB_SELBYCOLOR               30710
#define IDS_RB_SELOPENEDGES             30711
#define IDS_POLYGON                     30713
#define IDS_ELEMENT                     30714
#define IDS_RB_DETACHVERT               30715
#define IDS_RB_DETACHFACES              30716
#define IDS_RB_CONDENSEWARNING          30717
#define IDS_LIB_DESCRIPTION             30718
#define IDS_SCA_EDGECUT                 30719
#define IDS_SCA_ROTATE                  30720
#define IDS_SCA_SCALE                   30721
#define IDS_SCA_SLICE                   30722
#define IDS_SCA_MOVE                    30723
#define IDS_SCA_SELECTION               30724
#define IDS_SCA_GEOMETRY                30725
#define IDS_SCA_SURFACE                 30726
#define IDS_SCA_BASE_MESH               30727
#define IDS_SCA_BASEMESH                30728
#define IDS_BASE_OBJECTS                30731
#define IDS_EDIT_GEOM                   30732
#define IDS_OBJECT_SEL                  30733
#define IDS_FACE_DIVIDE                 30734
#define IDS_INHERIT_MATERIAL            30735
#define IDS_COMBINE_MATERIALS           30736
#define IDS_SET_FACE_COLOR              30737
#define IDS_BEVEL                       30738
#define IDS_OUTLINE                     30739
#define IDS_ADV_DISP_APPROX_WARNING_TITLE 30740
#define IDS_ADV_DISP_APPROX_WARNING     30741
#define IDS_DISP_APPROX_CHANGE          30742
#define IDS_CHAMFER                     30743
#define IDS_DIVIDE                      30746
#define IDS_BREAK                       30747
#define IDS_AFFECT_REGION               30748
#define IDS_DETACH                      30749
#define IDS_ATTACH_LIST                 30750
#define IDS_MASTERCONT                  30751
#define IDS_CHANGEWEIGHT                30752
#define IDS_PASTE_NS                    30753
#define IDS_EM_HIDE_SELECTED            30754
#define IDS_EM_SHOW_NORMALS             30755
#define IDS_EM_SWITCH_SUBLEVELS         30756
#define IDS_EMESH                       30757
#define IDS_EM_PREV_SUBLEVEL            30758
#define IDS_EM_WELD_SEL                 30759
#define IDS_EM_SLICEPLANE               30760
#define IDS_EM_GOTO_VERTEX              30761
#define IDS_EM_GOTO_EDGE                30762
#define IDS_EM_GOTO_FACE                30763
#define IDS_EM_GOTO_POLYGON             30764
#define IDS_EM_GOTO_ELEMENT             30765
#define IDS_EM_GOTO_OBJECT              30766
#define IDS_EM_IGNORE_BACK              30767
#define IDS_EM_CREATE_MODE              30768
#define IDS_EM_ATTACH_MODE              30769
#define IDS_EM_DIVIDE_MODE              30770
#define IDS_EM_EXTRUDE_MODE             30771
#define IDS_EM_SS_BACKFACE              30772
#define IDS_EM_BEVEL_MODE               30773
#define IDS_EM_UNIFY                    30774
#define IDS_EM_IGNORE_VISEDGE           30775
#define IDS_EM_SELBYVERT                30776
#define IDS_EM_CUT_MODE                 30777
#define IDS_EM_SELECT                   30778
#define ID_EM_SELTYPE                   40001
#define ID_EM_SELTYPE_BACK              40002
#define ID_EM_SELTYPE_VERTEX            40003
#define ID_EM_SELTYPE_EDGE              40004
#define ID_EM_SELTYPE_FACE              40005
#define ID_EM_SELTYPE_POLYGON           40006
#define ID_EM_SELTYPE_ELEMENT           40007
#define ID_EM_SELTYPE_OBJ               40008
#define ID_EM_AUTOSMOOTH                40009
#define ID_EM_ATTACH                    40010
#define ID_EM_BREAK                     40011
#define ID_EM_IGBACK                    40012
#define ID_EM_BEVEL                     40013
#define ID_EM_CREATE                    40014
#define ID_EM_CUT                       40015
#define ID_EM_DIVIDE                    40016
#define ID_EM_EXTRUDE                   40017
#define ID_EM_FLIPNORM                  40018
#define ID_EM_SS_BACKFACE               40019
#define ID_EM_UNIFY_NORMALS             40020
#define ID_EM_HIDE                      40021
#define ID_EM_EDGE_INVIS                40022
#define ID_EM_IGNORE_INVIS              40023
#define ID_EM_COLLAPSE                  40024
#define ID_EM_SHOWNORMAL                40025
#define ID_EM_SELOPEN                   40026
#define ID_EM_REMOVE_ISO                40027
#define ID_EM_SLICEPLANE                40028
#define ID_EM_SOFTSEL                   40029
#define ID_EM_SLICE                     40030
#define ID_EM_DETACH                    40031
#define ID_EM_TURNEDGE                  40032
#define ID_EM_UNHIDE                    40033
#define ID_EM_EDGE_VIS                  40034
#define ID_EM_SELBYVERT                 40035
#define ID_EM_AUTOEDGE                  40036
#define ID_EM_WELD                      40038
#define ID_EM_EXPLODE                   40039
#define IDC_SEL_PT_TEXT                 65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40017
#define _APS_NEXT_CONTROL_VALUE         1129
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\triedui.cpp ===
/**********************************************************************
 *<
	FILE: triedui.cpp

	DESCRIPTION: Editable Triangle Mesh Object UI code

	CREATED BY: Rolf Berteig

	HISTORY: created 4 March 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "pack1.h"
#include "triobjed.h"

static BOOL CALLBACK SelectDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK AffectRegionDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SurfaceDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK GeomDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static float weldThresh     = 0.1f;
static float planarFaceThresh = 45.0f;
static float explodeThresh  = 24.0f;
static float autoEdgeThresh  = 24.0f;
static float autoSmoothThresh = 45.0f;
static int autoEdgeType = 0;	// Set & Clear
static float tessTens       = 25.0f;
static BOOL expObj          = TRUE;
static BOOL edgeTes         = TRUE;
static int sbmParams[2]     = {1,1};
static DWORD sbsParams[3]   = {1,1,0};
static float lastEdgeThresh = 30.0f;
static int selDeltaR		= 10;
static int selDeltaG		= 10;
static int selDeltaB		= 10;
static Point3 selByColor    = Point3(1,1,1);
static int cloneTo = IDC_CLONE_ELEM;

void ResetEditableMeshUI() {
	weldThresh     = 0.1f;
	planarFaceThresh = 45.0f;
	explodeThresh  = 24.0f;
	autoEdgeThresh = 24.0f;
	autoSmoothThresh = 45.0f;
	autoEdgeType = 0;
	tessTens       = 25.0f;
	expObj         = TRUE;
	edgeTes        = TRUE;
	sbmParams[0]   = 1;
	sbmParams[1]   = 1;
	sbsParams[0]   = 1;
	sbsParams[1]   = 1;
	sbsParams[2]   = 0;
	lastEdgeThresh = 30.0f;
	selDeltaR		= 10;
	selDeltaG		= 10;
	selDeltaB		= 10;
	selByColor    = Point3(1,1,1);
	cloneTo = IDC_CLONE_ELEM;
}

class MeshSelImageHandler {
public:
	HIMAGELIST images;
	MeshSelImageHandler () { images = NULL; }
	~MeshSelImageHandler () { if (images) ImageList_Destroy (images); }
	HIMAGELIST LoadImages ();
};

static MeshSelImageHandler theMeshSelImageHandler;

HIMAGELIST MeshSelImageHandler::LoadImages() {
	if (images ) return images;

	HBITMAP hBitmap, hMask;
	images = ImageList_Create(24, 23, ILC_COLOR|ILC_MASK, 10, 0);
	hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE (IDB_SELTYPES));
	hMask = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_SELMASK));
	ImageList_Add (images, hBitmap, hMask);
	DeleteObject (hBitmap);
	DeleteObject (hMask);
	return images;
}

static int SurfDlgs[] = { 0, IDD_EDTRI_SURF_VERT, IDD_EDTRI_SURF_EDGE,
	IDD_EDTRI_SURF_FACE, IDD_EDTRI_SURF_FACE, IDD_EDTRI_SURF_FACE };

void EditTriObject::UpdateSurfType () {
	if (editObj != this) return;
	if (!hGeom) return;
	if (!hApprox) {
		if (selLevel == SL_OBJECT) {
			HWND hKeyFocus = GetFocus ();
			hApprox = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_DISP_APPROX),
									DispApproxDlgProc, GetString(IDS_SCA_SURFACE),
									(LPARAM)this, rsApprox ? 0 : APPENDROLL_CLOSED);
			SetFocus (hKeyFocus);
		}
	} else {
		if (selLevel != SL_OBJECT) {
			rsApprox = IsRollupPanelOpen (hApprox);
			ip->DeleteRollupPage (hApprox);
			hApprox = NULL;
		}
	}
	if (!hSurf) {
		if (selLevel == SL_OBJECT) return;
		HWND hKeyFocus = GetFocus ();
		hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
			SurfaceDlgProc, GetString(IDS_SCA_SURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		SetFocus (hKeyFocus);
		return;
	}
	bool wasFace = GetDlgItem (hSurf, IDC_SMOOTH_GRP1) ? TRUE : FALSE;
	bool wasEdge = GetDlgItem (hSurf, IDC_EDGE_VIS) ? TRUE : FALSE;
	bool wasVert = GetDlgItem (hSurf, IDC_VERT_SELCOLOR) ? TRUE : FALSE;
	if (wasVert && (selLevel == SL_VERTEX)) return;
	if (wasEdge && (selLevel == SL_EDGE)) return;
	if (wasFace && (selLevel >= SL_FACE)) return;

	rsSurf = IsRollupPanelOpen (hSurf);
	ip->DeleteRollupPage (hSurf);
	if (selLevel == SL_OBJECT) hSurf = NULL;
	else {
		HWND hFocus = GetFocus ();
		hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
			SurfaceDlgProc, GetString(IDS_SCA_SURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		SetFocus (hFocus);
	}
}

static int butIDs[] = { 0, IDC_SELVERTEX, IDC_SELEDGE, IDC_SELFACE, IDC_SELPOLY, IDC_SELELEMENT };
void EditTriObject::RefreshSelType () {
	if (editObj != this) return;
	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hSel,IDC_SELTYPE));
	ICustButton *but;
	for (int i=1; i<6; i++) {
		but = iToolbar->GetICustButton (butIDs[i]);
		but->SetCheck (selLevel==i);
		ReleaseICustButton (but);
	}
	ReleaseICustToolbar(iToolbar);
	SetSelDlgEnables();
	SetARDlgEnables();
	SetGeomDlgEnables();
	UpdateSurfType ();
}

static updateNumSel = TRUE;
void EditTriObject::InvalidateNumberSelected () {
	if (editObj != this) return;
	if (!hSel) return;
	InvalidateRect (hSel, NULL, FALSE);
	updateNumSel = TRUE;
}

void EditTriObject::SetNumSelLabel() {	
	static TSTR buf;
	if (!hSel) return;
	if (editObj != this) return;
	if (!updateNumSel) {
		SetDlgItemText (hSel, IDC_NUMSEL_LABEL, buf);
		return;
	}
	updateNumSel = FALSE;

	int num, j;
	switch (selLevel) {
	case SL_OBJECT:
		buf.printf (GetString (IDS_OBJECT_SEL));
		break;

	case SL_VERTEX:
		num = GetMesh().vertSel.NumberSet();
		if (num==1) {
			for (j=0; j<GetMesh().vertSel.GetSize(); j++) if (GetMesh().vertSel[j]) break;
			buf.printf (GetString(IDS_RB_NUMVERTSEL), j+1);
		} else buf.printf (GetString(IDS_RB_NUMVERTSELP), num);
		break;

	case SL_FACE:
	case SL_POLY:
	case SL_ELEMENT:
		num = GetMesh().faceSel.NumberSet();
		if (num==1) {
			for (j=0; j<GetMesh().faceSel.GetSize(); j++) if (GetMesh().faceSel[j]) break;
			buf.printf (GetString(IDS_RB_NUMFACESEL), j+1);
		} else buf.printf(GetString(IDS_RB_NUMFACESELP),num);
		break;

	case SL_EDGE:
		num = GetMesh().edgeSel.NumberSet();
		if (num==1) {
			for (j=0; j<GetMesh().edgeSel.GetSize(); j++) if (GetMesh().edgeSel[j]) break;
			buf.printf (GetString(IDS_RB_NUMEDGESEL), j+1);
		} else buf.printf(GetString(IDS_RB_NUMEDGESELP),num);
		break;
	}

	SetDlgItemText(hSel, IDC_NUMSEL_LABEL, buf);
}

float EditTriObject::GetPolyFaceThresh() {
	return DegToRad (planarFaceThresh);
}

// --- Begin/End Edit Params ---------------------------------

const ShortcutTableId kEMeshShortcuts = EM_SHORTCUT_ID;
static BOOL oldShowEnd;
static EMeshShortcutCB *accel=NULL;

void EditTriObject::BeginEditParams (IObjParam  *ip, ULONG flags,Animatable *prev) {
	if (!enabled) return;
	this->ip = ip;
	editObj = this;
	hSel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDTRI_SELECT),
		SelectDlgProc, GetString(IDS_SCA_SELECTION), (LPARAM)this, rsSel ? 0 : APPENDROLL_CLOSED);
	hAR = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDTRI_AFFECTREGION),
		AffectRegionDlgProc, GetString(IDS_AFFECT_REGION), (LPARAM)this, rsAR ? 0 : APPENDROLL_CLOSED);
	hGeom = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDTRI_GEOM),
		GeomDlgProc, GetString (IDS_EDIT_GEOM), (LPARAM) this, rsGeom ? 0 : APPENDROLL_CLOSED);

	if (selLevel == SL_OBJECT)
		hApprox = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_DISP_APPROX),
									DispApproxDlgProc, GetString(IDS_SCA_SURFACE),
									(LPARAM)this,  rsApprox ? 0 : APPENDROLL_CLOSED);

	if (selLevel == SL_OBJECT) hSurf = NULL;
	else hSurf = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(SurfDlgs[selLevel]),
			SurfaceDlgProc, GetString(IDS_SCA_SURFACE), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);

	InvalidateNumberSelected ();

	accel = new EMeshShortcutCB(this);
	ip->ActivateShortcutTable (accel, kEMeshShortcuts);

	// Create sub object editing modes.
	moveMode       = new MoveModBoxCMode(this,ip);
	rotMode        = new RotateModBoxCMode(this,ip);
	uscaleMode     = new UScaleModBoxCMode(this,ip);
	nuscaleMode    = new NUScaleModBoxCMode(this,ip);
	squashMode     = new SquashModBoxCMode(this,ip);
	selectMode     = new SelectModBoxCMode(this,ip);
	weldVertMode   = new WeldVertCMode(this,ip);
	createVertMode = new CreateVertCMode(this,ip);
	createFaceMode  = new CreateFaceCMode(this,ip);
	divideEdgeMode = new DivideEdgeCMode(this,ip);
	turnEdgeMode   = new TurnEdgeCMode(this,ip);
	attachPickMode = new AttachPickMode(this,ip);
	extrudeMode    = new ExtrudeCMode(this,ip);
	bevelMode = new BevelCMode (this, ip);
	chamferMode = new ChamferCMode (this, ip);
	divideFaceMode = new DivideFaceCMode (this, ip);
	flipMode       = new FlipNormCMode(this,ip);
	cutEdgeMode   = new CutEdgeCMode (this, ip);

	// Add our sub object type
	TSTR type1(GetString(IDS_VERTEX));
	TSTR type2(GetString (IDS_EDGE));
	TSTR type3(GetString (IDS_FACE));
	TSTR type4(GetString (IDS_POLYGON));
	TSTR type5(GetString (IDS_ELEMENT));
	const TCHAR *ptype[] = {type1,type2,type3,type4,type5};
	ip->RegisterSubObjectTypes (ptype, 5);

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);

	// We want del key input if in geometry level
	if (selLevel != SL_OBJECT) ip->RegisterDeleteUser(this);

	// Set show end result.
	oldShowEnd = ip->GetShowEndResult();
	ip->SetShowEndResult (GetFlag (ET_DISP_RESULT));

	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);		
	SetAFlag(A_OBJ_BEING_EDITED);	
}

void EditTriObject::EndEditParams (IObjParam *ip, ULONG flags,Animatable *next)
{
	if (!enabled) return;

	if (accel) {
		ip->DeactivateShortcutTable (accel, kEMeshShortcuts);
		delete accel;
		accel = NULL;
	}

	if (hSel) {
		rsSel = IsRollupPanelOpen (hSel);
		ip->DeleteRollupPage (hSel);
		hSel = NULL;
	}
	if (hAR) {
		rsAR = IsRollupPanelOpen (hAR);
		ip->DeleteRollupPage (hAR);
		hAR = NULL;
	}
	if (hGeom) {
		rsGeom = IsRollupPanelOpen (hGeom);
		ip->DeleteRollupPage (hGeom);
		hGeom = NULL;
	}
	if (hApprox) {
		rsApprox = IsRollupPanelOpen (hApprox);
		ip->DeleteRollupPage (hApprox);
		hApprox = NULL;
	}
	if (hSurf) {
		rsSurf = IsRollupPanelOpen (hSurf);
		ip->DeleteRollupPage (hSurf);
		hSurf = NULL;
	}

	// Unregister del key notification
	if (selLevel != SL_OBJECT) ip->UnRegisterDeleteUser(this);

	ExitAllCommandModes ();
	if (moveMode) delete moveMode;
	moveMode = NULL;
	if (rotMode) delete rotMode;
	rotMode = NULL;
	if (uscaleMode) delete uscaleMode;
	uscaleMode = NULL;
	if (nuscaleMode) delete nuscaleMode;
	nuscaleMode = NULL;
	if (squashMode) delete squashMode;
	squashMode = NULL;
	if (selectMode) delete selectMode;
	selectMode = NULL;
	if (weldVertMode) delete weldVertMode;
	weldVertMode = NULL;
	if (createVertMode) delete createVertMode;
	createVertMode = NULL;
	if (createFaceMode) delete createFaceMode;
	createFaceMode = NULL;
	if (divideFaceMode) delete divideFaceMode;
	divideFaceMode = NULL;
	if (divideEdgeMode) delete divideEdgeMode;
	divideEdgeMode = NULL;
	if (turnEdgeMode) delete turnEdgeMode;
	turnEdgeMode = NULL;
	if (attachPickMode) delete attachPickMode;
	attachPickMode = NULL;
	if (extrudeMode) delete extrudeMode;
	extrudeMode = NULL;
	if (bevelMode) delete bevelMode;
	bevelMode = NULL;
	if (chamferMode) delete chamferMode;
	chamferMode = NULL;
	if (flipMode) delete flipMode;
	flipMode = NULL;
	if (cutEdgeMode) delete cutEdgeMode;
	cutEdgeMode = NULL;

	this->ip = NULL;

	if (tempData) {
		delete tempData;
		tempData = NULL;
	}
	if (tempMove) {
		delete tempMove;
		tempMove = NULL;
	}
	editObj = NULL;

	// Reset show end result
	SetFlag (ET_DISP_RESULT, ip->GetShowEndResult());
	ip->SetShowEndResult(oldShowEnd);

	ClearAFlag(A_OBJ_BEING_EDITED);	
}

void EditTriObject::ExitAllCommandModes (bool exSlice) {
	ip->DeleteMode (moveMode);
	ip->DeleteMode (rotMode);
	ip->DeleteMode (uscaleMode);
	ip->DeleteMode (nuscaleMode);
	ip->DeleteMode (squashMode);
	ip->DeleteMode (selectMode);
	ip->DeleteMode (weldVertMode);
	ip->DeleteMode (createVertMode);
	ip->DeleteMode (createFaceMode);	
	ip->DeleteMode (divideFaceMode);
	ip->DeleteMode (divideEdgeMode);	
	ip->DeleteMode (turnEdgeMode);
	ip->DeleteMode (extrudeMode);
	ip->DeleteMode (bevelMode);
	ip->DeleteMode (chamferMode);
	ip->DeleteMode (flipMode);
	ip->DeleteMode (cutEdgeMode);
	ip->ClearPickMode();
	if (exSlice && sliceMode) ExitSliceMode ();
	inCutEdge = FALSE;
	inBuildFace = FALSE;
	inExtrude = FALSE;
	inBevel = FALSE;
	inChamfer = FALSE;
}



// -- Misc. Window procs ----------------------------------------

static int createCurveType   = IDC_CURVE_SMOOTH;
static int curveIgnoreHiddenEdges = TRUE;

static BOOL CALLBACK CurveNameDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText (GetDlgItem(hWnd,IDC_CURVE_NAME), name->data());
		CenterWindow (hWnd,GetParent(hWnd));
		SendMessage(GetDlgItem(hWnd,IDC_CURVE_NAME), EM_SETSEL,0,-1);			
		CheckDlgButton(hWnd,createCurveType,TRUE);
		CheckDlgButton(hWnd,IDC_CURVE_IGNOREHIDDEN,curveIgnoreHiddenEdges);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize(GetWindowTextLength(GetDlgItem(hWnd,IDC_CURVE_NAME))+1);
			GetWindowText(GetDlgItem(hWnd,IDC_CURVE_NAME), name->data(), name->length()+1);
			if (IsDlgButtonChecked(hWnd,IDC_CURVE_SMOOTH)) createCurveType = IDC_CURVE_SMOOTH;
			else createCurveType = IDC_CURVE_LINEAR;
			curveIgnoreHiddenEdges = IsDlgButtonChecked(hWnd,IDC_CURVE_IGNOREHIDDEN);
			EndDialog(hWnd,1);
			break;
		
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

static BOOL detachToElem = FALSE;
static BOOL detachAsClone = FALSE;

static void SetDetachNameState(HWND hWnd) {
	if (detachToElem) {
		EnableWindow(GetDlgItem(hWnd,IDC_DETACH_NAMELABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_DETACH_NAME),FALSE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_DETACH_NAMELABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_DETACH_NAME),TRUE);
	}
}

static BOOL CALLBACK DetachDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_DETACH_NAME), name->data());
		CenterWindow(hWnd,GetParent(hWnd));
		SendMessage(GetDlgItem(hWnd,IDC_DETACH_NAME), EM_SETSEL,0,-1);
		CheckDlgButton (hWnd, IDC_DETACH_ELEM, detachToElem);
		CheckDlgButton (hWnd, IDC_DETACH_CLONE, detachAsClone);
		if (detachToElem) SetFocus (GetDlgItem (hWnd, IDOK));
		else SetFocus (GetDlgItem (hWnd, IDC_DETACH_NAME));
		SetDetachNameState(hWnd);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_DETACH_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_DETACH_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDC_DETACH_ELEM:
			detachToElem = IsDlgButtonChecked(hWnd,IDC_DETACH_ELEM);
			SetDetachNameState(hWnd);
			break;

		case IDC_DETACH_CLONE:
			detachAsClone = IsDlgButtonChecked (hWnd, IDC_DETACH_CLONE);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetDetachObjectName (Interface *ip, TSTR &name, BOOL &elem, BOOL &clone) {
	HWND hMax = ip->GetMAXHWnd();
	name = GetString(IDS_OBJECT);
	ip->MakeNameUnique (name);
	if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DETACH),
			hMax, DetachDlgProc, (LPARAM)&name)) {
		elem = detachToElem;
		clone = detachAsClone;
		return TRUE;
	} else {
		return FALSE;
	}
}

static void SetCloneNameState(HWND hWnd) {
	switch (cloneTo) {
	case IDC_CLONE_ELEM:
		EnableWindow(GetDlgItem(hWnd,IDC_CLONE_NAME),FALSE);
		break;
	case IDC_CLONE_OBJ:
		EnableWindow(GetDlgItem(hWnd,IDC_CLONE_NAME),TRUE);
		break;
	}
}

static BOOL CALLBACK CloneDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_CLONE_NAME), name->data());
		CenterWindow(hWnd, GetParent(hWnd));

		CheckRadioButton (hWnd, IDC_CLONE_OBJ, IDC_CLONE_ELEM, cloneTo);
		if (cloneTo == IDC_CLONE_OBJ) {
			SetFocus(GetDlgItem(hWnd,IDC_CLONE_NAME));
			SendMessage(GetDlgItem(hWnd,IDC_CLONE_NAME), EM_SETSEL,0,-1);
		} else SetFocus (GetDlgItem (hWnd, IDOK));
		SetCloneNameState(hWnd);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_CLONE_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_CLONE_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog (hWnd, 0);
			break;

		case IDC_CLONE_ELEM:
		case IDC_CLONE_OBJ:
			cloneTo = LOWORD(wParam);
			SetCloneNameState(hWnd);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetCloneObjectName (Interface *ip, TSTR &name) {
	HWND hMax = ip->GetMAXHWnd();
	name = GetString(IDS_OBJECT);
	if (ip) ip->MakeNameUnique (name);
	DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_CLONE), hMax, CloneDlgProc, (LPARAM)&name);
	return (cloneTo==IDC_CLONE_OBJ);
}

static BOOL CALLBACK ExplodeDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		SetWindowText(GetDlgItem(hWnd,IDC_EXPLODE_NAME), name->data());
		CenterWindow(hWnd, GetParent(hWnd));
		SetFocus(GetDlgItem(hWnd,IDC_EXPLODE_NAME));
		SendMessage(GetDlgItem(hWnd,IDC_EXPLODE_NAME), EM_SETSEL,0,-1);
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			name->Resize (GetWindowTextLength(GetDlgItem(hWnd,IDC_EXPLODE_NAME))+1);
			GetWindowText (GetDlgItem(hWnd,IDC_EXPLODE_NAME),
				name->data(), name->length()+1);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

BOOL GetExplodeObjectName (HWND hMax, TSTR &name) {
	name = GetString(IDS_OBJECT);
	if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EXPLODE),
		hMax, ExplodeDlgProc, (LPARAM)&name)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

void EditTriObject::SetSelDlgEnables() {
	if (!hSel) return;
	BOOL fac = (selLevel >= SL_FACE);
	BOOL poly = (selLevel == SL_POLY);
	BOOL edg = (selLevel == SL_EDGE);
	BOOL obj = (selLevel == SL_OBJECT);
	BOOL vtx = (selLevel == SL_VERTEX);

	EnableWindow (GetDlgItem (hSel, IDC_SEL_BYVERT), fac||edg);
	EnableWindow (GetDlgItem (hSel, IDC_IGNORE_BACKFACES), !obj);
	EnableWindow (GetDlgItem (hSel,IDC_IGNORE_VISEDGE), poly);
	EnableWindow (GetDlgItem (hSel,IDC_SEL_PT_TEXT), poly);
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hSel,IDC_PLANARSPINNER));
	spin->Enable(poly);
	ReleaseISpinner(spin);
	ICustButton *but;
	but = GetICustButton (GetDlgItem (hSel, IDC_HIDE));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hSel, IDC_UNHIDEALL));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);

	but = GetICustButton (GetDlgItem (hSel, IDC_COPY_NS));
	but->Enable (!obj);
	ReleaseICustButton(but);
	but = GetICustButton (GetDlgItem (hSel, IDC_PASTE_NS));
	but->Enable (!obj && (GetMeshNamedSelClip (namedClipLevel[selLevel]) ? TRUE : FALSE));
	ReleaseICustButton(but);
}

static BOOL CALLBACK SelectDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditTriObject *eo = (EditTriObject *) GetWindowLong (hWnd, GWL_USERDATA);
	ICustToolbar *iToolbar;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		eo = (EditTriObject*)lParam;
		eo->hSel = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);			
		
		spin = GetISpinner(GetDlgItem(hWnd,IDC_PLANARSPINNER));
		spin->SetLimits(0, 180, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_PLANAR), EDITTYPE_FLOAT);
		spin->SetValue(planarFaceThresh,FALSE);
		ReleaseISpinner(spin);

		iToolbar = GetICustToolbar(GetDlgItem(hWnd,IDC_SELTYPE));
		iToolbar->SetImage (theMeshSelImageHandler.LoadImages());
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,5,0,5,24,23,24,23,IDC_SELVERTEX));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,6,1,6,24,23,24,23,IDC_SELEDGE));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,7,2,7,24,23,24,23,IDC_SELFACE));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,3,8,3,8,24,23,24,23,IDC_SELPOLY));
		iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,4,9,4,9,24,23,24,23,IDC_SELELEMENT));
		ReleaseICustToolbar(iToolbar);
		eo->RefreshSelType();

		CheckDlgButton (hWnd, IDC_SEL_BYVERT, eo->selByVert);
		CheckDlgButton (hWnd, IDC_IGNORE_BACKFACES, eo->ignoreBackfaces);
		CheckDlgButton (hWnd, IDC_IGNORE_VISEDGE, eo->ignoreVisEdge);
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_PLANARSPINNER:
			planarFaceThresh = spin->GetFVal();
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.

		switch (LOWORD(wParam)) {
		case IDC_SELVERTEX:
			if (eo->selLevel == SL_VERTEX) eo->ip->SetSubObjectLevel (SL_OBJECT);
			else eo->ip->SetSubObjectLevel (SL_VERTEX);
			break;

		case IDC_SELEDGE:
			if (eo->selLevel == SL_EDGE) eo->ip->SetSubObjectLevel (SL_OBJECT);
			else eo->ip->SetSubObjectLevel (SL_EDGE);
			break;

		case IDC_SELFACE:
			if (eo->selLevel == SL_FACE) eo->ip->SetSubObjectLevel (SL_OBJECT);
			else eo->ip->SetSubObjectLevel (SL_FACE);
			break;

		case IDC_SELPOLY:
			if (eo->selLevel == SL_POLY) eo->ip->SetSubObjectLevel (SL_OBJECT);
			else eo->ip->SetSubObjectLevel (SL_POLY);
			break;

		case IDC_SELELEMENT:
			if (eo->selLevel == SL_ELEMENT) eo->ip->SetSubObjectLevel (SL_OBJECT);
			else eo->ip->SetSubObjectLevel (SL_ELEMENT);
			break;

		case IDC_SEL_BYVERT:
			eo->selByVert = IsDlgButtonChecked(hWnd,IDC_SEL_BYVERT);
			break;

		case IDC_IGNORE_BACKFACES:
			eo->ignoreBackfaces = IsDlgButtonChecked(hWnd,IDC_IGNORE_BACKFACES);
			break;

		case IDC_IGNORE_VISEDGE:
			eo->ignoreVisEdge = IsDlgButtonChecked(hWnd,IDC_IGNORE_VISEDGE);
			break;

		case IDC_HIDE: eo->ButtonOp (MopHide); break;
		case IDC_UNHIDEALL: eo->ButtonOp (MopUnhideAll); break;
		case IDC_COPY_NS: eo->NSCopy(); break;
		case IDC_PASTE_NS: eo->NSPaste(); break;
		}
		break;

	case WM_PAINT:
		if (updateNumSel) eo->SetNumSelLabel ();
		return FALSE;

	case WM_NOTIFY:
		if(((LPNMHDR)lParam)->code != TTN_NEEDTEXT) break;
		LPTOOLTIPTEXT lpttt;
		lpttt = (LPTOOLTIPTEXT)lParam;				
		switch (lpttt->hdr.idFrom) {
		case IDC_SELVERTEX:
			lpttt->lpszText = GetString (IDS_VERTEX);
			break;
		case IDC_SELEDGE:
			lpttt->lpszText = GetString (IDS_EDGE);
			break;
		case IDC_SELFACE:
			lpttt->lpszText = GetString(IDS_FACE);
			break;
		case IDC_SELPOLY:
			lpttt->lpszText = GetString(IDS_POLYGON);
			break;
		case IDC_SELELEMENT:
			lpttt->lpszText = GetString(IDS_ELEMENT);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

#define GRAPHSTEPS 20

static void DrawCurve(HWND hWnd,HDC hdc) {
	float pinch, falloff, bubble;
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
	falloff = spin->GetFVal();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_PINCHSPIN));
	pinch = spin->GetFVal();
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_BUBBLESPIN));
	bubble = spin->GetFVal();
	ReleaseISpinner(spin);	

	TSTR label = FormatUniverseValue(falloff);
	SetWindowText(GetDlgItem(hWnd,IDC_FARLEFTLABEL), label);
	SetWindowText(GetDlgItem(hWnd,IDC_FARLEFTLABEL), FormatUniverseValue (0.0f));
	SetWindowText(GetDlgItem(hWnd,IDC_FARRIGHTLABEL), label);

	Rect rect, orect;
	GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
	orect = rect;

	SelectObject(hdc,GetStockObject(NULL_PEN));
	SelectObject(hdc,GetStockObject(WHITE_BRUSH));
	Rectangle(hdc,rect.left,rect.top,rect.right,rect.bottom);	
	SelectObject(hdc,GetStockObject(NULL_BRUSH));
	
	rect.left   += 3;
	rect.right  -= 3;
	rect.top    += 20;
	rect.bottom -= 20;
	
	SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
	MoveToEx(hdc,orect.left,rect.top,NULL);
	LineTo(hdc,orect.right,rect.top);
	MoveToEx(hdc,orect.left,rect.bottom,NULL);
	LineTo(hdc,orect.right,rect.bottom);
	MoveToEx(hdc,(rect.left+rect.right)/2,orect.top,NULL);
	LineTo(hdc,(rect.left+rect.right)/2,orect.bottom);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	
	MoveToEx(hdc,rect.left,rect.bottom,NULL);
	for (int i=0; i<=GRAPHSTEPS; i++) {
		float dist = falloff * float(abs(i-GRAPHSTEPS/2))/float(GRAPHSTEPS/2);		
		float y = AffectRegionFunction(dist,falloff,pinch,bubble);
		int ix = rect.left + int(float(rect.w()-1) * float(i)/float(GRAPHSTEPS));
		int	iy = rect.bottom - int(y*float(rect.h()-2)) - 1;
		if (iy<orect.top) iy = orect.top;
		if (iy>orect.bottom-1) iy = orect.bottom-1;
		LineTo(hdc, ix, iy);
	}
	
	WhiteRect3D(hdc,orect,TRUE);
}

void EditTriObject::SetARDlgEnables () {
	if (!hAR) return;
	ISpinnerControl *spin;
	EnableWindow (GetDlgItem (hAR, IDC_AFFECT_REGION), selLevel);
	bool enable = (selLevel && affectRegion) ? TRUE : FALSE;
	EnableWindow (GetDlgItem (hAR, IDC_E_DIST), enable);
	EnableWindow (GetDlgItem (hAR, IDC_AR_BACK), enable);
	spin = GetISpinner (GetDlgItem (hAR, IDC_E_ITER_SPIN));
	spin->Enable (enable && useEdgeDist);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_FALLOFFSPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_PINCHSPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hAR, IDC_BUBBLESPIN));
	spin->Enable (enable);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hAR, IDC_FALLOFF_LABEL), enable);
	EnableWindow (GetDlgItem (hAR, IDC_PINCH_LABEL), enable);
	EnableWindow (GetDlgItem (hAR, IDC_BUBBLE_LABEL), enable);
}

BOOL CALLBACK AffectRegionDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditTriObject *em = (EditTriObject*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	Rect rect;

	switch (msg) {
	case WM_INITDIALOG:
		em = (EditTriObject*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		// Set spinners:
		spin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
		spin->SetLimits(0.001f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_FALLOFF), EDITTYPE_POS_UNIVERSE);
		spin->SetValue(em->falloff,FALSE);
		spin->SetResetValue (DEF_FALLOFF);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_PINCHSPIN));
		spin->SetLimits(-10.0f,10.0f, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_PINCH), EDITTYPE_FLOAT);
		spin->SetValue(em->pinch,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_BUBBLESPIN));
		spin->SetLimits(-10.0f,10.0f, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_BUBBLE), EDITTYPE_FLOAT);
		spin->SetValue(em->bubble,FALSE);
		ReleaseISpinner(spin);
					
		spin = GetISpinner(GetDlgItem(hWnd,IDC_E_ITER_SPIN));
		spin->SetLimits(1,8, FALSE);
		spin->SetScale(0.01f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_E_ITER), EDITTYPE_INT);
		spin->SetValue(em->edgeIts,FALSE);
		spin->SetResetValue (1);
		if (!em->affectRegion || !em->useEdgeDist) spin->Disable();
		ReleaseISpinner(spin);

		// Check Checkboxes:
		CheckDlgButton (hWnd, IDC_AFFECT_REGION, em->affectRegion);
		CheckDlgButton(hWnd, IDC_E_DIST, em->useEdgeDist);
		CheckDlgButton (hWnd, IDC_AR_BACK, !em->arIgBack);

		ShowWindow(GetDlgItem(hWnd,IDC_AR_GRAPH),SW_HIDE);
		CenterWindow(hWnd,GetParent(hWnd));
		em->hAR = hWnd;
		em->SetARDlgEnables ();
		break;
		
	case WM_PAINT: {
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd,&ps);
		DrawCurve (hWnd, hdc);
		EndPaint(hWnd,&ps);
		break;
		}

	case CC_SPINNER_CHANGE:
		if (LOWORD(wParam) != IDC_E_ITER_SPIN) {
			GetClientRectP(GetDlgItem(hWnd,IDC_AR_GRAPH),&rect);
			InvalidateRect(hWnd,&rect,FALSE);
		}
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_FALLOFFSPIN:
			em->falloff = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_PINCHSPIN:
			em->pinch = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_BUBBLESPIN:
			em->bubble = spin->GetFVal();
			em->InvalidateAffectRegion();
			break;
		case IDC_E_ITER_SPIN:
			em->edgeIts = spin->GetIVal ();
			em->InvalidateDistances ();
		}
		em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
		em->ip->RedrawViews (em->ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_AFFECT_REGION:
			em->affectRegion = IsDlgButtonChecked (hWnd,IDC_AFFECT_REGION);
			em->SetARDlgEnables ();
			em->InvalidateDistances ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;

		case IDC_E_DIST:
			em->useEdgeDist = IsDlgButtonChecked (hWnd, IDC_E_DIST);
			spin = GetISpinner (GetDlgItem (hWnd, IDC_E_ITER_SPIN));
			spin->Enable (em->useEdgeDist && em->affectRegion);
			ReleaseISpinner(spin);
			em->InvalidateDistances ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;

		case IDC_AR_BACK:
			em->arIgBack = !IsDlgButtonChecked (hWnd, IDC_AR_BACK);
			em->InvalidateAffectRegion ();
			em->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
			em->ip->RedrawViews(em->ip->GetTime());
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

void EditTriObject::SetGeomDlgEnables () {
	if (!hGeom) return;
	BOOL edg = (selLevel == SL_EDGE);
	BOOL vtx = (selLevel == SL_VERTEX);
	BOOL fac = (selLevel >= SL_FACE);
	BOOL obj = (selLevel == SL_OBJECT);
	ISpinnerControl *spin;
	ICustButton *but;

	but = GetICustButton (GetDlgItem (hGeom, IDC_CREATE));
	but->Enable (vtx||fac);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_DETACH));
	but->Enable (!edg);
	if (obj) but->SetText (GetString (IDS_ATTACH_LIST));
	else but->SetText (GetString (IDS_DETACH));
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_DIVIDE));
	but->Enable (!obj);
	if (edg||fac) {
		but->SetText (GetString (IDS_DIVIDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
	} else {
		but->SetText (GetString (IDS_BREAK));
		but->SetType (CBT_PUSH);
	}
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EDGE_TURN));
	but->Enable (edg);
	ReleaseICustButton (but);
	// Align buttons always active.
	but = GetICustButton (GetDlgItem (hGeom, IDC_MAKEPLANAR));
	but->Enable (!obj);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_DELETE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_EXTRUDE));
	but->Enable (edg||fac);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_EXTRUDESPINNER));
	spin->Enable (edg||fac);
	ReleaseISpinner (spin);
	but = GetICustButton (GetDlgItem (hGeom, IDC_BEVEL));
	but->Enable (!obj);
	if (vtx||edg) but->SetText (GetString (IDS_CHAMFER));
	else but->SetText (GetString (IDS_BEVEL));
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_OUTLINESPINNER));
	spin->Enable (!obj);
	if (vtx||edg) spin->SetLimits(0.0f, 9999999.0f, FALSE);
	else spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_EXTYPE_A), fac||edg);
	EnableWindow (GetDlgItem (hGeom, IDC_EXTYPE_B), fac||edg);
	but = GetICustButton (GetDlgItem (hGeom, IDC_COLLAPSE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	// It would be nice if Slice Plane were always active, but we can't make it available
	// at the object level, since the transforms won't work.
	but = GetICustButton (GetDlgItem (hGeom, IDC_SLICEPLANE));
	but->Enable (!obj);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_SPLIT), !obj);
	but = GetICustButton (GetDlgItem (hGeom, IDC_CUT));
	but->Enable (edg|fac);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_REFINE), (edg||fac) && (!sliceMode));

	but = GetICustButton (GetDlgItem (hGeom, IDC_TESSELLATE));
	but->Enable (fac);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_TENSIONSPINNER));
	spin->Enable (fac && edgeTes);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_TES_TEXT), fac);
	EnableWindow (GetDlgItem (hGeom, IDC_TES_EDGE), fac);
	EnableWindow (GetDlgItem (hGeom, IDC_TES_CENTER), fac);

	but = GetICustButton (GetDlgItem (hGeom, IDC_EXPLODE));
	but->Enable (fac||obj);
	ReleaseICustButton (but);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_ANGLETHRESHSPIN));
	spin->Enable (fac || obj);
	ReleaseISpinner (spin);
	EnableWindow (GetDlgItem (hGeom, IDC_EXP_TEXT), fac||obj);
	EnableWindow (GetDlgItem (hGeom, IDC_EXP_ELEMENTS), fac||obj);
	EnableWindow (GetDlgItem (hGeom, IDC_EXP_OBJECTS), fac||obj);

	but = GetICustButton (GetDlgItem (hGeom, IDC_WELD));
	but->Enable (vtx);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_WELDTOVERT));
	but->Enable (vtx);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hGeom, IDC_PIXELS_TEXT), vtx);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_W_THR_SPIN));
	spin->Enable (vtx);
	ReleaseISpinner (spin);
	spin = GetISpinner (GetDlgItem (hGeom, IDC_T_THR_SPIN));
	spin->Enable (vtx);
	ReleaseISpinner (spin);

	but = GetICustButton (GetDlgItem (hGeom, IDC_SELECT_OPEN));
	but->Enable (edg);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hGeom, IDC_CREATE_CURVE));
	but->Enable (edg);
	ReleaseICustButton (but);
}

static BOOL CALLBACK GeomDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditTriObject *eo = (EditTriObject*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	ICustButton *but;
	TSTR name;
	//MeshDelta tmd;

	switch (msg) {
	case WM_INITDIALOG:
		// Record the ETO * in the window's long.
		eo = (EditTriObject*)lParam;
		eo->hGeom = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		// Set up the "depressed" color for the command-mode buttons
		but = GetICustButton(GetDlgItem(hWnd,IDC_CREATE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_DIVIDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EDGE_TURN));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_EXTRUDE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_BEVEL));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_OBJ_ATTACH));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);					

		but = GetICustButton(GetDlgItem(hWnd,IDC_SLICEPLANE));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		but->SetCheck (eo->sliceMode);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_CUT));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		but = GetICustButton(GetDlgItem(hWnd,IDC_WELDTOVERT));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		ReleaseICustButton(but);

		// Set up spinners
		spin = GetISpinner(GetDlgItem(hWnd,IDC_EXTRUDESPINNER));
		spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
		spin->LinkToEdit (GetDlgItem (hWnd,IDC_EXTRUDEAMOUNT), EDITTYPE_UNIVERSE);
		spin->SetScale (.1f);
		ReleaseISpinner (spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_OUTLINESPINNER));
		spin->SetLimits(-9999999.0f, 9999999.0f, FALSE);
		spin->LinkToEdit (GetDlgItem (hWnd,IDC_OUTLINEAMOUNT), EDITTYPE_UNIVERSE);
		spin->SetScale (.1f);
		ReleaseISpinner (spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_TENSIONSPINNER));
		spin->SetLimits(-100,100, FALSE);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_TENSION), EDITTYPE_FLOAT);
		spin->SetValue(tessTens,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner (GetDlgItem (hWnd,IDC_ANGLETHRESHSPIN));
		spin->SetLimits(0, 180, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_ANGLETHRESH), EDITTYPE_FLOAT);
		spin->SetValue(explodeThresh,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner (GetDlgItem(hWnd, IDC_W_THR_SPIN));
		spin->SetLimits(0,9999999, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_W_THR), EDITTYPE_POS_UNIVERSE);
		spin->SetValue(weldThresh,FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_T_THR_SPIN));
		spin->SetLimits(1,1000, FALSE);
		spin->SetScale(0.1f);
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_T_THR), EDITTYPE_INT);
		spin->SetValue(eo->weldBoxSize,FALSE);
		ReleaseISpinner(spin);

		// Take care of Explode and Tessellation radios:
		if (expObj) {
			CheckDlgButton (hWnd, IDC_EXP_OBJECTS, TRUE);
			CheckDlgButton (hWnd, IDC_EXP_ELEMENTS, FALSE);
		} else {
			CheckDlgButton (hWnd, IDC_EXP_OBJECTS, FALSE);
			CheckDlgButton (hWnd, IDC_EXP_ELEMENTS, TRUE);
		}

		if (edgeTes) {
			CheckDlgButton (hWnd, IDC_TES_EDGE, TRUE);
			CheckDlgButton (hWnd, IDC_TES_CENTER, FALSE);
		} else {
			CheckDlgButton(hWnd,IDC_TES_EDGE,FALSE);
			CheckDlgButton(hWnd,IDC_TES_CENTER,TRUE);				
		}

		if (eo->extType == MESH_EXTRUDE_CLUSTER) {
			CheckRadioButton (hWnd, IDC_EXTYPE_A, IDC_EXTYPE_B, IDC_EXTYPE_A);
		} else {
			CheckRadioButton (hWnd, IDC_EXTYPE_A, IDC_EXTYPE_B, IDC_EXTYPE_B);
		}

		// Set Slice button to be grey if not in Slice Plane mode.
		but = GetICustButton (GetDlgItem (hWnd, IDC_SLICE));
		but->Enable (eo->sliceMode);
		ReleaseICustButton (but);

		// Check boxes as appropriate
		CheckDlgButton(hWnd, IDC_SPLIT, eo->sliceSplit);
		CheckDlgButton(hWnd, IDC_REFINE, eo->cutRefine);
		eo->SetGeomDlgEnables();
		break;

	case CC_SPINNER_BUTTONDOWN:
		switch (LOWORD(wParam)) {
		case IDC_EXTRUDESPINNER:
			eo->BeginExtrude (eo->ip->GetTime());
			break;

		case IDC_OUTLINESPINNER:
			switch (eo->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				eo->BeginChamfer (eo->ip->GetTime ());
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				eo->BeginBevel (eo->ip->GetTime (), FALSE);
				break;
			}
			break;
		}
		break;

	case CC_SPINNER_BUTTONUP:
		switch (LOWORD(wParam)) {
		case IDC_EXTRUDESPINNER:
			eo->EndExtrude (eo->ip->GetTime(),HIWORD(wParam));
			eo->ip->RedrawViews (eo->ip->GetTime(), REDRAW_END);
			break;

		case IDC_OUTLINESPINNER:
			switch (eo->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				eo->EndChamfer (eo->ip->GetTime (), HIWORD(wParam));
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				eo->EndBevel (eo->ip->GetTime(), HIWORD(wParam));
				break;
			}
			eo->ip->RedrawViews (eo->ip->GetTime(), REDRAW_END);
			break;
		}
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;

		switch (LOWORD(wParam)) {
		case IDC_T_THR_SPIN: eo->weldBoxSize = spin->GetIVal(); break;
		case IDC_W_THR_SPIN: weldThresh = spin->GetFVal (); break;
		case IDC_ANGLETHRESHSPIN: explodeThresh = spin->GetFVal (); break;
		case IDC_TENSIONSPINNER: tessTens = spin->GetFVal (); break;

		case IDC_EXTRUDESPINNER:
			bool enterKey;
			enterKey = FALSE;
			if (!HIWORD(wParam) && !eo->inExtrude) {
				enterKey = TRUE;
				eo->BeginExtrude(eo->ip->GetTime());
			}
			eo->Extrude (eo->ip->GetTime(),spin->GetFVal());
			if (enterKey) {
				eo->EndExtrude (eo->ip->GetTime(),TRUE);
				eo->ip->RedrawViews (eo->ip->GetTime(),REDRAW_END);
			} else {
				eo->ip->RedrawViews (eo->ip->GetTime(),REDRAW_INTERACTIVE);
			}
			break;

		case IDC_OUTLINESPINNER:
			enterKey = FALSE;
			switch (eo->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				if (!HIWORD(wParam) && !eo->inChamfer) {
					enterKey = TRUE;
					eo->BeginChamfer (eo->ip->GetTime ());
				}
				eo->Chamfer (eo->ip->GetTime (), spin->GetFVal ());
				if (enterKey) eo->EndChamfer (eo->ip->GetTime (), TRUE);
				break;

			default:
				if (!HIWORD(wParam) && !eo->inBevel) {
					enterKey = TRUE;
					eo->BeginBevel (eo->ip->GetTime ());
				}
				eo->Bevel (eo->ip->GetTime (), spin->GetFVal ());
				if (enterKey) eo->EndBevel (eo->ip->GetTime (), TRUE);
				break;
			}
			if (enterKey) eo->ip->RedrawViews (eo->ip->GetTime(), REDRAW_END);
			else eo->ip->RedrawViews (eo->ip->GetTime(),REDRAW_INTERACTIVE);
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam)==1) return FALSE;	// not handling keyboard accelerators here.

		switch (LOWORD(wParam)) {
		case IDC_CREATE: eo->ToggleCommandMode (McmCreate); break;

		case IDC_DETACH:
			if (eo->selLevel == SL_OBJECT) {
				// Really an attach multiple button.
				AttachHitByName proc(eo);
				eo->ip->DoHitByNameDialog(&proc);
			} else eo->ButtonOp (MopDetach);
			break;

		case IDC_DIVIDE:
			switch (eo->selLevel) {
			case SL_OBJECT: break;
			case SL_VERTEX: eo->ButtonOp (MopBreak); break;
			default: eo->ToggleCommandMode (McmDivide); break;
			}
			break;

		case IDC_EDGE_TURN: eo->ToggleCommandMode (McmTurnEdge); break;
		case IDC_ALIGNVIEW: eo->ButtonOp (MopViewAlign); break;
		case IDC_ALIGNCONST: eo->ButtonOp (MopGridAlign); break;
		case IDC_MAKEPLANAR: eo->ButtonOp (MopMakePlanar); break;
		case IDC_DELETE: eo->ButtonOp (MopDelete); break;
		case IDC_EXTRUDE: eo->ToggleCommandMode (McmExtrude); break;

		case IDC_BEVEL:
			switch (eo->selLevel) {
			case SL_VERTEX:
			case SL_EDGE:
				eo->ToggleCommandMode (McmChamfer);
				break;
			case SL_FACE:
			case SL_POLY:
			case SL_ELEMENT:
				eo->ToggleCommandMode (McmBevel);
				break;
			}
			break;

		case IDC_EXTYPE_A:
			eo->extType = MESH_EXTRUDE_CLUSTER;
			break;

		case IDC_EXTYPE_B:
			eo->extType = MESH_EXTRUDE_LOCAL;
			break;

		case IDC_COLLAPSE: eo->ButtonOp (MopCollapse); break;
		case IDC_OBJ_ATTACH: eo->ToggleCommandMode (McmAttach); break;
		case IDC_SLICEPLANE: eo->ToggleCommandMode (McmSlicePlane); break;
		case IDC_CUT: eo->ToggleCommandMode (McmCut); break;
		case IDC_SLICE: eo->ButtonOp (MopSlice); break;

		case IDC_REFINE:
			eo->cutRefine = IsDlgButtonChecked(hWnd,IDC_REFINE) ? TRUE : FALSE;
			break;

		case IDC_SPLIT:
			eo->sliceSplit = IsDlgButtonChecked(hWnd,IDC_SPLIT) ? TRUE : FALSE;
			break;

		case IDC_TESSELLATE: eo->ButtonOp (MopTessellate); break;

		case IDC_TES_EDGE:
			edgeTes = TRUE;
			spin = GetISpinner (GetDlgItem (hWnd,IDC_TENSIONSPINNER));
			spin->Enable();
			ReleaseISpinner(spin);
			break;

		case IDC_TES_CENTER:
			edgeTes = FALSE;
			spin = GetISpinner (GetDlgItem (hWnd,IDC_TENSIONSPINNER));
			spin->Disable();
			ReleaseISpinner(spin);
			break;

		case IDC_EXPLODE: eo->ButtonOp (MopExplode); break;

		case IDC_EXP_OBJECTS:
			expObj = TRUE;
			break;

		case IDC_EXP_ELEMENTS:
			expObj = FALSE;
			break;

		case IDC_WELD: eo->ButtonOp (MopWeld); break;
		case IDC_WELDTOVERT: eo->ToggleCommandMode (McmWeldTarget); break;
		case IDC_REMOVE_ISO_VERTS: eo->ButtonOp (MopRemoveIsolatedVerts); break;
		case IDC_SELECT_OPEN: eo->ButtonOp (MopSelectOpenEdges); break;
		case IDC_CREATE_CURVE: eo->ButtonOp (MopCreateShapeFromEdges); break;
		}
		break;

	default:
		return FALSE;
	}

	return TRUE;
}

static void SetSmoothButtonState (HWND hWnd,DWORD bits,DWORD invalid,DWORD unused=0) {
	for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++) {
		if ( (unused&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			ShowWindow(GetDlgItem(hWnd,i),SW_HIDE);
			continue;
		}

		if ( (invalid&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			SetWindowText(GetDlgItem(hWnd,i),NULL);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,FALSE);
		} else {
			TSTR buf;
			buf.printf(_T("%d"),i-IDC_SMOOTH_GRP1+1);
			SetWindowText(GetDlgItem(hWnd,i),buf);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,
				(bits&(1<<(i-IDC_SMOOTH_GRP1)))?TRUE:FALSE);
		}
		InvalidateRect(GetDlgItem(hWnd,i),NULL,TRUE);
	}
}

static BOOL CALLBACK SelectBySmoothDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static DWORD *param;
	int i;
	ICustButton *iBut;

	switch (msg) {
	case WM_INITDIALOG:
		param = (DWORD*)lParam;
		for (i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
		SetSmoothButtonState(hWnd,param[0],0,param[2]);
		CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

	case WM_COMMAND: 
		if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
			LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
			iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));				
			int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;				
			if (iBut->IsChecked()) param[0] |= 1<<shift;
			else param[0] &= ~(1<<shift);		
			ReleaseICustButton(iBut);
			break;
		}

		switch (LOWORD(wParam)) {
		case IDOK:
			param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);					
			EndDialog(hWnd,1);					
			break;					

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;			

	default: return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK SelectByMatDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static int *param;
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		param = (int*)lParam;
		SetupIntSpinner(hWnd,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,param[0]);			
		CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			spin = GetISpinner(GetDlgItem(hWnd,IDC_MAT_IDSPIN));
			param[0] = spin->GetIVal();
			param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);
			ReleaseISpinner(spin);
			EndDialog(hWnd,1);					
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

void EditTriObject::InvalidateSurfaceUI() {
	if (!hSurf) return;
	faceUIValid = FALSE;
	InvalidateRect (hSurf, NULL, FALSE);
}

class WeightSpinRestore : public RestoreObj {
public:
	EditTriObject *eto;
	int vnum;
	Tab<float> oldWeights;
	Tab<float> newWeights;

	WeightSpinRestore () { eto = NULL; }
	WeightSpinRestore (EditTriObject *eo);
	void Restore (int isUndo);
	void Redo ();
	int Size () { return sizeof(eto) + sizeof(int) + 2*sizeof(Tab<float>); }
	TSTR Description() { return _T("Weight Spin Restore"); }
};

WeightSpinRestore::WeightSpinRestore (EditTriObject *eo) {
	eto = eo;
	vnum = eo->GetMesh().numVerts;
	float *vw = eo->GetMesh().getVertexWeights ();
	if (!vw) return;
	oldWeights.SetCount (vnum);
	memcpy (oldWeights.Addr(0), vw, vnum * sizeof(float));
}

void WeightSpinRestore::Restore (int isUndo) {
	if (!eto) return;
	float *vw = eto->GetMesh().getVertexWeights();
	if (!vw) return;
	if (!newWeights.Count()) {
		newWeights.SetCount (vnum);
		memcpy (newWeights.Addr(0), vw, vnum*sizeof(float));
	}
	if (oldWeights.Count()) {
		memcpy (vw, oldWeights.Addr(0), vnum * sizeof(float));
	} else {
		for (int i=0; i<vnum; i++) vw[i] = 1.0f;
	}

	if (eto->hSurf && GetDlgItem (eto->hSurf, IDC_WEIGHT_LABEL))
		eto->UpdateWeightDisplay (eto->ip ? eto->ip->GetTime() : 0, eto->hSurf);
	eto->NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
}

void WeightSpinRestore::Redo () {
	if (!eto) return;
	float *vw = eto->GetMesh().getVertexWeights();
	if (!vw) return;
	memcpy (vw, newWeights.Addr(0), vnum * sizeof(float));

	if (eto->hSurf && GetDlgItem (eto->hSurf, IDC_WEIGHT_LABEL))
		eto->UpdateWeightDisplay (eto->ip ? eto->ip->GetTime() : 0, eto->hSurf);
	eto->NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
}

static int autoEdgeTypeIDs[] = { IDC_AE_SETCLEAR, IDC_AE_SET, IDC_AE_CLEAR };

static BOOL CALLBACK SurfaceDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	EditTriObject *eo = (EditTriObject*)GetWindowLong(hWnd,GWL_USERDATA);
	ISpinnerControl *spin;
	ICustButton *but;
	IColorSwatch *iCol;
	COLORREF rgb;
	int i;
	bool isFace, isVert;
	static WeightSpinRestore *wsr = NULL;

	switch (msg) {
	case WM_INITDIALOG:
		eo = (EditTriObject*)lParam;
		eo->hSurf = hWnd;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		if (GetDlgItem (hWnd, IDC_SMOOTH_GRP1)) {	// Face stuff:
			// NOTE: the following requires that the smoothing group ID's be sequential!
			isFace = TRUE;
			for (i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
				SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SetupIntSpinner (hWnd, IDC_MAT_IDSPIN, IDC_MAT_ID, 1, MAX_MATID, 0);
			SetupFloatSpinner (hWnd, IDC_SMOOTH_THRESHSPIN, IDC_SMOOTH_THRESH,
				0.0f, 180.0f, autoSmoothThresh, 0.1f);

			but = GetICustButton(GetDlgItem(hWnd,IDC_NORMAL_FLIPMODE));
			but->SetType(CBT_CHECK);
			but->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(but);

			eo->faceUIValid = FALSE;

			CheckDlgButton(hWnd,IDC_NORMAL_SHOW,eo->normScale>0.0f);
			if (eo->normScale>0.0f) eo->ShowNormals();
			SetupFloatSpinner(hWnd,IDC_NORMAL_SCALESPIN,IDC_NORMAL_SCALE,0.0f,999999999.0f,10.0f,0.1f);

			iCol = GetIColorSwatch(GetDlgItem(hWnd,IDC_VERT_COLOR),
				eo->GetFaceColor(), GetString(IDS_RB_VERTEXCOLOR));
			ReleaseIColorSwatch(iCol);
		} else {
			isFace = FALSE;
		}

		if (GetDlgItem (hWnd, IDC_VERT_SELRSPIN)) {	// Vertex stuff:
			isVert = TRUE;
			spin = SetupFloatSpinner (hWnd, IDC_EM_WEIGHTSPIN, IDC_EM_WEIGHT, 0.0f, 9999999.0f, 1.0f, .1f);
			spin->SetAutoScale(TRUE);
			eo->UpdateWeightDisplay (eo->ip->GetTime(), hWnd);
			SetupIntSpinner (hWnd, IDC_VERT_SELRSPIN, IDC_VERT_SELR, 0, 255, selDeltaR);
			SetupIntSpinner (hWnd, IDC_VERT_SELGSPIN, IDC_VERT_SELG, 0, 255, selDeltaG);
			SetupIntSpinner (hWnd, IDC_VERT_SELBSPIN, IDC_VERT_SELB, 0, 255, selDeltaB);
			rgb = RGB(int(selByColor.x*255.0),int(selByColor.y*255.0),int(selByColor.z*255.0));
			iCol = GetIColorSwatch (GetDlgItem(hWnd,IDC_VERT_SELCOLOR), rgb, GetString(IDS_RB_SELBYCOLOR));
			ReleaseIColorSwatch(iCol);
			iCol = GetIColorSwatch(GetDlgItem(hWnd,IDC_VERT_COLOR),
				eo->GetVertColor(), GetString(IDS_RB_VERTEXCOLOR));
			ReleaseIColorSwatch(iCol);
		} else {
			isVert = FALSE;
		}

		if (GetDlgItem (hWnd, IDC_ANGLETHRESH)) {	// Edge stuff:
			SetupFloatSpinner (hWnd, IDC_ANGLETHRESHSPIN, IDC_ANGLETHRESH,
				0.f, 180.f, autoEdgeThresh, 0.1f);
			for (i=0; i<3; i++) CheckDlgButton (hWnd, autoEdgeTypeIDs[i], (autoEdgeType == i));
		}
		break;

	case WM_DESTROY:
		eo->ShowNormals();
		break;

	case WM_PAINT:
		if (eo->faceUIValid) return FALSE;
		if (GetDlgItem (hWnd, IDC_SMOOTH_GRP1)) {
			DWORD invalid, bits;
			bits = eo->GetSelSmoothBits(invalid);
			invalid -= bits;
			DWORD mat;
			mat = eo->GetMatIndex();
			SetSmoothButtonState(hWnd,bits,invalid);
			spin = GetISpinner(GetDlgItem(hWnd,IDC_MAT_IDSPIN));
			if (mat==UNDEFINED) {
				spin->SetIndeterminate(TRUE);
			} else {
				spin->SetIndeterminate(FALSE);
				spin->SetValue (int(mat+1), FALSE);
			}
			ReleaseISpinner(spin);
		}

		if (GetDlgItem (hWnd, IDC_VERT_COLOR)) {
			iCol = GetIColorSwatch (GetDlgItem(hWnd,IDC_VERT_COLOR),
				eo->selLevel==SL_VERTEX ? eo->GetVertColor() : eo->GetFaceColor(),
				GetString(IDS_RB_VERTEXCOLOR));
			ReleaseIColorSwatch(iCol);
			eo->UpdateWeightDisplay (eo->ip->GetTime (), hWnd);
		}
		eo->faceUIValid = TRUE;
		return FALSE;

	case CC_COLOR_BUTTONDOWN:
		theHold.Begin();
		break;

	case CC_COLOR_BUTTONUP:
		if (HIWORD(wParam)) theHold.Accept (GetString(IDS_RB_SETVERTCOLOR));
		else theHold.Cancel();
		break;

	case CC_COLOR_CHANGE:
		iCol = (IColorSwatch*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_VERT_COLOR:
			if (eo->selLevel == SL_VERTEX) eo->SetVertColor (iCol->GetColor());
			else eo->SetFaceColor (iCol->GetColor());
			break;
		case IDC_VERT_SELCOLOR:
			COLORREF rgb = iCol->GetColor();
			selByColor.x = float(GetRValue(rgb))/255.0f;
			selByColor.y = float(GetGValue(rgb))/255.0f;
			selByColor.z = float(GetBValue(rgb))/255.0f;
			break;
		}
		break;

	case CC_SPINNER_BUTTONDOWN:
		switch (LOWORD(wParam)) {
		case IDC_MAT_IDSPIN:
			theHold.Begin();
			break;
		case IDC_EM_WEIGHTSPIN:
			wsr = new WeightSpinRestore (eo);
			break;
		}
		break;

	case WM_CUSTEDIT_ENTER:
	case CC_SPINNER_BUTTONUP:
		switch (LOWORD(wParam)) {
		case IDC_MAT_ID:
		case IDC_MAT_IDSPIN:
			eo->ip->RedrawViews(eo->ip->GetTime(),REDRAW_END);
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				 theHold.Accept(GetString(IDS_RB_ASSIGNMATID));
			else theHold.Cancel();
			break;

		case IDC_NORMAL_SCALE:
		case IDC_NORMAL_SCALESPIN:
			if (!IsDlgButtonChecked(hWnd,IDC_NORMAL_SHOW)) break;
			eo->ip->RedrawViews(eo->ip->GetTime(),REDRAW_END);
			break;

		case IDC_EM_WEIGHT:
		case IDC_EM_WEIGHTSPIN:
			eo->ip->RedrawViews (eo->ip->GetTime(),REDRAW_END);
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) {
				theHold.Begin ();
				if (wsr) theHold.Put (wsr);
				theHold.Accept (GetString(IDS_CHANGEWEIGHT));
			} else {
				wsr->Restore (FALSE);
				delete wsr;
			}
			wsr = NULL;
			break;
		}
		break;

	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_MAT_IDSPIN:
			if (!theHold.Holding()) theHold.Begin();
			eo->SetMatIndex(spin->GetIVal()-1);
			break;

		case IDC_NORMAL_SCALESPIN: 
			if (!IsDlgButtonChecked(hWnd,IDC_NORMAL_SHOW)) break;
			eo->normScale = spin->GetFVal();
			eo->GetMesh().displayNormals(TRUE,eo->normScale);
			eo->GetMesh().buildBoundingBox();
			eo->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
			eo->ip->RedrawViews (eo->ip->GetTime(),REDRAW_INTERACTIVE);
			break;

		case IDC_VERT_SELRSPIN: selDeltaR = spin->GetIVal(); break;
		case IDC_VERT_SELGSPIN: selDeltaG = spin->GetIVal(); break;
		case IDC_VERT_SELBSPIN: selDeltaB = spin->GetIVal(); break;
		case IDC_ANGLETHRESHSPIN: autoEdgeThresh = spin->GetFVal (); break;
		case IDC_SMOOTH_THRESHSPIN: autoSmoothThresh = spin->GetFVal (); break;

		case IDC_EM_WEIGHTSPIN:
			if (!wsr) wsr = new WeightSpinRestore (eo);
			eo->SetWeight (eo->ip->GetTime(), spin->GetFVal());
			break;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam) == 1) return FALSE;	// not handling keyboard shortcuts here.
		if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
			LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));
			int bit = iBut->IsChecked() ? 1 : 0;
			int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;
			eo->SetSelSmoothBits(bit<<shift,1<<shift);
			ReleaseICustButton(iBut);
			break;
		}
		switch (LOWORD(wParam)) {
		case IDC_EDGE_VIS: eo->ButtonOp (MopVisibleEdge); break;
		case IDC_EDGE_INVIS: eo->ButtonOp (MopInvisibleEdge); break;
		case IDC_EDGE_AUTO: eo->ButtonOp (MopAutoEdge); break;

		case IDC_AE_SETCLEAR:
			autoEdgeType = 0;
			break;

		case IDC_AE_SET:
			autoEdgeType = 1;
			break;

		case IDC_AE_CLEAR:
			autoEdgeType = 2;
			break;

		case IDC_NORMAL_SHOW:
			spin = GetISpinner(GetDlgItem(hWnd,IDC_NORMAL_SCALESPIN));
			if (IsDlgButtonChecked(hWnd,IDC_NORMAL_SHOW)) {						
				eo->normScale = spin->GetFVal();
				eo->ShowNormals();
			} else {
				eo->normScale = -1.0f;
				eo->ShowNormals();
			}
			ReleaseISpinner(spin);
			break;

		case IDC_NORMAL_FLIP: eo->ButtonOp (MopFlipNormal); break;
		case IDC_NORMAL_UNIFY: eo->ButtonOp (MopUnifyNormal); break;
		case IDC_NORMAL_FLIPMODE: eo->ToggleCommandMode (McmFlipNormalMode); break;

		case IDC_SELECT_BYID:
			if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_SELECTBYMAT),
						eo->ip->GetMAXHWnd(), SelectByMatDlgProc, (LPARAM)sbmParams)) {
				if (eo->ip) eo->SelectByMat(sbmParams[0]-1,sbmParams[1]);
			}
			break;

		case IDC_SELECTBYSMOOTH:
			sbsParams[2] = ~eo->GetUsedSmoothBits();
			if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_EM_SELECTBYSMOOTH),
						eo->ip->GetMAXHWnd(), SelectBySmoothDlgProc, (LPARAM)sbsParams)) {
				if (eo->ip) eo->SelectBySmoothGroup(sbsParams[0],(BOOL)sbsParams[1]);
			}
			break;

		case IDC_SMOOTH_CLEAR:
			eo->SetSelSmoothBits(0,0xffffffff);
			break;

		case IDC_SMOOTH_AUTO: eo->ButtonOp (MopAutoSmooth); break;

		case IDC_VERT_SELBYCOLOR:
			BOOL add, sub;
			add = GetKeyState(VK_CONTROL)<0;
			sub = GetKeyState(VK_MENU)<0;
			eo->SelectVertByColor (selByColor,selDeltaR,selDeltaG,selDeltaB,add,sub);
			break;
		}
		break;

	default:
		return FALSE;
	}

	return TRUE;
}

//
// Customizable Shortcuts for Edit and Editable Mesh, the MeshDelta users:
//

static ShortcutDescription spShortcuts[] = {
	ID_EM_SELTYPE, IDS_EM_SWITCH_SUBLEVELS,
	ID_EM_SELTYPE_BACK, IDS_EM_PREV_SUBLEVEL,
	ID_EM_SELTYPE_VERTEX, IDS_EM_GOTO_VERTEX,
	ID_EM_SELTYPE_EDGE, IDS_EM_GOTO_EDGE,
	ID_EM_SELTYPE_FACE, IDS_EM_GOTO_FACE,
	ID_EM_SELTYPE_POLYGON, IDS_EM_GOTO_POLYGON,
	ID_EM_SELTYPE_ELEMENT, IDS_EM_GOTO_ELEMENT,
	ID_EM_SELTYPE_OBJ, IDS_EM_GOTO_OBJECT,
	ID_EM_AUTOSMOOTH, IDS_RB_AUTOSMOOTH,
	ID_EM_ATTACH, IDS_EM_ATTACH_MODE,
	ID_EM_BREAK, IDS_RB_BREAKVERTS,
	ID_EM_IGBACK, IDS_EM_IGNORE_BACK,
	ID_EM_BEVEL, IDS_EM_BEVEL_MODE,
	ID_EM_CREATE, IDS_EM_CREATE_MODE,
	ID_EM_CUT, IDS_EM_CUT_MODE,
	ID_EM_DIVIDE, IDS_EM_DIVIDE_MODE,
	ID_EM_EXTRUDE, IDS_EM_EXTRUDE_MODE,
	ID_EM_FLIPNORM, IDS_RB_FLIPNORMALS,
	ID_EM_SS_BACKFACE, IDS_EM_SS_BACKFACE,
	ID_EM_UNIFY_NORMALS, IDS_EM_UNIFY,
	ID_EM_HIDE, IDS_EM_HIDE_SELECTED,
	ID_EM_EDGE_INVIS, IDS_RB_EDGEINVISIBLE,
	ID_EM_IGNORE_INVIS, IDS_EM_IGNORE_VISEDGE,
	ID_EM_COLLAPSE, IDS_RB_COLLAPSE,
	ID_EM_SHOWNORMAL, IDS_EM_SHOW_NORMALS,
	ID_EM_SELOPEN, IDS_RB_SELOPENEDGES,
	ID_EM_REMOVE_ISO, IDS_RB_DELETEISO,
	ID_EM_SLICEPLANE, IDS_EM_SLICEPLANE,
	ID_EM_SOFTSEL, IDS_AFFECT_REGION,
	ID_EM_SLICE, IDS_SCA_SLICE,
	ID_EM_DETACH, IDS_DETACH,
	ID_EM_TURNEDGE, IDS_RB_EDGETURN,
	ID_EM_UNHIDE, IDS_RB_UNHIDEALLFACES,
	ID_EM_EDGE_VIS, IDS_RB_EDGEVISIBLE,
	ID_EM_SELBYVERT, IDS_EM_SELBYVERT,
	ID_EM_AUTOEDGE, IDS_RB_AUTOEDGE,
	ID_EM_WELD, IDS_EM_WELD_SEL,
	ID_EM_EXPLODE, IDS_RB_EXPLODE,
};
#define NUM_SHORTCUTS 38

static int shortCutIDsInSDK[] = {
	MDUID_EM_SELTYPE,
	MDUID_EM_SELTYPE_BACK,
	MDUID_EM_SELTYPE_VERTEX,
	MDUID_EM_SELTYPE_EDGE,
	MDUID_EM_SELTYPE_FACE,
	MDUID_EM_SELTYPE_POLYGON,
	MDUID_EM_SELTYPE_ELEMENT,
	MDUID_EM_SELTYPE_OBJ,
	MDUID_EM_AUTOSMOOTH,
	MDUID_EM_ATTACH,
	MDUID_EM_BREAK,
	MDUID_EM_IGBACK,
	MDUID_EM_BEVEL,
	MDUID_EM_CREATE,
	MDUID_EM_CUT,
	MDUID_EM_DIVIDE,
	MDUID_EM_EXTRUDE,
	MDUID_EM_FLIPNORM,
	MDUID_EM_SS_BACKFACE,
	MDUID_EM_UNIFY_NORMALS,
	MDUID_EM_HIDE,
	MDUID_EM_EDGE_INVIS,
	MDUID_EM_IGNORE_INVIS,
	MDUID_EM_COLLAPSE,
	MDUID_EM_SHOWNORMAL,
	MDUID_EM_SELOPEN,
	MDUID_EM_REMOVE_ISO,
	MDUID_EM_SLICEPLANE,
	MDUID_EM_SOFTSEL,
	MDUID_EM_SLICE,
	MDUID_EM_DETACH,
	MDUID_EM_TURNEDGE,
	MDUID_EM_UNHIDE,
	MDUID_EM_EDGE_VIS,
	MDUID_EM_SELBYVERT,
	MDUID_EM_AUTOEDGE,
	MDUID_EM_WELD,
	MDUID_EM_EXPLODE,
};

// Following should only be called once.
ShortcutTable* GetEMeshShortcuts()
{
#ifdef _DEBUG
	int i;
	for (i=0; i<NUM_SHORTCUTS; i++) {
		if (shortCutIDsInSDK[i] != spShortcuts[i].mCmdID) break;
	}
	if (i<NUM_SHORTCUTS) {
		DebugPrint ("EMesh: Please match SDK shortcut ID's with the resource ID's in Editable Mesh.\n");
		DbgAssert(0);
	}
#endif
	TSTR name = GetString(IDS_EMESH);
	HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE (IDR_ACCELERATORS));
	ShortcutTable* pTab;
	pTab = new ShortcutTable (kEMeshShortcuts, name, hAccel, NUM_SHORTCUTS, spShortcuts, hInstance);
	return pTab;
}

// Following should be _identical_ to that in edmui.cpp; the whole class should be in some core location.
// -sca/1999.03.12
BOOL EMeshShortcutCB::KeyboardShortcut (int id) {
	if (!em) return FALSE;
	if (!em->Editing()) return FALSE;
	int val;

	switch (id) {
	case MDUID_EM_SELTYPE:
		int type;
		switch (em->GetEMeshSelLevel()) {
			case EM_SL_FACE:  type = EM_SL_POLYGON;    break;
			case EM_SL_POLYGON:   type = EM_SL_ELEMENT; break;
			case EM_SL_ELEMENT: type = EM_SL_OBJECT;  break;
			case EM_SL_OBJECT: type = EM_SL_VERTEX; break;
			case EM_SL_VERTEX: type = EM_SL_EDGE; break;
			case EM_SL_EDGE: type = EM_SL_FACE; break;
		}
		em->SetEMeshSelLevel (type);
		break;

	case MDUID_EM_SELTYPE_BACK:
		switch (em->GetEMeshSelLevel()) {
			case EM_SL_FACE:  type = EM_SL_EDGE;    break;
			case EM_SL_POLYGON:   type = EM_SL_FACE; break;
			case EM_SL_ELEMENT: type = EM_SL_POLYGON;  break;
			case EM_SL_VERTEX: type = EM_SL_OBJECT; break;
			case EM_SL_OBJECT: type = EM_SL_ELEMENT; break;
			case EM_SL_EDGE: type = EM_SL_VERTEX; break;
		}
		em->SetEMeshSelLevel (type);
		break;

	case MDUID_EM_SELTYPE_VERTEX:
		em->SetEMeshSelLevel (EM_SL_VERTEX);
		break;

	case MDUID_EM_SELTYPE_EDGE:
		em->SetEMeshSelLevel (EM_SL_EDGE);
		break;

	case MDUID_EM_SELTYPE_FACE:
		em->SetEMeshSelLevel (EM_SL_FACE);
		break;

	case MDUID_EM_SELTYPE_POLYGON:
		em->SetEMeshSelLevel (EM_SL_POLYGON);
		break;

	case MDUID_EM_SELTYPE_ELEMENT:
		em->SetEMeshSelLevel (EM_SL_ELEMENT);
		break;

	case MDUID_EM_SELTYPE_OBJ:
		em->SetEMeshSelLevel (EM_SL_OBJECT);
		break;

	case MDUID_EM_AUTOSMOOTH:
		em->ButtonOp (MopAutoSmooth);
		break;

	case MDUID_EM_ATTACH:
		em->ToggleCommandMode (McmAttach);
		break;

	case MDUID_EM_BREAK:
		em->ButtonOp (MopBreak);
		break;

	case MDUID_EM_IGBACK:
		em->GetUIParam (MuiIgBack, val);
		em->SetUIParam (MuiIgBack, !val);
		break;

	case MDUID_EM_BEVEL:
		if (em->GetEMeshSelLevel() >= EM_SL_FACE) em->ToggleCommandMode (McmBevel);
		else em->ToggleCommandMode (McmChamfer);
		break;

	case MDUID_EM_CREATE:
		em->ToggleCommandMode (McmCreate);
		break;

	case MDUID_EM_CUT:
		em->ToggleCommandMode (McmCut);
		break;

	case MDUID_EM_DIVIDE:
		em->ToggleCommandMode (McmDivide);
		break;

	case MDUID_EM_EXTRUDE:
		em->ToggleCommandMode (McmExtrude);
		break;

	case MDUID_EM_FLIPNORM:
		em->ButtonOp (MopFlipNormal);
		break;

	case MDUID_EM_SS_BACKFACE:
		em->GetUIParam (MuiSSBack, val);
		em->SetUIParam (MuiSSBack, !val);
		break;

	case MDUID_EM_UNIFY_NORMALS:
		em->ButtonOp (MopUnifyNormal);
		break;

	case MDUID_EM_HIDE:
		em->ButtonOp (MopHide);
		break;

	case MDUID_EM_EDGE_INVIS:
		em->ButtonOp (MopInvisibleEdge);
		break;

	case MDUID_EM_IGNORE_INVIS:
		em->GetUIParam (MuiIgnoreVis, val);
		em->SetUIParam (MuiIgnoreVis, !val);
		break;

	case MDUID_EM_COLLAPSE:
		em->ButtonOp (MopCollapse);
		break;

	case MDUID_EM_SHOWNORMAL:
		em->ButtonOp (MopShowNormal);
		break;

	case MDUID_EM_SELOPEN:
		em->ButtonOp (MopSelectOpenEdges);
		break;

	case MDUID_EM_REMOVE_ISO:
		em->ButtonOp (MopRemoveIsolatedVerts);
		break;

	case MDUID_EM_SLICEPLANE:
		em->ToggleCommandMode (McmSlicePlane);
		break;

	case MDUID_EM_SOFTSEL:
		em->GetUIParam (MuiSoftSel, val);
		em->SetUIParam (MuiSoftSel, !val);
		break;

	case MDUID_EM_SLICE:
		em->ButtonOp (MopSlice);
		break;

	case MDUID_EM_DETACH:
		em->ButtonOp (MopDetach);
		break;

	case MDUID_EM_TURNEDGE:
		em->ToggleCommandMode (McmTurnEdge);
		break;

	case MDUID_EM_UNHIDE:
		em->ButtonOp (MopUnhideAll);
		break;

	case MDUID_EM_EDGE_VIS:
		em->ButtonOp (MopVisibleEdge);
		break;

	case MDUID_EM_SELBYVERT:
		em->GetUIParam (MuiSelByVert, val);
		em->SetUIParam (MuiSelByVert, !val);
		break;

	case MDUID_EM_AUTOEDGE:
		em->ButtonOp (MopAutoEdge);
		break;

	case MDUID_EM_WELD:
		em->ButtonOp (MopWeld);
		break;

	case MDUID_EM_EXPLODE:
		em->ButtonOp (MopExplode);
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

//---------------------------------------------------------
//  MeshDeltaUser UI-related methods

void EditTriObject::GetUIParam (meshUIParam uiCode, float & ret) {
	if (!ip) return;
	if (!Editing()) return;

	switch (uiCode) {
	case MuiPolyThresh:
		ret = planarFaceThresh;
		break;
	case MuiFalloff:
		ret = falloff;
		break;
	case MuiPinch:
		ret = pinch;
		break;
	case MuiBubble:
		ret = bubble;
		break;
	case MuiWeldDist:
		ret = weldThresh;
		break;
	}
}

void EditTriObject::SetUIParam (meshUIParam uiCode, float val) {
	if (!ip) return;
	if (!Editing()) return;
	ISpinnerControl *spin;

	switch (uiCode) {
	case MuiPolyThresh:
		planarFaceThresh = val;
		if (hSel) {
			spin = GetISpinner (GetDlgItem (hSel, IDC_PLANARSPINNER));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiFalloff:
		falloff = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_FALLOFFSPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiPinch:
		pinch = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_PINCHSPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiBubble:
		bubble = val;
		InvalidateAffectRegion ();
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_BUBBLESPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiWeldDist:
		weldThresh = val;
		if (hGeom) {
			spin = GetISpinner (GetDlgItem (hGeom, IDC_W_THR_SPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	}
}

void EditTriObject::GetUIParam (meshUIParam uiCode, int & ret) {
	if (!ip) return;
	if (!Editing()) return;

	switch (uiCode) {
	case MuiSelByVert:
		ret = selByVert;
		break;
	case MuiIgBack:
		ret = ignoreBackfaces;
		break;
	case MuiIgnoreVis:
		ret = ignoreVisEdge;
		break;
	case MuiSoftSel:
		ret = affectRegion;
		break;
	case MuiSSUseEDist:
		ret = useEdgeDist;
		break;
	case MuiSSEDist:
		ret = edgeIts;
		break;
	case MuiSSBack:
		ret = arIgBack;
		break;
	case MuiWeldBoxSize:
		ret = weldBoxSize;
		break;
	case MuiExtrudeType:
		ret = extType;
		break;
	}
}

void EditTriObject::SetUIParam (meshUIParam uiCode, int val) {
	if (!ip) return;
	if (!Editing()) return;
	ISpinnerControl *spin;

	switch (uiCode) {
	case MuiSelByVert:
		selByVert = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_SEL_BYVERT, selByVert);
		break;
	case MuiIgBack:
		ignoreBackfaces = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_IGNORE_BACKFACES, ignoreBackfaces);
		break;
	case MuiIgnoreVis:
		ignoreVisEdge = val ? TRUE : FALSE;
		if (hSel) CheckDlgButton (hSel, IDC_IGNORE_VISEDGE, ignoreVisEdge);
		break;
	case MuiSoftSel:
		affectRegion = val ? TRUE : FALSE;
		if (hAR) {
			CheckDlgButton (hAR, IDC_AFFECT_REGION, affectRegion);
			SetARDlgEnables ();
		}
		break;
	case MuiSSUseEDist:
		useEdgeDist = val ? TRUE : FALSE;
		if (hAR) {
			CheckDlgButton (hAR, IDC_E_DIST, useEdgeDist);
			spin = GetISpinner (GetDlgItem (hAR, IDC_E_ITER_SPIN));
			spin->Enable (useEdgeDist);
			ReleaseISpinner (spin);
		}
		break;
	case MuiSSEDist:
		edgeIts = val;
		if (hAR) {
			spin = GetISpinner (GetDlgItem (hAR, IDC_E_ITER_SPIN));
			spin->SetValue (edgeIts, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiSSBack:
		arIgBack = val ? TRUE : FALSE;
		if (hAR) CheckDlgButton (hAR, IDC_AR_BACK, arIgBack);
		break;
	case MuiWeldBoxSize:
		weldBoxSize = val;
		if (hGeom) {
			spin = GetISpinner (GetDlgItem (hGeom, IDC_T_THR_SPIN));
			spin->SetValue (val, FALSE);
			ReleaseISpinner (spin);
		}
		break;
	case MuiExtrudeType:
		extType = val;
		if (hGeom) {
			if (extType == MESH_EXTRUDE_CLUSTER) {
				CheckRadioButton (hGeom, IDC_EXTYPE_A, IDC_EXTYPE_B, IDC_EXTYPE_A);
			} else {
				CheckRadioButton (hGeom, IDC_EXTYPE_A, IDC_EXTYPE_B, IDC_EXTYPE_B);
			}
		}
		break;
	}
}

void EditTriObject::ToggleCommandMode(meshCommandMode mode) {
	if (!ip) return;
	if (sliceMode && (mode != McmSlicePlane)) ExitSliceMode ();

	switch (mode) {
	case McmCreate:
		switch (selLevel) {
		case SL_EDGE:
		case SL_OBJECT:
			break;
		case SL_VERTEX:
			if (ip->GetCommandMode()==createVertMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode(createVertMode);
			break;
		default:
			if (ip->GetCommandMode()==createFaceMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (createFaceMode);
			break;
		}
		break;

	case McmAttach:
		ip->SetPickMode (attachPickMode);
		break;

	case McmExtrude:
		if (selLevel < SL_EDGE) break;
		if (ip->GetCommandMode()==extrudeMode) ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode (extrudeMode);
		break;

	case McmBevel:
		if (selLevel < SL_FACE) break;
		if (ip->GetCommandMode()==bevelMode)
			ip->SetStdCommandMode (CID_OBJMOVE);
		else ip->SetCommandMode (bevelMode);
		break;

	case McmChamfer:
		if ((selLevel == SL_OBJECT) || (selLevel > SL_EDGE)) break;
		if (ip->GetCommandMode()==chamferMode)
			ip->SetStdCommandMode (CID_OBJMOVE);
		else ip->SetCommandMode (chamferMode);
		break;

	case McmSlicePlane:
		if (!selLevel) break;
		if (sliceMode) ExitSliceMode();
		else EnterSliceMode ();
		break;

	case McmCut:
		if (selLevel < SL_EDGE) break;
		if (ip->GetCommandMode()==cutEdgeMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(cutEdgeMode);
		break;

	case McmWeldTarget:
		if (selLevel != SL_VERTEX) break;
		if (ip->GetCommandMode()==weldVertMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(weldVertMode);
		break;

	case McmFlipNormalMode:
		if (selLevel < SL_FACE) break;
		if (ip->GetCommandMode()==flipMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode(flipMode);
		break;

	case McmDivide:
		if (selLevel < SL_EDGE) break;
		if (selLevel == SL_EDGE) {
			if (ip->GetCommandMode()==divideEdgeMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (divideEdgeMode);
		} else {
			if (ip->GetCommandMode()==divideFaceMode)
				ip->SetStdCommandMode(CID_OBJMOVE);
			else ip->SetCommandMode (divideFaceMode);
		}
		break;

	case McmTurnEdge:
		if (selLevel != SL_EDGE) break;
		if (ip->GetCommandMode()==turnEdgeMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		else ip->SetCommandMode (turnEdgeMode);
		break;
	}
}

void EditTriObject::ButtonOp(meshButtonOp opcode) {
	ISpinnerControl *spin;
	TSTR name;

	switch (opcode) {
	case MopHide:
		if (selLevel == SL_VERTEX) HideSelectedVerts ();
		else if (selLevel >= SL_FACE) HideSelectedFaces ();
		break;

	case MopUnhideAll:
		if (selLevel == SL_VERTEX) UnhideAllVerts();
		else if (selLevel >= SL_FACE) UnhideAllFaces ();
		break;

	case MopDelete:
		DeleteSelected ();
		break;

	case MopDetach:
		if (!hGeom || !editObj || !ip) break;
		if (selLevel == SL_VERTEX) {
			BOOL elem, asClone;
			TSTR name;
			if (GetDetachObjectName (ip, name, elem, asClone)) {
				Detach (name, FALSE, !asClone, elem);
			}
		}
		if (selLevel >= SL_FACE) {
			BOOL elem, asClone;
			TSTR name;
			if (GetDetachObjectName (ip, name, elem, asClone)) {
				Detach (name, TRUE, !asClone, elem);
			}
		}
		break;

	case MopBreak:
		BreakVerts ();
		break;

	case MopViewAlign:
		AlignTo(ALIGN_VIEW);
		break;

	case MopGridAlign:
		AlignTo(ALIGN_CONST);
		break;

	case MopMakePlanar:
		if (selLevel > SL_OBJECT) MakePlanar ();
		break;

	case MopCollapse:
		if (selLevel > SL_OBJECT) Collapse ();
		break;

	case MopTessellate:
		if (selLevel > SL_EDGE) Tessellate (tessTens/400.0f, edgeTes);
		break;

	case MopExplode:
		if ((selLevel > SL_EDGE) || (selLevel == SL_OBJECT)) {
			if (expObj) {
				name = GetString(IDS_SCA_BASEMESH);
				if (GetExplodeObjectName (ip->GetMAXHWnd(), name)) {
					Explode (DegToRad(explodeThresh), TRUE, name);
				}
			} else {
				Explode (DegToRad (explodeThresh), FALSE, name);
			}
		}
		break;

	case MopSlice:
		if (sliceMode && selLevel) Slice ();
		break;

	case MopWeld:
		if (selLevel == SL_VERTEX) {
			if (!WeldVerts(weldThresh)) {
				TSTR buf1 = GetString(IDS_RB_NOVERTSTOWELD);
				TSTR buf2 = GetString(IDS_RB_WELDVERTS);
				MessageBox (ip->GetMAXHWnd(), buf1, buf2, MB_OK|MB_TASKMODAL);
			}
		}
		break;

	case MopRemoveIsolatedVerts:
		RemoveIsoVerts ();
		break;

	case MopSelectOpenEdges:
		if (selLevel == SL_EDGE) SelectOpenEdges ();
		break;

	case MopCreateShapeFromEdges:
		if (selLevel != SL_EDGE) break;
		if (!GetMesh().edgeSel.NumberSet()) {
			TSTR buf1 = GetString(IDS_RB_CREATECURVE);
			TSTR buf2 = GetString(IDS_RB_NOEDGESSELECTED);
			MessageBox (ip->GetMAXHWnd(),buf2,buf1,MB_ICONEXCLAMATION|MB_OK);
			break;
		}
		name = GetString(IDS_RB_SHAPE);
		ip->MakeNameUnique(name);
		if (DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_CREATECURVE),
			ip->GetMAXHWnd(), CurveNameDlgProc, (LPARAM)&name)) {
			ModContextList mcList;
			INodeTab nodes;
			ip->GetModContexts (mcList, nodes);
			AdjEdgeList *ae = TempData()->AdjEList();
			theHold.Begin();
			CreateCurveFromMeshEdges (GetMesh(), nodes[0], ip, ae, name,
				(createCurveType==IDC_CURVE_SMOOTH), curveIgnoreHiddenEdges);
			theHold.Accept (GetString(IDS_RB_CREATECURVE));
			nodes.DisposeTemporary();
		}
		break;

	case MopShowNormal:
		if (!hSurf) break;
		spin = GetISpinner(GetDlgItem(hSurf,IDC_NORMAL_SCALESPIN));
		if (!spin) break;
		if (IsDlgButtonChecked(hSurf, IDC_NORMAL_SHOW)) {
			normScale = -1.0f;
			ShowNormals();
			CheckDlgButton (hSurf, IDC_NORMAL_SHOW, FALSE);
		} else {
			normScale = spin->GetFVal();
			ShowNormals();
			CheckDlgButton (hSurf, IDC_NORMAL_SHOW, TRUE);
		}
		ReleaseISpinner(spin);
		break;

	case MopFlipNormal:
		if (selLevel > SL_EDGE) FlipNormals ();
		break;

	case MopUnifyNormal:
		if (selLevel > SL_EDGE) UnifyNormals ();
		break;

	case MopAutoSmooth:
		if (selLevel > SL_EDGE) AutoSmooth (DegToRad (autoSmoothThresh));
		break;

	case MopVisibleEdge:
		if (selLevel == SL_EDGE) SetEdgeVis (TRUE);
		break;

	case MopInvisibleEdge:
		if (selLevel == SL_EDGE) SetEdgeVis (FALSE);
		break;

	case MopAutoEdge:
		if (selLevel == SL_EDGE) AutoEdge (DegToRad (autoEdgeThresh), autoEdgeType);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\kernelhdr.cpp ===
////////////////////////////////////////////////////////////////
//	precompiled header for prefilter kernels
//
#include	"kernelhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\triobjed.h ===
/**********************************************************************
 *<
	FILE: triobjed.h

	DESCRIPTION:   Editable Triangle Mesh Object

	CREATED BY: Rolf Berteig

	HISTORY: created 4 March 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __TRIOBJED__
#define __TRIOBJED__

#include "sbmtlapi.h"
#include "MeshDLib.h"
#include "istdplug.h"
#include "nsclip.h"
#include "KbdShortcut.h"

#define DEF_FALLOFF 20.0f

// Available selection levels
#define SL_OBJECT EM_SL_OBJECT  //0
#define SL_VERTEX EM_SL_VERTEX	//1
#define SL_EDGE EM_SL_EDGE	//2
#define SL_FACE EM_SL_FACE	//3
#define SL_POLY EM_SL_POLYGON	//4
#define SL_ELEMENT EM_SL_ELEMENT	//5

// Converts editable mesh selection levels to mesh ones.
static DWORD meshSelLevel[] = { MESH_OBJECT, MESH_VERTEX, MESH_EDGE, MESH_FACE, MESH_FACE, MESH_FACE };

#define DEF_PICKBOX_SIZE	4

// ID's for toolbar
#define IDC_SELVERTEX	0x4015
#define IDC_SELEDGE	0x4016
#define IDC_SELFACE	0x4017
#define IDC_SELPOLY		0x4018
#define IDC_SELELEMENT	0x4019

// Alignment types:
#define ALIGN_CONST	0
#define ALIGN_VIEW	1

class WeldVertCMode;
class CreateVertCMode;
class CreateFaceCMode;
class DivideEdgeCMode;
class TurnEdgeCMode;
class AttachPickMode;
class ExtrudeCMode;
class BevelCMode;
class ChamferCMode;
class FlipNormCMode;
class CutEdgeCMode;
class DivideFaceCMode;

#define CID_EXTRUDE		CID_USER + 972
#define CID_CREATEVERT	CID_USER + 973
#define CID_OBJATTACH  CID_USER + 974
#define CID_BUILDFACE	CID_USER + 975
#define CID_DIVIDEEDGE	CID_USER + 976
#define CID_TURNEDGE	CID_USER + 977
#define CID_WELDVERT	CID_USER + 978
#define CID_DIVIDEFACE CID_USER + 979
#define CID_CUTEDGE    CID_USER + 980
#define CID_FLIPNORM	CID_USER + 981
#define CID_BEVEL    CID_USER + 982
#define CID_MCHAMFER CID_USER + 983	// "Mesh Chamfer" -- CID_CHAMFER was taken.

#define MAX_MATID	0xffff

// Named selection set levels:
#define NS_VERTEX 0
#define NS_EDGE 1
#define NS_FACE 2
// Conversion from selLevel to named selection level:
static int namedSetLevel[] = { NS_VERTEX, NS_VERTEX, NS_EDGE, NS_FACE, NS_FACE, NS_FACE };
static int namedClipLevel[] = { CLIP_VERT, CLIP_VERT, CLIP_EDGE, CLIP_FACE, CLIP_FACE, CLIP_FACE };

// Flags:
// (Unlike Edit Mesh, all etFlags are permanent - no temporary ones - however we still start at 0x0100.)
// Disp Result keeps track of "Show End Result" button for this Editable Mesh.
#define ET_DISP_RESULT 0x0100

// References:
#define ET_MASTER_CONTROL_REF  0
#define ET_VERT_BASE_REF 1

class EMeshShortcutCB;
class TempMoveRestore;

class EditTriObject : public TriObject, public EventUser, public ISubMtlAPI, public IMeshSelect,
								public IMeshSelectData, public MeshDeltaUser, public MeshDeltaUserData,
								public AttachMatDlgUser {
	// Load reference version
	int loadRefVersion;
public:
	// Class vars
	// Window handles & an interface:
	static HWND hSel, hAR, hGeom, hSurf, hApprox;
	static Interface *ip;
	static EditTriObject *editObj;

	// Command modes
	static MoveModBoxCMode *moveMode;
	static RotateModBoxCMode *rotMode;
	static UScaleModBoxCMode *uscaleMode;
	static NUScaleModBoxCMode *nuscaleMode;
	static SquashModBoxCMode *squashMode;
	static SelectModBoxCMode *selectMode;
	static WeldVertCMode *weldVertMode;
	static CreateVertCMode *createVertMode;
	static CreateFaceCMode* createFaceMode;
	static TurnEdgeCMode* turnEdgeMode;
	static DivideEdgeCMode* divideEdgeMode;
	static DivideFaceCMode *divideFaceMode;
	static AttachPickMode* attachPickMode;
	static ExtrudeCMode* extrudeMode;
	static BevelCMode* bevelMode;
	static ChamferCMode *chamferMode;
	static FlipNormCMode* flipMode;
	static CutEdgeCMode * cutEdgeMode;

	static float normScale;
	static BOOL selByVert, ignoreBackfaces;
	static BOOL inBuildFace, inCutEdge;
	static BOOL faceUIValid;
	static BOOL inExtrude, inBevel, inChamfer;
	static int extType;
	static BOOL ignoreVisEdge;
	static BOOL rsSel, rsAR, rsGeom, rsSurf, rsApprox;	// Rollup States (FALSE=Rolled-up.)
	static int pickBoxSize;
	static int weldBoxSize;
	static int attachMat;
	static BOOL condenseMat;
	static bool sliceMode, sliceSplit, cutRefine;
	static Quat sliceRot;
	static Point3 sliceCenter;
	static float sliceSize;

	// Cache for computing coord. systems
	// methods in tridata.cpp
	MeshTempData *tempData;
	MeshTempData *TempData ();
	void InvalidateTempData (PartID parts=PART_TOPO|PART_GEOM);

	static TempMoveRestore *tempMove;

	GenericNamedSelSetList selSet[3];
	MasterPointControl	*masterCont;		// Master track controller
	Tab<Control*> cont;
	int selLevel;
	float falloff, pinch, bubble;
	int affectRegion, arIgBack, useEdgeDist, edgeIts;
	Interval arValid;
	DWORD etFlags;

	EditTriObject();
	~EditTriObject();	// CCJ 3/9/99

	// Flag methods.
	void SetFlag (DWORD fl, BOOL val=TRUE) { if (val) etFlags |= fl; else etFlags &= ~fl; }
	void ClearFlag (DWORD fl) { etFlags &= (~fl); }
	bool GetFlag (DWORD fl) { return (etFlags&fl) ? TRUE : FALSE; }

	// Temp (drag) move methods:
	void DragMoveInit ();
	void DragMoveRestore ();
	void DragMove (MeshDelta & md, MeshDeltaUser *mdu);
	void DragMoveAccept (TimeValue t);
	void DragMoveClear ();

	// Animatable methods
	void DeleteThis() {delete this;}
	Class_ID ClassID() {return Class_ID(EDITTRIOBJ_CLASS_ID,0);}
	void GetClassName(TSTR& s) {s = GetString(IDS_SCA_BASE_MESH);}
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
	int NumSubs() { return 1; }		// only the master.
	Animatable* SubAnim(int i) { return GetReference(i); }
	TSTR SubAnimName(int i);
	BOOL AssignController(Animatable *control,int subAnim);
	int SubNumToRefNum(int subNum) {return subNum;}
	BOOL SelectSubAnim(int subNum);

	// Reference methods
	int RemapRefOnLoad(int iref);
	int NumRefs() {return 1+cont.Count();}
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	void CreateContArray();
	void SynchContArray(int newNV);
	void AllocContArray(int count);
	void ReplaceContArray(Tab<Control *> &nc);
	//BOOL BypassTreeView();
	void DeletePointConts(BitArray &set);
	void PlugControllersSel(TimeValue t,BitArray &set);
	BOOL PlugControl(TimeValue t,int i);
	void SetPtCont(int i, Control *c);
	void SetPointAnim(TimeValue t, int i, Point3 pt);
	BOOL CloneVertCont(int from, int to);
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);

	// BaseObject methods
	ObjectState Eval(TimeValue time);
	//Object versions:
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	void GetWorldBoundBox (TimeValue t, INode * inode, ViewExp* vp, Box3& box);
	// Gizmo versions:
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc);
	void GetWorldBoundBox (TimeValue t, INode * inode, ViewExp* vp, Box3& box, ModContext *mc);

	void GetLocalBoundBox (TimeValue t, INode* inode, ViewExp* vp, Box3& box);
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
	void SelectSubComponent (HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
	void ClearSelection (int selLevel);
	void SelectAll (int selLevel);
	void InvertSelection (int selLevel);
	void InvalidateDistances ();
	void InvalidateAffectRegion ();
	void ActivateSubobjSel (int level, XFormModes& modes );		
	void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);		
	void ShowEndResultChanged (BOOL showEndResult);

	// Object methods		
	TCHAR *GetObjectName() { return GetString(IDS_SCA_BASE_MESH);}
	BOOL IsSubClassOf(Class_ID classID);

	// Named subobject selections:
	BOOL SupportsNamedSubSels() {return TRUE;}
	void ActivateSubSelSet(TSTR &setName);
	void NewSetFromCurSel(TSTR &setName);
	void RemoveSubSelSet(TSTR &setName);
	void SetupNamedSelDropDown();
	void UpdateNamedSelDropDown ();
	int NumNamedSelSets();
	TSTR GetNamedSelSetName(int i);
	void SetNamedSelSetName(int i,TSTR &newName);
	void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
	void NSCopy ();
	void NSPaste ();
	BOOL GetUniqueSetName(TSTR &name);
	int SelectNamedSet();
	void IncreaseNamedSetSize (int nsl, int oldsize, int increase);
	void DeleteNamedSetArray (int nsl, BitArray & del);

	// Reference methods
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	IOResult Load(ILoad *iload);
	IOResult Save(ISave *isave);

	// Local methods
	void ExitAllCommandModes (bool exSlice=TRUE);
	GenericNamedSelSetList &GetSelSet();
	int GetSubobjectLevel();
	void SetSubobjectLevel(int level);
	void RefreshSelType ();

	// Operations -- in triops.cpp
	// Shift-cloning:
	void CloneSelSubComponents(TimeValue t);
	void AcceptCloneSelSubComponents(TimeValue t);
	// Transform stuff:
	void Transform(TimeValue t, Matrix3& partm, Matrix3 tmAxis, BOOL localOrigin, Matrix3 xfrm, int type);
	void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
	void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
	void TransformStart(TimeValue t);
	void TransformHoldingFinish (TimeValue t);
	void TransformFinish(TimeValue t);
	void TransformCancel(TimeValue t);

	// Selection panel operations:
	void HideSelectedVerts();
	void UnhideAllVerts();
	void HideSelectedFaces();
	void UnhideAllFaces();

	// Topological & Geometric ops from the Edit Geometry panel:
	DWORD CreateVertex(Point3 pt);
	bool CreateFace(int *v, int deg);
	void DeleteSelected();
	
	// from AttachMatDlgUser
	int GetAttachMat() { return attachMat; }
	void SetAttachMat(int value) { attachMat = value; }
	BOOL GetCondenseMat() { return condenseMat; }
	void SetCondenseMat(BOOL sw) { condenseMat = sw; }

	void Attach (INode *node, bool & canUndo);
	void MultiAttach (INodeTab &nodeTab);
	void Detach (TSTR &name,BOOL doFaces,BOOL del=TRUE,BOOL elem=FALSE);
	void BreakVerts();
	void DoExtrusion();
	void BeginExtrude (TimeValue t);
	void EndExtrude (TimeValue t,BOOL accept);
	void Extrude (TimeValue t, float amount);
	void BeginBevel (TimeValue t, BOOL doExtrude=FALSE);
	void EndBevel (TimeValue t,BOOL accept);
	void Bevel (TimeValue t, float outline, float height=0);
	void DoChamfer();
	void BeginChamfer (TimeValue t);
	void EndChamfer (TimeValue t,BOOL accept);
	void Chamfer (TimeValue t, float amount);
	void AlignTo (int alignType);
	void MakePlanar ();
	void Collapse ();
	void Tessellate (float tens,BOOL edge);
	void Explode (float thresh, BOOL objs, TSTR &name);
	void Slice ();
	BOOL WeldVerts(float thresh);
	void WeldVerts(Point3 pt);
	void RemoveIsoVerts();
	void SelectOpenEdges();

	// Vertex Surface operations:
	float GetWeight (TimeValue t, int *numSel=NULL);
	void UpdateWeightDisplay (TimeValue t, HWND hWnd);
	void SetWeight (TimeValue t, float w);
	void ResetWeights (TimeValue t);
	Color GetVertColor ();
	void SetVertColor (Color clr);
	void SelectVertByColor (VertColor clr, int deltaR, int deltaG, int deltaB, BOOL add, BOOL sub);

	// Edge Surface operations:
	void SetEdgeVis (BOOL vis);
	void AutoEdge (float thresh, int type);

	// Face Surface operations:
	void ShowNormals ();
	void FlipNormals ();
	void UnifyNormals ();
	DWORD GetMatIndex ();
	void SetMatIndex (DWORD index);
	void SelectByMat (DWORD index,BOOL clear);
	DWORD GetUsedSmoothBits();
	DWORD GetSelSmoothBits(DWORD &some);
	void SetSelSmoothBits (DWORD bits, DWORD mask);		
	void SelectBySmoothGroup (DWORD bits, BOOL clear);
	void AutoSmooth(float thresh);
	Color GetFaceColor ();
	void SetFaceColor (Color clr);

	// Psuedo-command-mode, mixed in with real ones in triops.cpp:
	void EnterSliceMode ();
	void ExitSliceMode ();

	// UI code -- triedui.cpp
	void UpdateSurfType ();
	void SetSelDlgEnables(), SetGeomDlgEnables(), SetARDlgEnables();
	float GetPolyFaceThresh();
	void InvalidateSurfaceUI();
	void InvalidateNumberSelected ();
	void SetNumSelLabel();
	BOOL SplitSharedVertCol();

	// UI code in approxui.cpp:
	void UpdateApproxUI ();

	// IMeshSelect methods:
	DWORD GetSelLevel();
	void SetSelLevel(DWORD level);
	void LocalDataChanged();

	// IMeshSelectData methods:
	BitArray GetVertSel() { return GetMesh().vertSel; }
	BitArray GetFaceSel() { return GetMesh().faceSel; }
	BitArray GetEdgeSel() { return GetMesh().edgeSel; }
	BitArray GetSel (int nsl);
	void SetVertSel(BitArray &set, IMeshSelect *imod, TimeValue t);
	void SetFaceSel(BitArray &set, IMeshSelect *imod, TimeValue t);
	void SetEdgeSel(BitArray &set, IMeshSelect *imod, TimeValue t);
	void SetSel (int nsl, BitArray & set, IMeshSelect *imod, TimeValue t);
	GenericNamedSelSetList & GetNamedVertSelList () { return selSet[NS_VERTEX]; }
	GenericNamedSelSetList & GetNamedEdgeSelList () { return selSet[NS_EDGE]; }
	GenericNamedSelSetList & GetNamedFaceSelList () { return selSet[NS_FACE]; }

	// MeshDeltaUser methods:
	void LocalDataChanged (DWORD parts);
	void ToggleCommandMode(meshCommandMode mode);
	void ButtonOp(meshButtonOp opcode);
	void GetUIParam (meshUIParam uiCode, int & ret);
	void SetUIParam (meshUIParam uiCode, int val);
	void GetUIParam (meshUIParam uiCode, float & ret);
	void SetUIParam (meshUIParam uiCode, float val);
	void ExitCommandModes () { ExitAllCommandModes (TRUE); }
	bool Editing () { return (ip && (editObj==this)) ? TRUE : FALSE; }
	DWORD GetEMeshSelLevel () { return selLevel; }
	void SetEMeshSelLevel (DWORD sl) { if (ip) ip->SetSubObjectLevel (sl); else selLevel = sl; }

	// MeshDeltaUserData methods:
	void ApplyMeshDelta (MeshDelta & md, MeshDeltaUser *mdu, TimeValue t);
	void MoveSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
	void RotateSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
	void ScaleSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
	void ExtrudeSelection(int level, BitArray* sel, float amount, float bevel, BOOL groupNormal, Point3* direction);

	// ISubMtlAPI methods:
	void*	GetInterface(ULONG id);
	MtlID	GetNextAvailMtlID(ModContext* mc);
	BOOL	HasFaceSelection(ModContext* mc);
	void	SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
	int		GetSelFaceUniqueMtlID(ModContext* mc);
	int		GetSelFaceAnyMtlID(ModContext* mc);
	int		GetMaxMtlID(ModContext* mc);

	// EventUser methods:
	void Notify() {DeleteSelected();/*delete key was pressed*/}

};

// Accelerator table callback for Editable or Edit Mesh.
class EMeshShortcutCB : public ShortcutCallback {
public:
	MeshDeltaUser *em;
	EMeshShortcutCB (MeshDeltaUser *emm) { em=emm; }
	BOOL KeyboardShortcut(int id);
};

// --- Command Modes & Mouse Procs -------------------------------

// Virtual mouse procs:
class PickEdgeMouseProc : public MouseCallBack {
public:
	EditTriObject *et;
	IObjParam *ip;

	PickEdgeMouseProc(EditTriObject* e, IObjParam *i) {et=e;ip=i;}
	HitRecord *HitTestEdges(IPoint2 &m, ViewExp *vpt, float *prop, Point3 *snapPoint);
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m );
	virtual void EdgePick(DWORD edge, float prop)=0;
};

class PickFaceMouseProc : public MouseCallBack {
public:
	EditTriObject *et;
	IObjParam *ip;

	PickFaceMouseProc(EditTriObject* e, IObjParam *i) {et=e;ip=i;}
	HitRecord *HitTestFaces(IPoint2 &m, ViewExp *vpt, float *bary, Point3 *snapPoint);
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m );
	virtual void FacePick(DWORD face, float *bary)=0;
};

// Actual procs & command modes:

class CreateVertMouseProc : public MouseCallBack {
private:		
	EditTriObject *et;
	IObjParam *ip;		
public:
	CreateVertMouseProc(EditTriObject* mod, IObjParam *i) {et=mod;ip=i;}
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class CreateVertCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	CreateVertMouseProc proc;
	EditTriObject* et;

public:
	CreateVertCMode(EditTriObject* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {et=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_CREATEVERT; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class CreateFaceMouseProc : public MouseCallBack {
public:
	EditTriObject *et;
	IObjParam *ip;
	Tab<int> vts;
	IPoint2 mlast, mfirst, oldm;
	int pt;

	CreateFaceMouseProc(EditTriObject* e, IObjParam *i);
	void DrawEstablishedFace (GraphicsWindow *gw);
	void DrawCreatingFace (HWND hWnd, const IPoint2 & m);
	BOOL HitTestVerts(IPoint2 m, ViewExp *vpt,int &v);
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m );
};

class CreateFaceCMode : public CommandMode {
public:
	ChangeFGObject fgProc;
	EditTriObject *et;
	CreateFaceMouseProc proc;

	CreateFaceCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i) {et=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_BUILDFACE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=999999; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class AttachPickMode : public PickModeCallback, public PickNodeCallback {
public:
	EditTriObject* eo;
	IObjParam *ip;

	AttachPickMode(EditTriObject* o, IObjParam *i) { eo=o; ip=i; }
	BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
	BOOL Pick(IObjParam *ip,ViewExp *vpt);
	void EnterMode(IObjParam *ip);
	void ExitMode(IObjParam *ip);		
	
	BOOL Filter(INode *node);
	BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
	PickNodeCallback *GetFilter() {return this;}
};

class AttachHitByName : public HitByNameDlgCallback {
public:
	EditTriObject *eo;
	bool inProc;

	AttachHitByName (EditTriObject *e) {eo=e; inProc=FALSE;}
	TCHAR *dialogTitle() { return GetString(IDS_ATTACH_LIST); }
	TCHAR *buttonText() { return GetString(IDS_RB_ATTACH); }
	int filter(INode *node);	
	void proc(INodeTab &nodeTab);	
};

class DivideEdgeProc : public PickEdgeMouseProc {
public:
	DivideEdgeProc(EditTriObject* e, IObjParam *i) : PickEdgeMouseProc(e,i) {}
	void EdgePick(DWORD edge, float prop);
};

class DivideEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	DivideEdgeProc proc;
	EditTriObject* et;

public:
	DivideEdgeCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i) {et=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_DIVIDEEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class DivideFaceProc : public PickFaceMouseProc {
public:
	DivideFaceProc(EditTriObject* e, IObjParam *i) : PickFaceMouseProc(e,i) {}
	void FacePick(DWORD face, float *bary);
};

class DivideFaceCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	DivideFaceProc proc;
	EditTriObject* et;

public:
	DivideFaceCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i) {et=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_DIVIDEFACE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class TurnEdgeProc : public PickEdgeMouseProc {
public:
	TurnEdgeProc(EditTriObject* e, IObjParam *i) : PickEdgeMouseProc(e,i) {}
	void EdgePick(DWORD edge, float prop);
};

class TurnEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	TurnEdgeProc proc;
	EditTriObject* et;

public:
	TurnEdgeCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i) {et=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_TURNEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class ExtrudeMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditTriObject *eo;
	Interface *ip;
	IPoint2 om;
public:
	ExtrudeMouseProc(EditTriObject* o, IObjParam *i) : moveTrans(i) {eo=o;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class ExtrudeSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	ExtrudeSelectionProcessor(ExtrudeMouseProc *mc, EditTriObject *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,o,i) {}
};

class ExtrudeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	ExtrudeSelectionProcessor mouseProc;
	ExtrudeMouseProc eproc;
	EditTriObject* eo;

public:
	ExtrudeCMode(EditTriObject* o, IObjParam *i) :
		fgProc(o), mouseProc(&eproc,o,i), eproc(o,i) {eo=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EXTRUDE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class BevelMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditTriObject *eo;
	Interface *ip;
	IPoint2 m0, m1;
	bool m0set, m1set;
	float height;
public:
	BevelMouseProc(EditTriObject* o, IObjParam *i) : moveTrans(i) {eo=o;ip=i; m0set=FALSE; m1set=FALSE; }
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class BevelSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	BevelSelectionProcessor(BevelMouseProc *mc, EditTriObject *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,o,i) {}
};

class BevelCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	BevelSelectionProcessor mouseProc;
	BevelMouseProc eproc;
	EditTriObject* eo;

public:
	BevelCMode(EditTriObject* o, IObjParam *i) :
		fgProc(o), mouseProc(&eproc,o,i), eproc(o,i) {eo=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_BEVEL; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=3; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class ChamferMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditTriObject *eo;
	Interface *ip;
	IPoint2 om;
public:
	ChamferMouseProc (EditTriObject* o, IObjParam *i) : moveTrans(i) {eo=o;ip=i;}
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class ChamferSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EditTriObject *eto;
	ChamferSelectionProcessor(ChamferMouseProc *mc, EditTriObject *o, IObjParam *i) 
		: GenModSelectionProcessor(mc,o,i) {eto=o;}
};

class ChamferCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	ChamferSelectionProcessor mouseProc;
	ChamferMouseProc eproc;
	EditTriObject* eo;

public:
	ChamferCMode (EditTriObject* o, IObjParam *i) :
		fgProc(o), mouseProc(&eproc,o,i), eproc(o,i) {eo=o;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_MCHAMFER; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class CutEdgeProc : public MouseCallBack {
public:
	EditTriObject *et;
	IObjParam *ip;
	DWORD e1;
	bool e1set;
	float prop1;
	IPoint2 m1, oldm2;

	CutEdgeProc(EditTriObject* e, IObjParam *i) { et=e; ip=i; e1set = FALSE;}
	HitRecord *HitTestEdges(IPoint2 &m, ViewExp *vpt);
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m );
	void DrawCutter (HWND hWnd,IPoint2 &m);
};

class CutEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;	
	CutEdgeProc proc;
	EditTriObject* et;

public:
	CutEdgeCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i) {et=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_CUTEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=20; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
	void AbandonCut ();
};

class WeldVertMouseProc : public MoveModBox {
private:		
	EditTriObject *et;
	IObjParam *ip;
	int targetVert;
public:
	WeldVertMouseProc(EditTriObject* e, IObjParam *i) : MoveModBox(e,i) { et=e; ip=i; }
	BOOL HitTestVerts(IPoint2 &m, ViewExp *vpt,int &v);
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m);
	void PostTransformHolding ();
	int UndoStringID() { return IDS_RB_WELDVERTS; }
};

class WeldVertSelectionProcessor : public SubModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();

public:
	WeldVertSelectionProcessor(WeldVertMouseProc *mc, Object *o, IObjParam *i) 
		: SubModSelectionProcessor(mc,o,i) { SetSupportTransformGizmo (TRUE); }
};

class WeldVertCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	WeldVertSelectionProcessor mouseProc;
	WeldVertMouseProc eproc;
	EditTriObject* et;

public:
	WeldVertCMode(EditTriObject* mod, IObjParam *i) :
		fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {et=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_WELDVERT; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=2; return &mouseProc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) {return oldMode->ChangeFGProc() != &fgProc;}
	void EnterMode();
	void ExitMode();
};

class FlipNormProc : public PickFaceMouseProc {
public:
	FlipNormProc (EditTriObject* e, IObjParam *i) : PickFaceMouseProc(e,i) {}
	void FacePick (DWORD face, float *bary);
};

class FlipNormCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	FlipNormProc proc;
	EditTriObject* et;

public:
	FlipNormCMode(EditTriObject* e, IObjParam *i) : fgProc(e), proc(e,i	) {et=e;}
	int Class() {return MODIFY_COMMAND;}
	int ID() {return CID_FLIPNORM;}
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

// --- Restore objects ---------------------------------------------

// Not really a restore object, just used in some drag moves.
class TempMoveRestore {
public:
	Tab<Point3> init;
	BitArray active;

	TempMoveRestore (EditTriObject *em);
	void Restore (EditTriObject *em);
};

class CueLocalRestore : public RestoreObj {
public:
	EditTriObject *editObj;

	CueLocalRestore (EditTriObject *eo) { editObj = eo; }
	void Restore(int isUndo) { editObj->DragMoveRestore(); }
	void Redo() { }
	TSTR Description() {return TSTR(_T("Cue internal Restore"));}
	int Size() { return sizeof(int) + sizeof(void *); }
};

class MeshSelRestore : public RestoreObj {	
public:		   	
	BitArray undo, redo;
	EditTriObject *et;
	int selLevel;

	MeshSelRestore(EditTriObject *et);
	MeshSelRestore (EditTriObject *et, int selLev);
	void Restore(int isUndo);
	void Redo();
	TSTR Description() {return TSTR(_T("Mesh Sel"));}
};

class MeshVertRestore : public RestoreObj {
public:		   	
	Tab<Point3> undo, redo;
	BitArray uvdSupport, rvdSupport;
	PerData *uvData, *rvData;

	EditTriObject *et;

	MeshVertRestore(EditTriObject *et);
	~MeshVertRestore () { if (uvData) delete [] uvData; if (rvData) delete [] rvData; }
	void Restore(int isUndo);
	void Redo();
	void EndHold() {et->ClearAFlag(A_HELD);}
	TSTR Description() {return TSTR(_T("Mesh Geometry Change"));}
};

class MeshTopoRestore : public RestoreObj {
public:
	EditTriObject *et;
	Mesh umesh, rmesh;
	DWORD channels;
	BOOL undone;
	Tab<Control*> ucont, rcont;

	MeshTopoRestore(EditTriObject *et, DWORD chan);
	void Restore(int isUndo);
	void Redo();
	void EndHold() {et->ClearAFlag(A_HELD);}
	TSTR Description() {return TSTR(_T("Mesh Topo"));}
};

class MeshVertHideRestore : public RestoreObj {	
public:		   	
	BitArray undo, redo;
	EditTriObject *et;		

	MeshVertHideRestore(EditTriObject *et);
	void Restore(int isUndo);
	void Redo();
	TSTR Description() {return TSTR(_T("Mesh Vert Hide"));}
};

class MeshFaceHideRestore : public RestoreObj {	
public:
	BitArray undo, redo;
	EditTriObject *et;		

	MeshFaceHideRestore(EditTriObject *et);
	void Restore(int isUndo);
	void Redo();		
	TSTR Description() {return TSTR(_T("Mesh Face Hide"));}
};

class MeshFaceMatRestore : public RestoreObj {	
public:		   	
	Tab<MtlID> undo, redo;
	EditTriObject *et;		

	MeshFaceMatRestore(EditTriObject *et);
	void Restore(int isUndo);
	void Redo();
	void EndHold() {et->ClearAFlag(A_HELD);}
	TSTR Description() {return TSTR(_T("Mesh Face Mat"));}
};

class FaceIndexRec {
public:
	DWORD v[3], flags;
};
class UVFaceIndexRec {
public:
	DWORD v[3];
};


class AppendSetRestore : public RestoreObj {
public:
	BitArray set;
	TSTR name;
	GenericNamedSelSetList *setList;
	EditTriObject *et;

	AppendSetRestore(GenericNamedSelSetList *sl,EditTriObject *e) {
		setList = sl; et = e;
	}
	void Restore(int isUndo) {
		set  = *setList->sets[setList->Count()-1];
		name = *setList->names[setList->Count()-1];
		setList->DeleteSet(setList->Count()-1);
		if (et->ip) {
			et->ip->NamedSelSetListChanged();
			et->UpdateNamedSelDropDown ();
		}
	}
	void Redo() {
		setList->AppendSet(set, 0, name);
		if (et->ip) {
			et->ip->NamedSelSetListChanged();
			et->UpdateNamedSelDropDown ();
		}
	}
			
	TSTR Description() {return TSTR(_T("Append Set"));}
};

class DeleteSetRestore : public RestoreObj {
public:
	BitArray set;
	TSTR name;
	int index;
	GenericNamedSelSetList *setList;
	EditTriObject *et;

	DeleteSetRestore(TSTR nm, GenericNamedSelSetList *sl,EditTriObject *e) {
		setList = sl;
		et = e;
		set  = *(sl->GetSet(nm));
		name = nm;
	}
	void Restore(int isUndo) {
		setList->AppendSet (set, 0, name);
		if (et->ip) {
			et->ip->NamedSelSetListChanged();
			et->UpdateNamedSelDropDown ();
		}
	}
	void Redo() {
		setList->RemoveSet (name);
		if (et->ip) {
			et->ip->NamedSelSetListChanged();
			et->UpdateNamedSelDropDown ();
		}
	}
			
	TSTR Description() {return TSTR(_T("Delete Set"));}
};

class SetNameRestore : public RestoreObj {
public:
	TSTR undo, redo;
	int index;
	GenericNamedSelSetList *setList;
	EditTriObject *et;
	SetNameRestore(int i,GenericNamedSelSetList *sl,EditTriObject *e) {
		index = i; setList = sl; et = e;
		undo = *setList->names[index];
	}

	void Restore(int isUndo) {			
		redo = *setList->names[index];
		*setList->names[index] = undo;
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
	void Redo() {
		*setList->names[index] = redo;
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
			
	TSTR Description() {return TSTR(_T("Set Name"));}
};

class TransformPlaneRestore : public RestoreObj {
public:
	Point3 oldSliceCenter, newSliceCenter;
	Quat oldSliceRot, newSliceRot;
	float oldSliceSize, newSliceSize;
	EditTriObject *eo;
	TransformPlaneRestore (EditTriObject *eto) {
		eo = eto;
		oldSliceCenter = eo->sliceCenter;
		oldSliceRot = eo->sliceRot;
		oldSliceSize = eo->sliceSize;
	}
	void Restore (int isUndo) {
		newSliceCenter = eo->sliceCenter;
		newSliceRot = eo->sliceRot;
		newSliceSize = eo->sliceSize;
		eo->sliceCenter = oldSliceCenter;
		eo->sliceRot = oldSliceRot;
		eo->sliceSize = oldSliceSize;
		eo->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	}
	void Redo () {
		oldSliceCenter = eo->sliceCenter;
		oldSliceRot = eo->sliceRot;
		oldSliceSize = eo->sliceSize;
		eo->sliceCenter = newSliceCenter;
		eo->sliceRot = newSliceRot;
		eo->sliceSize = newSliceSize;
		eo->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	}
	int Size () {
		return 2*(sizeof(Point3) + sizeof(Quat) + sizeof(float))
			+ sizeof (EditTriObject *);
	}
	TSTR Description () { return TSTR (_T("Slice Plane transform")); }
};

// TriEdUI.cpp function:
BOOL GetCloneObjectName (Interface *ip, TSTR &name);
void ResetEditableMeshUI ();
ShortcutTable *GetEMeshShortcuts ();

// triops.cpp
void ExplodeToObjects (Mesh *mesh, float thresh, INode *node, TSTR &name,
					   Interface *ip, MeshDelta *tmd, AdjFaceList *af, BOOL selOnly);
BOOL CreateCurveFromMeshEdges (Mesh & mesh, INode *node, Interface *ip, AdjEdgeList *ae,
							   TSTR & name, BOOL curved, BOOL ignoreHiddenEdges);

BOOL CALLBACK DispApproxDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


#endif //__TRIOBJED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\kernelhdr.h ===
/**********************************************************************
 *<
	FILE: kernelhdr.h

	DESCRIPTION: Hearder for Prefilter Kernels DLL

	CREATED BY: Kells Elmquist

	HISTORY:

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __KERNELHDR__H
#define __KERNELHDR__H

#ifdef BLD_KERNEL
#define KernelExport __declspec( dllexport )
#else
#define KernelExport __declspec( dllimport )
#endif

#include "max.h"
#include "render.h"
#include "stdKernels.h"

extern ClassDesc* GetSampKernelDesc();




TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\pack1\triops.cpp ===
/**********************************************************************  
 *<
	FILE: triops.cpp

	DESCRIPTION: Editable Triangle Mesh Object

	CREATED BY: Rolf Berteig

	HISTORY: created 4 March 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "pack1.h"
#include "triobjed.h"
#include "macrorec.h"
#include "decomp.h"
#include "spline3d.h"
#include "splshape.h"
#include "shape.h"

void EditTriObject::CloneSelSubComponents(TimeValue t) {
	if (selLevel == SL_OBJECT) return;
	if (!ip) return;

	theHold.Begin();

	MeshDelta tmd(GetMesh());
	switch (selLevel) {
	case SL_VERTEX: tmd.CloneVerts(GetMesh(), GetMesh().vertSel); break;
	case SL_EDGE: tmd.ExtrudeEdges (GetMesh(), GetMesh().edgeSel); break;
	default: tmd.CloneFaces (GetMesh(), GetMesh().faceSel); break;
	}
	ApplyMeshDelta (tmd, this, t);

	theHold.Accept(GetString(IDS_RB_CLONE));	
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::AcceptCloneSelSubComponents(TimeValue t) {
	if ((selLevel==SL_OBJECT) || (selLevel==SL_EDGE)) return;
	TSTR name;
	if (!GetCloneObjectName(ip, name)) return;
	Detach (name, (selLevel != SL_VERTEX), TRUE, FALSE);
}

void EditTriObject::Transform (TimeValue t, Matrix3& partm, Matrix3 tmAxis, 
		BOOL localOrigin, Matrix3 xfrm, int type) {
	if (!ip) return;

	if (sliceMode) {
		// Special case -- just transform slicing plane.
		theHold.Put (new TransformPlaneRestore (this));
		Matrix3 tm  = partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		Matrix3 myxfm = tm * xfrm * itm;
		Point3 myTrans, myScale;
		Quat myRot;
		DecomposeMatrix (myxfm, myTrans, myRot, myScale);
		float factor;
		switch (type) {
		case 0: sliceCenter += myTrans; break;
		case 1: sliceRot *= myRot; break;
		case 2:
			factor = (float) exp(log(myScale[0]*myScale[1]*myScale[2])/3.0);
			sliceSize *= factor;
			break;
		}
		NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		return;
	}

	// Otherwise, moving subobject selections.

	// Get node transform
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	Matrix3 nodeTm = nodes[0]->GetObjectTM(t);

	// Get axis type:
	int numAxis = ip->GetNumAxis();

	// Special case for vertices: Only individual axis when moving in local space
	if ((selLevel==SL_VERTEX) && (numAxis==NUMAXIS_INDIVIDUAL)) {
		if (ip->GetRefCoordSys()!=COORDS_LOCAL || 
			ip->GetCommandMode()->ID()!=CID_SUBOBJMOVE) {
			numAxis = NUMAXIS_ALL;
		}
	}

	// Selected vertices - either directly or indirectly through selected faces or edges.
	BitArray sel = GetMesh().VertexTempSel();
	if (!sel.NumberSet()) {
		nodes.DisposeTemporary ();
		return;
	}
	MeshDelta tmd (GetMesh());

	int i, nv = GetMesh().numVerts;

	// Compute the transforms
	if (numAxis==NUMAXIS_INDIVIDUAL && selLevel != SL_VERTEX) {
		// Do each cluster one at a time
		DWORD count;
		Tab<DWORD> *vclust = NULL;
		if (selLevel == SL_EDGE) {
			count = TempData()->EdgeClusters()->count;
			vclust = TempData()->VertexClusters(MESH_EDGE);
		} else {
			count = TempData()->FaceClusters()->count;
			vclust = TempData()->VertexClusters(MESH_FACE);
		}
		float *clustDist=NULL, *ws=NULL;
		Tab<float> weightSum;
		Matrix3 tm, itm;
		if (affectRegion) {
			weightSum.SetCount(nv);
			ws = weightSum.Addr(0);
			for (i=0; i<nv; i++) ws[i] = 0.0f;
		}
		for (DWORD j=0; j<count; j++) {
			tmAxis = ip->GetTransformAxis (nodes[0], j);
			tm  = partm * Inverse(tmAxis);
			itm = Inverse(tm);
			tm *= xfrm;
			if (affectRegion) clustDist = TempData()->ClusterDist(meshSelLevel[selLevel], j, useEdgeDist, edgeIts)->Addr(0);
			for (i=0; i<nv; i++) {
				if (sel[i]) {
					if ((*vclust)[i]!=j) continue;
					Point3 & old = GetMesh().verts[i];
					tmd.Move (i, (tm*old)*itm - old);
				} else {
					if (!affectRegion) continue;
					if (clustDist[i] < 0) continue;
					if (clustDist[i] > falloff) continue;
					float af = AffectRegionFunction (clustDist[i], falloff, pinch, bubble);
					ws[i] += af;
					Point3 & old = GetMesh().verts[i];
					tmd.Move (i, ((tm*old)*itm - old)*af);
				}
			}
		}
		if (affectRegion) {
			for (i=0; i<nv; i++) {
				if (sel[i]) continue;
				if (ws[i] <= 1) continue;
				j = tmd.MoveID(i);
				if (j==(DWORD)tmd.vMove.Count()) continue;
				if (tmd.vMove[j].vid != (DWORD)i) continue;
				tmd.vMove[j].dv /= weightSum[i];
			}
		}
	} else {
		Matrix3 tm  = partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		tm *= xfrm;
		Point3 *vn = (numAxis == NUMAXIS_INDIVIDUAL) ? TempData()->VertexNormals()->Addr(0) : 0;
		float *vsw = affectRegion ? TempData()->VSWeight(useEdgeDist, edgeIts, arIgBack,
				falloff, pinch, bubble)->Addr(0) : NULL;
		for (i=0; i<nv; i++) {
			if (!sel[i]) {
				if (!vsw || !vsw[i]) continue;
			}
			Point3 & old = GetMesh().verts[i];
			Point3 delta;
			if (numAxis == NUMAXIS_INDIVIDUAL) {
				MatrixFromNormal (vn[i], tm);
				tm  = partm * Inverse(tm*nodeTm);
				itm = Inverse(tm);
				delta = itm*(xfrm*(tm*old)) - old;
			} else {
				delta = itm*(tm*old)-old;
			}
			if (sel[i]) tmd.Move (i, delta);
			else tmd.Move (i, delta * vsw[i]);
		}
	}

	nodes.DisposeTemporary ();
	DragMove (tmd, this);
}

void EditTriObject::Move (TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) {
	Transform(t, partm, tmAxis, localOrigin, TransMatrix(val), 0);
	macroRecorder->FunctionCall(_T("move"), 2, 0, mr_meshsel, selLevel, this, mr_point3, &val);  // JBW : macrorecorder
}

void EditTriObject::Rotate (TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin) {
	Matrix3 mat;
	val.MakeMatrix(mat);
	Transform(t, partm, tmAxis, localOrigin, mat, 1);
	macroRecorder->FunctionCall(_T("rotate"), 2, 0, mr_meshsel, selLevel, this, mr_quat, &val);  // JBW : macrorecorder
	return;
}

void EditTriObject::Scale (TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) {
	Transform (t, partm, tmAxis, localOrigin, ScaleMatrix(val), 2);	
	macroRecorder->FunctionCall(_T("scale"), 2, 0, mr_meshsel, selLevel, this, mr_point3, &val);  // JBW : macrorecorder
	return;
}

void EditTriObject::TransformStart(TimeValue t) {
	if (!ip) return;
	ip->LockAxisTripods(TRUE);
	if (sliceMode) return;
	DragMoveInit();
}

void EditTriObject::TransformHoldingFinish (TimeValue t) {
	if (!ip || sliceMode) return;
	DragMoveAccept (t);
}

void EditTriObject::TransformFinish(TimeValue t) {
	if (!ip) return;
	ip->LockAxisTripods(FALSE);
}

void EditTriObject::TransformCancel (TimeValue t) {
	DragMoveClear ();
	if (!ip) return;
	ip->LockAxisTripods(FALSE);
	if (sliceMode) return;
}

// Selection dialog ops

void EditTriObject::HideSelectedVerts() {
	theHold.Begin();
	theHold.Put(new MeshVertHideRestore(this));
	GetMesh().vertHide |= GetMesh().vertSel;
	BitArray emptyVertSel;
	emptyVertSel.SetSize (GetMesh().numVerts);
	SetVertSel (emptyVertSel, this, ip ? ip->GetTime () : 0);
	theHold.Accept(GetString(IDS_RB_HIDEVERT));

	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	LocalDataChanged ();
}

void EditTriObject::UnhideAllVerts() {
	theHold.Begin();
	theHold.Put(new MeshVertHideRestore(this));
	GetMesh().vertHide.ClearAll();
	theHold.Accept(GetString(IDS_RB_HIDEVERT));
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::HideSelectedFaces() {
	theHold.Begin();
	theHold.Put(new MeshFaceHideRestore(this));
	theHold.Put(new MeshVertHideRestore(this));
	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		if (GetMesh().faceSel[i]) GetMesh().faces[i].Hide();
	}
	HiddenFacesToVerts (GetMesh(), GetMesh().vertHide);
	BitArray emptyFaceSel;
	emptyFaceSel.SetSize (GetMesh().numFaces);
	SetFaceSel (emptyFaceSel, this, ip ? ip->GetTime() : 0);
	GetMesh().InvalidateTopologyCache();
	theHold.Accept(GetString(IDS_RB_HIDEFACE));

	NotifyDependents (FOREVER, PART_DISPLAY | PART_TOPO, REFMSG_CHANGE);
	LocalDataChanged ();
}

void EditTriObject::UnhideAllFaces() {
	theHold.Begin();
	theHold.Put(new MeshFaceHideRestore(this));
	theHold.Put(new MeshVertHideRestore(this));
	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		if (!GetMesh().faces[i].Hidden ()) continue;
		GetMesh().faces[i].Show();
		for (int j=0; j<3; j++) GetMesh().vertHide.Clear (GetMesh().faces[i].v[j]);
	}
	GetMesh().InvalidateTopologyCache();
	theHold.Accept(GetString(IDS_RB_HIDEFACE));
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

// Edit Geometry ops

DWORD EditTriObject::CreateVertex(Point3 pt) {
	if (!ip) return UNDEFINED;
	// Put the point in object space:
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	pt = pt * Inverse(nodes[0]->GetObjectTM(ip->GetTime()));
	nodes.DisposeTemporary();

	MeshDelta tmd(GetMesh());
	DWORD ret = tmd.VCreate (&pt);
	tmd.vsel.Set (ret);

	theHold.Begin();
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_ADDVERTS));

	ip->RedrawViews(ip->GetTime());
	return ret;
}

bool EditTriObject::CreateFace(int *v, int deg) {
	int tnum = deg-2;
	MeshDelta tmd(GetMesh());
	if (tmd.CreatePolygon (GetMesh (), deg, v) == UNDEFINED) return FALSE;
	theHold.Begin();
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_BUILDFACE));
	ip->RedrawViews(ip->GetTime());
	return TRUE;
}

void EditTriObject::DeleteSelected() {
	if (selLevel == SL_OBJECT) return;

	int i, j;
	BitArray fset, iso;
	DWORD stringID, of;
	AdjFaceList *af;

	theHold.Begin();
	MeshDelta tmd(GetMesh());

	switch (selLevel) {
	case SL_VERTEX:
		tmd.DeleteVertSet(GetMesh(), GetMesh().vertSel);
		stringID = IDS_RB_DELETEVERT;
		break;

	case SL_EDGE:
		af = TempData()->AdjFList();
		fset.SetSize (GetMesh().getNumFaces());

		for (i=0; i<GetMesh().getNumFaces(); i++) {
			for (j=0; j<3; j++) if (GetMesh().edgeSel[i*3+j]) break;
			if (j==3) continue;
			fset.Set(i);
			// Mark other sides of edges:
			for (; j<3; j++) {
				if (!GetMesh().edgeSel[i*3+j]) continue;
				if ((of=(*af)[i].f[j]) != UNDEFINED) fset.Set(of);
			}
		}

		GetMesh().FindVertsUsedOnlyByFaces (fset, iso);
		tmd.DeleteFaceSet (GetMesh(), fset);

		if (ip && iso.NumberSet()) {
			TSTR str1 = GetString(IDS_RB_DELETEISOLATED);
			TSTR str2 = GetString(IDS_RB_DELETEEDGE);
			if (IDYES==MessageBox (ip->GetMAXHWnd(), str1,str2, MB_ICONQUESTION|MB_YESNO)) {
				tmd.VDelete (iso);
			}
		}

		stringID = IDS_RB_DELETEEDGE;
		break;

	default:
		GetMesh().FindVertsUsedOnlyByFaces (GetMesh().faceSel, iso);
		tmd.DeleteFaceSet (GetMesh(), GetMesh().faceSel);

		if (ip && iso.NumberSet()) {
			TSTR str1 = GetString(IDS_RB_DELETEISOLATED);
			TSTR str2 = GetString(IDS_RB_DELETEFACE);
			if (IDYES==MessageBox (ip->GetMAXHWnd(), str1,str2, MB_ICONQUESTION|MB_YESNO)) {
				tmd.VDelete (iso);
			}
		}
		stringID = IDS_RB_DELETEFACE;
		break;
	}

	if (!ip) return;	// Can happen if we leave EMesh modify panel during MessageBox.

	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept (GetString (stringID));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Attach (INode *node, bool & canUndo) {
	// First get the object
	BOOL del = FALSE;
	TriObject *obj = NULL;
	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) obj = (TriObject *) os.obj;
	else {
		if (!os.obj->CanConvertToType(triObjectClassID)) return;
		obj = (TriObject*)os.obj->ConvertToType(ip->GetTime(),triObjectClassID);
		if (obj!=os.obj) del = TRUE;
	}

	// Get our node:
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	// Combine the materials of the two nodes.
	int mat2Offset=0;
	Mtl *m1 = nodes[0]->GetMtl();
	Mtl *m2 = node->GetMtl();
	bool condenseMe = FALSE;
	if (m1 && m2 && (m1 != m2)) {
		if (attachMat==ATTACHMAT_IDTOMAT) {
			FitMeshIDsToMaterial (GetMesh(), m1);
			FitMeshIDsToMaterial (obj->GetMesh(), m2);
			if (condenseMat) condenseMe = TRUE;
		}

		// the theHold calls here were a vain attempt to make this all undoable.
		// This should be revisited in the future so we don't have to use the SYSSET_CLEAR_UNDO.
		theHold.Suspend ();
		if (attachMat==ATTACHMAT_MATTOID) {
			m1 = FitMaterialToMeshIDs (GetMesh(), m1);
			m2 = FitMaterialToMeshIDs (obj->GetMesh(), m2);
		}
		Mtl *multi = CombineMaterials(m1, m2, mat2Offset);
		if (attachMat == ATTACHMAT_NEITHER) mat2Offset = 0;
		theHold.Resume ();
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = selLevel;
		if (oldSL>SL_EDGE) selLevel = SL_OBJECT;
		nodes[0]->SetMtl(multi);
		if (oldSL>SL_EDGE) selLevel = oldSL;
		m1 = multi;
		canUndo = FALSE;	// Absolutely cannot undo material combinations.
	}
	if (!m1 && m2) {
		// This material operation seems safe.
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = selLevel;
		if (oldSL>SL_EDGE) selLevel = SL_OBJECT;
		nodes[0]->SetMtl (m2);
		if (oldSL>SL_EDGE) selLevel = oldSL;
		m1 = m2;
	}

	// Construct a transformation that takes a vertex out of the space of
	// the source node and puts it into the space of the destination node.
	Matrix3 tm = node->GetObjectTM(ip->GetTime()) *
		Inverse(nodes[0]->GetObjectTM(ip->GetTime()));

	MeshDelta nmd;
	nmd.AttachMesh (GetMesh(), obj->GetMesh(), tm, mat2Offset);
	ApplyMeshDelta (nmd, this, ip->GetTime());
	ip->DeleteNode (node);
	theHold.Accept (GetString (IDS_RB_ATTACHOBJECT));

	if (m1 && condenseMe) {
		// Following clears undo stack.
		m1 = CondenseMatAssignments (GetMesh(), m1);
	}

	nodes.DisposeTemporary ();
	if (del) delete obj;
}

void EditTriObject::MultiAttach (INodeTab &nodeTab) {
	bool canUndo = TRUE;
	if (nodeTab.Count() > 1) theHold.SuperBegin ();
	for (int i=0; i<nodeTab.Count(); i++) Attach (nodeTab[i], canUndo);
	if (nodeTab.Count() > 1) theHold.SuperAccept (GetString (IDS_ATTACH_LIST));
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Detach (TSTR &name,BOOL doFaces,BOOL del,BOOL elem) {
	theHold.Begin ();
	if (!elem) {	// Animation confuses things.
		SuspendAnimate();
		AnimateOff();
	}

	TriObject *newObj;
	if (!elem) newObj = CreateNewTriObject();

	MeshDelta tmd;
	tmd.Detach (GetMesh(), elem ? NULL : &(newObj->GetMesh()),
		doFaces ? GetMesh().faceSel : GetMesh().vertSel, doFaces, del, elem);
	ApplyMeshDelta (tmd, this, ip->GetTime());

	if (!elem) {
		// We need our node (for our transform).
		ModContextList mcList;
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);

		// Add the object to the scene. Give it the given name
		// and set its transform to ours.
		// Also, give it our material.
		INode *node = ip->CreateObjectNode(newObj);
		Matrix3 ntm = nodes[0]->GetNodeTM(ip->GetTime());
		if (ip->GetINodeByName(name) != node) {	// Just in case name = "Object01" or some such default.
			TSTR uname = name;
			if (ip->GetINodeByName (uname)) ip->MakeNameUnique(uname);
			node->SetName(uname);
		}
		node->SetNodeTM(ip->GetTime(),ntm);
		node->FlagForeground(ip->GetTime(),FALSE);
		node->SetMtl(nodes[0]->GetMtl());
		node->SetObjOffsetPos(   nodes[0]->GetObjOffsetPos());
		node->SetObjOffsetRot(	 nodes[0]->GetObjOffsetRot());
		node->SetObjOffsetScale( nodes[0]->GetObjOffsetScale());

		nodes.DisposeTemporary();
	}

	if (!elem) ResumeAnimate();
	theHold.Accept(GetString(doFaces?IDS_RB_DETACHFACES:IDS_RB_DETACHVERT));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::BreakVerts() {
	theHold.Begin();
	MeshDelta tmd;
	tmd.BreakVerts (GetMesh(), GetMesh().vertSel);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_BREAKVERTS));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::DoExtrusion() {
	theHold.Begin();
	MeshDelta tmd;
	Tab<Point3> edir;
	if (selLevel == SL_EDGE) tmd.ExtrudeEdges (GetMesh(), GetMesh().edgeSel, &edir);
	else tmd.ExtrudeFaces (GetMesh(), GetMesh().faceSel, TempData()->AdjEList ());
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept (GetString (IDS_RB_EXTRUDE));

	if (selLevel == SL_EDGE) {
		// Edge normals messed up, so compute directions based on extrusion feedback.
		TempData()->EdgeExtDir (&edir, extType);
	} else {
		TempData()->FaceExtDir (extType);
	}
}

void EditTriObject::BeginExtrude(TimeValue t) {	
	if (inExtrude) return;
	inExtrude = TRUE;
	theHold.SuperBegin();
	DoExtrusion();
	BitArray sel = GetMesh().VertexTempSel();
	PlugControllersSel(t,sel);
	DragMoveInit();
}

void EditTriObject::EndExtrude (TimeValue t, BOOL accept) {		
	if (!ip) return;
	if (!inExtrude) return;
	inExtrude = FALSE;
	TempData()->freeBevelInfo();

	theHold.Begin ();
	DragMoveAccept (t);
	theHold.Accept(GetString(IDS_DS_MOVE));
	if (accept) theHold.SuperAccept(GetString(IDS_RB_EXTRUDE));
	else theHold.SuperCancel();

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditTriObject::Extrude( TimeValue t, float amount ) {
	if (!inExtrude) return;
	DragMoveRestore ();

	MeshDelta tmd(GetMesh());
	BitArray sel = GetMesh().VertexTempSel();
	Tab<Point3> *extDir = TempData()->CurrentExtDir();
	if ((extDir==NULL) || (amount==0)) return;
	tmd.Bevel (GetMesh(), sel, 0, NULL, amount, extDir);
	DragMove (tmd, this);
}

static int ExtDone=FALSE;

void EditTriObject::BeginBevel (TimeValue t, BOOL doExtrude) {	
	if (inBevel) return;
	inBevel = TRUE;
	theHold.SuperBegin();
	if (doExtrude) DoExtrusion ();
	ExtDone = doExtrude;
	BitArray sel = GetMesh().VertexTempSel();
	PlugControllersSel(t,sel);
	//theHold.Begin();
	DragMoveInit ();
}

void EditTriObject::EndBevel (TimeValue t, BOOL accept) {		
	if (!ip) return;
	if (!inBevel) return;
	inBevel = FALSE;
	TempData()->freeBevelInfo();

	theHold.Begin ();
	DragMoveAccept (t);
	theHold.Accept(GetString(IDS_DS_MOVE));
	if (accept)
		theHold.SuperAccept(GetString(ExtDone ? IDS_BEVEL : IDS_OUTLINE));
	else theHold.SuperCancel();

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
	spin = GetISpinner(GetDlgItem(hGeom,IDC_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditTriObject::Bevel (TimeValue t, float amount, float height) {
	if (!inBevel) return;
	DragMoveRestore ();

	MeshDelta tmd(GetMesh());
	tmd.Bevel (GetMesh(), GetMesh().VertexTempSel (), amount, TempData()->OutlineDir(extType),
		height, TempData()->FaceExtDir (extType));
	DragMove (tmd, this);
}

void EditTriObject::DoChamfer () {
	theHold.Begin();
	MeshDelta tmd;
	MeshChamferData *mcd = TempData()->ChamferData();
	AdjEdgeList *ae = TempData()->AdjEList();
	if (selLevel == SL_EDGE) tmd.ChamferEdges (GetMesh(), GetMesh().edgeSel, *mcd, ae);
	else tmd.ChamferVertices (GetMesh(), GetMesh().vertSel, *mcd, ae);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept (GetString (IDS_CHAMFER));
}

void EditTriObject::BeginChamfer (TimeValue t) {
	if (inChamfer) return;
	inChamfer = TRUE;
	theHold.SuperBegin();
	DoChamfer ();
	BitArray sel;
	sel.SetSize (GetMesh().numVerts);
	sel.ClearAll ();
	float *vmp = TempData()->ChamferData()->vmax.Addr(0);
	for (int i=0; i<GetMesh().numVerts; i++) if (vmp[i]) sel.Set(i);
	PlugControllersSel(t,sel);
	//theHold.Begin();
	DragMoveInit();
}

void EditTriObject::EndChamfer (TimeValue t, BOOL accept) {		
	if (!ip) return;
	if (!inChamfer) return;
	inChamfer = FALSE;
	TempData()->freeChamferData();

	theHold.Begin ();
	DragMoveAccept (t);
	theHold.Accept(GetString(IDS_DS_MOVE));
	if (accept) theHold.SuperAccept(GetString(IDS_CHAMFER));
	else theHold.SuperCancel();

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditTriObject::Chamfer (TimeValue t, float amount) {
	if (!inChamfer) return;
	DragMoveRestore ();
	if (amount<=0) return;

	MeshDelta tmd(GetMesh());
	tmd.ChamferMove (GetMesh(), *TempData()->ChamferData(), amount, TempData()->AdjEList());
	DragMove (tmd, this);
}

void EditTriObject::AlignTo(int alignType) {
	// We'll need the viewport or construction plane transform:
	Matrix3 atm, otm, res;
	ViewExp *vpt = ip->GetActiveViewport();
	float zoff;
	if (alignType == ALIGN_CONST) vpt->GetConstructionTM(atm);
	else {
		vpt->GetAffineTM(atm);
		atm = Inverse(atm);
	}
	ip->ReleaseViewport (vpt);

	// We'll also need our own transform:
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	otm = nodes[0]->GetObjectTM(ip->GetTime());
	nodes.DisposeTemporary();
	res = atm*Inverse (otm);	// screenspace-to-objectspace.

	BitArray sel = GetMesh().VertexTempSel();
	// For ZNorm, we want the object-space unit vector pointing into the screen:
	Point3 ZNorm (0,0,-1);
	ZNorm = Normalize (VectorTransform (res, ZNorm));

	if (alignType != ALIGN_CONST) {
		// Find the average z-depth for the current selection.
		zoff = 0.0f;
		for (int i=0; i<GetMesh().numVerts; i++) {
			if (!sel[i]) continue;
			zoff += DotProd (ZNorm, GetMesh().verts[i]);
		}
		zoff /= (float) sel.NumberSet();
	} else {
		// Find the z-depth of the construction plane, in object space:
		zoff = DotProd (ZNorm, res.GetTrans());
	}

	theHold.Begin();
	MeshDelta tmd(GetMesh());
	tmd.MoveVertsToPlane (GetMesh(), sel, ZNorm, zoff);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(alignType==ALIGN_CONST?IDS_RB_ALIGNTOCONST:IDS_RB_ALIGNTOVIEW));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::MakePlanar () {
	theHold.Begin ();
	MeshDelta tmd (GetMesh());
	BitArray tempSel;
	int j, k;
	switch (selLevel) {
	case SL_VERTEX:
		tmd.MakeSelVertsPlanar (GetMesh(), GetMesh().vertSel);
		break;

	case SL_EDGE:
		tempSel.SetSize (GetMesh().numVerts);
		tempSel.ClearAll ();
		for (j=0; j<GetMesh().numFaces; j++) {
			for (k=0; k<3; k++) if (GetMesh().edgeSel[j*3+k]) break;
			if (k==3) continue;
			tempSel.Set (GetMesh().faces[j].v[k]);
			tempSel.Set (GetMesh().faces[j].v[(k+1)%3]);
			if ((k<2) && (GetMesh().edgeSel[j*3+k+1] || GetMesh().edgeSel[j*3+(k+2)%3]))
				tempSel.Set (GetMesh().faces[j].v[(k+2)%3]);
		}
		tmd.MakeSelVertsPlanar (GetMesh(), tempSel);
		break;

	default:
		 tmd.MakeSelFacesPlanar (GetMesh(), GetMesh().faceSel);
		 break;
	}

	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_MAKEPLANAR));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Collapse () {
	if (selLevel == SL_OBJECT) return;
	theHold.Begin();

	MeshDelta tmd (GetMesh());
	switch (selLevel) {
	case SL_EDGE:
		tmd.CollapseEdges (GetMesh(), GetMesh().edgeSel, TempData()->AdjEList());
		break;
	default:
		tmd.WeldVertSet (GetMesh(), GetMesh().VertexTempSel());
		break;
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());

	theHold.Accept(GetString(IDS_RB_COLLAPSE));	
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Tessellate (float tens,BOOL edge) {
	if (selLevel < SL_FACE) return;
	theHold.Begin();

	MeshDelta tmd;
	if (edge) tmd.EdgeTessellate (GetMesh(), GetMesh().faceSel, tens, TempData()->AdjEList(), TempData()->AdjFList());
	else tmd.DivideFaces (GetMesh(), GetMesh().faceSel);
	ApplyMeshDelta (tmd, this, ip->GetTime());

	theHold.Accept(GetString(IDS_RB_TESSELLATE));	
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Explode (float thresh, BOOL objs, TSTR &name) {
	INodeTab nodes;
	ModContextList mcList;
	ip->GetModContexts(mcList,nodes);
	theHold.Begin();

	AdjFaceList *af = TempData()->AdjFList();
	MeshDelta tmd;
	if (!objs) tmd.ExplodeFaces (GetMesh(), thresh, (selLevel>=SL_FACE), af);
	else {
		theHold.Put (new MeshSelRestore (this));
		ExplodeToObjects (&GetMesh(), thresh, nodes[0], name, ip, &tmd, af, selLevel>=SL_FACE);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());

	theHold.Accept(GetString(IDS_RB_EXPLODE));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::Slice () {
	Matrix3 rotMatrix;
	sliceRot.MakeMatrix (rotMatrix);
	theHold.Begin ();

	Point3 N = Point3(0.0f,0.0f,1.0f) * rotMatrix;
	float offset = DotProd (N, sliceCenter);

	MeshDelta tmd;
	if (selLevel >= SL_FACE) tmd.Slice (GetMesh(), N, offset, sliceSplit, FALSE, &(GetMesh().faceSel));
	else tmd.Slice (GetMesh(), N, offset, sliceSplit, FALSE);
	ApplyMeshDelta (tmd, this, ip->GetTime());

	theHold.Accept (GetString (IDS_SCA_SLICE));
	ip->RedrawViews(ip->GetTime());	
}

BOOL EditTriObject::WeldVerts (float thresh) {
	if (GetMesh().vertSel.NumberSet()<1) return FALSE;
	theHold.Begin();
	MeshDelta tmd(GetMesh());
	BOOL found = tmd.WeldByThreshold (GetMesh(), GetMesh().vertSel, thresh);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_WELDVERTS));	
	ip->RedrawViews(ip->GetTime());
	return found;
}

void EditTriObject::WeldVerts (Point3 pt) {
	theHold.Begin();
	MeshDelta tmd(GetMesh());
	tmd.WeldVertSet (GetMesh(), GetMesh().vertSel, &pt);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_WELDVERTS));	
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::RemoveIsoVerts() {
	theHold.Begin();
	MeshDelta tmd(GetMesh());
	tmd.DeleteIsoVerts (GetMesh());
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_DELETEISO));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::SelectOpenEdges() {
	theHold.Begin();
	BitArray nesel;
	GetMesh().FindOpenEdges (nesel);
	SetEdgeSel (nesel, this, ip->GetTime());
	LocalDataChanged ();
	theHold.Accept(GetString(IDS_RB_SELOPENEDGES));
	ip->RedrawViews(ip->GetTime());	
}

// Vertex surface operations:

float EditTriObject::GetWeight (TimeValue t, int *numSel) {
	if (numSel) *numSel = GetMesh().vertSel.NumberSet();
	if (selLevel != SL_VERTEX) return 1.0f;
	float *vw = GetMesh().getVertexWeights ();
	if (!vw) return 1.0f;
	float weight;
	int found=0;
	for (int j=0; j< GetMesh().numVerts; j++) {
		if (!GetMesh().vertSel[j]) continue;
		if (!found) {
			weight = vw[j];
			found++;
		}
		else if (weight != vw[j]) weight = -1.0f;
	}
	return weight;
}

void EditTriObject::UpdateWeightDisplay (TimeValue t, HWND hWnd) {
	if (selLevel != SL_VERTEX) return;
	ISpinnerControl *spin = GetISpinner (GetDlgItem (hWnd, IDC_EM_WEIGHTSPIN));
	if (!spin) return;

	int num;
	float weight = GetWeight (t, &num);

	if (num == 0) {	// Nothing selected
		// Simply disable weight stuff & return
		spin->Disable ();
		EnableWindow (GetDlgItem (hWnd,	IDC_WEIGHT_LABEL), FALSE);
		ReleaseISpinner(spin);
		return;
	}

	spin->Enable ();
	EnableWindow (GetDlgItem (hWnd,	IDC_WEIGHT_LABEL), TRUE);

	// Set the actual weight:
	if (weight<0) {	// Verts don't have the same weight.
		spin->SetIndeterminate (TRUE);
		ReleaseISpinner(spin);
	} else {
		spin->SetIndeterminate(FALSE);
		spin->SetValue (weight, FALSE);
		ReleaseISpinner(spin);
	}
}

void EditTriObject::SetWeight (TimeValue t, float weight) {
	if (selLevel != SL_VERTEX) return;
	if (weight < MIN_WEIGHT) weight = MIN_WEIGHT;
	if (!GetMesh().vertSel.NumberSet()) return;

	MeshDelta tmd (GetMesh());
	tmd.SetVertWeights (GetMesh(), GetMesh().vertSel, weight);
	tmd.Apply (GetMesh());	// NOTE: not using ApplyMeshDelta; no undo support.
	NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews (t);
}

void EditTriObject::ResetWeights (TimeValue t) {
	if (selLevel != SL_VERTEX) return;
	MeshDelta tmd (GetMesh());
	tmd.ResetVertWeights (GetMesh());
	ApplyMeshDelta (tmd, this, t);
	NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews (t);
}

Color EditTriObject::GetVertColor () {
	static Color white(1,1,1), black(0,0,0);

	Color col=black;
	BOOL init=FALSE;

	TVFace *cf = GetMesh().mapFaces(0);
	UVVert *cv = GetMesh().mapVerts(0);
	if (!cf) return white;

	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		DWORD *tt = cf[i].t;
		DWORD *vv = GetMesh().faces[i].v;
		for (int j=0; j<3; j++) {
			if (!GetMesh().vertSel[vv[j]]) continue;
			if (!init) {
				col = cv[tt[j]];
				init = TRUE;
			} else {
				Color ac = cv[tt[j]];
				if (ac!=col) return black;
			}
		}
	}
	return col;
}

void EditTriObject::SetVertColor (Color clr) {
	if (GetMesh().vertSel.NumberSet()==0) return;
	MeshDelta tmd(GetMesh());
	tmd.SetVertColors (GetMesh(), GetMesh().vertSel, clr);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::SelectVertByColor (VertColor clr, int deltaR, int deltaG, int deltaB, BOOL add, BOOL sub) {
	if (!GetMesh().vcFace) return;
	float dr = float(deltaR)/255.0f;
	float dg = float(deltaG)/255.0f;
	float db = float(deltaB)/255.0f;

	theHold.Begin();
	TVFace *cf = GetMesh().mapFaces(0);
	UVVert *cv = GetMesh().mapVerts(0);

	BitArray nvs;
	if (add || sub) {
		nvs = GetMesh().vertSel;
		nvs.SetSize (GetMesh().numVerts, TRUE);
	} else {
		nvs.SetSize (GetMesh().numVerts);
		nvs.ClearAll();
	}

	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		for (int j=0; j<3; j++) {
			Point3 col = cv[cf[i].t[j]];
			if ((float)fabs(col.x-clr.x) > dr) continue;
			if ((float)fabs(col.y-clr.y) > dg) continue;
			if ((float)fabs(col.z-clr.z) > db) continue;
			if (sub) nvs.Clear(GetMesh().faces[i].v[j]);
			else nvs.Set(GetMesh().faces[i].v[j]);
		}
	}
	SetVertSel (nvs, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_SELBYCOLOR));
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

// Edge surface operations:

void EditTriObject::SetEdgeVis(BOOL vis) {
	theHold.Begin();
	AdjFaceList *af = TempData()->AdjFList ();
	MeshDelta tmd(GetMesh());
	int maxedge = GetMesh().numFaces*3;
	for (int j=0; j<maxedge; j++) {
		if (GetMesh().edgeSel[j]) tmd.SetSingleEdgeVis (GetMesh(), j, vis, af);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());
	if (vis) theHold.Accept(GetString(IDS_RB_EDGEVISIBLE));
	else theHold.Accept(GetString(IDS_RB_EDGEINVISIBLE));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::AutoEdge (float thresh, int type) {
	theHold.Begin();
	
	AdjEdgeList *ae = TempData()->AdjEList();
	AdjFaceList *af = TempData()->AdjFList();
	Tab<MEdge> &edges = ae->edges;

	MeshDelta tmd(GetMesh());
	for (int j=0; j<edges.Count(); j++) {
		if (!edges[j].Selected(GetMesh().faces,GetMesh().edgeSel)) continue;
		BOOL vis = (thresh==0.0f) || GetMesh().AngleBetweenFaces(edges[j].f[0], edges[j].f[1]) > thresh;
		if ((type == 1) && !vis) continue;
		if ((type == 2) && vis) continue;
		if (edges[j].f[0]!=UNDEFINED) {
			int e = GetMesh().faces[edges[j].f[0]].GetEdgeIndex(edges[j].v[0],edges[j].v[1]);
			tmd.SetSingleEdgeVis (GetMesh(), edges[j].f[0]*3+e, vis, af);
			continue;
		}
		assert (edges[j].f[1]!=UNDEFINED);
		int e = GetMesh().faces[edges[j].f[1]].GetEdgeIndex(edges[j].v[0],edges[j].v[1]);
		tmd.SetSingleEdgeVis (GetMesh(), edges[j].f[1]*3+e, vis, af);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());

	theHold.Accept(GetString(IDS_RB_AUTOEDGE));
	ip->RedrawViews(ip->GetTime());
}

// Face surface operations:

void EditTriObject::ShowNormals() {
	if ((normScale>0.0f) && (selLevel>SL_OBJECT)) GetMesh().displayNormals(TRUE,normScale);
	else GetMesh().displayNormals (FALSE, normScale);
	GetMesh().buildBoundingBox ();
	NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews (ip->GetTime());
}

void EditTriObject::FlipNormals() {
	theHold.Begin();
	MeshDelta tmd(GetMesh());
	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		if (GetMesh().faceSel[i]) tmd.FlipNormal (GetMesh(), i);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_FLIPNORMALS));	
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::UnifyNormals() {
	theHold.Begin();
	AdjFaceList *af = TempData()->AdjFList ();
	MeshDelta tmd (GetMesh());
	tmd.UnifyNormals (GetMesh(), GetMesh().faceSel, af);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept (GetString(IDS_RB_UNIFYNORMALS));
	ip->RedrawViews (ip->GetTime());
}

DWORD EditTriObject::GetMatIndex() {
	DWORD mat = UNDEFINED;
	for (int j=0; j<GetMesh().getNumFaces(); j++) {
		if (!GetMesh().faceSel[j]) continue;
		if (mat==UNDEFINED) mat = GetMesh().getFaceMtlIndex(j);
		else if (GetMesh().getFaceMtlIndex(j) != mat) return UNDEFINED;
	}
	return mat;
}

// Note: good reasons for handling theHold.Begin/Accept at higher level.
void EditTriObject::SetMatIndex (DWORD index) {
	MeshDelta tmd(GetMesh());
	for (int j=0; j<GetMesh().getNumFaces(); j++) {
		if (GetMesh().faceSel[j]) tmd.SetMatID (j,(MtlID)index);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::SelectByMat (DWORD index,BOOL clear) {
	theHold.Begin();
	BitArray ns;
	if (clear) {
		ns.SetSize (GetMesh().numFaces);
		ns.ClearAll ();
	} else {
		ns = GetMesh().faceSel;
		if (ns.GetSize() != GetMesh().numFaces) ns.SetSize (GetMesh().numFaces, TRUE);
	}
	for (int j=0; j<GetMesh().getNumFaces(); j++) {
		if (GetMesh().getFaceMtlIndex(j)==index) ns.Set(j);
	}
	SetFaceSel (ns, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_SELECTBYMATID));
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

DWORD EditTriObject::GetUsedSmoothBits() {
	DWORD bits = 0;
	for (int j=0; j<GetMesh().getNumFaces(); j++)
		bits |= GetMesh().faces[j].smGroup;
	return bits;
}

// Those bits used by ANY selected faces are set in "some".
// Those bits used by ALL selected faces are set in the return value.
DWORD EditTriObject::GetSelSmoothBits(DWORD &some) {
	DWORD all = ~0;
	some = 0;
	if (!GetMesh().faceSel.NumberSet()) return 0;
	for (int j=0; j<GetMesh().getNumFaces(); j++) {
		if (!GetMesh().faceSel[j]) continue;
		some |= GetMesh().faces[j].smGroup;
		all &= GetMesh().faces[j].smGroup;
	}
	return all;
}

void EditTriObject::SetSelSmoothBits (DWORD bits, DWORD mask) {
	theHold.Begin();
	bits &= mask;
	MeshDelta tmd(GetMesh());
	for (int j=0; j<GetMesh().getNumFaces(); j++) {			
		if (!GetMesh().faceSel[j]) continue;
		tmd.FSmooth (j, mask, bits);
	}
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_SETSMOOTHGROUP));
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::SelectBySmoothGroup(DWORD bits,BOOL clear) {
	theHold.Begin();
	BitArray nfs;
	if (clear) {
		nfs.SetSize (GetMesh().getNumFaces());
		nfs.ClearAll ();
	} else {
		nfs = GetMesh().faceSel;
		nfs.SetSize (GetMesh().getNumFaces(), TRUE);
	}
	for (int j=0; j<GetMesh().getNumFaces(); j++) {
		if (GetMesh().faces[j].smGroup & bits) nfs.Set(j);
	}
	SetFaceSel (nfs, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_SELECTBYSMOOTH));
	LocalDataChanged ();
	ip->RedrawViews (ip->GetTime());
}

void EditTriObject::AutoSmooth(float thresh) {
	theHold.Begin();
	MeshDelta tmd(GetMesh());
	AdjEdgeList *ae = TempData()->AdjEList();
	AdjFaceList *af = TempData()->AdjFList();
	tmd.AutoSmooth (GetMesh(), GetMesh().faceSel, thresh, af, ae);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_AUTOSMOOTH));
	ip->RedrawViews(ip->GetTime());
}

Color EditTriObject::GetFaceColor () {
	static Color white(1,1,1), black(0,0,0);

	if (!GetMesh().vcFace) return white;
	BOOL init=FALSE;
	Color col=white;

	TVFace *cf = GetMesh().mapFaces(0);
	UVVert *cv = GetMesh().mapVerts(0);

	for (int i=0; i<GetMesh().getNumFaces(); i++) {
		if (!GetMesh().faceSel[i]) continue;
		DWORD *tt = cf[i].t;
		for (int j=0; j<3; j++) {
			if (!init) {
				col = cv[tt[j]];
				init = TRUE;
			} else {
				Color ac = cv[tt[j]];
				if (ac!=col) return black;
			}
		}
	}
	return col;
}

void EditTriObject::SetFaceColor(Color c) {
	if (GetMesh().faceSel.NumberSet() == 0) return;
	MeshDelta tmd(GetMesh());
	tmd.SetFaceColors (GetMesh(), GetMesh().faceSel, c);
	ApplyMeshDelta (tmd, this, ip->GetTime());
	ip->RedrawViews(ip->GetTime());
}

//----Globals----------------------------------------------
// Move to class Interface or someplace someday?

void ExplodeToObjects (Mesh *mesh, float thresh, INode *node, TSTR &name,
					   Interface *ip, MeshDelta *tmd, AdjFaceList *af, BOOL selOnly) {  
	FaceClusterList fc(mesh, *af, thresh, selOnly);
	if (!selOnly || (mesh->faceSel.NumberSet() == mesh->numFaces)) {
		if (fc.count==1) return;	// nothing to do -- all in one cluster.
		if (!selOnly) mesh->faceSel.SetAll ();
		for (int i=0; i<mesh->numFaces; i++) if (fc[i] == fc.count-1) mesh->faceSel.Clear (i);
		fc.count--;
	}

	// For speed, make face-lists for each cluster:
	int j,k, mp;
	DWORD i;
	DWORDTab *flist = new DWORDTab[fc.count];
	for (i=0; i<(DWORD)mesh->numFaces; i++) {
		if (!mesh->faceSel[i]) continue;
		flist[fc[i]].Append (1, &i, 10);
	}

	// Make used, lookup arrays big enough to hold verts or any mapping vert set.
	int vsize = mesh->numVerts;
	for (mp=0; mp<mesh->getNumMaps(); mp++) {
		if (!mesh->mapSupport(mp)) continue;
		if (mesh->getNumMapVerts (mp) > vsize) vsize = mesh->getNumMapVerts(mp);
	}
	BitArray usedVerts;
	usedVerts.SetSize (vsize);
	DWORD *vlut = new DWORD[vsize];

	// Transfer all clusters to new meshes.
	for (i=0; i<fc.count; i++) {
		if (flist[i].Count() < 1) continue;	// shouldn't happen.

		usedVerts.ClearAll();
		for (j=0; j<flist[i].Count(); j++) {
			DWORD *vv = mesh->faces[flist[i][j]].v;
			usedVerts.Set (vv[0]);
			usedVerts.Set (vv[1]);
			usedVerts.Set (vv[2]);
		}

		TriObject *newObj = CreateNewTriObject();
		Mesh *newMesh = &newObj->GetMesh();
		newMesh->setNumVerts(usedVerts.NumberSet());
		newMesh->setNumFaces(flist[i].Count());
		for (j=0,k=0; j<mesh->numVerts; j++) {
			if (!usedVerts[j]) continue;
			newMesh->verts[k] = mesh->verts[j];
			vlut[j] = k++;
		}
		for (j=0; j<flist[i].Count(); j++) {
			Face & f = mesh->faces[flist[i][j]];
			newMesh->faces[j] = f;
			for (k=0; k<3; k++) newMesh->faces[j].v[k] = vlut[f.v[k]];
		}

		// Handle mapping.
		newMesh->setNumMaps (mesh->getNumMaps ());
		for (mp=0; mp<mesh->getNumMaps(); mp++) {
			if (!mesh->mapSupport(mp)) {
				newMesh->setMapSupport (mp, FALSE);
				continue;
			}
			newMesh->setMapSupport (mp, TRUE);

			TVFace *mapf = mesh->mapFaces(mp);
			UVVert *mapv = mesh->mapVerts(mp);
			TVFace *nmapf = newMesh->mapFaces(mp);
			usedVerts.ClearAll ();
			for (j=0; j<flist[i].Count(); j++) {
				DWORD *vv = mapf[flist[i][j]].t;
				usedVerts.Set (vv[0]);
				usedVerts.Set (vv[1]);
				usedVerts.Set (vv[2]);
			}

			newMesh->setNumMapVerts (mp, usedVerts.NumberSet());
			for (j=0,k=0; j<mesh->getNumMapVerts(mp); j++) {
				if (!usedVerts[j]) continue;
				newMesh->setMapVert (mp, k, mapv[j]);
				vlut[j] = k++;
			}
			for (j=0; j<flist[i].Count(); j++) {
				TVFace & f = mapf[flist[i][j]];
				nmapf[j] = f;
				for (k=0; k<3; k++) nmapf[j].t[k] = vlut[f.t[k]];
			}
		}

		INode *newNode = ip->CreateObjectNode(newObj);
		Matrix3 ntm = node->GetNodeTM(ip->GetTime());
		TSTR uname = name;
		ip->MakeNameUnique(uname);
		newNode->SetName(uname);
		newNode->SetNodeTM (ip->GetTime(), ntm);
		newNode->FlagForeground (ip->GetTime(), FALSE);
		newNode->SetMtl (node->GetMtl());
		newNode->SetObjOffsetPos (node->GetObjOffsetPos());
		newNode->SetObjOffsetRot (node->GetObjOffsetRot());
		newNode->SetObjOffsetScale (node->GetObjOffsetScale());
	}
	delete [] vlut;
	delete [] flist;

	// Finally, set up meshdelta to delete components from this mesh.
	tmd->ClearAllOps ();
	tmd->InitToMesh (*mesh);
	BitArray vdel;
	mesh->FindVertsUsedOnlyByFaces (mesh->faceSel, vdel);
	tmd->FDelete (mesh->faceSel);
	tmd->VDelete (vdel);
}

BOOL CreateCurveFromMeshEdges (Mesh & mesh, INode *onode, Interface *ip, AdjEdgeList *ae,
							   TSTR & name, BOOL curved, BOOL ignoreHiddenEdges) {
	if (!mesh.edgeSel.NumberSet()) return FALSE;

	SuspendAnimate();
	AnimateOff();	

	SplineShape *shape = (SplineShape*)GetSplineShapeDescriptor()->Create(0);	

	BitArray done;
	done.SetSize(ae->edges.Count());

	// Mark hidden edges as done to ignore them
	if (ignoreHiddenEdges) {
		for (int i=0; i<ae->edges.Count(); i++) {
			if (!ae->edges[i].Visible(mesh.faces)) done.Set(i);
		}
	}

	for (int i=0; i<ae->edges.Count(); i++) {
		if (done[i]) continue;
		if (!ae->edges[i].Selected (mesh.faces,mesh.edgeSel)) continue;
			
		// The array of points for the spline
		Tab<Point3> pts;
		
		// Add the first two points.
		pts.Append(1,&mesh.verts[ae->edges[i].v[0]],10);
		pts.Append(1,&mesh.verts[ae->edges[i].v[1]],10);
		int nextv = ae->edges[i].v[1], start = ae->edges[i].v[0];
		
		// Mark this edge as done
		done.Set(i);

		// Trace along selected edges
		while (1) {
			DWORDTab &ve = ae->list[nextv];
			for (int j=0; j<ve.Count(); j++) {
				if (done[ve[j]]) continue;
				if (ae->edges[ve[j]].Selected(mesh.faces,mesh.edgeSel)) break;
			}
			if (j==ve.Count()) break;
			if (ae->edges[ve[j]].v[0]==(DWORD)nextv) nextv = (int)ae->edges[ve[j]].v[1];
			else nextv = ae->edges[ve[j]].v[0];

			// Mark this edge as done
			done.Set(ve[j]);

			// Add this vertex to the list
			pts.Append(1,&mesh.verts[nextv],10);
		}
		int lastV = nextv;

		// Now trace backwards
		nextv = start;
		while (1) {
			DWORDTab &ve = ae->list[nextv];
			for (int j=0; j<ve.Count(); j++) {
				if (done[ve[j]]) continue;
				if (ae->edges[ve[j]].Selected(mesh.faces,mesh.edgeSel)) break;
			}
			if (j==ve.Count()) break;
			if (ae->edges[ve[j]].v[0]==(DWORD)nextv) nextv = (int)ae->edges[ve[j]].v[1];
			else nextv = ae->edges[ve[j]].v[0];

			// Mark this edge as done
			done.Set(ve[j]);

			// Add this vertex to the list
			pts.Insert(0,1,&mesh.verts[nextv]);
		}
		int firstV = nextv;

		// Now weve got all th points. Create the spline and add points
		Spline3D *spline = new Spline3D(KTYPE_AUTO,KTYPE_BEZIER);					
		int max = pts.Count();
		if (firstV == lastV) {
			max--;
			spline->SetClosed ();
		}
		if (curved) {
			for (int j=0; j<max; j++) {
				int prvv = j ? j-1 : ((firstV==lastV) ? max-1 : 0);
				int nxtv = (max-1-j) ? j+1 : ((firstV==lastV) ? 0 : max-1);
				float prev_length = Length(pts[j] - pts[prvv])/3.0f;
				float next_length = Length(pts[j] - pts[nxtv])/3.0f;
				Point3 tangent = Normalize (pts[nxtv] - pts[prvv]);
				SplineKnot sn (KTYPE_BEZIER, LTYPE_CURVE, pts[j],
						pts[j] - prev_length*tangent, pts[j] + next_length*tangent);
				spline->AddKnot(sn);
			}
		} else {
			for (int j=0; j<max; j++) {
				SplineKnot sn(KTYPE_CORNER, LTYPE_LINE, pts[j],pts[j],pts[j]);
				spline->AddKnot(sn);
			}
			spline->ComputeBezPoints();
		}
		shape->shape.AddSpline(spline);
	}

	shape->shape.InvalidateGeomCache();
	shape->shape.UpdateSels();

	INode *node = ip->CreateObjectNode (shape);
	INode *nodeByName = ip->GetINodeByName (name);
	if (nodeByName != node) {
		if (nodeByName) ip->MakeNameUnique(name);
		node->SetName (name);
	}
	Matrix3 ntm = onode->GetNodeTM(ip->GetTime());
	node->SetNodeTM (ip->GetTime(),ntm);
	node->FlagForeground (ip->GetTime(),FALSE);
	node->SetMtl (onode->GetMtl());
	node->SetObjOffsetPos (onode->GetObjOffsetPos());
	node->SetObjOffsetRot (onode->GetObjOffsetRot());
	node->SetObjOffsetScale (onode->GetObjOffsetScale());	
	ResumeAnimate();
	ip->RedrawViews(ip->GetTime());
	return TRUE;
}

/*------------Command modes & Mouse procs----------------------*/

HitRecord *PickEdgeMouseProc::HitTestEdges (IPoint2 &m, ViewExp *vpt, float *prop, Point3 *snapPoint) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	if (!hr) return hr;
	if (!prop) return hr;

	// Find where along this edge we hit
	// Strategy:
	// Get Mouse click, plus viewport z-direction at mouse click, in object space.
	// Then find the direction of the edge in a plane orthogonal to z, and see how far
	// along that edge we are.

	DWORD ee = hr->hitInfo;
	Matrix3 obj2world = hr->nodeRef->GetObjectTM (ip->GetTime ());

	Ray r;
	vpt->MapScreenToWorldRay ((float)m.x, (float)m.y, r);
	if (!snapPoint) snapPoint = &(r.p);
	Point3 Zdir = Normalize (r.dir);

	Mesh *mm = &(et->GetMesh());
	Point3 A = obj2world * mm->verts[mm->faces[ee/3].v[ee%3]];
	Point3 B = obj2world * mm->verts[mm->faces[ee/3].v[(ee+1)%3]];
	Point3 Xdir = B-A;
	Xdir -= DotProd(Xdir, Zdir)*Zdir;
	*prop = DotProd (Xdir, *snapPoint-A) / LengthSquared (Xdir);
	if (*prop<.0001f) *prop=0;
	if (*prop>.9999f) *prop=1;
	return hr;
}

int PickEdgeMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	ViewExp *vpt;
	HitRecord *hr;
	float prop;
	Point3 snapPoint;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport(hwnd);
		snapPoint = vpt->SnapPoint (m, m, NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		hr = HitTestEdges (m, vpt, &prop, &snapPoint);
		if (vpt) ip->ReleaseViewport(vpt);
		if (hr) EdgePick(hr->hitInfo, prop);
		break;
	
	case MOUSE_MOVE:
	case MOUSE_FREEMOVE:			
		vpt = ip->GetViewport(hwnd);
		vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);//|SNAP_SEL_OBJS_ONLY);
		if (HitTestEdges(m,vpt,NULL,NULL)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));		
		if (vpt) ip->ReleaseViewport(vpt);
		break;
	}

	return TRUE;	
}

// --------------------------------------------------------

HitRecord *PickFaceMouseProc::HitTestFaces (IPoint2 &m, ViewExp *vpt, float *bary, Point3 *snapPoint=NULL) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	if (!hr) return hr;
	if (!bary) return hr;

	// Find barycentric coordinates of hit in face.
	// Strategy:
	// Get Mouse click, plus viewport z-direction at mouse click, in object space.
	// Then find face coords in a plane orthogonal to z, and compare hit to points.

	DWORD ff = hr->hitInfo;
	Matrix3 obj2world = hr->nodeRef->GetObjectTM (ip->GetTime ());

	Ray r;
	vpt->MapScreenToWorldRay ((float)m.x, (float)m.y, r);
	if (!snapPoint) snapPoint = &(r.p);
	Point3 Zdir = Normalize (r.dir);

	Mesh *mm = &(et->GetMesh());
	Point3 A = obj2world * mm->verts[mm->faces[ff].v[0]];
	Point3 B = obj2world * mm->verts[mm->faces[ff].v[1]];
	Point3 C = obj2world * mm->verts[mm->faces[ff].v[2]];
	Point3 Xdir = B-A;
	Xdir = Normalize (Xdir - DotProd(Xdir, Zdir)*Zdir);
	Point3 Ydir = Zdir^Xdir;	// orthonormal basis
	bary[2] = DotProd (*snapPoint-A, Ydir) / DotProd (C-A, Ydir);
	if (bary[2] < .0001f) bary[2] = 0.f;
	if (bary[2] > .9999f) {
		bary[2] = 1.0f;
		bary[0] = bary[1] = 0.0f;
		return hr;
	}
	A += bary[2] * (C-A);
	B += bary[2] * (C-B);
	bary[1] = DotProd (Xdir, *snapPoint-A) / DotProd (Xdir, B-A);
	bary[1] *= (1.0f-bary[2]);
	if (bary[1] < .0001f) bary[1] = 0.f;
	if (bary[1] > .9999f) bary[1] = 1.f;
	if (bary[1] + bary[2] > .9999f) {
		float prop = 1.0f / (bary[1] + bary[2]);
		bary[1] *= prop;
		bary[2] *= prop;
		bary[0] = 0.0f;
		return hr;
	}
	bary[0] = 1.0f - bary[1] - bary[2];
	return hr;
}

int PickFaceMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	ViewExp *vpt;
	HitRecord *hr;
	float bary[3];
	Point3 snapPoint;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport(hwnd);
		snapPoint = vpt->SnapPoint (m, m, NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		hr = HitTestFaces (m, vpt, bary, &snapPoint);
		if (vpt) ip->ReleaseViewport(vpt);
		if (hr) FacePick (hr->hitInfo, bary);
		break;

	case MOUSE_MOVE:
	case MOUSE_FREEMOVE:			
		vpt = ip->GetViewport(hwnd);
		vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);//|SNAP_SEL_OBJS_ONLY);
		if (HitTestFaces(m,vpt,NULL)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));		
		if (vpt) ip->ReleaseViewport(vpt);
		break;			
	}

	return TRUE;	
}

// -------------------------------------------------------

static HCURSOR hCurCreateVert = NULL;

void CreateVertCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CREATE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void CreateVertCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CREATE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

int CreateVertMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	if (!hCurCreateVert) hCurCreateVert = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ADDVERTCUR)); 

	ViewExp *vpt = ip->GetViewport (hwnd);
	Matrix3 ctm;
	Point3 pt;
	IPoint2 m2;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt->GetConstructionTM(ctm);
		pt = vpt->SnapPoint (m, m2, &ctm);
		pt = pt * ctm;
		et->CreateVertex(pt);
		break;

	case MOUSE_FREEMOVE:
		SetCursor(hCurCreateVert);
		vpt->SnapPreview(m, m, NULL, SNAP_FORCE_3D_RESULT);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

//----------------------------------------------------------

void CreateFaceCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CREATE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	et->inBuildFace = TRUE;
	if (!et->ip->GetShowEndResult()) {
		et->GetMesh().dispFlags |= (DISP_VERTTICKS|DISP_SELVERTS);
	}
	et->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	et->ip->RedrawViews(et->ip->GetTime());
}

void CreateFaceCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CREATE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	et->inBuildFace = FALSE;
	et->GetMesh().dispFlags &= ~(DISP_VERTTICKS|DISP_SELVERTS);
	et->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	et->ip->RedrawViews(et->ip->GetTime());
}

CreateFaceMouseProc::CreateFaceMouseProc (EditTriObject* e, IObjParam *i) {
	et = e;
	ip = i;	
	pt = 0;
}

// We assume the transform, color, render style, etc, has been set up in advance.
void CreateFaceMouseProc::DrawEstablishedFace (GraphicsWindow *gw) {
	if (pt<2) return;
	Tab<Point3> rverts;
	rverts.SetCount (pt+1);
	for (int j=0; j<pt; j++) {
		rverts[j] = et->GetMesh().verts[vts[j]];
	}
	gw->polyline (pt, rverts.Addr(0), NULL, NULL, FALSE, NULL);
}

void CreateFaceMouseProc::DrawCreatingFace (HWND hWnd, const IPoint2 & m) {
	if (pt<1) return;

	HDC hdc = GetDC(hWnd);
	SetROP2(hdc, R2_XORPEN);
	SetBkMode(hdc, TRANSPARENT);
	SelectObject(hdc,CreatePen(PS_DOT, 0, RGB(255,255,255)));

	MoveToEx (hdc, mfirst.x, mfirst.y, NULL);
	LineTo (hdc, m.x, m.y);
	if (pt>1) LineTo (hdc, mlast.x, mlast.y);

	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	ReleaseDC(hWnd, hdc);
}

BOOL CreateFaceMouseProc::HitTestVerts (IPoint2 m, ViewExp *vpt, int &v) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return FALSE;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	assert(hr);
	if (et->selLevel != SL_POLY) {
		for (int i=0; i<pt; i++) if (vts[i]==(int)hr->hitInfo) return FALSE;
	}
	v = hr->hitInfo;
	return TRUE;
}

int CreateFaceMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {	
	if (!hCurCreateVert) hCurCreateVert = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ADDVERTCUR));

	ViewExp *vpt = ip->GetViewport(hwnd);
	int dummyVert;
	int nv, lpt;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (point==1) break;
		ip->SetActiveViewport(hwnd);
		bool done;
		done=FALSE;

		if (HitTestVerts(m, vpt, nv)) {
			HitLog& hitLog = vpt->GetSubObjHitList();
			HitRecord *hr = hitLog.ClosestHit();
			MaxAssert (hr);
			for (int j=0; j<pt; j++) if (vts[j] == nv) break;
			if (j<pt) done=TRUE;
			else {
				vts.Append (1, &nv, 20);
				if (pt==0) mfirst = m;
				else mlast = m;
				pt++;
				et->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				ip->RedrawViews (ip->GetTime());
				oldm = m;
				DrawCreatingFace(hwnd, m);
			}
		} else {
			if (!(flags & MOUSE_SHIFT)) {
				ip->ReleaseViewport(vpt);
				if (!pt) return FALSE;
				else return TRUE;
			}
			Matrix3 ctm;
			vpt->GetConstructionTM(ctm);
			Point3 newpt = vpt->SnapPoint(m,m,&ctm, SNAP_FORCE_3D_RESULT|SNAP_SEL_SUBOBJ_ONLY);
			newpt = newpt * ctm;
			nv = et->GetMesh().numVerts;

			vts.Append (1, &nv, 20);
			if (pt==0) mfirst = m;
			else mlast = m;
			pt++;
			et->CreateVertex(newpt);
			oldm = m;
			DrawCreatingFace(hwnd, m);
		}

		if ((et->selLevel != SL_POLY) && (pt==3)) done = TRUE;

		if (done) {
			// We're done collecting verts - build a face
			lpt = pt;
			pt = 0;	// so the redraw gets that we're done.
			if ((lpt>2) && (!et->CreateFace(vts.Addr(0), lpt))) {
				InvalidateRect(vpt->getGW()->getHWnd(),NULL,FALSE);
				TSTR buf1 = GetString(IDS_RB_DUPFACEWARNING);
				TSTR buf2 = GetString(IDS_SCA_BASE_MESH);
				MessageBox(et->ip->GetMAXHWnd(),buf1,buf2,MB_OK|MB_ICONINFORMATION);						
				et->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				ip->RedrawViews (ip->GetTime());
			}
			vts.SetCount(0);
			ip->ReleaseViewport (vpt);
			return FALSE;
		}
		break;

	case MOUSE_MOVE:
		if (pt) DrawCreatingFace (hwnd, oldm);	// Erase old outline
		if (HitTestVerts(m,vpt,dummyVert))
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else {
			if (flags & MOUSE_SHIFT) {
				SetCursor(hCurCreateVert);
				vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT|SNAP_SEL_SUBOBJ_ONLY);
				ip->RedrawViews (ip->GetTime());
			} else SetCursor (ip->GetSysCursor (SYSCUR_DEFARROW));
		}
		if (pt) {
			oldm = m;
			DrawCreatingFace (hwnd, oldm);
		}
		break;

	case MOUSE_FREEMOVE:
		if (HitTestVerts(m,vpt,dummyVert))
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else {
			if (flags & MOUSE_SHIFT) {
				SetCursor(hCurCreateVert);
				vpt->SnapPreview (m, m, NULL, SNAP_SEL_SUBOBJ_ONLY|SNAP_FORCE_3D_RESULT);
			} else SetCursor (ip->GetSysCursor (SYSCUR_DEFARROW));
		}
		break;

	case MOUSE_ABORT:
		pt = 0;
		vts.SetCount(0);
		et->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
		ip->RedrawViews (ip->GetTime());
		break;
	}

	ip->ReleaseViewport(vpt);
	return TRUE;
}

/*-----------------------------------------------------------------------*/

BOOL AttachPickMode::Filter(INode *node) {
	if (!node) return FALSE;

	// Make sure the node does not depend on us
	node->BeginDependencyTest();
	eo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) return TRUE;
	if (os.obj->CanConvertToType(triObjectClassID)) return TRUE;
	return FALSE;
}

BOOL AttachPickMode::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,int flags) {
	return ip->PickNode(hWnd,m,this) ? TRUE : FALSE;
}

BOOL AttachPickMode::Pick(IObjParam *ip,ViewExp *vpt) {
	INode *node = vpt->GetClosestHit();
	if (!Filter(node)) return FALSE;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	BOOL ret = TRUE;
	if (nodes[0]->GetMtl() && node->GetMtl() && (nodes[0]->GetMtl()!=node->GetMtl())) {
		ret = DoAttachMatOptionDialog (ip, eo);
	}
	nodes.DisposeTemporary ();
	if (!ret) return FALSE;
	if (!eo->ip) return FALSE;

	bool canUndo = TRUE;
	eo->Attach (node, canUndo);
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	ip->RedrawViews(ip->GetTime());
	return FALSE;
}

void AttachPickMode::EnterMode(IObjParam *ip) {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton (GetDlgItem (eo->hGeom,IDC_OBJ_ATTACH));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void AttachPickMode::ExitMode(IObjParam *ip) {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_OBJ_ATTACH));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// -----------------------------

int AttachHitByName::filter(INode *node) {
	if (!node) return FALSE;

	// Make sure the node does not depend on this modifier.
	node->BeginDependencyTest();
	eo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	ObjectState os = node->GetObjectRef()->Eval(eo->ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) return TRUE;
	if (os.obj->CanConvertToType(triObjectClassID)) return TRUE;
	return FALSE;
}

void AttachHitByName::proc(INodeTab &nodeTab) {
	if (inProc) return;
	inProc = TRUE;
	ModContextList mcList;
	INodeTab nodes;
	eo->ip->GetModContexts (mcList, nodes);
	BOOL ret = TRUE;
	if (nodes[0]->GetMtl()) {
		for (int i=0; i<nodeTab.Count(); i++) {
			if (nodeTab[i]->GetMtl() && (nodes[0]->GetMtl()!=nodeTab[i]->GetMtl())) break;
		}
		if (i<nodeTab.Count()) ret = DoAttachMatOptionDialog ((IObjParam *)eo->ip, eo);
		if (!eo->ip) ret = FALSE;
	}
	nodes.DisposeTemporary ();
	inProc = FALSE;
	if (!ret) return;
	eo->MultiAttach (nodeTab);
}

//----------------------------------------------------------

void DivideEdgeProc::EdgePick(DWORD edge, float prop) {			
	theHold.Begin();
	MeshDelta tmd;
	tmd.DivideEdge (et->GetMesh(), edge, prop, et->TempData()->AdjEList());
	et->ApplyMeshDelta (tmd, et, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_EDGEDIVIDE));

	ip->RedrawViews(ip->GetTime());	
}

void DivideEdgeCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_DIVIDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);		
}

void DivideEdgeCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_DIVIDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);		
}

//----------------------------------------------------------

void DivideFaceProc::FacePick (DWORD ff, float *bary) {
	theHold.Begin();
	MeshDelta tmd;
	tmd.DivideFace (et->GetMesh(), ff, bary);
	et->ApplyMeshDelta (tmd, et, ip->GetTime());
	theHold.Accept(GetString(IDS_FACE_DIVIDE));
	ip->RedrawViews(ip->GetTime());	
}

void DivideFaceCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom, IDC_DIVIDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);		
}

void DivideFaceCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom, IDC_DIVIDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

void TurnEdgeProc::EdgePick(DWORD edge, float prop) {
	theHold.Begin();
	MeshDelta tmd(et->GetMesh());
	tmd.TurnEdge (et->GetMesh(), edge);
	et->ApplyMeshDelta (tmd, et, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_EDGETURN));

	ip->RedrawViews(ip->GetTime());	
}

void TurnEdgeCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_EDGE_TURN));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);		
}

void TurnEdgeCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_EDGE_TURN));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);		
}

// ------------------------------------------------------

int ExtrudeMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	float amount;
	IPoint2 m2;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (!point) {
			eo->BeginExtrude(ip->GetTime());		
			om = m;
		} else {
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			eo->EndExtrude(ip->GetTime(),TRUE);
		}
		break;

	case MOUSE_MOVE:
		p0 = vpt->MapScreenToView (om,float(-200));
		m2.x = om.x;
		m2.y = m.y;
		p1 = vpt->MapScreenToView (m2,float(-200));
		amount = Length (p1-p0);
		if (m.y > om.y) amount *= -1.0f;
		eo->Extrude (ip->GetTime(), amount);

		spin = GetISpinner (GetDlgItem (eo->hGeom,IDC_EXTRUDESPINNER));
		if (spin) {
			spin->SetValue (amount, FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		eo->EndExtrude(ip->GetTime(),FALSE);			
		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR ExtrudeSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_EXTRUDECUR));
	return hCur; 
}

void ExtrudeCMode::EnterMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_EXTRUDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void ExtrudeCMode::ExitMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_EXTRUDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------

int BevelMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	float amount;
	IPoint2 m2;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		switch (point) {
		case 0:
			m0 = m;
			m0set = TRUE;
			eo->BeginBevel (ip->GetTime(), TRUE);
			break;
		case 1:
			m1 = m;
			m1set = TRUE;
			p0 = vpt->MapScreenToView (m0, float(-200));
			m2.x = m0.x;
			m2.y = m.y;
			p1 = vpt->MapScreenToView (m2, float(-200));
			height = Length (p0-p1);
			if (m1.y > m0.y) height *= -1.0f;
			eo->Bevel (ip->GetTime(), 0, height);
			spin = GetISpinner(GetDlgItem(eo->hGeom,IDC_EXTRUDESPINNER));
			if (spin) {
				spin->SetValue(height,FALSE);
				ReleaseISpinner(spin);
			}
			break;
		case 2:
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			eo->EndBevel(ip->GetTime(),TRUE);
			m1set = m0set = FALSE;
			break;
		}
		break;

	case MOUSE_MOVE:
		if (!m0set) break;
		m2.y = m.y;
		if (!m1set) {
			p0 = vpt->MapScreenToView (m0, float(-200));
			m2.x = m0.x;
			p1 = vpt->MapScreenToView (m2, float(-200));
			amount = Length (p1-p0);
			if (m.y > m0.y) amount *= -1.0f;
			eo->Bevel (ip->GetTime(), 0, amount);
			spin = GetISpinner(GetDlgItem(eo->hGeom,IDC_EXTRUDESPINNER));
		} else {
			p0 = vpt->MapScreenToView (m1, float(-200));
			m2.x = m1.x;
			p1 = vpt->MapScreenToView (m2, float(-200));
			amount = Length (p1-p0);
			if (m.y > m1.y) amount *= -1.0f;
			eo->Bevel (ip->GetTime(), amount, height);
			spin = GetISpinner(GetDlgItem(eo->hGeom,IDC_OUTLINESPINNER));
		}
		if (spin) {
			spin->SetValue(amount,FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		eo->EndBevel(ip->GetTime(),FALSE);
		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		m1set = m0set = FALSE;
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR BevelSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_BEVELCUR));
	return hCur;
}

void BevelCMode::EnterMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_BEVEL));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void BevelCMode::ExitMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_BEVEL));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------

int ChamferMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (!point) {
			eo->BeginChamfer (ip->GetTime());		
			om = m;
		} else {
			ip->RedrawViews (ip->GetTime(),REDRAW_END);
			eo->EndChamfer (ip->GetTime(),TRUE);
		}
		break;

	case MOUSE_MOVE:
		p0 = vpt->MapScreenToView(om,float(-200));
		p1 = vpt->MapScreenToView(m,float(-200));
		eo->Chamfer (ip->GetTime(), Length(p1-p0));

		spin = GetISpinner(GetDlgItem(eo->hGeom,IDC_OUTLINESPINNER));
		if (spin) {
			spin->SetValue(Length(p1-p0),FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		eo->EndChamfer (ip->GetTime(),FALSE);			
		ip->RedrawViews (ip->GetTime(),REDRAW_END);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR ChamferSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hECur = NULL;
	static HCURSOR hVCur = NULL;
	if (eto->selLevel == SL_VERTEX) {
		if ( !hVCur ) hVCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_VCHAMFERCUR));
		return hVCur;
	}
	if ( !hECur ) hECur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ECHAMFERCUR));
	return hECur;
}

void ChamferCMode::EnterMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_BEVEL));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void ChamferCMode::ExitMode() {
	if (!eo->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(eo->hGeom,IDC_BEVEL));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// --- Slice: not really a command mode, just looks like it.--------- //

// Each time we enter the slice mode, we reset the slice plane.

void EditTriObject::EnterSliceMode () {
	sliceMode = TRUE;
	if (hGeom) {
		ICustButton *but = GetICustButton (GetDlgItem(hGeom,IDC_SLICE));
		but->Enable ();
		ReleaseICustButton (but);
		EnableWindow (GetDlgItem (hGeom, IDC_REFINE), FALSE);
		but = GetICustButton (GetDlgItem (hGeom, IDC_SLICEPLANE));
		but->SetCheck (TRUE);
		ReleaseICustButton (but);
	}

	Box3 box = GetMesh().getBoundingBox();
	sliceCenter = (box.pmax + box.pmin)*.5f;
	sliceRot.Identity();
	box.pmax -= box.pmin;
	sliceSize = (box.pmax.x > box.pmax.y) ? box.pmax.x : box.pmax.y;
	if (box.pmax.z > sliceSize) sliceSize = box.pmax.z;
	sliceSize *= .52f;
	if (sliceSize < 1) sliceSize = 1.0f;

	if (ip->GetCommandMode()->ID() >= CID_USER) ip->SetStdCommandMode (CID_OBJMOVE);
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditTriObject::ExitSliceMode () {
	sliceMode = FALSE;
	if (hGeom) {
		ICustButton *but = GetICustButton (GetDlgItem(hGeom,IDC_SLICE));
		but->Disable ();
		ReleaseICustButton (but);
		if (selLevel >= SL_EDGE) EnableWindow (GetDlgItem (hGeom, IDC_REFINE), TRUE);
		but = GetICustButton (GetDlgItem (hGeom, IDC_SLICEPLANE));
		but->SetCheck (FALSE);
		ReleaseICustButton (but);
	}
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

// -- Cut Edge proc/mode -------------------------------------

class CutAbandon : public RestoreObj {
public:
	EditTriObject *obj;

	CutAbandon (EditTriObject *m) { obj = m; }
	void Restore(int isUndo) { if (obj->cutEdgeMode) obj->cutEdgeMode->AbandonCut(); }
	void Redo() { if (obj->cutEdgeMode) obj->cutEdgeMode->AbandonCut (); }
	int Size() { return sizeof(void *); }
	TSTR Description() { return TSTR(_T("Editable Mesh Cut Abandon")); }
};

HitRecord *CutEdgeProc::HitTestEdges (IPoint2 &m, ViewExp *vpt) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest (ip->GetTime(), HITTYPE_POINT, 0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *ret = hitLog.ClosestHit();

	if (e1set && (e1 == (int)ret->hitInfo)) return NULL;
	return ret;
}

void CutEdgeProc::DrawCutter (HWND hWnd,IPoint2 &m) {
	HDC hdc = GetDC(hWnd);
	SetROP2(hdc, R2_XORPEN);
	SetBkMode(hdc, TRANSPARENT);	
	SelectObject(hdc,CreatePen(PS_DOT, 0, RGB(255,255,255)));
	MoveToEx(hdc,m1.x,m1.y,NULL);
	LineTo(hdc,m.x,m.y);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	ReleaseDC(hWnd, hdc);
}

int CutEdgeProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {
	ViewExp *vpt;
	HitRecord *hr;
	AdjEdgeList *ae;
	AdjFaceList *af;
	MeshDelta tmd;
	IPoint2 betterM;
	Point3 A, B, snapPoint, Xdir, Zdir;
	Matrix3 obj2world, world2obj;
	float prop;
	Ray r;

	switch (msg) {
	case MOUSE_ABORT:
		// Erase last cutter line:
		if (e1set) DrawCutter (hwnd, oldm2);
		e1set = FALSE;
		return FALSE;

	case MOUSE_PROPCLICK:
		// Erase last cutter line:
		if (e1set) DrawCutter (hwnd, oldm2);
		ip->SetStdCommandMode(CID_OBJMOVE);
		return FALSE;

	case MOUSE_DBLCLICK:
		if (!e1set) break;
		// Erase last cutter line:
		DrawCutter (hwnd, oldm2);

		theHold.Begin ();
		ae = et->TempData()->AdjEList();
		tmd.DivideEdge (et->GetMesh(), e1, prop1, ae, FALSE, et->cutRefine,
			FALSE, et->sliceSplit);
		et->ApplyMeshDelta (tmd, et, ip->GetTime());
		theHold.Accept (GetString (IDS_SCA_EDGECUT));
		ip->RedrawViews(ip->GetTime());
		e1set = FALSE;
		return FALSE;

	case MOUSE_POINT:
		ip->SetActiveViewport (hwnd);
		vpt = ip->GetViewport (hwnd);
		hr = HitTestEdges(m,vpt);
		if (!hr) {
			ip->ReleaseViewport (vpt);
			break;
		}

		DWORD ee;
		ee = hr->hitInfo;

		// Find where along this edge we hit
		// Strategy:
		// Get Mouse click, plus viewport z-direction at mouse click, in object space.
		// Then find the direction of the edge in a plane orthogonal to z, and see how far
		// along that edge we are.
		snapPoint = vpt->SnapPoint (m, betterM, NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		vpt->MapScreenToWorldRay ((float)betterM.x, (float)betterM.y, r);
		Zdir = Normalize (r.dir);
		obj2world = hr->nodeRef->GetObjectTM (ip->GetTime ());
		A = obj2world * et->GetMesh().verts[et->GetMesh().faces[ee/3].v[ee%3]];
		B = obj2world * et->GetMesh().verts[et->GetMesh().faces[ee/3].v[(ee+1)%3]];
		Xdir = B-A;
		Xdir -= DotProd(Xdir, Zdir)*Zdir;
		prop = DotProd (Xdir, snapPoint-A) / LengthSquared (Xdir);
		if (prop<.0001f) prop=0;
		if (prop>.9999f) prop=1;

		ip->ReleaseViewport (vpt);

		if (!e1set) {
			e1 = hr->hitInfo;
			prop1 = prop;
			e1set = TRUE;
			m1 = betterM;
			DrawCutter (hwnd, m);
			oldm2=m;
			break;
		}

		// Erase last cutter line:
		DrawCutter (hwnd, oldm2);

		// Do the cut:
		af = et->TempData()->AdjFList();
		world2obj = Inverse (obj2world);
		Zdir = VectorTransform (world2obj, Zdir);
		theHold.Begin ();
		e1 = tmd.Cut (et->GetMesh(), e1, prop1, ee, prop, -Zdir, et->cutRefine, et->sliceSplit);
		et->ApplyMeshDelta (tmd, et, ip->GetTime());
		theHold.Put (new CutAbandon(et));
		theHold.Accept (GetString (IDS_SCA_EDGECUT));
		ip->RedrawViews (ip->GetTime());

		if (e1==UNDEFINED) {
			e1set = FALSE;
			return FALSE;
		} else {
			prop1=0.0f;
			m1 = betterM;
			DrawCutter (hwnd, m);
			oldm2 = m;
		}
		break;

	case MOUSE_MOVE:
		vpt = ip->GetViewport (hwnd);
		vpt->SnapPoint(m,m,NULL);
		if (e1set) {
			DrawCutter (hwnd,oldm2);
			oldm2 = m;
		}
		if (HitTestEdges(m,vpt)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		ip->ReleaseViewport (vpt);
		ip->RedrawViews (ip->GetTime());
		if (e1set) DrawCutter (hwnd,oldm2);
		break;

	case MOUSE_FREEMOVE:
		vpt = ip->GetViewport (hwnd);
		vpt->SnapPreview(m,m,NULL);//, SNAP_SEL_OBJS_ONLY);
		if (HitTestEdges(m,vpt)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		ip->ReleaseViewport (vpt);
		break;
	}

	return TRUE;	
}

void CutEdgeCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CUT));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	proc.e1set = FALSE;
	et->inCutEdge = TRUE;
}

void CutEdgeCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_CUT));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	et->inCutEdge = FALSE;
}

void CutEdgeCMode::AbandonCut () {
	proc.e1set = FALSE;
}

/*-------------------------------------------------------------------*/

void WeldVertCMode::EnterMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_WELDTOVERT));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void WeldVertCMode::ExitMode() {
	if (!et->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hGeom,IDC_WELDTOVERT));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

BOOL WeldVertMouseProc::HitTestVerts (IPoint2 &m, ViewExp *vpt, int &v) {
	vpt->ClearSubObjHitList();	
	et->pickBoxSize = et->weldBoxSize;
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, HIT_UNSELONLY, &m, vpt);
	et->pickBoxSize = DEF_PICKBOX_SIZE;
	if (!vpt->NumSubObjHits()) return FALSE;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	MaxAssert(hr);
	v = hr->hitInfo;
	return TRUE;
}

void WeldVertMouseProc::PostTransformHolding () {
	TransformModBox::PostTransformHolding();	// so our object gets the "TranformHoldingFinish" call.
	if (targetVert < 0) return;
	Mesh & mesh = et->GetMesh();
	Point3 pt = mesh.verts[targetVert];

	// Select the point that was hit
	BitArray vsel = et->GetVertSel ();
	vsel.Set (targetVert);
	et->SetVertSel (vsel, et, ip->GetTime());

	// Do the weld
	et->WeldVerts (pt);
}

int WeldVertMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	ViewExp *vpt = ip->GetViewport(hwnd);
	int res = TRUE;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (point==1) {
			if (!HitTestVerts(m,vpt,targetVert)) {
				targetVert = -1;
			}
		}
		break;

	case MOUSE_MOVE:
		int vert;
		if (HitTestVerts(m,vpt,vert)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(ip->GetSysCursor(SYSCUR_MOVE));
		break;
	}
	
	if (vpt) ip->ReleaseViewport(vpt);
	return MoveModBox::proc(hwnd,msg,point,flags,m);	
}

HCURSOR WeldVertSelectionProcessor::GetTransformCursor() { 	
	return ip->GetSysCursor(SYSCUR_MOVE);
}

//----------------------------------------------------------

void FlipNormProc::FacePick (DWORD face, float *bary) {
	theHold.Begin();
	MeshDelta tmd (et->GetMesh());
	if (et->selLevel <= SL_FACE) {
		tmd.FlipNormal (et->GetMesh(), face);
	} else {
		BitArray flip;
		flip.SetSize (tmd.fnum);
		if (et->selLevel == SL_POLY) {
			et->GetMesh().PolyFromFace (face, flip, et->GetPolyFaceThresh(), et->ignoreVisEdge, et->TempData()->AdjFList());
		} else {
			et->GetMesh().ElementFromFace (face, flip, et->TempData()->AdjFList());
		}
		for (DWORD i=0; i<tmd.fnum; i++) if (flip[i]) tmd.FlipNormal (et->GetMesh(), i);
	}
	et->ApplyMeshDelta (tmd, et, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_FLIPNORMALS));
	ip->RedrawViews(ip->GetTime());
}

void FlipNormCMode::EnterMode() {
	if (!et->hSurf) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hSurf, IDC_NORMAL_FLIPMODE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);		
}

void FlipNormCMode::ExitMode() {
	if (!et->hSurf) return;
	ICustButton *but = GetICustButton(GetDlgItem(et->hSurf, IDC_NORMAL_FLIPMODE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

//----------------------------------------------------------
// MeshDeltaUserData methods  (see also triedui.cpp for ui-related MeshDeltaUser stuff

void EditTriObject::MoveSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)
{
}

void EditTriObject::RotateSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin)
{
}

void EditTriObject::ScaleSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin)
{
}

void EditTriObject::ExtrudeSelection(int level, BitArray* sel, float amount, float bevel, BOOL groupNormal, Point3* direction)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\kernelres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kernel.rc
//
#define IDS_KE_KERNELDESC               1
#define IDS_KE_SAMPKERNEL               2
#define IDS_KE_PARAMETERS               3
#define IDS_KE_CONE_KERNEL              4
#define IDS_KE_QUADRATIC_KERNEL         5
#define IDS_KE_CUBIC_KERNEL             6
#define IDS_KE_CATROM_KERNEL            7
#define IDS_KE_GAUSS_NARROW_KERNEL      8
#define IDS_KE_GAUSS_MEDIUM_KERNEL      9
#define IDS_KE_GAUSS_WIDE_KERNEL        10
#define IDS_KE_PAVIC_UNITVOL_KERNEL     11
#define IDS_KE_PAVIC_OP_KERNEL          12
#define IDS_KE_HANNING_KERNEL           13
#define IDS_KE_HAMMING_KERNEL           14
#define IDS_KE_BLACKMAN_KERNEL          15
#define IDS_KE_BLACKMAN361_KERNEL       16
#define IDS_KE_BLACKMAN367_KERNEL       17
#define IDS_KE_BLACKMAN474_KERNEL       18
#define IDS_KE_BLACKMAN492_KERNEL       19
#define IDS_KE_MAX1_KERNEL              20
#define IDS_KE_MAX2_KERNEL              21
#define IDS_KE_MAX3_KERNEL              22
#define IDS_KE_MITNET_OP_KERNEL         23
#define IDS_KE_MITNET_NOTCH_KERNEL      24
#define IDS_KE_NTSC_KERNEL              25
#define IDS_KE_COOK_OP_KERNEL           26
#define IDS_KE_MITNET_VAR_KERNEL        27
#define IDS_KE_COOK_VAR_KERNEL          28
#define IDS_KE_GAUSS_VAR_KERNEL         29
#define IDS_KE_MITNET_PARAMS            30
#define IDS_KE_CYLINDER_VAR_KERNEL      31
#define IDS_KE_CONE_VAR_KERNEL          32
#define IDS_KE_QUADRATIC_VAR_KERNEL     33
#define IDS_KE_CUBIC_VAR_KERNEL         34
#define IDS_KE_QUAD_COMMENT             35
#define IDS_KE_MAX_COMMENT              36
#define IDS_KE_CUBIC_COMMENT            37
#define IDS_KE_NTSC_COMMENT             38
#define IDS_KE_COOK_COMMENT             39
#define IDS_KE_GAUSSVAR_COMMENT         40
#define IDS_KE_CONEVAR_COMMENT          41
#define IDS_KE_HANNING_COMMENT          42
#define IDS_KE_BLACKMAN_COMMENT         43
#define IDS_KE_CATROM_COMMENT           44
#define IDS_KE_MITNET_COMMENT           45
#define IDS_KE_BLANK                    46
#define IDS_KE_MITNET_PARAM_B           47
#define IDS_KE_MITNET_PARAM_C           48
#define IDS_KE_BLEND_COMMENT            49
#define IDS_KE_STOCKING_BLEND           50
#define IDS_KE_STOCKING_PARAMS          51
#define IDS_KE_STOCKING_KERNEL          52
#define IDS_KE_STOCKING_SHARPNESS       53
#define IDS_KE_AREA_COMMENT             54
#define IDS_KE_AREA_KERNEL              55
#define IDS_KE_CYLVAR_COMMENT           56
#define IDS_KE_BLEND_KERNEL             57
#define IDS_KE_STOCKING_COMMENT         58
#define IDS_KE_PIXELSIZE_KERNEL         59
#define IDS_KE_PIXELSIZE_COMMENT        60
#define IDD_SAMPLE_EFFECT               107
#define IDD_BRITECON_EFFECT             108
#define IDD_MITNET_PARAMS               109
#define IDC_SAMP_COLOR                  1713
#define IDC_BC_BRIGHTNESS               1718
#define IDC_BC_CONTRAST                 1719
#define IDC_BC_BRIGHTNESS_SPIN          1720
#define IDC_BC_CONTRAST_SPIN            1721
#define IDC_MITNET_C                    1724
#define IDC_MITNET_B                    1725
#define IDC_MITNET_B_SPIN               1726
#define IDC_MITNET_C_SPIN               1727
#define IDS_DS_SAMPEFPARAMS             30532
#define IDS_KE_BRITECON_PARAMS          30533
#define IDS_KE_BRIGHTNESS               30534
#define IDS_KE_CONTRAST                 30535
#define IDS_KE_BRITECON                 30536
#define IDS_KE_EFFDESC                  30537
#define IDS_DS_PARAMETERS               30538
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1728
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\kernelmain.cpp ===
/**********************************************************************
 *<
	FILE: kernelmain.cpp

	DESCRIPTION:   DLL implementation prefilter kernels

	CREATED BY: 	Kells Elmquist

	HISTORY: 	created 29 june 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "kernelhdr.h"
#include "kernelres.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();

		// register SXP readers
		// RegisterSXPReader(_T("MARBLE_I.SXP"), Class_ID(MARBLE_CLASS_ID,0));
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR * LibDescription() { return GetString(IDS_KE_KERNELDESC); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() 
{
#ifdef INCLUDE_PIXELSIZE
	return 12;
#else
	return 11;
#endif 
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		case 0: return GetAreaKernelDesc();
		case 1: return GetMax1KernelDesc();
		case 2: return GetQuadraticKernelDesc();
		case 3: return GetCubicKernelDesc();
		case 4: return GetNTSCKernelDesc();
		case 5: return GetGaussVarKernelDesc();
		case 6: return GetCookVarKernelDesc();
		case 7: return GetBlendKernelDesc();
		case 8: return GetBlackman474KernelDesc();
		case 9: return GetMitNetVarKernelDesc();
		case 10: return GetCatRomKernelDesc();
#ifdef INCLUDE_PIXELSIZE
		case 11: return GetPixelSizeKernelDesc();
#endif
//		case 6: return GetCylinderVarKernelDesc();

//		case 10: return GetStockingKernelDesc();
//		case 11: return GetHanningKernelDesc();
//		case 12: return GetSampKernelDesc();
//		case 13: return GetConeKernelDesc();
//		case 14: return GetCubicKernelDesc();
//		case 15: return GetGaussNarrowKernelDesc();
//		case 16: return GetGaussMediumKernelDesc();
//		case 17: return GetGaussWideKernelDesc();
//		case 18: return GetPavicUnitVolKernelDesc();
//		case 19: return GetPavicOpKernelDesc();
//		case 20: return GetHammingKernelDesc();
//		case 21: return GetBlackmanKernelDesc();
//		case 22: return GetBlackman361KernelDesc();
//		case 23: return GetBlackman367KernelDesc();
//		case 24: return GetBlackman492KernelDesc();
//		case 25: return GetMax2KernelDesc();
//		case 26: return GetMax3KernelDesc();
//		case 27: return GetMitNetNotchKernelDesc();
//		case 28: return GetCookOpKernelDesc();
//		case 29: return GetCylinderVarKernelDesc();
//		case 30: return GetQuadraticVarKernelDesc();
//		case 31: return GetCubicVarKernelDesc();


#ifndef DESIGN_VER

#else

#endif // !DESIGN_VER

		default: return 0;
	}
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\stdKernels.h ===
///////////////////////////////////////////////////////////////
//
//	Standard Pre-filter kernel functions
//

#ifndef STDKERNELS_H
#define STDKERNELS_H

// comment out this define to remove the r 2.5 pixelSize filter
#define INCLUDE_PIXELSIZE	


// Get the Kernel Class Descriptors
ClassDesc* GetAreaKernelDesc();
ClassDesc* GetPixelSizeKernelDesc();
ClassDesc* GetNTSCKernelDesc();
ClassDesc*  GetConeKernelDesc();
ClassDesc*  GetQuadraticKernelDesc();
ClassDesc* GetCubicKernelDesc();
ClassDesc* GetCatRomKernelDesc();
ClassDesc* GetGaussNarrowKernelDesc();
ClassDesc* GetGaussMediumKernelDesc();
ClassDesc* GetGaussWideKernelDesc();
ClassDesc* GetPavicUnitVolKernelDesc();
ClassDesc* GetPavicOpKernelDesc();
ClassDesc* GetHanningKernelDesc();
ClassDesc* GetHammingKernelDesc();
ClassDesc* GetBlackmanKernelDesc();
ClassDesc* GetBlackman361KernelDesc();
ClassDesc*  GetBlackman367KernelDesc();
ClassDesc* GetBlackman474KernelDesc();
ClassDesc* GetBlackman492KernelDesc();
ClassDesc* GetMax1KernelDesc();
ClassDesc* GetMax2KernelDesc();
ClassDesc* GetMax3KernelDesc();
ClassDesc* GetMitNetOpKernelDesc();
ClassDesc* GetMitNetNotchKernelDesc();
ClassDesc* GetNTSCKernelDesc();
ClassDesc* GetCookOpKernelDesc();
ClassDesc* GetCookVarKernelDesc();
ClassDesc* GetGaussVarKernelDesc();
ClassDesc* GetMitNetVarKernelDesc();
ClassDesc* GetCylinderVarKernelDesc();
ClassDesc* GetConeVarKernelDesc();
ClassDesc* GetQuadraticVarKernelDesc();
ClassDesc* GetCubicVarKernelDesc();
ClassDesc* GetStockingKernelDesc();
ClassDesc* GetBlendKernelDesc();






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\stdKernels.cpp ===
/**********************************************************************
 *<
	FILE: StdKernels.cpp	

	DESCRIPTION:Standard prefilter kernel plugins

	CREATED BY: Kells Elmquist

	HISTORY:	Created 7/29/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "kernelhdr.h"
#include "kernelres.h"
#include "iparamm.h"

#define M_PI	3.141592654

#define LOW_THRESH	0.5f	// halfpixel radius minimum


// Class IDs for kernel plug-ins
#define STD_KERNEL_CLASS_ID				0x77912300
//#define AREA_KERNEL_CLASS_ID			0x77912301
#define CYLINDER_KERNEL_CLASS_ID		0x77912302
#define CONE_KERNEL_CLASS_ID			0x77912303
#define QUADRATIC_KERNEL_CLASS_ID		0x77912304
#define CUBIC_KERNEL_CLASS_ID			0x77912305
#define CATROM_KERNEL_CLASS_ID			0x77912306
#define GAUSS_NARROW_KERNEL_CLASS_ID	0x77912307
#define GAUSS_MEDIUM_KERNEL_CLASS_ID	0x77912308
#define GAUSS_WIDE_KERNEL_CLASS_ID	    0x77912309
#define PAVIC_UNITVOL_KERNEL_CLASS_ID   0x7791230a
#define PAVIC_OPTIMIZED_KERNEL_CLASS_ID 0x7791230b
#define HANNING_KERNEL_CLASS_ID			0x7791230d
#define HAMMING_KERNEL_CLASS_ID			0x7791230e
#define BLACKMAN_KERNEL_CLASS_ID		0x7791230f
#define BLACKMAN367_KERNEL_CLASS_ID		0x77912310
#define BLACKMAN361_KERNEL_CLASS_ID		0x77912311
#define BLACKMAN492_KERNEL_CLASS_ID		0x77912312
#define BLACKMAN474_KERNEL_CLASS_ID		0x77912313
#define MAX1_KERNEL_CLASS_ID			0x77912314
#define MAX2_KERNEL_CLASS_ID			0x77912315
#define MAX3_KERNEL_CLASS_ID			0x77912316
#define MITNET_OP_KERNEL_CLASS_ID		0x77912317
#define MITNET_NOTCH_KERNEL_CLASS_ID	0x77912318
#define NTSC_KERNEL_CLASS_ID			0x77912319
#define COOK_OP_KERNEL_CLASS_ID			0x7791231a
#define PIXELSIZE_KERNEL_CLASS_ID		0x7791231b

// variable width filters
#define COOK_VAR_KERNEL_CLASS_ID		0x77912330
#define GAUSS_VAR_KERNEL_CLASS_ID		0x77912331
#define CYLINDER_VAR_KERNEL_CLASS_ID	0x77912332
#define CONE_VAR_KERNEL_CLASS_ID		0x77912333
#define QUADRATIC_VAR_KERNEL_CLASS_ID	0x77912334
#define CUBIC_VAR_KERNEL_CLASS_ID		0x77912335

// parameterized filters
#define MITNET_VAR_KERNEL_CLASS_ID		0x77912350
#define STOCKING_KERNEL_CLASS_ID		0x77912351
#define BLEND_KERNEL_CLASS_ID			0x77912352

// ClassID statics
Class_ID StdKernelClassID(STD_KERNEL_CLASS_ID,0);
Class_ID AreaKernelClassID(AREA_KERNEL_CLASS_ID,0);
Class_ID ConeKernelClassID(CONE_KERNEL_CLASS_ID,0);
Class_ID QuadraticKernelClassID(QUADRATIC_KERNEL_CLASS_ID,0);
Class_ID CubicKernelClassID(CUBIC_KERNEL_CLASS_ID,0);
Class_ID CatRomKernelClassID(CATROM_KERNEL_CLASS_ID,0);
Class_ID GaussNarrowKernelClassID(GAUSS_NARROW_KERNEL_CLASS_ID,0);
Class_ID GaussMediumKernelClassID(GAUSS_MEDIUM_KERNEL_CLASS_ID,0);
Class_ID GaussWideKernelClassID(GAUSS_WIDE_KERNEL_CLASS_ID,0);
Class_ID PavicUnitVolKernelClassID(PAVIC_UNITVOL_KERNEL_CLASS_ID,0);
Class_ID PavicOpKernelClassID(PAVIC_OPTIMIZED_KERNEL_CLASS_ID,0);
Class_ID HanningKernelClassID(HANNING_KERNEL_CLASS_ID,0);
Class_ID HammingKernelClassID(HAMMING_KERNEL_CLASS_ID,0);
Class_ID BlackmanKernelClassID(BLACKMAN_KERNEL_CLASS_ID,0);
Class_ID Blackman367KernelClassID(BLACKMAN367_KERNEL_CLASS_ID,0);
Class_ID Blackman361KernelClassID(BLACKMAN361_KERNEL_CLASS_ID,0);
Class_ID Blackman474KernelClassID(BLACKMAN474_KERNEL_CLASS_ID,0);
Class_ID Blackman492KernelClassID(BLACKMAN492_KERNEL_CLASS_ID,0);
Class_ID Max1KernelClassID(MAX1_KERNEL_CLASS_ID,0);
Class_ID Max2KernelClassID(MAX2_KERNEL_CLASS_ID,0);
Class_ID Max3KernelClassID(MAX3_KERNEL_CLASS_ID,0);
Class_ID MitNetOpKernelClassID(MITNET_OP_KERNEL_CLASS_ID,0);
Class_ID MitNetNotchKernelClassID(MITNET_NOTCH_KERNEL_CLASS_ID,0);
Class_ID NTSCKernelClassID(NTSC_KERNEL_CLASS_ID,0);
Class_ID CookOpKernelClassID(COOK_OP_KERNEL_CLASS_ID,0);
Class_ID PixelSizeKernelClassID(PIXELSIZE_KERNEL_CLASS_ID,0);


// classes with parameters
Class_ID CookVarKernelClassID(COOK_VAR_KERNEL_CLASS_ID,0);
Class_ID MitNetVarKernelClassID(MITNET_VAR_KERNEL_CLASS_ID,0);
Class_ID GaussVarKernelClassID(GAUSS_VAR_KERNEL_CLASS_ID,0);
Class_ID CylinderVarKernelClassID(CYLINDER_VAR_KERNEL_CLASS_ID,0);
Class_ID ConeVarKernelClassID(CONE_VAR_KERNEL_CLASS_ID,0);
Class_ID QuadraticVarKernelClassID(QUADRATIC_VAR_KERNEL_CLASS_ID,0);
Class_ID CubicVarKernelClassID(CUBIC_VAR_KERNEL_CLASS_ID,0);
Class_ID StockingKernelClassID(STOCKING_KERNEL_CLASS_ID,0);
Class_ID BlendKernelClassID(BLEND_KERNEL_CLASS_ID,0);

// ClassNames
//#define AREA_KERNEL_CLASSNAME	GetString(IDS_KE_AREA)

//-------------------------------------------------------

//class GenericDlgProc;

// global generic do nothing dlg proc
//static GenericDlgProc *pGenericDlgProc = NULL;

// Generic filter kernel class to handle most of the stuff
class GenericKernel: public FilterKernel {
	public:
		GenericKernel(){};
		~GenericKernel(){};

		RefTargetHandle Clone(RemapDir& remap) 
		{ 
			GenericKernel *copy = new GenericKernel;
			return copy;	
		}	

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
									PartID& partID, RefMessage message ) 
		{ 
			switch (message) {
				case REFMSG_TARGET_DELETED:
					break;
			}							
		   	return REF_SUCCEED; 
		}

		// From Animatable
		void *GetInterface(ULONG id) {  return NULL; }
		void DeleteThis() { delete this; }
		int NumSubs() {return 0;}
		Animatable* SubAnim(int i){ return NULL; }
		TSTR SubAnimName(int i){ return _T( "" ); }
		virtual TCHAR *GetObjectName() { return NULL; } // dummy, overridden by subclass
		void GetClassName(TSTR& s) { s = GetObjectName(); };
		TSTR GetName() { TSTR s = GetObjectName(); return s; };
//		Class_ID ClassID() { return standinClassID; }

		// From ref
		int NumRefs() { return 0; }
		RefTargetHandle GetReference(int i) { return NULL; }
		void SetReference(int i, RefTargetHandle rtarg) {}
		SClass_ID  	SuperClassID() { return FILTER_KERNEL_CLASS_ID; }

//		FilterKernelParamDlg *CreateParamDialog(IRendParams *ip) {
//			return NULL; //new GenericKernelParamDlg(this,ip);
//		}
		TCHAR * GetDefaultComment() { return GetString( IDS_KE_BLANK); }

		// there are 2 optional 0...1 parameters
		virtual long GetNFilterParams() { return 0; }
		virtual TCHAR * GetFilterParamName( long nParam ) { return GetString( IDS_KE_BLANK ); }
		virtual double GetFilterParam( long nParam ){ return 0.0; }
		virtual void SetFilterParam( long nParam, double val ){}

		// for 2d returns y support, for 1d returns 0
		long GetKernelSupportY(){ return 0; };

		bool Is2DKernel(){ return FALSE; };
		bool IsVariableSz(){ return FALSE; };
		// 1-D filters ignore the y parameter, r = x/2
		void SetKernelSz( double x, double y = 0.0 ) {};
		// return 2...the most common case
		void GetKernelSz( double& x, double& y ){ x = 2.0; y = 0.0; }

		// returning true will disable the built-in normalizer
		bool IsNormalized(){ return FALSE; };

		// this is for alpha enables
		bool HasNegativeLobes(){ return FALSE; };

		IOResult Load (ILoad *iload){ SpecialFX::Load (iload);	return IO_OK; }
		IOResult Save (ISave *isave){ SpecialFX::Save(isave); return IO_OK; }

		// just dummies so we can instance the abstract class
		virtual long GetKernelSupport() { return 0; };
		virtual double KernelFn( double x, double y ) {return 0.0;}

};

//---------------------------- the filter kernel classes -----------------------------------
class AreaFilterKernel : public GenericKernel {
public:
		double w;
		AreaFilterKernel(){ w = 0.75; }
		RefTargetHandle Clone(RemapDir& remap)
		{ AreaFilterKernel* a = new AreaFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return AreaKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_AREA_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_AREA_COMMENT); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double ) {
			if ( x > w ) return 0.0;
			return 1.0;
		}
};

//////////////////////////////////////////////////////////////////////////////
//
//	 PixelsSize filter, for 2.5 compatibility & camera mapping
//
#ifdef INCLUDE_PIXELSIZE 

#define PIXELSIZE_MAX	1.0f

class PixelSizeKernel : public GenericKernel {
public:
		double w;
		PixelSizeKernel(){ w = 0.75; }
		RefTargetHandle Clone(RemapDir& remap)
		{ PixelSizeKernel* a = new PixelSizeKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return PixelSizeKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_PIXELSIZE_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_PIXELSIZE_COMMENT); }
		long GetKernelSupport() { return 0; }
		bool IsVariableSz(){ return TRUE; };

		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : (x > PIXELSIZE_MAX)? PIXELSIZE_MAX : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = -1.0; } // the flag
		double KernelFn( double x, double ) { return 0.0; } // dummy
};
#endif /////////////////////////////////////////////////////////////////////////


class ConeFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return ConeKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CONE_KERNEL); }
//		TCHAR * GetDefaultComment() { return GetString(IDS_KE_CONE_COMMENT); }
		long GetKernelSupport() { return 1; }
		void GetKernelSz( double& x, double& y ){ x = 1.0; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ ConeFilterKernel* a = new ConeFilterKernel(); return a; }	
		double KernelFn( double x, double y ) {return ( x < 1.0f ) ? 1.0f - x : 0.0;}
};

class QuadraticFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return QuadraticKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_QUADRATIC_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_QUAD_COMMENT); }
		RefTargetHandle Clone(RemapDir& remap)
		{ QuadraticFilterKernel* a = new QuadraticFilterKernel(); return a; }	
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.5; y = 0.0; }
		double KernelFn( double x, double ) {
			if ( x < 0.5 ) return 0.75 - x * x;
			if ( x < 1.5 ) {
				double t = x - 1.5; 
				return 0.5 * t * t;
			}
			return 0.0f;
		}
};

class CubicFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return CubicKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CUBIC_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_CUBIC_COMMENT); }
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ CubicFilterKernel* a = new CubicFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x < 1.0 ) return (4.0 + x * x * (-6.0 + x * 3.0))/6.0;
			if ( x < 2.0 ) { 
				double t = 2.0 - x; 
				return t * t * t / 6.0; 
			}
			return 0.0;
		}
};

class CatRomFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return CatRomKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CATROM_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_CATROM_COMMENT); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ CatRomFilterKernel* a = new CatRomFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x < 1.0 ) return 0.5 * ( 2.0 + x * x *( -5.0 + x * 3.0));
			if ( x < 2.0 ) return 0.5 * ( 4.0 + x * ( -8.0 + x * (5.0 - x )));
			return 0.0;
		}
};

class GaussNarrowFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return GaussNarrowKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_GAUSS_NARROW_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.25; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ GaussNarrowFilterKernel* a = new GaussNarrowFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double sqrt2overPi = sqrt( 2.0 / M_PI );
			return exp( -2.0 * x * x ) * sqrt2overPi ;
		}
};

class GaussMediumFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return GaussMediumKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_GAUSS_MEDIUM_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.5; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ GaussMediumFilterKernel* a = new GaussMediumFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			return pow( 2.0, -2.0 * x * x );
		}
};

class GaussWideFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return GaussWideKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_GAUSS_WIDE_KERNEL); }
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ GaussWideFilterKernel* a = new GaussWideFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			return pow( 2.0, -4.0 * x * x );
		}
};

class PavicUnitVolFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return PavicUnitVolKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_PAVIC_UNITVOL_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.0; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ PavicUnitVolFilterKernel* a = new PavicUnitVolFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x > 1.0 ) return 0.0;
			const double beta = -2.378;
			return ( 1.0 - (1.0 - exp( beta * x * x )) / (1.0 - exp( beta )) );
		}
};

class PavicOpFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return PavicOpKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_PAVIC_OP_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.0; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ PavicOpFilterKernel* a = new PavicOpFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x > 1.0 ) return 0.0;
			double alpha = 0.918;
			double beta = -1.953;
			return alpha * (1.0 - (1.0 - exp( beta * x * x )) / (1.0 - exp( beta )) );
		}
};

class HanningFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return HanningKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_HANNING_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_HANNING_COMMENT); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ HanningFilterKernel* a = new HanningFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.5;
			const double b = 0.5;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return (sincX * ( a - b * cos( t ) ));
		}
};

class HammingFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return HammingKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_HAMMING_KERNEL); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ HammingFilterKernel* a = new HammingFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.54;
			const double b = 0.46;
			double t = M_PI * 0.5 * ( 2.0 - x );
			// want cos( pi ) at x == 0, cos( 0 or 2pi ) at x == 2
			// cos( pi * t ) where t = (2 - r)/2 
			return sincX * ( a - b * cos( t ) );
		}
};

class BlackmanFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return BlackmanKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLACKMAN_KERNEL); }
		bool HasNegativeLobes(){ return TRUE; };
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ BlackmanFilterKernel* a = new BlackmanFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.42;
			const double b = 0.5;
			const double c = 0.08;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return sincX * ( a - b * cos(  t ) + c * cos( 2.0 * t ) );
		}
};

class Blackman361FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Blackman361KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLACKMAN361_KERNEL); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ Blackman361FilterKernel* a = new Blackman361FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.44959;
			const double b = 0.49364;
			const double c = 0.05677;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return sincX * ( a - b * cos(  t ) + c * cos( 2.0 * t ) );
		}
};

class Blackman367FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Blackman367KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLACKMAN367_KERNEL); }
		bool HasNegativeLobes(){ return TRUE; };
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ Blackman367FilterKernel* a = new Blackman367FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.42323;
			const double b = 0.49755;
			const double c = 0.07922;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return sincX * ( a - b * cos(  t ) + c * cos( 2.0 * t ) );
		}
};

class Blackman474FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Blackman474KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLACKMAN474_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_BLACKMAN_COMMENT); }
		bool HasNegativeLobes(){ return TRUE; };
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ Blackman474FilterKernel* a = new Blackman474FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.40217;
			const double b = 0.49703;
			const double c = 0.09392;
			const double d = 0.00183;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return sincX * ( a - b * cos( t ) + c * cos( 2.0 * t ) - d * cos( 4.0 * t ) );
		}
};

class Blackman492FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Blackman492KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLACKMAN492_KERNEL); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ Blackman492FilterKernel* a = new Blackman492FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			double s = M_PI * x;
			double sincX = ( s == 0.0 ) ? 1.0 : sin( s ) / s;
			const double a = 0.35875;
			const double b = 0.48829;
			const double c = 0.14128;
			const double d = 0.01168;
			double t = M_PI * 0.5 * ( 2.0 - x );
			return sincX * ( a - b * cos( t ) + c * cos( 2.0 * t ) - d * cos( 4.0 * t ) );
		}
};

class Max1FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Max1KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MAX1_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_MAX_COMMENT); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.4; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ Max1FilterKernel* a = new Max1FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double t = 1.3778;
			const double s = 0.4848;
			const double stInv = 1.0 / (s * t);
			const double ttms = t * (t - s);

			if ( x >= t ) return 0.0;
			if ( x > s ) 
				return (t - x) * (t - x) / ttms;
			return 1.0 - x * x * stInv;
		}
};

class Max2FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Max2KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MAX2_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.4; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ Max2FilterKernel* a = new Max2FilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double t = 1.3778;
			const double s = 0.4848;
			const double stInv = 1.0 / (s * t);
			const double ttms = t * (t - s);

			if ( x >= t ) return 0.0;
			if ( x > s ) 
				return (t - x) * (t - x) / ttms;
			return 1.0 - x * x * stInv;
		}
};

class Max3FilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return Max3KernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MAX3_KERNEL); }
		long GetKernelSupport() { return 1; };
		void GetKernelSz( double& x, double& y ){ x = 1.3; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ Max3FilterKernel* a = new Max3FilterKernel(); return a; }	
		double KernelFn( double x, double y ) {
			const double t = 1.3682;
			const double s = 0.4792;
			const double stInv = 1.0 / (s * t);
			const double ttms = t * (t - s);

			if ( x >= t ) return 0.0;
			if ( x > s ) 
				return (t - x) * (t - x) / ttms;
			return 1.0 - x * x * stInv;
		}
};

class MitNetOpFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return MitNetOpKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MITNET_OP_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_MITNET_COMMENT); }
		bool HasNegativeLobes(){ return TRUE; };
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ MitNetOpFilterKernel* a = new MitNetOpFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double b = 0.33333;
			const double c = 0.33333;

			if ( x >= 2.0 ) return 0.0;
			if ( x < 1.0 ) {
				// coeffs for x < 1, compute as const
				const double D0 = 6.0 - 2.0 * b ;  				// constant term
				const double C0 = 0.0;							// linear term
				const double B0 = -18.0 + 12.0 * b + 6.0 * c;	// quadratic term
				const double A0 = 12.0 - 9.0 * b - 6.0 * c ;	// cubic term
				return x * ( x * (A0 * x + B0) + C0 ) + D0;
			}
			// 1 < x < 2
			const double D1 = 8.0 * b + 24.0 * c ;  			// constant term
			const double C1 = -12.0 * b - 48.0 * c;				// linear term
			const double B1 = 6.0 * b + 30.0 * c;				// quadratic term
			const double A1 = - b - 6.0 * c ;					// cubic term
			return x * ( x * (A1 * x + B1) + C1 ) + D1;
		}
};

class NTSCFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return NTSCKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_NTSC_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_NTSC_COMMENT); }
		long GetKernelSupport() { return 2; };
		RefTargetHandle Clone(RemapDir& remap)
		{ NTSCFilterKernel* a = new NTSCFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			if ( x >= 2.0 ) return 0.0;
			if ( x < 1.0 )
				return -0.25 * x * x + 0.5;
			// 1 < x < 2
			return 0.25 * x * x  - x + 1.0;
		}
};

class MitNetNotchFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return MitNetNotchKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MITNET_NOTCH_KERNEL); }
		long GetKernelSupport() { return 2; };
		bool HasNegativeLobes(){ return TRUE; };
		RefTargetHandle Clone(RemapDir& remap)
		{ MitNetNotchFilterKernel* a = new MitNetNotchFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double b = 1.5;
			const double c = -0.25;

			if ( x >= 2.0 ) return 0.0;
			if ( x < 1.0 ) {
				// coeffs for x < 1, compute as const
				const double D0 = 6.0 - 2.0 * b ;  				// constant term
				const double C0 = 0.0;							// linear term
				const double B0 = -18.0 + 12.0 * b + 6.0 * c;	// quadratic term
				const double A0 = 12.0 - 9.0 * b - 6.0 * c ;	// cubic term
				return x * ( x * (A0 * x + B0) + C0 ) + D0;
			}
			// 1 < x < 2
			const double D1 = 8.0 * b + 24.0 * c ;  			// constant term
			const double C1 = -12.0 * b - 48.0 * c;				// linear term
			const double B1 = 6.0 * b + 30.0 * c;				// quadratic term
			const double A1 = - b - 6.0 * c ;					// cubic term
			return x * ( x * (A1 * x + B1) + C1 ) + D1;
		}
};

class CookOpFilterKernel : public GenericKernel {
public:
		Class_ID ClassID()      { return CookOpKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_COOK_OP_KERNEL); }
		long GetKernelSupport() { return 2; }
		void GetKernelSz( double& x, double& y ){ x = 1.5; y = 0.0; }
		RefTargetHandle Clone(RemapDir& remap)
		{ CookOpFilterKernel* a = new CookOpFilterKernel(); return a; }	
		double KernelFn( double x, double ) {
			const double w = 1.5;
			if ( x > w ) return 0.0;
			const double expW2 = exp( -(w * w) );

			return exp( -(x * x) ) - expW2;
		}
};

///////////////////////////////////////////////////////////////////////////////////
//
//	Variable size filters
//

class CylinderVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		CylinderVarFilterKernel() : w(3.0) {}
		RefTargetHandle Clone(RemapDir& remap)
		{ CylinderVarFilterKernel* a = new CylinderVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return CylinderVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CYLINDER_VAR_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_CYLVAR_COMMENT); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double ) {
			if ( x > w ) return 0.0;
			return 1.0;
		}
};

class ConeVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		ConeVarFilterKernel() : w(1.5) {}
		RefTargetHandle Clone(RemapDir& remap)
		{ ConeVarFilterKernel* a = new ConeVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return ConeVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CONE_VAR_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_CONEVAR_COMMENT); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
//		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 1.0 : x; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double y ) {return ( x < w ) ? (w - x)/w : 0.0;}
};

class QuadraticVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		QuadraticVarFilterKernel() : w(1.5) {}
		RefTargetHandle Clone(RemapDir& remap)
		{ QuadraticVarFilterKernel* a = new QuadraticVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return QuadraticVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_QUADRATIC_VAR_KERNEL); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
//		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 1.5 : x; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		
		double KernelFn( double x, double ) {
			assert ( w != 0.0 );
			double r = 1.5 * x / w;
			if ( r < 0.5 ) return 0.75 - r * r;
			if ( r < 1.5 ) {
				double t = r - 1.5; 
				return 0.5 * t * t;
			}
			return 0.0f;
		}
};

class CubicVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		CubicVarFilterKernel() : w(2.0) {}
		RefTargetHandle Clone(RemapDir& remap)
		{ CubicVarFilterKernel* a = new CubicVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return CubicVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_CUBIC_VAR_KERNEL); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
//		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 2.0 : x; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double ) {
			assert ( w != 0.0 );
			double r = 2.0 * x / w;
			if ( r < 1.0 ) return (4.0 + r * r * (-6.0 + r * 3.0))/6.0;
			if ( r < 2.0 ) { 
				double t = 2.0 - r; 
				return t * t * t / 6.0; 
			}
			return 0.0;
		}
};

class CookVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		CookVarFilterKernel() : w(1.25) {}
		RefTargetHandle Clone(RemapDir& remap)
		{ CookVarFilterKernel* a = new CookVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return CookVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_COOK_VAR_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_COOK_COMMENT); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
//		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 1.5 : x; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double ) {
			if ( x > w ) return 0.0;
			double expW2 = exp( -(w * w) );

			return exp( -(x * x) ) - expW2;
		}
};

class GaussVarFilterKernel : public GenericKernel {
	private:
		double	w;
	public:
		GaussVarFilterKernel() : w(3.0) {};
		RefTargetHandle Clone(RemapDir& remap)
		{ GaussVarFilterKernel* a = new GaussVarFilterKernel(); a->w = w; return a; }	
		Class_ID ClassID()      { return GaussVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_GAUSS_VAR_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_GAUSSVAR_COMMENT); }
		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
//		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 1.5 : x; };
		void SetKernelSz( double x, double y = 0.0 ) { w = (x < LOW_THRESH)? LOW_THRESH : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }
		double KernelFn( double x, double ) {
			double r = 2.0 * x / w;
			return pow( 2.0, -2.0 * r * r );
		}
};



//------------------------------ Class Descriptors ----------------------------------------
class GenericKernelClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	SClass_ID		SuperClassID() { return FILTER_KERNEL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
};

class AreaKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new AreaFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_AREA_KERNEL); }
	Class_ID		ClassID() { return AreaKernelClassID; }
};
static AreaKernelClassDesc areaCD;
ClassDesc* GetAreaKernelDesc() {return &areaCD;}

//////////////////////////////////////////////////////////////////////////////
//	 PixelsSize filter, for 2.5 compatibility & camera mapping
#ifdef INCLUDE_PIXELSIZE 
class PixelSizeKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new PixelSizeKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_PIXELSIZE_KERNEL); }
	Class_ID		ClassID() { return PixelSizeKernelClassID; }
};
static PixelSizeKernelClassDesc pixelSizeCD;
ClassDesc* GetPixelSizeKernelDesc() {return &pixelSizeCD;}
#endif ////////////////////////////////////////////////////////////////////////

class ConeKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new ConeFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CONE_KERNEL); }
	Class_ID		ClassID() { return ConeKernelClassID; }
};
static ConeKernelClassDesc coneCD;
ClassDesc* GetConeKernelDesc() {return &coneCD;}

class QuadraticKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new QuadraticFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_QUADRATIC_KERNEL); }
	Class_ID		ClassID() { return QuadraticKernelClassID; }
};
static QuadraticKernelClassDesc quadCD;
ClassDesc* GetQuadraticKernelDesc() {return &quadCD;}

class CubicKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CubicFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CUBIC_KERNEL); }
	Class_ID		ClassID() { return CubicKernelClassID; }
};
static CubicKernelClassDesc cubicCD;
ClassDesc* GetCubicKernelDesc() {return &cubicCD;}

class CatRomKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CatRomFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CATROM_KERNEL); }
	Class_ID		ClassID() { return CatRomKernelClassID; }
};
static CatRomKernelClassDesc CatRomCD;
ClassDesc* GetCatRomKernelDesc() {return &CatRomCD;}

class GaussNarrowKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new GaussNarrowFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_GAUSS_NARROW_KERNEL); }
	Class_ID		ClassID() { return GaussNarrowKernelClassID; }
};
static GaussNarrowKernelClassDesc GaussNarrowCD;
ClassDesc* GetGaussNarrowKernelDesc() {return &GaussNarrowCD;}

class GaussMediumKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new GaussMediumFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_GAUSS_MEDIUM_KERNEL); }
	Class_ID		ClassID() { return GaussMediumKernelClassID; }
};
static GaussMediumKernelClassDesc GaussMediumCD;
ClassDesc* GetGaussMediumKernelDesc() {return &GaussMediumCD;}

class GaussWideKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new GaussWideFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_GAUSS_WIDE_KERNEL); }
	Class_ID		ClassID() { return GaussWideKernelClassID; }
};
static GaussWideKernelClassDesc GaussWideCD;
ClassDesc* GetGaussWideKernelDesc() {return &GaussWideCD;}

class PavicUnitVolKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new PavicUnitVolFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_PAVIC_UNITVOL_KERNEL); }
	Class_ID		ClassID() { return PavicUnitVolKernelClassID; }
};
static PavicUnitVolKernelClassDesc PavicUnitVolCD;
ClassDesc* GetPavicUnitVolKernelDesc() {return &PavicUnitVolCD;}

class PavicOpKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new PavicOpFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_PAVIC_OP_KERNEL); }
	Class_ID		ClassID() { return PavicOpKernelClassID; }
};
static PavicOpKernelClassDesc PavicOpCD;
ClassDesc* GetPavicOpKernelDesc() {return &PavicOpCD;}

class HanningKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new HanningFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_HANNING_KERNEL); }
	Class_ID		ClassID() { return HanningKernelClassID; }
};
static HanningKernelClassDesc HanningCD;
ClassDesc* GetHanningKernelDesc() {return &HanningCD;}

class HammingKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new HammingFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_HAMMING_KERNEL); }
	Class_ID		ClassID() { return HammingKernelClassID; }
};
static HammingKernelClassDesc HammingCD;
ClassDesc* GetHammingKernelDesc() {return &HammingCD;}

class BlackmanKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new BlackmanFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLACKMAN_KERNEL); }
	Class_ID		ClassID() { return BlackmanKernelClassID; }
};
static BlackmanKernelClassDesc BlackmanCD;
ClassDesc* GetBlackmanKernelDesc() {return &BlackmanCD;}

class Blackman367KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Blackman367FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLACKMAN367_KERNEL); }
	Class_ID		ClassID() { return Blackman367KernelClassID; }
};
static Blackman367KernelClassDesc Blackman367CD;
ClassDesc* GetBlackman367KernelDesc() {return &Blackman367CD;}

class Blackman361KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Blackman361FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLACKMAN361_KERNEL); }
	Class_ID		ClassID() { return Blackman361KernelClassID; }
};
static Blackman361KernelClassDesc Blackman361CD;
ClassDesc* GetBlackman361KernelDesc() {return &Blackman361CD;}

class Blackman474KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Blackman474FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLACKMAN474_KERNEL); }
	Class_ID		ClassID() { return Blackman474KernelClassID; }
};
static Blackman474KernelClassDesc Blackman474CD;
ClassDesc* GetBlackman474KernelDesc() {return &Blackman474CD;}

class Blackman492KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Blackman492FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLACKMAN492_KERNEL); }
	Class_ID		ClassID() { return Blackman492KernelClassID; }
};
static Blackman492KernelClassDesc Blackman492CD;
ClassDesc* GetBlackman492KernelDesc() {return &Blackman492CD;}

class	Max1KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Max1FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MAX1_KERNEL); }
	Class_ID		ClassID() { return Max1KernelClassID; }
};
static Max1KernelClassDesc Max1CD;
ClassDesc* GetMax1KernelDesc() {return &Max1CD;}

class	Max2KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Max2FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MAX2_KERNEL); }
	Class_ID		ClassID() { return Max2KernelClassID; }
};
static Max2KernelClassDesc Max2CD;
ClassDesc* GetMax2KernelDesc() {return &Max2CD;}

class	Max3KernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new Max3FilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MAX3_KERNEL); }
	Class_ID		ClassID() { return Max3KernelClassID; }
};
static Max3KernelClassDesc Max3CD;
ClassDesc* GetMax3KernelDesc() {return &Max3CD;}

class	MitNetOpKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new MitNetOpFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MITNET_OP_KERNEL); }
	Class_ID		ClassID() { return MitNetOpKernelClassID; }
};
static MitNetOpKernelClassDesc MitNetOpCD;
ClassDesc* GetMitNetOpKernelDesc() {return &MitNetOpCD;}

class	MitNetNotchKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new MitNetNotchFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MITNET_NOTCH_KERNEL); }
	Class_ID		ClassID() { return MitNetNotchKernelClassID; }
};
static MitNetNotchKernelClassDesc MitNetNotchCD;
ClassDesc* GetMitNetNotchKernelDesc() {return &MitNetNotchCD;}

class	NTSCKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new NTSCFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_NTSC_KERNEL); }
	Class_ID		ClassID() { return NTSCKernelClassID; }
};
static NTSCKernelClassDesc NtscCD;
ClassDesc* GetNTSCKernelDesc() {return &NtscCD;}

class	CookOpKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CookOpFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_COOK_OP_KERNEL); }
	Class_ID		ClassID() { return CookOpKernelClassID; }
};
static CookOpKernelClassDesc CookOpCD;
ClassDesc* GetCookOpKernelDesc() {return &CookOpCD;}

// ----------------- soften filters -----------------------------
class	GaussVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new GaussVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_GAUSS_VAR_KERNEL); }
	Class_ID		ClassID() { return GaussVarKernelClassID; }
};
static GaussVarKernelClassDesc GaussVarCD;
ClassDesc* GetGaussVarKernelDesc() {return &GaussVarCD;}

class	CookVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CookVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_COOK_VAR_KERNEL); }
	Class_ID		ClassID() { return CookVarKernelClassID; }
	bool IsVariableSz(){ return TRUE; };
};

static CookVarKernelClassDesc CookVarCD;
ClassDesc* GetCookVarKernelDesc() {return &CookVarCD;}

class	CylinderVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CylinderVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CYLINDER_VAR_KERNEL); }
	Class_ID		ClassID() { return CylinderVarKernelClassID; }
	bool IsVariableSz(){ return TRUE; };
};
static CylinderVarKernelClassDesc CylinderVarCD;
ClassDesc* GetCylinderVarKernelDesc() {return &CylinderVarCD;}


class	ConeVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new ConeVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CONE_VAR_KERNEL); }
	Class_ID		ClassID() { return ConeVarKernelClassID; }
	bool IsVariableSz(){ return TRUE; };
};
static ConeVarKernelClassDesc ConeVarCD;
ClassDesc* GetConeVarKernelDesc() {return &ConeVarCD;}

class	QuadraticVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new QuadraticVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_QUADRATIC_VAR_KERNEL); }
	Class_ID		ClassID() { return QuadraticVarKernelClassID; }
	bool IsVariableSz(){ return TRUE; };
};
static QuadraticVarKernelClassDesc QuadraticVarCD;
ClassDesc* GetQuadraticVarKernelDesc() {return &QuadraticVarCD;}

class	CubicVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new CubicVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CUBIC_VAR_KERNEL); }
	Class_ID		ClassID() { return CubicVarKernelClassID; }
	bool IsVariableSz(){ return TRUE; };
};
static CubicVarKernelClassDesc CubicVarCD;
ClassDesc* GetCubicVarKernelDesc() {return &CubicVarCD;}

// ----------------------- Mitchell / Netravali variable filter ----------------------------

// Parameter Description
#define PB_B	0
#define PB_C	1

/*
static ParamUIDesc descParam[] = {
	// B Spinner
	ParamUIDesc(
		PB_B,
		EDITTYPE_FLOAT, 
		IDC_MITNET_B, IDC_MITNET_B_SPIN, 
		0.0, 1.0, 
		SPIN_AUTOSCALE), 

	// C Spinner
	ParamUIDesc(
		PB_C, 
		EDITTYPE_FLOAT, 
		IDC_MITNET_C, IDC_MITNET_C_SPIN, 
		0.0, 1.0, 
		SPIN_AUTOSCALE), 
};
#define PARAMDESC_LENGTH 2
*/

static ParamBlockDescID MitNetDescV0[] = {
	{ TYPE_FLOAT, NULL, FALSE, PB_B }, // B [0]
	{ TYPE_FLOAT, NULL, FALSE, PB_C }  // C [1]
}; 	
#define MNPBLOCK_LENGTH 2

// Version definition
#define MNNUM_OLDVERSIONS	0
#define MNCURRENT_VERSION	1
static ParamVersionDesc curMitnetVersion( MitNetDescV0, MNPBLOCK_LENGTH, MNCURRENT_VERSION );


//--- Variable Mitchell / Netvravali filter --------------------------------------------
//class MitNetDlgProc;
//class MitNetParamDlg;

class MitNetVarFilterKernel : public GenericKernel {
	private:
		double b ;
		double c ;
	public:
//		static MitNetDlgProc *	pDlgProc;
		// Parameters
		IParamBlock *pParamBlock;

		MitNetVarFilterKernel();

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rTarget);

		RefResult NotifyRefChanged(
					Interval changeInt, 
					RefTargetHandle hTarget, 
					PartID& partID,  
					RefMessage message	);

//		FilterKernelParamDlg * CreateParamDialog(IRendParams *ip);

		Class_ID ClassID()      { return MitNetVarKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_MITNET_VAR_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_MITNET_COMMENT); }
		
		// support both the optional parameters
		long GetNFilterParams() { return 2; }
		TCHAR * GetFilterParamName( long nParam ) { 
			return GetString( nParam ? IDS_KE_MITNET_PARAM_C:IDS_KE_MITNET_PARAM_B );
		}
		double GetFilterParam( long nParam ){ return nParam ? c : b; }
		void SetFilterParam( long nParam, double val ){ 
			if (nParam) {  
				c = val;	
				pParamBlock->SetValue( PB_C, 0, float( val ) );		
 			} else { 
				b = val; 
				pParamBlock->SetValue( PB_B, 0, float( val ) );		
			}
		}
		RefTargetHandle Clone(RemapDir& remap)
		{ MitNetVarFilterKernel* a = new MitNetVarFilterKernel();
		   a->SetFilterParam(0,b); a->SetFilterParam(1,c); return a; }	

		void Update(TimeValue t, Interval& valid){
			float val;
			pParamBlock->GetValue( PB_B, t, val, valid ); b = val;
			pParamBlock->GetValue( PB_C, t, val, valid ); c = val;
		}

		long GetKernelSupport() { return 2; }
		double KernelFn( double x, double ) {

			// fill in b & c 
			float val = 0.0f;
			Interval valid;

			pParamBlock->GetValue( PB_B, 0, val, valid );
			b = double( val );
			pParamBlock->GetValue( PB_C, 0, val, valid );
			c = double( val );

			if ( x >= 2.0 ) return 0.0;
			if ( x < 1.0 ) {
				// coeffs for x < 1, compute as const
				double D0 = 6.0 - 2.0 * b ;  			// constant term
				double B0 = -18.0 + 12.0 * b + 6.0 * c;	// quadratic term
				double A0 = 12.0 - 9.0 * b - 6.0 * c ;	// cubic term
				return x * ( x * (A0 * x + B0) ) + D0;
			}
			// 1 < x < 2
			double D1 = 8.0 * b + 24.0 * c ;  			// constant term
			double C1 = -12.0 * b - 48.0 * c;			// linear term
			double B1 = 6.0 * b + 30.0 * c;				// quadratic term
			double A1 = - b - 6.0 * c ;					// cubic term
			return x * ( x * (A1 * x + B1) + C1 ) + D1;
		}
};


// MitNetDlgProc *MitNetVarFilterKernel::pDlgProc = NULL;

MitNetVarFilterKernel::MitNetVarFilterKernel()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(MitNetDescV0, MNPBLOCK_LENGTH, MNCURRENT_VERSION));
	assert(pParamBlock);
	//valid.SetEmpty();
	b = c = 0.33333f;
	pParamBlock->SetValue( PB_B, 0, 0.3333f );		
	pParamBlock->SetValue( PB_C, 0, 0.3333f );		
}


Animatable* MitNetVarFilterKernel::SubAnim(int i) 
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}



TSTR MitNetVarFilterKernel::SubAnimName(int i) 
{
	switch (i) {
		case 0: return GetString(IDS_KE_MITNET_PARAMS);
		default: return _T("");
	}
}

RefTargetHandle MitNetVarFilterKernel::GetReference(int i)
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}

void MitNetVarFilterKernel::SetReference(int i, RefTargetHandle rtArg)
{
	switch (i) {
		case 0: pParamBlock = (IParamBlock*)rtArg; break;
	}
}

RefResult MitNetVarFilterKernel::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	switch (message) {
		case REFMSG_CHANGE:
			//valid.SetEmpty();
//			if (pDlgProc)
//				pDlgProc->Invalidate();
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_B:			 	gpd->dim = stdNormalizedDim; break;
				case PB_C:				gpd->dim = stdNormalizedDim; break;
				default: 				gpd->dim = defaultDim;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_B:				gpn->name = GetString(IDS_KE_MITNET_PARAM_B); break;
				case PB_C:				gpn->name = GetString(IDS_KE_MITNET_PARAM_C); break;
				default:				gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}


// --------------------- Class Description ----------------------------------------
class	MitNetVarKernelClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new MitNetVarFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MITNET_VAR_KERNEL); }
	Class_ID		ClassID() { return MitNetVarKernelClassID; }
};
static MitNetVarKernelClassDesc MitNetVarCD;
ClassDesc* GetMitNetVarKernelDesc() {return &MitNetVarCD;}


// ----------------------- Stocking variable filter ----------------------------

// Parameter Description
#define PB_BLEND		0
#define PB_SHARPNESS	1


static ParamBlockDescID StockingDescV0[] = {
	{ TYPE_FLOAT, NULL, FALSE, PB_BLEND }, // blend, 0 is sharp 1 is blurry
	{ TYPE_FLOAT, NULL, FALSE, PB_SHARPNESS }, // radius of sharp cylinder
}; 	
#define STPBLOCK_LENGTH 2

// Version definition
#define STNUM_OLDVERSIONS	0
#define STCURRENT_VERSION	1
static ParamVersionDesc curStockingVersion( StockingDescV0, STPBLOCK_LENGTH, STCURRENT_VERSION );


//-------- Stocking filter: blend between area & gauss soften --------------------------
#define N_STOCKING_FILTER_PARAMS	2		// 1 is just blend, 2 includes sharpness
class StockingFilterKernel : public GenericKernel {
	private:
		float   blend ;
		float   sharpness;
		double  cylRadius ;	//internal
		double	w;

	public:
		// Parameters
		IParamBlock *pParamBlock;

		StockingFilterKernel();

		RefTargetHandle Clone(RemapDir& remap)
		{ StockingFilterKernel* a = new StockingFilterKernel();
		   a->SetFilterParam(0,blend); a->SetFilterParam(1,sharpness); 
		   a->w = w; 
		   return a; 
		}	
		void Update(TimeValue t, Interval& valid){
			float val;
			pParamBlock->GetValue( PB_BLEND, t, val, valid ); blend = val;
			pParamBlock->GetValue( PB_SHARPNESS, t, val, valid ); sharpness = val;
		}

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rTarget);

		RefResult NotifyRefChanged(
					Interval changeInt, 
					RefTargetHandle hTarget, 
					PartID& partID,  
					RefMessage message	);

		Class_ID ClassID()      { return StockingKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_STOCKING_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_STOCKING_COMMENT); }
		
		// support both the optional parameters
		long GetNFilterParams() { return N_STOCKING_FILTER_PARAMS; }
		TCHAR * GetFilterParamName( long nParam ) { return  GetString( nParam==0 ? IDS_KE_STOCKING_BLEND: IDS_KE_STOCKING_SHARPNESS ); }
		double GetFilterParam( long nParam ){ return nParam ? sharpness : blend; }
		void SetFilterParam( long nParam, double val );

		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
		void SetKernelSz( double x, double y = 0.0 ) { w = (x == 0.0)? 0.0001 : x; };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }

		double KernelFn( double x, double ) {
			if ( x > w ) return 0.0;
			double r = 2.0 * x / w;
			double h = 2.0f * cylRadius / w; //correct for un-equal volumes
			double g = blend * h * pow( 2.0, -2.0 * r * r );
			if ( x < cylRadius ) {
				// inside the cylindrical area filter, add it's part
				g += (1.0 - blend);
			}
			if ( g > 1.0 ) g = 1.0;
			return g;
		}

};



StockingFilterKernel::StockingFilterKernel ()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(StockingDescV0, STPBLOCK_LENGTH, STCURRENT_VERSION));
	assert(pParamBlock);
	blend = 0.3f;
	w = 4.0;
	pParamBlock->SetValue( PB_BLEND, 0, blend );
	sharpness = 0.6f; // d = 2 at s == 0 && d = 1 at s == 1; r = 0.5d
	cylRadius = (2.0f - sharpness) * 0.5f;
	pParamBlock->SetValue( PB_SHARPNESS, 0, sharpness );		
}

void StockingFilterKernel::SetFilterParam( long nParam, double val )
{ 
	if ( nParam == 0 ) {
		blend = float(val);	
		pParamBlock->SetValue( PB_BLEND, 0, blend );		
	} else {
		sharpness = float(val);	
		cylRadius = (2.0f - sharpness) * 0.5f;
		pParamBlock->SetValue( PB_SHARPNESS, 0, sharpness );		
	}
}

Animatable* StockingFilterKernel::SubAnim(int i) 
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}



TSTR StockingFilterKernel::SubAnimName(int i) 
{
	switch (i) {
		case 0: return GetString(IDS_KE_STOCKING_PARAMS);
		default: return _T("");
	}
}

RefTargetHandle StockingFilterKernel::GetReference(int i)
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}

void StockingFilterKernel::SetReference(int i, RefTargetHandle rtArg)
{
	switch (i) {
		case 0: pParamBlock = (IParamBlock*)rtArg; break;
	}
}

RefResult StockingFilterKernel::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_SHARPNESS:	 	gpd->dim = stdNormalizedDim; break;
				case PB_BLEND:		 	gpd->dim = stdNormalizedDim; break;
				default: 				gpd->dim = defaultDim;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
			case PB_BLEND:			gpn->name = GetString(IDS_KE_STOCKING_BLEND); break;
			case PB_SHARPNESS:		gpn->name = GetString(IDS_KE_STOCKING_SHARPNESS); break;
				default:			gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}


// --------------------- Class Description ----------------------------------------
class	StockingClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new StockingFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_STOCKING_KERNEL); }
	Class_ID		ClassID() { return StockingKernelClassID; }
};
static StockingClassDesc StockingCD;
ClassDesc* GetStockingKernelDesc() {return &StockingCD;}


// ----------------------- Blend variable filter ----------------------------

// Parameter Description
#define PB_BLEND		0


static ParamBlockDescID BlendDescV0[] = {
	{ TYPE_FLOAT, NULL, FALSE, PB_BLEND }, // blend, 0 is sharp 1 is blurry
}; 	
#define BLPBLOCK_LENGTH 1

// Version definition
#define BLNUM_OLDVERSIONS	0
#define BLCURRENT_VERSION	1
static ParamVersionDesc curBlendVersion( BlendDescV0, BLPBLOCK_LENGTH, BLCURRENT_VERSION );




//-------- New Blend filter: blend between max1 and quadratic soften ------------------
class BlendFilterKernel : public GenericKernel {
	private:
		float   blend ;
		float	w;

	public:
		// Parameters
		IParamBlock *pParamBlock;

		BlendFilterKernel();
		RefTargetHandle Clone(RemapDir& remap)
		{ BlendFilterKernel* a = new BlendFilterKernel();
		   a->SetFilterParam(0,blend); a->w = w; 
		   return a; 
		}	
		void Update(TimeValue t, Interval& valid){
			float val;
			pParamBlock->GetValue( PB_BLEND, t, val, valid ); blend = val;
		}

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rTarget);

		RefResult NotifyRefChanged(
					Interval changeInt, 
					RefTargetHandle hTarget, 
					PartID& partID,  
					RefMessage message	);

		Class_ID ClassID()      { return BlendKernelClassID; }
		TCHAR *GetObjectName()  { return GetString(IDS_KE_BLEND_KERNEL); }
		TCHAR * GetDefaultComment() { return GetString(IDS_KE_BLEND_COMMENT); }
		
		// support both the optional parameters
		long GetNFilterParams() { return 1; }
		TCHAR * GetFilterParamName( long nParam ) { return  nParam==0 ? GetString(IDS_KE_STOCKING_BLEND) : NULL; }
		double GetFilterParam( long nParam ){ return nParam==0 ? blend : 0.0; }
		void SetFilterParam( long nParam, double val );

		long GetKernelSupport() { return long( w + 0.5 ); }
		bool IsVariableSz(){ return TRUE; };
		// 1-D filters ignore the y parameter
		void SetKernelSz( double x, double y = 0.0 ) { w = float((x == 0.0)? 0.0001 : x ); };
		void GetKernelSz( double& x, double& y ){ x = w; y = 0.0; }

		double KernelFn( double x, double ) {
			if ( x > w ) return 0.0;

			const double Pi = 3.14159;
			const double t = 1.3778;
			const double s = 0.4848;
			const double t2 = t*t;
			const double s2 = s*s;
			const double stInv = 1.0 / (s * t);
			const double ttms = t * (t - s);
			const double v = 2.0 * Pi * (s2 * 0.5 - s2*s/(4.0 * t) + t2 * t2 /(12.0*ttms)
							+ s2*t2/(2.0*ttms) + 2.0*s2*s*t/(3.0*ttms) - s2*s2/(4.0*ttms) );
			double h =/* 2.0* */ v / (Pi * w * w); 
			double g = blend * h;

			if ( x >= t ) return g;

			if ( x > s ) 
				g += (1.0-blend) * (t - x) * (t - x) / ttms;
			else 
				g += (1.0-blend) * (1.0 - x * x * stInv);

			if ( g > 1.0 ) g = 1.0;
			return g;
		}

};



BlendFilterKernel::BlendFilterKernel ()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(BlendDescV0, BLPBLOCK_LENGTH, BLCURRENT_VERSION));
	assert(pParamBlock);
	blend = 0.3f;
	w = 4.0;
	pParamBlock->SetValue( PB_BLEND, 0, blend );
}

void BlendFilterKernel::SetFilterParam( long nParam, double val )
{ 
	if ( nParam == 0 ) {
		blend = float(val);	
		pParamBlock->SetValue( PB_BLEND, 0, blend );		
	}
}

Animatable* BlendFilterKernel::SubAnim(int i) 
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}



TSTR BlendFilterKernel::SubAnimName(int i) 
{
	switch (i) {
		case 0: return GetString(IDS_KE_STOCKING_PARAMS);
		default: return _T("");
	}
}

RefTargetHandle BlendFilterKernel::GetReference(int i)
{
	switch (i) {
		case 0: return pParamBlock;
		default: return NULL;
	}
}

void BlendFilterKernel::SetReference(int i, RefTargetHandle rtArg)
{
	switch (i) {
		case 0: pParamBlock = (IParamBlock*)rtArg; break;
	}
}

RefResult BlendFilterKernel::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_BLEND:		 	gpd->dim = stdNormalizedDim; break;
				default: 				gpd->dim = defaultDim;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
			case PB_BLEND:			gpn->name = GetString(IDS_KE_STOCKING_BLEND); break;
				default:			gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}


// --------------------- Class Description ----------------------------------------
class	BlendClassDesc : public GenericKernelClassDesc {
public:
	void *			Create(BOOL loading) { return new BlendFilterKernel; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_BLEND_KERNEL); }
	Class_ID		ClassID() { return BlendKernelClassID; }
};
static BlendClassDesc BlendCD;
ClassDesc* GetBlendKernelDesc() {return &BlendCD;}




/***************** rollup version

//--- Mitchell/Netravali DlgProc -----------------------------------------

class MitNetDlgProc : public ParamMapUserDlgProc {
	public:
		IParamMap *pMap;
		MitNetVarFilterKernel * pKernel;
		IRendParams *pParams;
		HWND hWnd;

		MitNetDlgProc( IParamMap *map, MitNetVarFilterKernel *kern, IRendParams *par );
		~MitNetDlgProc();

		void Init();
		void SetState();
		void Invalidate() { pMap->Invalidate(); } //{ if (hWnd) InvalidateRect(hWnd,NULL,0); }
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() { delete this; }
	};
  
MitNetDlgProc::MitNetDlgProc(IParamMap *map, MitNetVarFilterKernel *kern, IRendParams *par) 
{
	this->pMap = map;
	pKernel = kern;
	pParams  = par;
	pKernel->pDlgProc = this;
}

MitNetDlgProc::~MitNetDlgProc()
{
	pKernel->pDlgProc = NULL;
}

void MitNetDlgProc::Init()
{
}

void MitNetDlgProc::SetState()
{
}

BOOL MitNetDlgProc::DlgProc(
		TimeValue t, IParamMap *map, HWND hWnd,
		UINT msg, WPARAM wParam, LPARAM lParam )
{
	switch (msg) {
		case WM_INITDIALOG:
			this->hWnd = hWnd;
			Init();
			SetState();
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			break;
	}
	return FALSE;
}


//--- Mitchell/ Netravali ParamDlg -------------------------------------------------------

class MitNetParamDlg : public FilterKernelParamDlg {
	public:
		MitNetVarFilterKernel * pKernel;
		IRendParams *pParams;
		IParamMap *pMap;

		MitNetParamDlg( MitNetVarFilterKernel *kern, IRendParams *par ); 
		Class_ID ClassID() { return StdKernelClassID; }
		ReferenceTarget* GetThing() { return pKernel;}
		void SetThing( ReferenceTarget *m );		
		void DeleteThis();
};


MitNetParamDlg::MitNetParamDlg( MitNetVarFilterKernel *kern, IRendParams *par ) 
{
	pKernel = kern;
	pParams = par;	
	pMap = CreateRParamMap(
		descParam, PARAMDESC_LENGTH,
		pKernel->pParamBlock,
		par,
		hInstance,
		MAKEINTRESOURCE(IDD_MITNET_PARAMS),
		GetString(IDS_KE_MITNET_PARAMS),
		0);
	
	pMap->SetUserDlgProc(new MitNetDlgProc(pMap, pKernel, pParams));	
}

void MitNetParamDlg::SetThing(ReferenceTarget *m)
{
	assert(m->ClassID()== pKernel->ClassID());
	pKernel = (MitNetVarFilterKernel*)m;
	pMap->SetParamBlock( pKernel->pParamBlock );
	pMap->SetUserDlgProc( new MitNetDlgProc(pMap, pKernel, pParams) );	
	if (pKernel->pDlgProc) {
		pKernel->pDlgProc->pKernel = pKernel;		
		pKernel->pDlgProc->Init();
		pKernel->pDlgProc->SetState();
	}
}

void MitNetParamDlg::DeleteThis()
{
	DestroyRParamMap(pMap);
	delete this;
}

// ------------------------ must be here due to class interlock dependency ------------------------
FilterKernelParamDlg * MitNetVarFilterKernel::CreateParamDialog(IRendParams *ip)
{	
	return new MitNetParamDlg(this,ip);
}

**************/




////////////////////////////////////////////////////////////////////
// anisotropic filters not supported yet
// shirley's filter, 1 pixels
float shirleyFilter( float x, float y )
{
	if ( x >= 1.0f || y >= 1.0f ) return 0.0f;
	return (1.0f - x ) * ( 1.0f - y);
}

// simple box filter, equivalent to default filter, 1 pixel
float boxFilter( float x, float y )
{
	if ( x >= 1.0f || y >= 1.0f ) return 0.0f;
	return 1.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\procmap.cpp ===
/**********************************************************************
 *<
	FILE: procmap.cpp

	DESCRIPTION:   textures

	CREATED BY: Dan Silva

	HISTORY: created 15 Feb  1997

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "procmaps.h"
#include "resource.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();

		// register SXP readers
		RegisterSXPReader(_T("PLANET_I.SXP"), Class_ID(PLANET_CLASS_ID,0));
		RegisterSXPReader(_T("STUCCO_I.SXP"), Class_ID(STUCCO_CLASS_ID,0));
		RegisterSXPReader(_T("SMOKE_I.SXP"), Class_ID(SMOKE_CLASS_ID,0));
		RegisterSXPReader(_T("SPECKL_I.SXP"), Class_ID(SPECKLE_CLASS_ID,0));
		RegisterSXPReader(_T("SPLAT_I.SXP"), Class_ID(SPLAT_CLASS_ID,0));
		RegisterSXPReader(_T("WATER_I.SXP"), Class_ID(WATER_CLASS_ID,0));
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_DS_PROCMAPDESC); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 6;}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i) {
	switch(i) {
		case  0: return GetPlanetDesc();
		case  1: return GetSmokeDesc();
		case  2: return GetSpeckleDesc();
		case  3: return GetStuccoDesc();
		case  4: return GetWaterDesc();
		case  5: return GetSplatDesc();
		default: return 0;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\PreFilters\sampKernel.cpp ===
/**********************************************************************
 *<
	FILE: sampkernel.cpp	

	DESCRIPTION: Simple prefilter kernel....the cylinder of radius 0.5 pixels

	CREATED BY: Kells Elmquist

	HISTORY: created 7/29/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "kernelhdr.h"
#include "kernelres.h"
//#include "imtl.h"
//#include <bmmlib.h>
#include "iparamm.h"

#define SAMPKERNEL_CLASS_ID 0x77912300

Class_ID sampKernelClassID(SAMPKERNEL_CLASS_ID ,0);
#define SAMPKERNEL_CLASSNAME   GetString(IDS_KE_SAMPKERNEL)


class SampKernelDlgProc; // forward

class SampleKernel: public FilterKernel {
	public:
		// Parameters
		IParamBlock *pblock;
		
		// Caches
		static SampKernelDlgProc *dlg;

		SampleKernel();
		~SampleKernel() { 	};

		// >>>> is a kernel w/ no params animatable ???

		// Animatable/Reference
		int NumSubs() {return 1;};
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int NumRefs() {return 1;};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		Class_ID ClassID() {return sampKernelClassID;};
		void GetClassName(TSTR& s) {s=SAMPKERNEL_CLASSNAME;};
		void DeleteThis() {delete this;};
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload);
		IOResult SampleKernel::Save(ISave *isave);

		TSTR GetName() { return SAMPKERNEL_CLASSNAME; }
//		FilterKernelParamDlg *CreateParamDialog(IRendParams *ip);

		// there are 2 optional 0...1 parameters
		long GetNFilterParams() { return 0; }
		TCHAR * GetFilterParamName( long nParam ) { return GetString( IDS_KE_BLANK );	}
		double GetFilterParam( long nParam ){ return 0.0; }
		void SetFilterParam( long nParam, double val ){}
		TCHAR * GetDefaultComment() { return GetString( IDS_KE_BLANK); }

		double KernelFn( double x, double y );

		// integer number of pixels from center to filter 0 edge, must not truncate filter
		// x dimension for 2D filters
		long GetKernelSupport(){ return 1; }

		// for 2d returns y support, for 1d returns 0
		long GetKernelSupportY(){ return 0; }

		bool Is2DKernel(){ return FALSE; }
		bool IsVariableSz(){ return FALSE; }
		// 1-D filters ignore the y parameter, return it as 0.0
		void SetKernelSz( double x, double y = 0.0 ){}
		void GetKernelSz( double& x, double& y ){ x = 0.5; y = 0.0; }

		// returning true will disable the built-in normalizer
		bool IsNormalized(){ return FALSE; }

		// this is for possible future optimizations, not sure its needed
		bool HasNegativeLobes(){ return FALSE; }
	};
/*
class SampKernelParamDlg : public FilterKernelParamDlg {
	public:
		SampleKernel *eff;
		IRendParams *ip;
		IParamMap *pmap;

		SampKernelParamDlg(SampleKernel *f,IRendParams *i);
		Class_ID ClassID() {return sampKernelClassID;}
		ReferenceTarget* GetThing() {return eff;}
		void SetThing(ReferenceTarget *m);		
		void DeleteThis();
	};
*/

class SampKernelClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SampleKernel; }
	const TCHAR *	ClassName() { return SAMPKERNEL_CLASSNAME; }
	SClass_ID		SuperClassID() { return FILTER_KERNEL_CLASS_ID; }
	Class_ID 		ClassID() { return sampKernelClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static SampKernelClassDesc sampKernelCD;
ClassDesc* GetSampKernelDesc() {return &sampKernelCD;}

// Parameter Block
#define	PB_DUMMY_PARM	0

static ParamUIDesc descParam[] = {
	ParamUIDesc(PB_DUMMY_PARM , TYPE_SINGLECHEKBOX, 0 )
	
	};
#define PARAMDESC_LENGH 1

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, TRUE, 0 } // dummy param, for demonstration only
	}; 	
#define PBLOCK_LENGTH 1


#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	1

//static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);
static ParamVersionDesc curVersion(NULL, 0, CURRENT_VERSION);

/******************
//--- SampKernelDlgProc ----------------------------------------------------------

class SampKernelDlgProc : public ParamMapUserDlgProc {
	public:
		IParamMap *pmap;
		SampleKernel *eff;
		IRendParams *ip;
		HWND hWnd;

		SampKernelDlgProc(IParamMap *pmap,SampleKernel *f,IRendParams *i);
		~SampKernelDlgProc();

		void Init();
		void SetState();
		void Invalidate() {pmap->Invalidate();}//{ if (hWnd) InvalidateRect(hWnd,NULL,0); }
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};
  
//------------------------------------------------------------------------------

SampKernelDlgProc::SampKernelDlgProc(IParamMap *pmap, SampleKernel *f,IRendParams *i) 
{
	this->pmap = pmap;
	eff = f;
	ip  = i;
	eff->dlg = this;
}

SampKernelDlgProc::~SampKernelDlgProc()
{
	eff->dlg = NULL;
}

void SampKernelDlgProc::Init()
{
}

void SampKernelDlgProc::SetState()
{
}

BOOL SampKernelDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,
		UINT msg,WPARAM wParam,LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			this->hWnd = hWnd;
			Init();
			SetState();
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			break;
		}
	
	return FALSE;
}


//--- SampKernelParamDlg -------------------------------------------------------


SampKernelParamDlg::SampKernelParamDlg(SampleKernel *f,IRendParams *i) 
{
	eff = f;
	ip  = i;	
	pmap = CreateRParamMap(
		descParam,PARAMDESC_LENGH,
		eff->pblock,
		i,
		hInstance,
		MAKEINTRESOURCE(IDD_SAMPLE_EFFECT),
		GetString(IDS_DS_SAMPEFPARAMS),
		0);
	
	pmap->SetUserDlgProc(new SampKernelDlgProc(pmap,eff,ip));	
}

void SampKernelParamDlg::SetThing(ReferenceTarget *m)
{
	assert(m->ClassID()==eff->ClassID());
	eff = (SampleKernel*)m;
	pmap->SetParamBlock(eff->pblock);
	pmap->SetUserDlgProc(new SampKernelDlgProc(pmap,eff,ip));	
	if (eff->dlg) {
		eff->dlg->eff = eff;		
		eff->dlg->Init();
		eff->dlg->SetState();
		}
}

void SampKernelParamDlg::DeleteThis()
{
	DestroyRParamMap(pmap);
	delete this;
}
********/

//--- SampleEffect ----------------------------------------------------------

//SampKernelDlgProc *SampleKernel::dlg = NULL;

SampleKernel::SampleKernel()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);
	//valid.SetEmpty();
	pblock->SetValue(PB_DUMMY_PARM, 0, 0 );		
}

IOResult SampleKernel::Load(ILoad *iload)
{
	FilterKernel::Load(iload);
	return IO_OK;
}
IOResult SampleKernel::Save(ISave *isave)
{
	FilterKernel::Save(isave);
	return IO_OK;
}

//FilterKernelParamDlg *SampleKernel::CreateParamDialog(IRendParams *ip)
//{	
//	return new SampKernelParamDlg(this,ip);
//	return NULL;
//}

Animatable* SampleKernel::SubAnim(int i) 
{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
	}
}

TSTR SampleKernel::SubAnimName(int i) 
{
	switch (i) {
		case 0: return GetString(IDS_KE_PARAMETERS);
		default: return _T("");
	}
}

RefTargetHandle SampleKernel::GetReference(int i)
{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
	}
}

void SampleKernel::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i) {
		case 0: pblock = (IParamBlock*)rtarg; break;
	}
}

RefResult SampleKernel::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			//valid.SetEmpty();
//			if (dlg)
//				dlg->Invalidate();
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_DUMMY_PARM: gpd->dim = defaultDim; break;
				default: 			gpd->dim = defaultDim;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_DUMMY_PARM:	gpn->name = _T("Dummy"); break;
				default:			gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}

double SampleKernel::KernelFn( double x, double y )
{
	return 	( x < 0.5 ) ? 1.0 : 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\procmaps.h ===
/**********************************************************************
 *<
	FILE: procmaps.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __PROCMAPS__H
#define __PROCMAPS__H

#include "max.h"
#include "imtl.h"
#include "stdmat.h"
#include "texutil.h"

extern HINSTANCE hInstance;

extern ClassDesc* GetPlanetDesc();
extern ClassDesc* GetStuccoDesc();
extern ClassDesc* GetSplatDesc();
extern ClassDesc* GetWaterDesc();
extern ClassDesc* GetSpeckleDesc();
extern ClassDesc* GetSmokeDesc();

extern TCHAR *GetString(int id);

#define PLANET_CLASS_ID 0x46396cf1
#define WATER_CLASS_ID 0x7712634e
#define SMOKE_CLASS_ID 0xa845e7c
#define SPECKLE_CLASS_ID 0x62c32b8a
#define SPLAT_CLASS_ID 0x90b04f9
#define STUCCO_CLASS_ID 0x9312fbe

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by procmaps.rc
//
#define IDS_DS_PROCMAPDESC              1
#define IDS_DS_PLANET_PARAMS            2
#define IDS_DS_SMOKE_PARAMS             3
#define IDS_DS_SPECKLE_PARAMS           4
#define IDS_DS_STUCCO_PARAMS            5
#define IDS_DS_WATER_PARAMS             6
#define IDS_DS_SPLAT_PARAMS             7
#define IDS_DS_PLANET                   8
#define IDS_DS_SIZE                     9
#define IDS_DS_ISLAND                   10
#define IDS_DS_PERCENT                  11
#define IDS_DS_SEED                     12
#define IDS_DS_COL1                     13
#define IDS_DS_COL2                     14
#define IDS_DS_COL3                     15
#define IDS_DS_COL4                     16
#define IDS_DS_COL5                     17
#define IDS_DS_COL6                     18
#define IDS_DS_COL7                     19
#define IDS_DS_COL8                     20
#define IDS_DS_COORDS                   21
#define IDS_DS_PARAMETERS               22
#define IDS_DS_SMOKE                    23
#define IDS_DS_ITER                     24
#define IDS_DS_EXPONENT                 25
#define IDS_DS_PHASE                    26
#define IDS_DS_NONE                     27
#define IDS_DS_SPECKLE                  28
#define IDS_DS_SPLAT                    29
#define IDS_DS_THRESH                   30
#define IDS_DS_STUCCO                   31
#define IDS_DS_THICKNESS                32
#define IDS_DS_WATER                    33
#define IDS_DS_NUMWAVSETS               34
#define IDS_DS_WAVERAD                  35
#define IDS_DS_WAVELENMIN               36
#define IDS_DS_WAVELENMAX               37
#define IDS_DS_AMPL                     38
#define IDS_DS_TYPE                     39
#define IDS_DS_CONTSIZE                 40
#define IDS_PW_BLEND                    41
#define IDS_PW_COORDINATES              42
#define IDS_PW_MAPON1                   43
#define IDS_PW_MAPON2                   44
#define IDS_PW_MAP1                     45
#define IDS_PW_MAP2                     46
#define IDS_DS_CONT2SIZE                47
#define IDS_PW_BLENDWL                  48
#define IDS_PW_DISTRIBUTION             49
#define IDS_PW_RSEED                    50
#define IDS_DS_WATER_CDESC              51
#define IDS_DS_STUCCO_CDESC             52
#define IDS_DS_SPLAT_CDESC              53
#define IDS_DS_SPECKLE_CDESC            54
#define IDS_DS_SMOKE_CDESC              55
#define IDS_DS_PLANET_CDESC             56
#define IDD_DIALOG1                     101
#define IDD_SMOKE                       101
#define IDD_DIALOG2                     102
#define IDD_DIALOG3                     103
#define IDD_PLANET                      104
#define IDD_SPECKLE                     105
#define IDD_STUCCO                      107
#define IDD_WATER                       108
#define IDD_SPLAT                       109
#define IDC_TEX1                        1000
#define IDC_TEX2                        1001
#define IDC_MAPON1                      1002
#define IDC_MAPON2                      1003
#define IDC_BLEND                       1004
#define IDC_THICK_SPIN                  1005
#define IDC_ISLAND_EDIT                 1006
#define IDC_THICK_EDIT                  1007
#define IDC_ISLAND_SPIN                 1008
#define IDC_RADIO_3D                    1009
#define IDC_RADIO_2D                    1010
#define IDC_PERCENT_EDIT                1011
#define IDC_PERCENT_SPIN                1012
#define IDC_COL1                        1027
#define IDC_COL2                        1028
#define IDC_COL3                        1029
#define IDC_COL4                        1030
#define IDC_SIZE_EDIT                   1031
#define IDC_NUM_EDIT                    1032
#define IDC_SIZE_SPIN                   1033
#define IDC_NUM_SPIN                    1034
#define IDC_ITER_EDIT                   1035
#define IDC_RSEED_EDIT                  1035
#define IDC_ITER_SPIN                   1036
#define IDC_RSEED_SPIN                  1036
#define IDC_EXP_EDIT                    1037
#define IDC_THRESH_EDIT                 1038
#define IDC_LEN_MAX_EDIT                1039
#define IDC_EXP_SPIN                    1040
#define IDC_THRESH_SPIN                 1041
#define IDC_LEN_MAX_SPIN                1042
#define IDC_SPEED_EDIT                  1043
#define IDC_SEED_EDIT                   1044
#define IDC_LEN_MIN_EDIT                1045
#define IDC_SPEED_SPIN                  1046
#define IDC_SEED_SPIN                   1047
#define IDC_LEN_MIN_SPIN                1048
#define IDC_COL5                        1049
#define IDC_AMP_EDIT                    1050
#define IDC_COL6                        1051
#define IDC_AMP_SPIN                    1052
#define IDC_COL7                        1053
#define IDC_COL8                        1054
#define IDC_SWAP                        1055

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1058
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\PLANET.CPP ===
/*===========================================================================*\
 |    File: Planet.cpp
 |
 | Purpose: A 3D Map for creating planet surface textures.
 |          This is a port of the 3D Studio/DOS SXP by Tom Hudson.
 |
 | History: Mark Meier, Began 02/03/97.
 |          MM, Updated for R3 11/11/98.
 		    Updated to Param Block2 by Peter Watje 12/1/1998
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID planetClassID(PLANET_CLASS_ID, 0);

// This is the number of colors used
#define NUM_COLORS 8

// This is the version number of the IPAS SXP files that can be read
#define PLANET_SXP_VERSION 0x8273F5EC

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

static Col24 Col24FromColor(Color a) {
	Col24 c;
	c.r = (ULONG)(a.r*255.0f);
	c.g = (ULONG)(a.g*255.0f);
	c.b = (ULONG)(a.b*255.0f);
	return c;
}

#pragma pack(1)
struct PlanetState {
	ulong version;
	float size;
	float island;
	float percent;
	int blend,seed;
	char file[13],filler[3];
	Col24 palette[8];
	float land;
};
#pragma pack()

// These are various resource IDs
static int colID[NUM_COLORS] = { IDC_COL1, IDC_COL2, IDC_COL3, IDC_COL4,
	IDC_COL5, IDC_COL6, IDC_COL7, IDC_COL8 };

// Forward references
class Planet;
//class PlanetDlgProc;

/*===========================================================================*\
 | Planet 3D Texture Map Plug-In Class
\*===========================================================================*/
class Planet : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class PlanetDlg;

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];

	// These are the parameters managed by the parameter map
	float size;
	float land;
	float island;
	float percent;
	Point3 col1, col2, col3, col4, col5, col6, col7, col8;

	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	PlanetDlg *paramDlg;
	
	public:
		// --- Methods inherited from Animatable ---
		int blend, seed;
		static ParamDlg* xyzGenDlg;	
		IParamBlock2 *pblock;
		Class_ID ClassID() { return planetClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_PLANET); }  
		void DeleteThis() { delete this; }	

		// We have 2 sub-animatables.  These are the xyzGen, 
		// and the pblock
		int NumSubs() { return 2; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 2 references.  These are the xyzGen, 
		// and the pblock
 		int NumRefs() { return 2; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);

		// --- Methods inherited from Texmap ---
		XYZGen *GetTheXYZGen() { return xyzGen; }
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);
		float NoiseFunc(float x, float y, float z);
		float BumpFunc(Point3 p);

		// --- Methods inherited from Tex3D ---
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods of Planet ---
		Planet();
		void NotifyChanged();
		void SetSize(float i, TimeValue t);
		void SetColor(int i, Color c, TimeValue t);
		void SetPercent(float f, TimeValue t);
		void SetIsland(float f, TimeValue t); 
		void SetSeed(int i, TimeValue t);
		void ClampFloat(float &f, float min, float max);
		void ClampInt(int &i, int min, int max);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Planet 3D Texture plug-in
class PlanetClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Planet; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_PLANET_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return planetClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("planet"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};

static PlanetClassDesc planetCD;

ClassDesc *GetPlanetDesc() { return &planetCD; }
ParamDlg* Planet::xyzGenDlg;	

/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class PlanetDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Planet being edited.
		Planet *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue curTime; 
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void DeleteThis() { delete this; }

		// --- PlanetDlg Methods ---
		PlanetDlg(HWND hwMtlEdit, IMtlParams *imp, Planet *m); 
		~PlanetDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/
/*===========================================================================*\
 | Noise Functions and Data Structures
\*===========================================================================*/
#define NOISE_DIM 20
#define FNOISE_DIM 20.0f

static float noise_table[NOISE_DIM+1][NOISE_DIM+1][NOISE_DIM+1];

static void init_noise(int seed) {
	int i,j,k,ii,jj,kk;
	srand(seed);
	for (i=0; i<=NOISE_DIM; i++)
		for (j=0; j<=NOISE_DIM; j++)
			for (k=0; k<=NOISE_DIM; k++) {
				noise_table[i][j][k] = (float)(rand()&0x7FFF);
				ii = (i==NOISE_DIM)?0:i; 
				jj = (j==NOISE_DIM)?0:j; 
				kk = (k==NOISE_DIM)?0:k; 
				noise_table[i][j][k] = noise_table[ii][jj][kk];
			}
}

static float noise(float x, float y, float z) {
	int ix,iy,iz;
	float fx,fy,fz,mx,my,mz;
	float n,n00,n01,n10,n11,n0,n1;
	mx = (float)fmod(x,FNOISE_DIM); if (mx<0) mx += FNOISE_DIM;
	my = (float)fmod(y,FNOISE_DIM); if (my<0) my += FNOISE_DIM;
	mz = (float)fmod(z,FNOISE_DIM); if (mz<0) mz += FNOISE_DIM;
	ix = (int)mx;
	iy = (int)my;
	iz = (int)mz;
	fx = (float)fmod(mx,1.0f);
	fy = (float)fmod(my,1.0f);
	fz = (float)fmod(mz,1.0f);
	n = noise_table[ix][iy][iz];
	n00 = n + fx*(noise_table[ix+1][iy][iz]-n);
	n = noise_table[ix][iy][iz+1];
	n01 = n + fx*(noise_table[ix+1][iy][iz+1]-n);
	n = noise_table[ix][iy+1][iz];
	n10 = n + fx*(noise_table[ix+1][iy+1][iz]-n);
	n = noise_table[ix][iy+1][iz+1];
	n11 = n + fx*(noise_table[ix+1][iy+1][iz+1]-n);
	n0 = n00 + fy*(n10-n00);
	n1 = n01 + fy*(n11-n01);
	return(((float)(n0+fz*(n1-n0)))/32768.0f);
}


/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_SIZE		0
#define PB_ISLAND	1 
#define PB_PERCENT	2
#define PB_SEED		3
#define PB_COL1		4
#define PB_COL2		5
#define PB_COL3		6
#define PB_COL4		7
#define PB_COL5		8
#define PB_COL6		9
#define PB_COL7		10
#define PB_COL8		11
*/
// Spinner limits
#define MIN_SIZE 0.0f
#define MAX_SIZE 999999999.0f

#define MIN_ISLAND 0.0f
#define MAX_ISLAND 100.0f

#define MIN_PERCENT 0.0f
#define MAX_PERCENT 100.0f

#define MIN_SEED 0
#define MAX_SEED 99999

// Paramter block version number
#define PLANET_PB_VERSION 2

enum { planet_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	planet_color1, planet_color2,
	planet_color3, planet_color4,
	planet_color5, planet_color6,
	planet_color7, planet_color8,
	planet_size, planet_island,		
	planet_percent, planet_seed,		
	planet_blend,
	planet_coords,	  // access for UVW mapping
};




static ParamBlockDesc2 planet_param_blk ( planet_params, _T("parameters"),  0, &planetCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_PLANET, IDS_DS_PLANET_PARAMS, 0, 0, NULL, 
	// params


	planet_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.04, 0.08, 0.31), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	planet_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(0.04f, 0.12f, 0.31f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,
	planet_color3,	 _T("color3"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL3,	
		p_default,		Color(0.04f, 0.16f, 0.31f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL3, 
		end,
	planet_color4,	 _T("color4"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL4,	
		p_default,		Color(0.04f, 0.39f, 0.05f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL4, 
		end,
	planet_color5,	 _T("color5"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL5,	
		p_default,		Color(0.39f, 0.31f, 0.05f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL5, 
		end,
	planet_color6,	 _T("color6"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL6,	
		p_default,		Color(0.31f, 0.08f, 0.03f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL6, 
		end,
	planet_color7,	 _T("color7"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL7,	
		p_default,		Color(0.39f, 0.31f, 0.20f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL7, 
		end,
	planet_color8,	 _T("color8"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL8,	
		p_default,		Color(0.39f, 0.39f, 0.39f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL8, 
		end,
	planet_size,	_T("continentSize"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_CONTSIZE,
		p_default,		40.f,
		p_range,		MIN_SIZE, MAX_SIZE,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN, 0.1f, 
		end,
	planet_island,	_T("islandFactor"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_ISLAND,
		p_default,		0.5f,
		p_range,		MIN_ISLAND, MAX_ISLAND,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_ISLAND_EDIT,IDC_ISLAND_SPIN, 0.1f, 
		end,
	planet_percent,	_T("oceanPercent"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PERCENT,
		p_default,		60.f,
		p_range,		MIN_PERCENT, MAX_PERCENT,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PERCENT_EDIT,IDC_PERCENT_SPIN, 0.1f, 
		end,
	planet_seed,	_T("randomSeed"),   TYPE_INT,			0,	IDS_PW_RSEED,
		p_default,		12345,
		p_range,		MIN_SEED, MAX_SEED,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_SEED_EDIT,IDC_SEED_SPIN,  1.0f, 
		end,
	planet_blend,	_T("blendWaterLand"), TYPE_BOOL,			0,				IDS_PW_BLENDWL,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_BLEND,
		end,
	planet_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);
/*
// Array of parameter descriptors
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_ISLAND, 
		EDITTYPE_FLOAT, 
		IDC_ISLAND_EDIT,IDC_ISLAND_SPIN, 
		MIN_ISLAND, MAX_ISLAND, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_PERCENT, 
		EDITTYPE_FLOAT, 
		IDC_PERCENT_EDIT,IDC_PERCENT_SPIN, 
		MIN_PERCENT, MAX_PERCENT, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_SEED, 
		EDITTYPE_INT, 
		IDC_SEED_EDIT,IDC_SEED_SPIN, 
		MIN_SEED, MAX_SEED, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2),
	ParamUIDesc(PB_COL3, TYPE_COLORSWATCH, IDC_COL3),
	ParamUIDesc(PB_COL4, TYPE_COLORSWATCH, IDC_COL4),
	ParamUIDesc(PB_COL5, TYPE_COLORSWATCH, IDC_COL5),
	ParamUIDesc(PB_COL6, TYPE_COLORSWATCH, IDC_COL6),
	ParamUIDesc(PB_COL7, TYPE_COLORSWATCH, IDC_COL7),
	ParamUIDesc(PB_COL8, TYPE_COLORSWATCH, IDC_COL8)

  };

*/
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 12


// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE,  planet_size }, // size 
	{ TYPE_FLOAT, NULL, TRUE,  planet_island}, // island
	{ TYPE_FLOAT, NULL, TRUE,  planet_percent }, // percent
	{ TYPE_INT,   NULL, FALSE, planet_seed }, // seed
	{ TYPE_RGBA,  NULL, TRUE,  planet_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE,  planet_color2}, // color 2
	{ TYPE_RGBA,  NULL, TRUE,  planet_color3 }, // color 3
	{ TYPE_RGBA,  NULL, TRUE,  planet_color4 }, // color 4
	{ TYPE_RGBA,  NULL, TRUE,  planet_color5 }, // color 5
	{ TYPE_RGBA,  NULL, TRUE,  planet_color6 }, // color 6
	{ TYPE_RGBA,  NULL, TRUE,  planet_color7 }, // color 7
	{ TYPE_RGBA,  NULL, TRUE,  planet_color8 }  // color 8
};
// The number of parameters in the parameter block
#define PB_LENGTH 12

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,12,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = {
	IDS_DS_CONTSIZE, IDS_DS_ISLAND, IDS_DS_PERCENT, IDS_DS_SEED, 
	IDS_DS_COL1, IDS_DS_COL2,IDS_DS_COL3,IDS_DS_COL4,
	IDS_DS_COL5,IDS_DS_COL6,IDS_DS_COL7,IDS_DS_COL8 };

/*
// This is the class that allows the sub-map buttons to be processed.
class PlanetDlgProc : public ParamMapUserDlgProc {
	public:
		PlanetDlg *theDlg;
		PlanetDlgProc(PlanetDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL PlanetDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

static int colNameIDs[] = {
	IDS_DS_COL1, IDS_DS_COL2,IDS_DS_COL3,IDS_DS_COL4,
	IDS_DS_COL5,IDS_DS_COL6,IDS_DS_COL7,IDS_DS_COL8 };

BOOL PlanetDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], GetString(colNameIDs[i]));
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_BLEND:
					theTex->blend = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

			}
			break;

		// We need to trap the case of the 'Seed' value changing because
		// we need to update the noise table with new values.
		case WM_CUSTEDIT_ENTER: {
			int editID = wParam;
			if (editID == IDC_SEED_EDIT) {
				init_noise(theTex->seed);
				theTex->NotifyChanged();
			    UpdateMtlDisplay();
				break;
			}
		}
		case CC_SPINNER_BUTTONUP: {
			int spinID = LOWORD(wParam);
			if (spinID == IDC_SEED_SPIN) {
				init_noise(theTex->seed);
				theTex->NotifyChanged();
			    UpdateMtlDisplay();
				break;
			}
		}
		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/
/*===========================================================================*\
 | PlanetDlg Methods
\*===========================================================================*/
// --- PlanetDlg Methods ---
// Constructor.
// This is called from within the Planet::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
PlanetDlg::PlanetDlg(HWND hwMtlEdit, IMtlParams *imp, Planet *m) { 
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	curTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_PLANET),
		GetString(IDS_DS_PLANET_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new PlanetDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Planet texture.
// Note that it is not called if they do go to another Planet -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside PlanetDlg::SetThing()).
PlanetDlg::~PlanetDlg() {
	theTex->paramDlg = NULL;
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}

// Update the dialog display with the values of the texture we are
// currently editing.
void PlanetDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(curTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_ISLAND_SPIN));
		spin->SetValue(theTex->island, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_PERCENT_SPIN));
		spin->SetValue(theTex->percent, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SEED_SPIN));
		spin->SetValue(theTex->seed, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);
		cs[2]->SetColor(theTex->col[2]);
		cs[3]->SetColor(theTex->col[3]);
		cs[4]->SetColor(theTex->col[4]);
		cs[5]->SetColor(theTex->col[5]);
		cs[6]->SetColor(theTex->col[6]);
		cs[7]->SetColor(theTex->col[7]);
		CheckDlgButton(hParamDlg, IDC_BLEND, 
			 ((theTex->blend) ? BST_CHECKED : BST_UNCHECKED));
	}
}

// This method invalidates the rollup page so it will get redrawn
void PlanetDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID PlanetDlg::ClassID() {
	return planetClassID; 
}

// This sets the current texture being edited to the texture passed
void PlanetDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == planetClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Planet *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *PlanetDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void PlanetDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != curTime) {
		xyzGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void PlanetDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(curTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void PlanetDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}
*/
/*===========================================================================*\
 | Planet Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Planet::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return 0;
	}
}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Planet::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return TSTR(_T(""));
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Planet::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default: return 0;
	}
}

// Save the 'i-th' reference
void Planet::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Planet::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:

			texValidity.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				// MM: 2/99, If the seed changed update the noise table
				if (changing_param == planet_seed) {
					pblock->GetValue(planet_seed, 0, seed, texValidity);
					init_noise(seed);
				}
				planet_param_blk.InvalidateUI(changing_param);
			}


			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget == pblock) {
//				if (paramDlg) 
//					paramDlg->pmap->Invalidate();
//				}
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_PERCENT:
					gpd->dim = stdPercentDim; break;
				case PB_SIZE: gpd->dim =  stdWorldDim; 	break;
				case PB_ISLAND:
				case PB_SEED:
					gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: 
				case PB_COL3: 
				case PB_COL4: 
				case PB_COL5: 
				case PB_COL6: 
				case PB_COL7: 
				case PB_COL8: 
					gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define PLANET_VERS1_CHUNK		0x4001
#define BLEND_CHUNK				0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Planet::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

/*
	// Save a version number chunk

	isave->BeginChunk(PLANET_VERS1_CHUNK);
	isave->EndChunk();
	if (blend) {
		isave->BeginChunk(BLEND_CHUNK);
		isave->EndChunk();

	}
*/
	return IO_OK;
}

class PlanetPostLoad : public PostLoadCallback {
	public:
		Planet *n;
		BOOL Param1;
		PlanetPostLoad(Planet *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( planet_blend, 0, n->blend);
				}
			delete this; 


			} 
	};



// This is called by the system to allow the plug-in to load its data
IOResult Planet::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	blend = 0;
	
	BOOL Param1 = TRUE;

	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case BLEND_CHUNK:
				blend = 1; 
				break;
			case PLANET_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1 = FALSE;
				break;

		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &planet_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new PlanetPostLoad(this,Param1));

	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Planet::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Planet *newPlanet = new Planet();

	// Copy superclass stuff
	*((MtlBase *)newPlanet) = *((MtlBase *)this);

	// Clone the items we reference
	newPlanet->ReplaceReference(0, remap.CloneRef(xyzGen));
	newPlanet->ReplaceReference(1, remap.CloneRef(pblock));
	newPlanet->col[0] = col[0];
	newPlanet->col[1] = col[1];
	newPlanet->col[2] = col[2];
	newPlanet->col[3] = col[3];
	newPlanet->col[4] = col[4];
	newPlanet->col[5] = col[5];
	newPlanet->col[6] = col[6];
	newPlanet->col[7] = col[7];
	newPlanet->size = size;
	newPlanet->island = island;
	newPlanet->percent = percent;
	newPlanet->seed = seed;
	newPlanet->texValidity.SetEmpty();	
	// Return the new cloned texture
	return (RefTargetHandle)newPlanet;
}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Planet::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
}

// This method is called to reset the texmap back to its default values.
void Planet::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	


//	ReplaceReference(1, CreateParameterBlock(pbdesc, 
//		PB_LENGTH, PLANET_PB_VERSION));
//	if (paramDlg) 
//		paramDlg->pmap->SetParamBlock(pblock);

	// Set the inital parameters
	// {10,20,80},{10,30,80},{10,40,90},{10,100,12},
	// {100,80,12},{80,20,8},{100,80,50},{100,100,100}
	SetColor(0, Color(0.04f, 0.08f, 0.31f), TimeValue(0));
	SetColor(1, Color(0.04f, 0.12f, 0.31f), TimeValue(0));
	SetColor(2, Color(0.04f, 0.16f, 0.31f), TimeValue(0));
	SetColor(3, Color(0.04f, 0.39f, 0.05f), TimeValue(0));
	SetColor(4, Color(0.39f, 0.31f, 0.05f), TimeValue(0));
	SetColor(5, Color(0.31f, 0.08f, 0.03f), TimeValue(0));
	SetColor(6, Color(0.39f, 0.31f, 0.20f), TimeValue(0));
	SetColor(7, Color(0.39f, 0.39f, 0.39f), TimeValue(0));

	SetSize(40.0f, TimeValue(0));
	SetIsland(0.5f, TimeValue(0));
	SetPercent(60.0f, TimeValue(0));
	SetSeed(12345, TimeValue(0));
	blend = 1;

	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
}

void Planet::Reset() {
	planetCD.Reset(this, TRUE);	// reset all pb2's
	Init();
	}

// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Planet::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	PlanetDlg *planetDlg = new PlanetDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	planetDlg->LoadDialog();
//	paramDlg = planetDlg;
//	return planetDlg;	
	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = planetCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	return masterDlg;

}

BOOL Planet::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}

// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Planet::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
		for (int i = 0; i < NUM_COLORS; i++) {
//			pblock->GetValue(i+PB_COL1, t, col[i], texValidity);
			pblock->GetValue(i+planet_color1, t, col[i], texValidity);
			col[i].ClampMinMax();
			}

//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(planet_size, t, size, texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE);
//		pblock->GetValue(PB_ISLAND, t, island, texValidity);
		pblock->GetValue(planet_island, t, island, texValidity);
		ClampFloat(island, MIN_ISLAND, MAX_ISLAND);
//		pblock->GetValue(PB_PERCENT, t, percent, texValidity);
		pblock->GetValue(planet_percent, t, percent, texValidity);
		ClampFloat(percent, MIN_PERCENT, MAX_PERCENT);
		land = percent/100.0f;
//		pblock->GetValue(PB_SEED, t, seed, texValidity);
		pblock->GetValue(planet_seed, t, seed, texValidity);
		ClampInt(seed, (int) MIN_SEED, (int) MAX_SEED);
		pblock->GetValue(planet_blend, t, blend, texValidity);
	}
	ivalid &= texValidity;
}

void Planet::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

void Planet::ClampInt(int &i, int min, int max) {
	if (i < min) i = min;
	else if (i > max) i = max;
}

float Planet::NoiseFunc(float x, float y, float z) {
 	return  noise(x, y, z) + noise(x*island, y*island, z*island)/5.0f;
	}

// --- Methods inherited from Texmap ---
RGBA Planet::EvalColor(ShadeContext& sc) {
	float d, x, y, z;
	RGBA color;

	// After being evaluated, if a map or material has a non-zero gbufID, 
	// it should call ShadeContext::SetGBuffer() to store it into 
	// the shade context.
	if (gbufID) 
		sc.SetGBufferID(gbufID);

	// Use the XYZGen instance to get a transformed point from the
	// ShadeContext.
	Point3 p, dp;
	xyzGen->GetXYZ(sc, p, dp);

	if (size == 0.0f) 
		size = 0.0001f;
	x = p.x/size;
	y = p.y/size;
	z = p.z/size;
	d = NoiseFunc(x, y, z);
	if (d < land) {
		float frac;
		int index;

		d = d/land*3.0f;
		index = (int)d;
		frac = d-(float)index;
		if (index < 2)
			color = (1.0f-frac)*col[index]+frac*col[index+1];
		else {
			if (blend)
				color = (1.0f-frac)*col[2]+frac*col[3];
			else
				color = col[2];
			}
		}
	else {
		float divfac, frac;
		int index;
		
		divfac = 1.0f-land;
		if (divfac==0.0) divfac = .000001f;
		d = (d-land)/divfac*5;
		index = (int)d;
		frac = d-(float)index;
		if (index < 4)
			color = (1.0f-frac)*col[index+3]+frac*col[index+4];
		else
			color = col[7];
		}
	return color;
	}

float Planet::BumpFunc(Point3 p) {
	float f = NoiseFunc(p.x,p.y,p.z);
	return (f<land)?land:f;
	}

Point3 Planet::EvalNormalPerturb(ShadeContext& sc) {
	float del,d;
	Point3 p,dp;
	if (!sc.doMaps) return Point3(0,0,0);
	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	if (size == 0.0f) 
		size = 0.0001f;
	p /= size;
	del = 10.0f;
	d = BumpFunc(p);
	Point3 np;
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = (BumpFunc(p+del*M[0]) - d)/del;
	np.y = (BumpFunc(p+del*M[1]) - d)/del;
	np.z = (BumpFunc(p+del*M[2]) - d)/del;
	return sc.VectorFromNoScale(np*100.0f,REF_OBJECT);
    }

// --- Methods inherited from Tex3D ---
void Planet::ReadSXPData(TCHAR *name, void *sxpdata) {
	PlanetState *state = (PlanetState*)sxpdata;
	if (state != NULL && (state->version == PLANET_SXP_VERSION)) {
		SetSize(state->size, TimeValue(0));
		SetPercent(state->percent, TimeValue(0));
		SetIsland(state->island, TimeValue(0));
		SetSeed(state->seed, TimeValue(0));
	}
}

// --- Methods of Planet ---
Planet::Planet() {
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	planetCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
	// Allocate data structures, compute lookup tables, etc.
	init_noise(seed);
}

void Planet::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void Planet::SetSize(float f, TimeValue t) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(planet_size, t, f);
}

void Planet::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue(i+PB_COL1, t, c);
	pblock->SetValue(i+planet_color1, t, c);
}

void Planet::SetPercent(float f, TimeValue t) { 
	percent = f; 
	// Also set land as percent/100.
	land = f/100.0f;
//	pblock->SetValue(PB_PERCENT, t, f);
	pblock->SetValue(planet_percent, t, f);
}

void Planet::SetIsland(float f, TimeValue t) { 
	island = f; 
//	pblock->SetValue(PB_ISLAND, t, f);
	pblock->SetValue(planet_island, t, f);
}

void Planet::SetSeed(int i, TimeValue t) { 
	seed = i; 
//	pblock->SetValue(PB_SEED, t, i);
	pblock->SetValue(planet_seed, t, i);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\STUCCO.CPP ===
/*===========================================================================*\
 |    File: Stucco.cpp
 |
 | Purpose: A 3D Map for creating 'stucco' type patterns.
 |          This is a port of the 3D Studio/DOS SXP by Dan Silva.
 |
 | History: Mark Meier, Began 02/05/97.
 |          MM, Last Change 02/05/97.
			Updated to Param Block2 by Peter Watje 12/1/1998
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"
#include "macrorec.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID stuccoClassID(STUCCO_CLASS_ID, 0);

// This is the number of colors used
#define NUM_COLORS 2

// This is the number of sub-texmaps used
#define NUM_SUB_TEXMAPS 2

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

static Col24 Col24FromColor(Color a) {
	Col24 c;
	c.r = (ULONG)(a.r*255.0f);
	c.g = (ULONG)(a.g*255.0f);
	c.b = (ULONG)(a.b*255.0f);
	return c;
}

#define STUCCO_VERS 0xfaaaa3c2

#pragma pack(1)
struct StuccoState {
	ulong version;
	float size;
	float threshold;
	float thickness;
	float del;
	Col24 col1, col2;
};
#pragma pack()

// These are various resource IDs
static int colID[2] = { IDC_COL1, IDC_COL2 };
static int subTexId[NUM_SUB_TEXMAPS] = { IDC_TEX1, IDC_TEX2 };
static int mapOnId[NUM_SUB_TEXMAPS] = { IDC_MAPON1, IDC_MAPON2 };

// Forward references
//class Stucco;
//class StuccoDlgProc;

/*===========================================================================*\
 | Stucco 3D Texture Map Plug-In Class
\*===========================================================================*/
class Stucco : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class StuccoDlg;

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];

	// These are the parameters managed by the parameter map
	float size;
	float thresh;
	float thick;
	float del;
	Point3 col1, col2;

	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// These are the sub-texmaps.  If these are set by the user
	// then the color of our texture is affected by the sub-texmaps
	// and not the color swatches.
	// These are reference #2 and #3 of this class.
	Texmap *subTex[NUM_SUB_TEXMAPS];
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	StuccoDlg *paramDlg;

	public:
		static ParamDlg* xyzGenDlg;	
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
		IParamBlock2 *pblock;
	// Indicates if a sub-texmap is to be used or not
		BOOL mapOn[NUM_SUB_TEXMAPS];
		// --- Methods inherited from Animatable ---
		Class_ID ClassID() { return stuccoClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_STUCCO); }  
		void DeleteThis() { delete this; }	

		// We have 4 sub-animatables.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
		int NumSubs() { return 2+NUM_SUB_TEXMAPS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 4 references.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
 		int NumRefs() { return 2+NUM_SUB_TEXMAPS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		int NumSubTexmaps() { return NUM_SUB_TEXMAPS; }
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods inherited from Texmap ---
		XYZGen *GetTheXYZGen() { return xyzGen; }
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// --- Methods of Stucco ---
		Stucco();
		float Func(Point3 p, float scl);
		void SwapInputs(); 
		void NotifyChanged();
		void SetSize(float f, TimeValue t);
		void SetThick(float f, TimeValue t);
		void SetThresh(float f, TimeValue t);
		void SetColor(int i, Color c, TimeValue t);
		void ClampFloat(float &f, float min, float max);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Stucco 3D Texture plug-in
class StuccoClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Stucco; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_STUCCO_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return stuccoClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("stucco"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};
static StuccoClassDesc stuccoCD;

ClassDesc *GetStuccoDesc() { return &stuccoCD; }
ParamDlg* Stucco::xyzGenDlg;	

/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class StuccoDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Stucco being edited.
		Stucco *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom buttons for texture maps
		ICustButton *iCustButton[NUM_SUB_TEXMAPS];
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue curTime; 
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;
		TexDADMgr dadMgr;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		int FindSubTexFromHWND(HWND hw);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void DeleteThis() { delete this; }

		// --- StuccoDlg Methods ---
		StuccoDlg(HWND hwMtlEdit, IMtlParams *imp, Stucco *m); 
		~StuccoDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void UpdateSubTexNames();
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/
/*===========================================================================*\
 | Noise and Lerp Functions
\*===========================================================================*/
static void lerp_color(Col24 *c, Col24 *a, Col24 *b, float f) {
	int alph = (int)(4096*f);
	int ialph = 4096-alph;
	c->r = (ialph*a->r + alph*b->r)>>12;
	c->g = (ialph*a->g + alph*b->g)>>12;
	c->b = (ialph*a->b + alph*b->b)>>12;
}

/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_SIZE		0
#define PB_THRESH	1
#define PB_THICK	2 
#define PB_COL1		3
#define PB_COL2		4
*/

// Spinner limits
#define MIN_SIZE 0.001f
#define MAX_SIZE 999999999.0f
#define MIN_THRESH 0.0f
#define MAX_THRESH 1.0f

#define MIN_THICK 0.0f
#define MAX_THICK 1.0f

// Paramter block version number
#define STUCCO_PB_VERSION 2

enum { stucco_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	stucco_size,stucco_thickness,stucco_threshold,
	stucco_color1, stucco_color2,
	stucco_map1, stucco_map2,
	stucco_mapon1,stucco_mapon2,
	stucco_coords,	  // access for UVW mapping
};

static ParamBlockDesc2 stucco_param_blk ( stucco_params, _T("parameters"),  0, &stuccoCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_STUCCO, IDS_DS_STUCCO_PARAMS, 0, 0, NULL, 
	// params


	stucco_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SIZE,
		p_default,		20.f,
		p_range,		MIN_SIZE, MAX_SIZE,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN, 0.1f, 
		end,
	stucco_thickness,	_T("thickness"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_THICKNESS,
		p_default,		.15f,
		p_range,		MIN_THICK, MAX_THICK,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_THICK_EDIT,IDC_THICK_SPIN, 0.1f, 
		end,
	stucco_threshold,	_T("threshold"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_THRESH,
		p_default,		0.57f,
		p_range,		MIN_THRESH, MAX_THRESH,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_THRESH_EDIT,IDC_THRESH_SPIN, 0.1f, 
		end,
	stucco_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.f, 0.f, 0.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	stucco_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(0.9f, 0.9f, 0.9f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,
	stucco_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX1,
		end,
	stucco_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX2,
		end,
	stucco_mapon1,	_T("map1On"), TYPE_BOOL,			0,				IDS_PW_MAPON1,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	stucco_mapon2,	_T("map2On"), TYPE_BOOL,			0,				IDS_PW_MAPON2,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	stucco_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);

/*
// Array of parameter descriptors
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_THRESH, 
		EDITTYPE_FLOAT, 
		IDC_THRESH_EDIT,IDC_THRESH_SPIN, 
		MIN_THRESH, MAX_THRESH, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_THICK, 
		EDITTYPE_FLOAT, 
		IDC_THICK_EDIT,IDC_THICK_SPIN, 
		MIN_THICK, MAX_THICK, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2)
};
*/
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 5

// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE, stucco_size }, // size 
	{ TYPE_FLOAT, NULL, TRUE, stucco_threshold }, // thresh
	{ TYPE_FLOAT, NULL, TRUE, stucco_thickness }, // thick
	{ TYPE_RGBA,  NULL, TRUE, stucco_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE, stucco_color2 }  // color 2
};
// The number of parameters in the parameter block
#define PB_LENGTH 5


static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,5,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = {
	IDS_DS_SIZE,IDS_DS_THRESH,IDS_DS_THICKNESS,
	IDS_DS_COL1, IDS_DS_COL2 };
/*
// This is the class that allows the sub-map buttons to be processed.
class StuccoDlgProc : public ParamMapUserDlgProc {
	public:
		StuccoDlg *theDlg;
		StuccoDlgProc(StuccoDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL StuccoDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

BOOL StuccoDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], theTex->GetSubTexmapSlotName(i).data());
			for (i = 0; i < NUM_SUB_TEXMAPS; i++) {
				iCustButton[i] = GetICustButton(GetDlgItem(hWnd, subTexId[i]));
				iCustButton[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hWnd, mapOnId[i], theTex->mapOn[i]);
			}
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_TEX1: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 0, (LPARAM)theTex);
					break;

				case IDC_TEX2: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 1, (LPARAM)theTex);
					break;

				case IDC_SWAP: {
					theTex->SwapInputs(); 
					IParamBlock *pb = (IParamBlock *)pmap->GetParamBlock();
					pb->SetValue(PB_COL1, curTime, theTex->col[0]);
					pb->SetValue(PB_COL2, curTime, theTex->col[1]);
					pmap->Invalidate();
					UpdateSubTexNames();
					UpdateMtlDisplay();
					theTex->NotifyChanged();
					}
					break;

				case IDC_MAPON1:
					theTex->mapOn[0] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_MAPON2:
					theTex->mapOn[1] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;
			}
			break;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/
/*===========================================================================*\
 | StuccoDlg Methods
\*===========================================================================*/
// --- StuccoDlg Methods ---
// Constructor.
// This is called from within the Stucco::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
StuccoDlg::StuccoDlg(HWND hwMtlEdit, IMtlParams *imp, Stucco *m) { 
	dadMgr.Init(this);
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	curTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_STUCCO),
		GetString(IDS_DS_STUCCO_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new StuccoDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Stucco texture.
// Note that it is not called if they do go to another Stucco -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside StuccoDlg::SetThing()).
StuccoDlg::~StuccoDlg() {
	theTex->paramDlg = NULL;
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		ReleaseICustButton(iCustButton[i]);
		iCustButton[i] = NULL; 
	}
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}

// This is called by the DADMgr
int StuccoDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NUM_SUB_TEXMAPS; i++) {
		if (hw == iCustButton[i]->GetHwnd()) return i;
		}	
	return -1;
	}

// This is called when the dialog is loaded to set the names of the
// textures displayed
void StuccoDlg::UpdateSubTexNames() {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		TSTR nm;
		Texmap *m = theTex->subTex[i];
		if (m) 	
			nm = m->GetFullName();
		else
			nm = GetString(IDS_DS_NONE);
		iCustButton[i]->SetText(nm.data());
	}
}

// Update the dialog display with the values of the texture we are
// currently editing.
void StuccoDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(curTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_THRESH_SPIN));
		spin->SetValue(theTex->thresh, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_THICK_SPIN));
		spin->SetValue(theTex->thick, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);

		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) 
			SetCheckBox(hParamDlg, mapOnId[i], theTex->mapOn[i]);

		UpdateSubTexNames();
	}
}

// This method invalidates the rollup page so it will get redrawn
void StuccoDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID StuccoDlg::ClassID() {
	return stuccoClassID; 
}

// This sets the current texture being edited to the texture passed
void StuccoDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == stuccoClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Stucco *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *StuccoDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void StuccoDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != curTime) {
		xyzGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void StuccoDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(curTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void StuccoDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}
*/

//dialog stuff to get the Set Ref button
class StuccoDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Stucco *stucco;		
		StuccoDlgProc(Stucco *m) {stucco = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};



BOOL StuccoDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_SWAP:
					{
					stucco = (Stucco*)map->GetParamBlock()->GetOwner(); 

					stucco->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}

/*===========================================================================*\
 | Stucco Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Stucco::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
	}
}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Stucco::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return GetSubTexmapTVName(i-2);
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Stucco::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
	}
}

// Save the 'i-th' reference
void Stucco::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Stucco::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			texValidity.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				stucco_param_blk.InvalidateUI(changing_param);
				}

			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget != xyzGen) {
//				if (paramDlg) {
//					paramDlg->pmap->Invalidate();
//					}
//				}
			break;

/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_SIZE:		gpd->dim =  stdWorldDim; 
					break;
				case PB_THRESH:
				case PB_THICK:
					gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define STUCCO_VERS1_CHUNK		0x4001
#define MAPOFF_CHUNK			0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Stucco::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();

	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
/*	// Save a version number chunk
	isave->BeginChunk(STUCCO_VERS1_CHUNK);
	isave->EndChunk();
	// Save the on/off status of the sub-texmaps
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (mapOn[i] == 0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
		}
	}
*/
	return IO_OK;
}

class StuccoPostLoad : public PostLoadCallback {
	public:
		Stucco *n;
		BOOL Param1;
		StuccoPostLoad(Stucco *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( stucco_mapon1, 0, n->mapOn[0]);
				n->pblock->SetValue( stucco_mapon2, 0, n->mapOn[1]);
				}
			delete this; 


			} 
	};


// This is called by the system to allow the plug-in to load its data
IOResult Stucco::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	BOOL Param1 = TRUE;
	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case STUCCO_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1 = FALSE;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				// Set the sub-texmap on/off settings
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &stucco_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new StuccoPostLoad(this,Param1));
	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Stucco::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Stucco *newStucco = new Stucco();

	// Copy superclass stuff
	*((MtlBase *)newStucco) = *((MtlBase *)this);

	// Clone the items we reference
	newStucco->ReplaceReference(0, remap.CloneRef(xyzGen));
	newStucco->ReplaceReference(1, remap.CloneRef(pblock));
	newStucco->col[0] = col[0];
	newStucco->col[1] = col[1];
	newStucco->size = size;
	newStucco->thresh = thresh;
	newStucco->thick = thick;
	newStucco->texValidity.SetEmpty();	
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		newStucco->subTex[i] = NULL;
		newStucco->mapOn[i] = mapOn[i];
		if (subTex[i])
			newStucco->ReplaceReference(i+2, remap.CloneRef(subTex[i]));
		}
	// Return the new cloned texture
	return (RefTargetHandle)newStucco;
	}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Stucco::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
	}

// This method is called to reset the texmap back to its default values.
void Stucco::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	

	// Set the inital parameters
	SetColor(0, Color(0.0f, 0.0f, 0.0f), TimeValue(0));
	SetColor(1, Color(0.9f, 0.9f, 0.9f), TimeValue(0));
	SetSize(20.0f, TimeValue(0));
	SetThresh(0.57f, TimeValue(0));
	SetThick(0.15f, TimeValue(0));

	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
	}

void Stucco::Reset() {
	stuccoCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

Stucco::Stucco() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	mapOn[0] = mapOn[1] = 1;
	stuccoCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
	del = 0.1f; // This is a constant for now...
	}


// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Stucco::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	StuccoDlg *stuccoDlg = new StuccoDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	stuccoDlg->LoadDialog();
//	paramDlg = stuccoDlg;
//	return stuccoDlg;	
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = stuccoCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	stucco_param_blk.SetUserDlgProc(new StuccoDlgProc(this));

	return masterDlg;
	

}

static Color ColrFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
	}


void Stucco::ReadSXPData(TCHAR *name, void *sxpdata) {
	StuccoState *state = (StuccoState*)sxpdata;
	if (state!=NULL && (state->version==STUCCO_VERS)) {
		SetColor(0, ColrFromCol24(state->col1),0);
		SetColor(1, ColrFromCol24(state->col2),0);
		SetSize(state->size,0);
		SetThick(state->thickness,0);
		SetThresh(state->threshold,0);
		del = state->del;
		}
	}

BOOL Stucco::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}


// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Stucco::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
//		pblock->GetValue(PB_COL1, t, col[0], texValidity);
		pblock->GetValue(stucco_color1, t, col[0], texValidity);
		col[0].ClampMinMax();
//		pblock->GetValue(PB_COL2, t, col[1], texValidity);
		pblock->GetValue(stucco_color2, t, col[1], texValidity);
		col[1].ClampMinMax();
//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(stucco_size, t, size, texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE);
//		pblock->GetValue(PB_THRESH, t, thresh, texValidity);
		pblock->GetValue(stucco_threshold, t, thresh, texValidity);
		ClampFloat(thresh, MIN_THRESH, MAX_THRESH);
//		pblock->GetValue(PB_THICK, t, thick, texValidity);
		pblock->GetValue(stucco_thickness, t, thick, texValidity);
		pblock->GetValue(stucco_mapon1, t, mapOn[0], texValidity);
		pblock->GetValue(stucco_mapon2, t, mapOn[1], texValidity);
		ClampFloat(thick, MIN_THICK, MAX_THICK);
		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t, texValidity);
		}
	}
	ivalid &= texValidity;
}

void Stucco::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

// Returns a pointer to the 'i-th' sub-texmap managed by this texture.
Texmap *Stucco::GetSubTexmap(int i) { 
	return subTex[i]; 
}

// Stores the 'i-th' sub-texmap managed by the material or texture.
void Stucco::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2, m);
	if (i==0)
		{
		stucco_param_blk.InvalidateUI(stucco_map1);
		texValidity.SetEmpty();
		}
	else if (i==1)
		{
		stucco_param_blk.InvalidateUI(stucco_map2);
		texValidity.SetEmpty();
		}

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
}

// This name appears in the materials editor dialog when editing the
// 'i-th' sub-map.
TSTR Stucco::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_COL1); 
		case 1:  return GetString(IDS_DS_COL2); 
		default: return TSTR(_T(""));
	}
}
	 

static float compscl(Point3 dp, float size) {
	float f;
	float scl = (float)fabs(dp.x);
	if ((f = (float)fabs(dp.y)) > scl) 
		scl = f;
	if ((f = (float)fabs(dp.z)) > scl) 
		scl = f;
	scl /= size;
	return scl;
	}

#define CRV  (.2)
#define K   (.5/(1-CRV))
#define K1  (K/CRV)

/*
STUCCO function

works off a noise function 'f'in range [0..1.0]

when f<=threshold returns 0.0;

state.thickness is the fraction of the remaining interval [thresh..1.0] 
taken up by a transition from 0 to 1.0;
Over this interval, a 2nd order curve (piecewise parabolic) is used.
over the first CRV part of the transition its parablolic, then for
the next 1-2*CRV part its linear, then for the last CRV part it's
an inverted parabola.
-------------------------------------------------------
*/
float Stucco::Func(Point3 p, float scl) {
	float f,t;
	f = 0.5f*(noise3(p)+1.0f); /* get number from  0 to 1.0 */

	if (f <= thresh) 
		return(float) 0.0f;
	t = thick+0.5f*scl;
	f = (f-thresh)/t;
	if (f >= 1.0f) 
		return (float) (1.0f);
	if (f < CRV) 	{
		return (float) (K1*f*f);
		}
	else 
	if (f < (1.0f-CRV)) {
	   return (float) (K*((2.0f*f)-CRV));
		}
	else {
		f = 1.0f-f;
		return (float) (1.0f - K1*(f*f));
		}
	}

// --- Methods inherited from Texmap ---
RGBA Stucco::EvalColor(ShadeContext& sc) {
	float f;
	Point3 p, dp;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	if (size == 0.0f) 
		size = 0.0001f;
	p /= size;

	float scl = compscl(dp, size);
	f = Func(p, scl);

	// If we have sub-texmaps and they are enabled, get the colors from 
	// the sub-texmaps, otherwise get them from the color swatch
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];

	Col24 c;
	Col24 col1 = Col24FromColor(c0);
	Col24 col2 = Col24FromColor(c1);

	lerp_color(&c, &col1, &col2, f);
	return ColorFromCol24(c);
}

Point3 Stucco::EvalNormalPerturb(ShadeContext& sc) {
	float d,k;
	Point3 p, dp, np;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	float scl = compscl(dp, size);
	p /= size;
	d = Func(p, scl);
	k = 0.25f/del;

	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
	np.x = (Func(p + del*M[0], scl) - d)*k;
	np.y = (Func(p + del*M[1], scl) - d)*k;
	np.z = (Func(p + del*M[2], scl) - d)*k;
	return sc.VectorFromNoScale(np,REF_OBJECT);
}

// --- Methods of Stucco ---
void Stucco::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void Stucco::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
//	pblock->SwapControllers(PB_COL1, PB_COL2);
	pblock->SwapControllers(stucco_color1,0, stucco_color2,0);
	stucco_param_blk.InvalidateUI(stucco_color1);
	stucco_param_blk.InvalidateUI(stucco_color2);
	stucco_param_blk.InvalidateUI(stucco_map1);
	stucco_param_blk.InvalidateUI(stucco_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
}

void Stucco::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue((i == 0) ? PB_COL1 : PB_COL2, t, c);
	pblock->SetValue((i == 0) ? stucco_color1 : stucco_color2, t, c);
}

void Stucco::SetThick(float f, TimeValue t) { 
	thick = f; 
//	pblock->SetValue(PB_THICK, t, f);
	pblock->SetValue(stucco_thickness, t, f);
}

void Stucco::SetThresh(float f, TimeValue t) { 
	thresh = f; 
//	pblock->SetValue(PB_THRESH, t, f);
	pblock->SetValue(stucco_threshold, t, f);
}

void Stucco::SetSize(float f, TimeValue t) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(stucco_size, t, f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\proscatr.cpp ===
/**********************************************************************
 *<
	FILE: ProScatr.cpp

	DESCRIPTION:  A Procedural Scatter Object

	CREATED BY: Audrey Peterson

	HISTORY: created 24 December 1996

 *>	Copyright (c) 1996,1997 All Rights Reserved.
 **********************************************************************/
#include <io.h>
#include "proscatr.h"

static Class_ID PROSCATTEROBJ_CLASS_ID(0x5c2417bd, 0x44050964);

#define CID_CREATEPROSCATTERMODE CID_USER + 26		
#define REF_OP1		0
#define REF_OP2		1
#define REF_CONT1	2
#define REF_CONT2	3
#define PBLOCK		4
#define EPSILON 0.0001f
#define TESTLIMIT 100

const int isize=sizeof(int);
const int fsize=sizeof(float);
const int NLEN=16;
const int HLEN=4*isize;
typedef TCHAR AName[NLEN];

typedef struct{
  DWORD vfrom,vto;
  Point3 normal;
}fEdge;

// Flag bits
#define PSCAT_OB1SEL			(1<<0)
#define PSCAT_OB2SEL			(1<<1)
#define PSCAT_ANYSEL			(PSCAT_OB1SEL|PSCAT_OB2SEL)
#define PSCAT_INRENDER			(1<<2)
#define PSCAT_ROTX				(1<<4)
#define PSCAT_ROTY				(1<<5)
#define PSCAT_ROTZ				(1<<6)
#define PSCAT_TRANX				(1<<7)
#define PSCAT_TRANY				(1<<8)
#define PSCAT_TRANZ				(1<<9)
#define PSCAT_TRANFX			(1<<10)
#define PSCAT_TRANFY			(1<<11)
#define PSCAT_TRANFZ			(1<<12)
#define PSCAT_SCALEX			(1<<13)
#define PSCAT_SCALEY			(1<<14)
#define PSCAT_SCALEZ			(1<<15)
#define forceredraw				(1<<16)
#define PSCAT_DISPRESULT		(1<<3)

//--- Parameter map/block descriptors -------------------------------
#define PB_DISTMETHOD		0
#define PB_NUMBER			1
#define PB_BASESCALE		2
#define PB_VERTEXCHAOS		3
#define PB_MAKEPERP			4
#define PB_DOONSELFACES		5
#define PB_DISTMETHOD2		6
#define PB_EVERYNFACES		7

#define PB_DOWITHDIST		8

#define PB_ROTX				9
#define PB_ROTY				10
#define PB_ROTZ				11
#define PB_ROTLOCK			12
#define PB_TRANX			13
#define PB_TRANY			14
#define PB_TRANZ			15
#define PB_TRANLOCK			16
#define PB_TRANFX			17
#define PB_TRANFY			18
#define PB_TRANFZ			19
#define PB_TRANFLOCK		20
#define PB_SCALEX			21
#define PB_SCALEY			22
#define PB_SCALEZ			23
#define PB_SCALELOCK		24
#define PB_ASPECTLOCK		25

#define PB_DISPLAYMETHOD	26
#define PB_DISPLAYPORTION	27
#define PB_HIDEDISTOBJECT	28
#define PB_RANDOMSEED		29
#define PB_SHOWTYPE			30

#define PB_EXTRACTTYPE		31
#define PB_ANIOFF			32


static int createMethodIDs[] = {IDC_AP_VOLARRAY,IDC_AP_DISTOBJECT};
static int extractMethodIDs[] = {IDC_SCATR_EXTRACT_INSTANCE,IDC_SCATR_EXTRACT_COPY};
static int createDistDoIDs[] = {IDC_AP_DISTREF,IDC_AP_DISTCOPY,IDC_AP_DISTMOVE,IDC_AP_DISTINST};
static int createDistributeWayIDs[] = {IDC_AP_DISTCENTERS,IDC_AP_DISTVERTICES,IDC_AP_DISTAREA,
									   IDC_AP_DISTEVEN,IDC_AP_DISTNFACES,IDC_AP_DISTRANDOM,IDC_AP_DISTEDGES,IDC_AP_DISTECENTER,IDC_AP_DISTVOLUME};
static int ShowIDs[] = {IDC_PS_DISPRESULT,IDC_PS_DISPOPS};
#define FCENTER 0
#define VERTICES 1
#define UNIFORM 2
#define EVEN 3
#define NFACES 4
#define RANDOM 5
#define EDGES 6
#define ECENTER 7
#define VOLUME 8

static int createDisplayIDs[] = {IDC_AP_DISPPROXY,IDC_AP_DISPMESH};


static ParamUIDesc descObjects[] = {
	// Distribution Method
	ParamUIDesc(PB_DISTMETHOD,TYPE_RADIO,createMethodIDs,2),

	// Extraction Method
	ParamUIDesc(PB_EXTRACTTYPE,TYPE_RADIO,extractMethodIDs,2),

	// Number of instances in ScatterObject
	ParamUIDesc(
		PB_NUMBER,
		EDITTYPE_INT,
		IDC_AP_NUMBER,IDC_AP_NUMBERSPIN,
		0.0f,65000.0f,
		1.0f),

	// Base Scale
	ParamUIDesc(
		PB_BASESCALE,
		EDITTYPE_FLOAT,
		IDC_AP_BASESCALE,IDC_AP_BASESCALESPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),
	
	// Vertex Chaos
	ParamUIDesc(
		PB_VERTEXCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_BASEVERTS,IDC_AP_BASEVERTSSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	// Animation offset
	ParamUIDesc(
		PB_ANIOFF,
		EDITTYPE_TIME,
		IDC_AP_FRAMESDIFF,IDC_AP_FRAMESDIFFSPIN,
		1.0f,999999999.0f,
		10.0f),
	
	// Start with Perpendicular Instances
	ParamUIDesc(PB_MAKEPERP,TYPE_SINGLECHEKBOX,IDC_AP_GOPERP),			

	// Use Selected Faces
	ParamUIDesc(PB_DOONSELFACES,TYPE_SINGLECHEKBOX,IDC_AP_GOSELECT),			

	// Distribute instances using
	ParamUIDesc(PB_DISTMETHOD2,TYPE_RADIO,createDistributeWayIDs,9),

	// Skip N faces
	ParamUIDesc(
		PB_EVERYNFACES,
		EDITTYPE_INT,
		IDC_AP_DISTNFACESN,IDC_AP_DISTNFACESNSPIN,
		0.0f,65000.0f,
		1.0f),

	// Show Types
	ParamUIDesc(PB_SHOWTYPE,TYPE_RADIO,ShowIDs,2),			
	};

#define OBJECTSDESC_LENGTH 11

static ParamUIDesc descPickDist[] = {
	// What to do with dist object
	ParamUIDesc(PB_DOWITHDIST,TYPE_RADIO,createDistDoIDs,4),
	};

#define PICKDISTDESC_LENGTH 1

static ParamUIDesc descTransforms[] = {
	// Rotation Controls
	ParamUIDesc(
		PB_ROTX,
		EDITTYPE_FLOAT,
		IDC_AP_ROTX,IDC_AP_ROTXSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_ROTY,
		EDITTYPE_FLOAT,
		IDC_AP_ROTY,IDC_AP_ROTYSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_ROTZ,
		EDITTYPE_FLOAT,
		IDC_AP_ROTZ,IDC_AP_ROTZSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	// Lock maximum rotation
	ParamUIDesc(PB_ROTLOCK,TYPE_SINGLECHEKBOX,IDC_AP_ROTLOCK),			

	// Translation controls in local frame
	ParamUIDesc(
		PB_TRANX,
		EDITTYPE_FLOAT,
		IDC_AP_TRANX,IDC_AP_TRANXSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_TRANY,
		EDITTYPE_FLOAT,
		IDC_AP_TRANY,IDC_AP_TRANYSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_TRANZ,
		EDITTYPE_FLOAT,
		IDC_AP_TRANZ,IDC_AP_TRANZSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	// Lock maximum translation
	ParamUIDesc(PB_TRANLOCK,TYPE_SINGLECHEKBOX,IDC_AP_TRANLOCK),			

	// Translation controls in FACE frame
	ParamUIDesc(
		PB_TRANFX,
		EDITTYPE_FLOAT,
		IDC_AP_TRANXF,IDC_AP_TRANXFSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_TRANFY,
		EDITTYPE_FLOAT,
		IDC_AP_TRANYF,IDC_AP_TRANYFSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	ParamUIDesc(
		PB_TRANFZ,
		EDITTYPE_FLOAT,
		IDC_AP_TRANZF,IDC_AP_TRANZFSPIN,
		-9999999.0f,9999999.0f,
		SPIN_AUTOSCALE),

	// Lock maximum translation
	ParamUIDesc(PB_TRANFLOCK,TYPE_SINGLECHEKBOX,IDC_AP_TRANFLOCK),			

	// Scale Controls
	ParamUIDesc(
		PB_SCALEX,
		EDITTYPE_FLOAT,
		IDC_AP_SCALEX,IDC_AP_SCALEXSPIN,
		0.0f,1000.0f,
		0.1f),
	
	ParamUIDesc(
		PB_SCALEY,
		EDITTYPE_FLOAT,
		IDC_AP_SCALEY,IDC_AP_SCALEYSPIN,
		0.0f,1000.0f,
		0.1f),
	
	ParamUIDesc(
		PB_SCALEZ,
		EDITTYPE_FLOAT,
		IDC_AP_SCALEZ,IDC_AP_SCALEZSPIN,
		0.0f,1000.0f,
		0.1f),
	
	// Lock maximum scale transform
	ParamUIDesc(PB_SCALELOCK,TYPE_SINGLECHEKBOX,IDC_AP_SCALELOCK),			

	// Lock aspect ratios
	ParamUIDesc(PB_ASPECTLOCK,TYPE_SINGLECHEKBOX,IDC_AP_ASPECTLOCK)

	};

#define TRANSFORMSDESC_LENGTH 17

static ParamUIDesc descDisplay[] = {
	// Distribute instances using
	ParamUIDesc(PB_DISPLAYMETHOD,TYPE_RADIO,createDisplayIDs,2),

	// Display Portion
	ParamUIDesc(
		PB_DISPLAYPORTION,
		EDITTYPE_FLOAT,
		IDC_AP_DISPPORTION,IDC_AP_DISPPORTIONSPIN,
		1.0f,100.0f,
		1.0f,stdPercentDim),

	// Start with Perpendicular Instances
	ParamUIDesc(PB_HIDEDISTOBJECT,TYPE_SINGLECHEKBOX,IDC_AP_HIDEDIST),			
	
	// Random Number Seed
	ParamUIDesc(
		PB_RANDOMSEED,
		EDITTYPE_INT,
		IDC_AP_RANDOMSEED,IDC_AP_RANDOMSEEDSPIN,
		0.0f,32000.0f,
		1.0f)
	};

#define DISPLAYDESC_LENGTH 4

// variable type, NULL, animatable, number
ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },

	{ TYPE_INT, NULL, FALSE, 8 },

	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 },
	{ TYPE_INT, NULL, FALSE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
	{ TYPE_FLOAT, NULL, TRUE, 18 },
	{ TYPE_FLOAT, NULL, TRUE, 19 },
	{ TYPE_INT, NULL, FALSE, 20 },
	{ TYPE_FLOAT, NULL, TRUE, 21 },
	{ TYPE_FLOAT, NULL, TRUE, 22 },
	{ TYPE_FLOAT, NULL, TRUE, 23 },
	{ TYPE_INT, NULL, FALSE, 24 },
	{ TYPE_INT, NULL, FALSE, 25 },

	{ TYPE_INT, NULL, FALSE, 26 },
	{ TYPE_FLOAT, NULL, FALSE, 27 },
	{ TYPE_INT, NULL, FALSE, 28 },
	{ TYPE_INT, NULL, FALSE, 29 }
	};
ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },

	{ TYPE_INT, NULL, FALSE, 8 },

	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 },
	{ TYPE_INT, NULL, FALSE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
	{ TYPE_FLOAT, NULL, TRUE, 18 },
	{ TYPE_FLOAT, NULL, TRUE, 19 },
	{ TYPE_INT, NULL, FALSE, 20 },
	{ TYPE_FLOAT, NULL, TRUE, 21 },
	{ TYPE_FLOAT, NULL, TRUE, 22 },
	{ TYPE_FLOAT, NULL, TRUE, 23 },
	{ TYPE_INT, NULL, FALSE, 24 },
	{ TYPE_INT, NULL, FALSE, 25 },

	{ TYPE_INT, NULL, FALSE, 26 },
	{ TYPE_FLOAT, NULL, FALSE, 27 },
	{ TYPE_INT, NULL, FALSE, 28 },
	{ TYPE_INT, NULL, FALSE, 29 },
	{ TYPE_INT, NULL, FALSE, 30 }
	};
ParamBlockDescID descVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },

	{ TYPE_INT, NULL, FALSE, 8 },

	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 },
	{ TYPE_INT, NULL, FALSE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
	{ TYPE_FLOAT, NULL, TRUE, 18 },
	{ TYPE_FLOAT, NULL, TRUE, 19 },
	{ TYPE_INT, NULL, FALSE, 20 },
	{ TYPE_FLOAT, NULL, TRUE, 21 },
	{ TYPE_FLOAT, NULL, TRUE, 22 },
	{ TYPE_FLOAT, NULL, TRUE, 23 },
	{ TYPE_INT, NULL, FALSE, 24 },
	{ TYPE_INT, NULL, FALSE, 25 },

	{ TYPE_INT, NULL, FALSE, 26 },
	{ TYPE_FLOAT, NULL, FALSE, 27 },
	{ TYPE_INT, NULL, FALSE, 28 },
	{ TYPE_INT, NULL, FALSE, 29 },
	{ TYPE_INT, NULL, FALSE, 30 },
	{ TYPE_INT, NULL, FALSE, 31 },
	{ TYPE_INT, NULL, TRUE, 32 }
	};

#define PBLOCK_LENGTH	33

#define NUM_OLDVERSIONS	2

#define CURRENT_VERSION	2
static ParamVersionDesc psversions[] = {
	ParamVersionDesc(descVer0,30,0),
	ParamVersionDesc(descVer1,31,1),
	};
static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);
typedef struct {
 Point3	pt,norm,x,V02;
} SavePt;
static Point3 ZNorm(0.0f,0.0f,1.0f);
static Point3 XNorm(1.0f,0.0f,0.0f);
class PickOperand;

class PScatterObject: public GeomObject, public MeshOpProgress {
		
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
				
	public:
		TSTR opaName, opbName;
		Object *ob1, *ob2;
		Control *tm1,*tm2;
		INode *mainnode;
		static IParamMap *pmapObjects;
		static IParamMap *pmapDist;
		static IParamMap *pmapTransforms;
		static IParamMap *pmapDisplay;
		static custsettings;
		IParamBlock *pblock;
		static Matrix3 createTM;
		static HWND thwnd,distwnd;
		DWORD flags;
		int ob1verts,ob1faces,firstmtls,secondmtls,size;
		Interval ivalid;
		Mesh mesh;		

		static IObjParam *ip;
		static PickOperand pickCB;
		static BOOL creating;
		static PScatterObject *editOb;
		static int extractCopy;

		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;

		PScatterObject();
		~PScatterObject();
		
		void SetFlag(DWORD mask) { flags|=mask; }
		void ClearFlag(DWORD mask) { flags &= ~mask; }
		int TestFlag(DWORD mask) { return(flags&mask?1:0); }
		DWORD BoolOp(int &order);

		void SetOperand(INode *node,Matrix3& boolTm,Matrix3& oppTm,int which,INode *orignode,bool *canUndo=NULL);
		BOOL UpdateMesh(TimeValue t,BOOL force=FALSE,BOOL sel=FALSE);
		Object *GetPipeObj(TimeValue t,int which);
		Matrix3 GetOpTM(TimeValue t,int which,Interval *iv=NULL);
		void Invalidate() {ivalid.SetEmpty();}
		void ExtractOperand(int which);
//		void MapKeys(TimeMap *map,DWORD flags);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		TCHAR *GetObjectName() { return GetString(IDS_AP_SCATTERNAME); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// For sub-object selection
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc);
		
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert);
		void ClearSelection(int selLevel);

		int SubObjectIndex(HitRecord *hitRec);

		void ActivateSubobjSel(int level, XFormModes& modes);
		void ShowOpList(BOOL isobj);
		void ShowName(BOOL ob2);
		static AName *NameLst;
		static HWND hParams2,hObject;
		static ICustEdit *custCtrlEdit;
		// From Object		
		void InitNodeName(TSTR& s) {s = GetString(IDS_AP_SCATTERNAME);}
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		ObjectState Eval(TimeValue time);
		int NumPipeBranches();
		Object *GetPipeBranch(int i);
		INode *GetBranchINode(TimeValue t,INode *node,int i);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int aflags);
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel);
		void GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt, Box3& box);
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
		void SetExtractButtonState();

		// From GeomObject		
		ObjectHandle CreateTriObjRep(TimeValue t) {return NULL;}
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		// Animatable methods
		Class_ID ClassID() {return PROSCATTEROBJ_CLASS_ID;}  
		void GetClassName(TSTR& s) {s = GetString(IDS_AP_SCATTEROBJECT);}
		void DeleteThis() {delete this;}				
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum);

		// From ref
		RefTargetHandle Clone(RemapDir& remap);
		int NumRefs() {return 5;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		void GetFilename(TCHAR *filename);
		void SetupTargetList();
		int SaveSettings(int overwrite,TCHAR *newname);
		int GetSettings(int setnum,TCHAR *newname);
		int RemSettings(int setnum,TCHAR *newname);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		// From MeshOpProgress
		void Init(int total);
		BOOL Progress(int p);
		void GetPosInfo(int x,int y,int z,int sx,int sy,int sz,float *rotx,float *roty,float *rotz,TimeValue t);
		void InvalidateUI();
	};				

class PickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PScatterObject *bo;
		
		PickOperand() {bo=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);
		
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}

		PickNodeCallback *GetFilter() {return this;}
	};

IParamMap *PScatterObject::pmapObjects = NULL;
IParamMap *PScatterObject::pmapDist = NULL;
IParamMap *PScatterObject::pmapTransforms = NULL;
IParamMap *PScatterObject::pmapDisplay = NULL;
IObjParam *PScatterObject::ip                   = NULL;
BOOL PScatterObject::creating                   = FALSE;
PScatterObject *PScatterObject::editOb              = NULL;
MoveModBoxCMode*    PScatterObject::moveMode    = NULL;
RotateModBoxCMode*  PScatterObject::rotMode 	= NULL;
UScaleModBoxCMode*  PScatterObject::uscaleMode  = NULL;
NUScaleModBoxCMode* PScatterObject::nuscaleMode = NULL;
SquashModBoxCMode*  PScatterObject::squashMode  = NULL;
SelectModBoxCMode*  PScatterObject::selectMode  = NULL;
ICustEdit *PScatterObject::custCtrlEdit=NULL;
int PScatterObject::custsettings=0;
AName *PScatterObject::NameLst=NULL;
PickOperand PScatterObject::pickCB;
Matrix3 PScatterObject::createTM;
HWND PScatterObject::thwnd;
HWND PScatterObject::distwnd;
HWND PScatterObject::hParams2;
HWND PScatterObject::hObject;
int PScatterObject::extractCopy = FALSE;

class PScatObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new PScatterObject;}
	const TCHAR *	ClassName() { return GetString(IDS_AP_SCATTEROBJECT); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return PROSCATTEROBJ_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_COMPOUNDOBJECTS);}
	BOOL			OkToCreate(Interface *i);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	};

class CreateScatrref : public RestoreObj {
	public:   		
		PScatterObject *obj;
		TSTR name,name2;
		CreateScatrref(PScatterObject *o, TSTR n, TSTR n1) {
			obj = o; name=TSTR(n);name2=TSTR(n1); 
			}
		void Restore(int isUndo) {
			BOOL isname=_tcslen(name)>0;
			obj->opbName=(isname?TSTR(GetString(IDS_AP_D)) + name:name);
			obj->ShowOpList(isname);
			}	
		void Redo() 
		{   BOOL isname=_tcslen(name2)>0;
		obj->opbName=(isname?TSTR(GetString(IDS_AP_D)) + name2:name2);
			obj->ShowOpList(isname);
			}
		TSTR Description() {return GetString(IDS_AP_CREATESCATNOTIFY);}
	};

void PScatObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	}
static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

BOOL PScatObjClassDesc::OkToCreate(Interface *i)
	{
	if (i->GetSelNodeCount()!=1) return FALSE;
	Interval intvalid;
	BOOL needsDel;
	Object *tob=i->GetSelNode(0)->GetObjectRef();
	TriObject *tri=GetTriObject(i->GetTime(),tob,intvalid,needsDel);
	if (tri==NULL) return FALSE;
	if (needsDel) tri->DeleteThis();
	return TRUE;	
	}

static PScatObjClassDesc PScatObjDesc;

ClassDesc* GetPScatObjDesc() { return &PScatObjDesc; }

BOOL PScatterObject::HasUVW() { 
	BOOL genUV1=FALSE,genUV2=FALSE;
    if (ob1) genUV1=ob1->HasUVW();
	if (ob2) genUV2=ob2->HasUVW();
	return (genUV1&& genUV2); 
	}

void PScatterObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	if (ob1) ob1->SetGenUVW(sw);
	if (ob2) ob2->SetGenUVW(sw);			
	}


// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

//----------------------------------------------------------------------

class CreatePScatProc : public MouseCallBack {
	public:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		int proc( 
			HWND hWnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

int CreatePScatProc::proc( 
		HWND hWnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m ) 
	{
	switch (msg) {
		case MOUSE_POINT:
			ip->SetActiveViewport(hWnd);
			break;
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
		case MOUSE_PROPCLICK:
			// right click while between creations
			ip->RemoveMode(NULL);
			break;
		}	
	return TRUE;
	}

class CreatePScatMode : public CommandMode, ReferenceMaker {		
	public:		
		CreatePScatProc proc;
		INode *node, *svNode;
		IObjParam *ip;
		PScatterObject *obj;

		void Begin(INode *n,IObjParam *i);
		void End(IObjParam *i);
		void JumpStart(IObjParam *i,PScatterObject *o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEPROSCATTERMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 1; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG(CommandMode *oldMode) {return TRUE;}
		void EnterMode() {/*MakeRefByID(FOREVER,0,svNode);*/}
		void ExitMode() {/*DeleteAllRefsFromMe();*/}
		
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return node;}
		void SetReference(int i, RefTargetHandle rtarg) {node = (INode*)rtarg;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);		
	};
static CreatePScatMode theCreatePScatMode;

RefResult CreatePScatMode::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,
		RefMessage message)
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:		
		case REFMSG_TARGET_DELETED:			
			if (ip) ip->StopCreating();
			break;

		}
	return REF_SUCCEED;
	}

class CreateScatterRestore : public RestoreObj {
	public:   		
		void Restore(int isUndo) {
			if (theCreatePScatMode.ip) {
				// Jump out of boolean create mode.
				theCreatePScatMode.ip->SetStdCommandMode(CID_OBJMOVE);
				}
			}	
		void Redo() {}
		TSTR Description() {return GetString(IDS_AP_CREATESCAT);}
	};

// Sending the REFMSG_NOTIFY_PASTE message notifies the modify
// panel that the Node's object reference has changed when
// undoing or redoing.
class CreateScatterNotify : public RestoreObj {
	public:   		
		PScatterObject *obj;
		BOOL which;
		CreateScatterNotify(PScatterObject *o, BOOL w) {
			obj = o; which = w;
			}
		void Restore(int isUndo) {
			if (which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}	
		void Redo() {
			if (!which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}
		TSTR Description() {return GetString(IDS_AP_CREATESCATNOTIFY);}
	};

void CreatePScatMode::Begin(INode *n,IObjParam *i) 
	{
	MakeRefByID(FOREVER,0,n);
	svNode = node;
	assert(node);
	ip = i;
	proc.Init(ip);

	theHold.Begin();
	theHold.Put(new CreateScatterRestore);

	obj = new PScatterObject;

	theHold.Put(new CreateScatterNotify(obj,1));

	obj->createTM = node->GetObjectTM(0);
	obj->mainnode=node;
	theHold.Begin();

	obj->SetOperand(
		node,
		obj->createTM,
		obj->createTM,
		0,NULL);
	node->SetObjectRef(obj);
	
	theHold.Put(new CreateScatterNotify(obj,0));

	theHold.Accept(GetString(IDS_AP_CREATE));

	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

void CreatePScatMode::End(IObjParam *i)
	{
	svNode = node;
	if (obj) obj->EndEditParams(i,END_EDIT_REMOVEUI,NULL);
	DeleteAllRefsFromMe();
	ip  = NULL;
	obj = NULL;
	}

void CreatePScatMode::JumpStart(IObjParam *i,PScatterObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int PScatObjClassDesc::BeginCreate(Interface *i)
	{	
	assert(i->GetSelNodeCount()==1);
	theCreatePScatMode.Begin(i->GetSelNode(0),(IObjParam*)i);
	i->PushCommandMode(&theCreatePScatMode);
	return TRUE;
	}

int PScatObjClassDesc::EndCreate(Interface *i)
	{
	theCreatePScatMode.End((IObjParam*)i);
	i->RemoveMode(&theCreatePScatMode);
	return TRUE;
	}

//----------------------------------------------------------------------
/*void PScatterObject::MapKeys(TimeMap *map,DWORD flags)
{//	Animatable::MapKeys(map,flags);
//	TimeValue TempTime;
// remap values
//	pblock->GetValue(PB_ANIOFF,0,TempTime,FOREVER);
//	TempTime=map->map(TempTime);
//	pblock->SetValue(PB_ANIOFF,0,TempTime);
}  */


PScatterObject::PScatterObject()
	{	MakeRefByID(FOREVER, PBLOCK, CreateParameterBlock(descVer2, PBLOCK_LENGTH, CURRENT_VERSION));	
	ob1 = ob2 = NULL;
	tm1 = tm2 = NULL;
	flags = (PSCAT_ROTX | PSCAT_ROTY | PSCAT_ROTZ | PSCAT_TRANX | PSCAT_TRANY | PSCAT_TRANZ);
	flags |= (PSCAT_SCALEX | PSCAT_SCALEY | PSCAT_SCALEZ | PSCAT_TRANFX | PSCAT_TRANFY | PSCAT_TRANFZ);
	flags |= PSCAT_DISPRESULT;
	ivalid.SetEmpty();
	pblock->SetValue(PB_DOWITHDIST,0,3);
	pblock->SetValue(PB_DISTMETHOD,0,1);
	pblock->SetValue(PB_DISTMETHOD2,0,3);
	pblock->SetValue(PB_BASESCALE,0,1.0f);
	pblock->SetValue(PB_MAKEPERP,0,1);
	pblock->SetValue(PB_RANDOMSEED,0,12345);
	pblock->SetValue(PB_NUMBER,0,1);
	pblock->SetValue(PB_SCALEX,0,0.0f);
	pblock->SetValue(PB_SCALEY,0,0.0f);
	pblock->SetValue(PB_SCALEZ,0,0.0f);
	pblock->SetValue(PB_DISPLAYPORTION,0,1.0f);
	pblock->SetValue(PB_DISPLAYMETHOD,0,1);
	pblock->SetValue(PB_SHOWTYPE,0,0);
	pblock->SetValue(PB_ANIOFF,0,TimeValue(0));
	ob1verts=0;ob1faces=0;
	firstmtls=0;secondmtls=0;
	size=16*isize+fsize*15;
	}

PScatterObject::~PScatterObject()
	{
	DeleteAllRefsFromMe();
	}

static int Progress(int percent,void *data)
	{
	if (data) {
		MeshOpProgress *p = (MeshOpProgress*)data;
		return p->Progress(percent);
	} else {
		return 1;
		}
	}

void PScatterObject::ExtractOperand(int which)
{	if (creating) return;

	// Compute a node TM for the new object
	assert(ip);
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	Matrix3 tm = nodes[0]->GetObjectTM(ip->GetTime());
	Matrix3 tmOp = GetOpTM(ip->GetTime(),which);
	Object *obj = which ? ob2 : ob1;
	if (!obj) return;
	tm = tmOp * tm;

	// Clone the object if specified
	if (extractCopy) obj = (Object*)obj->Clone();

	// Create the new node
	INode *node = ip->CreateObjectNode(obj);

	// Set the node TM.
	SuspendAnimate();
	AnimateOff();
	node->SetNodeTM(0,tm);
	ResumeAnimate();

	nodes.DisposeTemporary();
}

Point3 GetNormalizedNormal(ulong *curface,Point3 *v)
{return(Normalize((v[curface[0]]-v[curface[1]])^(v[curface[0]]-v[curface[2]])));
}
void SpreadOutParts(float *arealst,float TotalArea,int maxfaces,int block,int total,int *lst)
{int i,newcount;

  newcount=0;
  for (i=0;i<block;i++)
  {	newcount+=(lst[i]=(int)floor(total*(arealst[i]/TotalArea)));
  }
  for (i=newcount;i<total;i++)
   lst[RND0x(maxfaces)]+=1;
}

float GetFaceArea(DWORD *curface,Point3 *v)
{ Point3 V1,V2;

  V1=v[curface[1]]-v[curface[0]];
  V2=v[curface[2]]-v[curface[0]];
/* Point3 D,N;
  float h,b;
  N=V1^V2;
	D=Normalize(N^V1);
  h=(float)fabs(DotProd(D,v[curface[2]])-DotProd(D,v[curface[0]]));
  b=Length(V1);
  return(0.5f*b*h);	 */
  return(Length(V1^V2)*0.5f);
}

void FillInUniform(int infaces,int c,Face *faces,Point3 *verts,SavePt *center)
{ int i,*lst,vertices=0;
  float *arealst,TotalArea,rx,ry;
  Point3 Norm,X;

  arealst=new float[infaces];
  lst=new int[infaces];
  assert(arealst && lst);
  TotalArea=0.0f;
  for (i=0;i<infaces;i++)
    TotalArea+=(arealst[i]=GetFaceArea(&faces[i].v[0],verts));
  float incr=TotalArea/(float)c,cpos=0.0f,tarea=arealst[0];
  i=0;
  for (int cnt=0;cnt<c;cnt++)
  {	cpos+=incr;
    while ((cpos>tarea)&&(i+1<infaces)) tarea+=arealst[++i];
    Point3 V0,V1,V2,V01,V02,nV02;
    V01=(V1=verts[faces[i].v[1]])-(V0=verts[faces[i].v[0]]);
    V02=(V2=verts[faces[i].v[2]])-V0;
    Norm=GetNormalizedNormal(&faces[i].v[0],verts);
	X=Normalize(V01);
	nV02=Normalize(V02);
    center[vertices].norm=Norm;
	center[vertices].x=X;
	center[vertices].V02=nV02;
    rx=RND01();ry=RND01();
    if (rx+ry>1) {rx=1-rx;ry=1-ry;}
	center[vertices].pt=V0+V01*rx+V02*ry;
	vertices++;
  }
  delete[] arealst;
  delete[] lst;
}
Point3 AveNormal(Point3 newnorm,Point3 oldnorm)
{ Point3 aveN;

  aveN=(newnorm+oldnorm)/2.0f;
  if (Length(aveN)==0.0f)
  { aveN=Point3(RND11(),RND11(),RND11());}
  return(Normalize(aveN));
}
float Checkfordup(DWORD *curface,int P0,int P1,float *arealst,fEdge *edgelst,int *edges,int face,Point3 *vlst,Face *f)
{ int i,found;
  float area;
  Point3 norm;

  found=i=0;area=0.0f;
  while ((!found)&&(i<*edges))
   { found=((edgelst[i].vto==curface[P0])&&(edgelst[i].vfrom==curface[P1]))||
            ((edgelst[i].vfrom==curface[P0])&&(edgelst[i].vto==curface[P1]));
     if (!found) i++;
   }
   if (found)
   { norm=GetNormalizedNormal(curface,vlst);
     edgelst[i].normal=AveNormal(norm,edgelst[i].normal);
   }
   else
   {if (arealst) area=(arealst[i]=Length(vlst[curface[P0]]-vlst[curface[P1]]));
    edgelst[i].vfrom=curface[P0];edgelst[i].vto=curface[P1];
    edgelst[i].normal=GetNormalizedNormal(curface,vlst);
    (*edges)++;
   }
 return(area);
}

float GetEdgeArea(Face *faces,Point3 *verts,float *arealst,fEdge *edgelst,int *edges,int face)
{ float area;
  DWORD *curface=&(faces[face]).v[0],flags=faces[face].flags;
  area=0.0f;
  if ((flags & EDGE_A)>0)
    area+=Checkfordup(curface,0,1,arealst,edgelst,edges,face,verts,faces);
  if ((flags & EDGE_B)>0)
    area+=Checkfordup(curface,1,2,arealst,edgelst,edges,face,verts,faces);
  if ((flags & EDGE_C)>0)
    area+=Checkfordup(curface,2,0,arealst,edgelst,edges,face,verts,faces);
  return(area);
}

void FillByEdges(int infaces,int c,Face *faces,Point3 *verts,SavePt *center)
{ int i,edges,numedges=3*infaces,*lst,vertices=0;
  float *arealst,TotalArea,r;
  fEdge *edgelst;
  Point3 lastpt;

  edges=0;
  assert((arealst=new float[numedges])!=NULL);
  assert((edgelst=new fEdge[numedges])!=NULL);
  lst=new int[numedges];assert(lst);
  TotalArea=0.0f;
  for (i=0;i<infaces;i++)
    TotalArea+=GetEdgeArea(faces,verts,arealst,edgelst,&edges,i);
  SpreadOutParts(arealst,TotalArea,edges-1,edges,c,lst);
  for (i=0;i<edges;i++)
  { Point3 pt=verts[edgelst[i].vfrom],pdist=verts[edgelst[i].vto]-pt;
    Point3 X=Normalize(pdist);
	for (int j=0;j<lst[i];j++)
	{ r=RND01();
      center[vertices].pt=pt+pdist*r;
      center[vertices].norm=edgelst[i].normal;
      center[vertices].x=X;
      vertices++;
    }
  }
  if (lst) delete[] lst;
  delete[] arealst;
  delete[] edgelst;
} 
void FillEdgeCenter(int edges,fEdge *edgelst,Point3 *verts,SavePt *center)
{ int i;

  for (i=0;i<edges;i++)
  { Point3 pt=verts[edgelst[i].vfrom],pdist=verts[edgelst[i].vto]-pt;
    Point3 X=Normalize(pdist);
    center[i].pt=pt+pdist*0.5f;
    center[i].norm=edgelst[i].normal;
    center[i].x=X;
  }
  if (edgelst) delete[] edgelst;
} 

int amatch(DWORD *ptr,DWORD nxt)
{ return((ptr[0]==nxt)||(ptr[1]==nxt)||(ptr[2]==nxt));
}
BOOL VertexinWhichFace(int v,Face *flst,int infaces,int *aface)
{ BOOL found;

  found=0;
  while ((*aface<infaces)&&(!found))
  { found=amatch(flst[*aface].v,v);
    if (!found) (*aface)++;
  }
  return(found);
}

void FillInFaces(int nfaces,int vertices,Face *faces,Point3 *verts,SavePt *center)
{ int i;

  for (i=0;i<nfaces;i++)
  { center[i].pt=(verts[faces[i].v[0]]+verts[faces[i].v[1]]+verts[faces[i].v[2]])/3.0f;
	center[i].norm=GetNormalizedNormal(&faces[i].v[0],verts);
	center[i].x=Normalize(verts[faces[i].v[1]]-verts[faces[i].v[0]]);
	center[i].V02=Normalize(verts[faces[i].v[2]]-verts[faces[i].v[0]]);
  }
}

void FillInVertex(int inverts,int infaces,Face *faces,Point3 *verts,SavePt *center)
{ int i,face,ncounter,firstface,icount=0;
  Point3 newNorm,zero=Point3(0.0f,0.0f,0.0f);

  for (i=0;i<inverts;i++)
  {	face=firstface=ncounter=0;
	  newNorm=zero;
      while (VertexinWhichFace(i,faces,infaces,&face))
	  { newNorm+=GetNormalizedNormal(&faces[face].v[0],verts);
	    if (ncounter==0) firstface=face;
	    ncounter++;face++;
	   }
	if (ncounter>0)
	{
	int firstv=(faces[firstface].v[0]==(DWORD)i?faces[firstface].v[1]:faces[firstface].v[0]);
	center[icount].pt=verts[i];
	center[icount].norm=Normalize(ncounter>0?newNorm/(float)ncounter:Point3(RND11(),RND11(),RND11()));
	center[icount].x=Normalize((verts[firstv]-verts[i])^center[icount].norm);
	icount++; }
  }
}

void FillByXFaces(int infaces,int c,Face *faces,Point3 *verts,SavePt *center,int incr,BOOL rnd)
{ int i=0,maxrnd=infaces-1;
  float rx,ry;
  Point3 Norm;

  Point3 V0,V1,V2,V01,V02;
  incr++;
  for (int cnt=0;cnt<c;cnt++)
  { if (rnd) i=RND0x(maxrnd);
	V01=(V1=verts[faces[i].v[1]])-(V0=verts[faces[i].v[0]]);
    V02=(V2=verts[faces[i].v[2]])-V0;
	Norm=GetNormalizedNormal(&faces[i].v[0],verts);
    center[cnt].norm=Norm;
	center[cnt].x=Normalize(V01);
	center[cnt].V02=Normalize(V02);
    rx=RND01();ry=RND01();
    if (rx+ry>1) {rx=1-rx;ry=1-ry;}
	center[cnt].pt=V0+V01*rx+V02*ry;
	if (!rnd) {i+=incr;if (i>=infaces) i%=infaces;}
  }
}

BOOL InsideMesh(Ray& ray, Mesh *amesh,Point3 *fnorms)
{	Face *face;	
	Point3 n,p, bry;
	float d, rn, a,at;
	BOOL notfirst = FALSE,inside=FALSE,savein=FALSE;
	int raycount=0;

   while ((!savein)&&(raycount<3))
   { notfirst=FALSE;
     if (raycount==0) ray.dir=Point3(1.0f,0.0f,0.0f);
	 else if (raycount==1) ray.dir=Point3(0.0f,1.0f,0.0f);
	 else ray.dir=Point3(0.0f,0.0f,1.0f);
	face=amesh->faces;
	for (int i=0; i<amesh->getNumFaces(); i++,face++)
	{	n = fnorms[i];
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (fabs(rn) < EPSILON) continue; //is parallel, so bail
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);
		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;
		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;
		inside=(((a > 0.0f)&&(rn>0.0f))||((a < 0.0f)&&(rn<0.0f)));
		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);
		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;
		// Must be closer than the closest at so far
		if (notfirst)
			if (fabs(a) > at) continue;

		// Hit!
		notfirst = TRUE;		
		at    = (float)fabs(a);
		savein=inside;
	  } raycount++;
   }
	return savein;

	}

void FillByNoVolume(Mesh *amesh,int num,SavePt *center,Box3 bbox,Point3 box)
{ Ray ray;
  for (int i=0;i<num;i++)
  { center[i].pt=bbox.pmin+Point3(RND01(),RND01(),RND01())*box;
  }
}
void FillByVolume(Mesh *amesh,int num,SavePt *center,Box3 bbox,Point3 box,Point3 *fnorms)
{ Ray ray;
  for (int i=0;i<num;i++)
  {	int testcount=0;
	ray.p=bbox.pmin+Point3(RND01(),RND01(),RND01())*box;
	while ((!InsideMesh(ray,amesh,fnorms))&&(testcount<TESTLIMIT))
	{ testcount++;
	  ray.p=bbox.pmin+Point3(RND01(),RND01(),RND01())*box;
	}
	center[i].pt=ray.p;
  }
}


void PScatterObject::SetOperand(
		INode *node,Matrix3& boolTm,Matrix3& oppTm,int which,INode *orignode,bool *canUndo)
{ if (which)
	{ opbName = TSTR(GetString(IDS_AP_D)) + TSTR(node->GetName()); }
  else { opaName= TSTR(GetString(IDS_AP_S)) + TSTR(node->GetName()); }

  BOOL delnode = FALSE;
  Object *obj = node->GetObjectRef();

  if (which)
  {	int	dmethod;
	pblock->GetValue(PB_DOWITHDIST,0,dmethod,FOREVER);
	if (dmethod==0)	obj = MakeObjectDerivedObject(obj);
	else if (dmethod==1) obj = (Object*)obj->Clone();
    else if (dmethod==2) delnode = TRUE;
	else flags |= forceredraw;
  }
	
//	theHold.Begin();

	// Plug in the object and a new controller.	
	if (which?ob1:ob2) ReplaceReference(which,obj,TRUE);
	else MakeRefByID(FOREVER,which,obj);
	ShowOpList(ob2!=NULL);
//	ReplaceReference(2,NewDefaultMatrix3Controller());
	SuspendAnimate();
	AnimateOff();
	 RemapDir *remap = NewRemapDir(); 
	 Control *oldtm=node->GetTMController(),*nxttm;
	 nxttm = (Control *)oldtm->Clone(*remap);
	 remap->DeleteThis();
	ReplaceReference(which+2,nxttm);
	if (which)
	{ //theHold.Put(new CreateDistref(bo,node));
	  int c1=0,c2=0;
	  if (orignode)
	  {	if (orignode->GetMtl() && node->GetMtl()) 
	    { if (orignode->GetMtl()!=node->GetMtl()) 
		  {	Mtl *multi = CMaterials(orignode->GetMtl(), node->GetMtl(), c1, c2);
			orignode->SetMtl(multi);
		   (*canUndo)=FALSE;
		  }
	    }
		else if (node->GetMtl()) orignode->SetMtl(node->GetMtl());
	  }
	  firstmtls=c1;secondmtls=c2;
	}
	SetXFormPacket pckt(oppTm,boolTm);
    if (which) tm2->SetValue(0,&pckt);
	else tm1->SetValue(0,&pckt);
	ResumeAnimate();
	if (delnode) ip->DeleteNode(node);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	theHold.Accept(GetString(IDS_AP_PICKDISTOBJ));
	ivalid.SetEmpty();
}		

Object *PScatterObject::GetPipeObj(TimeValue t,int which)
	{
	ObjectState os;
	if (which==0) {
		if (ob1) {
			os = ob1->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
	} else {
		if (ob2) {
			os = ob2->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
		}
	return os.obj;
	}

Matrix3 PScatterObject::GetOpTM(TimeValue t,int which,Interval *iv)
	{
	Matrix3 tm(1);
	Interval valid, *v;
	if (iv) v = iv;
	else v = &valid;

	if (which==0) {
		if (tm1) {
			tm1->GetValue(t,&tm,*v,CTRL_RELATIVE);
			}
	} else {
		if (tm2) {
			tm2->GetValue(t,&tm,*v,CTRL_RELATIVE);
			}
		}
	return tm;
	}

int PScatterObject::RenderBegin(TimeValue t, ULONG flags)
	{
	SetFlag(PSCAT_INRENDER);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;
	}

int PScatterObject::RenderEnd(TimeValue t)
	{
	ivalid.SetEmpty();
	ClearFlag(PSCAT_INRENDER);	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return 0;
	}

void PScatterObject::Init(int total)
	{
	}

BOOL PScatterObject::Progress(int p)
	{
	SHORT res = GetAsyncKeyState(VK_ESCAPE);
	if (res&1) {
		return FALSE;
		}
	else return TRUE;
	}
#define LOTSOFACES	2000
void MakeProxy(Point3 *invlst,Face *inflst,Box3 inbox)
{	 float Dy=inbox.pmax.y-inbox.pmin.y,Dy125=0.125f*Dy,Ay=(inbox.pmax.y+inbox.pmin.y)/2.0f;
	 float Dx=inbox.pmax.x-inbox.pmin.x,Dx25=0.25f*Dx,Ax=(inbox.pmax.x+inbox.pmin.x)/2.0f;
	 invlst[0]=Point3(inbox.pmax.x,inbox.pmin.y,inbox.pmin.z);
	 invlst[1]=Point3(inbox.pmax.x,inbox.pmax.y,inbox.pmin.z);
	 invlst[2]=Point3(inbox.pmin.x,inbox.pmax.y,inbox.pmin.z);
	 invlst[3]=Point3(inbox.pmin.x,inbox.pmin.y,inbox.pmin.z);
	 invlst[4]=Point3(Ax+Dx25,Ay-Dy125,inbox.pmax.z);
	 invlst[5]=Point3(Ax+Dx25,Ay+Dy125,inbox.pmax.z);
	 invlst[6]=Point3(Ax-Dx25,Ay+Dy125,inbox.pmax.z);
	 invlst[7]=Point3(Ax-Dx25,Ay-Dy125,inbox.pmax.z);
	 inflst[0].setVerts(0,1,5);
	 inflst[0].setEdgeVisFlags(1,1,0);
	 inflst[0].setSmGroup(2);
	 inflst[1].setVerts(0,5,4);
	 inflst[1].setEdgeVisFlags(0,1,1);
	 inflst[1].setSmGroup(2);
	 inflst[2].setVerts(1,2,6);
	 inflst[2].setEdgeVisFlags(1,1,0);
	 inflst[2].setSmGroup(4);
	 inflst[3].setVerts(1,6,5);
	 inflst[3].setEdgeVisFlags(0,1,1);
	 inflst[3].setSmGroup(4);
	 inflst[4].setVerts(2,3,7);
	 inflst[4].setEdgeVisFlags(1,1,0);
	 inflst[4].setSmGroup(2);
	 inflst[5].setVerts(2,7,6);
	 inflst[5].setEdgeVisFlags(0,1,1);
	 inflst[5].setSmGroup(2);
	 inflst[6].setVerts(3,0,4);
	 inflst[6].setEdgeVisFlags(1,1,0);
	 inflst[6].setSmGroup(4);
	 inflst[7].setVerts(3,4,7);
	 inflst[7].setEdgeVisFlags(0,1,1);
	 inflst[7].setSmGroup(4);
	 inflst[8].setVerts(0,3,2);
	 inflst[8].setEdgeVisFlags(1,1,0);
	 inflst[8].setSmGroup(1);
	 inflst[9].setVerts(0,2,1);
	 inflst[9].setEdgeVisFlags(0,1,1);
	 inflst[9].setSmGroup(1);
	 inflst[10].setVerts(4,5,6);
	 inflst[10].setEdgeVisFlags(1,1,0);
	 inflst[10].setSmGroup(1);
	 inflst[11].setVerts(4,6,7);
	 inflst[11].setEdgeVisFlags(0,1,1);
	 inflst[11].setSmGroup(1);
}
void PScatterObject::GetPosInfo(int x,int y,int z,int sx,int sy,int sz,float *rotx,float *roty,float *rotz,TimeValue t)
{   pblock->GetValue(x,t,*rotx,ivalid);
	pblock->GetValue(y,t,*roty,ivalid);
	pblock->GetValue(z,t,*rotz,ivalid);
	if (!(flags&sx))
	  *rotx=(flags&sy?*roty:*rotz);
	if (!(flags&sy))
	  *roty=(flags&sx?*rotx:*rotz);
	if (!(flags&sz))
	  *rotz=(flags&sx?*rotx:*roty);
	}
typedef Mesh* mp;
typedef struct
{ mp MeshPtr;
  int vertsoff,prevs;
  int *pmv;
}MeshPtrinfo;
typedef struct
{ int meshnum,count;
  TimeValue t;
} Meshinfo;

int __cdecl timesort( const void *arg1, const void *arg2 )
{  TimeValue v1=((Meshinfo *)arg1)->t,v2=((Meshinfo *)arg2)->t;
	if (v1<v2) return 1;
	if (v1==v2) return 0;
	return -1;
}

BOOL PScatterObject::UpdateMesh(TimeValue t,BOOL force,BOOL sel)
{
  Point3 Zero=Point3(0.0f,0.0f,0.0f);
  SavePt *center;
  int seed,vertexnum=0,face=0,dverts,dfaces,dtv,inrend=TestFlag(PSCAT_INRENDER); 
  int cnum=0;
  if ((!ivalid.InInterval(t))||force)
  { ivalid = FOREVER;
	BOOL needsDel1, needsDel2;

    pblock->GetValue(PB_RANDOMSEED,0,seed,FOREVER);
	TriObject *tob1, *tob2;
	tob1 = GetTriObject(t,ob1,ivalid,needsDel1);
	tob2 = GetTriObject(t,ob2,ivalid,needsDel2);
	Matrix3 mat1;mat1.IdentityMatrix();
	int number,dmeth,mperp,numcopies=0;
	int inverts,infaces,hdist;
	TimeValue anioff=0;
	pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
    srand(seed);
	float bscale;
	pblock->GetValue(PB_DISTMETHOD,0,dmeth,FOREVER);
	pblock->GetValue(PB_NUMBER,t,number,ivalid); 
	if (number < 0) number = 0;
	pblock->GetValue(PB_BASESCALE,t,bscale,ivalid);
	pblock->GetValue(PB_MAKEPERP,t,mperp,ivalid);
	numcopies=number;
	center=NULL;
	BOOL dnotV=dmeth;
	if (tob1)
	{ ob1verts=tob1->GetMesh().getNumVerts();
	  ob1faces=tob1->GetMesh().getNumFaces();
	} else {ob1verts=0;ob1faces=0;}
 	pblock->GetValue(PB_ANIOFF,0,anioff,ivalid);
	if (dmeth)
	{ if (tob1 && tob2) 
	  {/*		HCURSOR hCur;
		if (faces > LOTSOFACES) hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
		GetAsyncKeyState(VK_ESCAPE);  */
		mat1 = GetOpTM(t,1,&ivalid);
		int scatby,nfaces,dsfaces;
	    dverts=inverts=tob2->GetMesh().getNumVerts();
	    dfaces=infaces=tob2->GetMesh().getNumFaces();
		if (hdist){ dverts=0;dfaces=0;dtv=-1;}
		dtv=tob2->GetMesh().getNumTVerts();
		Face *flst;
		pblock->GetValue(PB_DOONSELFACES,t,dsfaces,ivalid);
		pblock->GetValue(PB_DISTMETHOD2,0,scatby,FOREVER);
		if (scatby==VOLUME)
		{ if (infaces==0) numcopies=0;
		  else
		  { Point3 *fnorms=NULL;
		    int nf=tob2->GetMesh().getNumFaces();
			fnorms=new Point3[nf];
			Point3 v1;
			Face *face=tob2->GetMesh().faces;
			for (int fi=0; fi<nf; fi++) 
			{ v1 = tob2->GetMesh().verts[face[fi].v[1]];
			  fnorms[fi] = Normalize((v1-tob2->GetMesh().verts[face[fi].v[0]])^(tob2->GetMesh().verts[face[fi].v[2]]-v1));
			}
			center=new SavePt[numcopies];
		    Box3 bbox=tob2->GetMesh().getBoundingBox();
		    Point3 box=bbox.pmax-bbox.pmin;
		    if ((box.x<EPSILON)||(box.y<EPSILON)||(box.z<EPSILON)) //emitter volume isn't
			  FillByNoVolume(&(tob2->GetMesh()),numcopies,center,bbox,box);
		    else //assume we have a logically arranged mesh
			  FillByVolume(&(tob2->GetMesh()),numcopies,center,bbox,box,fnorms);
			if (fnorms) delete[] fnorms;
			for (int i=0;i<numcopies;i++)
			{ center[i].pt=center[i].pt*mat1;
			  center[i].norm=ZNorm;
			  center[i].x=XNorm;
			}
			dnotV=0;
		  }
//		  dverts=0;dfaces=0;dtv=-1;
		}
		else
		{ BOOL makevlst=(scatby==VERTICES);
		  int svlst=inverts;
		  if (dsfaces)
		  { flst=new Face[infaces];
		    assert(flst);
		    int sface=infaces;infaces=0;
		    for (int fcnt=0;fcnt<sface;fcnt++)
			{ if (tob2->GetMesh().faceSel[fcnt])
		        flst[infaces++]=tob2->GetMesh().faces[fcnt];
			}
		    if (infaces==0) {svlst=0;numcopies=0;}
		    else if (makevlst)
			{ int face=0;svlst=0;
		      for (int vcnt=0;vcnt<inverts;vcnt++)
			  { face=0;
			    if (VertexinWhichFace(vcnt,flst,infaces,&face))
			      svlst++;
			  }
			}
		  }
		 else
		  flst=tob2->GetMesh().faces;
		  Point3 *vlst;
		  vlst=new Point3[inverts];
		  assert(vlst);
		  for (int iv=0;iv<inverts;iv++)
		    vlst[iv]=tob2->GetMesh().verts[iv]*mat1;
		  pblock->GetValue(PB_EVERYNFACES,t,nfaces,ivalid);
		  fEdge *edgelst;
		  if (scatby==VERTICES) numcopies=svlst;
		  else if (scatby==FCENTER) numcopies=infaces;
		  else if (scatby==ECENTER)
		  { if ((infaces==0)||(svlst==0)) numcopies=0;
		    else
			{ int i,numedges=3*infaces;
		      numcopies=0;
		      assert((edgelst=new fEdge[numedges])!=NULL);
	          for (i=0;i<infaces;i++)
			    GetEdgeArea(flst,vlst,NULL,edgelst,&numcopies,i);
		      if ((numcopies==0)&&(edgelst)) delete[] edgelst;
			}
		  }
		  else if ((infaces==0)||(inverts==0)) numcopies=0;
		  if (numcopies>0)
		  {	center=new SavePt[numcopies];
			if (scatby==VERTICES) FillInVertex(inverts,infaces,flst,vlst,&center[0]);
			else if (scatby==FCENTER) FillInFaces(infaces,inverts,flst,vlst,&center[0]);
			else if (scatby==EDGES) FillByEdges(infaces,number,flst,vlst,&center[0]);
			else if (scatby==ECENTER) FillEdgeCenter(numcopies,edgelst,vlst,&center[0]);
			else if (scatby==UNIFORM) FillInUniform(infaces,number,flst,vlst,&center[0]);
			else if (scatby==NFACES)  FillByXFaces(infaces,number,flst,vlst,&center[0],nfaces,0);
			else FillByXFaces(infaces,number,flst,vlst,center,(int)((float)infaces/numcopies),scatby!=EVEN);
//			if (faces > LOTSOFACES) SetCursor(hCur);
		  }
		  if (dsfaces) { if (flst) delete[] flst; }
		  if (vlst) delete[] vlst;
		}
		}
	  else 
	  { mesh.DeepCopy(&tob1->GetMesh(), GEOM_CHANNEL|TOPO_CHANNEL|TEXMAP_CHANNEL|DISP_ATTRIB_CHANNEL);
	    mesh.InvalidateGeomCache(); 
	    if (needsDel1) tob1->DeleteThis();
	    return ivalid.InInterval(t);
	  }
	}
	else
	{ center=new SavePt[numcopies];
	  for (int i=0;i<numcopies;i++)
	    center[i].pt=Zero;
	  dverts=0;dfaces=0;dtv=-1;
	}
	float anirange=0;
	int oneframe=GetTicksPerFrame();
	if (anioff>0)
	{ 
	  anirange=(float)anioff/oneframe;
	}
	BOOL Proxy,showless;	
	int intvs=0, tvcount=0,dmesh,allcopies=numcopies;
	float dpercent;
	pblock->GetValue(PB_DISPLAYMETHOD,t,dmesh,ivalid);
	pblock->GetValue(PB_DISPLAYPORTION,t,dpercent,ivalid);
	showless=(!inrend)&&(dpercent<1.0f);
	Proxy=((dmesh==0)&&(!inrend));
	float offby=0.0f,ob;
	int skipby=1;
	if ((numcopies>0)&&(showless) )
	{ if (dpercent==0.0f) numcopies=0;
	  else {
	  skipby=(int)(ob=1.0f/dpercent)+1;
	  ob=ob+1-skipby;
	  numcopies=1+(int)(numcopies-1)/skipby;
	  offby=(dpercent*allcopies-numcopies)/(float)numcopies;
	  }
	}
	int tverts=0,tottvs=0,totfaces=0;
	MeshPtrinfo *meshlst=NULL;
	Meshinfo *anistuff=NULL;
	int *mnum=NULL,vertsoff=0;
    int tob1map=0,tob2map=0,totalmaps=0;
	totalmaps=nummaps(tob1,tob2,hdist,tob1map,tob2map,Proxy);
	int *maplst=(tob1map?new int[tob1map]:NULL);
	int *mtob1=(tob1map?new int[tob1map]:NULL);
	int *mtob2=(tob2map?new int[tob2map]:NULL);
	int *mapvcnt=(tob1map?new int[tob1map]:NULL);
	int mcnt1=2,mcnt2=2;
	for (int mx=2;((mcnt1<tob1map)||(mcnt2<tob2map))&&(mx<mmap);mx++)
	{ if (tob1->GetMesh().mapSupport(mx)) 
			{mtob1[mcnt1]=mx;mcnt1++;}
	  if (tob2->GetMesh().mapSupport(mx)) 
			{mtob2[mcnt2]=mx;mcnt2++;}
	}
	for (int ml=0;ml<tob1map;ml++) maplst[ml]=0;
	if (numcopies>0)
	{ int holdrnd=rand();
	  mnum=new int[numcopies];assert(mnum);memset(mnum,0,numcopies*sizeof(int));
	  srand(seed);
	  if (anioff==0) 
	  { if (Proxy)
		{ vertsoff=tob1->GetMesh().getNumVerts()-8;inverts=8;infaces=12;intvs=0;}
	    else
		{ inverts=tob1->GetMesh().getNumVerts();
	      infaces=tob1->GetMesh().getNumFaces();
	      intvs=tob1->GetMesh().getNumTVerts();
	      vertsoff=8-tob1->GetMesh().getNumVerts();
		  for (ml=2;ml<tob1map;ml++) maplst[ml]=tob1->GetMesh().getNumMapVerts(mtob1[ml]);
		}
	    tverts=(numcopies*inverts);
	    totfaces=(numcopies*infaces);
	  }
	  else
	  { anistuff=new Meshinfo[allcopies];assert(anistuff);
	    int next=0,numcount=0;
	    for (int i=0;i<allcopies;i++)
		{ TimeValue newt=t+((TimeValue)(anirange*RND11())*oneframe);
		  if (i==next)
		  { BOOL found=FALSE;
		  	for (int j=0;(!found)&&(j<cnum);j++) 
			{ if (newt==anistuff[j].t) {found=TRUE;mnum[numcount]=j;anistuff[j].count++;}}
			if (!found) {anistuff[cnum].meshnum=cnum;anistuff[cnum].t=newt;anistuff[j].count=1;mnum[numcount]=cnum;cnum++;}
		    next+=skipby;numcount++;
		  }
		}
		qsort(anistuff,cnum,sizeof(Meshinfo),timesort);
	    meshlst=new MeshPtrinfo[cnum];assert(meshlst);BOOL needsDel;int last=0,texverts=0;
		for (i=0;i<cnum;i++)
		{ int numvs=8,numfs=12,numtvs=0;
/*		  iszero=-1;
		  if (anistuff[i].t==t) 
		  { iszero=anistuff[i].meshnum;
		    meshlst[anistuff[i].meshnum].MeshPtr=&tob1->GetMesh();
			if (!Proxy) 
			{ numvs=tob1->GetMesh().getNumVerts();numfs=tob1->GetMesh().getNumFaces();
			  numtvs=tob1->GetMesh().getNumTVerts();
			}
		  }
		  else*/
		  for (ml=2;ml<tob1map;ml++)
		  {	if (ml==2) meshlst[anistuff[i].meshnum].pmv[ml]=maplst[ml];
		    else meshlst[anistuff[i].meshnum].pmv[ml]+=maplst[ml];
		  }
		  { TriObject *tri=GetTriObject(anistuff[i].t,ob1,ivalid,needsDel);
		    meshlst[anistuff[i].meshnum].MeshPtr=new Mesh;
			if (Proxy)
			{ Box3 inbox=tri->GetMesh().getBoundingBox();
			  meshlst[anistuff[i].meshnum].vertsoff=8-tri->GetMesh().getNumVerts();
			  meshlst[anistuff[i].meshnum].MeshPtr->setNumVerts(8);
			  meshlst[anistuff[i].meshnum].MeshPtr->setNumFaces(12);
			  MakeProxy(meshlst[anistuff[i].meshnum].MeshPtr->verts,meshlst[anistuff[i].meshnum].MeshPtr->faces,inbox);
	          if (needsDel) tri->DeleteThis();
			}
			else
			{ meshlst[anistuff[i].meshnum].MeshPtr->DeepCopy(&tri->GetMesh(), GEOM_CHANNEL|TOPO_CHANNEL|TEXMAP_CHANNEL|DISP_ATTRIB_CHANNEL);
			  numvs=meshlst[anistuff[i].meshnum].MeshPtr->getNumVerts();
			  numfs=meshlst[anistuff[i].meshnum].MeshPtr->getNumFaces();
			  meshlst[anistuff[i].meshnum].vertsoff=numvs-8;
			  Point3 *vlst=meshlst[anistuff[i].meshnum].MeshPtr->verts;
			  for (int k=0;k<numvs;k++) vlst[k]=vlst[k]*bscale;
	          if (needsDel) tri->DeleteThis();
		      intvs+=(numtvs=meshlst[anistuff[i].meshnum].MeshPtr->getNumTVerts());
		      for (ml=2;ml<tob1map;ml++) maplst[ml]+=meshlst[anistuff[i].meshnum].MeshPtr->getNumMapVerts(mtob1[ml]);
			}
		  }
		  tverts+=numvs*anistuff[i].count;
		  totfaces+=numfs*anistuff[i].count;
		  meshlst[anistuff[i].meshnum].prevs=texverts;
		  texverts+=numtvs;
		}
	   tob1 = GetTriObject(t,ob1,ivalid,needsDel1);
	  }
	  srand(holdrnd);
	}
	tottvs=intvs+(dtv>0?dtv:0);
	ob1verts=tverts;ob1faces=totfaces;
	totfaces+=dfaces;
	mesh.setNumVerts(tverts+dverts);
	mesh.setNumFaces(totfaces);
	BOOL tvs=(((numcopies>0)&&(intvs>0))||(dtv>0));
	if ((tvs)&&((intvs==0)||(dtv==0))) tottvs++;
	mesh.setNumTVerts(tottvs);
	mesh.setNumTVFaces(tvs?totfaces:0);
	mesh.setNumMaps(totalmaps);
	int chnum=2,lastm=2;
	int t1f=totfaces-dfaces;
    for (ml=2;ml<tob1map;ml++)
	{ mesh.setMapSupport (ml, TRUE);
	  mesh.setNumMapFaces(ml, totfaces);
	  mesh.setNumMapVerts(ml,maplst[ml]+1);
	  mesh.setMapVert(ml,maplst[ml],Zero);
	  TVFace *nmapf = mesh.mapFaces(ml);	 
	  TVFace defface(maplst[ml],maplst[ml],maplst[ml]);
	  for (int mv=t1f;mv<totfaces;mv++) nmapf[mv]=defface;
	} if (chnum<tob1map) chnum=tob1map;
    for (ml=chnum;ml<totalmaps;ml++)
	{ mesh.setMapSupport (ml, TRUE);
	  mesh.setNumMapFaces(ml, totfaces);
	  Mesh *m1=&(tob2->GetMesh());int c=mtob2[lastm];
	  UVVert *mapv = m1->mapVerts(c);
	  int vnum=m1->getNumMapVerts(c);
	  mesh.setNumMapVerts(ml,vnum+1);
	  mesh.setMapVert(ml,vnum,Zero);
	  for (int mv=0;mv<vnum;mv++)
		  mesh.setMapVert(ml,mv,mapv[mv]);
	  TVFace *mapf = m1->mapFaces(c);TVFace *nmapf = mesh.mapFaces(ml);
	  int t1f=totfaces-dfaces;
	  TVFace defface(vnum,vnum,vnum);
	  for (mv=0;mv<t1f;mv++) nmapf[mv]=defface;
	  int old=0;
	  for (mv=t1f;mv<totfaces;mv++)
	  {	  nmapf[mv]=mapf[old];old++;}
	  lastm++;
	}
	face=0;
	int addvert=0,i;
	if (numcopies>0)
	{ Point3 *tmpvs=NULL,*invlst=NULL;
	  Face *inflst=NULL;
  	  int inob1=inverts;
	  if (anioff==0)
	  { tmpvs=new Point3[inverts];
	    if (Proxy) 
		{ invlst=new Point3[inverts];
	      inflst=new Face[infaces];
	      Box3 inbox=tob1->GetMesh().getBoundingBox();
	      MakeProxy(invlst,inflst,inbox);
		}
	    else {invlst=tob1->GetMesh().verts;inflst=tob1->GetMesh().faces;}
		for (int i=0;i<inob1;i++)
		  tmpvs[i]=invlst[i]*bscale;
	  }
	float scalex,scaley,scalez;
	int slockon;
	pblock->GetValue(PB_ASPECTLOCK,0,slockon,FOREVER);
   	float vchaos;
	pblock->GetValue(PB_VERTEXCHAOS,t,vchaos,ivalid);
   	float rotx,rotz,roty,tranx,trany,tranz,tranfx,tranfy,tranfz,bscalex,bscaley,bscalez;
	GetPosInfo(PB_ROTX,PB_ROTY,PB_ROTZ,PSCAT_ROTX,PSCAT_ROTY,PSCAT_ROTZ,&rotx,&roty,&rotz,t);
	rotx*=PIOver180;roty*=PIOver180;rotz*=PIOver180;
	GetPosInfo(PB_TRANX,PB_TRANY,PB_TRANZ,PSCAT_TRANX,PSCAT_TRANY,PSCAT_TRANZ,&tranx,&trany,&tranz,t);
	GetPosInfo(PB_TRANFX,PB_TRANFY,PB_TRANFZ,PSCAT_TRANFX,PSCAT_TRANFY,PSCAT_TRANFZ,&tranfx,&tranfy,&tranfz,t);
	GetPosInfo(PB_SCALEX,PB_SCALEY,PB_SCALEZ,PSCAT_SCALEX,PSCAT_SCALEY,PSCAT_SCALEZ,&bscalex,&bscaley,&bscalez,t);
	bscalex*=0.01f;
	bscaley*=0.01f;
	bscalez*=0.01f;
	int curcopy=0;
	float cumerr=0.0f;
	Point3 *curverts=tmpvs;int ncount=0;
	int evenuprnd=vertsoff;
	while (curcopy<allcopies)
	{ float tmpsave=RND11();
	  if (cnum>0)
	  { curverts=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr->verts;
	    inob1=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr->getNumVerts();
	  }
	  else {curverts=tmpvs;inob1=inverts;}
	  if (anioff>0) evenuprnd=meshlst[anistuff[mnum[ncount]].meshnum].vertsoff;
	  ncount++;
	  scalex=1.0f+bscalex*tmpsave;
	  if (slockon) 
	  { scaley=(scalez=scalex);RND11();RND11();}
	  else
	  { scaley=1.0f+bscaley*RND11();
	    scalez=1.0f+bscalez*RND11();
	  }
	  float alpha,beta,gamma,calpha,cbeta,cgamma,salpha,sbeta,sgamma;
	  calpha=(float)cos(alpha=RND11()*rotx);salpha=(float)sin(alpha);
	  cbeta=(float)cos(beta=RND11()*roty); sbeta=(float)sin(beta);
	  cgamma=(float)cos(gamma=RND11()*rotz);sgamma=(float)sin(gamma);
	  Matrix4By4 rotmat;
	  rotmat[0][0]=cbeta*cgamma;
	  rotmat[0][1]=salpha*sbeta*cgamma-calpha*sgamma;
	  rotmat[0][2]=calpha*sbeta*cgamma+salpha*sgamma;
	  rotmat[0][3]=RND11()*tranx;
	  rotmat[1][3]=RND11()*trany;
	  rotmat[2][3]=RND11()*tranz;
	  rotmat[3][0]=rotmat[3][1]=rotmat[3][2]=0.0f;
	  rotmat[3][3]=1.0f;
	  rotmat[1][0]=cbeta*sgamma;
	  rotmat[1][1]=salpha*sbeta*sgamma+calpha*cgamma;
	  rotmat[1][2]=calpha*sbeta*sgamma-salpha*cgamma;
	  rotmat[2][0]=-sbeta;
	  rotmat[2][1]=salpha*cbeta;
	  rotmat[2][2]=calpha*cbeta;
	  Point3 y;
	  Matrix4By4 omat;
	  if (dmeth) y=Normalize(center[curcopy].norm^center[curcopy].x);
	  if (dmeth && mperp)
	  {	omat[0][0]=center[curcopy].x[0];
	    omat[1][0]=center[curcopy].x[1];
		omat[2][0]=center[curcopy].x[2];
		omat[0][1]=y[0];omat[1][1]=y[1];omat[2][1]=y[2];
		omat[0][2]=center[curcopy].norm[0];
		omat[1][2]=center[curcopy].norm[1];
		omat[2][2]=center[curcopy].norm[2];
		omat[0][3]=center[curcopy].pt.x;
		omat[1][3]=center[curcopy].pt.y;
		omat[2][3]=center[curcopy].pt.z;
		omat[3][0]=omat[3][1]=omat[3][2]=0.0f;omat[3][3]=1.0f;
	  }
	  Point3 offset;
	  if (dmeth) offset=center[curcopy].x*RND11()*tranfx+y*RND11()*tranfy+center[curcopy].norm*RND11()*tranfz;
	  for (int i=0;i<inob1;i++)
	  { mesh.verts[vertexnum].x=curverts[i].x*scalex+RND11()*vchaos;
	    mesh.verts[vertexnum].y=curverts[i].y*scaley+RND11()*vchaos;
	    mesh.verts[vertexnum].z=curverts[i].z*scalez+RND11()*vchaos;
	    Mult4XPoint(&mesh.verts[vertexnum],rotmat);
	    if (dmeth && mperp)
	    { Mult4XPoint(&mesh.verts[vertexnum],omat);
	    } else {mesh.verts[vertexnum]+=center[curcopy].pt;}
	    if (dmeth)
	      mesh.verts[vertexnum]+=offset;
	    vertexnum++;
	  }
	  for (int evn=0;evn<evenuprnd;evn++)
	  { rand();rand();rand(); }
	  curcopy+=skipby;cumerr=cumerr+offby;
	}
	if (tmpvs) delete[] tmpvs;
	int j=0,cvs=0;
	if (center) delete[] center;
	ncount=0;
	while (j<allcopies)
	{ int curf;Face *flst;
	  if (cnum>0)
	  { flst=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr->faces;
	    curf=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr->getNumFaces();
		cvs=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr->getNumVerts();
	  }
	  else {flst=inflst;curf=infaces;cvs=inverts;}
	  for (i=0;i<curf;i++)
	  { memcpy(&mesh.faces[face],&flst[i],sizeof(Face));
	    if (firstmtls==1) mesh.faces[face].setMatID(0);
		mesh.faces[face].v[0]+=addvert;
		mesh.faces[face].v[1]+=addvert;
		mesh.faces[face].v[2]+=addvert;
	    if (tvs) 
		{ if (intvs>0)
		  { if (cnum>0)
			{ Mesh *m=meshlst[anistuff[mnum[ncount]].meshnum].MeshPtr;
			  TVFace tvf=m->tvFace[i];
			  int prevs=meshlst[anistuff[mnum[ncount]].meshnum].prevs;
			  mesh.tvFace[face].setTVerts(tvf.t[0]+prevs,tvf.t[1]+prevs,tvf.t[2]+prevs);		  
			  for (int mv=2;mv<tob1map;mv++)
			  { TVFace mtvf=m->mapFaces(mtob1[mv])[i];
			    prevs=meshlst[anistuff[mnum[ncount]].meshnum].pmv[mv];
			    mesh.mapFaces(mv)[face]=TVFace(mtvf.t[1]+prevs,mtvf.t[1]+prevs,mtvf.t[2]+prevs);
			  }
			}
			else 
			{ for (int mv=2;mv<tob1map;mv++)
			    mesh.mapFaces(mv)[face]=tob1->GetMesh().mapFaces(mtob1[mv])[i];
			  mesh.tvFace[face]=tob1->GetMesh().tvFace[i];
			}
		  }	
		  else mesh.tvFace[face].setTVerts(dtv,dtv,dtv);
		}
		face++;
	  }
	  addvert+=cvs;
	  j+=skipby;ncount++;
	}
	if (Proxy) 
	{ if (inflst) delete[] inflst;
	  if (invlst) delete[] invlst;
	}
	tvcount=intvs;
	if (intvs>0)
	{ if (cnum==0)
	  { for (i=0;i<intvs;i++)
		  mesh.tVerts[i]=tob1->GetMesh().tVerts[i];
	    for (j=2;j<tob1map;j++)
		{ int c=mtob1[j];UVVert *mapv = tob1->GetMesh().mapVerts(c);
		  for (i=0;i<tob1->GetMesh().getNumMapVerts(c);i++)
			mesh.setMapVert(j,i,mapv[i]);
		}
	  }
	  else
	  { tvcount=0;for (j=2;j<tob1map;j++) mapvcnt[j]=0;
		for (i=0;i<cnum;i++)
		{ for (j=0;j<meshlst[anistuff[i].meshnum].MeshPtr->getNumTVerts();j++)
		  { mesh.tVerts[tvcount]=meshlst[anistuff[i].meshnum].MeshPtr->tVerts[j];
		    tvcount++;
		  }
		  for (j=2;j<tob1map;j++)
		  { Mesh *m=meshlst[anistuff[i].meshnum].MeshPtr;int c=mtob1[j];
			UVVert *mapv = m->mapVerts(c);
		    for (i=0;i<m->getNumMapVerts(c);i++)
			{ mesh.setMapVert(j,mapvcnt[j],mapv[i]);(mapvcnt[j])++;}
		  }
		}
	  }
	}
	if (tvs)
	{ if (intvs==0) {mesh.tVerts[dtv]=Zero;}
	  else if (dtv==0) mesh.tVerts[tvcount]=Zero;}
	} else tvcount=0;
	for (i=0;i<dtv;i++)
	  mesh.tVerts[i+tvcount]=tob2->GetMesh().tVerts[i];
	if ((tob2)&&(!hdist))
	{ for (i=0;i<dverts;i++)
	    mesh.verts[vertexnum++]=tob2->GetMesh().verts[i]*mat1;
	  for (i=0;i<dfaces;i++)
	  {	memcpy(&mesh.faces[face],&tob2->GetMesh().faces[i],sizeof(Face));
		mesh.faces[face].v[0]+=addvert;
		mesh.faces[face].v[1]+=addvert;
		mesh.faces[face].v[2]+=addvert;
		mesh.faces[face].setMatID(firstmtls+(secondmtls==1?0:tob2->GetMesh().faces[i].getMatID()));		
	    if (tvs) 
		{ if (dtv>0) mesh.tvFace[face].setTVerts(tob2->GetMesh().tvFace[i].t[0]+tvcount,tob2->GetMesh().tvFace[i].t[1]+tvcount,tob2->GetMesh().tvFace[i].t[2]+tvcount);
		  else mesh.tvFace[face].setTVerts(tvcount,tvcount,tvcount);
		}
		face++;
	  }
	}
	if (maplst) delete[] maplst;if (mapvcnt) delete[] mapvcnt;
	if (mtob1) delete[] mtob1;if (mtob2) delete[] mtob2;
	for (i=0;i<cnum;i++) delete meshlst[i].MeshPtr;
	if (meshlst) delete[] meshlst;
	if (anistuff) delete[] anistuff;
	if (mnum) delete[] mnum;
	if (needsDel1) tob1->DeleteThis();
	if (needsDel2) tob2->DeleteThis();
	mesh.InvalidateGeomCache(); 
  } 
  else 
  { if (!ivalid.InInterval(t)) 
    {	ivalid.SetInstant(t); }
  }
  return ivalid.InInterval(t);
}

Interval PScatterObject::ObjectValidity(TimeValue t)
	{ 
	UpdateMesh(t);
	if (ivalid.Empty()) return Interval(t,t);
	else return ivalid;
	}

int PScatterObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 || ob2) return 1;
		else return 0;
	}
	return Object::CanConvertToType(obtype);
/*	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 && ob2) return 1;
		else if (ob1) return ob1->CanConvertToType(obtype);
		else if (ob2) return ob2->CanConvertToType(obtype);
		else return 0;
		}*/
	return Object::CanConvertToType(obtype);
	}

Object* PScatterObject::ConvertToType(TimeValue t, Class_ID obtype)
{/*	int dmeth;pblock->GetValue(PB_DISTMETHOD,0,dmeth,FOREVER);
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 && (ob2 ||(!dmeth))) {
			TriObject *triob;
			UpdateMesh(t);
			triob = CreateNewTriObject();
			triob->GetMesh() = mesh;
			triob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
			triob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
			return triob;
		} else {
			// RB 4-11-96:
			// There was a bug where if one of the operands was a tri-object
			// it would convert itself to a tri-object by just returning itself (as it should)
			// The problem is that there are places in the system where the
			// the system would think it needed to delete the tri-object
			// becuase it was not equal to the boolean object. In other words,
			// it thinks that the boolean convert itself to a tri-object and
			// therefore the tri-object was a temporary object.
			// So what this code does is clone the tri-object in this case
			// so that the boolean object will always return a temporary
			// object.
			Object *obj = NULL;
			if (ob1) {
				obj = ob1->ConvertToType(t,obtype);
				if (obj && obj==ob1) {
					return (Object*)obj->Clone();
				} else {
					return obj;
					}
				}
			if (ob2) {
				obj = ob2->ConvertToType(t,obtype);
				if (obj && obj==ob2) {
					return (Object*)obj->Clone();
				} else {
					return obj;
					}
				}			
			return NULL;
			}
	} else {
		return Object::ConvertToType(t,obtype);
		}*/
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		// Since PrepForBoolean changes the mesh, we should use UpdateMesh to produce new
		// output even when there is only 1 operand.
		TriObject *triob;
		UpdateMesh(t);
		triob = CreateNewTriObject();
		triob->GetMesh() = mesh;
		triob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		triob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return triob;
	} else {
		return Object::ConvertToType(t,obtype);
	}
}

ObjectState PScatterObject::Eval(TimeValue time)
	{
	return ObjectState(this);
	}

void PScatterObject::SetExtractButtonState()
{	ICustButton *iBut = GetICustButton(GetDlgItem(hObject,IDC_SCATR_EXTRACTOP));
	if (!creating && (flags & (PSCAT_OB1SEL|PSCAT_OB2SEL))) {
		iBut->Enable();
		EnableWindow(GetDlgItem(hObject,IDC_SCATR_EXTRACT_INSTANCE),TRUE);
		EnableWindow(GetDlgItem(hObject,IDC_SCATR_EXTRACT_COPY),TRUE);
	} else {
		iBut->Disable();
		EnableWindow(GetDlgItem(hObject,IDC_SCATR_EXTRACT_INSTANCE),FALSE);
		EnableWindow(GetDlgItem(hObject,IDC_SCATR_EXTRACT_COPY),FALSE);
		}
	ReleaseICustButton(iBut);	

	CheckDlgButton(hObject,IDC_SCATR_EXTRACT_INSTANCE,!extractCopy);
	CheckDlgButton(hObject,IDC_SCATR_EXTRACT_COPY,extractCopy);
}


BOOL PickOperand::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(bo->ip->GetTime());
		if (os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}

		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL PickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) {  
	  Interval intvalid;
	  BOOL needsDel;
	  Object *tob=node->GetObjectRef();
	  TriObject *tri=GetTriObject(ip->GetTime(),tob,intvalid,needsDel);
	  if (tri==NULL) { node = NULL; return FALSE;	}
	    if (needsDel) tri->DeleteThis();
		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL PickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	int stkclr=IDYES;
	if ((bo->mainnode)&&((bo->mainnode->GetMtl() && node->GetMtl())&& (bo->mainnode->GetMtl()!=node->GetMtl())) )
	{ TSTR buf(GetString(IDS_AP_MTLMSG));
	  TSTR buf1(GetString(IDS_AP_MTLTITLE));
	  stkclr=MessageBox(NULL,buf,buf1,MB_ICONQUESTION|MB_YESNO);
	}
	if (stkclr==IDNO) return FALSE;
	Matrix3 ourTM;
	Matrix3 ntm = node->GetObjectTM(ip->GetTime());	
	INode *mainnode;
	theHold.Begin();
	theHold.Put(new CreateScatrref(bo,bo->opbName,node->GetName()));

	if (bo->creating) {
		ourTM = bo->createTM;
		mainnode=bo->mainnode;
	} else {
		if (bo->mainnode) {
			ourTM = bo->mainnode->GetObjectTM(ip->GetTime());
		} else {
			MaxAssert(0);
			ourTM.IdentityMatrix();
			}
		}

	bool canUndo = TRUE;
	bo->SetOperand(node,ourTM,ntm,1,bo->mainnode,&canUndo);	
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	bo->SetFlag(PSCAT_DISPRESULT);
	CheckRadioButton(bo->pmapObjects->GetHWnd(),IDC_PS_DISPRESULT,IDC_PS_DISPOPS,IDC_PS_DISPRESULT);
		
	bo->UpdateMesh(ip->GetTime(),TRUE);
//	bo->ShowOpList();
	
	if (bo->creating) {
		theCreatePScatMode.JumpStart(ip,bo);
		ip->SetCommandMode(&theCreatePScatMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void PickOperand::EnterMode(IObjParam *ip)
{	ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapDist->GetHWnd(),IDC_AP_PROSCATTER_OBJECTDPICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
}

void PickOperand::ExitMode(IObjParam *ip)
{ if (bo->pmapDist)
	{ ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapDist->GetHWnd(),IDC_AP_PROSCATTER_OBJECTDPICK));
	  if (iBut) iBut->SetCheck(FALSE);
	  ReleaseICustButton(iBut);
	}
}

static BOOL ReadInt(int *buf,FILE *f)
{ return(fread(buf,isize,1,f)==1);
}
static BOOL WriteInt(int *buf,FILE *f)
{ return(fwrite(buf,isize,1,f)==1);
}
BOOL GenNewSaveFile(int osize,int size,int custsettings,FILE *f,TCHAR *filename,int vers)
{ int future=0;BOOL ok=TRUE;
  fclose(f);
  if ((f = _tfopen(filename, _T("r+b"))) == NULL) return FALSE;
  ok=(WriteInt(&custsettings,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f));
 if (custsettings>0)
 { int cset=(custsettings-1),odata=osize+NLEN;
   AName Name;int ofs=(size-osize),tofs=cset*ofs;
   BYTE *data=new BYTE[size];for (int x=0;x<size;x++) data[x]=0;
   cset*=odata;cset+=HLEN;
   while (cset>=HLEN)
   { fseek(f,cset,SEEK_SET);
      if (fread(Name,NLEN,1,f)==1)
	 { if (fread(data,osize,1,f)!=1) goto badend;
       fseek(f,cset+tofs,SEEK_SET);
		if (fwrite(Name,1,NLEN,f)!=NLEN) goto badend;
	   if (fwrite(data,size,1,f)!=1) goto badend;
	 } else goto badend;
	 cset-=odata;tofs-=ofs;
   }
   delete[] data;
   rewind(f);
 }
 return ok;
badend: fclose(f);return FALSE;
 }

void PScatterObject::GetFilename(TCHAR *filename)
{   _tcscpy(filename,ip->GetDir(APP_PLUGCFG_DIR));
  int len= _tcslen(filename);
  if (len)
  {  if (filename[len-1]!=_T('\\'))
		  _tcscat(filename,_T("\\"));
  }
  _tcscat(filename,GetString(IDS_AP_PASCATCST));
}
void PScatterObject::SetupTargetList()		
	{TCHAR filename[MAX_PATH];
     FILE *f;
	 int vers,i,future,osize;

	custsettings=0;
    GetFilename(filename);
	BOOL fileok=TRUE;
	if ((f = _tfopen(filename, _T("rb"))) == NULL) return;
	if((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)))
	{ if ((vers!=CURRENT_VERSION)&&(fileok=GenNewSaveFile(osize,size,custsettings,f,filename,CURRENT_VERSION)))
		{fileok=((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)));
		}
	if (fileok&&(vers==CURRENT_VERSION))
	{ NameLst=new AName[custsettings]; 
	  for (i=0;i<custsettings;i++)
	  if (fread(NameLst[i],NLEN,1,f)==1)
	    fseek(f,size,SEEK_CUR);
	  else goto onerr;
	}}
	onerr:if (i<custsettings) 
	{ custsettings=0;
	MessageBox (NULL,GetString(IDS_RB_BADFILE),
            "", MB_ICONINFORMATION);
	}
	if (fileok) fclose(f);
	SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),LB_RESETCONTENT,0,0);
	for (i=0; i<custsettings; i++) 
	{ SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
	}
}

int PScatterObject::RemSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  long startpt;
  int vers,newsets,future=0,baselen=size+NLEN;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings-1;
  if ((f = _tfopen(filename,_T("r+b"))) == NULL) return 0;
  if (custsettings==1) 
  {fclose(f);remove(filename);custsettings=0;delete[] NameLst;NameLst=NULL;
    SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),LB_RESETCONTENT,0,0);
   return (1);}
 if (!WriteInt(&newsets,f)) {fclose(f);return 0;}
  startpt=overwrite*(baselen)+HLEN;
  fseek(f,startpt,SEEK_SET); 
  int i;
  BYTE *buf;
  buf=new BYTE[baselen];
  assert(buf);
  long cpos=startpt;
  for (i=overwrite+1;i<custsettings;i++)
  {	fseek(f,cpos+baselen,SEEK_SET);
	if (fread(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	fseek(f,cpos,SEEK_SET);
	if (fwrite(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	cpos+=baselen;
  }
  delete[] buf;
  _chsize(_fileno(f),ftell(f));
  fclose(f);								  
  AName *Tmp=new AName[custsettings-1];
  int newi=0;
  for (i=0;i<custsettings;i++)
  { if (i!=overwrite) 
      _tcscpy(Tmp[newi++],NameLst[i]);}
  delete []NameLst;NameLst=Tmp;
  custsettings--;
  SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),LB_RESETCONTENT,0,0);
  for (i=0; i<custsettings; i++) 
  {	SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);	}
  return(1);
}
int PScatterObject::SaveSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  int vers,newsets,future=0;

  if ((overwrite>-1)&&(MessageBox (NULL,GetString(IDS_AP_SETEXISTS),GetString(IDS_AP_WARNING), MB_ICONQUESTION | MB_YESNO ) == IDNO))
	 return 0;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings+1;
  if ((f = _tfopen(filename,(custsettings==0?_T("wb"):_T("r+b")))) == NULL) return 0;
  // longest one
 int plength=PBLOCK_LENGTH;
  if (custsettings==0)
  { if (!(WriteInt(&newsets,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f))) goto errend;
  } 
  else 
  { if (overwrite>=0) 
    { overwrite=overwrite*(size+NLEN)+HLEN;
      fseek(f,overwrite,SEEK_SET); }
    else 
	{ if (!WriteInt(&newsets,f)) goto errend;
	  fseek(f,0,SEEK_END);
	}
  }	 
  int ival,i;
  float fval;
  if (fwrite(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer2[i].type==TYPE_INT) 
    { pblock->GetValue(i,0,ival,FOREVER);
      if (fwrite(&ival,isize,1,f)!=1) goto errend;
	}
    else
    { pblock->GetValue(i,0,fval,FOREVER);
      if (fwrite(&fval,fsize,1,f)!=1) goto errend;
	}
  }
  fclose(f);
  if (overwrite<0) 
  { AName *Tmp=new AName[custsettings+1];
    memcpy(Tmp,NameLst,sizeof(AName)*custsettings);
	delete []NameLst;NameLst=Tmp;
    _tcscpy(NameLst[custsettings],newname);
	custsettings++;
	SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),LB_RESETCONTENT,0,0);
	for (int i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_PS_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
  }  
  return(1);
errend: fclose(f);return(0);
}
int PScatterObject::GetSettings(int setnum,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  GetFilename(filename);
  if ((f = _tfopen(filename,_T("rb"))) == NULL) return 0;
  { setnum=setnum*(size+NLEN)+HLEN;
    fseek(f,setnum,SEEK_SET); 
  }	 
  int ival,i;
  float fval;
  // longest one
  int plength=PBLOCK_LENGTH;
  if (fread(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer2[i].type==TYPE_INT) 
    { if (fread(&ival,isize,1,f)!=1) goto errend;
	  pblock->SetValue(i,0,ival);
	}
    else
    { if (fread(&fval,fsize,1,f)!=1) goto errend;
//	  if (i!=PB_EMITRWID) 
		  pblock->SetValue(i,0,fval);
	}
  }
  fclose(f);
  pmapDisplay->Invalidate();
  pmapObjects->Invalidate();
  pmapTransforms->Invalidate();
  return(1);
  errend: fclose(f);return(0);
}
void SpinnerOff(HWND hWnd,int SpinNum)
{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
  spin2->Disable();
  ReleaseISpinner(spin2);
}
void SpinnerOn(HWND hWnd,int SpinNum)
{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
  spin2->Enable();
  ReleaseISpinner(spin2);
}

void LockOuts(HWND hWnd,int flags)
{ if (!(flags &PSCAT_ROTX)) SpinnerOff(hWnd,IDC_AP_ROTXSPIN);
  if (!(flags &PSCAT_ROTY)) SpinnerOff(hWnd,IDC_AP_ROTYSPIN);
  if (!(flags &PSCAT_ROTZ)) SpinnerOff(hWnd,IDC_AP_ROTZSPIN);
  if (!(flags &PSCAT_TRANX)) SpinnerOff(hWnd,IDC_AP_TRANXSPIN);
  if (!(flags &PSCAT_TRANY)) SpinnerOff(hWnd,IDC_AP_TRANYSPIN);
  if (!(flags &PSCAT_TRANZ)) SpinnerOff(hWnd,IDC_AP_TRANZSPIN);
  if (!(flags &PSCAT_TRANFX)) SpinnerOff(hWnd,IDC_AP_TRANXFSPIN);
  if (!(flags &PSCAT_TRANFY)) SpinnerOff(hWnd,IDC_AP_TRANYFSPIN);
  if (!(flags &PSCAT_TRANFZ)) SpinnerOff(hWnd,IDC_AP_TRANZFSPIN);
  if (!(flags &PSCAT_SCALEX))	SpinnerOff(hWnd,IDC_AP_SCALEXSPIN);
  if (!(flags &PSCAT_SCALEY))	SpinnerOff(hWnd,IDC_AP_SCALEYSPIN);
  if (!(flags &PSCAT_SCALEZ))	SpinnerOff(hWnd,IDC_AP_SCALEZSPIN);
}

void DistObjectOff(PScatterObject *po,HWND hWnd)
{ EnableWindow(GetDlgItem(po->pmapDisplay->GetHWnd(),IDC_AP_HIDEDIST),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_GOPERP),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_GOSELECT),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTVOLUME),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTCENTERS),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTVERTICES),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTAREA),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTEVEN),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTNFACES),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTRANDOM),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTEDGES),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTECENTER),FALSE);
  HWND thWnd=po->pmapTransforms->GetHWnd();
  EnableWindow(GetDlgItem(thWnd,IDC_AP_TRANFLOCK),FALSE);
  SpinnerOff(thWnd,IDC_AP_TRANXFSPIN);
  SpinnerOff(thWnd,IDC_AP_TRANYFSPIN);
  SpinnerOff(thWnd,IDC_AP_TRANZFSPIN);
  HWND dhWnd=po->pmapDist->GetHWnd();
  ICustButton *iBut = GetICustButton(GetDlgItem(dhWnd,IDC_AP_PROSCATTER_OBJECTDPICK));
  if (iBut) iBut->Disable();
  ReleaseICustButton(iBut);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTREF),FALSE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTCOPY),FALSE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTMOVE),FALSE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTINST),FALSE);
}
void DistObjectOn(PScatterObject *po,HWND hWnd)
{ EnableWindow(GetDlgItem(po->pmapDisplay->GetHWnd(),IDC_AP_HIDEDIST),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_GOPERP),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_GOSELECT),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTVOLUME),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTCENTERS),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTVERTICES),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTAREA),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTEVEN),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTNFACES),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTRANDOM),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTEDGES),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DISTECENTER),TRUE);
  HWND thWnd=po->pmapTransforms->GetHWnd();
  EnableWindow(GetDlgItem(thWnd,IDC_AP_TRANFLOCK),TRUE);
  if (po->flags &PSCAT_TRANFX) SpinnerOn(po->thwnd,IDC_AP_TRANXFSPIN);else SpinnerOff(po->thwnd,IDC_AP_TRANXFSPIN);
  if (po->flags &PSCAT_TRANFY) SpinnerOn(po->thwnd,IDC_AP_TRANYFSPIN);else SpinnerOff(po->thwnd,IDC_AP_TRANYFSPIN);
  if (po->flags &PSCAT_TRANFZ) SpinnerOn(po->thwnd,IDC_AP_TRANZFSPIN);else SpinnerOff(po->thwnd,IDC_AP_TRANZFSPIN);
  HWND dhWnd=po->pmapDist->GetHWnd();
  ICustButton *iBut = GetICustButton(GetDlgItem(dhWnd,IDC_AP_PROSCATTER_OBJECTDPICK));
  if (iBut) iBut->Enable();
  ReleaseICustButton(iBut);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTREF),TRUE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTCOPY),TRUE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTMOVE),TRUE);
  EnableWindow(GetDlgItem(dhWnd,IDC_AP_DISTINST),TRUE);
}

void DistGreyOuts(PScatterObject *po,HWND hWnd,TimeValue t)
{ int dist;
  CheckDlgButton(hWnd,IDC_PS_DISPRESULT,po->TestFlag(PSCAT_DISPRESULT));
  CheckDlgButton(hWnd,IDC_PS_DISPOPS,!po->TestFlag(PSCAT_DISPRESULT));	
  po->pblock->GetValue(PB_DISTMETHOD,t,dist,FOREVER);
  if (dist) DistObjectOn(po,hWnd);
  else DistObjectOff(po,hWnd);
  po->pblock->GetValue(PB_DISTMETHOD2,t,dist,FOREVER);
  if ((dist<UNIFORM)||(dist==ECENTER)) 
	SpinnerOff(hWnd,IDC_AP_NUMBERSPIN);
  else SpinnerOn(hWnd,IDC_AP_NUMBERSPIN);
}

static BOOL CALLBACK CustomSettingParamDlgProc( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ TCHAR newname[NLEN];
  int i,save=0;
  PScatterObject *po = (PScatterObject*)GetWindowLong(hWnd,GWL_USERDATA);
  if (!po && message!=WM_INITDIALOG) return FALSE;

  switch (message) {
		case WM_INITDIALOG: {
			po = (PScatterObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			po->custCtrlEdit = GetICustEdit(GetDlgItem(hWnd,IDC_PS_SETEDIT));
			po->custCtrlEdit->SetText(_T(""));
			po->hParams2 = hWnd;
			po->SetupTargetList();
			break;
			}
		case WM_COMMAND:
			{ switch(LOWORD(wParam)) {
				case IDC_PS_SETLIST:  
					if (HIWORD(wParam)==LBN_DBLCLK)
					  goto doload;
					break;
				case IDC_PS_DELETE:  
					i = SendMessage(GetDlgItem(po->hParams2,IDC_PS_SETLIST),
							LB_GETCURSEL,0,0);
					   if (po->custsettings>0)
					   { po->custCtrlEdit->GetText(newname,NLEN);
						 if (_tcscmp(newname,po->NameLst[i])==0)
						   po->custCtrlEdit->SetText(_T(""));
					     po->RemSettings(i,po->NameLst[i]);
					   }
					break;
				case IDC_PS_SAVE:
				   save=1;
				case IDC_PS_LOAD:
					doload:
					if (!save)
					{ i = SendMessage(GetDlgItem(po->hParams2,IDC_PS_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					     po->custCtrlEdit->SetText(po->NameLst[i]);
					}
				    po->custCtrlEdit->GetText(newname,NLEN);
					if (save) 
					{int tstblk=0,tstlen=_tcslen(newname);
					  while ((tstblk<tstlen)&&(newname[tstblk]==' ')) tstblk++;
					  if (tstblk>=tstlen) 
						MessageBox (NULL,GetString(IDS_AP_NONAME),
            "", MB_ICONINFORMATION);
					  else 
					  { i=0;
					    while ((i<po->custsettings)&&(_tcscmp(newname,po->NameLst[i])))
					     i++;
						if (i>=po->custsettings) i=-1;
					    po->SaveSettings(i,newname);
					  }
					}
					else if ((i>-1)&&(i<po->custsettings))
					{ po->GetSettings(i,newname);
					  LockOuts(po->thwnd,po->flags);
					  DistGreyOuts(po,po->distwnd,po->ip->GetTime());
					  po->ip->RedrawViews(po->ip->GetTime()); 
					}
					else MessageBox (NULL,GetString(IDS_AP_BADNAME),
            "", MB_ICONINFORMATION);
					break;
				}
			break;
			}

		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustEdit(po->custCtrlEdit);
			if (po->NameLst) {delete []po->NameLst;po->NameLst=NULL;}
			return FALSE;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			po->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:	return FALSE;		
		}
	return TRUE;
	}	

class ProScatPickObj : public ParamMapUserDlgProc {
	public:
		PScatterObject *po;

		ProScatPickObj(PScatterObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ProScatPickObj::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_PROSCATTER_OBJECTDPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
		    ReleaseICustButton(iBut);
			po->ShowName(po->ob2!=NULL);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_PROSCATTER_OBJECTDPICK:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePScatMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePScatMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.bo = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
		default:
			return FALSE;
			}
			break;	
		}
	return TRUE;
}
class ProScatDispProc : public ParamMapUserDlgProc {
	public:
		PScatterObject *po;

		ProScatDispProc(PScatterObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ProScatDispProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ 	case IDC_AP_NEWSEED:
					{ srand( (unsigned)time( NULL ) );
					  int newseed=rand() % 25001;
					  po->pblock->SetValue(PB_RANDOMSEED,0,newseed);
					  po->pmapDisplay->Invalidate();
					}
			        return TRUE;
		default:
			return FALSE;
			}
			break;	
		}
	return TRUE;
}

class ProScatLockProc : public ParamMapUserDlgProc {
	public:
		PScatterObject *po;

		ProScatLockProc(PScatterObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void  ProScatLockProc::Update(TimeValue t)
{ if (!po->editOb) return;
   LockOuts(po->thwnd,po->flags);
}

BOOL ProScatLockProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{	Point3 rot;
	    int maxv;
		switch (msg) {

		case WM_INITDIALOG: {
			po->thwnd=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{
			case IDC_AP_ROTLOCK:
			{	int rlock;
			    po->pblock->GetValue(PB_ROTLOCK,t,rlock,FOREVER);
				if (rlock)
				{po->pblock->GetValue(PB_ROTX,t,rot.x,FOREVER);
			    po->pblock->GetValue(PB_ROTY,t,rot.y,FOREVER);
			    po->pblock->GetValue(PB_ROTZ,t,rot.z,FOREVER);
				maxv=MaxComponent(rot);
				if (maxv==0) 
				{ po->pblock->SetValue(PB_ROTY,t,rot.x);
				  po->pblock->SetValue(PB_ROTZ,t,rot.x);
				  SpinnerOff(hWnd,IDC_AP_ROTYSPIN);
				  SpinnerOff(hWnd,IDC_AP_ROTZSPIN);
				  po->flags &=~(PSCAT_ROTY|PSCAT_ROTZ);
				}
				else if (maxv==1) 
				{ po->pblock->SetValue(PB_ROTX,t,rot.y);
				  po->pblock->SetValue(PB_ROTZ,t,rot.y);
				  SpinnerOff(hWnd,IDC_AP_ROTXSPIN);
				  SpinnerOff(hWnd,IDC_AP_ROTZSPIN);
				  po->flags &=~(PSCAT_ROTX|PSCAT_ROTZ);
				}
				else  
				{ po->pblock->SetValue(PB_ROTX,t,rot.z);
				  po->pblock->SetValue(PB_ROTY,t,rot.z);
				  SpinnerOff(hWnd,IDC_AP_ROTXSPIN);
				  SpinnerOff(hWnd,IDC_AP_ROTYSPIN);
				  po->flags &=~(PSCAT_ROTX|PSCAT_ROTY);
				}
				} else
				{ SpinnerOn(hWnd,IDC_AP_ROTXSPIN);
				  SpinnerOn(hWnd,IDC_AP_ROTYSPIN);
				  SpinnerOn(hWnd,IDC_AP_ROTZSPIN);
				  po->flags |=(PSCAT_ROTX|PSCAT_ROTY|PSCAT_ROTZ);
				}
				po->pmapTransforms->Invalidate();
 				break;
			  }
			  case IDC_AP_TRANLOCK:
			  {	int rlock;
			    po->pblock->GetValue(PB_TRANLOCK,t,rlock,FOREVER);
				if (rlock)
				{po->pblock->GetValue(PB_TRANX,t,rot.x,FOREVER);
			    po->pblock->GetValue(PB_TRANY,t,rot.y,FOREVER);
			    po->pblock->GetValue(PB_TRANZ,t,rot.z,FOREVER);
				maxv=MaxComponent(rot);
				if (maxv==0) 
				{ po->pblock->SetValue(PB_TRANY,t,rot.x);
				  po->pblock->SetValue(PB_TRANZ,t,rot.x);
				  SpinnerOff(hWnd,IDC_AP_TRANYSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANZSPIN);
				  po->flags &=~(PSCAT_TRANY|PSCAT_TRANZ);
				}
				else if (maxv==1) 
				{ po->pblock->SetValue(PB_TRANX,t,rot.y);
				  po->pblock->SetValue(PB_TRANZ,t,rot.y);
				  SpinnerOff(hWnd,IDC_AP_TRANXSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANZSPIN);
				  po->flags &=~(PSCAT_TRANX|PSCAT_TRANZ);
				}
				else  
				{ po->pblock->SetValue(PB_TRANX,t,rot.z);
				  po->pblock->SetValue(PB_TRANY,t,rot.z);
				  SpinnerOff(hWnd,IDC_AP_TRANXSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANYSPIN);
				  po->flags &=~(PSCAT_TRANX|PSCAT_TRANY);
				}
				}  else
				{ SpinnerOn(hWnd,IDC_AP_TRANXSPIN);
				  SpinnerOn(hWnd,IDC_AP_TRANYSPIN);
				  SpinnerOn(hWnd,IDC_AP_TRANZSPIN);
				  po->flags |=(PSCAT_TRANX|PSCAT_TRANY|PSCAT_TRANZ);
				}
				  po->pmapTransforms->Invalidate();
				   break;
			  }
			  case IDC_AP_TRANFLOCK:
			  {	int rlock;
			    po->pblock->GetValue(PB_TRANFLOCK,t,rlock,FOREVER);
				if (rlock)
				{po->pblock->GetValue(PB_TRANFX,t,rot.x,FOREVER);
			    po->pblock->GetValue(PB_TRANFY,t,rot.y,FOREVER);
			    po->pblock->GetValue(PB_TRANFZ,t,rot.z,FOREVER);
				maxv=MaxComponent(rot);
				if (maxv==0) 
				{ po->pblock->SetValue(PB_TRANFY,t,rot.x);
				  po->pblock->SetValue(PB_TRANFZ,t,rot.x);
				  SpinnerOff(hWnd,IDC_AP_TRANYFSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANZFSPIN);
				  po->flags &=~(PSCAT_TRANFY|PSCAT_TRANFZ);
				}
				else if (maxv==1) 
				{ po->pblock->SetValue(PB_TRANFX,t,rot.y);
				  po->pblock->SetValue(PB_TRANFZ,t,rot.y);
				  SpinnerOff(hWnd,IDC_AP_TRANXFSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANZFSPIN);
				  po->flags &=~(PSCAT_TRANFX|PSCAT_TRANFZ);
				}
				else  
				{ po->pblock->SetValue(PB_TRANFX,t,rot.z);
				  po->pblock->SetValue(PB_TRANFY,t,rot.z);
				  SpinnerOff(hWnd,IDC_AP_TRANXFSPIN);
				  SpinnerOff(hWnd,IDC_AP_TRANYFSPIN);
				  po->flags &=~(PSCAT_TRANFX|PSCAT_TRANFY);
				}
				}  else
				{ SpinnerOn(hWnd,IDC_AP_TRANXFSPIN);
				  SpinnerOn(hWnd,IDC_AP_TRANYFSPIN);
				  SpinnerOn(hWnd,IDC_AP_TRANZFSPIN);
				  po->flags |=(PSCAT_TRANFX|PSCAT_TRANFY|PSCAT_TRANFZ);
				}
				  po->pmapTransforms->Invalidate();
				   break;
			  }
			  case IDC_AP_SCALELOCK:
			  {	int rlock;
			    po->pblock->GetValue(PB_SCALELOCK,t,rlock,FOREVER);
				if (rlock)
				{po->pblock->GetValue(PB_SCALEX,t,rot.x,FOREVER);
			    po->pblock->GetValue(PB_SCALEY,t,rot.y,FOREVER);
			    po->pblock->GetValue(PB_SCALEZ,t,rot.z,FOREVER);
				maxv=MaxComponent(rot);
				if (maxv==0) 
				{ po->pblock->SetValue(PB_SCALEY,t,rot.x);
				  po->pblock->SetValue(PB_SCALEZ,t,rot.x);
				  SpinnerOff(hWnd,IDC_AP_SCALEYSPIN);
				  SpinnerOff(hWnd,IDC_AP_SCALEZSPIN);
				  po->flags &=~(PSCAT_SCALEY|PSCAT_SCALEZ);
				}
				else if (maxv==1) 
				{ po->pblock->SetValue(PB_SCALEX,t,rot.y);
				  po->pblock->SetValue(PB_SCALEY,t,rot.y);
				  SpinnerOff(hWnd,IDC_AP_SCALEXSPIN);
				  SpinnerOff(hWnd,IDC_AP_SCALEZSPIN);
				  po->flags &=~(PSCAT_SCALEX|PSCAT_SCALEZ);
				}
				else  
				{ po->pblock->SetValue(PB_SCALEX,t,rot.z);
				  po->pblock->SetValue(PB_SCALEY,t,rot.z);
				  SpinnerOff(hWnd,IDC_AP_SCALEXSPIN);
				  SpinnerOff(hWnd,IDC_AP_SCALEYSPIN);
				  po->flags &=~(PSCAT_SCALEX|PSCAT_SCALEY);
				}
				}  else
				{ SpinnerOn(hWnd,IDC_AP_SCALEXSPIN);
				  SpinnerOn(hWnd,IDC_AP_SCALEYSPIN);
				  SpinnerOn(hWnd,IDC_AP_SCALEZSPIN);
				  po->flags |=(PSCAT_SCALEX|PSCAT_SCALEY|PSCAT_SCALEZ);
				}
				  po->pmapTransforms->Invalidate();
					   break;
			  }
			}
			break;

		default:
			return FALSE;
		}
	return TRUE;
}		

class ProScatObjList : public ParamMapUserDlgProc {
	public:
		PScatterObject *po;

		ProScatObjList(PScatterObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void ProScatObjList::Update(TimeValue t)
{   if (!po->editOb) return;
	po->ShowOpList(po->ob2!=NULL);
	DistGreyOuts(po,po->distwnd,t);
}

BOOL ProScatObjList::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{ switch (msg) {
		case WM_INITDIALOG: {
			po->distwnd=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_CUSTEDIT_ENTER: {
			ICustEdit *edit;
			TCHAR buf[256];
			
			switch (LOWORD(wParam)) {
				case IDC_PSCAT_ANAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_PSCAT_ANAME));					
					edit->GetText(buf,256);
					po->opaName = TSTR(buf);					
					if (po->ob1) po->ob1->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;
					
				case IDC_PSCAT_BNAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_PSCAT_BNAME));					
					edit->GetText(buf,256);
					po->opbName = TSTR(buf);
					if (po->ob2) po->ob2->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;					
				}
			
			po->ShowOpList(po->ob2!=NULL);
			break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_BOOL_OPERANDS:
					if (HIWORD(wParam)==LBN_SELCHANGE) 
					{	po->flags &= ~PSCAT_ANYSEL;
						
						if (SendMessage((HWND)lParam,LB_GETSEL,0,0)) 
						{ po->flags |= PSCAT_OB1SEL;	}
							
						if (SendMessage((HWND)lParam,LB_GETSEL,1,0))
						{ po->flags |= PSCAT_OB2SEL;	}
						po->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
						po->NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
						po->ip->RedrawViews(po->ip->GetTime());
						po->SetExtractButtonState();
					}
					break;
			  case IDC_AP_DISTOBJECT:
				DistObjectOn(po,hWnd);
				break;
			  case IDC_AP_VOLARRAY:
				DistObjectOff(po,hWnd);
				break;
			  case IDC_AP_DISTCENTERS:
			  case IDC_AP_DISTVERTICES:
			  case IDC_AP_DISTECENTER:
				  SpinnerOff(hWnd,IDC_AP_NUMBERSPIN);
				break;
			  case IDC_AP_DISTAREA:
			  case IDC_AP_DISTEVEN:
			  case IDC_AP_DISTNFACES:
			  case IDC_AP_DISTRANDOM:
			  case IDC_AP_DISTEDGES:
			  case IDC_AP_DISTVOLUME:
				  SpinnerOn(hWnd,IDC_AP_NUMBERSPIN);
				break;
				case IDC_PS_DISPOPS:
				case IDC_PS_DISPRESULT:
					if (IsDlgButtonChecked(hWnd,IDC_PS_DISPRESULT)) {						
						po->SetFlag(PSCAT_DISPRESULT);
					} else {
						po->ClearFlag(PSCAT_DISPRESULT);
						}
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					po->ip->RedrawViews(po->ip->GetTime());
					break;
				case IDC_SCATR_EXTRACT_INSTANCE:
					po->extractCopy = FALSE;
					break;
				case IDC_SCATR_EXTRACT_COPY:
					po->extractCopy = TRUE;
					break;
				case IDC_SCATR_EXTRACTOP:
					theHold.Begin();
					if (po->flags&PSCAT_OB1SEL) po->ExtractOperand(0);
					if (po->flags&PSCAT_OB2SEL) po->ExtractOperand(1);
					theHold.Accept(GetString(IDS_AP_EXTRACTOP));
					po->ip->RedrawViews(po->ip->GetTime());
					break;
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
}
void PScatterObject::InvalidateUI()
	{
	if (pmapDist) pmapDist->Invalidate();
	if (pmapObjects) pmapObjects->Invalidate();
	if (pmapTransforms) pmapTransforms->Invalidate();
	if (pmapDisplay) pmapDisplay->Invalidate();
	}


void PScatterObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	this->ip = ip;	
	editOb   = this;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else {
		creating = FALSE;
		// Create sub object editing modes.
		moveMode       = new MoveModBoxCMode(this,ip);
		rotMode        = new RotateModBoxCMode(this,ip);
		uscaleMode     = new UScaleModBoxCMode(this,ip);
		nuscaleMode    = new NUScaleModBoxCMode(this,ip);
		squashMode     = new SquashModBoxCMode(this,ip);
		selectMode     = new SelectModBoxCMode(this,ip);
		
		// Add our sub object type
		TSTR type(GetString(IDS_AP_OPERANDS));
		const TCHAR *ptype[] = {type};
		ip->RegisterSubObjectTypes(ptype, 1);
		}
	if (pmapObjects && pmapTransforms && pmapDisplay && pmapTransforms)
	{	pmapDist->SetParamBlock(pblock);
		pmapDisplay->SetParamBlock(pblock);
		pmapObjects->SetParamBlock(pblock);
		pmapTransforms->SetParamBlock(pblock);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
	}
	else 
	{ pmapDist = CreateCPParamMap(
				descPickDist,PICKDISTDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PROSCATTER_PICKDIST),
				GetString(IDS_AP_PICKDISTOBJ),
				0);

	  pmapObjects = CreateCPParamMap(
				descObjects,OBJECTSDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PROSCATTER_OBJECTS),
				GetString(IDS_AP_SCATTEROBJECTS),
				0);


		pmapTransforms= CreateCPParamMap(
				descTransforms,TRANSFORMSDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PROSCATTER_XFORMS),
				GetString(IDS_AP_TRANSFORMS),
				(creating?APPENDROLL_CLOSED:0));			

		pmapDisplay = CreateCPParamMap(
				descDisplay,DISPLAYDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PROSCATTER_DISPLAY),
				GetString(IDS_AP_SCATRDISPLAY),
				(creating?APPENDROLL_CLOSED:0));

		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_PROSCATTER_SAVE),
				CustomSettingParamDlgProc, 
				GetString(IDS_AP_LOADSAVE), 
				(LPARAM)this,APPENDROLL_CLOSED);		
		ip->RegisterDlgWnd(hParams2);

	hObject=pmapObjects->GetHWnd();
   thwnd=pmapTransforms->GetHWnd();
if (pmapObjects) pmapObjects->SetUserDlgProc(new ProScatObjList(this));
  if (pmapDist) pmapDist->SetUserDlgProc(new ProScatPickObj(this));
  if (pmapTransforms) pmapTransforms->SetUserDlgProc(new ProScatLockProc(this));
  if (pmapDisplay) pmapDisplay->SetUserDlgProc(new ProScatDispProc(this));
	} 
 }

void PScatterObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	editOb = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapObjects) DestroyCPParamMap(pmapObjects);
		if (pmapTransforms) DestroyCPParamMap(pmapTransforms);
		if (pmapDisplay) DestroyCPParamMap(pmapDisplay);
		if (pmapDist) DestroyCPParamMap(pmapDist);
		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;
		pmapObjects  = NULL;
		pmapTransforms = NULL;
		pmapDisplay = NULL;
		pmapDist = NULL;
		}else
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);

	if (!creating) {
		ip->DeleteMode(moveMode);
		ip->DeleteMode(rotMode);
		ip->DeleteMode(uscaleMode);
		ip->DeleteMode(nuscaleMode);
		ip->DeleteMode(squashMode);
		ip->DeleteMode(selectMode);
		if ( moveMode ) delete moveMode;
		moveMode = NULL;
		if ( rotMode ) delete rotMode;
		rotMode = NULL;
		if ( uscaleMode ) delete uscaleMode;
		uscaleMode = NULL;
		if ( nuscaleMode ) delete nuscaleMode;
		nuscaleMode = NULL;
		if ( squashMode ) delete squashMode;
		squashMode = NULL;
		if ( selectMode ) delete selectMode;
		selectMode = NULL;	
	}
	ip->ClearPickMode();
	ip = NULL;
	creating = FALSE;
	}

int PScatterObject::NumPipeBranches() 
	{
	int num=0;
	if (TestFlag(PSCAT_OB1SEL) && ob1) num++;
	if (TestFlag(PSCAT_OB2SEL) && ob2) num++;
	return num;
	}

Object *PScatterObject::GetPipeBranch(int i) 
	{
	if (i) return ob2;	
	if (TestFlag(PSCAT_OB1SEL)) return ob1;
	return ob2;
	}

INode *PScatterObject::GetBranchINode(TimeValue t,INode *node,int i)
	{
	assert(i<2);
	int index = 0;
	if (i) index = 1;
	else if (TestFlag(PSCAT_OB1SEL)) index = 0;
	else index = 1;
	return CreateINodeTransformed(node,GetOpTM(t,index));
	}

int PScatterObject::NumSubs()
{ 	return 5; 	}

Animatable* PScatterObject::SubAnim(int i)
{ 	switch (i) {
		case 0:  return ob1;
		case 1:  return tm1;
		case 2:	 return ob2;
		case 3:	 return tm2;
		case 4:	 return pblock;
		default: return NULL;
		}	
}

TSTR PScatterObject::SubAnimName(int i)
	{	
	switch (i) {
		case 0: return opaName;//return GetString(IDS_AP_OPERANDA);
		case 1: return GetString(IDS_AP_OPERANDATRANSFORM);
		case 2: return opbName;//return GetString(IDS_AP_OPERANDB);
		case 3: return GetString(IDS_AP_OPERANDBTRANSFORM);
		case 4: return GetString(IDS_AP_PARAMETERS);
		}
	return _T("Error");
	}

int PScatterObject::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case 0:  return REF_OP1;
		case 1:  return REF_CONT1;
		case 2:	 return REF_OP2;
		case 3:	 return REF_CONT2;
		case 4:	 return PBLOCK;
		default: return -1;
		}	
	}

RefTargetHandle PScatterObject::GetReference(int i)
	{
	switch (i) {
		case REF_OP1: 	return ob1;
		case REF_OP2: 	return ob2;
		case REF_CONT1:	return tm1;
		case REF_CONT2:	return tm2;
		case PBLOCK:	return pblock;
		default:        return NULL;
		}
	}
void PScatterObject::ShowName(BOOL ob2)
{ if (pmapDist)
{ TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (ob2 ? opbName : TSTR(GetString(IDS_AP_NONE)));
SetWindowText(GetDlgItem(pmapDist->GetHWnd(), IDC_AP_PROSCATTER_DISTOBJ), name);}
}
void PScatterObject::ShowOpList(BOOL isobj)
{ if (pmapObjects)
{	ShowName(isobj); 
	HWND hList = GetDlgItem(pmapObjects->GetHWnd(),IDC_BOOL_OPERANDS);
	SendMessage(hList,LB_RESETCONTENT,0,0);
	TSTR name = TSTR(GetString(IDS_AP_SCATTERTITLE))+ (ob1 ? opaName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	name = TSTR(GetString(IDS_AP_DISTRIBTITLE))+ (isobj ? opbName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	if (flags&PSCAT_OB1SEL) {SendMessage(hList,LB_SETSEL,TRUE,0); }
	if (flags&PSCAT_OB2SEL) {SendMessage(hList,LB_SETSEL,TRUE,1); }
	ICustEdit *edit = GetICustEdit(GetDlgItem(pmapObjects->GetHWnd(),IDC_PSCAT_ANAME));
	edit->SetText(opaName);
	ReleaseICustEdit(edit);

	edit = GetICustEdit(GetDlgItem(pmapObjects->GetHWnd(),IDC_PSCAT_BNAME));
	edit->SetText(opbName);
	ReleaseICustEdit(edit);
	SetExtractButtonState();
}
}

void PScatterObject::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case REF_OP1: 	 
			ob1 = (Object*)rtarg;
/*			if (rtarg==NULL) {				
				if (editOb==this) {
					ShowOpList(ob2!=NULL);
					}
				}*/
			break;

		case REF_OP2: 	 
			ob2 = (Object*)rtarg;  
/*			if (rtarg==NULL) {
				if (editOb==this) {
					ShowOpList();
					}
				}*/
			break;

		case REF_CONT1:	 tm1 = (Control*)rtarg; break;
		case REF_CONT2:	 tm2 = (Control*)rtarg; break;
		case PBLOCK:	 pblock=(IParamBlock*)rtarg; break;
		}
	}

RefTargetHandle PScatterObject::Clone(RemapDir& remap)
	{
	PScatterObject *obj = new PScatterObject;
	if (ob1) obj->ReplaceReference(REF_OP1,remap.CloneRef(ob1));
	if (ob2) obj->ReplaceReference(REF_OP2,remap.CloneRef(ob2));
	if (tm1) obj->ReplaceReference(REF_CONT1,remap.CloneRef(tm1));
	if (tm2) obj->ReplaceReference(REF_CONT2,remap.CloneRef(tm2));
	if (pblock) obj->ReplaceReference(PBLOCK,pblock->Clone(remap)); 
	obj->flags = flags;
	obj->opaName=opaName;
	obj->opbName=opbName;
	obj->ivalid.SetEmpty();
	return obj;
	}

int PScatterObject::IntersectRay(
		TimeValue t, Ray& r, float& at, Point3& norm)
	{
	if (TestFlag(PSCAT_DISPRESULT)) {
		UpdateMesh(t);
		return mesh.IntersectRay(r,at,norm);
	} else {
		return 0;
		}
	}

Mesh* PScatterObject::GetRenderMesh(
		TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{	
	UpdateMesh(t);
	needDelete = FALSE;
	return &mesh;	
	}

int PScatterObject::HitTest(
		TimeValue t, INode* inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt)
	{
	int res = 0;
	if (ob1&& TestFlag(PSCAT_DISPRESULT)) {
		UpdateMesh(t,FALSE,inode->Selected());
		HitRegion hitRegion;
		GraphicsWindow *gw = vpt->getGW();	
		Material *mtl = gw->getMaterial();		
		gw->setTransform(inode->GetObjectTM(t));
		MakeHitRegion(hitRegion, type, crossing, 4, p);
		res = mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return res;
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		}
	return res;
	}

void PScatterObject::Snap(
		TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{
	if (TestFlag(PSCAT_DISPRESULT)&&ob1) {
		UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();		
		gw->setTransform(tm);
		mesh.snap( gw, snap, p, tm );
	} else {	
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->Snap(t,&n,snap,p,vpt);
			}	
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			ob->Snap(t,&n,snap,p,vpt);
			}
		}
	}

#define DRAW_A (1<<1)
#define DRAW_B (1<<2)

int PScatterObject::
		Display(TimeValue t, INode* inode, ViewExp *vpt, int aflags)
	{	
	GraphicsWindow *gw = vpt->getGW();

/*	UpdateMesh(t,FALSE,inode->Selected());
	Matrix3 mat;
	mat=inode->GetObjectTM(t);
	gw->setTransform(mat);
	mesh.render(gw, inode->Mtls(),(aflags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL, COMP_ALL, inode->NumMtls());*/

	Object *ob;
		
	DWORD rlim = gw->getRndLimits();

	if (ob=GetPipeObj(t,0)) {
	  if (TestFlag(PSCAT_DISPRESULT))
	  { UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 mat;
		mat=inode->GetObjectTM(t);
		gw->setTransform(mat);
		 if (inode->Selected()) {
				 if (TestFlag(PSCAT_OB1SEL)) {
					vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
				 } else {
					Point3 selClr = GetUIColor(COLOR_SELECTION); 
					vpt->getGW()->setColor( LINE_COLOR, selClr.x, selClr.y, selClr.z);
				 	}
				}
		TriObject t1;
		t1.GetMesh().DeepCopy(&mesh,PART_GEOM|PART_TOPO);
		t1.GetMesh().setNumVerts(ob1verts,TRUE);t1.GetMesh().setNumFaces(ob1faces,TRUE);
		t1.GetMesh().render(gw, inode->Mtls(),(aflags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL, COMP_ALL, inode->NumMtls());				 
	  }
	  else
		{	INodeTransformed n(inode,GetOpTM(t,0));
			if (inode->Selected()) 
			{ if (TestFlag(PSCAT_OB1SEL)) 
				vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
			  else vpt->getGW()->setColor( LINE_COLOR, GetSelColor());
			}
			ob->Display(t,&n,vpt,aflags);
		}
	}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			if (inode->Selected()) 
			{ if (TestFlag(PSCAT_OB2SEL)) 
				vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
			  else vpt->getGW()->setColor( LINE_COLOR, GetSelColor());
			}
			ob->Display(t,&n,vpt,flags);
		}
		
	gw->setRndLimits(rlim);
	return 0;
	}

void PScatterObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(PSCAT_DISPRESULT) && ob1) {
		UpdateMesh(t);
		box = mesh.getBoundingBox(tm);
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {				
			if (tm) {
				Matrix3 mat = GetOpTM(t,0) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	if (tm) {
				Matrix3 mat = GetOpTM(t,1) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		}
	}

void PScatterObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt, Box3& box) 
	{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(PSCAT_DISPRESULT) && ob1) {
		UpdateMesh(t,FALSE,inode->Selected());
		box = mesh.getBoundingBox();	
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,0);
			box += abox;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,1);
			box += abox;
			}
		}
}

void PScatterObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
{	Box3 abox;
	int disp = 0;
	abox.Init();
	box.Init();

	if (TestFlag(PSCAT_DISPRESULT) && ob1) 
	{	UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 mat = inode->GetObjectTM(t);	
		box = mesh.getBoundingBox();
		if (!box.IsEmpty()) box = box * mat;
	} 
	else 
	{ Object *ob;
	  if (ob=GetPipeObj(t,0)) 
	  {		INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetWorldBoundBox(t,&n,vpt,abox);
			box += abox;
	  }
		
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
	  {	INodeTransformed n(inode,GetOpTM(t,1));
		ob->GetWorldBoundBox(t,&n,vpt,abox);
		box += abox;
	  }
	}
}

RefResult PScatterObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message ) 
	{
	switch (message) {
		case REFMSG_SELECT_BRANCH:
			if (hTarget==ob1 || hTarget==ob2) {
				ClearFlag(PSCAT_OB1SEL|PSCAT_OB2SEL);
				if (hTarget==ob1) SetFlag(PSCAT_OB1SEL);
				if (hTarget==ob2) SetFlag(PSCAT_OB2SEL);
				NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
				NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
				}
			break;
		case REFMSG_CHANGE:
			 ivalid.SetEmpty();
			if (editOb==this) InvalidateUI();
			break;
		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			ivalid.SetEmpty();
			if (editOb==this) InvalidateUI();
			break;
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}




//--Subobject Selection-------------------------------------------------------------


int PScatterObject::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{	
	int res = 0;
	Object *ob;
	if ((ob=GetPipeObj(t,0)) &&
		!(flags&HIT_SELONLY && !TestFlag(PSCAT_OB1SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(PSCAT_OB1SEL)) )
		if (TestFlag(PSCAT_DISPRESULT))
		{TriObject t1;
		t1.GetMesh().DeepCopy(&mesh,PART_GEOM|PART_TOPO);
		t1.GetMesh().setNumVerts(ob1verts,TRUE);t1.GetMesh().setNumFaces(ob1faces,TRUE);
		if (t1.HitTest(t,inode,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,0,NULL);
			res = TRUE;
			if (flags & HIT_ABORTONHIT) 
			{ return TRUE;}
			}
		}
		else
		{INodeTransformed n(inode,GetOpTM(t,0));
		
		if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,0,NULL);
			res = TRUE;
			if (flags & HIT_ABORTONHIT) return TRUE;
			}		
		}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)) &&
		!(flags&HIT_SELONLY && !TestFlag(PSCAT_OB2SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(PSCAT_OB2SEL)) ) {
		
		INodeTransformed n(inode,GetOpTM(t,1));
		
		if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,1,NULL);
			res = TRUE;			
			}		
		}
	
	return res;
	}

int PScatterObject::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flags, ModContext* mc)
	{
	return 0;
	}

void PScatterObject::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	while (hitRec) {
		if (hitRec->hitInfo) {
			if (selected) SetFlag(PSCAT_OB2SEL);
			else ClearFlag(PSCAT_OB2SEL);
		} else {
			if (selected) SetFlag(PSCAT_OB1SEL);
			else ClearFlag(PSCAT_OB1SEL);
			}
		if (all) hitRec = hitRec->Next();
		else break;
		}
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
	if (ip) ShowOpList(ob2!=NULL);
	}

void PScatterObject::ClearSelection(int selLevel)
	{
	ClearFlag(PSCAT_OB1SEL|PSCAT_OB2SEL);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip) ShowOpList(ob2!=NULL);
	}

int PScatterObject::SubObjectIndex(HitRecord *hitRec)
	{
	return hitRec->hitInfo;
	}

void PScatterObject::ActivateSubobjSel(int level, XFormModes& modes)
	{
	if (level) {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		NotifyDependents(
			FOREVER, 
			PART_SUBSEL_TYPE|PART_DISPLAY, 
			REFMSG_CHANGE);		
		ip->PipeSelLevelChanged();
		HWND hList = GetDlgItem(pmapObjects->GetHWnd(),IDC_SWRAP_OPERANDS);
		if (SendMessage(hList,LB_GETSEL,0,0)) flags |= PSCAT_OB1SEL;							
		if (SendMessage(hList,LB_GETSEL,1,0)) flags |= PSCAT_OB2SEL;	
		}
}
class ProScatPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		ProScatPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((PScatterObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<2) {	
 				((PScatterObject*)targ)->pblock->SetValue(PB_ANIOFF,0,TimeValue(0));
 				((PScatterObject*)targ)->pblock->SetValue(PB_EXTRACTTYPE,0,0);
				}
			if (oldVer<1) {	
 				((PScatterObject*)targ)->pblock->SetValue(PB_SHOWTYPE,0,0);
				((PScatterObject*)targ)->SetFlag(PSCAT_DISPRESULT);
				}
			delete this;
			}
	};


#define BOOL_FLAGS_CHUNK	0x0100
#define BOOL_OPANAME_CHUNK	0x0110
#define BOOL_OPBNAME_CHUNK	0x0120
#define BOOL_FIRSTMTLS_CHUNK 0x0130
#define BOOL_SECONDMTLS_CHUNK 0x0140

IOResult PScatterObject::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(BOOL_FLAGS_CHUNK);		
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_OPANAME_CHUNK);		
	isave->WriteWString(opaName);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_OPBNAME_CHUNK);		
	isave->WriteWString(opbName);
	isave->EndChunk();
	
	isave->BeginChunk(BOOL_FIRSTMTLS_CHUNK);		
	isave->Write(&firstmtls,sizeof(firstmtls),&nb);
	isave->EndChunk();

	isave->BeginChunk(BOOL_SECONDMTLS_CHUNK);		
	isave->Write(&firstmtls,sizeof(secondmtls),&nb);
	isave->EndChunk();

	return IO_OK;
	}


IOResult PScatterObject::Load(ILoad *iload)
	{
		iload->RegisterPostLoadCallback(
			new ProScatPostLoadCallback(
				new ParamBlockPLCB(psversions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK)));
	ULONG nb;
	IOResult res = IO_OK;
	
	// Default names
	opaName = TSTR(GetString(IDS_AP_OPERAND));
	opbName = TSTR(GetString(IDS_AP_OPERAND));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case BOOL_FLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			
			case BOOL_OPANAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opaName = TSTR(buf);
				break;
				}

			case BOOL_OPBNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opbName = TSTR(buf);
				break;
				}
			case BOOL_FIRSTMTLS_CHUNK:
				res=iload->Read(&firstmtls,sizeof(firstmtls),&nb);
				break;
			case BOOL_SECONDMTLS_CHUNK:
				res=iload->Read(&secondmtls,sizeof(secondmtls),&nb);
				break;
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	Invalidate();
	return IO_OK;
	}

ParamDimension *PScatterObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_BASESCALE: return stdPercentDim;
		case PB_VERTEXCHAOS: return stdWorldDim;
		case PB_ROTX: return stdWorldDim;
		case PB_ROTY: return stdWorldDim;
		case PB_ROTZ: return stdWorldDim;
		case PB_TRANX: return stdWorldDim;
		case PB_TRANY: return stdWorldDim;
		case PB_TRANZ: return stdWorldDim;
		case PB_TRANFX: return stdWorldDim;
		case PB_TRANFY: return stdWorldDim;
		case PB_TRANFZ: return stdWorldDim;
		case PB_SCALEX: return stdWorldDim;
		case PB_SCALEY: return stdWorldDim;
		case PB_SCALEZ: return stdWorldDim;
		case PB_DISPLAYPORTION: return stdPercentDim;
		case PB_ANIOFF:			return stdTimeDim;
		default: return defaultDim;
		}
	}

TSTR PScatterObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_NUMBER: return GetString(IDS_AP_NUMBER);
		case PB_BASESCALE: return GetString(IDS_AP_BASESCALE);
		case PB_VERTEXCHAOS: return GetString(IDS_AP_VERTICESDANCE);
		case PB_ROTX: return GetString(IDS_AP_ROTX);
		case PB_ROTY: return GetString(IDS_AP_ROTY);
		case PB_ROTZ: return GetString(IDS_AP_ROTZ);
		case PB_TRANX: return GetString(IDS_AP_TRANX);
		case PB_TRANY: return GetString(IDS_AP_TRANY);
		case PB_TRANZ: return GetString(IDS_AP_TRANZ);
		case PB_TRANFX: return GetString(IDS_AP_TRANFX);
		case PB_TRANFY: return GetString(IDS_AP_TRANFY);
		case PB_TRANFZ: return GetString(IDS_AP_TRANFZ);
		case PB_SCALEX: return GetString(IDS_AP_SCALEX);
		case PB_SCALEY: return GetString(IDS_AP_SCALEY);
		case PB_SCALEZ: return GetString(IDS_AP_SCALEZ);
		case PB_EXTRACTTYPE: return GetString(IDS_AP_EXTRACTTYPE);
		case PB_ANIOFF: return GetString(IDS_AP_ANIOFF);
		default: return TSTR(_T(""));
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\SMOKE.CPP ===
/*===========================================================================*\
 |    File: Smoke.cpp
 |
 | Purpose: A 3D Map for creating amorphous fractal based turbulent patterns.
 |          This is a port of the 3D Studio/DOS SXP by Dan Silva.
 |
 | History: Mark Meier, Began 02/03/97.
 |          MM, Last Change 02/03/97.
  		    Updated to Param Block2 by Peter Watje 12/1/1998
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"
#include "macrorec.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID smokeClassID(SMOKE_CLASS_ID, 0);

// This is the number of colors used
#define NUM_COLORS 2

// This is the number of sub-texmaps used
#define NUM_SUB_TEXMAPS 2

// This is the version number of the IPAS SXP files that can be read
#define SMOKE_SXP_VERSION 0xDE08

#define MAXNITS 20

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

static Col24 Col24FromColor(Color a) {
	Col24 c;
	c.r = (ULONG)(a.r*255.0f);
	c.g = (ULONG)(a.g*255.0f);
	c.b = (ULONG)(a.b*255.0f);
	return c;
}

#pragma pack(1)
struct SmokeState {
	ulong version;
	float size, hfboost, speed;
	Col24 col1, col2;
	int nits;
	float power;
	long startframe, endframe;
};
#pragma pack()

#define frand() ( (((float)(rand()&0x7FFF))-16384.0f) /16384.0f)



// These are various resource IDs
static int colID[2] = { IDC_COL1, IDC_COL2 };
static int subTexId[NUM_SUB_TEXMAPS] = { IDC_TEX1, IDC_TEX2 };
static int mapOnId[NUM_SUB_TEXMAPS] = { IDC_MAPON1, IDC_MAPON2 };

// Forward references
//class Smoke;
//class SmokeDlgProc;

/*===========================================================================*\
 | Smoke 3D Texture Map Plug-In Class
\*===========================================================================*/
class Smoke : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class SmokeDlg;

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];

	// These are the parameters managed by the parameter map
	float size;
	int iter;
	int seed;
	float power;
	float phase;
	Point3 col1, col2;
	float xvel[MAXNITS];
	float yvel[MAXNITS];
	float zvel[MAXNITS];
	float lastpow;


	float hfboost; // This is currently a constant

	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// These are the sub-texmaps.  If these are set by the user
	// then the color of our texture is affected by the sub-texmaps
	// and not the color swatches.
	// These are reference #2 and #3 of this class.
	Texmap *subTex[NUM_SUB_TEXMAPS];
	// Indicates if a sub-texmap is to be used or not
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	SmokeDlg *paramDlg;

	public:
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
		BOOL mapOn[NUM_SUB_TEXMAPS];
		static ParamDlg* xyzGenDlg;	
		IParamBlock2 *pblock;
		// --- Methods inherited from Animatable ---
		Class_ID ClassID() { return smokeClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_SMOKE); }  
		void DeleteThis() { delete this; }	

		// We have 4 sub-animatables.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
		int NumSubs() { return 2+NUM_SUB_TEXMAPS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 4 references.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
 		int NumRefs() { return 2+NUM_SUB_TEXMAPS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		int NumSubTexmaps() { return NUM_SUB_TEXMAPS; }
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		// --- Methods inherited from Texmap ---
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// --- Methods inherited from Tex3D ---
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods of Smoke ---
		Smoke();
		void SwapInputs(); 
		void NotifyChanged();
		void SetPhase(float f, TimeValue t);
		void SetSize(float f, TimeValue t);
		void SetExp(float f, TimeValue t);
		void SetIter(int i, TimeValue t);
		void SetColor(int i, Color c, TimeValue t);
		void ClampFloat(float &f, float min, float max);
		void ClampInt(int &i, int min, int max);
		float SmokeFunc(Point3 p, int iter);
		void InitVel(int seed);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Smoke 3D Texture plug-in
class SmokeClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Smoke; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_SMOKE_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return smokeClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("smoke"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};
static SmokeClassDesc smokeCD;
ParamDlg* Smoke::xyzGenDlg;	

ClassDesc *GetSmokeDesc() { return &smokeCD; }

/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class SmokeDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Smoke being edited.
		Smoke *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom buttons for texture maps
		ICustButton *iCustButton[NUM_SUB_TEXMAPS];
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue curTime; 
		// This is used to implement Drag-and-Drop for sub-Texmaps.
		TexDADMgr dadMgr;
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		int FindSubTexFromHWND(HWND hw);
		void DeleteThis() { delete this; }

		// --- SmokeDlg Methods ---
		SmokeDlg(HWND hwMtlEdit, IMtlParams *imp, Smoke *m); 
		~SmokeDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void UpdateSubTexNames();
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/
/*===========================================================================*\
 | Noise and Lerp Functions
\*===========================================================================*/
static void lerp_color(Col24 *c, Col24 *a, Col24 *b, float f) {
	int alph = (int)(4096*f);
	int ialph = 4096-alph;
	c->r = (ialph*a->r + alph*b->r)>>12;
	c->g = (ialph*a->g + alph*b->g)>>12;
	c->b = (ialph*a->b + alph*b->b)>>12;
}


/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_SIZE		0
#define PB_ITER		1
#define PB_EXP		2 
#define PB_PHASE	3
#define PB_COL1		4
#define PB_COL2		5
*/
// Spinner limits
#define MIN_SIZE 0.001f
#define MAX_SIZE 999999999.0f

#define MIN_ITER 1
#define MAX_ITER 20

#define MIN_EXP 0.001f
#define MAX_EXP 5.0f

#define MIN_SPEED 0.0f
#define MAX_SPEED 100.0f

// Paramter block version number
#define SMOKE_PB_VERSION 2

enum { smoke_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	smoke_size, smoke_iteration,		
	smoke_exponent, smoke_phase,		
	smoke_color1, smoke_color2,
	smoke_map1, smoke_map2,
	smoke_mapon1,smoke_mapon2,
	smoke_coords,	  // access for UVW mapping
};


static ParamBlockDesc2 smoke_param_blk ( smoke_params, _T("parameters"),  0, &smokeCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_SMOKE, IDS_DS_SMOKE_PARAMS, 0, 0, NULL, 
	// params


	smoke_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SIZE,
		p_default,		40.f,
		p_range,		MIN_SIZE, MAX_SIZE,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN, 0.1f, 
		end,
	smoke_iteration,	_T("iterations"),   TYPE_INT,			P_ANIMATABLE,	IDS_DS_ITER,
		p_default,		5,
		p_range,		MIN_ITER, MAX_ITER, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_ITER_EDIT,IDC_ITER_SPIN, 1.0f, 
		end,
	smoke_exponent,	_T("exponent"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_EXPONENT,
		p_default,		1.5f,
		p_range,		MIN_EXP, MAX_EXP,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_EXP_EDIT,IDC_EXP_SPIN, 0.1f, 
		end,
	smoke_phase,	_T("phase"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PHASE,
		p_default,		0.f,
		p_range,		MIN_SPEED, MAX_SPEED, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SPEED_EDIT,IDC_SPEED_SPIN,  0.1f, 
		end,
	smoke_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.0, 0.0, 0.0), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	smoke_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(1.0f, 1.0f, 1.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,
	smoke_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX1,
		end,
	smoke_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX2,
		end,
	smoke_mapon1,	_T("map1On"), TYPE_BOOL,			0,				IDS_PW_MAPON1,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	smoke_mapon2,	_T("map2On"), TYPE_BOOL,			0,				IDS_PW_MAPON2,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	smoke_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);

// Array of parameter descriptors
/*
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_ITER, 
		EDITTYPE_INT, 
		IDC_ITER_EDIT,IDC_ITER_SPIN, 
		MIN_ITER, MAX_ITER, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_EXP, 
		EDITTYPE_FLOAT, 
		IDC_EXP_EDIT,IDC_EXP_SPIN, 
		MIN_EXP, MAX_EXP, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_PHASE, 
		EDITTYPE_FLOAT, 
		IDC_SPEED_EDIT,IDC_SPEED_SPIN, 
		MIN_SPEED, MAX_SPEED, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2)
};
*/
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 6

// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE, smoke_size }, // size 
	{ TYPE_INT,   NULL, TRUE, smoke_iteration }, // iter
	{ TYPE_FLOAT, NULL, TRUE, smoke_exponent }, // exponent
	{ TYPE_FLOAT, NULL, TRUE, smoke_phase }, // phase
	{ TYPE_RGBA,  NULL, TRUE, smoke_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE, smoke_color2 }  // color 2
};
// The number of parameters in the parameter block
#define PB_LENGTH 6

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,6,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = {
	IDS_DS_SIZE, IDS_DS_ITER, IDS_DS_EXPONENT, IDS_DS_PHASE, IDS_DS_COL1, IDS_DS_COL2
	};

/*
// This is the class that allows the sub-map buttons to be processed.
class SmokeDlgProc : public ParamMapUserDlgProc {
	public:
		SmokeDlg *theDlg;
		SmokeDlgProc(SmokeDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL SmokeDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

BOOL SmokeDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], theTex->GetSubTexmapSlotName(i).data());
			for (i = 0; i < NUM_SUB_TEXMAPS; i++) {
				iCustButton[i] = GetICustButton(GetDlgItem(hWnd, subTexId[i]));
				iCustButton[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hWnd, mapOnId[i], theTex->mapOn[i]);
			}
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_TEX1: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 0, (LPARAM)theTex);
					break;

				case IDC_TEX2: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 1, (LPARAM)theTex);
					break;

				case IDC_SWAP: {
					theTex->SwapInputs(); 
					IParamBlock *pb = (IParamBlock *)pmap->GetParamBlock();
					pb->SetValue(PB_COL1, curTime, theTex->col[0]);
					pb->SetValue(PB_COL2, curTime, theTex->col[1]);
					pmap->Invalidate();
					UpdateSubTexNames();
					UpdateMtlDisplay();
					theTex->NotifyChanged();
					}
					break;

				case IDC_MAPON1:
					theTex->mapOn[0] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_MAPON2:
					theTex->mapOn[1] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;
			}
			break;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/

/*===========================================================================*\
 | SmokeDlg Methods
\*===========================================================================*/
// --- SmokeDlg Methods ---
// Constructor.
// This is called from within the Smoke::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
SmokeDlg::SmokeDlg(HWND hwMtlEdit, IMtlParams *imp, Smoke *m) { 
	dadMgr.Init(this);
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	curTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_SMOKE),
		GetString(IDS_DS_SMOKE_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new SmokeDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Smoke texture.
// Note that it is not called if they do go to another Smoke -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside SmokeDlg::SetThing()).
SmokeDlg::~SmokeDlg() {
	theTex->paramDlg = NULL;
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		ReleaseICustButton(iCustButton[i]);
		iCustButton[i] = NULL; 
	}
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}

// This is called when the dialog is loaded to set the names of the
// textures displayed
void SmokeDlg::UpdateSubTexNames() {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		TSTR nm;
		Texmap *m = theTex->subTex[i];
		if (m) 	
			nm = m->GetFullName();
		else
			nm = GetString(IDS_DS_NONE);
		iCustButton[i]->SetText(nm.data());
	}
}

// Update the dialog display with the values of the texture we are
// currently editing.
void SmokeDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(curTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);
		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_ITER_SPIN));
		spin->SetValue(theTex->iter, FALSE);
		ReleaseISpinner(spin);
		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_EXP_SPIN));
		spin->SetValue(theTex->power, FALSE);
		ReleaseISpinner(spin);
		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SPEED_SPIN));
		spin->SetValue(theTex->phase, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);

		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) 
			SetCheckBox(hParamDlg, mapOnId[i], theTex->mapOn[i]);

		UpdateSubTexNames();
	}
}

// This method invalidates the rollup page so it will get redrawn
void SmokeDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID SmokeDlg::ClassID() {
	return smokeClassID; 
}

// This sets the current texture being edited to the texture passed
void SmokeDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == smokeClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Smoke *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *SmokeDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void SmokeDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != curTime) {
		xyzGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void SmokeDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(curTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void SmokeDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}

// This returns the index of the sub texmap whose window handle is passed.
// This is used by the Drag-and-Drop manager class (TexDADMgr).
int SmokeDlg::FindSubTexFromHWND(HWND hw) {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (hw == iCustButton[i]->GetHwnd()) return i;
	}	
	return -1;
}
*/

//dialog stuff to get the Set Ref button
class SmokeDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Smoke *smoke;		
		SmokeDlgProc(Smoke *m) {smoke = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			smoke = (Smoke*)m;
			}

	};



BOOL SmokeDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_SWAP:
					{
					smoke = (Smoke*)map->GetParamBlock()->GetOwner(); 

					smoke->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}



/*===========================================================================*\
 | Smoke Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Smoke::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
	}
}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Smoke::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return GetSubTexmapTVName(i-2);
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Smoke::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
	}
}

// Save the 'i-th' reference
void Smoke::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Smoke::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			texValidity.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				smoke_param_blk.InvalidateUI(changing_param);
				}

			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget != xyzGen) {
//				if (paramDlg) 
//					paramDlg->pmap->Invalidate();
//			}
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_SIZE: gpd->dim =  stdWorldDim; 	break;
				case PB_ITER:
				case PB_EXP:
				case PB_PHASE:
					gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define SMOKE_VERS1_CHUNK		0x4001
#define MAPOFF_CHUNK			0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Smoke::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();
	// Save a version number chunk
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
/*
	isave->BeginChunk(SMOKE_VERS1_CHUNK);
	isave->EndChunk();
	// Save the on/off status of the sub-texmaps
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (mapOn[i] == 0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
		}
	}
*/
	return IO_OK;

}



class SmokePostLoad : public PostLoadCallback {
	public:
		Smoke *n;
		BOOL Param1;
		SmokePostLoad(Smoke *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( smoke_mapon1, 0, n->mapOn[0]);
				n->pblock->SetValue( smoke_mapon2, 0, n->mapOn[1]);
				}
			delete this; 


			} 
	};


// This is called by the system to allow the plug-in to load its data
IOResult Smoke::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	BOOL Param1 = TRUE;
	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case SMOKE_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1=FALSE;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				// Set the sub-texmap on/off settings
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &smoke_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new SmokePostLoad(this,Param1));

	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Smoke::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Smoke *newSmoke = new Smoke();

	// Copy superclass stuff
	*((MtlBase *)newSmoke) = *((MtlBase *)this);

	// Clone the items we reference
	newSmoke->ReplaceReference(0, remap.CloneRef(xyzGen));
	newSmoke->ReplaceReference(1, remap.CloneRef(pblock));
	newSmoke->col[0] = col[0];
	newSmoke->col[1] = col[1];
	newSmoke->size = size;
	newSmoke->power = power;
	newSmoke->iter = iter;
	newSmoke->phase = phase;
	newSmoke->texValidity.SetEmpty();	
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		newSmoke->subTex[i] = NULL;
		newSmoke->mapOn[i] = mapOn[i];
		if (subTex[i])
			newSmoke->ReplaceReference(i+2, remap.CloneRef(subTex[i]));
	}
	// Return the new cloned texture
	return (RefTargetHandle)newSmoke;
}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Smoke::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
}

// This method is called to reset the texmap back to its default values.
void Smoke::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	

	// Set the inital parameters
	SetColor(0, Color(0.0f, 0.0f, 0.0f), TimeValue(0));
	SetColor(1, Color(0.9f, 0.9f, 0.9f), TimeValue(0));
	SetExp(1.5f, TimeValue(0));
	SetIter(5, TimeValue(0));
	SetSize(40.0f, TimeValue(0));
	SetPhase(0.0f, TimeValue(0));
	seed = 0x8563;

	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
	}

void Smoke::Reset() {
	smokeCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

Smoke::Smoke() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	mapOn[0] = mapOn[1] = 1;
	lastpow = -1;
	smokeCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
	hfboost = 1.2f; // This is currently a constant
	InitVel(seed);
}


// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Smoke::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	SmokeDlg *smokeDlg = new SmokeDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	smokeDlg->LoadDialog();
//	paramDlg = smokeDlg;
//	return smokeDlg;	
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = smokeCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	smoke_param_blk.SetUserDlgProc(new SmokeDlgProc(this));

	return masterDlg;

}

BOOL Smoke::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}

// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Smoke::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
//		pblock->GetValue(PB_COL1, t, col[0], texValidity);
		pblock->GetValue(smoke_color1, t, col[0], texValidity);
		col[0].ClampMinMax();
//		pblock->GetValue(PB_COL2, t, col[1], texValidity);
		pblock->GetValue(smoke_color2, t, col[1], texValidity);
		col[1].ClampMinMax();
//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(smoke_size, t, size, texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE);
//		pblock->GetValue(PB_EXP, t, power, texValidity);
		pblock->GetValue(smoke_exponent, t, power, texValidity);
		ClampFloat(power, MIN_EXP, MAX_EXP);
//		pblock->GetValue(PB_PHASE, t, phase, texValidity);
//		pblock->GetValue(PB_ITER, t, iter, texValidity);
		pblock->GetValue(smoke_phase, t, phase, texValidity);
		pblock->GetValue(smoke_iteration, t, iter, texValidity);
		ClampInt(iter, (int) MIN_ITER, (int) MAX_ITER);
		pblock->GetValue(smoke_mapon1, t, mapOn[0], texValidity);
		pblock->GetValue(smoke_mapon2, t, mapOn[1], texValidity);
		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t, texValidity);
		}
	}
	ivalid &= texValidity;

}

void Smoke::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

void Smoke::ClampInt(int &i, int min, int max) {
	if (i < min) i = min;
	else if (i > max) i = max;
}

// Returns a pointer to the 'i-th' sub-texmap managed by this texture.
Texmap *Smoke::GetSubTexmap(int i) { 
	return subTex[i]; 
}

// Stores the 'i-th' sub-texmap managed by the material or texture.
void Smoke::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2, m);
	if (i==0)
		{
		smoke_param_blk.InvalidateUI(smoke_map1);
		texValidity.SetEmpty();
		}
	else if (i==1)
		{
		smoke_param_blk.InvalidateUI(smoke_map2);
		texValidity.SetEmpty();
		}

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
}

// This name appears in the materials editor dialog when editing the
// 'i-th' sub-map.
TSTR Smoke::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_COL1); 
		case 1:  return GetString(IDS_DS_COL2); 
		default: return TSTR(_T(""));
		}
	}

void Smoke::InitVel(int seed) {
	srand(seed);
	for (int i=0; i<MAXNITS; i++) {
		xvel[i] = frand();
		yvel[i] = frand();
		zvel[i] = frand();
		}
	}

float Smoke::SmokeFunc(Point3 p, int iter) {
	float s, mag, ft, r[3], d, hfb;
	int i;
	s = 1.0f;
	mag = 0.0f;
	hfb = 2.0f*1.2f; // *hfboost;
	ft = 1.0f;
	float x = p.x;
	float y = p.y;
	float z = p.z;
	for (i = 0; i < iter; i++) {
		float k = ft*phase;
		r[0] = x + xvel[i]*k;
		r[1] = y + yvel[i]*k;
		r[2] = z + zvel[i]*k;
		mag += (float)fabs(noise3(r))/s;
		x *= 2.0f; 
		y *= 2.0f;	
		z *= 2.0f;
		s *= 2.0f; 
		ft *= hfb; // Make motion a little greater for fine detail
		}
	d = mag;
	if (d>1.0f) return 1.0f;
	return (float )pow(d,power);
	}
	 
// --- Methods inherited from Texmap ---
RGBA Smoke::EvalColor(ShadeContext& sc) {
	float d;
	Point3 p, dp;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	if (size == 0.0f) 
		size = 1.0f;

	d = SmokeFunc(p/size, iter);

	// If we have sub-texmaps and they are enabled, get the colors from 
	// the sub-texmaps, otherwise get them from the color swatch
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];

	Col24 c;
	Col24 col1 = Col24FromColor(c0);
	Col24 col2 = Col24FromColor(c1);

	lerp_color(&c, &col1, &col2, d);
	return ColorFromCol24(c);
}

Point3 Smoke::EvalNormalPerturb(ShadeContext& sc) {
	float del, d;
	Point3 p, dp, np;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	p /= size;

	del = 0.1f;
	d = SmokeFunc(p, iter);
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
	np.x = (SmokeFunc(p+del*M[0], iter) - d)/del;
	np.y = (SmokeFunc(p+del*M[1], iter) - d)/del;
	np.z = (SmokeFunc(p+del*M[2], iter) - d)/del;
	return sc.VectorFromNoScale(np,REF_OBJECT);
}

// --- Methods inherited from Tex3D ---
void Smoke::ReadSXPData(TCHAR *name, void *sxpdata) {
	SmokeState *state = (SmokeState*)sxpdata;
	if (state != NULL && (state->version == SMOKE_SXP_VERSION)) {
		SetColor(0, ColorFromCol24(state->col1), TimeValue(0));
		SetColor(1, ColorFromCol24(state->col2), TimeValue(0));
		//SetSpeed(state->speed, TimeValue(0));
		SetPhase(0.0f, TimeValue(0));
		SetSize(state->size, TimeValue(0));
		SetIter(state->nits, TimeValue(0));
		SetExp(state->power, TimeValue(0));
	}
}

// --- Methods of Smoke ---
void Smoke::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void Smoke::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
//	pblock->SwapControllers(PB_COL1, PB_COL2);
	pblock->SwapControllers(smoke_color1,0,smoke_color2 ,0);
	smoke_param_blk.InvalidateUI(smoke_color1);
	smoke_param_blk.InvalidateUI(smoke_color2);
	smoke_param_blk.InvalidateUI(smoke_map1);
	smoke_param_blk.InvalidateUI(smoke_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
}

void Smoke::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue((i == 0) ? PB_COL1 : PB_COL2, t, c);
	pblock->SetValue((i == 0) ? smoke_color1 : smoke_color2, t, c);
}

void Smoke::SetPhase(float f, TimeValue t) { 
	phase = f; 
//	pblock->SetValue(PB_PHASE, t, f);
	pblock->SetValue(smoke_phase, t, f);
}

void Smoke::SetSize(float f, TimeValue t) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(smoke_size, t, f);
}

void Smoke::SetExp(float f, TimeValue t) { 
	power = f; 
//	pblock->SetValue(PB_EXP, t, f);
	pblock->SetValue(smoke_exponent, t, f);
}

void Smoke::SetIter(int i, TimeValue t) { 
	iter = i; 
//	pblock->SetValue(PB_ITER, t, i);
	pblock->SetValue(smoke_iteration, t, i);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\SPLAT.CPP ===
/*===========================================================================*\
 |    File: Splat.cpp
 |
 | Purpose: A 3D Map for creating splatd surface textures.
 |          This is a port of the 3D Studio/DOS SXP by Dan Silva.
 |
 | History: Mark Meier, Began 02/03/97.
 |          MM, Last Change 02/03/97.
 |			Updated to Param Block2 by Peter Watje 12/1/1998
 |			MM, 02/99, Bug fix.
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"
#include "macrorec.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID splatClassID(SPLAT_CLASS_ID, 0);

// This is the number of colors used
#define NUM_COLORS 2

// This is the number of sub-texmaps used
#define NUM_SUB_TEXMAPS 2

// This is the version number of the IPAS SXP files that can be read
#define SPLAT_SXP_VERSION 0xE041

#define EPSILON 0.02f

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

#pragma pack(1)
struct SplatState {
	ulong version;
	float size, thresh;
	int init;
	Col24 col1, col2;
	float strength;
};
#pragma pack()

// These are various resource IDs
static int colID[2] = { IDC_COL1, IDC_COL2 };
static int subTexId[NUM_SUB_TEXMAPS] = { IDC_TEX1, IDC_TEX2 };
static int mapOnId[NUM_SUB_TEXMAPS] = { IDC_MAPON1, IDC_MAPON2 };

// Forward references
//class Splat;
//class SplatDlgProc;

/*===========================================================================*\
 | Splat 3D Texture Map Plug-In Class
\*===========================================================================*/
class Splat : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class SplatDlg;

	// This is the function that actually computes the speckling.
	float splatter(Point3 p);

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];

	// These are the parameters managed by the parameter map
	float size;
	float thresh;
	int iter;
	Point3 col1, col2;

	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// These are the sub-texmaps.  If these are set by the user
	// then the color of our texture is affected by the sub-texmaps
	// and not the color swatches.
	// These are reference #2 and #3 of this class.
	Texmap *subTex[NUM_SUB_TEXMAPS];
	// Indicates if a sub-texmap is to be used or not
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	SplatDlg *paramDlg;

	public:
		static ParamDlg* xyzGenDlg;	
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
		IParamBlock2 *pblock;
		BOOL mapOn[NUM_SUB_TEXMAPS];
		// --- Methods inherited from Animatable ---
		Class_ID ClassID() { return splatClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_SPLAT); }  
		void DeleteThis() { delete this; }	

		// We have 4 sub-animatables.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
		int NumSubs() { return 2+NUM_SUB_TEXMAPS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 4 references.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
 		int NumRefs() { return 2+NUM_SUB_TEXMAPS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		int NumSubTexmaps() { return NUM_SUB_TEXMAPS; }
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		// --- Methods inherited from Texmap ---
		XYZGen *GetTheXYZGen() { return xyzGen; }
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// --- Methods inherited from Tex3D ---
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods of Splat ---
		Splat();
		void SwapInputs(); 
		void NotifyChanged();
		void SetSize(float f, TimeValue t);
		void SetThresh(float f, TimeValue t);
		void SetIter(int i, TimeValue t);
		void SetColor(int i, Color c, TimeValue t);
		void ClampFloat(float &f, float min, float max);
		void ClampInt(int &i, int min, int max);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Splat 3D Texture plug-in
class SplatClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Splat; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_SPLAT_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return splatClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("splat"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};
static SplatClassDesc splatCD;
ClassDesc *GetSplatDesc() { return &splatCD; }
ParamDlg* Splat::xyzGenDlg;	

/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class SplatDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Splat being edited.
		Splat *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom buttons for texture maps
		ICustButton *iCustButton[NUM_SUB_TEXMAPS];
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue curTime; 
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;
		TexDADMgr dadMgr;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		int FindSubTexFromHWND(HWND hw);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void DeleteThis() { delete this; }

		// --- SplatDlg Methods ---
		SplatDlg(HWND hwMtlEdit, IMtlParams *imp, Splat *m); 
		~SplatDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void UpdateSubTexNames();
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/
/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_SIZE		0
#define PB_THRESH	1 
#define PB_ITER		2
#define PB_COL1		3
#define PB_COL2		4
*/
// Spinner limits
#define MIN_SIZE 0.001f
#define MAX_SIZE 999999999.0f

#define MIN_THRESH 0.0f
#define MAX_THRESH 1.0f

#define MIN_ITER 1
#define MAX_ITER 10

// Paramter block version number
#define SPLAT_PB_VERSION 2


enum { splat_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	splat_size,splat_iteration,splat_threshold,
	splat_color1, splat_color2,
	splat_map1, splat_map2,
	splat_mapon1,splat_mapon2,
	splat_coords,	  // access for UVW mapping
};


static ParamBlockDesc2 splat_param_blk ( splat_params, _T("parameters"),  0, &splatCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_SPLAT, IDS_DS_SPLAT_PARAMS, 0, 0, NULL, 
	// params


	splat_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SIZE,
		p_default,		40.f,
		p_range,		MIN_SIZE, MAX_SIZE,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN, 0.1f, 
		end,
	splat_iteration,	_T("iterations"),   TYPE_INT,		P_ANIMATABLE,	IDS_DS_ITER,
		p_default,		4,
		p_range,		MIN_ITER, MAX_ITER,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_ITER_EDIT,IDC_ITER_SPIN, 1.f, 
		end,
	splat_threshold,	_T("threshold"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_THRESH,
		p_default,		0.2f,
		p_range,		MIN_THRESH, MAX_THRESH,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_THRESH_EDIT,IDC_THRESH_SPIN, 0.1f, 
		end,
	splat_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.7f, 0.8f, 0.8f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	splat_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(0.2f, 0.5f, 1.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,
	splat_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX1,
		end,
	splat_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX2,
		end,
	splat_mapon1,	_T("map1On"), TYPE_BOOL,			0,				IDS_PW_MAPON1,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	splat_mapon2,	_T("map2On"), TYPE_BOOL,			0,				IDS_PW_MAPON2,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	splat_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);

/*
// Array of parameter descriptors
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_THRESH, 
		EDITTYPE_FLOAT, 
		IDC_THRESH_EDIT,IDC_THRESH_SPIN, 
		MIN_THRESH, MAX_THRESH, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_ITER, 
		EDITTYPE_INT, 
		IDC_ITER_EDIT,IDC_ITER_SPIN, 
		MIN_ITER, MAX_ITER, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2)
};
*/
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 5

// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE, splat_size }, // size 
	{ TYPE_FLOAT, NULL, TRUE, splat_threshold }, // thresh
	{ TYPE_INT,   NULL, TRUE, splat_iteration }, // iter
	{ TYPE_RGBA,  NULL, TRUE, splat_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE, splat_color2 }  // color 2
};
// The number of parameters in the parameter block
#define PB_LENGTH 5

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,5,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = { IDS_DS_SIZE, IDS_DS_THRESH, IDS_DS_ITER, IDS_DS_COL1, IDS_DS_COL2 };
/*
// This is the class that allows the sub-map buttons to be processed.
class SplatDlgProc : public ParamMapUserDlgProc {
	public:
		SplatDlg *theDlg;
		SplatDlgProc(SplatDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL SplatDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

BOOL SplatDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], theTex->GetSubTexmapSlotName(i).data());
			for (i = 0; i < NUM_SUB_TEXMAPS; i++) {
				iCustButton[i] = GetICustButton(GetDlgItem(hWnd, subTexId[i]));
				iCustButton[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hWnd, mapOnId[i], theTex->mapOn[i]);
			}
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_TEX1: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 0, (LPARAM)theTex);
					break;

				case IDC_TEX2: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 1, (LPARAM)theTex);
					break;

				case IDC_SWAP: {
					theTex->SwapInputs(); 
					IParamBlock *pb = (IParamBlock *)pmap->GetParamBlock();
					pb->SetValue(PB_COL1, curTime, theTex->col[0]);
					pb->SetValue(PB_COL2, curTime, theTex->col[1]);
					pmap->Invalidate();
					UpdateSubTexNames();
					UpdateMtlDisplay();
					theTex->NotifyChanged();
					}
					break;

				case IDC_MAPON1:
					theTex->mapOn[0] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_MAPON2:
					theTex->mapOn[1] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;
			}
			break;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/
/*===========================================================================*\
 | SplatDlg Methods
\*===========================================================================*/
// --- SplatDlg Methods ---
// Constructor.
// This is called from within the Splat::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
SplatDlg::SplatDlg(HWND hwMtlEdit, IMtlParams *imp, Splat *m) { 
	dadMgr.Init(this);
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	curTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_SPLAT),
		GetString(IDS_DS_SPLAT_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new SplatDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Splat texture.
// Note that it is not called if they do go to another Splat -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside SplatDlg::SetThing()).
SplatDlg::~SplatDlg() {
	theTex->paramDlg = NULL;
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		ReleaseICustButton(iCustButton[i]);
		iCustButton[i] = NULL; 
	}
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}

// This is called by the DADMgr
int SplatDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NUM_SUB_TEXMAPS; i++) {
		if (hw == iCustButton[i]->GetHwnd()) return i;
		}	
	return -1;
	}


// This is called when the dialog is loaded to set the names of the
// textures displayed
void SplatDlg::UpdateSubTexNames() {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		TSTR nm;
		Texmap *m = theTex->subTex[i];
		if (m) 	
			nm = m->GetFullName();
		else
			nm = GetString(IDS_DS_NONE);
		iCustButton[i]->SetText(nm.data());
	}
}

// Update the dialog display with the values of the texture we are
// currently editing.
void SplatDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(curTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);
		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_THRESH_SPIN));
		spin->SetValue(theTex->thresh, FALSE);
		ReleaseISpinner(spin);
		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_ITER_SPIN));
		spin->SetValue(theTex->iter, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);

		UpdateSubTexNames();
	}
}

// This method invalidates the rollup page so it will get redrawn
void SplatDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID SplatDlg::ClassID() {
	return splatClassID; 
}

// This sets the current texture being edited to the texture passed
void SplatDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == splatClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Splat *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *SplatDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void SplatDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != curTime) {
		xyzGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void SplatDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(curTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void SplatDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}
*/
//dialog stuff to get the Set Ref button
class SplatDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Splat *splat;		
		SplatDlgProc(Splat *m) {splat = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};



BOOL SplatDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_SWAP:
					{
					splat = (Splat*)map->GetParamBlock()->GetOwner(); 

					splat->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}

/*===========================================================================*\
 | Splat Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Splat::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
	}
}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Splat::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return GetSubTexmapTVName(i-2);
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Splat::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
	}
}

// Save the 'i-th' reference
void Splat::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Splat::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget != xyzGen) {
//				if (paramDlg) 
//					paramDlg->pmap->Invalidate();
//				}
			texValidity.SetEmpty();
			if (hTarget == pblock)
				{

				ParamID changing_param = pblock->LastNotifyParamID();
				splat_param_blk.InvalidateUI(changing_param);
				}	

			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_SIZE:	gpd->dim =  stdWorldDim; break;
				case PB_THRESH:
				case PB_ITER:
					gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define SPLAT_VERS1_CHUNK		0x4001
#define MAPOFF_CHUNK			0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Splat::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
/*
	// Save a version number chunk
	isave->BeginChunk(SPLAT_VERS1_CHUNK);
	isave->EndChunk();
	// Save the on/off status of the sub-texmaps
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (mapOn[i] == 0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
		}
	}
*/
	return IO_OK;
}

class SplatPostLoad : public PostLoadCallback {
	public:
		Splat *n;
		BOOL Param1;
		SplatPostLoad(Splat *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( splat_mapon1, 0, n->mapOn[0]);
				n->pblock->SetValue( splat_mapon2, 0, n->mapOn[1]);
				}
			delete this; 


			} 
	};



// This is called by the system to allow the plug-in to load its data
IOResult Splat::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	BOOL Param1 = TRUE;
	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case SPLAT_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1 = FALSE;;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				// Set the sub-texmap on/off settings
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &splat_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new SplatPostLoad(this,Param1));
	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Splat::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Splat *newSplat = new Splat();

	// Copy superclass stuff
	*((MtlBase *)newSplat) = *((MtlBase *)this);

	// Clone the items we reference
	newSplat->ReplaceReference(0, remap.CloneRef(xyzGen));
	newSplat->ReplaceReference(1, remap.CloneRef(pblock));
	newSplat->col[0] = col[0];
	newSplat->col[1] = col[1];
	newSplat->size = size;
	newSplat->thresh = thresh;
	newSplat->iter = iter;
	newSplat->texValidity.SetEmpty();	
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		newSplat->subTex[i] = NULL;
		newSplat->mapOn[i] = mapOn[i];
		if (subTex[i])
			newSplat->ReplaceReference(i+2, remap.CloneRef(subTex[i]));
	}
	// Return the new cloned texture
	return (RefTargetHandle)newSplat;
}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Splat::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
}

// This method is called to reset the texmap back to its default values.
void Splat::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	

	// Set the inital parameters
	SetColor(0, Color(0.7f, 0.8f, 0.8f), TimeValue(0));
	SetColor(1, Color(0.2f, 0.5f, 1.0f), TimeValue(0));
	SetSize(40.0f, TimeValue(0));
	SetThresh(0.2f, TimeValue(0));
	SetIter(4, TimeValue(0));

	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
}

void Splat::Reset() {
	splatCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

Splat::Splat() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	mapOn[0] = mapOn[1] = 1;
	splatCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
}

// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Splat::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	SplatDlg *splatDlg = new SplatDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	splatDlg->LoadDialog();
//	paramDlg = splatDlg;
//	return splatDlg;
	
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = splatCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	splat_param_blk.SetUserDlgProc(new SplatDlgProc(this));

	return masterDlg;

}

BOOL Splat::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}
// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Splat::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
//		pblock->GetValue(PB_COL1, t, col[0], texValidity);
		pblock->GetValue(splat_color1, t, col[0], texValidity);
		col[0].ClampMinMax();
//		pblock->GetValue(PB_COL2, t, col[1], texValidity);
		pblock->GetValue(splat_color2, t, col[1], texValidity);
		col[1].ClampMinMax();
//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(splat_size, t, size, texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE);
//		pblock->GetValue(PB_THRESH, t, thresh, texValidity);
		pblock->GetValue(splat_threshold, t, thresh, texValidity);
		ClampFloat(thresh, MIN_THRESH, MAX_THRESH);
//		pblock->GetValue(PB_ITER, t, iter, texValidity);
		pblock->GetValue(splat_iteration, t, iter, texValidity);
		pblock->GetValue(splat_mapon1, t, mapOn[0], texValidity);
		pblock->GetValue(splat_mapon2, t, mapOn[1], texValidity);
		ClampInt(iter, (int) MIN_ITER, (int) MAX_ITER);
		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t, texValidity);
		}
	}
	ivalid &= texValidity;
}

void Splat::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

void Splat::ClampInt(int &i, int min, int max) {
	if (i < min) i = min;
	else if (i > max) i = max;
}

// Returns a pointer to the 'i-th' sub-texmap managed by this texture.
Texmap *Splat::GetSubTexmap(int i) { 
	return subTex[i]; 
}

// Stores the 'i-th' sub-texmap managed by the material or texture.
void Splat::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2, m);

	if (i==0)
		{
		splat_param_blk.InvalidateUI(splat_map1);
		texValidity.SetEmpty();
		}
	else if (i==1)
		{
		splat_param_blk.InvalidateUI(splat_map2);
		texValidity.SetEmpty();
		}

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
}

// This name appears in the materials editor dialog when editing the
// 'i-th' sub-map.
TSTR Splat::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_COL1); 
		case 1:  return GetString(IDS_DS_COL2); 
		default: return TSTR(_T(""));
	}
}
	 
// --- Methods inherited from Texmap ---
RGBA Splat::EvalColor(ShadeContext& sc) {
	// After being evaluated, if a map or material has a non-zero gbufID, 
	// it should call ShadeContext::SetGBuffer() to store it into 
	// the shade context.
	if (gbufID) 
		sc.SetGBufferID(gbufID);

	// Use the XYZGen instance to get a transformed point from the
	// ShadeContext.
	Point3 p, dp;
	xyzGen->GetXYZ(sc, p, dp);
	if (size == 0.0f) 
		size = 0.0001f;

	float d = splatter(p);

	// If we have sub-texmaps and they are enabled, get the colors from 
	// the sub-texmaps, otherwise get them from the color swatch
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];

	// Composite the colors together and return the result.
	return (1.0f-d)*c0 + d*c1;
}

Point3 Splat::EvalNormalPerturb(ShadeContext& sc) {
	float del, d, f;
	Point3 p, dp, np;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	d = splatter(p);
	del = 0.1f;
//	float strength = (abs((int)col[1].r-(int)col[0].r)+
//				abs((int)col[1].g-(int)col[0].g)+
//				abs((int)col[1].b-(int)col[0].b)); ///100.0f; // 756.0f

//	f = strength/del;
	f = 1.0f/del;
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = f*(splatter(p+del*M[0]) - d);
	np.y = f*(splatter(p+del*M[1]) - d);
	np.z = f*(splatter(p+del*M[2]) - d);

	return sc.VectorFromNoScale(np,REF_OBJECT);
}

// --- Methods inherited from Tex3D ---
void Splat::ReadSXPData(TCHAR *name, void *sxpdata) {
	SplatState *state = (SplatState*)sxpdata;
	if (state != NULL && (state->version == SPLAT_SXP_VERSION)) {
		SetColor(0, ColorFromCol24(state->col1), TimeValue(0));
		SetColor(1, ColorFromCol24(state->col2), TimeValue(0));
		SetSize(state->size, TimeValue(0));
		SetThresh(state->thresh, TimeValue(0));
	}
}

// --- Methods of Splat ---

float Splat::splatter(Point3 p) {
	float fact, ss, q[3], t;

	q[0] = p[0]/size;
	q[1] = p[1]/size;
	q[2] = p[2]/size;
	fact = 1.0f;
	for (int i = 0; i < iter; i++) {
		t = NOISE(q);
		if (t > 1.0) 
			t = 1.0f;
		ss = smoothstep(thresh-EPSILON, thresh+EPSILON, t);
		fact *= ss;
		q[0] *= 2.0f;	q[1] *= 2.0f;	q[2] *= 2.0f;
	}
	return(1.0f-fact);
}

void Splat::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void Splat::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
//	pblock->SwapControllers(PB_COL1, PB_COL2);
	pblock->SwapControllers(splat_color1,0, splat_color2,0);
	splat_param_blk.InvalidateUI(splat_color1);
	splat_param_blk.InvalidateUI(splat_color2);
	splat_param_blk.InvalidateUI(splat_map1);
	splat_param_blk.InvalidateUI(splat_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
}

void Splat::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue((i == 0) ? PB_COL1 : PB_COL2, t, c);
	pblock->SetValue((i == 0) ? splat_color1 : splat_color2, t, c);
}

void Splat::SetSize(float f, TimeValue t) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(splat_size, t, f);
}

void Splat::SetThresh(float f, TimeValue t) { 
	thresh = f; 
	if (thresh < EPSILON) 
		thresh = EPSILON;
	if (thresh > 1.0f-EPSILON) 
		thresh = 1.0f-EPSILON;
//	pblock->SetValue(PB_THRESH, t, thresh);
	pblock->SetValue(splat_threshold, t, thresh);
}

void Splat::SetIter(int i, TimeValue t) { 
	iter = i; 
//	pblock->SetValue(PB_ITER, t, i);
	pblock->SetValue(splat_iteration, t, i);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\pscatr.cpp ===
/**********************************************************************
 *<
	FILE: PScatr.cpp

	DESCRIPTION:  Procedural Scatter Object Support Code

	CREATED BY: Audrey Peterson

	HISTORY: created 24 December 1996

 *>	Copyright (c) 1996,1997 All Rights Reserved.
 **********************************************************************/
#include "proscatr.h"
#include "stdmat.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;

Point3 Zero=Point3(0.0f,0.0f,0.0f);
TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
//
//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_PSCTRLIB); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() 
{ 
#ifndef DESIGN_VER
	return 2; 
#else
	return 1;
#endif
}

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetPScatObjDesc();
#ifndef DESIGN_VER
	case 1:return GetSWrapObjDesc();
#endif
    default:return 0;}
 }

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

/* rand returns a number between 0 and 32767 */
/* number between 0 and 1 */
const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;
typedef float Matrix3By3[3][3];
typedef float Matrix4By3[4][3];
int FloatEQ0(float number)
{return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));
}
int SmallerEQ0(float number)
{return((SMALL_EPSILON>=number)&&(SMALL_EPSILON>=-FLOAT_EPSILON));
}
int FGT0(Point3 p1)
{
	return((fabs(p1[0])>SMALL_EPSILON)||(fabs(p1[1])>SMALL_EPSILON)||(fabs(p1[2])>SMALL_EPSILON));
}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult4X1(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[0][1]+A[2]*B[0][2]+A[3]*B[0][3];
   C[1]=A[0]*B[1][0]+A[1]*B[1][1]+A[2]*B[1][2]+A[3]*B[1][3];
   C[2]=A[0]*B[2][0]+A[1]*B[2][1]+A[2]*B[2][2]+A[3]*B[2][3];
   C[3]=A[0]*B[3][0]+A[1]*B[3][1]+A[2]*B[3][2]+A[3]*B[3][3];
}

void Mult4XPoint(Point3 *Pin,Matrix4By4 B)
{ float Pby4[4],Pout[4]; 
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult4X1(Pby4,B,Pout);
 memcpy(Pin,Pout,row3size);
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void Mult3X4(Matrix3By4 A,Matrix4By4 B,Matrix3By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
}

void Mult4X3(Matrix4By3 A,Matrix4By4 B,Matrix4By3 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[1][0]*B[0][1]+A[2][0]*B[0][2]+A[3][0]*B[0][3];
   C[1][0]=A[0][0]*B[1][0]+A[1][0]*B[1][1]+A[2][0]*B[1][2]+A[3][0]*B[1][3];
   C[2][0]=A[0][0]*B[2][0]+A[1][0]*B[2][1]+A[2][0]*B[2][2]+A[3][0]*B[2][3];
   C[3][0]=A[0][0]*B[3][0]+A[1][0]*B[3][1]+A[2][0]*B[3][2]+A[3][0]*B[3][3];
   C[0][1]=A[0][1]*B[0][0]+A[1][1]*B[0][1]+A[2][1]*B[0][2]+A[3][1]*B[0][3];
   C[1][1]=A[0][1]*B[1][0]+A[1][1]*B[1][1]+A[2][1]*B[1][2]+A[3][1]*B[1][3];
   C[2][1]=A[0][1]*B[2][0]+A[1][1]*B[2][1]+A[2][1]*B[2][2]+A[3][1]*B[2][3];
   C[3][1]=A[0][1]*B[3][0]+A[1][1]*B[3][1]+A[2][1]*B[3][2]+A[3][1]*B[3][3];
   C[0][2]=A[0][2]*B[0][0]+A[1][2]*B[0][1]+A[2][2]*B[0][2]+A[3][2]*B[0][3];
   C[1][2]=A[0][2]*B[1][0]+A[1][2]*B[1][1]+A[2][2]*B[1][2]+A[3][2]*B[1][3];
   C[2][2]=A[0][2]*B[2][0]+A[1][2]*B[2][1]+A[2][2]*B[2][2]+A[3][2]*B[2][3];
   C[3][2]=A[0][2]*B[3][0]+A[1][2]*B[3][1]+A[2][2]*B[3][2]+A[3][2]*B[3][3];
}

void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
   C[3][0]=A[3][0]*B[0][0]+A[3][1]*B[1][0]+A[3][2]*B[2][0]+A[3][3]*B[3][0];
   C[3][1]=A[3][0]*B[0][1]+A[3][1]*B[1][1]+A[3][2]*B[2][1]+A[3][3]*B[3][1];
   C[3][2]=A[3][0]*B[0][2]+A[3][1]*B[1][2]+A[3][2]*B[2][2]+A[3][3]*B[3][2];
   C[3][3]=A[3][0]*B[0][3]+A[3][1]*B[1][3]+A[3][2]*B[2][3]+A[3][3]*B[3][3];
}

float det2x2(float a,float b,float c,float d)
{ return(a*d-b*c);
}
float det3x3(float a1,float a2,float a3,float b1,float b2,float b3,float c1,float c2,float c3)
{ return(a1*det2x2(b2,b3,c2,c3)-b1*det2x2(a2,a3,c2,c3)+c1*det2x2(a2,a3,b2,b3));
}

void Adjoint(Matrix4By4 in, Matrix4By4 out,float det)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4;

 a1=in[0][0];b1=in[0][1];c1=in[0][2];d1=in[0][3];
 a2=in[1][0];b2=in[1][1];c2=in[1][2];d2=in[1][3];
 a3=in[2][0];b3=in[2][1];c3=in[2][2];d3=in[2][3];
 a4=in[3][0];b4=in[3][1];c4=in[3][2];d4=in[3][3];
 out[0][0]= det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)/det;
 out[1][0]=-det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)/det;
 out[2][0]= det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)/det;
 out[3][0]=-det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4)/det;
 out[0][1]=-det3x3(b1,b3,b4,c1,c3,c4,d1,d3,d4)/det;
 out[1][1]= det3x3(a1,a3,a4,c1,c3,c4,d1,d3,d4)/det;
 out[2][1]=-det3x3(a1,a3,a4,b1,b3,b4,d1,d3,d4)/det;
 out[3][1]= det3x3(a1,a3,a4,b1,b3,b4,c1,c3,c4)/det;
 out[0][2]= det3x3(b1,b2,b4,c1,c2,c4,d1,d2,d4)/det;
 out[1][2]=-det3x3(a1,a2,a4,c1,c2,c4,d1,d2,d4)/det;
 out[2][2]= det3x3(a1,a2,a4,b1,b2,b4,d1,d2,d4)/det;
 out[3][2]=-det3x3(a1,a2,a4,b1,b2,b4,c1,c2,c4)/det;
 out[0][3]=-det3x3(b1,b2,b3,c1,c2,c3,d1,d2,d3)/det;
 out[1][3]= det3x3(a1,a2,a3,c1,c2,c3,d1,d2,d3)/det;
 out[2][3]=-det3x3(a1,a2,a3,b1,b2,b3,d1,d2,d3)/det;
 out[3][3]= det3x3(a1,a2,a3,b1,b2,b3,c1,c2,c3)/det;
}

float det4x4(Matrix4By4 m)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4,ans;

 a1=m[0][0];b1=m[0][1];c1=m[0][2];d1=m[0][3];
 a2=m[1][0];b2=m[1][1];c2=m[1][2];d2=m[1][3];
 a3=m[2][0];b3=m[2][1];c3=m[2][2];d3=m[2][3];
 a4=m[3][0];b4=m[3][1];c4=m[3][2];d4=m[3][3];
 ans= a1*det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)
     -b1*det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)
     +c1*det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)
     -d1*det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4);
 return(ans);
}

int MatrixInvert(Matrix4By4 in,Matrix4By4 out)
{ float det;

  det=det4x4(in);
  if (fabs(det)<PRECISION_LIMIT)  /* NO INVERSE */
    return(0);
  Adjoint(in,out,det);
  return(1);
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta)
{ Matrix3By4 Pout;
  Matrix4By4 Rq;

 SetUpRotation(Q,W,Theta,Rq);
 Mult3X4(Pin,Rq,Pout);
 memcpy(Pin, Pout, sizeof(Matrix3By4));
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}

float RND01()
{ float num;

  num=(float)rand();
  return(num/IntMax);
}

/* number between -1 and 1 */
float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

int RNDSign()
{
  return((RND11()<0?-1:1));
}

float RND55()
{ float num;

  num=RND11();
  return(num/2);
}
int RND0x(int maxnum)
{ float num;
  int newnum;

   num=(float)rand();
   if (maxnum==0) return(0);
   newnum=(int)floor((++maxnum)*num/IntMax1);
   return(newnum>maxnum?maxnum:newnum);
}
BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}
void SpinnerOn(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	EnableWindow(GetDlgItem(hWnd,Winnum),TRUE);
	ReleaseISpinner(spin2);

};
void SpinnerOff(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	EnableWindow(GetDlgItem(hWnd,Winnum),FALSE);
	ReleaseISpinner(spin2);
};
BOOL SpinIsEnabled(HWND hWnd,int SpinNum)
{ BOOL ison;
  ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
  ison=spin2->IsEnabled();
  ReleaseISpinner(spin2);
  return(ison);
}

Point3 CalcSpread(float divangle,Point3 oldnorm)
{ float Q[3];
  Point3 r;

  Q[0]=Q[1]=Q[2]=0.0f;
  r=Point3(RND11(),RND11(),RND11());
  r=Normalize(r^oldnorm);
  RotateOnePoint(&oldnorm.x,Q,&r.x,RND01()*divangle);
  return(oldnorm);
}

Mtl *CMaterials(Mtl *mat1, Mtl *mat2, int &c1, int &c2)
	{	
	MultiMtl *multi = NewDefaultMultiMtl();
	
	// First count the mats
	if (mat1->IsMultiMtl()) {		
		c1 = mat1->NumSubMtls();

		// Special case: If mat2 is present in mat1 then they 
		// are already combined. We just need to compute the offset.		
		for (int i=0; i<c1; i++) {
			if (mat1->GetSubMtl(i)==mat2) {
				c1 = i;
				return mat1;
				}
			}		

	} else {
		c1 = 1;
		}
	if (mat2->IsMultiMtl()) {
		c2 = mat2->NumSubMtls();		
	} else {
		c2 = 1;
		}

	// Set the number of slots
	multi->SetNumSubMtls(c1+c2);

	// Copy in materials from first mat
	int i=0;
	if (mat1->IsMultiMtl()) {
		for (; i<c1; i++) {
			multi->SetSubMtl(i,mat1->GetSubMtl(i));
			}
	} else {
		multi->SetSubMtl(0,mat1);
		i++;
		}
	
	// And from second
	if (mat2->IsMultiMtl()) {
		for (; i<c1+c2; i++) {
			multi->SetSubMtl(i,mat2->GetSubMtl(i-c1));
			}
	} else {
		multi->SetSubMtl(c1,mat2);
		}
		
	return multi;
	}

int nummaps(TriObject *wrap1,TriObject *wrap2,BOOL hdist,int &inmap,int &dmap,BOOL proxy)
{ inmap=wrap1->GetMesh().getNumMaps();
  if (wrap2) dmap=wrap2->GetMesh().getNumMaps();
/*  int tpre1=0,tpre2=0;BOOL t1[2],t2[2];
  for (int i=0;i<2;i++)
  { t1[i]=(wrap1->GetMesh().mapSupport(i));
    if (t1[i]) tpre1++;
	t2[i]=(wrap2->GetMesh().mapSupport(i));
	if (t2[i]) tpre2++;
  } 
  int m1=inmap-tpre1,m2=dmap-tpre2;
  int lowc=(t1[0]||t2[0]?1:0)+(t1[1]||t2[1]?1:0),stmap=0;
  if (proxy) dmap=0;else {stmap=dmap;dmap=m1+2;}
  if (hdist) {inmap=0;return stmap;}
  stmap=inmap;inmap=m2+2;if (dmap==0) return stmap;
  return m1+m2+lowc;*/
  if (proxy) dmap=0;
  if (hdist) inmap=0;
  if ((inmap>2)&&(dmap>2)) return (inmap+dmap-2);
  else return (inmap>dmap?inmap:dmap);
}
void setmaps(Mesh *newMesh,Mesh *mesh,int omp,int &cmp,int rep)
{ int newmp,fnum=mesh->getNumFaces(),k;
  int l,j,tfaces=newMesh->getNumFaces(),deltafaces=tfaces-fnum;
  BOOL firstblk=(rep==0);if (firstblk) rep=1;
  int cnt=2;
  for (int mp=2;(cnt<omp)&&(mp<mmap); mp++) 
   { int dtv=mesh->getNumMapVerts(mp);
	 if (!mesh->mapSupport(mp))
	 {// newMesh->setMapSupport (newmp, FALSE);
	   continue;
	 }
	 newmp=++cmp;
	 newMesh->setMapSupport (newmp, TRUE);
	 newMesh->setNumMapFaces(newmp, tfaces);
	 TVFace *mapf = mesh->mapFaces(mp);
	 UVVert *mapv = mesh->mapVerts(mp);
	 TVFace *nmapf = newMesh->mapFaces(newmp);
	 newMesh->setNumMapVerts (mp,dtv+1);
	 for (j=0,k=0; j<mesh->getNumMapVerts(mp); j++)
	 {	newMesh->setMapVert (newmp, k, mapv[j]);	}
	 newMesh->setMapVert(newmp,dtv,Zero);
	 Face *flist=mesh->faces;int cnt=0;
	 if (firstblk)
	 { cnt=deltafaces;for (l=0;l<deltafaces;l++) nmapf[l].setTVerts(dtv,dtv,dtv);}
	 else {for (l=fnum;l<tfaces;l++) nmapf[l].setTVerts(dtv,dtv,dtv);}
	 for (int l=0;l<rep;l++)
	   for (j=0; j<fnum; j++) 
		{ nmapf[cnt] = mapf[j];cnt++;}
	 cnt++;
   }
}
void mapstuff(Mesh *newMesh,TriObject *wrappee,TriObject *wrapper,int oldmap,int wrappermap,int rep)
{  Mesh *mesh=&(wrapper->GetMesh()),*meshee=&(wrappee->GetMesh());
   int cmp=1;
   setmaps(newMesh,mesh,wrappermap,cmp,0);
   setmaps(newMesh,meshee,oldmap,cmp,rep);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\SPECKLE.CPP ===
/*===========================================================================*\
 |    File: Speckle.cpp
 |
 | Purpose: A 3D Map for creating speckled surface textures.
 |          This is a port of the 3D Studio/DOS SXP by Dan Silva.
 |
 | History: Mark Meier, Began 01/07/97.
 |          MM, Updated to used Parameter Maps on 01/29/97.
 |          MM, Last Change 01/30/97.
  		    Updated to Param Block2 by Peter Watje 12/1/1998
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"
#include "macrorec.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID speckleClassID(SPECKLE_CLASS_ID, 0);

// This is the number of colors used
#define NUM_COLORS 2

// This is the number of sub-texmaps used
#define NUM_SUB_TEXMAPS 2

// This is a scale factor applied to the values computed by the 
// function that does the speckling
#define SCALE_FACTOR 10.0f

// This is the version number of the IPAS SXP files that can be read
#define SPECKLE_SXP_VERSION 0xE001

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

#pragma pack(1)
struct SpeckleState {
	ulong version;
	float size;
	Col24 col1, col2;
};
#pragma pack()

// These are various resource IDs
static int colID[2] = { IDC_COL1, IDC_COL2 };
static int subTexId[NUM_SUB_TEXMAPS] = { IDC_TEX1, IDC_TEX2 };
static int mapOnId[NUM_SUB_TEXMAPS] = { IDC_MAPON1, IDC_MAPON2 };

// Forward references
//class Speckle;
//class SpeckleDlgProc;

/*===========================================================================*\
 | Speckle 3D Texture Map Plug-In Class
\*===========================================================================*/
class Speckle : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class SpeckleDlg;

	// This is the function that actually computes the speckling.
	float SpeckleFunc(Point3 p);

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];
	// This is the size parameter managed by the parameter map
	float size;
	// Color values manipulated by the parameter map
	Point3 col1, col2;
	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
	// These are the sub-texmaps.  If these are set by the user
	// then the color of our texture is affected by the sub-texmaps
	// and not the color swatches.
	// These are reference #2 and #3 of this class.
	Texmap *subTex[NUM_SUB_TEXMAPS];
	// Indicates if a sub-texmap is to be used or not
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	SpeckleDlg *paramDlg;

	public:
		static ParamDlg* xyzGenDlg;	
		BOOL mapOn[NUM_SUB_TEXMAPS];
		IParamBlock2 *pblock;
		// --- Methods inherited from Animatable ---
		Class_ID ClassID() { return speckleClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s =  GetString(IDS_DS_SPECKLE); }  
		void DeleteThis() { delete this; }	

		// We have 4 sub-animatables.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
		int NumSubs() { return 2+NUM_SUB_TEXMAPS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 4 references.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
 		int NumRefs() { return 2+NUM_SUB_TEXMAPS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		int NumSubTexmaps() { return NUM_SUB_TEXMAPS; }
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		// --- Methods inherited from Texmap ---
		XYZGen *GetTheXYZGen() { return xyzGen; }
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// --- Methods inherited from Tex3D ---
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods of Speckle ---
		Speckle();
		void SwapInputs(); 
		void NotifyChanged();
		void SetSize(float f, TimeValue t);
		void SetColor(int i, Color c, TimeValue t);
		void ClampFloat(float &f, float min, float max);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Speckle 3D Texture plug-in
class SpeckleClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Speckle; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_SPECKLE_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return speckleClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }

// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("speckle"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};
static SpeckleClassDesc speckleCD;
ClassDesc *GetSpeckleDesc() { return &speckleCD; }
ParamDlg* Speckle::xyzGenDlg;	

/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class SpeckleDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Speckle being edited.
		Speckle *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom buttons for texture maps
		ICustButton *iCustButton[NUM_SUB_TEXMAPS];
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue curTime; 
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;
		TexDADMgr dadMgr;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		int FindSubTexFromHWND(HWND hw);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void DeleteThis() { delete this; }

		// --- SpeckleDlg Methods ---
		SpeckleDlg(HWND hwMtlEdit, IMtlParams *imp, Speckle *m); 
		~SpeckleDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void UpdateSubTexNames();
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/
/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_SIZE 0
#define PB_COL1 1
#define PB_COL2 2
*/
// Spinner limits
#define MIN_SIZE 0.001f
#define MAX_SIZE 999999999.0f

// Paramter block version number
#define SPECKLE_PB_VERSION 2

enum { speckle_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	speckle_size,
	speckle_color1, speckle_color2,
	speckle_map1, speckle_map2,
	speckle_mapon1,speckle_mapon2,
	speckle_coords,	  // access for UVW mapping
};

static ParamBlockDesc2 speckle_param_blk ( speckle_params, _T("parameters"),  0, &speckleCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_SPECKLE, IDS_DS_SPECKLE_PARAMS, 0, 0, NULL, 
	// params


	speckle_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_SIZE,
		p_default,		60.f,
		p_range,		MIN_SIZE, MAX_SIZE,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN, 0.1f, 
		end,
	speckle_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.2f, 0.5f, 1.0f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	speckle_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(0.7f, 0.8f, 0.8f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,
	speckle_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX1,
		end,
	speckle_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX2,
		end,
	speckle_mapon1,	_T("map1On"), TYPE_BOOL,			0,				IDS_PW_MAPON1,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	speckle_mapon2,	_T("map2On"), TYPE_BOOL,			0,				IDS_PW_MAPON2,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	speckle_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);

/*
// Array of parameter descriptors
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2)
};
*/
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 3

// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_FLOAT, NULL, TRUE, speckle_size }, // size 
	{ TYPE_RGBA,  NULL, TRUE, speckle_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE, speckle_color2 }  // color 2
};
// The number of parameters in the parameter block
#define PB_LENGTH 3

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,3,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = { IDS_DS_SIZE, IDS_DS_COL1, IDS_DS_COL2 };

/*
// This is the class that allows the sub-map buttons to be processed.
class SpeckleDlgProc : public ParamMapUserDlgProc {
	public:
		SpeckleDlg *theDlg;
		SpeckleDlgProc(SpeckleDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL SpeckleDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

BOOL SpeckleDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], theTex->GetSubTexmapSlotName(i).data());
			for (i = 0; i < NUM_SUB_TEXMAPS; i++) {
				iCustButton[i] = GetICustButton(GetDlgItem(hWnd, subTexId[i]));
				iCustButton[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hWnd, mapOnId[i], theTex->mapOn[i]);
			}
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_TEX1: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 0, (LPARAM)theTex);
					break;

				case IDC_TEX2: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 1, (LPARAM)theTex);
					break;

				case IDC_SWAP: {
					theTex->SwapInputs(); 
					IParamBlock *pb = (IParamBlock *)pmap->GetParamBlock();
					pb->SetValue(PB_COL1, curTime, theTex->col[0]);
					pb->SetValue(PB_COL2, curTime, theTex->col[1]);
					pmap->Invalidate();
					UpdateSubTexNames();
					UpdateMtlDisplay();
					theTex->NotifyChanged();
					}
					break;

				case IDC_MAPON1:
					theTex->mapOn[0] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_MAPON2:
					theTex->mapOn[1] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;
			}
			break;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/
/*===========================================================================*\
 | SpeckleDlg Methods
\*===========================================================================*/
// --- SpeckleDlg Methods ---
// Constructor.
// This is called from within the Speckle::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
SpeckleDlg::SpeckleDlg(HWND hwMtlEdit, IMtlParams *imp, Speckle *m) { 
	dadMgr.Init(this);
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	curTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_SPECKLE),
		GetString(IDS_DS_SPECKLE_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new SpeckleDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Speckle texture.
// Note that it is not called if they do go to another Speckle -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside SpeckleDlg::SetThing()).
SpeckleDlg::~SpeckleDlg() {
	theTex->paramDlg = NULL;
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		ReleaseICustButton(iCustButton[i]);
		iCustButton[i] = NULL; 
	}
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}


// This is called by the DADMgr
int SpeckleDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NUM_SUB_TEXMAPS; i++) {
		if (hw == iCustButton[i]->GetHwnd()) return i;
		}	
	return -1;
	}


// This is called when the dialog is loaded to set the names of the
// textures displayed
void SpeckleDlg::UpdateSubTexNames() {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		TSTR nm;
		Texmap *m = theTex->subTex[i];
		if (m) 	
			nm = m->GetFullName();
		else
			nm = GetString(IDS_DS_NONE);
		iCustButton[i]->SetText(nm.data());
	}
}

// Update the dialog display with the values of the texture we are
// currently editing.
void SpeckleDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(curTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);

		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) 
			SetCheckBox(hParamDlg, mapOnId[i], theTex->mapOn[i]);

		UpdateSubTexNames();
	}
}

// This method invalidates the rollup page so it will get redrawn
void SpeckleDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID SpeckleDlg::ClassID() {
	return speckleClassID; 
}

// This sets the current texture being edited to the texture passed
void SpeckleDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == speckleClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Speckle *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *SpeckleDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void SpeckleDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != curTime) {
		xyzGenDlg->SetTime(t);
		curTime = t;
		theTex->Update(curTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void SpeckleDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(curTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void SpeckleDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}
*/
//dialog stuff to get the Set Ref button
class SpeckleDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Speckle *speckle;		
		SpeckleDlgProc(Speckle *m) {speckle = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
		void SetThing(ReferenceTarget *m) {
			speckle = (Speckle*)m;
			}

	};



BOOL SpeckleDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_SWAP:
					{
					speckle = (Speckle*)map->GetParamBlock()->GetOwner(); 

					speckle->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}


/*===========================================================================*\
 | Speckle Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Speckle::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
	}
}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Speckle::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return GetSubTexmapTVName(i-2);
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Speckle::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
	}
}

// Save the 'i-th' reference
void Speckle::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Speckle::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			texValidity.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				speckle_param_blk.InvalidateUI(changing_param);
				}

			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget != xyzGen) {
//				if (paramDlg) 
//					paramDlg->pmap->Invalidate();
//			}
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_SIZE: gpd->dim =  stdWorldDim; 	break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define SPECKLE_VERS1_CHUNK		0x4001
#define MAPOFF_CHUNK			0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Speckle::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();
	// Save a version number chunk
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();
/*
	isave->BeginChunk(SPECKLE_VERS1_CHUNK);
	isave->EndChunk();
	// Save the on/off status of the sub-texmaps
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (mapOn[i] == 0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
		}
	}
*/
	return IO_OK;
}


class SpecklePostLoad : public PostLoadCallback {
	public:
		Speckle *n;
		BOOL Param1;
		SpecklePostLoad(Speckle *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( speckle_mapon1, 0, n->mapOn[0]);
				n->pblock->SetValue( speckle_mapon2, 0, n->mapOn[1]);
				}
			delete this; 


			} 
	};



// This is called by the system to allow the plug-in to load its data
IOResult Speckle::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	BOOL Param1 = TRUE;

	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case SPECKLE_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1 = FALSE;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				// Set the sub-texmap on/off settings
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}
	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &speckle_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new SpecklePostLoad(this,Param1));

	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Speckle::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Speckle *newSpeckle = new Speckle();

	// Copy the superclass stuff
	*((MtlBase *)newSpeckle) = *((MtlBase *)this);

	// Clone the items we reference
	newSpeckle->ReplaceReference(0,remap.CloneRef(xyzGen));
	newSpeckle->ReplaceReference(1,remap.CloneRef(pblock));
	newSpeckle->col[0] = col[0];
	newSpeckle->col[1] = col[1];
	newSpeckle->size = size;
	newSpeckle->texValidity.SetEmpty();	
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		newSpeckle->subTex[i] = NULL;
		newSpeckle->mapOn[i] = mapOn[i];
		if (subTex[i])
			newSpeckle->ReplaceReference(i+2, remap.CloneRef(subTex[i]));
	}
	// Return the new cloned texture
	return (RefTargetHandle)newSpeckle;
}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Speckle::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
}

// This method is called to reset the texmap back to its default values.
void Speckle::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	

	// Set the inital colors and size
	SetColor(0, Color(0.2f, 0.5f, 1.0f), TimeValue(0));
	SetColor(1, Color(0.7f, 0.8f, 0.8f), TimeValue(0));
	SetSize(60.0f, TimeValue(0));
	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
}

void Speckle::Reset() {
	speckleCD.Reset(this, TRUE);	// reset all pb2's
	// Delete the references to the two sub-texture maps
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

Speckle::Speckle() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	mapOn[0] = mapOn[1] = 1;
	speckleCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
}

// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Speckle::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	SpeckleDlg *speckleDlg = new SpeckleDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	speckleDlg->LoadDialog();
//	paramDlg = speckleDlg;
//	return speckleDlg;
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = speckleCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	speckle_param_blk.SetUserDlgProc(new SpeckleDlgProc(this));

	return masterDlg;
	
}

// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Speckle::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
//		pblock->GetValue(PB_COL1, t, col[0], texValidity);
		pblock->GetValue(speckle_color1, t, col[0], texValidity);
		col[0].ClampMinMax();
//		pblock->GetValue(PB_COL2, t, col[1], texValidity);
		pblock->GetValue(speckle_color2, t, col[1], texValidity);
		col[1].ClampMinMax();
//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(speckle_size, t, size, texValidity);
		pblock->GetValue(speckle_mapon1, t, mapOn[0], texValidity);
		pblock->GetValue(speckle_mapon2, t, mapOn[1], texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE); 
		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t, texValidity);
		}
	}
	ivalid &= texValidity;
}

BOOL Speckle::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}


void Speckle::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

// Returns a pointer to the 'i-th' sub-texmap managed by this texture.
Texmap *Speckle::GetSubTexmap(int i) { 
	return subTex[i]; 
}

// Stores the 'i-th' sub-texmap managed by the material or texture.
void Speckle::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2, m);
	if (i==0)
		{
		speckle_param_blk.InvalidateUI(speckle_map1);
		texValidity.SetEmpty();
		}
	else if (i==1)
		{
		speckle_param_blk.InvalidateUI(speckle_map2);
		texValidity.SetEmpty();
		}

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
}

// This name appears in the materials editor dialog when editing the
// 'i-th' sub-map.
TSTR Speckle::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_COL1); 
		case 1:  return GetString(IDS_DS_COL2); 
		default: return TSTR(_T(""));
	}
}
	 
// --- Methods inherited from Texmap ---
RGBA Speckle::EvalColor(ShadeContext& sc) {
	// After being evaluated, if a map or material has a non-zero gbufID, 
	// it should call ShadeContext::SetGBuffer() to store it into 
	// the shade context.
	if (gbufID) 
		sc.SetGBufferID(gbufID);

	// Use the XYZGen instance to get a transformed point from the
	// ShadeContext.
	Point3 p, dp;
	xyzGen->GetXYZ(sc, p, dp);
	if (size == 0.0f) 
		size = 0.0001f;
	p *= SCALE_FACTOR/size;

	float d = SpeckleFunc(p);
	if (d>1.0f) d = 1.0f;

	// If we have sub-texmaps and they are enabled, get the colors from 
	// the sub-texmaps, otherwise get them from the color swatch
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];

	// Composite the colors together and return the result.
	return (1.0f-d)*c0 + d*c1;
}

Point3 Speckle::EvalNormalPerturb(ShadeContext& sc) {
	float del, d;
	Point3 p, dp;
	Point3 np;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);
	if (size == 0.0f) 
		size = 0.0001f;
	p *= SCALE_FACTOR/size;

	del = 0.1f;
	d = SpeckleFunc(p);
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
    np.x = (SpeckleFunc(p+del*M[0]) - d)/del;
	np.y = (SpeckleFunc(p+del*M[1]) - d)/del;
	np.z = (SpeckleFunc(p+del*M[2]) - d)/del;

	return sc.VectorFromNoScale(np,REF_OBJECT);
}

// --- Methods inherited from Tex3D ---
void Speckle::ReadSXPData(TCHAR *name, void *sxpdata) {
	SpeckleState *state = (SpeckleState*)sxpdata;
	if (state != NULL && (state->version == SPECKLE_SXP_VERSION)) {
		SetColor(0, ColorFromCol24(state->col1), TimeValue(0));
		SetColor(1, ColorFromCol24(state->col2), TimeValue(0));
		SetSize(state->size, TimeValue(0));
	}
}

// --- Methods of Speckle ---

float Speckle::SpeckleFunc(Point3 p) {
	float sum, s, q[3];

	s = 1.0f;
	sum = 0.0f;
	q[0] = p.x; q[1] = p.y; q[2] = p.z;
	for (int i = 0; i < 6; i++) {
		sum += NOISE(q)/s;
		s *= 2.0f;
		q[0] *= 2.0f; q[1] *= 2.0f; q[2] *= 2.0f;
	}
	return(sum);
}

void Speckle::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void Speckle::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
//	pblock->SwapControllers(PB_COL1, PB_COL2);
	pblock->SwapControllers(speckle_color1,0, speckle_color2,0);
	speckle_param_blk.InvalidateUI(speckle_color1);
	speckle_param_blk.InvalidateUI(speckle_color2);
	speckle_param_blk.InvalidateUI(speckle_map1);
	speckle_param_blk.InvalidateUI(speckle_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
}

void Speckle::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue((i == 0) ? PB_COL1 : PB_COL2, t, c);
	pblock->SetValue((i == 0) ? speckle_color1 : speckle_color2, t, c);
}

void Speckle::SetSize(float f, TimeValue t) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(speckle_size, t, f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\procmap\WATER.CPP ===
/*===========================================================================*\
 |    File: Water.cpp
 |
 | Purpose: A 3D Map for creating watery and wavy effects.
 |          This is a port of the 3D Studio/DOS SXP by Dan Silva.
 |
 | History: Mark Meier, Began 02/06/97.
 |          MM, Last Change 02/07/97.
			Updated to Param Block2 by Peter Watje 12/1/1998
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "procmaps.h"
#include "iparamm2.h"
#include "resource.h"
#include "macrorec.h"

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassID
static Class_ID waterClassID(WATER_CLASS_ID, 0);
// This is the number of colors used
#define NUM_COLORS 2

// This is the number of sub-texmaps used
#define NUM_SUB_TEXMAPS 2

// This is the version number of the IPAS SXP files that can be read
#define WATER_SXP_VERSION 0x1D0A45EF

struct Col24 {
	ULONG r, g, b; 
};

static Color ColorFromCol24(Col24 a) {
	Color c;
	c.r = (float)a.r/255.0f;
	c.g = (float)a.g/255.0f;
	c.b = (float)a.b/255.0f;
	return c;
}

static Col24 Col24FromColor(Color a) {
	Col24 c;
	c.r = (ULONG)(a.r*255.0f);
	c.g = (ULONG)(a.g*255.0f);
	c.b = (ULONG)(a.b*255.0f);
	return c;
}

#pragma pack(1)
struct WaterState {
	ulong version;
	ulong count;
	ulong type;
	float size;
	float minperiod;
	float maxperiod;
	float amp;
	float speed;
	Col24 col1,col2;
	long startframe,endframe;
};
#pragma pack()

// These are various resource IDs
static int colID[2] = { IDC_COL1, IDC_COL2 };
static int subTexId[NUM_SUB_TEXMAPS] = { IDC_TEX1, IDC_TEX2 };
static int mapOnId[NUM_SUB_TEXMAPS] = { IDC_MAPON1, IDC_MAPON2 };

// Forward references
//class Water;
//class WaterDlgProc;

/*===========================================================================*\
 | Water/Wave Functions and Definitions
\*===========================================================================*/

// returns random number in [-1.0,1.0] 
float frand() {
	float r =  ((float)(rand()&0x7FFF))/16384.0f - 1.0f;
	return(r);
	}

static float LerpFraction(int fld, int f1, int f2) {
	int nflds, fld1,fld2;
	fld1 = 2*f1;
	fld2 = 2*f2;
	if (fld>=fld2) return(1.0f);
	else if (fld<=fld1) return(0.0f);
	else {
		nflds = fld2-fld1;
		if (nflds<=0) return(1.0f);
		else return((float)(fld-fld1)/((float)nflds));
	}
}

struct WaveDesc {
	float cent[3];
	float period;
	float rate;
	};

/*===========================================================================*\
 | Water 3D Texture Map Plug-In Class
\*===========================================================================*/
class Water : public Tex3D { 
	// This allows the class that manages the UI to access the private 
	// data members of this class.
//	friend class WaterDlg;

	// These are the current colors from the color swatch controls.
	Color col[NUM_COLORS];

	// These are the parameters managed by the parameter map
	int count;			// Num Wave Sets
	int type;			// 2D or 3D
	int randSeed;       // Random number seed
	float size;			// Wave radius
	float minperiod;	// Wave len min
	float maxperiod;	// Wave len max
	float amp;			// Amlitude
	float phase;		// PHase

	Tab<WaveDesc> waves;

	Point3 col1, col2;

	// This points to the XYZGen instance used to handle the 
	// 'Coordinates' rollup in the materials editor.
	// This is reference #0 of this class.
	XYZGen *xyzGen;
	// These are the sub-texmaps.  If these are set by the user
	// then the color of our texture is affected by the sub-texmaps
	// and not the color swatches.
	// These are reference #2 and #3 of this class.
	Texmap *subTex[NUM_SUB_TEXMAPS];
	// This holds the validity interval of the texmap.
	Interval texValidity;
	// This is the version of the texture loaded from disk.
	int fileVersion;
	// This points to the ParamDlg instance used to manage the UI
//	WaterDlg *paramDlg;

	public:
		static ParamDlg* xyzGenDlg;	
	// Indicates if a sub-texmap is to be used or not
		BOOL mapOn[NUM_SUB_TEXMAPS];
	// This is the parameter block which manages the data for the
	// spinner and color swatch controls.
	// This is reference #1 of this class.
		IParamBlock2 *pblock;

		// --- Methods inherited from Animatable ---
		Class_ID ClassID() { return waterClassID; }
		SClass_ID SuperClassID() { return TEXMAP_CLASS_ID; }
		void GetClassName(TSTR& s) { s= GetString(IDS_DS_WATER); }  
		void DeleteThis() { delete this; }	

		// We have 4 sub-animatables.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
		int NumSubs() { return 2+NUM_SUB_TEXMAPS; }  
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) { return subNum; }

		// --- Methods inherited from ReferenceMaker ---
		// We have 4 references.  These are the xyzGen, 
		// the pblock, and the two sub-texmaps
 		int NumRefs() { return 2+NUM_SUB_TEXMAPS; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval changeInt, 
			RefTargetHandle hTarget, PartID& partID, RefMessage message);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// --- Methods inherited from ReferenceTarget ---
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// --- Methods inherited from MtlBase ---
		ULONG LocalRequirements(int subMtlNum) { 
			return xyzGen->Requirements(subMtlNum); 
		}
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
			xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
		}
		void Update(TimeValue t, Interval& ivalid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		int NumSubTexmaps() { return NUM_SUB_TEXMAPS; }
		Texmap* GetSubTexmap(int i);
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		// --- Methods inherited from Texmap ---
		XYZGen *GetTheXYZGen() { return xyzGen; }
		RGBA EvalColor(ShadeContext& sc);
		Point3 EvalNormalPerturb(ShadeContext& sc);

		// --- Methods inherited from Tex3D ---
		void ReadSXPData(TCHAR *name, void *sxpdata);

		// --- Methods of Water ---
		Water();
		void SwapInputs(); 
		void NotifyChanged();
		void SetNum(int i, TimeValue t, BOOL init = FALSE);
		void SetSize(float f, TimeValue t, BOOL init = FALSE);
		void SetLenMin(float f, TimeValue t, BOOL init = FALSE);
		void SetLenMax(float f, TimeValue t, BOOL init = FALSE);
		void SetAmp(float f, TimeValue t, BOOL init = FALSE);
		void SetPhase(float f, TimeValue t, BOOL init = FALSE);
		void SetColor(int i, Color c, TimeValue t);
		void SetRandSeed(int i, BOOL init = FALSE);
		void ClampFloat(float &f, float min, float max);
		void ClampInt(int &i, int min, int max);
		float swave(float *v, float rate);
		float ScalarWave(float *p);
		void VectorWave(Point3 &p, Point3 &n);
		void vwave(float *v, float rate, float *w);
		void ReInit();
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

};

// This is the Class Descriptor for the Water 3D Texture plug-in
class WaterClassDesc : public ClassDesc2 {
	public:
		int 			IsPublic() { return 1; }
		void *			Create(BOOL loading) { 	return new Water; }
		const TCHAR *	ClassName() { return GetString(IDS_DS_WATER_CDESC); } // mjm - 2.3.99
		SClass_ID		SuperClassID() { return TEXMAP_CLASS_ID; }
		Class_ID 		ClassID() { return waterClassID; }
		const TCHAR* 	Category() { return TEXMAP_CAT_3D; }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
		const TCHAR*	InternalName() { return _T("water"); }	// returns fixed parsable name (scripter-visible name)
		HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle

};
static WaterClassDesc waterCD;
ClassDesc *GetWaterDesc() { return &waterCD; }

ParamDlg* Water::xyzGenDlg;	


/*===========================================================================*\
 | Class to Manage the User Interface in the Materials Editor
\*===========================================================================*/
/*
class WaterDlg: public ParamDlg {
	public:
		// This is our UI rollup page window handle in the materials editor
		HWND hParamDlg;
		// Window handle of the materials editor dialog itself
		HWND hMedit;
		// Interface for calling methods provided by MAX
		IMtlParams *ip;
		// The current Water being edited.
		Water *theTex;
		// Parameter Map for handling UI controls
		IParamMap *pmap;
		// Custom buttons for texture maps
		ICustButton *iCustButton[NUM_SUB_TEXMAPS];
		// Custom conrols for the colors
		IColorSwatch *cs[NUM_COLORS];
		// This is used inside the SetTime method to only update the UI
		// controls when the time slider has changed
		TimeValue cTime; 
		// Point to the XYZGenDlg we use
		ParamDlg *xyzGenDlg;
		BOOL valid;
		BOOL isActive;
		TexDADMgr dadMgr;

		// --- Methods inherited from ParamDlg ---
		Class_ID ClassID();
		void SetThing(ReferenceTarget *m);
		ReferenceTarget* GetThing();
		void SetTime(TimeValue t);
		int FindSubTexFromHWND(HWND hw);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff);
		void DeleteThis() { delete this; }

		// --- WaterDlg Methods ---
		WaterDlg(HWND hwMtlEdit, IMtlParams *imp, Water *m); 
		~WaterDlg();
		BOOL PanelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void UpdateSubTexNames();
		void LoadDialog();
		void UpdateMtlDisplay() { ip->MtlChanged(); }
		void Invalidate();
};
*/

/*===========================================================================*\
 | Noise and Lerp Functions
\*===========================================================================*/
static void lerp_color(Col24 *c, Col24 *a, Col24 *b, float f) {
	int alph = (int)(4096*f);
	int ialph = 4096-alph;
	c->r = (ialph*a->r + alph*b->r)>>12;
	c->g = (ialph*a->g + alph*b->g)>>12;
	c->b = (ialph*a->b + alph*b->b)>>12;
}

/*===========================================================================*\
 | Parameter Map Related Data and Methods
\*===========================================================================*/
// Parameter block indices
/*
#define PB_NUM		0
#define PB_SIZE		1
#define PB_LEN_MIN	2 
#define PB_LEN_MAX	3
#define PB_AMP		4
#define PB_PHASE	5
#define PB_TYPE		6
#define PB_COL1		7
#define PB_COL2		8
#define PB_SEED		9
*/

// Spinner limits
#define MIN_NUM 1
#define MAX_NUM 50

#define MIN_SIZE 0.0001f
#define MAX_SIZE 999999999.0f

#define MIN_LEN_MIN 0.0f
#define MAX_LEN_MIN 999999999.0f

#define MIN_LEN_MAX 0.0f
#define MAX_LEN_MAX 999999999.0f

#define MIN_AMP 0.0f
#define MAX_AMP 10000.0f

#define MIN_SPEED 0.0f
#define MAX_SPEED 10000.0f

// Paramter block version number
#define WATER_PB_VERSION 2

// Resource IDs of the radio buttons
static int typeIDs[] = { IDC_RADIO_3D, IDC_RADIO_2D };

// Array of parameter descriptors
/*
static ParamUIDesc paramDesc[] = {
	ParamUIDesc(
		PB_NUM, 
		EDITTYPE_INT, 
		IDC_NUM_EDIT,IDC_NUM_SPIN, 
		MIN_NUM, MAX_NUM, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_SIZE, 
		EDITTYPE_FLOAT, 
		IDC_SIZE_EDIT,IDC_SIZE_SPIN, 
		MIN_SIZE, MAX_SIZE, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_LEN_MIN, 
		EDITTYPE_FLOAT, 
		IDC_LEN_MIN_EDIT,IDC_LEN_MIN_SPIN, 
		MIN_LEN_MIN, MAX_LEN_MIN, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_LEN_MAX, 
		EDITTYPE_FLOAT, 
		IDC_LEN_MAX_EDIT,IDC_LEN_MAX_SPIN, 
		MIN_LEN_MAX, MAX_LEN_MAX, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_AMP, 
		EDITTYPE_FLOAT, 
		IDC_AMP_EDIT,IDC_AMP_SPIN, 
		MIN_AMP, MAX_AMP, 
		SPIN_AUTOSCALE), 

	ParamUIDesc(
		PB_PHASE, 
		EDITTYPE_FLOAT, 
		IDC_SPEED_EDIT,IDC_SPEED_SPIN, 
		MIN_SPEED, MAX_SPEED, 
		SPIN_AUTOSCALE),

	ParamUIDesc(PB_TYPE, TYPE_RADIO, typeIDs, 2),

	ParamUIDesc(PB_COL1, TYPE_COLORSWATCH, IDC_COL1),
	ParamUIDesc(PB_COL2, TYPE_COLORSWATCH, IDC_COL2),
	ParamUIDesc(
		PB_SEED, 
		EDITTYPE_INT, 
		IDC_RSEED_EDIT,IDC_RSEED_SPIN, 
		0, 65535, 
		SPIN_AUTOSCALE), 
};
*/

enum { water_params };  // pblock ID
// grad_params param IDs
enum 
{ 
	water_num,water_size,water_len_min,water_len_max,
	water_amp,water_phase,water_type,
	water_seed,
	water_color1, water_color2,
	water_map1, water_map2,
	water_mapon1,water_mapon2,
	water_coords,	  // access for UVW mapping
};

static ParamBlockDesc2 water_param_blk ( water_params, _T("parameters"),  0, &waterCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 1, 
	//rollout
	IDD_WATER, IDS_DS_WATER_PARAMS, 0, 0, NULL, 
	// params

	water_num,	_T("numWaveSets"),   TYPE_INT,			P_ANIMATABLE,	IDS_DS_NUMWAVSETS,
		p_default,		10,
		p_range,		MIN_NUM, MAX_NUM,
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_NUM_EDIT,IDC_NUM_SPIN, 1.0f, 
		end,


	water_size,	_T("waveRadius"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WAVERAD,
		p_default,		800.f,
		p_range,		MIN_SIZE, MAX_SIZE, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SIZE_EDIT,IDC_SIZE_SPIN,  0.1f, 
		end,

	water_len_min,	_T("waveLenMin"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WAVELENMIN,
		p_default,		5.f,
		p_range,		MIN_LEN_MIN, MAX_LEN_MIN, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LEN_MIN_EDIT,IDC_LEN_MIN_SPIN, 0.1f, 
		end,
	water_len_max,	_T("waveLenMax"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_WAVELENMAX,
		p_default,		50.f,
		p_range,		MIN_LEN_MAX, MAX_LEN_MAX,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_LEN_MAX_EDIT,IDC_LEN_MAX_SPIN, 0.1f, 
		end,


	water_amp,	_T("amplitude"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_AMPL,
		p_default,		1.f,
		p_range,		MIN_AMP, MAX_AMP, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_AMP_EDIT,IDC_AMP_SPIN, 0.1f, 
		end,
	water_phase,	_T("phase"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_DS_PHASE,
		p_default,		0.f,
		p_range,		MIN_SPEED, MAX_SPEED, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_SPEED_EDIT,IDC_SPEED_SPIN, 0.1f, 
		end,
	water_type, _T("distribution"), TYPE_INT,				0,				IDS_PW_DISTRIBUTION,
		p_default,		0,
		p_range,		0,	1,
		p_ui,			TYPE_RADIO, 2, IDC_RADIO_3D, IDC_RADIO_2D,
		end,

	water_seed,	_T("randomSeed"),   TYPE_INT,			0,	IDS_PW_RSEED,
		p_default,		30159,
		p_range,		0, 65535, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_INT, IDC_RSEED_EDIT,IDC_RSEED_SPIN, 1.0f, 
		end,

	water_color1,	 _T("color1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL1,	
		p_default,		Color(0.78f, 0.78f, 0.94f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL1, 
		end,
	water_color2,	 _T("color2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_DS_COL2,	
		p_default,		Color(0.1f, 0.1f, 0.78f), 
		p_ui,			TYPE_COLORSWATCH, IDC_COL2, 
		end,

	water_map1,		_T("map1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP1,
		p_refno,		2,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX1,
		end,
	water_map2,		_T("map2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_PW_MAP2,
		p_refno,		3,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_TEX2,
		end,
	water_mapon1,	_T("map1On"), TYPE_BOOL,			0,				IDS_PW_MAPON1,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON1,
		end,
	water_mapon2,	_T("map2On"), TYPE_BOOL,			0,				IDS_PW_MAPON2,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_MAPON2,
		end,
	water_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDINATES,
		p_refno,		0, 
		end,

	end
);
// The number of descriptors in the paramDesc array
#define PARAMDESC_LENGTH 10

// Parameter block parameters	
static ParamBlockDescID pbdesc[] = {
	{ TYPE_INT,   NULL, TRUE,  water_num }, // count
	{ TYPE_FLOAT, NULL, TRUE,  water_size}, // size
	{ TYPE_FLOAT, NULL, TRUE,  water_len_min }, // len_min
	{ TYPE_FLOAT, NULL, TRUE,  water_len_max }, // len_max
	{ TYPE_FLOAT, NULL, TRUE,  water_amp }, // amp
	{ TYPE_FLOAT, NULL, TRUE,  water_phase }, // phase
	{ TYPE_INT,   NULL, FALSE, water_type }, // type
	{ TYPE_RGBA,  NULL, TRUE,  water_color1 }, // color 1
	{ TYPE_RGBA,  NULL, TRUE,  water_color2 },  // color 2
	{ TYPE_INT,  NULL, FALSE,  water_seed }  // randSeed
};
// The number of parameters in the parameter block
#define PB_LENGTH 10

static ParamVersionDesc versions[] = {
	ParamVersionDesc(pbdesc,10,1)	// Version 1 params
	};

// The names of the parameters in the parameter block
static int nameIDs[] = {
	IDS_DS_NUMWAVSETS, IDS_DS_WAVERAD, IDS_DS_WAVELENMIN,
	IDS_DS_WAVELENMAX, IDS_DS_AMPL, IDS_DS_PHASE, IDS_DS_TYPE,
	IDS_DS_COL1, IDS_DS_COL2, IDS_DS_SEED };

// This is the class that allows the sub-map buttons to be processed.
/*
class WaterDlgProc : public ParamMapUserDlgProc {
	public:
		WaterDlg *theDlg;
		WaterDlgProc(WaterDlg *s) { theDlg = s; }
		BOOL DlgProc(TimeValue t, IParamMap *map,
			HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { delete this; }
};

// This is the dialog proc to process the texmap buttons
BOOL WaterDlgProc::DlgProc(TimeValue t, IParamMap *map,
	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	theDlg->isActive = TRUE;
	BOOL res = theDlg->PanelProc(hWnd, msg, wParam, lParam);
	theDlg->isActive = FALSE;
	return res;
}

BOOL WaterDlg::PanelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG: {
			for (int i = 0; i < NUM_COLORS; i++) 
   				cs[i] = GetIColorSwatch(GetDlgItem(hParamDlg, colID[i]),
   					theTex->col[i], theTex->GetSubTexmapSlotName(i).data());
			for (i = 0; i < NUM_SUB_TEXMAPS; i++) {
				iCustButton[i] = GetICustButton(GetDlgItem(hWnd, subTexId[i]));
				iCustButton[i]->SetDADMgr(&dadMgr);
				SetCheckBox(hWnd, mapOnId[i], theTex->mapOn[i]);
			}
			return TRUE;
		}
		break;

		case WM_COMMAND:  
		    switch (id) {
				case IDC_TEX1: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 0, (LPARAM)theTex);
					break;

				case IDC_TEX2: 
					PostMessage(hMedit, WM_TEXMAP_BUTTON, 1, (LPARAM)theTex);
					break;

				case IDC_SWAP: {
					theTex->SwapInputs(); 
					IParamBlock *pb = (IParamBlock *)pmap->GetParamBlock();
					pb->SetValue(PB_COL1, cTime, theTex->col[0]);
					pb->SetValue(PB_COL2, cTime, theTex->col[1]);
					pmap->Invalidate();
					UpdateSubTexNames();
					UpdateMtlDisplay();
					theTex->NotifyChanged();
					}
					break;

				case IDC_MAPON1:
					theTex->mapOn[0] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;

				case IDC_MAPON2:
					theTex->mapOn[1] = GetCheckBox(hWnd, id);
					theTex->NotifyChanged();
					UpdateMtlDisplay();
					break;
			}
			break;

		case CC_SPINNER_BUTTONUP:
		case WM_CUSTEDIT_ENTER: {
			theTex->ReInit();
			theTex->NotifyChanged();
		    UpdateMtlDisplay();
			break;
		}

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		case WM_PAINT: 	
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
			}
			break;

		case WM_CLOSE: 
			break;       

		case WM_DESTROY: 
			break;
   	}
	return FALSE;
}
*/
/*===========================================================================*\
 | WaterDlg Methods
\*===========================================================================*/
// --- WaterDlg Methods ---
// Constructor.
// This is called from within the Water::CreateParamDlg method.  That
// method is passed the handle to the materials editor dialog, and an
// interface for calling methods of MAX.  These are passed in here and stored.
/*
WaterDlg::WaterDlg(HWND hwMtlEdit, IMtlParams *imp, Water *m) { 
	dadMgr.Init(this);
	hMedit = hwMtlEdit;
	ip = imp;
	theTex = m; 
    valid = FALSE;
    isActive = FALSE;
	cTime = ip->GetTime();

	// This call allocates a new instance of the XYZGen class
	xyzGenDlg = theTex->xyzGen->CreateParamDlg(hMedit, imp);

	// Creates a parameter map to handle the display of texture map 
	// parameters in the material editor
	pmap = CreateMParamMap(paramDesc, PARAMDESC_LENGTH,
		theTex->pblock, ip, hInstance, MAKEINTRESOURCE(IDD_WATER),
		GetString(IDS_DS_WATER_PARAMS), 0);

	// Save the window handle of the rollup page
	hParamDlg = pmap->GetHWnd();

	// Establish the dialog proc to handle the custom button controls
	pmap->SetUserDlgProc(new WaterDlgProc(this));
}

// Destructor.
// This is called after the user changes to another sample slot in
// the materials editor that does not contain a Water texture.
// Note that it is not called if they do go to another Water -- in
// that case, the parameters in the rollup page are updated, but
// the entire page is not deleted.  This is accomplished by simply
// changing the parameter block pointer (done inside WaterDlg::SetThing()).
WaterDlg::~WaterDlg() {
	theTex->paramDlg = NULL;
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		ReleaseICustButton(iCustButton[i]);
		iCustButton[i] = NULL; 
	}
	// Delete the XYZGen class we created
	xyzGenDlg->DeleteThis();
	// Delete the parameter map
	DestroyMParamMap(pmap);
	pmap = NULL;
}

// This is called by the DADMgr
int WaterDlg::FindSubTexFromHWND(HWND hw) {
	for (int i=0; i<NUM_SUB_TEXMAPS; i++) {
		if (hw == iCustButton[i]->GetHwnd()) return i;
		}	
	return -1;
	}


// This is called when the dialog is loaded to set the names of the
// textures displayed
void WaterDlg::UpdateSubTexNames() {
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		TSTR nm;
		Texmap *m = theTex->subTex[i];
		if (m) 	
			nm = m->GetFullName();
		else
			nm = GetString(IDS_DS_NONE);
		iCustButton[i]->SetText(nm.data());
	}
}

// Update the dialog display with the values of the texture we are
// currently editing.
void WaterDlg::LoadDialog() {
	if (theTex) {
		Interval ivalid;
		theTex->Update(cTime, ivalid);

		ISpinnerControl *spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_NUM_SPIN));
		spin->SetValue(theTex->count, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SIZE_SPIN));
		spin->SetValue(theTex->size, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_LEN_MIN_SPIN));
		spin->SetValue(theTex->minperiod, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_LEN_MAX_SPIN));
		spin->SetValue(theTex->maxperiod, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_AMP_SPIN));
		spin->SetValue(theTex->amp, FALSE);
		ReleaseISpinner(spin);

		spin = (ISpinnerControl *)
			GetISpinner(GetDlgItem(hParamDlg, IDC_SPEED_SPIN));
		spin->SetValue(theTex->phase, FALSE);
		ReleaseISpinner(spin);

		cs[0]->SetColor(theTex->col[0]);
		cs[1]->SetColor(theTex->col[1]);

		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) 
			SetCheckBox(hParamDlg, mapOnId[i], theTex->mapOn[i]);

		UpdateSubTexNames();
	}
}

// This method invalidates the rollup page so it will get redrawn
void WaterDlg::Invalidate() { 
	InvalidateRect(hParamDlg, NULL, FALSE); 
	valid = FALSE; 
}

// --- Methods inherited from ParamDlg ---
// Returns the Class_ID of the plug-in this dialog manages
Class_ID WaterDlg::ClassID() {
	return waterClassID; 
}

// This sets the current texture being edited to the texture passed
void WaterDlg::SetThing(ReferenceTarget *m) {
	assert(m->ClassID() == waterClassID);
	assert(m->SuperClassID() == TEXMAP_CLASS_ID);
	if (theTex) 
		theTex->paramDlg = NULL;

	// Set the pointer to the texmap being edited to the one passed.
	theTex = (Water *)m;

	// Point the parameter map parameter block pointer at the
	// one that is now being edited.
	pmap->SetParamBlock(theTex->pblock);
	if (theTex)
		theTex->paramDlg = this;

	// Let the XYZGen set the new one being edited
	xyzGenDlg->SetThing(theTex->xyzGen);

	// Update the dialog display with the values of the new texmap.
	LoadDialog();
}

// This returns the current texture being edited
ReferenceTarget *WaterDlg::GetThing() {
	return (ReferenceTarget *)theTex; 
}

// This method is called when the current time has changed.  
// This gives the developer an opportunity to update any user 
// interface data that may need adjusting due to the change in time.
void WaterDlg::SetTime(TimeValue t) {
	Interval ivalid;
	if (t != cTime) {
		xyzGenDlg->SetTime(t);
		cTime = t;
		theTex->Update(cTime, ivalid);
		LoadDialog();
		InvalidateRect(hParamDlg, NULL, 0);
	}
}

// This method should place values into all the parameter dialog's controls, 
// edit fields etc.  
void WaterDlg::ReloadDialog() {
	Interval ivalid;
	theTex->Update(cTime, ivalid);
	LoadDialog();
}

// This method is called when the dialog box becomes active or inactive. 
void WaterDlg::ActivateDlg(BOOL onOff) {
	for (int i = 0; i < NUM_COLORS; i++) {
		cs[i]->Activate(onOff);
	}
}
*/

//dialog stuff to get the Set Ref button
class WaterDlgProc : public ParamMap2UserDlgProc {
//public ParamMapUserDlgProc {
	public:
		Water *water;		
		WaterDlgProc(Water *m) {water = m;}		
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
		void DeleteThis() {delete this;}
	};



BOOL WaterDlgProc::DlgProc(
		TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
				{
				case IDC_SWAP:
					{
					water = (Water*)map->GetParamBlock()->GetOwner(); 

					water->SwapInputs();
					}
				break;
				}
			break;
		}
	return FALSE;
	}


/*===========================================================================*\
 | Water Methods
\*===========================================================================*/
// --- Methods inherited from Animatable ---
// This method returns a pointer to the 'i-th' sub-anim.  
Animatable* Water::SubAnim(int i) {
	switch (i) {
		case 0: return xyzGen;
		case 1: return pblock;
		default: return subTex[i-2]; 
	}
}



float Water::swave(float *v, float rate) {
	float d = (float)sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
	return(0.5f*(1.0f+(float)sin((d-phase*rate)*TWOPI)));
	}

float Water::ScalarWave(float *p) {
	int i;
	float n;
	float pd;
	float v[3];
	n = 0.0f;
	for (i=0; i < count; i++ )	{
		WaveDesc &wd = waves[i];
		pd = wd.period;
		v[0] = (p[0]-wd.cent[0])/pd;								
		v[1] = (p[1]-wd.cent[1])/pd;								
		v[2] = (p[2]-wd.cent[2])/pd;								
		n += swave(v, wd.rate)*pd/maxperiod;
	}
	return(n*amp/((float)count));
	}
						 
void Water::vwave(float *v, float rate, float *w) {
	float d = (float)sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
	float f = (float)cos((d-phase*rate)*TWOPI);
	w[0] = f*v[0]/d;
	w[1] = f*v[1]/d;
	w[2] = f*v[2]/d;
	}

void Water::VectorWave(Point3 &p, Point3 &n) {

	int i;
	float f,pd;
	Point3 d,v;
	n.x = n.y = n.z = 0.0f;
	for (i = 0; i < count; i++)	{
		WaveDesc &wd = waves[i];
		pd = wd.period;
		v.x = (p.x-wd.cent[0])/pd;								
		v.y = (p.y-wd.cent[1])/pd;								
		v.z = (p.z-wd.cent[2])/pd;								
		vwave(v,wd.rate,d);
		f = pd/maxperiod;
		n += f*d;
		}
	f = amp/((float)count);
	n *= f;
	}

void Water::ReInit() {
	float c[3], d;

	if (count!=waves.Count()) {
		waves.SetCount(count);
		waves.Resize(count);
		}

	// Reseed random number generator
	srand(randSeed); 

	// Compute wave centers on sphere with radius size
	for (int i = 0; i < count; i++) {
		WaveDesc &wv = waves[i];
		c[0] = frand();
		c[1] = (type == 0) ? frand() : 0.0f;
		c[2] = frand();
		d = size/(float)sqrt(c[0]*c[0]+c[1]*c[1]+c[2]*c[2]);
		wv.cent[0] = c[0]*d;
		wv.cent[1] = c[1]*d;
		wv.cent[2] = c[2]*d;
		wv.period = (((float)(rand()&0x7FFF))/32768.0f)*
			(maxperiod-minperiod)+minperiod; 
		wv.rate = (float)sqrt(maxperiod/wv.period);
		}
	}

// This method returns the name of the 'i-th' sub-anim to appear in track view. 
TSTR Water::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_DS_COORDS);
		case 1: return GetString(IDS_DS_PARAMETERS);
		default: return GetSubTexmapTVName(i-2);
	}
}

// --- Methods inherited from ReferenceMaker ---
// Return the 'i-th' reference
RefTargetHandle Water::GetReference(int i) {
	switch(i) {
		case 0: return xyzGen;
		case 1:	return pblock ;
		default:return subTex[i-2];
	}
}

// Save the 'i-th' reference
void Water::SetReference(int i, RefTargetHandle rtarg) {
	switch(i) {
		case 0: xyzGen = (XYZGen *)rtarg; break;
		case 1:	pblock = (IParamBlock2 *)rtarg; break;
		default: subTex[i-2] = (Texmap *)rtarg; break;
	}
}

// This method is responsible for responding to the change notification
// messages sent by the texmap dependants.
RefResult Water::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message ) {
	switch (message) {
		case REFMSG_CHANGE:
			texValidity.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				water_param_blk.InvalidateUI(changing_param);
				}

			// One of the texmap dependants have changed.  We set our
			// validity interval to empty and invalidate the dialog
			// so it gets redrawn.
//			texValidity.SetEmpty();
//			if (hTarget != xyzGen) {
//				if (paramDlg) 
//					paramDlg->pmap->Invalidate();
//				}
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			// This returns the 'dimension' of the parameter.  This is 
			// the type and order of magnitude of the parameter.
			GetParamDim *gpd = (GetParamDim *)partID;
			switch (gpd->index) {
				case PB_LEN_MIN:
				case PB_LEN_MAX:
				case PB_SIZE: gpd->dim =  stdWorldDim; 	break;
				case PB_AMP:
				case PB_NUM:
				case PB_PHASE:
					gpd->dim = defaultDim; break;
				case PB_COL1: 
				case PB_COL2: gpd->dim = stdColor255Dim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			// This returns the name that will appear in track view
			// of the parameter.
			GetParamName *gpn = (GetParamName *)partID;
			gpn->name = GetString(nameIDs[gpn->index]);
			return REF_STOP; 
		}
*/
	}
	return(REF_SUCCEED);
}

// Load/Save Chunk IDs
#define MTL_HDR_CHUNK			0x4000
#define WATER_VERS1_CHUNK		0x4001
#define MAPOFF_CHUNK			0x1000
#define PARAM2_CHUNK			0x1010

// This is called by the system to allow the plug-in to save its data
IOResult Water::Save(ISave *isave) { 
	IOResult res;

	// Save the common stuff from the base class
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	if (res != IO_OK) 
		return res;
	isave->EndChunk();
	isave->BeginChunk(PARAM2_CHUNK);
	isave->EndChunk();

/*
	// Save a version number chunk
	isave->BeginChunk(WATER_VERS1_CHUNK);
	isave->EndChunk();
	// Save the on/off status of the sub-texmaps
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		if (mapOn[i] == 0) {
			isave->BeginChunk(MAPOFF_CHUNK+i);
			isave->EndChunk();
		}
	}
*/
	return IO_OK;
}



class WaterPostLoad : public PostLoadCallback {
	public:
		Water *n;
		BOOL Param1;
		WaterPostLoad(Water *ns, BOOL b) {n = ns; Param1 = b;}
		void proc(ILoad *iload) {  
			if (Param1)
				{
				n->pblock->SetValue( water_mapon1, 0, n->mapOn[0]);
				n->pblock->SetValue( water_mapon2, 0, n->mapOn[1]);
				}
			delete this; 
			} 
	};


// This is called by the system to allow the plug-in to load its data
IOResult Water::Load(ILoad *iload) { 
	IOResult res;
	int id;
	fileVersion = 0;
	BOOL Param1 = TRUE;

	while (IO_OK == (res = iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				// Load the common stuff from the base class
				res = MtlBase::Load(iload);
				break;
			case WATER_VERS1_CHUNK:
				// Set the version number
				fileVersion = 1;
				break;
			case PARAM2_CHUNK:
				// Set the version number
				Param1 = FALSE;
				break;
			case MAPOFF_CHUNK+0:
			case MAPOFF_CHUNK+1:
				// Set the sub-texmap on/off settings
				mapOn[id-MAPOFF_CHUNK] = 0; 
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK) 
			return res;
	}

	// JBW: register old version ParamBlock to ParamBlock2 converter
	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, 1, &water_param_blk, this, 1);
	iload->RegisterPostLoadCallback(plcb);

	iload->RegisterPostLoadCallback(new WaterPostLoad(this,Param1));

	return IO_OK;
}

// --- Methods inherited from ReferenceTarget ---
// This method is called to have the plug-in clone itself.
RefTargetHandle Water::Clone(RemapDir &remap) {
	// Create a new instance of the plug-in class
	Water *newWater = new Water();

	// Copy superclass stuff
	*((MtlBase *)newWater) = *((MtlBase *)this);

	// Clone the items we reference
	newWater->ReplaceReference(0, remap.CloneRef(xyzGen));
	newWater->ReplaceReference(1, remap.CloneRef(pblock));
	newWater->col[0] = col[0];
	newWater->col[1] = col[1];
	newWater->count = count;
	newWater->size = size;
	newWater->minperiod = minperiod;
	newWater->maxperiod = maxperiod;
	newWater->amp = amp;
	newWater->phase = phase;
	newWater->type = type;
	newWater->randSeed = randSeed;
	newWater->texValidity.SetEmpty();	
	for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
		newWater->subTex[i] = NULL;
		newWater->mapOn[i] = mapOn[i];
		if (subTex[i])
			newWater->ReplaceReference(i+2, remap.CloneRef(subTex[i]));
	}
	// Return the new cloned texture
	return (RefTargetHandle)newWater;
}

// --- Methods inherited from MtlBase ---
// This method is called to return the validity interval of the texmap.
Interval Water::Validity(TimeValue t) { 
	Interval v;
	// Calling Update() sets texValidity.
	Update(t, v); 
	return texValidity; 
}

// This method is called to reset the texmap back to its default values.
void Water::Init() {
	// Reset the XYZGen or allocate a new one
	if (xyzGen) 
		xyzGen->Reset();
	else 
		ReplaceReference(0, GetNewDefaultXYZGen());	

	// This replaces the reference to the previous parameter block with
	// a new one.  Note that the previous one is automatically deleted
	// because when the last reference to an item is deleted, MAX deletes
	// the item itself.
//	ReplaceReference(1, CreateParameterBlock(pbdesc, 
//		PB_LENGTH, WATER_PB_VERSION));

//	if (paramDlg) 
//		paramDlg->pmap->SetParamBlock(pblock);

	// Set the inital parameters
	SetColor(0, Color(0.78f, 0.78f, 0.94f), TimeValue(0));
	SetColor(1, Color(0.1f, 0.1f, 0.78f), TimeValue(0));
	SetRandSeed(0x75cf);
	SetNum(10, TimeValue(0));
	SetSize(800.0f, TimeValue(0));
	SetLenMin(5.0f, TimeValue(0));
	SetLenMax(50.0f, TimeValue(0));
	SetAmp(1.0f, TimeValue(0));
	SetPhase(0.0f, TimeValue(0));

	ReInit();

	type = 0;
	// Set the validity interval of the texture to empty
	texValidity.SetEmpty();
}


void Water::Reset() {
	waterCD.Reset(this, TRUE); // reset all pb2's
	// Delete the references to the two sub-texture maps
	DeleteReference(2);
	DeleteReference(3);
	Init();
	}

// This method gets called when the material or texture is to be displayed 
// in the material editor parameters area. 
ParamDlg* Water::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp) {
	// Allocate a new instance of ParamDlg to manage the UI.  This will
	// create the rollup page in the materials editor.
//	WaterDlg *waterDlg = new WaterDlg(hwMtlEdit, imp, this);
	// Update the dialog display with the proper values of the texture.
//	waterDlg->LoadDialog();
//	paramDlg = waterDlg;
//	return waterDlg;
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = waterCD.CreateParamDlgs(hwMtlEdit, imp, this);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	water_param_blk.SetUserDlgProc(new WaterDlgProc(this));

	return masterDlg;
	
}

BOOL Water::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else 
		return FALSE;
	return TRUE;
}

// This method is called before rendering begins to allow the plug-in 
// to evaluate anything prior to the render so it can store this information.
void Water::Update(TimeValue t, Interval& ivalid) {		
	if (!texValidity.InInterval(t)) {
		texValidity.SetInfinite();
		xyzGen->Update(t, texValidity);
//		pblock->GetValue(PB_COL1, t, col[0], texValidity);
		pblock->GetValue(water_color1, t, col[0], texValidity);
		col[0].ClampMinMax();
//		pblock->GetValue(PB_COL2, t, col[1], texValidity);
		pblock->GetValue(water_color2, t, col[1], texValidity);
		col[1].ClampMinMax();
//		pblock->GetValue(PB_NUM, t, count, texValidity);
		pblock->GetValue(water_num, t, count, texValidity);
		ClampInt(count, (int) MIN_NUM, (int) MAX_NUM);
//		pblock->GetValue(PB_SIZE, t, size, texValidity);
		pblock->GetValue(water_size, t, size, texValidity);
		ClampFloat(size, MIN_SIZE, MAX_SIZE);
//		pblock->GetValue(PB_LEN_MIN, t, minperiod, texValidity);
		pblock->GetValue(water_len_min, t, minperiod, texValidity);
		ClampFloat(minperiod, MIN_LEN_MIN, MAX_LEN_MAX);
//		pblock->GetValue(PB_LEN_MAX, t, maxperiod, texValidity);
		pblock->GetValue(water_len_max, t, maxperiod, texValidity);
		ClampFloat(maxperiod, MIN_LEN_MAX, MAX_LEN_MAX);
//		pblock->GetValue(PB_AMP, t, amp, texValidity);
		pblock->GetValue(water_amp, t, amp, texValidity);
		ClampFloat(amp, MIN_AMP, MAX_AMP);
//		pblock->GetValue(PB_PHASE, t, phase, texValidity);
//		pblock->GetValue(PB_TYPE, t, type, texValidity);
		pblock->GetValue(water_phase, t, phase, texValidity);
		pblock->GetValue(water_type, t, type, texValidity);
		for (int i = 0; i < NUM_SUB_TEXMAPS; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t, texValidity);
//		pblock->GetValue(PB_SEED, t, randSeed, texValidity);
		pblock->GetValue(water_seed, t, randSeed, texValidity);

		pblock->GetValue(water_mapon1, t, mapOn[0], texValidity);
		pblock->GetValue(water_mapon2, t, mapOn[1], texValidity);

		ReInit();
		}
	}
	ivalid &= texValidity;
}

void Water::ClampFloat(float &f, float min, float max) {
	if (f < min) f = min;
	else if (f > max) f = max;
}

void Water::ClampInt(int &i, int min, int max) {
	if (i < min) i = min;
	else if (i > max) i = max;
}

// Returns a pointer to the 'i-th' sub-texmap managed by this texture.
Texmap *Water::GetSubTexmap(int i) { 
	return subTex[i]; 
}

// Stores the 'i-th' sub-texmap managed by the material or texture.
void Water::SetSubTexmap(int i, Texmap *m) {
	ReplaceReference(i+2, m);
	if (i==0)
		{
		water_param_blk.InvalidateUI(water_map1);
		texValidity.SetEmpty();
		}
	else if (i==1)
		{
		water_param_blk.InvalidateUI(water_map2);
		texValidity.SetEmpty();
		}

//	if (paramDlg)
//		paramDlg->UpdateSubTexNames();
	}

// This name appears in the materials editor dialog when editing the
// 'i-th' sub-map.
TSTR Water::GetSubTexmapSlotName(int i) {
	switch(i) {
		case 0:  return GetString(IDS_DS_COL1); 
		case 1:  return GetString(IDS_DS_COL2); 
		default: return TSTR(_T(""));
		}
	}
	 
// --- Methods inherited from Texmap ---
RGBA Water::EvalColor(ShadeContext& sc) {
	float d;
	float q[3];
	Point3 p, dp;

	if (gbufID) 
		sc.SetGBufferID(gbufID);

	xyzGen->GetXYZ(sc, p, dp);

	q[0] = p.x;
	q[1] = p.y;
	q[2] = p.z;
	d = ScalarWave(q);
	if (d>1.0f) d = 1.0f;

	// If we have sub-texmaps and they are enabled, get the colors from 
	// the sub-texmaps, otherwise get them from the color swatch
	RGBA c0 = (mapOn[0]&&subTex[0]) ? subTex[0]->EvalColor(sc): col[0];
	RGBA c1 = (mapOn[1]&&subTex[1]) ? subTex[1]->EvalColor(sc): col[1];

	Col24 c;
	Col24 col1 = Col24FromColor(c0);
	Col24 col2 = Col24FromColor(c1);

	lerp_color(&c, &col1, &col2, d);
	return ColorFromCol24(c);
	}

Point3 Water::EvalNormalPerturb(ShadeContext& sc) {
	if (gbufID) 
		sc.SetGBufferID(gbufID);

	Point3 p, dp, np;
	xyzGen->GetXYZ(sc, p, dp);

	VectorWave(p, np);
	Point3 M[3];
	xyzGen->GetBumpDP(sc,M);
	np = Point3( DotProd(np,M[0]),DotProd(np,M[1]),DotProd(np,M[2]));

	return sc.VectorFromNoScale(np,REF_OBJECT);
	}

// --- Methods inherited from Tex3D ---
void Water::ReadSXPData(TCHAR *name, void *sxpdata) {
	WaterState *state = (WaterState*)sxpdata;
	if (state != NULL && (state->version == WATER_SXP_VERSION)) {
		SetColor(0, ColorFromCol24(state->col1), TimeValue(0));
		SetColor(1, ColorFromCol24(state->col2), TimeValue(0));
		SetNum(state->count, TimeValue(0));
		SetSize(state->size, TimeValue(0));
		SetLenMin(state->minperiod, TimeValue(0));
		SetLenMax(state->maxperiod, TimeValue(0));
		SetAmp(state->amp, TimeValue(0));
		SetPhase(0.0f, TimeValue(0), TRUE); 
		}
	}

// --- Methods of Water ---
Water::Water() {
	subTex[0] = subTex[1] = NULL;
	pblock = NULL;
	xyzGen = NULL;
//	paramDlg = NULL;
	mapOn[0] = mapOn[1] = 1;
	waterCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	fileVersion = 0;
	type = 0;
	}

void Water::NotifyChanged() {
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void Water::SwapInputs() {
	Color t = col[0]; col[0] = col[1]; col[1] = t;
	Texmap *x = subTex[0];  subTex[0] = subTex[1];  subTex[1] = x;
//	pblock->SwapControllers(PB_COL1, PB_COL2);
	pblock->SwapControllers(water_color1,0, water_color2,0);
	water_param_blk.InvalidateUI(water_color1);
	water_param_blk.InvalidateUI(water_color2);
	water_param_blk.InvalidateUI(water_map1);
	water_param_blk.InvalidateUI(water_map2);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("color1"), mr_reftarg, this, mr_prop, _T("color2"), mr_reftarg, this);
	macroRec->FunctionCall(_T("swap"), 2, 0, mr_prop, _T("map1"), mr_reftarg, this, mr_prop, _T("map2"), mr_reftarg, this);
	}

void Water::SetColor(int i, Color c, TimeValue t) {
    col[i] = c;
//	pblock->SetValue((i == 0) ? PB_COL1 : PB_COL2, t, c);
	pblock->SetValue((i == 0) ? water_color1 : water_color2, t, c);
	}

void Water::SetNum(int i, TimeValue t, BOOL init) { 
	count = i;
	waves.SetCount(count); 
	waves.Resize(count);
//	pblock->SetValue(PB_NUM, t, i);
	pblock->SetValue(water_num, t, i);
	if (init) ReInit();
	}

void Water::SetRandSeed(int i, BOOL init) { 
	randSeed  = i;
//	pblock->SetValue(PB_SEED, 0, i);
	pblock->SetValue(water_seed, 0, i);
	if (init) ReInit();
	}


void Water::SetSize(float f, TimeValue t, BOOL init) { 
	size = f; 
//	pblock->SetValue(PB_SIZE, t, f);
	pblock->SetValue(water_size, t, f);
	if (init) ReInit();
	}

void Water::SetLenMin(float f, TimeValue t, BOOL init) { 
	minperiod = f; 
//	pblock->SetValue(PB_LEN_MIN, t, f);
	pblock->SetValue(water_len_min, t, f);
	if (init) ReInit();
	}

void Water::SetLenMax(float f, TimeValue t, BOOL init) { 
	maxperiod = f; 
//	pblock->SetValue(PB_LEN_MAX, t, f);
	pblock->SetValue(water_len_max, t, f);
	if (init) ReInit();
	}

void Water::SetAmp(float f, TimeValue t, BOOL init) { 
	amp = f; 
//	pblock->SetValue(PB_AMP, t, f);
	pblock->SetValue(water_amp, t, f);
	if (init) ReInit();
	}

void Water::SetPhase(float f, TimeValue t, BOOL init) { 
	phase = f; 
//	pblock->SetValue(PB_PHASE, t, f);
	pblock->SetValue(water_phase, t, f);
	if (init) ReInit();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\proscatr.h ===
#ifndef __PROSCATR__H
#define __PROSCATR__H

#include "Max.h"
#include "pscatr1.h"
#include "iparamm.h"
#include "simpobj.h"

TCHAR *GetString(int id);

extern ClassDesc* GetPScatObjDesc();
extern ClassDesc* GetSWrapObjDesc();

extern HINSTANCE hInstance;
extern int RNDSign();
extern float RND01();
extern float RND11();
extern int RND0x(int maxnum);
const float FLOAT_EPSILON=0.005f;
const float HalfPI=1.570796327f;
const float PIOver5=0.62831853f;
const float PIOver180=0.017453292f;
const float PRECISION_LIMIT=1.0e-15f;
//const float SMALL_EPSILON=0.00002f;
const float SMALL_EPSILON=0.005f;
const int row3size=3*sizeof(float);
const int mmap=MAX_MESHMAPS-1;
typedef float Matrix4By4[4][4];
typedef float Matrix3By4[3][4];
void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C);
extern void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta);
extern void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
extern int FloatEQ0(float number);
extern int SmallerEQ0(float number);
extern int FGT0(Point3 p1);
extern void Mult4X1(float *A,Matrix4By4 B,float *C);
extern int MatrixInvert(Matrix4By4 in,Matrix4By4 out);
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
extern void SpinnerOn(HWND hWnd,int SpinNum,int Winnum);
extern void SpinnerOff(HWND hWnd,int SpinNum,int Winnum);
extern Point3 CalcSpread(float divangle,Point3 oldnorm);
extern void Mult4XPoint(Point3 *Pin,Matrix4By4 B);
extern BOOL SpinIsEnabled(HWND hWnd,int SpinNum);
extern Mtl *CMaterials(Mtl *mat1, Mtl *mat2, int &c1, int &c2);
extern int nummaps(TriObject *wrap1,TriObject *wrap2,BOOL hdist,int &inmap,int &dmap,BOOL Proxy=FALSE);
extern void mapstuff(Mesh *newMesh,TriObject *wrappee,TriObject *wrapper,int oldmap,int wrappermap,int rep=1);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\pscatr1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by proscatr.rc
//
#define IDD_PROSCATTER_SAVE             107
#define IDD_ATTACH_MATS                 216
#define IDC_AP_KIDEFAULT                1000
#define IDS_AP_PARAMETERS               1001
#define IDC_PSCAT_BNAME                 1001
#define IDC_PS_LOAD                     1001
#define IDS_AP_SCATTEROBJECT            1002
#define IDC_AP_STANDOFF2                1002
#define IDC_PS_SAVE                     1002
#define IDS_AP_PICKDISTOBJ              1003
#define IDC_PS_DELETE                   1003
#define IDS_AP_SCATTEROBJECTS           1004
#define IDS_AP_TRANSFORMS               1005
#define IDS_AP_SCATRDISPLAY             1006
#define IDS_AP_NUMBER                   1007
#define IDS_AP_BASESCALE                1008
#define IDS_AP_VERTICESDANCE            1009
#define IDS_AP_ROTX                     1010
#define IDS_AP_ROTY                     1011
#define IDC_AP_KIDEFAULTSPIN            1011
#define IDS_AP_ROTZ                     1012
#define IDC_AP_STANDOFFSPIN             1012
#define IDS_AP_TRANX                    1013
#define IDS_AP_TRANY                    1014
#define IDS_AP_TRANZ                    1015
#define IDS_AP_TRANFX                   1016
#define IDS_AP_TRANFY                   1017
#define IDS_AP_TRANFZ                   1018
#define IDC_AP_USESELVERTS              1018
#define IDS_AP_SCALEX                   1019
#define IDS_AP_SCALEY                   1020
#define IDC_ATTACH_IDTOMAT              1020
#define IDS_AP_SCALEZ                   1021
#define IDC_ATTACH_MATTOID              1021
#define IDS_AP_SCATTERNAME              1022
#define IDC_AP_DISTREF                  1023
#define IDS_AP_CREATE                   1023
#define IDC_ATTACH_NEITHER              1023
#define IDC_AP_DISTCOPY                 1024
#define IDS_AP_COMPOUNDOBJECTS          1024
#define IDC_ATTACH_NO_B                 1024
#define IDC_AP_DISTMOVE                 1025
#define IDS_AP_OPERAND                  1025
#define IDC_ATTACH_NO_A                 1025
#define IDC_AP_DISTINST                 1026
#define IDS_AP_OPERANDA                 1026
#define IDC_SW_DISPRESULT               1026
#define IDC_AP_SOURCEREF                1027
#define IDS_AP_OPERANDB                 1027
#define IDC_AP_DISPPROXY                1028
#define IDS_AP_OPERANDATRANSFORM        1028
#define IDC_AP_ROTLOCK                  1029
#define IDC_AP_DISPMESH                 1029
#define IDS_AP_OPERANDBTRANSFORM        1029
#define IDC_PS_SETEDIT                  1029
#define IDC_AP_SOURCECOPY               1030
#define IDC_AP_TRANLOCK                 1030
#define IDS_AP_OPERANDS                 1030
#define IDC_AP_HIDEDIST                 1030
#define IDC_AP_SOURCEMOVE               1031
#define IDC_AP_TRANFLOCK                1031
#define IDS_AP_OBJECTSTR                1031
#define IDC_AP_SCALELOCK                1032
#define IDC_BOOL_OPERANDS               1032
#define IDS_AP_NONE                     1032
#define IDC_PS_SETLIST                  1032
#define IDC_AP_ASPECTLOCK               1033
#define IDS_AP_SCATTERTITLE             1033
#define IDC_AP_DISTCENTERS              1034
#define IDS_AP_DISTRIBTITLE             1034
#define IDC_AP_SOURCEINST               1035
#define IDS_AP_CREATESCAT               1035
#define IDC_AP_DISTVOLUME               1035
#define IDC_AP_DISTVERTICES             1036
#define IDS_AP_CREATESCATNOTIFY         1036
#define IDC_AP_DISTAREA                 1037
#define IDS_AP_D                        1037
#define IDC_AP_DISTEVEN                 1038
#define IDS_AP_S                        1038
#define IDC_AP_DISTNFACES               1039
#define IDS_AP_KIDEFAULT                1039
#define IDC_AP_DISTRANDOM               1040
#define IDS_AP_STANDOFF                 1040
#define IDC_AP_USETREE                  1041
#define IDS_AP_SURFWRAPNAME             1041
#define IDC_AP_DISTEDGES                1042
#define IDS_AP_SURFWRAPOBJECT           1042
#define IDC_AP_DISTEDGES2               1043
#define IDC_AP_DISTECENTER              1043
#define IDS_AP_SWRAPTITLE               1043
#define IDS_AP_SWRAPTOTITLE             1044
#define IDS_AP_MBASE                    1045
#define IDS_AP_PICKWRAPTOOBJ            1046
#define IDS_AP_WRAPTO                   1047
#define IDS_AP_PASCATCST                1048
#define IDS_RB_BADFILE                  1049
#define IDS_AP_NONAME                   1050
#define IDS_AP_SETEXISTS                1051
#define IDS_AP_WARNING                  1052
#define IDS_AP_BADNAME                  1053
#define IDS_AP_LOADSAVE                 1054
#define IDS_AP_PICKWTOOBJ               1055
#define IDS_AP_PSCTRLIB                 1056
#define IDS_AP_EXTRACTOP                1057
#define IDS_AP_ANIOFF                   1058
#define IDS_AP_EXTRACTTYPE              1059
#define IDS_AP_MTLMSG                   1063
#define IDS_AP_MTLTITLE                 1064
#define IDC_AP_SOURCEOBJECT             1089
#define IDC_AP_NEWSEED                  1100
#define IDC_AP_ROTX                     1158
#define IDC_AP_TRANX                    1159
#define IDC_AP_ROTY                     1160
#define IDC_AP_TRANY                    1161
#define IDC_AP_ROTZ                     1162
#define IDC_AP_TRANZ                    1163
#define IDC_AP_TRANXF                   1164
#define IDC_AP_ROTXSPIN                 1165
#define IDC_AP_TRANXSPIN                1166
#define IDC_AP_ROTYSPIN                 1167
#define IDC_AP_TRANYSPIN                1168
#define IDC_AP_ROTZSPIN                 1169
#define IDC_AP_TRANZSPIN                1170
#define IDC_AP_TRANYF                   1171
#define IDC_AP_TRANZF                   1172
#define IDC_AP_TRANXFSPIN               1173
#define IDC_AP_TRANYFSPIN               1174
#define IDC_AP_TRANZFSPIN               1175
#define IDC_AP_DISPPORTION              1176
#define IDC_AP_BASEVERTS                1177
#define IDC_AP_SCALEY                   1177
#define IDC_AP_NUMBER                   1178
#define IDC_AP_SCALEZ                   1178
#define IDC_AP_DISPPORTIONSPIN          1179
#define IDC_AP_FRAMESDIFF               1179
#define IDC_AP_BASEVERTSSPIN            1180
#define IDC_AP_SCALEYSPIN               1180
#define IDC_AP_NUMBERSPIN               1181
#define IDC_AP_SCALEZSPIN               1181
#define IDC_AP_DISTNFACESN              1182
#define IDC_AP_DISTNFACESNSPIN          1183
#define IDC_AP_FRAMESDIFFSPIN           1184
#define IDC_AP_VOLARRAY                 1247
#define IDC_AP_DISTOBJECT               1248
#define IDC_AP_BASESCALE                1249
#define IDC_AP_BASESCALESPIN            1250
#define IDC_AP_GOPERP                   1251
#define IDC_AP_GOSELECT                 1252
#define IDC_AP_SCALEX                   1253
#define IDC_AP_SCALEXSPIN               1254
#define IDC_AP_SURFWRAP_WRAPTOOBJ       1255
#define IDC_AP_SURFWRAP_OBJECTPICK      1256
#define IDC_AP_SURFWRAP_OBJECTDPICK2    1257
#define IDC_AP_HIDEWRAPTO               1258
#define IDC_SWRAP_BNAME                 1259
#define IDC_SWRAP_ANAME                 1260
#define IDC_SWRAP_OPERANDS              1261
#define IDC_AP_SURFWRAP_OBJECTDPICK3    1262
#define IDC_AP_SURFWRAP_NORMOBJ         1263
#define IDC_PS_DISPRESULT               1264
#define IDC_PS_DISPOPS                  1265
#define IDC_AP_PROSCATTER_OBJECTDPICK   2005
#define IDC_AP_PROSCATTER_DISTOBJ       2006
#define IDD_PROSCATTER_OBJECTS          2009
#define IDD_PROSCATTER_XFORMS           2010
#define IDD_PROSCATTER_DISPLAY          2011
#define IDD_PROSCATTER_PICKDIST         2012
#define IDD_SURFWRAP_OBJECTS            2014
#define IDD_SURFWRAP_PICKWRAPTO         2015
#define IDC_AP_RANDOMSEED               2020
#define IDC_AP_RANDOMSEEDSPIN           2022
#define IDC_SWRAP_RECALC                3012
#define IDC_SCATR_EXTRACTOP             3013
#define IDC_SW_DISPOPS                  3015
#define IDC_SWRAP_UPDATERENDER          3016
#define IDC_SWRAP_UPDATEMANUAL          3017
#define IDC_SWRAP_UPDATEALWAYS          3018
#define IDC_AP_VIEWDIR                  3020
#define IDC_AP_OBJECTDIR                3021
#define IDC_AP_VERTEXDIR                3022
#define IDC_AP_WRAPPERCTRDIR            3023
#define IDC_AP_WRAP2CTRDIR              3024
#define IDC_AP_WRAPPERPIVDIR            3025
#define IDC_AP_WRAP2PIVDIR              3026
#define IDC_PSCAT_ANAME                 3075
#define IDC_ATTACH_WARNING              3131
#define IDC_SCATR_EXTRACT_INSTANCE      4005
#define IDC_SCATR_EXTRACT_COPY          4006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1266
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\scat.cpp ===
/**********************************************************************
 *<
 *> Copyright (c), All Rights Reserved.
 **********************************************************************/

#define STRICT
#include <strbasic.h>
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <math.h>
#include "gfxlib.h"
#include "proflib.h"
#include "mesh.h"

// 3DS DOS did this backwards!
#define ABLINE (1<<2)
#define BCLINE (1<<1)
#define CALINE 1

#define VSEL_A 0x8000		/* Group selectors (same as faces) */
#define VSEL_B 0x4000
#define VSEL_C 0x2000


static int Progress(int percent,void *data)
	{
	if (data) {
		MeshOpProgress *p = (MeshOpProgress*)data;
		return p->Progress(percent);
	} else {
		return 1;
		}
	}
typedef struct {
 Point3	pt,Norm;
} SavePt;

/*void FillInUniform(int infaces,int c,int vertices,Mesh *mesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m)
{ int i,*lst;
  float *arealst,TotalArea,rx,ry;
  Point3 Norm;

  arealst=new float[infaces];
  lst=new int[infaces];
  assert(arealst && lst);
  TotalArea=0.0f;
  for (i=0;i<infaces;i++)
    TotalArea+=(arealst[i]=GetFaceArea(&mesh->faces[i].v[0],mesh->verts));
  SpreadOutParts(arealst,TotalArea,infaces-1,infaces,c,lst);
  Point3 V0,V1,V2,V01,V02,lastpt,lV0,lV01,lV02;
  for (i=0;i<infaces;i++)
  { V01=(V1=mesh->verts[mesh->faces[i].v[1]])-(V0=mesh->verts[mesh->faces[i].v[0]]);
    V02=(V2=mesh->verts[mesh->faces[i].v[2]])-V0;
	lV01=(lastv[lastf[i].v[1]])-(lV0=lastv[lastf[i].v[0]]);
    lV02=(lastv[lastf[i].v[2]])-lV0;
    Norm=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
    for (int j=0;j<lst[i];j++)
    { parts->vels[vertices]=Norm;
      rx=RND01();ry=RND01();
      if (rx+ry>1) {rx=1-rx;ry=1-ry;}
	  parts->points[vertices]=V0+V01*rx+V02*ry;
	  if (s[vertices].M>0.0f)
	  { lastpt=lV0+lV01*rx+lV02*ry;
	    s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
	  }
	  if (doTVs)
	  { s[vertices].pmtl=mesh->faces[i].getMatID();
	    Point3 tv0=mesh->tVerts[mesh->tvFace[i].t[0]];
		Point3 tv1=mesh->tVerts[mesh->tvFace[i].t[1]];
		Point3 tv2=mesh->tVerts[mesh->tvFace[i].t[2]];
	    s[vertices].tv=Point3((1-ry)*(rx*tv1.x+tv0.x-rx*tv0.x)+ry*tv2.x,(1-ry)*(rx*tv1.y+tv0.y-rx*tv0.y)+ry*tv2.y,0.0f);
	  }
	  vertices++;
	}
  }
  delete[] arealst;
  delete[] lst;
}

float Checkfordup(DWORD *curface,int P0,int P1,float *arealst,fEdge *edgelst,int *edges,int face,Point3 *vlst,Face *f)
{ int i,found;
  float area;
  Point3 norm;

  found=i=0;area=0.0f;
  while ((!found)&&(i<*edges))
   { found=((edgelst[i].vto==curface[P0])&&(edgelst[i].vfrom==curface[P1]))||
            ((edgelst[i].vfrom==curface[P0])&&(edgelst[i].vto==curface[P1]));
     if (!found) i++;
   }
   if (found)
   { norm=GetNormalizedNormal(curface,vlst);
     edgelst[i].normal=AveNormal(norm,edgelst[i].normal);
     if (f[face].getMatID()!=f[edgelst[i].face].getMatID())
     { if (GetFaceArea(curface,vlst)>GetFaceArea(&f[edgelst[i].face].v[0],vlst))
         edgelst[i].face=face;
     }
   }
   else
   {area=(arealst[i]=Length(vlst[curface[P0]]-vlst[curface[P1]]));
    edgelst[i].vfrom=curface[P0];edgelst[i].vto=curface[P1];
    edgelst[i].normal=GetNormalizedNormal(curface,vlst);
    edgelst[i].face=face;
    (*edges)++;
   }
 return(area);
}

float GetEdgeArea(Mesh *mesh,float *arealst,fEdge *edgelst,int *edges,int face)
{ float area;
  DWORD *curface=&(mesh->faces[face]).v[0],flags=mesh->faces[face].flags;
  area=0.0f;
  if ((flags & EDGE_A)>0)
    area+=Checkfordup(curface,0,1,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  if ((flags & EDGE_B)>0)
    area+=Checkfordup(curface,1,2,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  if ((flags & EDGE_C)>0)
    area+=Checkfordup(curface,2,0,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  return(area);
}

void FillByEdges(int infaces,int c,int vertices,Mesh *mesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m)
{ int i,edges,numedges=3*infaces,*lst;
  float *arealst,TotalArea,r;
  fEdge *edgelst;
  Point3 lastpt;

  edges=0;
  assert((arealst=new float[numedges])!=NULL);
  assert((edgelst=new fEdge[numedges])!=NULL);
  lst=new int[numedges];assert(lst);
  TotalArea=0.0f;
  for (i=0;i<infaces;i++)
    TotalArea+=GetEdgeArea(mesh,arealst,edgelst,&edges,i);
  SpreadOutParts(arealst,TotalArea,edges-1,edges,c,lst);
  for (i=0;i<edges;i++)
  { Point3 pt=mesh->verts[edgelst[i].vfrom],pdist=mesh->verts[edgelst[i].vto]-pt;
    Point3 lpt=lastv[edgelst[i].vfrom],lpdist=lastv[edgelst[i].vto]-lpt;
	for (int j=0;j<lst[i];j++)
	{ r=RND01();
      parts->points[vertices]=pt+pdist*r;
	  if (s[vertices].M>0.0f)
	  { lastpt=lpt+lpdist*r;
	    s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
	  }
      parts->vels[vertices]=edgelst[i].normal;
	if (doTVs) 
	{ DWORD *vlst;vlst=&mesh->faces[edgelst[i].face].v[0];
	  int st0=(vlst[0]==edgelst[i].vfrom?0:(vlst[1]==edgelst[i].vfrom?1:2));
	  int st1=(vlst[0]==edgelst[i].vto?0:(vlst[1]==edgelst[i].vto?1:2));
	  Point3 tv0=mesh->tVerts[mesh->tvFace[edgelst[i].face].t[st0]];
	  Point3 tv1=mesh->tVerts[mesh->tvFace[edgelst[i].face].t[st1]];
	  s[vertices].tv=Point3(tv0.x+(tv1.x-tv0.x)*r,tv0.y+(tv1.y-tv0.y)*r,0.0f);
	  s[vertices].pmtl=mesh->faces[edgelst[i].face].getMatID();
	}
      vertices++;
    }
  }
  delete[] arealst;
  delete[] edgelst;
}

BOOL VertexinWhichFace(int v,Face *flst,int infaces,int *aface)
{ BOOL found;

  found=0;
  while ((*aface<infaces)&&(!found))
  { found=amatch(flst[*aface].v,v);
    if (!found) (*aface)++;
  }
  return(found);
}

void FillInFaces(int faces,int vertices,Mesh *mesh,int c,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m)
{ int i,j,*lst,localf;
  Point3 lastpt;
  lst=new int[faces];
  SelectEmitterPer(faces,c,lst);

  for (i=0;i<faces;i++)
  if (lst[i]>0)
  { parts->points[vertices]=(mesh->verts[mesh->faces[i].v[0]]+mesh->verts[mesh->faces[i].v[1]]+mesh->verts[mesh->faces[i].v[2]])/3.0f;
    parts->vels[vertices]=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
	if (s[vertices].M>0.0f)
	{ lastpt=(lastv[lastf[i].v[0]]+lastv[lastf[i].v[1]]+lastv[lastf[i].v[2]])/3.0f;
	  s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
	}
    if (doTVs)
	{ s[vertices].tv=(mesh->tVerts[mesh->tvFace[i].t[0]]+mesh->tVerts[mesh->tvFace[i].t[1]]+mesh->tVerts[mesh->tvFace[i].t[2]])/3.0f;
	  s[vertices].pmtl=mesh->faces[i].getMatID();
	}
	localf=vertices+1;
	for (j=1;j<lst[i];j++)
	{ parts->points[localf]=parts->points[vertices];
	  parts->vels[localf]=parts->vels[vertices];
	  s[localf].Ve=s[vertices].Ve;
	  if (doTVs) 
	  { s[localf].tv=s[vertices].tv;
	    s[localf].pmtl=s[vertices].pmtl;
      }
	  localf++;
	}
	vertices=localf;
  }
  delete[] lst;
}	*/

void FillInVertex(int inverts,int infaces,Mesh *mesh,SavePt *center)
{ int i,face,ncounter,firstface;
  Point3 newNorm,zero=Point3(0.0f,0.0f,0.0f);

  for (i=0;i<inverts;i++)
  { center->pt[i]=mesh->verts[i];
    face=firstface=ncounter=0;
	newNorm=zero;
    while (VertexinWhichFace(i,mesh->faces,infaces,&face))
	{ newNorm+=GetNormalizedNormal(&mesh->faces[face].v[0],mesh->verts);
	  if (ncounter==0) firstface=face;
	  ncounter++;face++;
	}
	center->norm[i]=Normalize(ncounter>0?newNorm/(float)ncounter:Point3(RND11(),RND11(),RND11()));
  }
}
int DoScatter(Mesh &mesh, Mesh &mesh1, Mesh &mesh2,int op, MeshOpProgress *prog,
		Matrix3 *tm1,Matrix3 *tm2,int whichInv,	int weld)
{  	double cnt;
	center.x = center.y = center.z = 0.0;
	int nfaces, res;
	BitArray weldSet;

	if (prog) prog->Init(100);

	mesh.setNumVerts(bool_vcount);
	mesh.setNumFaces(bool_fcount);
	weldSet.SetSize(bool_vcount);
	nfaces = 0;
	mesh.numFaces = nfaces;

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\blurMgr.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurMgr.h

	 DESCRIPTION: blur manager - class declarations

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_BLUR_H_INCLUDED_)
#define _BLUR_H_INCLUDED_

// maxsdk includes and predeclarations
#include <max.h>
#include <iparamm2.h>
#include <bmmlib.h>

// local includes and predeclarations
#include "globals.h"
#include "resource.h"
#include "dllMain.h"
#include "dlgProcs.h"
#include "_blurTypes\blurUniform.h"
#include "_blurTypes\blurDirectional.h"
#include "_blurTypes\blurRadial.h"
#include "_selectTypes\selImage.h"
#include "_selectTypes\selIgnBack.h"
#include "_selectTypes\selLum.h"
#include "_selectTypes\selMaps.h"

#define NUM_SUBS	numIDs
#define NUM_REFS	NUM_SUBS
#define NUM_PBLOCKS	NUM_SUBS

// ----------------------------------------
// blur effect - class declaration
// ----------------------------------------
class BlurMgr : public Effect
{
protected:
	DWORD m_lastBMModifyID;
	CheckAbortCallback *m_checkAbort;
	int m_imageSz, m_imageW, m_imageH;
	CompMap m_compMap;
	bool m_compValid;

	// blur type instances
	BlurBase *m_blurs[numBlurs];

	// selection type instances
	SelBase *m_sels[numSels];

	// local copies of paramBlock elements
	BOOL m_activeSels[numSels];

	void updateSelections(TimeValue t, Bitmap *bm, RenderGlobalContext *gc);
	void blur(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, BOOL composite);

public:
	// paramblocks & parammaps
	IParamBlock2 *pbMaster, *pbBlurData, *pbSelData;
	static IParamMap2 *pmMaster;
	static IParamMap2 *pmBlurData;
	static IParamMap2 *pmSelData;

	// class descriptor
	static const Class_ID blurMgrClassID;

	// dialog procs
	static MasterDlgProc masterDlgProc;
	static BlurDataDlgProc blurDataDlgProc;
	static SelDataDlgProc selDataDlgProc;

	// paramblock descriptors
	static ParamBlockDesc2 pbdMaster;
	static ParamBlockDesc2 pbdBlurData;
	static ParamBlockDesc2 pbdSelData;

	BlurMgr();
	~BlurMgr();
	BOOL progress(const TCHAR *title,int done, int total) { m_checkAbort->SetTitle(title); return m_checkAbort->Progress(done,total); }
	BOOL getBlurValue(ParamID id, TimeValue t, float& v, Interval &ivalid, int tabIndex=0) { return pbBlurData->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL getBlurValue(ParamID id, TimeValue t, int& v, Interval &ivalid, int tabIndex=0) { return pbBlurData->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL getBlurValue(ParamID id, TimeValue t, INode*& v, Interval &ivalid, int tabIndex=0) { return pbBlurData->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL setBlurValue(ParamID id, TimeValue t, INode*& v, int tabIndex=0) { return pbBlurData->SetValue(id, t, v, tabIndex); }
	BOOL getSelValue(ParamID id, TimeValue t, float& v, Interval &ivalid, int tabIndex=0) { return pbSelData->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL getSelValue(ParamID id, TimeValue t, int& v, Interval &ivalid, int tabIndex=0) { return pbSelData->GetValue(id, t, v, ivalid, tabIndex); }
	BOOL getSelValue(ParamID id, TimeValue t, Texmap*& v, Interval &ivalid, int tabIndex=0) { return pbSelData->GetValue(id, t, v, ivalid, tabIndex); }
	void blurEnable(ParamID id, BOOL onOff, int tabIndex=0) { pmBlurData->Enable(id, onOff, tabIndex); }
	void selEnable(ParamID id, BOOL onOff, int tabIndex=0) { pmSelData->Enable(id, onOff, tabIndex); }
	HWND getBlurHWnd() { return pmBlurData->GetHWnd(); }
	HWND getSelHWnd() { return pmBlurData->GetHWnd(); }

	// Animatable/Reference
	int NumSubs() { return NUM_SUBS; }
	Animatable* SubAnim(int i) { return GetReference(i); }
	TSTR SubAnimName(int i);
	int NumRefs() { return NUM_REFS; }
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	Class_ID ClassID() { return blurMgrClassID; }
	void GetClassName(TSTR& s) { s = GetString(IDS_CLASS_NAME); }
	void DeleteThis() { delete this; }
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);
	int NumParamBlocks() { return NUM_PBLOCKS; }
	IParamBlock2* GetParamBlock(int i) { return (IParamBlock2 *)GetReference(i); }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (IParamBlock2 *)GetReference(id); }
	IOResult Load(ILoad *iload);

	// Effect
	TSTR GetName() { return GetString(IDS_NAME); }
	EffectParamDlg *CreateParamDialog(IRendParams *ip);
	DWORD GBufferChannelsRequired(TimeValue t) { return BMM_CHAN_NONE; }
	void Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *_checkAbort);
};

// --------------------------------------------------
// blur class descriptor - class declaration
// --------------------------------------------------
class BlurMgrClassDesc : public ClassDesc2
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new BlurMgr; }
	const TCHAR *	ClassName() { return GetString(IDS_CDESC_CLASS_NAME); }
	SClass_ID		SuperClassID() { return RENDER_EFFECT_CLASS_ID; }
	Class_ID		ClassID() { return BlurMgr::blurMgrClassID; }
	const TCHAR*	Category() { return _T(""); }
	const TCHAR*	InternalName() { return _T("Blur"); } // hard-coded for scripter
	HINSTANCE		HInstance() { return hInstance; }
	};

extern BlurMgrClassDesc blurMgrCD;

#endif // !defined(_BLUR_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\proscatr\surfwrap.cpp ===
/**********************************************************************
 *<
	FILE: surfwrap.cpp

	DESCRIPTION:  A Procedural Geometry Projection Tool

	CREATED BY: Audrey Peterson

	HISTORY: created January 1997

 *>	Copyright (c) 1997 All Rights Reserved.
 **********************************************************************/
#include "proscatr.h"

#define BIGFLOAT	float(999999)
static Class_ID SURFWRAPOBJ_CLASS_ID(0x1ab13757, 0x12365b98);

#define CID_CREATESURFWRAPMODE CID_USER + 30		
#define REF_OP1		0
#define REF_OP2		1
#define REF_CONT1	2
#define REF_CONT2	3
#define PBLOCK		4
#define MBASE		5

// Flag bits
#define SWRAP_OB1SEL			(1<<0)
#define SWRAP_OB2SEL			(1<<1)
#define SWRAP_ANYSEL			(SWRAP_OB1SEL|SWRAP_OB2SEL)
#define SWRAP_INRENDER			(1<<2)
#define SWRAP_UPDATEALWAYS	(1<<3)
#define SWRAP_UPDATERENDER	(1<<4)
#define SWRAP_UPDATEMANUAL	(1<<5)
#define SWRAP_DISPRESULT    (1<<6)

//--- Parameter map/block descriptors -------------------------------
#define PB_DOWITHDIST		0
#define PB_KIDEFAULT		1
#define PB_STANDOFF			2
#define PB_USESELVERTS		3
#define PB_HIDEDISTOBJECT	4
#define PB_UPDATETYPE		5
#define PB_GETNORM			6
#define PB_SHOWTYPE			7


static int createDistDoIDs[] = {IDC_AP_DISTREF,IDC_AP_DISTCOPY,IDC_AP_DISTMOVE,IDC_AP_DISTINST};
static int UpdateIDs[] = {IDC_SWRAP_UPDATEALWAYS,IDC_SWRAP_UPDATERENDER,IDC_SWRAP_UPDATEMANUAL};
static int NormIDs[] = {IDC_AP_VIEWDIR,IDC_AP_OBJECTDIR,IDC_AP_VERTEXDIR,IDC_AP_WRAPPERCTRDIR,IDC_AP_WRAP2CTRDIR,IDC_AP_WRAPPERPIVDIR,IDC_AP_WRAP2PIVDIR};
static int ShowIDs[] = {IDC_SW_DISPRESULT,IDC_SW_DISPOPS};

static ParamUIDesc descObjects[] = {
	// Get Normal BY
	ParamUIDesc(PB_GETNORM,TYPE_RADIO,NormIDs,7),			

	// Default Projection Distance Ki
	ParamUIDesc(
		PB_KIDEFAULT,
		EDITTYPE_FLOAT,
		IDC_AP_KIDEFAULT,IDC_AP_KIDEFAULTSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Standoff Distance
	ParamUIDesc(
		PB_STANDOFF,
		EDITTYPE_FLOAT,
		IDC_AP_STANDOFF2,IDC_AP_STANDOFFSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Use Selected Vertices ONLY
	ParamUIDesc(PB_USESELVERTS,TYPE_SINGLECHEKBOX,IDC_AP_USESELVERTS),

	// Start with Perpendicular Instances
	ParamUIDesc(PB_HIDEDISTOBJECT,TYPE_SINGLECHEKBOX,IDC_AP_HIDEWRAPTO),
	
	// Update Types
	ParamUIDesc(PB_UPDATETYPE,TYPE_RADIO,UpdateIDs,3),
	
	// Show Types
	ParamUIDesc(PB_SHOWTYPE,TYPE_RADIO,ShowIDs,2),			
	};

#define OBJECTSDESC_LENGTH 7

static ParamUIDesc descPickDist[] = {
	// What to do with dist object
	ParamUIDesc(PB_DOWITHDIST,TYPE_RADIO,createDistDoIDs,4),
	};

#define PICKDISTDESC_LENGTH 1

// variable type, NULL, animatable, number
ParamBlockDescID SWdescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 }
	};
ParamBlockDescID SWdescVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 }
	};

#define PBLOCK_LENGTH	8

#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc swversions[] = {
	ParamVersionDesc(SWdescVer0,7,0),
	};
static ParamVersionDesc curVersion(SWdescVer1,PBLOCK_LENGTH,CURRENT_VERSION);

class VNormal {
	public:
		Point3 norm;
		DWORD smooth;
		VNormal *next;
		BOOL init;

		VNormal() {smooth=0;next=NULL;init=FALSE;norm=Point3(0,0,0);}
		VNormal(Point3 &n,DWORD s) {next=NULL;init=TRUE;norm=n;smooth=s;}
		~VNormal() {delete next;}
		void AddNormal(Point3 &n,DWORD s);
		Point3 &GetNormal(DWORD s);
		void Normalize();
	};

void VNormal::AddNormal(Point3 &n,DWORD s)
	{
	if (!(s&smooth) && init) {
		if (next) next->AddNormal(n,s);
		else {
			next = new VNormal(n,s);
			}
	} else {
		norm   += n;
		smooth |= s;
		init    = TRUE;
		}
	}

Point3 &VNormal::GetNormal(DWORD s)
	{
	if (smooth&s || !next) return norm;
	else return next->GetNormal(s);	
	}

void VNormal::Normalize()
	{
	VNormal *ptr = next, *prev = this;
	while (ptr) {
		if (ptr->smooth&smooth) {
			norm += ptr->norm;			
			prev->next = ptr->next;
			delete ptr;
			ptr = prev->next;
		} else {
			prev = ptr;
			ptr  = ptr->next;
			}
		}
	norm = ::Normalize(norm);
	if (next) next->Normalize();
	}

class SWPickOperand;
class SWPickNorm;

class SurfWrapObject: public GeomObject, public MeshOpProgress {
		
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );
				
	public:
		TSTR opaName, opbName, normname;
		Object *ob1, *ob2;
		Control *tm1,*tm2;
		INode *mbase,*mainnode;
		static IParamMap *pmapObjects;
		static IParamMap *pmapDist;
		IParamBlock *pblock;
		static Matrix3 createTM;
		static int dlgNormby;
		static HWND thwnd;
		Point3 wrappivot,topivot;
		Matrix3 wrapoff,wrapoff2;
		Interval ivalid;
		Mesh mesh;	
		DWORD flags;
		int ob1verts,ob1faces,firstmtls,secondmtls;

		Point3 viewPt;
		static IObjParam *ip;
		static SWPickOperand pickCB;
		static SWPickNorm pickNorm;
		static BOOL creating;
		static SurfWrapObject *editOb;

		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;
		static SelectModBoxCMode *selectMode;

		SurfWrapObject();
		~SurfWrapObject();
		
		void SetFlag(DWORD mask) { flags|=mask; }
		void ClearFlag(DWORD mask) { flags &= ~mask; }
		int TestFlag(DWORD mask) { return(flags&mask?1:0); }
		DWORD BoolOp(int &order);

		void SetOperand(INode *node,Matrix3& boolTm,Matrix3& oppTm,int which,INode *orignode,bool *canUndo=NULL);
		BOOL UpdateMesh(TimeValue t,BOOL force=FALSE,BOOL sel=FALSE);
		Object *GetPipeObj(TimeValue t,int which);
		Matrix3 GetOpTM(TimeValue t,int which,Interval *iv=NULL);
		void Invalidate() {ivalid.SetEmpty();}

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		TCHAR *GetObjectName() { return GetString(IDS_AP_SURFWRAPNAME); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// For sub-object selection
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE);
		void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc);
		
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert);
		void ClearSelection(int selLevel);

		int SubObjectIndex(HitRecord *hitRec);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);

		void ActivateSubobjSel(int level, XFormModes& modes);
		void ShowOpList(BOOL isobj);
		void ShowName(BOOL ob2);
		void ShowNormName();
		// From Object		
		void InitNodeName(TSTR& s) {s = GetString(IDS_AP_SURFWRAPNAME);}
		Interval ObjectValidity(TimeValue t);
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		ObjectState Eval(TimeValue time);
		int NumPipeBranches();
		Object *GetPipeBranch(int i);
		INode *GetBranchINode(TimeValue t,INode *node,int i);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int aflags);
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel);
		void GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt, Box3& box);
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);

		// From GeomObject		
		ObjectHandle CreateTriObjRep(TimeValue t) {return NULL;}
		int IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm);
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		// Animatable methods
		Class_ID ClassID() {return SURFWRAPOBJ_CLASS_ID;}  
		void GetClassName(TSTR& s) {s = GetString(IDS_AP_SURFWRAPOBJECT);}
		void DeleteThis() {delete this;}				
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum);

		// From ref
		RefTargetHandle Clone(RemapDir& remap);
		int NumRefs() {return 6;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		// From MeshOpProgress
		BOOL Progress(int p);
		void Init(int total);
		void InvalidateUI();
	};				

class SWPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SurfWrapObject *bo;
		
		SWPickOperand() {bo=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);
		
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}

		PickNodeCallback *GetFilter() {return this;}
	};
class SWPickNorm : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SurfWrapObject *bo;
		
		SWPickNorm() {bo=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);
		
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}

		PickNodeCallback *GetFilter() {return this;}
	};

IParamMap *SurfWrapObject::pmapObjects = NULL;
IParamMap *SurfWrapObject::pmapDist = NULL;
IObjParam *SurfWrapObject::ip                   = NULL;
BOOL SurfWrapObject::creating                   = FALSE;
SurfWrapObject *SurfWrapObject::editOb              = NULL;
MoveModBoxCMode*    SurfWrapObject::moveMode    = NULL;
RotateModBoxCMode*  SurfWrapObject::rotMode 	= NULL;
UScaleModBoxCMode*  SurfWrapObject::uscaleMode  = NULL;
NUScaleModBoxCMode* SurfWrapObject::nuscaleMode = NULL;
SquashModBoxCMode*  SurfWrapObject::squashMode  = NULL;
SelectModBoxCMode*  SurfWrapObject::selectMode  = NULL;
SWPickOperand SurfWrapObject::pickCB;
SWPickNorm SurfWrapObject::pickNorm;
Matrix3 SurfWrapObject::createTM;
HWND SurfWrapObject::thwnd;
int SurfWrapObject::dlgNormby=0;

class SWrapObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new SurfWrapObject;}
	const TCHAR *	ClassName() { return GetString(IDS_AP_SURFWRAPOBJECT); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SURFWRAPOBJ_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_COMPOUNDOBJECTS);}
	BOOL			OkToCreate(Interface *i);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	};

BOOL SurfWrapObject::HasUVW() { 
	BOOL genUV1=FALSE,genUV2=FALSE;
    if (ob1) genUV1=ob1->HasUVW();
	if (ob2) genUV2=ob2->HasUVW();
	return (genUV1&& genUV2); 
	}

void SurfWrapObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	if (ob1) ob1->SetGenUVW(sw);
	if (ob2) ob2->SetGenUVW(sw);			
	}

void SWrapObjClassDesc::ResetClassParams(BOOL fileReset)
	{SurfWrapObject::dlgNormby=0;
	}

static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

BOOL SWrapObjClassDesc::OkToCreate(Interface *i)
	{
	if (i->GetSelNodeCount()!=1) return FALSE;
	Interval intvalid;
	BOOL needsDel;
	Object *tob=i->GetSelNode(0)->GetObjectRef();
	TriObject *tri=GetTriObject(i->GetTime(),tob,intvalid,needsDel);
	if (tri==NULL) return FALSE;
	if (needsDel) tri->DeleteThis();
	return TRUE;	
	}

static SWrapObjClassDesc SWrapObjDesc;

ClassDesc* GetSWrapObjDesc() { return &SWrapObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

//----------------------------------------------------------------------

class CreateSWrapProc : public MouseCallBack {
	public:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		int proc( 
			HWND hWnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m );
	};

int CreateSWrapProc::proc( 
		HWND hWnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m ) 
	{
	switch (msg) {
		case MOUSE_POINT:
			ip->SetActiveViewport(hWnd);
			break;
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
		case MOUSE_PROPCLICK:
			// right click while between creations
			ip->RemoveMode(NULL);
			break;
		}	
	return TRUE;
	}

class CreateSWrapMode : public CommandMode, ReferenceMaker {		
	public:		
		CreateSWrapProc proc;
		INode *node, *svNode;
		IObjParam *ip;
		SurfWrapObject *obj;

		void Begin(INode *n,IObjParam *i);
		void End(IObjParam *i);
		void JumpStart(IObjParam *i,SurfWrapObject *o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATESURFWRAPMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 1; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG(CommandMode *oldMode) {return TRUE;}
		void EnterMode() {/*MakeRefByID(FOREVER,0,svNode);*/}
		void ExitMode() {/*DeleteAllRefsFromMe();*/}
		
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return node;}
		void SetReference(int i, RefTargetHandle rtarg) {node = (INode*)rtarg;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);		
	};
static CreateSWrapMode theCreateSWrapMode;


void GenerateViewRay(Point3 *viewPt,Interface *intf)
{  float xpos=1.0f,ypos=1.0f;
   Ray ray;
	ViewExp *view = intf->GetActiveViewport();
	GraphicsWindow *gw=view->getGW();
	if (gw->isPerspectiveView())
	{ xpos+=gw->getWinSizeX()/2;
	  ypos+=gw->getWinSizeY()/2;
	}
	view->MapScreenToWorldRay(xpos, ypos,ray);
	*viewPt=ray.dir;
	intf->ReleaseViewport(view);
}

RefResult CreateSWrapMode::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID,
		RefMessage message)
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:		
		case REFMSG_TARGET_DELETED:			
			if (ip) ip->StopCreating();
			break;

		}
	return REF_SUCCEED;
	}

class CreateSurfWrapRestore : public RestoreObj {
	public:   		
		void Restore(int isUndo) {
			if (theCreateSWrapMode.ip) {
				// Jump out of boolean create mode.
				theCreateSWrapMode.ip->SetStdCommandMode(CID_OBJMOVE);
				}
			}	
		void Redo() {}
		TSTR Description() {return GetString(IDS_AP_CREATESCAT);}
	};

// Sending the REFMSG_NOTIFY_PASTE message notifies the modify
// panel that the Node's object reference has changed when
// undoing or redoing.

class CreateSurfWrapTM : public RestoreObj {
	public:   		
		SurfWrapObject *obj;
		INode *oldn;
		Control *oldc;
		CreateSurfWrapTM(SurfWrapObject *o, INode *n) {
			obj = o; oldn=n; 
			}
		void Restore(int isUndo) {
			if (obj->tm1) {
				oldn->SetTMController(obj->tm1);
			    obj->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				}
			}	
		void Redo() { }
		TSTR Description() {return GetString(IDS_AP_CREATESCATNOTIFY);}
	};

class CreateWraptoref : public RestoreObj {
	public:   		
		SurfWrapObject *obj;
		TSTR name,name2;
		CreateWraptoref(SurfWrapObject *o, TSTR n, TSTR n1) {
			obj = o; name=TSTR(n);name2=TSTR(n1); 
			}
		void Restore(int isUndo) {
			BOOL isname=_tcslen(name)>0;
			obj->opbName=(isname?TSTR(GetString(IDS_AP_D)) + name:name);
			obj->ShowOpList(isname);
			}	
		void Redo() 
		{   BOOL isname=_tcslen(name2)>0;
		obj->opbName=(isname?TSTR(GetString(IDS_AP_D)) + name2:name2);
			obj->ShowOpList(isname);
			}
		TSTR Description() {return GetString(IDS_AP_CREATESCATNOTIFY);}
	};

class CreateSurfWrapNotify : public RestoreObj {
	public:   		
		SurfWrapObject *obj;
		BOOL which;
		CreateSurfWrapNotify(SurfWrapObject *o, BOOL w) {
			obj = o; which = w;
			}
		void Restore(int isUndo) {
			if (which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}	
		void Redo() {
			if (!which) {
				obj->NotifyDependents(FOREVER,0,REFMSG_NOTIFY_PASTE);
				}
			}
		TSTR Description() {return GetString(IDS_AP_CREATESCATNOTIFY);}
	};

void CreateSWrapMode::Begin(INode *n,IObjParam *i) 
	{
	MakeRefByID(FOREVER,0,n);
	svNode = node;
	assert(node);
	ip = i;
	proc.Init(ip);

	theHold.Begin();
	theHold.Put(new CreateSurfWrapRestore);

	obj = new SurfWrapObject;

	theHold.Put(new CreateSurfWrapNotify(obj,1));

	obj->createTM = node->GetObjectTM(0);
	GenerateViewRay(&obj->viewPt,ip);

	Matrix3 oldtm=node->GetObjectTM(0);
	obj->mainnode=node;
		theHold.Begin();

	obj->SetOperand(
		node,
		obj->createTM,
		oldtm,
		0,NULL);
	obj->createTM=node->GetObjectTM(0);

	node->SetObjectRef(obj);
	
	theHold.Put(new CreateSurfWrapNotify(obj,0));

	theHold.Accept(GetString(IDS_AP_CREATE));

	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

void CreateSWrapMode::End(IObjParam *i)
	{
	svNode = node;
	if (obj) obj->EndEditParams(i,END_EDIT_REMOVEUI,NULL);
	DeleteAllRefsFromMe();
	ip  = NULL;
	obj = NULL;
	}

void CreateSWrapMode::JumpStart(IObjParam *i,SurfWrapObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int SWrapObjClassDesc::BeginCreate(Interface *i)
	{	
	assert(i->GetSelNodeCount()==1);

	theCreateSWrapMode.Begin(i->GetSelNode(0),(IObjParam*)i);
	i->PushCommandMode(&theCreateSWrapMode);
	return TRUE;
	}

int SWrapObjClassDesc::EndCreate(Interface *i)
	{
	theCreateSWrapMode.End((IObjParam*)i);
	i->RemoveMode(&theCreateSWrapMode);
	return TRUE;
	}

//----------------------------------------------------------------------


SurfWrapObject::SurfWrapObject()
	{	MakeRefByID(FOREVER, PBLOCK, CreateParameterBlock(SWdescVer1, PBLOCK_LENGTH, CURRENT_VERSION));	
	ob1 = ob2 = NULL;
	tm1 = tm2 = NULL;
	mbase = NULL;
	ivalid.SetEmpty();
	pblock->SetValue(PB_DOWITHDIST,0,3);
	pblock->SetValue(PB_KIDEFAULT,0,1.0f);
	pblock->SetValue(PB_STANDOFF,0,1.0f);
	pblock->SetValue(PB_USESELVERTS,0,0);
	pblock->SetValue(PB_HIDEDISTOBJECT,0,0);
	pblock->SetValue(PB_GETNORM,0,dlgNormby);
	pblock->SetValue(PB_SHOWTYPE,0,0);
	flags = 0;
	SetFlag(SWRAP_UPDATEALWAYS|SWRAP_DISPRESULT);
	ob1verts=0;ob1faces=0;
	firstmtls=0;secondmtls=0;
	opaName=TSTR(_T(""));
	opbName=TSTR(_T(""));
	}

SurfWrapObject::~SurfWrapObject()
	{
	DeleteAllRefsFromMe();
	}

const Point3 Zero=Point3(0.0f,0.0f,0.0f);

Matrix3 GetObjOffMtx(INode *node)
{ ScaleValue scale=node->GetObjOffsetScale();
  Quat rot=node->GetObjOffsetRot();
  Point3 pos=node->GetObjOffsetPos();
  Matrix3 pp(TRUE),ppr(TRUE);
  ApplyScaling(pp,scale);
  rot.MakeMatrix(ppr);
  pp=pp*ppr;
  pp.SetTrans(pos);
  pp=Inverse(pp);
  return pp;
}

void SurfWrapObject::SetOperand(INode *node,Matrix3& boolTm,Matrix3& oppTm,int which,INode *orignode,bool *canundo)
{ if (which) { opbName = TSTR(GetString(IDS_AP_D)) + TSTR(node->GetName()); }
  else { opaName= TSTR(GetString(IDS_AP_S)) + TSTR(node->GetName()); }

  BOOL delnode = FALSE;
  Object *obj = node->GetObjectRef();

  if (which)
  {	int	dmethod;
	pblock->GetValue(PB_DOWITHDIST,0,dmethod,FOREVER);
	if (dmethod==0)	obj = MakeObjectDerivedObject(obj);
	else if (dmethod==1) obj = (Object*)obj->Clone();
    else if (dmethod==2) delnode = TRUE;
  }
	
  // Plug in the object and a new controller.	
  if (which?ob1:ob2) ReplaceReference(which,obj,TRUE);
  else MakeRefByID(FOREVER,which,obj);
  ShowOpList(ob2!=NULL);
  if (which)
  { RemapDir *remap = NewRemapDir(); 
    ReplaceReference(which+2,remap->CloneRef(node->GetTMController()));
    remap->DeleteThis();
    wrapoff2=GetObjOffMtx(node);
    int c1=0,c2=0;
    if (orignode)
	{ if (orignode->GetMtl() && node->GetMtl()) 
	  { if (orignode->GetMtl()!=node->GetMtl()) 
		{ Mtl *multi = CMaterials(orignode->GetMtl(), node->GetMtl(), c1, c2);
		  orignode->SetMtl(multi);
		  (*canundo)=FALSE;
		}
	  }
	  else if (node->GetMtl()) orignode->SetMtl(node->GetMtl());
	}
	firstmtls=c1;secondmtls=c2;
  }
  else
  { Control *c1=NewDefaultMatrix3Controller();
    wrapoff=GetObjOffMtx(node);
    ReplaceReference(which+2,node->GetTMController());
    theHold.Put(new CreateSurfWrapTM(this,node));
    node->SetTMController(c1);
    boolTm.NoRot();boolTm.NoScale();
    node->SetNodeTM(0,boolTm);
    Point3 spt=Point3(1.0f,1.0f,1.0f);
    ScaleValue s(spt);
    node->SetObjOffsetScale(s);
    Quat q;q.Identity();
    node->SetObjOffsetRot(q);
    node->SetObjOffsetPos(Zero);
  }
  SuspendAnimate();
  AnimateOff();
  SetXFormPacket pckt(oppTm,boolTm);
  if (which)
  { tm2->SetValue(0,&pckt);}
  else { tm1->SetValue(0,&pckt);}
  ResumeAnimate();
  if (delnode) ip->DeleteNode(node);
  NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
  theHold.Accept(GetString(IDS_AP_PICKWTOOBJ));
  ivalid.SetEmpty();
}		

Object *SurfWrapObject::GetPipeObj(TimeValue t,int which)
	{
	ObjectState os;
	if (which==0) {
		if (ob1) {
			os = ob1->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
	} else {
		if (ob2) {
			os = ob2->Eval(t);
			return os.obj;
		} else {
			return NULL;
			}
		}
	return os.obj;
	}

Matrix3 SurfWrapObject::GetOpTM(TimeValue t,int which,Interval *iv)
	{
	Matrix3 tm(1);
	Interval valid, *v;
	if (iv) v = iv;
	else v = &valid;
	
	if (which==0)
	{ if (tm1) 
	{tm1->GetValue(t,&tm,*v,CTRL_RELATIVE);
	  wrappivot=wrapoff.GetTrans();
	 } else wrappivot=Zero;
	}
	else if (which==1)
	{ if (tm2) 
	{tm2->GetValue(t,&tm,*v,CTRL_RELATIVE);
	  topivot=wrapoff2.GetTrans();
	 } else topivot=Zero;
	}
	return tm;
	}	   

int SurfWrapObject::RenderBegin(TimeValue t, ULONG flags)
	{
	SetFlag(SWRAP_INRENDER);
	if (TestFlag(SWRAP_UPDATERENDER)) {
		ivalid.SetEmpty();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	return 0;
	}

int SurfWrapObject::RenderEnd(TimeValue t)
	{
	ClearFlag(SWRAP_INRENDER);	
	return 0;
	}

void SurfWrapObject::Init(int total)
	{
	}

BOOL SurfWrapObject::Progress(int p)
	{
	SHORT res = GetAsyncKeyState(VK_ESCAPE);
	if (res&1) {
		return FALSE;
		}
	else return TRUE;
	}

 #define EPSILON	0.0001f

int RayIntersect(Ray& ray, float& at, Point3& norm,Mesh *amesh,Tab<VNormal> vnorms,Tab<Point3> fnorms)
	{
	DWORD fi;
	Point3 bary;
	Face *face = amesh->faces;	
	Point3 v0, v1, v2;
	Point3 n, sum, p, bry;
	float d, rn, a;
	Matrix3 vTM(1);
	BOOL first = FALSE;
	fi = 0xFFFFFFFF;

	for (int i=0; i<amesh->getNumFaces(); i++,face++) {
		n = fnorms[i];
		
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (rn > -EPSILON) continue;
		
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);

		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;

		// Must be positive...
		if (a < 0.0f) continue;

		// Must be closer than the closest at so far
		if (first) {
			if (a > at) continue;
			}

		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;

		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);

		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;

		// Hit!
		first = TRUE;		
		at    = a;
		fi    = (DWORD)i;		
//		bary.x  = bry.z;
//		bary.y  = bry.x;
//		bary.z  = bry.y;
		bary  = bry;	// DS 3/8/97
		
		// Use interpolated normal instead.
		if (!face->smGroup) {
			norm  = n;
		} else {
			norm = 
				vnorms[face->v[0]].GetNormal(face->smGroup) * bary.x +
				vnorms[face->v[1]].GetNormal(face->smGroup) * bary.y +
				vnorms[face->v[2]].GetNormal(face->smGroup) * bary.z;
			norm = Normalize(norm);
			}
		}

	return first;
	}

void GetVFLst(Mesh* dmesh,Tab<VNormal>* vnorms,Tab<Point3>* fnorms)	 
{ int nv=dmesh->getNumVerts();	
  int nf=dmesh->getNumFaces();	
  (*fnorms).Resize(nf);
  (*fnorms).SetCount(nf);
  (*vnorms).Resize(nv);
  (*vnorms).SetCount(nv);
  Face *face = dmesh->faces;
  for (int i=0; i<nv; i++) 
    (*vnorms)[i] = VNormal();
  Point3 v0, v1, v2;
  for (i=0; i<dmesh->getNumFaces(); i++,face++) 
  {	// Calculate the surface normal
	v0 = dmesh->verts[face->v[0]];
	v1 = dmesh->verts[face->v[1]];
	v2 = dmesh->verts[face->v[2]];
	(*fnorms)[i] = (v1-v0)^(v2-v1);
	for (int j=0; j<3; j++) 
	   (*vnorms)[face->v[j]].AddNormal((*fnorms)[i],face->smGroup);
    (*fnorms)[i] = Normalize((*fnorms)[i]);
  }
  for (i=0; i<nv; i++) 
	(*vnorms)[i].Normalize();
}

BOOL GetV(Mesh* dmesh,DWORD vnum,Point3 *localpt)	 
{ int nv=dmesh->getNumVerts();	
  int nf=dmesh->getNumFaces();
  Point3 vnorms=Point3(0.0f,0.0f,0.0f);
  Face *face = dmesh->faces;
  Point3 fnorm;int vfound=0;
  Point3 v0, v1, v2;
  for (int i=0; i<dmesh->getNumFaces(); i++,face++) 
  if ((face->v[0]==vnum)||(face->v[1]==vnum)||(face->v[2]==vnum))
  {	// Calculate the surface normal
	v0 = dmesh->verts[face->v[0]];
	v1 = dmesh->verts[face->v[1]];
	v2 = dmesh->verts[face->v[2]];
	fnorm = (v1-v0)^(v2-v1);
	vnorms+=fnorm;
	vfound++;
  }
  if (!vfound) return FALSE;
  *localpt=vnorms/(float)vfound;
  return TRUE;
}

#define LOTSOFACES	2000

BOOL SurfWrapObject::UpdateMesh(TimeValue t,BOOL force,BOOL sel)
{	//Point3 Zero=Point3(0.0f,0.0f,0.0f);
	int vertexnum=0,face=0,dverts=0,dfaces=0,dtv,inrend=TestFlag(SWRAP_INRENDER); 
	if (!ivalid.InInterval(t)&&(TestFlag(SWRAP_UPDATEALWAYS) || 
		(TestFlag(SWRAP_UPDATERENDER)&&TestFlag(SWRAP_INRENDER)) ||	force)) 
	{	Point3 localpt;
		BOOL ismirrored = FALSE;
		int normtype;
		pblock->GetValue(PB_GETNORM,t,normtype,ivalid);
		if ((normtype!=1)||(mbase))
		{	ivalid = FOREVER;
			BOOL needsDel1, needsDel2;

			TriObject *towrapOb, *tob2;
			towrapOb = GetTriObject(t,ob1,ivalid,needsDel1);
			tob2 = GetTriObject(t,ob2,ivalid,needsDel2);
			Matrix3 towtm;
			towtm = GetOpTM(t,0,&ivalid);

			if (DotProd((towtm.GetRow(0)^towtm.GetRow(1)),towtm.GetRow(2)) < 0.0f)
				ismirrored = TRUE;

			if (towrapOb)
			{	ob1verts=towrapOb->GetMesh().getNumVerts();
				ob1faces=towrapOb->GetMesh().getNumFaces();
			} 
			else 
			{	ob1verts=0;
				ob1faces=0;
			}

			int infaces, intvs;
			int holdv0, holdv1, holdv2, holdvis0, holdvis1, holdvis2;
			DWORD onetvert, holdtverts[3];

			if (!(towrapOb && tob2))
			{	mesh.DeepCopy(&towrapOb->GetMesh(), OBJ_CHANNELS);//GEOM_CHANNEL|TOPO_CHANNEL|TEXMAP_CHANNEL|DISP_ATTRIB_CHANNEL|SELECT_CHANNEL|SUBSEL_TYPE_CHANNEL);
				for (int i=0;i<ob1verts;i++)
					mesh.verts[i]=mesh.verts[i]*towtm;
				if (needsDel1) 
					towrapOb->DeleteThis();
				if (ismirrored)	
				{	infaces = mesh.getNumFaces();
					for (int revface=0 ; revface < infaces ; revface++)
					{	holdv0 = mesh.faces[revface].v[0];
						holdv1 = mesh.faces[revface].v[1];
						holdv2 = mesh.faces[revface].v[2];
						holdvis0 = mesh.faces[revface].getEdgeVis(0);
						holdvis1 = mesh.faces[revface].getEdgeVis(2);
						holdvis2 = mesh.faces[revface].getEdgeVis(3);
						mesh.faces[revface].setEdgeVis(0,holdvis1);
						mesh.faces[revface].setEdgeVis(1,holdvis0);
						mesh.faces[revface].setVerts(holdv2, holdv1, holdv0);
						intvs = mesh.getNumTVerts();
						if (intvs)
						{	holdtverts[0] = mesh.tvFace[revface].getTVert(0);
							holdtverts[1] = mesh.tvFace[revface].getTVert(1);
							holdtverts[2] = mesh.tvFace[revface].getTVert(2);
							onetvert = holdtverts[0];
							holdtverts[0] = holdtverts[2];
							holdtverts[2] = onetvert;
							mesh.tvFace[revface].setTVerts(holdtverts);
						}
					}
				}
				mesh.InvalidateGeomCache(); 	
//				mesh.InvalidateTopologyCache();
//				mesh.BuildStripsAndEdges();
				return ivalid.InInterval(t);
			}
			int inverts,hdist;
			int totfaces,tottvs;
			Matrix3 tm;tm.IdentityMatrix();
			HCURSOR hCur;
			tm = GetOpTM(t,1,&ivalid);
			int origvs;
			origvs = dverts=tob2->GetMesh().getNumVerts();
			dfaces = tob2->GetMesh().getNumFaces();
			intvs = towrapOb->GetMesh().getNumTVerts();
			dtv = tob2->GetMesh().getNumTVerts();
			inverts = towrapOb->GetMesh().getNumVerts();
			infaces = towrapOb->GetMesh().getNumFaces();
			intvs = towrapOb->GetMesh().getNumTVerts();
			pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
			if (hdist)
			{	dverts=0;
				dfaces=0;
				dtv=-1;
			}
			mesh.setNumVerts(inverts+dverts);
			int inmap,dmap,totalmaps=nummaps(tob2,towrapOb,hdist,inmap,dmap);
			mesh.setNumMaps(totalmaps);
			if (infaces+dfaces > LOTSOFACES) 
				hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
			GetAsyncKeyState(VK_ESCAPE);  
			Matrix3 invtm=Inverse(tm);
			Ray ray;
			if (!normtype) 
				localpt=viewPt; 
			else if (normtype==1)
			{	Matrix3 ntm = mbase->GetObjectTM(t,&ivalid);
				localpt=ntm.GetRow(2);
				Matrix3 nooff=mainnode->GetObjectTM(t);
				nooff.NoTrans();localpt=localpt*Inverse(nooff);
			}
			int selverts;				
			float kdef,standoff;
			pblock->GetValue(PB_USESELVERTS,t,selverts,ivalid);
			pblock->GetValue(PB_KIDEFAULT,t,kdef,ivalid);
			pblock->GetValue(PB_STANDOFF,t,standoff,ivalid);
			Mesh *tmpmesh=new Mesh;
			tmpmesh->DeepCopy(&tob2->GetMesh(), GEOM_CHANNEL|TOPO_CHANNEL);
/*			mesh.selLevel=tob2->GetMesh().selLevel;
			mesh.dispFlags=tob2->GetMesh().dispFlags;
			mesh.faceSel=tob2->GetMesh().faceSel;
			mesh.faceSel=tob2->GetMesh().faceSel;
			mesh.edgeSel=tob2->GetMesh().edgeSel;
			mesh.vertHide=tob2->GetMesh().vertHide;*/

			for (int j=0;j<origvs;j++)
			{	tmpmesh->verts[j] = tmpmesh->verts[j]*tm;
			}
			Point3 wrapc;
			if ((normtype==3)||(normtype==5))
			{	wrapc=(normtype==3?towrapOb->GetMesh().getBoundingBox().Center():wrappivot);
				wrapc=wrapc*towtm;
			}
			else if (normtype>3)
			{	wrapc=(normtype==4?tob2->GetMesh().getBoundingBox().Center():topivot);
				wrapc=wrapc*tm;
			}
			Tab<VNormal> vnorms;
			Tab<Point3> fnorms;
			GetVFLst(tmpmesh,&vnorms,&fnorms);
			BOOL inface=TRUE;
			for (int i=0;i<inverts;i++)
			{	Point3 vert=towrapOb->GetMesh().verts[i]*towtm;
				if (normtype==2)
				{	inface=GetV(&towrapOb->GetMesh(),i,&localpt);
					localpt = Normalize(-localpt*towtm);
				}
				else if (normtype>2)
				{	localpt = Normalize(wrapc-vert);	
				}
				ray.dir=localpt;
				float *vssel = NULL;
				if (selverts) vssel = towrapOb->GetMesh().getVSelectionWeights ();
				if (inface&&((!selverts)||(towrapOb->GetMesh().vertSel[i])||(vssel&&vssel[i])))
				{	ray.p=vert;
					float at;Point3 norm;
					int kfound=RayIntersect(ray,at,norm,tmpmesh,vnorms,fnorms);
//					int kfound=tmpmesh->IntersectRay(ray,at,norm);
					if (!kfound) 
						vert+=kdef*localpt;
					else 
					{ 	Point3 intersect=ray.p+ray.dir*at;
						intersect=vert-intersect;
						vert=vert+localpt*(Length(intersect)-standoff);
					}
				}			
				mesh.verts[i]=vert;
			}
			vnorms.SetCount(0);vnorms.Shrink();
			fnorms.SetCount(0);fnorms.Shrink();
			mesh.setNumFaces(totfaces=(infaces+dfaces));
			tottvs=intvs+(dtv>0?dtv:0);
			BOOL tvs=((intvs>0)||(dtv>0));
			if ((tvs)&&((intvs==0)||(dtv==0))) 
				tottvs++;
			mesh.setNumTVerts(tottvs);
			mesh.setNumTVFaces(tvs?totfaces:0);
			if (totalmaps>2) mapstuff(&mesh,tob2,towrapOb,inmap,dmap);
			for (i=0;i<infaces;i++)
			{	mesh.faces[i]=towrapOb->GetMesh().faces[i];
				if (firstmtls==1) 
					mesh.faces[i].setMatID(0);
				if (tvs) 
				{	if (intvs>0) 
						mesh.tvFace[i] = towrapOb->GetMesh().tvFace[i];
					else 
						mesh.tvFace[i].setTVerts(dtv,dtv,dtv);
				}
			}
			face = infaces;
			int addvert=inverts;
			for (i=0;i<intvs;i++)
				mesh.tVerts[i]=towrapOb->GetMesh().tVerts[i];
			if (tvs)
			{	if (intvs==0) 
					mesh.tVerts[dtv]=Zero;
				else if (dtv==0) 
					mesh.tVerts[intvs]=Zero;
			} 
			for (i=0;i<dtv;i++)
				mesh.tVerts[i+intvs]=tob2->GetMesh().tVerts[i];
			vertexnum=inverts;
			if (tob2 &&(!hdist))
			{	for (i=0;i<dverts;i++)
					for (i=0;i<dverts;i++)
						mesh.verts[vertexnum++]=tmpmesh->verts[i];
						for (i=0;i<dfaces;i++)
						{	memcpy(&mesh.faces[face],&tob2->GetMesh().faces[i],sizeof(Face));
							mesh.faces[face].v[0]+=addvert;
							mesh.faces[face].v[1]+=addvert;
							mesh.faces[face].v[2]+=addvert;
							mesh.faces[face].setMatID(firstmtls+(secondmtls==1?0:tob2->GetMesh().faces[i].getMatID()));		
							if (tvs) 
							{	if (dtv>0) 
									mesh.tvFace[face].setTVerts(tob2->GetMesh().tvFace[i].t[0]+intvs,tob2->GetMesh().tvFace[i].t[1]+intvs,tob2->GetMesh().tvFace[i].t[2]+intvs);
								else 
									mesh.tvFace[face].setTVerts(intvs,intvs,intvs);
							}
							face++;
						}
			}
			if (tmpmesh) 
				delete tmpmesh;
			if (needsDel1)
				towrapOb->DeleteThis();
			if (needsDel2)
				tob2->DeleteThis();
// here -->
			if (ismirrored)	
			{	infaces = mesh.getNumFaces();
				for (int revface=0 ; revface < infaces ; revface++)
				{	holdv0 = mesh.faces[revface].v[0];
					holdv1 = mesh.faces[revface].v[1];
					holdv2 = mesh.faces[revface].v[2];
					holdvis0 = mesh.faces[revface].getEdgeVis(0);
					holdvis1 = mesh.faces[revface].getEdgeVis(2);
					holdvis2 = mesh.faces[revface].getEdgeVis(3);
					mesh.faces[revface].setEdgeVis(0,holdvis1);
					mesh.faces[revface].setEdgeVis(1,holdvis0);
					mesh.faces[revface].setVerts(holdv2, holdv1, holdv0);
					intvs = mesh.getNumTVerts();
					if (intvs)
					{	holdtverts[0] = mesh.tvFace[revface].getTVert(0);
						holdtverts[1] = mesh.tvFace[revface].getTVert(1);
						holdtverts[2] = mesh.tvFace[revface].getTVert(2);
						onetvert = holdtverts[0];
						holdtverts[0] = holdtverts[2];
						holdtverts[2] = onetvert;
						mesh.tvFace[revface].setTVerts(holdtverts);
					}
				}
			}

			mesh.InvalidateGeomCache(); 	
//			mesh.InvalidateTopologyCache();
//			mesh.BuildStripsAndEdges();
		} 
	}
	else 
	{	if (!ivalid.InInterval(t)) 
		{	ivalid.SetInstant(t); 
		}
	}
	return ivalid.InInterval(t);
}

Interval SurfWrapObject::ObjectValidity(TimeValue t)
	{ 
	UpdateMesh(t);
	if (ivalid.Empty()) return Interval(t,t);
	else return ivalid;
	}

int SurfWrapObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 || ob2) return 1;
		else return 0;
	}
	return Object::CanConvertToType(obtype);
/*	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		if (ob1 && ob2) return 1;
		else if (ob1) return ob1->CanConvertToType(obtype);
		else if (ob2) return ob2->CanConvertToType(obtype);
		else return 0;
		}*/
	return Object::CanConvertToType(obtype);
	}

Object* SurfWrapObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	if (obtype==defObjectClassID||obtype==triObjectClassID||obtype==mapObjectClassID) {
		// Since PrepForBoolean changes the mesh, we should use UpdateMesh to produce new
		// output even when there is only 1 operand.
		TriObject *triob;
		UpdateMesh(t);
		triob = CreateNewTriObject();
		triob->GetMesh() = mesh;
		triob->SetChannelValidity(TOPO_CHAN_NUM,ObjectValidity(t));
		triob->SetChannelValidity(GEOM_CHAN_NUM,ObjectValidity(t));
		return triob;
	} else {
		return Object::ConvertToType(t,obtype);
	}
}

ObjectState SurfWrapObject::Eval(TimeValue time)
	{
	return ObjectState(this);
	}



BOOL SWPickOperand::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(bo->ip->GetTime());
		if (os.obj->IsParticleSystem() || 
			os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}

		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL SWPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) {
	  Interval intvalid;
	  BOOL needsDel;
	  Object *tob=node->GetObjectRef();
	  TriObject *tri=GetTriObject(ip->GetTime(),tob,intvalid,needsDel);
	  if (tri==NULL) { node = NULL; return FALSE;	}
	    if (needsDel) tri->DeleteThis();
		node->BeginDependencyTest();
		bo->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}		
		}

	return node ? TRUE : FALSE;
	}

BOOL SWPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	int stkclr=IDYES;
	if ((bo->mainnode)&&((bo->mainnode->GetMtl() && node->GetMtl())&& (bo->mainnode->GetMtl()!=node->GetMtl())) )
	{ TSTR buf(GetString(IDS_AP_MTLMSG));
	  TSTR buf1(GetString(IDS_AP_MTLTITLE));
	  stkclr=MessageBox(NULL,buf,buf1,MB_ICONQUESTION|MB_YESNO);
	}
	if (stkclr==IDNO) return FALSE;
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	ip->FlashNodes(&nodes);
	Matrix3 ourTM;
	Matrix3 ntm = node->GetObjectTM(ip->GetTime());	
	theHold.Begin();
	theHold.Put(new CreateWraptoref(bo,bo->opbName,node->GetName()));
	BOOL matRet = TRUE;

	if (bo->creating) {
		ourTM = bo->createTM;
	} else {
		if (bo->mainnode) {
			ourTM = bo->mainnode->GetObjectTM(ip->GetTime());
		} else {
			MaxAssert(0);
			ourTM.IdentityMatrix();
			}
		}

/*	if (bo->mainnode) {
		if (bo->mainnode->GetMtl() && node->GetMtl() && (bo->mainnode->GetMtl()!=node->GetMtl())) {
			matRet = bo->DoAttachMatOptionDialog (bo->pmapDist->GetHWnd());
			bo->inheritMat = FALSE;
		}
		if (!bo->mainnode->GetMtl() && node->GetMtl()) {
			matRet = bo->DoInheritMatOptionDialog (bo->pmapDist->GetHWnd());
		}
	}

	if (!matRet) return FALSE;

	theHold.Begin();
	bo->SetOperandB (ip->GetTime(), node, bo->mainnode, bo->addOppMethod,
		bo->inheritMat ? BOOL_MAT_DISCARD_ORIG : bo->attachMat, &canUndo);
	bo->ReleaseMyNode();
	theHold.Accept(GetString(IDS_PICK_OPERAND));
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
*/	
	bool canUndo = TRUE;
	bo->SetOperand(node,ourTM,ntm,1,bo->mainnode,&canUndo);	
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	GenerateViewRay(&bo->viewPt,bo->ip);
	bo->SetFlag(SWRAP_DISPRESULT);
	CheckRadioButton(bo->pmapObjects->GetHWnd(),IDC_SW_DISPRESULT,IDC_SW_DISPOPS,IDC_SW_DISPRESULT);
	bo->ivalid.SetEmpty();
	bo->UpdateMesh(ip->GetTime(),TRUE);
	
	if (bo->creating) {
		theCreateSWrapMode.JumpStart(ip,bo);
		ip->SetCommandMode(&theCreateSWrapMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void SWPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapDist->GetHWnd(),IDC_AP_SURFWRAP_OBJECTPICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void SWPickOperand::ExitMode(IObjParam *ip)
	{
	if (bo->pmapDist)
	{ ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapDist->GetHWnd(),IDC_AP_SURFWRAP_OBJECTPICK));
	  if (iBut) iBut->SetCheck(FALSE);
	  ReleaseICustButton(iBut);
	}
	}

BOOL SWPickNorm::Filter(INode *node)
	{
	return node ? TRUE : FALSE;
	}

BOOL SWPickNorm::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	return node ? TRUE : FALSE;
	}

BOOL SWPickNorm::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	ip->FlashNodes(&nodes);
	if (bo->mbase) bo->ReplaceReference(MBASE,node,TRUE);
	else bo->MakeRefByID(FOREVER,MBASE,node);
	bo->normname = TSTR(node->GetName());
	bo->ShowNormName();
	bo->ivalid.SetEmpty();
	bo->UpdateMesh(ip->GetTime(),TRUE);
	
	if (bo->creating) {
		theCreateSWrapMode.JumpStart(ip,bo);
		ip->SetCommandMode(&theCreateSWrapMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void SWPickNorm::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapObjects->GetHWnd(),IDC_AP_SURFWRAP_OBJECTDPICK3));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void SWPickNorm::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(bo->pmapObjects->GetHWnd(),IDC_AP_SURFWRAP_OBJECTDPICK3));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}

class SurfWrapPickObj : public ParamMapUserDlgProc {
	public:
		SurfWrapObject *po;

		SurfWrapPickObj(SurfWrapObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
		void Update(TimeValue t);
	};
void SurfWrapPickObj::Update(TimeValue t)
{	if (!po->editOb) return;
    po->ShowName(po->ob2!=NULL);
}

BOOL SurfWrapPickObj::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_SURFWRAP_OBJECTPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
		    ReleaseICustButton(iBut);
			po->ShowName(po->ob2!=NULL);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_SURFWRAP_OBJECTPICK:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSWrapMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSWrapMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.bo = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			}
			break;	
		}
	return TRUE;
}

class SurfWrapObjList : public ParamMapUserDlgProc {
	public:
		SurfWrapObject *po;

		SurfWrapObjList(SurfWrapObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void CalcButton(HWND hWnd,BOOL ON)
{	ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_SWRAP_RECALC));
	if (ON)  iBut->Enable();
	 else iBut->Disable();
	ReleaseICustButton(iBut);
}
void ViewNormButton(HWND hWnd,int whichon)
{	ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_SURFWRAP_OBJECTDPICK2));
	ICustButton *iBut2 = GetICustButton(GetDlgItem(hWnd,IDC_AP_SURFWRAP_OBJECTDPICK3));
	if (!whichon)  
	{ iBut->Enable();  
	  iBut2->Disable();  
	  EnableWindow(GetDlgItem(hWnd,IDC_AP_SURFWRAP_NORMOBJ),FALSE);
	}
	else if (whichon==1)
	{ iBut->Disable();
	  iBut2->Enable();  
	  EnableWindow(GetDlgItem(hWnd,IDC_AP_SURFWRAP_NORMOBJ),TRUE);
	}
	else
	{ iBut->Disable();
	  iBut2->Disable();
	  EnableWindow(GetDlgItem(hWnd,IDC_AP_SURFWRAP_NORMOBJ),FALSE);
	}
	ReleaseICustButton(iBut);
	ReleaseICustButton(iBut2);
}
void SurfWrapObjList::Update(TimeValue t)
{	if (!po->editOb) return;
	HWND hWnd=po->pmapObjects->GetHWnd();
	po->ShowOpList(po->ob2!=NULL);
	CheckDlgButton(hWnd,IDC_SW_DISPRESULT,po->TestFlag(SWRAP_DISPRESULT));
	CheckDlgButton(hWnd,IDC_SW_DISPOPS,!po->TestFlag(SWRAP_DISPRESULT));	
	if (po->TestFlag(SWRAP_UPDATERENDER)) CheckDlgButton(hWnd,IDC_SWRAP_UPDATERENDER,TRUE);
	else CheckDlgButton(hWnd,IDC_SWRAP_UPDATERENDER,FALSE);
	if (po->TestFlag(SWRAP_UPDATEMANUAL)) CheckDlgButton(hWnd,IDC_SWRAP_UPDATEMANUAL,TRUE);
	else CheckDlgButton(hWnd,IDC_SWRAP_UPDATEMANUAL,FALSE);
	if (po->TestFlag(SWRAP_UPDATEALWAYS)) CheckDlgButton(hWnd,IDC_SWRAP_UPDATEALWAYS,TRUE);
	else CheckDlgButton(hWnd,IDC_SWRAP_UPDATEALWAYS,FALSE);
//	if (po->TestFlag(SWRAP_UPDATESELECT)) CheckDlgButton(hWnd,IDC_SWRAP_UPDATESELECT,TRUE);
//	else CheckDlgButton(hWnd,IDC_SWRAP_UPDATESELECT,FALSE);	
	ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_SWRAP_RECALC));
	CalcButton(hWnd,po->TestFlag(SWRAP_UPDATEMANUAL));
	ReleaseICustButton(iBut);		
	iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_SURFWRAP_OBJECTDPICK3));
	iBut->SetType(CBT_CHECK);
	iBut->SetHighlightColor(GREEN_WASH);
    ReleaseICustButton(iBut);
	po->ShowNormName();
	int tview;
	po->pblock->GetValue(PB_GETNORM,0,tview,FOREVER);
	ViewNormButton(hWnd,(po->dlgNormby=tview));
}

BOOL SurfWrapObjList::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_CUSTEDIT_ENTER: {
			ICustEdit *edit;
			TCHAR buf[256];
			
			switch (LOWORD(wParam)) {
				case IDC_SWRAP_ANAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_SWRAP_ANAME));					
					edit->GetText(buf,256);
					po->opaName = TSTR(buf);					
					if (po->ob1) po->ob1->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;
					
				case IDC_SWRAP_BNAME:
					edit = GetICustEdit(GetDlgItem(hWnd,IDC_SWRAP_BNAME));					
					edit->GetText(buf,256);
					po->opbName = TSTR(buf);
					if (po->ob2) po->ob2->NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE,TREE_VIEW_CLASS_ID);
					break;					
				}
			
			po->ShowOpList(po->ob2!=NULL);
			break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SWRAP_OPERANDS:
					if (HIWORD(wParam)==LBN_SELCHANGE) 
					{	po->flags &= ~SWRAP_ANYSEL;
						
						if (SendMessage((HWND)lParam,LB_GETSEL,0,0)) 
						{ po->flags |= SWRAP_OB1SEL;	}
							
						if (SendMessage((HWND)lParam,LB_GETSEL,1,0))
						{ po->flags |= SWRAP_OB2SEL;	}
						po->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
						po->NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
						po->ip->RedrawViews(po->ip->GetTime());
					}
					break;
				case IDC_SW_DISPOPS:
				case IDC_SW_DISPRESULT:
					if (IsDlgButtonChecked(hWnd,IDC_SW_DISPRESULT)) {						
						po->SetFlag(SWRAP_DISPRESULT);
					} else {
						po->ClearFlag(SWRAP_DISPRESULT);
						}
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					po->ip->RedrawViews(po->ip->GetTime());
					break;
			  case IDC_AP_VIEWDIR:
				{ ViewNormButton(hWnd,(po->dlgNormby=0));
				  break;
				}
			  case IDC_AP_OBJECTDIR:
				{ ViewNormButton(hWnd,(po->dlgNormby=1));
				  break;
				}
			  case IDC_AP_VERTEXDIR:
				{ ViewNormButton(hWnd,(po->dlgNormby=2));
				  break;
				}
			  case IDC_AP_WRAPPERCTRDIR:
				{ ViewNormButton(hWnd,(po->dlgNormby=3));
				  break;
				}
			  case IDC_AP_WRAP2CTRDIR:
				{ ViewNormButton(hWnd,(po->dlgNormby=4));
				  break;
				}
			  case IDC_AP_SURFWRAP_OBJECTDPICK2:
				  {	Point3 oldpt=po->viewPt;
					GenerateViewRay(&po->viewPt,po->ip);
					if (!(oldpt==po->viewPt))
					{ po->ivalid.SetEmpty();
					  po->UpdateMesh(t);
					  po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					  po->ip->RedrawViews(t);
					}
				  }
					break;
			  case IDC_AP_SURFWRAP_OBJECTDPICK3:
				    if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSWrapMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSWrapMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickNorm.bo = po;						
						  po->ip->SetPickMode(&po->pickNorm);
						}
					break;

				case IDC_SWRAP_RECALC:
					po->ivalid.SetEmpty();
					po->UpdateMesh(t,TRUE);
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					po->ip->RedrawViews(t);
					break;

				case IDC_SWRAP_UPDATEALWAYS:
					po->ClearFlag(SWRAP_UPDATEALWAYS|SWRAP_UPDATERENDER|SWRAP_UPDATEMANUAL);
					po->SetFlag(SWRAP_UPDATEALWAYS);					
					po->ip->RedrawViews(po->ip->GetTime());
					CalcButton(hWnd,FALSE);
					break;

/*				case IDC_SWRAP_UPDATESELECT:
					po->ClearFlag(SWRAP_UPDATEALWAYS|SWRAP_UPDATERENDER|SWRAP_UPDATEMANUAL|SWRAP_UPDATESELECT);
					po->SetFlag(SWRAP_UPDATESELECT);					
					po->ip->RedrawViews(po->ip->GetTime());
					CalcButton(hWnd,FALSE);
					break;	*/			

				case IDC_SWRAP_UPDATERENDER:
					po->ClearFlag(SWRAP_UPDATEALWAYS|SWRAP_UPDATERENDER|SWRAP_UPDATEMANUAL);
					po->SetFlag(SWRAP_UPDATERENDER);					
					CalcButton(hWnd,FALSE);
					break;

				case IDC_SWRAP_UPDATEMANUAL:
					po->ClearFlag(SWRAP_UPDATEALWAYS|SWRAP_UPDATERENDER|SWRAP_UPDATEMANUAL);
					po->SetFlag(SWRAP_UPDATEMANUAL);					
					CalcButton(hWnd,TRUE);
					break;
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
}

void SurfWrapObject::InvalidateUI()
	{
	if (pmapDist) pmapDist->Invalidate();
	if (pmapObjects) pmapObjects->Invalidate();
	}

void SurfWrapObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	this->ip = ip;	
	editOb   = this;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else {
		creating = FALSE;
		// Create sub object editing modes.
		moveMode       = new MoveModBoxCMode(this,ip);
		rotMode        = new RotateModBoxCMode(this,ip);
		uscaleMode     = new UScaleModBoxCMode(this,ip);
		nuscaleMode    = new NUScaleModBoxCMode(this,ip);
		squashMode     = new SquashModBoxCMode(this,ip);
		selectMode     = new SelectModBoxCMode(this,ip);
		
		// Add our sub object type
		TSTR type(GetString(IDS_AP_OPERANDS));
		const TCHAR *ptype[] = {type};
		ip->RegisterSubObjectTypes(ptype, 1);
		}
	if (pmapObjects && pmapDist)
	{	pmapObjects->SetParamBlock(pblock);
		pmapDist->SetParamBlock(pblock);
	}
	else 
	{  pmapDist = CreateCPParamMap(
				descPickDist,PICKDISTDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SURFWRAP_PICKWRAPTO),
				GetString(IDS_AP_PICKWRAPTOOBJ),
				(creating?0:APPENDROLL_CLOSED));
		pmapObjects = CreateCPParamMap(
				descObjects,OBJECTSDESC_LENGTH,
				pblock,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SURFWRAP_OBJECTS),
				GetString(IDS_AP_PARAMETERS),
				0);
  if (pmapObjects) pmapObjects->SetUserDlgProc(new SurfWrapObjList(this));
  if (pmapDist) pmapDist->SetUserDlgProc(new SurfWrapPickObj(this));
	} 
}

void SurfWrapObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	editOb = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapObjects) DestroyCPParamMap(pmapObjects);
		pmapObjects  = NULL;
		if (pmapDist) DestroyCPParamMap(pmapDist);
		pmapDist  = NULL;
		}

	if (!creating) {
		ip->DeleteMode(moveMode);
		ip->DeleteMode(rotMode);
		ip->DeleteMode(uscaleMode);
		ip->DeleteMode(nuscaleMode);
		ip->DeleteMode(squashMode);
		ip->DeleteMode(selectMode);
		if ( moveMode ) delete moveMode;
		moveMode = NULL;
		if ( rotMode ) delete rotMode;
		rotMode = NULL;
		if ( uscaleMode ) delete uscaleMode;
		uscaleMode = NULL;
		if ( nuscaleMode ) delete nuscaleMode;
		nuscaleMode = NULL;
		if ( squashMode ) delete squashMode;
		squashMode = NULL;
		if ( selectMode ) delete selectMode;
		selectMode = NULL;	
	}
	ip->ClearPickMode();
	ip = NULL;
	creating = FALSE;
	}

int SurfWrapObject::NumPipeBranches() 
	{
	int num=0;
	if (TestFlag(SWRAP_OB1SEL) && ob1) num++;
	if (TestFlag(SWRAP_OB2SEL) && ob2) num++;
	return num;
	}

Object *SurfWrapObject::GetPipeBranch(int i) 
	{
	if (i) return ob2;	
	if (TestFlag(SWRAP_OB1SEL)) return ob1;
	return ob2;
	}

INode *SurfWrapObject::GetBranchINode(TimeValue t,INode *node,int i)
	{
	assert(i<2);
	int index = 0;
	if (i) index = 1;
	else if (TestFlag(SWRAP_OB1SEL)) index = 0;
	else index = 1;
	return CreateINodeTransformed(node,GetOpTM(t,index));
	}

int SurfWrapObject::NumSubs()
{ 	return 6; 	}

Animatable* SurfWrapObject::SubAnim(int i)
{ 	switch (i) {
		case 0:  return ob1;
		case 1:  return tm1;
		case 2:	 return ob2;
		case 3:	 return tm2;
		case 4:	 return pblock;
		case 5:  return mbase;
		default: return NULL;
		}	
}

TSTR SurfWrapObject::SubAnimName(int i)
	{	
	switch (i) {
		case 0: return opaName;//return GetString(IDS_AP_OPERANDA);
		case 1: return GetString(IDS_AP_OPERANDATRANSFORM);
		case 2: return opbName;//return GetString(IDS_AP_OPERANDB);
		case 3: return GetString(IDS_AP_OPERANDBTRANSFORM);
		case 4: return GetString(IDS_AP_PARAMETERS);
		case 5: return GetString(IDS_AP_MBASE);
		}
	return _T("Error");
	}

int SurfWrapObject::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case 0:  return REF_OP1;
		case 1:  return REF_CONT1;
		case 2:	 return REF_OP2;
		case 3:	 return REF_CONT2;
		case 4:	 return PBLOCK;
		case 5:	 return MBASE;
		default: return -1;
		}	
	}

RefTargetHandle SurfWrapObject::GetReference(int i)
	{
	switch (i) {
		case REF_OP1: 	return ob1;
		case REF_OP2: 	return ob2;
		case REF_CONT1:	return tm1;
		case REF_CONT2:	return tm2;
		case PBLOCK:	return pblock;
		case MBASE:		return mbase;
		default:        return NULL;
		}
	}
void SurfWrapObject::ShowNormName()
{
TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (mbase ? normname : TSTR(GetString(IDS_AP_NONE)));
SetWindowText(GetDlgItem(pmapObjects->GetHWnd(), IDC_AP_SURFWRAP_NORMOBJ), name);
}
void SurfWrapObject::ShowName(BOOL ob2)
{if (pmapDist)
{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (ob2 ? opbName : TSTR(GetString(IDS_AP_NONE)));
SetWindowText(GetDlgItem(pmapDist->GetHWnd(), IDC_AP_SURFWRAP_WRAPTOOBJ), name);}
}
void SurfWrapObject::ShowOpList(BOOL isobj)
{	if (pmapObjects)
	{ShowName(isobj); 
	HWND hList = GetDlgItem(pmapObjects->GetHWnd(),IDC_SWRAP_OPERANDS);
	SendMessage(hList,LB_RESETCONTENT,0,0);
	TSTR name = TSTR(GetString(IDS_AP_SWRAPTITLE))+ (ob1 ? opaName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	name = TSTR(GetString(IDS_AP_SWRAPTOTITLE))+ (isobj ? opbName : TSTR(_T("")));
	SendMessage(hList,LB_ADDSTRING,0,(LPARAM)(const TCHAR*)name);
	if (flags&SWRAP_OB1SEL) {SendMessage(hList,LB_SETSEL,TRUE,0); }
	if (flags&SWRAP_OB2SEL) {SendMessage(hList,LB_SETSEL,TRUE,1); }
	ICustEdit *edit = GetICustEdit(GetDlgItem(pmapObjects->GetHWnd(),IDC_SWRAP_ANAME));
	edit->SetText(opaName);
	ReleaseICustEdit(edit);

	edit = GetICustEdit(GetDlgItem(pmapObjects->GetHWnd(),IDC_SWRAP_BNAME));
	edit->SetText(opbName);
	ReleaseICustEdit(edit);
}
}

void SurfWrapObject::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case REF_OP1: 	 
			ob1 = (Object*)rtarg;
/*			if (rtarg==NULL) {				
				if (editOb==this) {
					ShowOpList(ob2!=NULL);
					}
			}*/
			break;

		case REF_OP2: 	 
			ob2 = (Object*)rtarg;  
/*			if (rtarg==NULL) {
				if (editOb==this) {
					ShowOpList(ob2!=NULL);
					}
				}*/
			break;

		case REF_CONT1:	 tm1 = (Control*)rtarg; break;
		case REF_CONT2:	 tm2 = (Control*)rtarg; break;
		case PBLOCK:	 pblock=(IParamBlock*)rtarg; break;
		case MBASE:		 mbase=(INode *)rtarg; break;
		}
	}

RefTargetHandle SurfWrapObject::Clone(RemapDir& remap)
	{
	SurfWrapObject *obj = new SurfWrapObject;
	if (pblock) obj->ReplaceReference(PBLOCK,pblock->Clone(remap)); 
	if (ob1) obj->ReplaceReference(REF_OP1,remap.CloneRef(ob1));
	if (ob2) obj->ReplaceReference(REF_OP2,remap.CloneRef(ob2));
	if (tm1) obj->ReplaceReference(REF_CONT1,remap.CloneRef(tm1));
	if (tm2) obj->ReplaceReference(REF_CONT2,remap.CloneRef(tm2));
	if (mbase) obj->ReplaceReference(MBASE,mbase); 
	obj->flags = flags;
	obj->opaName = opaName;
	obj->opbName = opbName;
	obj->ivalid.SetEmpty();
	return obj;
	}

int SurfWrapObject::IntersectRay(
		TimeValue t, Ray& r, float& at, Point3& norm)
	{
	if (TestFlag(SWRAP_DISPRESULT)) {
		UpdateMesh(t);
		return mesh.IntersectRay(r,at,norm);
	} else {
		return 0;
		}
	}

Mesh* SurfWrapObject::GetRenderMesh(
		TimeValue t, INode *inode, View& view, BOOL& needDelete)
	{	
	UpdateMesh(t);
	needDelete = FALSE;
	return &mesh;	
	}

int SurfWrapObject::HitTest(
		TimeValue t, INode* inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt)
	{
	int res = 0;
	BOOL issel=inode->Selected();
	if (ob1 && ob2&& TestFlag(SWRAP_DISPRESULT)) {
		UpdateMesh(t,FALSE,inode->Selected());
		HitRegion hitRegion;
		GraphicsWindow *gw = vpt->getGW();	
		Material *mtl = gw->getMaterial();		
		gw->setTransform(inode->GetObjectTM(t));
		MakeHitRegion(hitRegion, type, crossing, 4, p);
		res = mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return res;
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			res = ob->HitTest(t,&n,type,crossing,flags,p,vpt);
			if (res) return res;
			}
		}
	return res;
	}

void SurfWrapObject::Snap(
		TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{
	if (TestFlag(SWRAP_DISPRESULT)&&ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 tm = inode->GetObjectTM(t);	
		GraphicsWindow *gw = vpt->getGW();		
		gw->setTransform(tm);
		mesh.snap( gw, snap, p, tm );
	} else {	
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->Snap(t,&n,snap,p,vpt);
			}	
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			ob->Snap(t,&n,snap,p,vpt);
			}
		}
	}

#define DRAW_A (1<<1)
#define DRAW_B (1<<2)

int SurfWrapObject::
		Display(TimeValue t, INode* inode, ViewExp *vpt, int aflags)
{	GraphicsWindow *gw = vpt->getGW();

	Object *ob;
		
	DWORD rlim = gw->getRndLimits();

/*	Interval intvalid;
	BOOL needsDel;
	TriObject *tri;*/
	if (ob=GetPipeObj(t,0)) {
	  if (TestFlag(SWRAP_DISPRESULT))
	  { UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 mat;
		mat=inode->GetObjectTM(t);
		gw->setTransform(mat);
		mesh.render(gw, inode->Mtls(),(flags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL, COMP_ALL, inode->NumMtls());
/*		 if (inode->Selected()) {
				 if (TestFlag(SWRAP_OB1SEL)) {
					vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
				 } else {
					Point3 selClr = GetUIColor(COLOR_SELECTION); 
					vpt->getGW()->setColor( LINE_COLOR, selClr.x, selClr.y, selClr.z);
				 	}
				}
		TriObject t1;
		t1.GetMesh().DeepCopy(&mesh,PART_GEOM|PART_TOPO);//|SUBSEL_TYPE_CHANNEL|DISP_ATTRIB_CHANNEL);
		t1.GetMesh().setNumVerts(ob1verts,TRUE);t1.GetMesh().setNumFaces(ob1faces,TRUE);
//		t1.mesh.DeepCopy(&tri->mesh,SUBSEL_TYPE_CHANNEL|DISP_ATTRIB_CHANNEL);
//		t1.mesh.dispFlags=tri->mesh.dispFlags;COMP_ALL| ((aflags&DISP_SHOWSUBOBJECT)?COMP_OBJSELECTED:0)
		t1.GetMesh().render(gw, inode->Mtls(),(aflags&USE_DAMAGE_RECT)?&vpt->GetDammageRect():NULL, COMP_ALL, inode->NumMtls());				 */
	  }
	  else
		{	INodeTransformed n(inode,GetOpTM(t,0));
			if (inode->Selected()) 
			{ if (TestFlag(SWRAP_OB1SEL)) 
				vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
			  else vpt->getGW()->setColor( LINE_COLOR, GetSelColor());
			}
			ob->Display(t,&n,vpt,aflags);
//	    if (needsDel) tri->DeleteThis(); 
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			if (inode->Selected()) 
			{ if (TestFlag(SWRAP_OB2SEL)) 
				vpt->getGW()->setColor(LINE_COLOR,1.0f,0.0f,0.0f);
			  else vpt->getGW()->setColor( LINE_COLOR, GetSelColor());
			}
			ob->Display(t,&n,vpt,flags);
		}
		}
	}
		
	gw->setRndLimits(rlim);
	return 0;
}

void SurfWrapObject::GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel)
{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(SWRAP_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t);
		box = mesh.getBoundingBox(tm);
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {				
			if (tm) {
				Matrix3 mat = GetOpTM(t,0) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	if (tm) {
				Matrix3 mat = GetOpTM(t,1) * *tm;
				ob->GetDeformBBox(t,abox,&mat,useSel);
			} else ob->GetDeformBBox(t,abox,NULL,useSel);
			box += abox;
			}
		}
	}

void SurfWrapObject::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt, Box3& box) 
	{
	Box3 abox;
	abox.Init();
	box.Init();
	if (TestFlag(SWRAP_DISPRESULT) && ob1 && ob2) {
		UpdateMesh(t,FALSE,inode->Selected());
		box = mesh.getBoundingBox();	
	} else {
		Object *ob;
		if (ob=GetPipeObj(t,0)) {
			INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,0);
			box += abox;
			}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
		{	INodeTransformed n(inode,GetOpTM(t,1));
			ob->GetLocalBoundBox(t,&n,vpt,abox);
			if (!abox.IsEmpty()) abox = abox * GetOpTM(t,1);
			box += abox;
			}
		}
	}

void SurfWrapObject::GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
{	Box3 abox;
	int disp = 0;
	abox.Init();
	box.Init();

	if (TestFlag(SWRAP_DISPRESULT) && ob1 && ob2) 
	{	UpdateMesh(t,FALSE,inode->Selected());
		Matrix3 mat = inode->GetObjectTM(t);	
		box = mesh.getBoundingBox();
		if (!box.IsEmpty()) box = box * mat;
	} 
	else 
	{ Object *ob;
	  if (ob=GetPipeObj(t,0)) 
	  {		INodeTransformed n(inode,GetOpTM(t,0));
			ob->GetWorldBoundBox(t,&n,vpt,abox);
			box += abox;
	  }
		
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)))
	  {	INodeTransformed n(inode,GetOpTM(t,1));
		ob->GetWorldBoundBox(t,&n,vpt,abox);
		box += abox;
	  }
	}
}

RefResult SurfWrapObject::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message ) 
	{
	switch (message) {
		case REFMSG_SELECT_BRANCH:
			if (hTarget==ob1 || hTarget==ob2) {
				ClearFlag(SWRAP_OB1SEL|SWRAP_OB2SEL);
				if (hTarget==ob1) SetFlag(SWRAP_OB1SEL);
				if (hTarget==ob2) SetFlag(SWRAP_OB2SEL);
				NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
				NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
				}
			break;
		case REFMSG_CHANGE:
			 ivalid.SetEmpty();
			if (editOb==this) InvalidateUI();
			break;
		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			ivalid.SetEmpty();
			if (editOb==this) InvalidateUI();
			break;
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==mbase) mbase=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==mbase) 
			  { normname = TSTR(mbase->GetName());
			    ShowNormName();
				}
			  break;
			}
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}




//--Subobject Selection-------------------------------------------------------------


void SurfWrapObject::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(SWRAP_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(SWRAP_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

void SurfWrapObject::Rotate(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Quat& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(SWRAP_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(SWRAP_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

void SurfWrapObject::Scale(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (TestFlag(SWRAP_OB1SEL) && tm1) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm1->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	if (TestFlag(SWRAP_OB2SEL) && tm2) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tm2->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}

/*int SurfWrapObject::HitTest(TimeValue t, INode* inode, int type, int crossing,int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{	
	int savedLimits, res = 0;
	
	UpdateMesh(t,FALSE,inode->Selected());
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	gw->setHitRegion(&hitRegion);
	gw->setTransform(inode->GetObjectTM(t));
	SubObjHitList hitList;
	MeshSubHitRec *rec;	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
	gw->clearHitCode();
	res = mesh.SubObjectHitTest(gw, gw->getMaterial(), &hitRegion,
				flags|SUBHIT_ABORTONHIT|SUBHIT_VERTS, hitList);
	rec = hitList.First();
	if (rec)
	  vpt->LogHit(inode,mc,0,(rec->index<ob1verts?0:1),NULL);
	gw->setRndLimits(savedLimits);	
	return res;
	}*/
int SurfWrapObject::HitTest(TimeValue t, INode* inode, int type, int crossing,int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
{	int  res = 0;
	Object *ob;
	Interval ivalid=FOREVER;
	if ((ob=GetPipeObj(t,0)) &&
		!(flags&HIT_SELONLY && !TestFlag(SWRAP_OB1SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(SWRAP_OB1SEL)) ) {
		if (TestFlag(SWRAP_DISPRESULT))
		{TriObject t1;
		t1.GetMesh().DeepCopy(&mesh,PART_GEOM|PART_TOPO);
		t1.GetMesh().setNumVerts(ob1verts,TRUE);t1.GetMesh().setNumFaces(ob1faces,TRUE);
		if (t1.HitTest(t,inode,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,0,NULL);
			res = TRUE;
			if (flags & HIT_ABORTONHIT) 
			{ return TRUE;}
			}
		}
		else
		{ INodeTransformed n(inode,GetOpTM(t,0));
		  if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,0,NULL);
			res = TRUE;			
			}		
		}
	}
		int hdist;
		pblock->GetValue(PB_HIDEDISTOBJECT,t,hdist,ivalid);
		if ((!hdist)&&(ob=GetPipeObj(t,1)) &&
		!(flags&HIT_SELONLY && !TestFlag(SWRAP_OB2SEL)) &&
		!(flags&HIT_UNSELONLY && TestFlag(SWRAP_OB2SEL)) ) {
		
		INodeTransformed n(inode,GetOpTM(t,1));
		
		if (ob->HitTest(t,&n,type,crossing,flags,p,vpt)) {
			vpt->LogHit(inode,mc,0,1,NULL);
			res = TRUE;			
			}		
		}
	return res;
}

int SurfWrapObject::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flags, ModContext* mc)
	{
	return 0;
	}

void SurfWrapObject::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	while (hitRec) {
		if (hitRec->hitInfo) {
			if (selected) SetFlag(SWRAP_OB2SEL);
			else ClearFlag(SWRAP_OB2SEL);
		} else {
			if (selected) SetFlag(SWRAP_OB1SEL);
			else ClearFlag(SWRAP_OB1SEL);
			}
		if (all) hitRec = hitRec->Next();
		else break;
		}
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_BRANCHED_HISTORY_CHANGED);
	if (ip) ShowOpList(ob2!=NULL);
	}

void SurfWrapObject::ClearSelection(int selLevel)
	{
	ClearFlag(SWRAP_OB1SEL|SWRAP_OB2SEL);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if (ip) ShowOpList(ob2!=NULL);
	}

int SurfWrapObject::SubObjectIndex(HitRecord *hitRec)
	{
	return hitRec->hitInfo;
	}

void SurfWrapObject::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 tm;
	if (TestFlag(SWRAP_OB1SEL)) {
		tm = GetOpTM(t,0) * node->GetObjectTM(t);
		cb->Center(tm.GetTrans(),0);
		}
	if (TestFlag(SWRAP_OB2SEL)) {
		tm = GetOpTM(t,1) * node->GetObjectTM(t);
		cb->Center(tm.GetTrans(),1);
		}
	}

void SurfWrapObject::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 tm;
	if (TestFlag(SWRAP_OB1SEL)) {
		tm = GetOpTM(t,0) * node->GetObjectTM(t);
		cb->TM(tm,0);
		}
	if (TestFlag(SWRAP_OB2SEL)) {
		tm = GetOpTM(t,1) * node->GetObjectTM(t);
		cb->TM(tm,1);
		}
	}

void SurfWrapObject::ActivateSubobjSel(int level, XFormModes& modes)
	{
	if (level) {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		NotifyDependents(
			FOREVER, 
			PART_SUBSEL_TYPE|PART_DISPLAY, 
			REFMSG_CHANGE);		
		ip->PipeSelLevelChanged();
		HWND hList = GetDlgItem(pmapObjects->GetHWnd(),IDC_SWRAP_OPERANDS);
		if (SendMessage(hList,LB_GETSEL,0,0)) flags |= SWRAP_OB1SEL;							
		if (SendMessage(hList,LB_GETSEL,1,0)) flags |= SWRAP_OB2SEL;	
	} 
}

class SurfWrapPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		SurfWrapPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((SurfWrapObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((SurfWrapObject*)targ)->pblock->SetValue(PB_SHOWTYPE,0,0);
				((SurfWrapObject*)targ)->SetFlag(SWRAP_DISPRESULT);
				}
			delete this;
			}
	};

#define WRAP_FLAGS_CHUNK	 0x0100
#define WRAP_OPANAME_CHUNK	 0x0110
#define WRAP_OPBNAME_CHUNK	 0x0120
#define WRAP_TRANS_CHUNK	 0x0130
#define WRAP_NORMNAME_CHUNK	 0x0140
#define WRAP_FIRSTMTLS_CHUNK 0x0150
#define WRAP_MAINNODE_CHUNK  0x0160
#define	WRAP_OFFMTX_CHUNK	 0x0170
#define WRAP_SECONDMTLS_CHUNK 0x0180
#define	WRAP_OFFMTX2_CHUNK	 0x0190


IOResult SurfWrapObject::Save(ISave *isave)
	{
	ULONG nb;
	int refid;

	isave->BeginChunk(WRAP_FLAGS_CHUNK);		
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(WRAP_OPANAME_CHUNK);		
	isave->WriteWString(opaName);
	isave->EndChunk();
	
	isave->BeginChunk(WRAP_OPBNAME_CHUNK);		
	isave->WriteWString(opbName);
	isave->EndChunk();
	
	isave->BeginChunk(WRAP_TRANS_CHUNK);		
	isave->Write(&viewPt,sizeof(viewPt),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(WRAP_NORMNAME_CHUNK);		
	isave->WriteWString(normname);
	isave->EndChunk();

	isave->BeginChunk(WRAP_FIRSTMTLS_CHUNK);		
	isave->Write(&firstmtls,sizeof(firstmtls),&nb);
	isave->EndChunk();

	isave->BeginChunk(WRAP_SECONDMTLS_CHUNK);		
	isave->Write(&secondmtls,sizeof(secondmtls),&nb);
	isave->EndChunk();

	refid=isave->GetRefID(mainnode);
	isave->BeginChunk(WRAP_MAINNODE_CHUNK);		
	isave->Write(&refid,sizeof(int),&nb);
	isave->EndChunk();

	isave->BeginChunk(WRAP_OFFMTX_CHUNK);		
	isave->Write(&wrapoff,sizeof(wrapoff),&nb);
	isave->EndChunk();

	isave->BeginChunk(WRAP_OFFMTX2_CHUNK);		
	isave->Write(&wrapoff2,sizeof(wrapoff2),&nb);
	isave->EndChunk();

	return IO_OK;
	}


IOResult SurfWrapObject::Load(ILoad *iload)
	{
		iload->RegisterPostLoadCallback(
			new SurfWrapPostLoadCallback(
				new ParamBlockPLCB(swversions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK)));
	ULONG nb;
	IOResult res = IO_OK;
	int refid;
	
	// Default names
	opaName = TSTR(GetString(IDS_AP_OPERAND));
	opbName = TSTR(GetString(IDS_AP_OPERAND));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case WRAP_FLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			
			case WRAP_OPANAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opaName = TSTR(buf);
				break;
				}

			case WRAP_OPBNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				opbName = TSTR(buf);
				break;
				}

			case WRAP_TRANS_CHUNK:
				res=iload->Read(&viewPt,sizeof(viewPt),&nb);
				break;

			case WRAP_NORMNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				normname = TSTR(buf);
				break;
				}
			case WRAP_FIRSTMTLS_CHUNK:
				res=iload->Read(&firstmtls,sizeof(firstmtls),&nb);
				break;
			case WRAP_SECONDMTLS_CHUNK:
				res=iload->Read(&secondmtls,sizeof(secondmtls),&nb);
				break;
			case WRAP_MAINNODE_CHUNK: 
				{res=iload->Read(&refid,sizeof(int),&nb);
			     iload->RecordBackpatch(refid,(void**)&mainnode);
				 break;
			case WRAP_OFFMTX_CHUNK:
				res=iload->Read(&wrapoff,sizeof(wrapoff),&nb);
				break;
			case WRAP_OFFMTX2_CHUNK:
				res=iload->Read(&wrapoff2,sizeof(wrapoff2),&nb);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	Invalidate();
	return IO_OK;
	}

ParamDimension *SurfWrapObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_KIDEFAULT: return stdWorldDim;
		case PB_STANDOFF: return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR SurfWrapObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_KIDEFAULT: return GetString(IDS_AP_KIDEFAULT);
		case PB_STANDOFF: return GetString(IDS_AP_STANDOFF);
		default: return TSTR(_T(""));
		}
	}

/*BOOL SurfWrapObject::DoAttachMatOptionDialog (HWND hWnd) {
	return DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_ATTACH_MATS),
		hWnd, AttachMatsDlgProc, (LPARAM)this);
}

BOOL SurfWrapObject::DoInheritMatOptionDialog (HWND hWnd) {
	TSTR buf1 = GetString (IDS_ATTACH_INHERIT);
	TSTR buf2 = GetString (IDS_AP_SURFWRAPOBJECT);
	int ret = MessageBox (hWnd, buf1, buf2, MB_ICONQUESTION|MB_YESNOCANCEL);
	inheritMat = (ret==IDYES);
	return (ret != IDCANCEL);
}*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\blurMgr.cpp ===
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
//
//   FILE: blurMgr.cpp
//
//	 DESCRIPTION: BlurMgr - class definitions
//				  main interface to blur render effect
//
//	 CREATED BY: michael malone (mjm)
//
//	 HISTORY: created November 4, 1998
//
//	 Copyright (c) 1998, All Rights Reserved
//
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// precompiled header
#include "pch.h"

// system includes
#include  <math.h>

// local includes
#include "blurMgr.h"

// maxsdk includes
#include <iparamm2.h>
#include <iparamb2.h>
#include <bmmlib.h>

// ---------------------
// class ID & descriptor
// ---------------------
const Class_ID BlurMgr::blurMgrClassID(0xd481816, 0x786d799c);
BlurMgrClassDesc blurMgrCD;
ClassDesc* GetBlurMgrDesc() { return &blurMgrCD; }

// -----------------
// paramMap pointers
// -----------------
IParamMap2 *BlurMgr::pmMaster   = NULL;
IParamMap2 *BlurMgr::pmBlurData = NULL;
IParamMap2 *BlurMgr::pmSelData  = NULL;

// ------------
// dialog procs
// ------------
MasterDlgProc	BlurMgr::masterDlgProc;
BlurDataDlgProc	BlurMgr::blurDataDlgProc(&masterDlgProc);
SelDataDlgProc	BlurMgr::selDataDlgProc(&masterDlgProc);

// ----------------------
// paramblock descriptors
// ----------------------
ParamBlockDesc2 BlurMgr::pbdMaster(idMaster, _T("blur effect parameters"), 0, &blurMgrCD, P_AUTO_CONSTRUCT + P_AUTO_UI, idMaster,
	//rollout
	IDD_MASTER, IDS_PARAMS, 0, 0, &masterDlgProc,
	// no params - used only for auto ui
	end
	);

ParamBlockDesc2 BlurMgr::pbdBlurData(idBlurData, _T("blurData"), 0, &blurMgrCD, P_AUTO_CONSTRUCT, idBlurData,
	// params
	prmBlurType, _T("blur type"), TYPE_RADIOBTN_INDEX, P_ANIMATABLE, IDS_BLUR_TYPE,
		p_default, idBlurUnif,
		p_range, idBlurUnif, idBlurRadial,
		p_ui, TYPE_RADIO, 3, IDR_BLUR_UNIF, IDR_BLUR_DIR, IDR_BLUR_RADIAL,
		p_enable_ctrls,
			// IDR_BLUR_UNIF toggles:
			2, prmUnifPixRad, prmUnifAlpha,
			// IDR_BLUR_DIR toggles:
			6, prmDirUPixRad, prmDirVPixRad, prmDirUTrail, prmDirVTrail, prmDirRot, prmDirAlpha,
			// IDR_BLUR_RADIAL toggles:
			7, prmRadialPixRad, prmRadialTrail, prmRadialAlpha, prmRadialXOrig, prmRadialYOrig, prmRadialUseNode, prmRadialNode,
		end,
	// BlurUniform
	prmUnifPixRad, _T("bUnifPixRad"), TYPE_FLOAT, P_ANIMATABLE, IDS_BUNIF_PIXEL_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BUNIF_RAD, IDSP_BUNIF_RAD, SPIN_AUTOSCALE,
		end,
	prmUnifAlpha, _T("bUnifAlpha"), TYPE_BOOL, P_ANIMATABLE, IDS_BUNIF_ALPHA,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_BUNIF_ALPHA,
		end,
	// BlurDirectional
	prmDirUPixRad, _T("bDirUPixRad"), TYPE_FLOAT, P_ANIMATABLE, IDS_BDIR_UPIX_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BDIR_URAD, IDSP_BDIR_URAD, SPIN_AUTOSCALE,
		end,
	prmDirVPixRad, _T("bDirVPixRad"), TYPE_FLOAT, P_ANIMATABLE, IDS_BDIR_VPIX_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BDIR_VRAD, IDSP_BDIR_VRAD, SPIN_AUTOSCALE,
		end,
	prmDirUTrail, _T("bDirUTrail"), TYPE_FLOAT, P_ANIMATABLE, IDS_BDIR_UTRAIL,
		p_default, 0.0f,
		p_range, -100.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BDIR_UTRAIL, IDSP_BDIR_UTRAIL, SPIN_AUTOSCALE,
		end,
	prmDirVTrail, _T("bDirVTrail"), TYPE_FLOAT, P_ANIMATABLE, IDS_BDIR_VTRAIL,
		p_default, 0.0f,
		p_range, -100.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BDIR_VTRAIL, IDSP_BDIR_VTRAIL, SPIN_AUTOSCALE,
		end,
	prmDirRot, _T("bDirRotation"), TYPE_INT, P_ANIMATABLE, IDS_BDIR_ROTATION,
		p_default, 0,
		p_range, -180, 180,
		p_ui, TYPE_SPINNER, EDITTYPE_INT, IDE_BDIR_ROT, IDSP_BDIR_ROT, SPIN_AUTOSCALE,
		end,
	prmDirAlpha, _T("bDirAlpha"), TYPE_BOOL, P_ANIMATABLE, IDS_BDIR_ALPHA,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_BDIR_ALPHA,
		end,
	// BlurRadial
	prmRadialPixRad, _T("bRadialPixRad"), TYPE_FLOAT, P_ANIMATABLE, IDS_BRADIAL_PIXEL_RAD,
		p_default, 20.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BRADIAL_RAD, IDSP_BRADIAL_RAD, SPIN_AUTOSCALE,
		end,
	prmRadialTrail, _T("bRadialTrail"), TYPE_FLOAT, P_ANIMATABLE, IDS_BRADIAL_TRAIL,
		p_default, 0.0f,
		p_range, -100.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_BRADIAL_TRAIL, IDSP_BRADIAL_TRAIL, SPIN_AUTOSCALE,
		end,
	prmRadialAlpha, _T("bRadialAlpha"), TYPE_BOOL, P_ANIMATABLE, IDS_BRADIAL_ALPHA,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_BRADIAL_ALPHA,
		end,
	prmRadialXOrig, _T("bRadialXOrig"), TYPE_INT, P_ANIMATABLE, IDS_BRADIAL_XORIGIN,
		p_range, -999999, 999999,
		p_ui, TYPE_SPINNER, EDITTYPE_INT, IDE_BRADIAL_XORIGIN, IDSP_BRADIAL_XORIGIN, SPIN_AUTOSCALE,
		end,
	prmRadialYOrig, _T("bRadialYOrig"), TYPE_INT, P_ANIMATABLE, IDS_BRADIAL_YORIGIN,
		p_range, -999999, 999999,
		p_ui, TYPE_SPINNER, EDITTYPE_INT, IDE_BRADIAL_YORIGIN, IDSP_BRADIAL_YORIGIN, SPIN_AUTOSCALE,
		end,
	prmRadialUseNode, _T("bRadialUseNode"), TYPE_BOOL, P_ANIMATABLE, IDS_BRADIAL_USE_NODE,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_BRADIAL_USE_NODE,
		end,
	prmRadialNode, _T("bRadialNode"), TYPE_INODE, 0, IDS_BRADIAL_NODE,	// not animatable
		p_ui, TYPE_PICKNODEBUTTON, IDB_BRADIAL_NODE,
		p_prompt, IDS_BRADIAL_NODE_PROMPT,
		end,
	end
	);

ParamBlockDesc2 BlurMgr::pbdSelData(idSelData, _T("selectionData"), 0, &blurMgrCD, P_AUTO_CONSTRUCT, idSelData,
	// params
	// SelImage
	prmImageActive, _T("selImageActive"), TYPE_BOOL, P_ANIMATABLE, IDS_SIMAGE_ACTIVE,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_SIMAGE_ACTIVE,
		p_enable_ctrls, 2, prmImageBrighten, prmImageBlend,
		end,
	prmImageBrighten, _T("selImageBrighten"), TYPE_FLOAT, P_ANIMATABLE, IDS_SIMAGE_BRIGHTEN,
		p_default, 0.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SIMAGE_BRIGHTEN, IDSP_SIMAGE_BRIGHTEN, SPIN_AUTOSCALE,
		end,
	prmImageBlend, _T("selImageBlend"), TYPE_FLOAT, P_ANIMATABLE, IDS_SIMAGE_BLEND,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SIMAGE_BLEND, IDSP_SIMAGE_BLEND, SPIN_AUTOSCALE,
		end,
	// SelIBack
	prmIBackActive, _T("selIBackActive"), TYPE_BOOL, P_ANIMATABLE, IDS_SIBACK_ACTIVE,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_SIBACK_ACTIVE,
		p_enable_ctrls, 3, prmIBackBrighten, prmIBackBlend, prmIBackFeathRad,
		end,
	prmIBackBrighten, _T("selIBackBrighten"), TYPE_FLOAT, P_ANIMATABLE, IDS_SIBACK_BRIGHTEN,
		p_default, 0.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SIBACK_BRIGHTEN, IDSP_SIBACK_BRIGHTEN, SPIN_AUTOSCALE,
		end,
	prmIBackBlend, _T("selIBackBlend"), TYPE_FLOAT, P_ANIMATABLE, IDS_SIBACK_BLEND,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SIBACK_BLEND, IDSP_SIBACK_BLEND, SPIN_AUTOSCALE,
		end,
	prmIBackFeathRad, _T("selIBackFRadius"), TYPE_FLOAT, P_ANIMATABLE, IDS_SIBACK_FEATHER_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SIBACK_FRAD, IDSP_SIBACK_FRAD, SPIN_AUTOSCALE,
		end,
	// SelLum
	prmLumActive, _T("selLumActive"), TYPE_BOOL, P_ANIMATABLE, IDS_SLUM_ACTIVE,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_SLUM_ACTIVE,
		p_enable_ctrls, 5, prmLumBrighten, prmLumBlend, prmLumMin, prmLumMax, prmLumFeathRad,
		end,
	prmLumBrighten, _T("selLumBrighten"), TYPE_FLOAT, P_ANIMATABLE, IDS_SLUM_BRIGHTEN,
		p_default, 0.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SLUM_BRIGHTEN, IDSP_SLUM_BRIGHTEN, SPIN_AUTOSCALE,
		end,
	prmLumBlend, _T("selLumBlend"), TYPE_FLOAT, P_ANIMATABLE, IDS_SLUM_BLEND,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SLUM_BLEND, IDSP_SLUM_BLEND, SPIN_AUTOSCALE,
		end,
	prmLumMin, _T("selLumMin"), TYPE_FLOAT, P_ANIMATABLE, IDS_SLUM_MIN,
		p_default, 90.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SLUM_MIN, IDSP_SLUM_MIN, SPIN_AUTOSCALE,
		end,
	prmLumMax, _T("selLumMax"), TYPE_FLOAT, P_ANIMATABLE, IDS_SLUM_MAX,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SLUM_MAX, IDSP_SLUM_MAX, SPIN_AUTOSCALE,
		end,
	prmLumFeathRad, _T("selLumFRadius"), TYPE_FLOAT, P_ANIMATABLE, IDS_SLUM_FEATHER_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SLUM_FRAD, IDSP_SLUM_FRAD, SPIN_AUTOSCALE,
		end,
	// SelMask
	prmMaskActive, _T("selMaskActive"), TYPE_BOOL, P_ANIMATABLE, IDS_SMASK_ACTIVE,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_SMASK_ACTIVE,
		p_enable_ctrls, 6, prmMaskMap, prmMaskBrighten, prmMaskBlend, prmMaskMin, prmMaskMax, prmMaskFeathRad,
		end,
	prmMaskMap, _T("selMaskMap"), TYPE_TEXMAP, 0, IDS_SMASK_MAP,
		p_ui, TYPE_TEXMAPBUTTON, IDB_SMASK_MAP,
		end,
	prmMaskChannel, _T("selMaskChannel"), TYPE_INT, P_ANIMATABLE, IDS_SMASK_CHANNEL,
		p_default, 4,
		end,
	prmMaskBrighten, _T("selMaskBrighten"), TYPE_FLOAT, P_ANIMATABLE, IDS_SMASK_BRIGHTEN,
		p_default, 0.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SMASK_BRIGHTEN, IDSP_SMASK_BRIGHTEN, SPIN_AUTOSCALE,
		end,
	prmMaskBlend, _T("selMaskBlend"), TYPE_FLOAT, P_ANIMATABLE, IDS_SMASK_BLEND,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SMASK_BLEND, IDSP_SMASK_BLEND, SPIN_AUTOSCALE,
		end,
	prmMaskMin, _T("selMaskMin"), TYPE_FLOAT, P_ANIMATABLE, IDS_SMASK_MIN,
		p_default, 90.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SMASK_MIN, IDSP_SMASK_MIN, SPIN_AUTOSCALE,
		end,
	prmMaskMax, _T("selMaskMax"), TYPE_FLOAT, P_ANIMATABLE, IDS_SMASK_MAX,
		p_default, 100.0f,
		p_range, 0.0f, 100.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SMASK_MAX, IDSP_SMASK_MAX, SPIN_AUTOSCALE,
		end,
	prmMaskFeathRad, _T("selMaskFRadius"), TYPE_FLOAT, P_ANIMATABLE, IDS_SMASK_FEATHER_RAD,
		p_default, 10.0f,
		p_range, 0.0f, 1000.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDE_SMASK_FRAD, IDSP_SMASK_FRAD, SPIN_AUTOSCALE,
		end,
	end
	);


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// class constructor

BlurMgr::BlurMgr() :
	pbMaster(NULL), pbBlurData(NULL), pbSelData(NULL),
	m_lastBMModifyID(0xFFFFFFFF), m_imageW(0), m_imageH(0), m_imageSz(0), m_compValid(false)

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
{
	m_blurs[idBlurUnif] = new BlurUniform(this);
	m_blurs[idBlurDir] = new BlurDirectional(this);
	m_blurs[idBlurRadial] = new BlurRadial(this);

	m_sels[idSelImage] = new SelImage(this);
	m_sels[idSelIBack] = new SelIgnBack(this);
	m_sels[idSelLum] = new SelLum(this);
	m_sels[idSelMask] = new SelMaps(this);

	// set default blur radial origin to coincide with current render settings
	pbdBlurData.ParamOption(prmRadialXOrig, p_default, GetCOREInterface()->GetRendWidth()/2);
	pbdBlurData.ParamOption(prmRadialYOrig, p_default, GetCOREInterface()->GetRendHeight()/2);
	blurMgrCD.MakeAutoParamBlocks(this);
	assert(	pbMaster && pbBlurData && pbSelData);
}


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// class destructor

BlurMgr::~BlurMgr()

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
{
	for (int i=0; i<numBlurs; i++)
		if (m_blurs[i])
			delete m_blurs[i];
	for (i=0; i<numSels; i++)
		if (m_sels[i])
			delete m_sels[i];
}


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// class destructor

IOResult BlurMgr::Load(ILoad *iload)

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
{
	Effect::Load(iload);
	return IO_OK;
}

EffectParamDlg *BlurMgr::CreateParamDialog(IRendParams *ip)
{	
    // create the master rollout dialog
    IAutoEParamDlg* masterDlg = blurMgrCD.CreateParamDialog(pbMaster->ID(), ip, this);
	pmMaster = masterDlg->GetMap();

	// create the blur types child dialogs
	pmBlurData = CreateChildRParamMap2(pbBlurData, ip, hInstance,
									   pmMaster, MAKEINTRESOURCE(IDD_BLUR_TYPES),
									   GetString(IDS_BLUR_TYPE), &blurDataDlgProc);

	// create the compositing selections child dialogs
	pmSelData = CreateChildRParamMap2(pbSelData, ip, hInstance,
									  pmMaster, MAKEINTRESOURCE(IDD_SEL_TYPES),
									  GetString(IDS_SEL_TYPES), &selDataDlgProc);

	// tell the master dialog we're done adding children
	masterDlgProc.notifyChildrenCreated();

    return masterDlg;
}

TSTR BlurMgr::SubAnimName(int i)
{
	switch (i)
	{
	case idMaster:
		return GetString(IDS_BLUR_PARAMS);
	case idBlurData:
		return GetString(IDS_BLUR_TYPE);
	case idSelData:
		return GetString(IDS_SEL_TYPES);
	default:
		return _T("");
	}
}

RefTargetHandle BlurMgr::GetReference(int i)
{
	switch (i)
	{
	case idMaster:
		return pbMaster;
	case idBlurData:
		return pbBlurData;
	case idSelData:
		return pbSelData;
	default:
		return NULL;
	}
}

void BlurMgr::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i)
	{
	case idMaster:
		pbMaster = (IParamBlock2*)rtarg;
		break;
	case idBlurData:
		pbBlurData = (IParamBlock2*)rtarg;
		break;
	case idSelData:
		pbSelData = (IParamBlock2*)rtarg;
		break;
	}
}

RefResult BlurMgr::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
{
	int prmID;

	switch (message) {
		case REFMSG_CHANGE:
			if (hTarget == pbMaster)
			{
				pbdMaster.InvalidateUI(pbMaster->LastNotifyParamID());
				return REF_SUCCEED;
			}

			// blur types
			if (hTarget == pbBlurData)
			{
				switch (prmID = pbBlurData->LastNotifyParamID())
				{
					case prmUnifPixRad:
					case prmUnifAlpha:
						m_blurs[idBlurUnif]->notifyPrmChanged(prmID);
						break;
					case prmDirUPixRad:
					case prmDirVPixRad:
					case prmDirUTrail:
					case prmDirVTrail:
					case prmDirRot:
					case prmDirAlpha:
						m_blurs[idBlurDir]->notifyPrmChanged(prmID);
						break;
					case prmRadialPixRad:
					case prmRadialTrail:
					case prmRadialAlpha:
					case prmRadialXOrig:
					case prmRadialYOrig:
					case prmRadialUseNode:
					case prmRadialNode:
						m_blurs[idBlurRadial]->notifyPrmChanged(prmID);
						break;
				}
				IParamMap2 *map = pbBlurData->GetMap();
				if (map)
					map->Invalidate(prmID);
				return REF_SUCCEED;
			}

			// selection types
			if (hTarget == pbSelData)
			{
				switch (prmID = pbSelData->LastNotifyParamID())
				{
					case prmImageActive:
					case prmImageBrighten:
					case prmImageBlend:
						m_sels[idSelImage]->notifyPrmChanged(prmID);
						break;
					case prmIBackActive:
					case prmIBackBrighten:
					case prmIBackBlend:
					case prmIBackFeathRad:
						m_sels[idSelIBack]->notifyPrmChanged(prmID);
						break;
					case prmLumActive:
					case prmLumBrighten:
					case prmLumBlend:
					case prmLumMin:
					case prmLumMax:
					case prmLumFeathRad:
						m_sels[idSelLum]->notifyPrmChanged(prmID);
						break;
					case prmMaskActive:
					case prmMaskMap:
					case prmMaskChannel:
					case prmMaskBrighten:
					case prmMaskBlend:
					case prmMaskMin:
					case prmMaskMax:
					case prmMaskFeathRad:
						m_sels[idSelMask]->notifyPrmChanged(prmID);
						break;
				}
				IParamMap2 *map = pbSelData->GetMap();
				if (map)
					map->Invalidate(prmID);
				return REF_SUCCEED;
			}
	}
	return REF_SUCCEED;
}

void BlurMgr::updateSelections(TimeValue t, Bitmap *bm, RenderGlobalContext *gc)
{
	BOOL selActive;
	for (int id=0; id<numSels; id++)
	{
		pbSelData->GetValue(id, t, selActive, FOREVER); // check selection's activity
		if (!m_compValid)
			m_activeSels[id] = selActive; // record activity
		else if (m_activeSels[id] == selActive) // activity hasn't changed
		{
			if (m_activeSels[id]) // if active
				m_compValid = m_sels[id]->checkValid( bm->GetModifyID() ); // check if its valid internally
		}
		else // activity has changed
		{
			m_activeSels[id] = selActive;
			m_compValid = false;
		}
	}

	// rebuild the compositing map
	if (!m_compValid)
	{
		if ( m_activeSels[0] ) // whole image selection
		{
			float brighten = m_sels[0]->getBrighten(t);
			float blend = m_sels[0]->getBlend(t);
			m_compMap.set(brighten, blend, m_imageSz);
		}
		else
		{
			m_compMap.set(0.0f, 0.0f, m_imageSz);
		}

		for (int i=1; i<numSels; i++)
			if (m_activeSels[i])
				m_sels[i]->select(t, m_compMap, bm, gc);
	}
}

void BlurMgr::blur(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, BOOL doComposite)
{
	int activeBlur;
	pbBlurData->GetValue(prmBlurType, t, activeBlur, FOREVER);
	m_blurs[activeBlur]->blur(t, ((doComposite) ? &m_compMap : NULL), bm, gc);
}

void BlurMgr::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *_checkAbort)
{
	m_checkAbort = _checkAbort;
	int type;
	WORD *map = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// check for active selections
	BOOL selsActive = false;
	for (int id=0; (!selsActive && id<numSels); id++)
		pbSelData->GetValue(id, t, selsActive, FOREVER);

	if (!selsActive)
		return;

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_compValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_compMap.resize(m_imageSz = m_imageW * m_imageH);
		}
	}

	updateSelections(t, bm, gc);
	blur(t, bm, gc, selsActive);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\dlgProcs.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dlgProcs.h

	 DESCRIPTION: dialog procedures, class declarations

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_DLGPROCS_H_INCLUDED_)
#define _DLGPROCS_H_INCLUDED_

// system includes
#include <windows.h>

// maxsdk includes
#include <max.h>
#include <iparamm2.h>

// local includes
#include "globals.h"
#include "resource.h"
class BlurMgr;

#define NAMELENGTH 64
typedef TCHAR TChBuffer[NAMELENGTH];

// -----------------------
// master dialog procedure
// -----------------------
class MasterDlgProc : public ParamMap2UserDlgProc
{
	int numCheckedIn;
	bool mAllDlgsCreated;
	HWND mHWnds[numIDs];

	void placeChildren();

	// from ParamMap2UserDlgProc
	BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void SetThing(ReferenceTarget *m);
	void DeleteThis();

public:
	MasterDlgProc() : numCheckedIn(0), mAllDlgsCreated(false) { mHWnds[0] = mHWnds[1] = mHWnds[2] = NULL; }
	void showWnd(int dlgId) { ShowWindow(mHWnds[dlgId], SW_SHOW); }
	void hideWnd(int dlgId) { ShowWindow(mHWnds[dlgId], SW_HIDE); }
	void checkIn(int dlgId, HWND hDlg);
	void notifyChildrenCreated();
};

// -----------------------
// child dialog procedures
// -----------------------
class BlurDataDlgProc : public ParamMap2UserDlgProc
{
	MasterDlgProc *mpMasterDlgProc;
	void DeleteThis() { }
	BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void enableControls(TimeValue t, IParamMap2* map, HWND hWnd);

public:
	BlurDataDlgProc() : mpMasterDlgProc(NULL) { }
	BlurDataDlgProc(MasterDlgProc *mpMaster) : mpMasterDlgProc(mpMaster) { }
};

class SelDataDlgProc : public ParamMap2UserDlgProc
{
	TChBuffer mChannelStr[5];
	MasterDlgProc *mpMasterDlgProc;
	void DeleteThis() { }
	BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

public:
	SelDataDlgProc() : mpMasterDlgProc(NULL) { }
	SelDataDlgProc(MasterDlgProc *mpMaster) : mpMasterDlgProc(mpMaster) { }
};

#endif // !defined(_DLGPROCS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\dllMain.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.cpp

	 DESCRIPTION: DLL entry implementation

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "dllMain.h"
#include "resource.h"

// global variables
HINSTANCE hInstance;

// global functions
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved)
{
	// remember this dll's instance handle
	hInstance = hinstDLL;

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// initialize max controls
		InitCustomControls(hInstance);
		// initialize microsoft controls
		InitCommonControls();
		break;
	}
	return (TRUE);
}


//------------------------------------------------------
// interface to Max
//------------------------------------------------------

// returns dll descriptive string
__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}


// returns number of classes in dll
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


// returns appropriate class descriptor
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i)
	{
	case 0:
		return GetBlurMgrDesc();
	default:
		return 0;
	}
}


// returns version to detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}


// standard hInstance dependent GetString()
TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\dlgProcs.cpp ===
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
//
//	 FILE: dlgProcs.cpp
//
//	 DESCRIPTION: dialog procedures - class definitions
//
//	 CREATED BY: michael malone (mjm)
//
//	 HISTORY: created November 4, 1998
//
//	 Copyright (c) 1998, All Rights Reserved
//
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// precompiled header
#include "pch.h"

// local includes
#include "pch.h"
#include "dllMain.h"
#include "dlgProcs.h"
#include "blurMgr.h"

void MasterDlgProc::checkIn(int id, HWND hDlg)
{
	mHWnds[id] = hDlg;
	numCheckedIn++;
	mAllDlgsCreated = (numCheckedIn == numIDs) ? true : false;
}

void MasterDlgProc::placeChildren()
{
	// compute locations for child dialogs
	Rect rc;
	GetWindowRect(mHWnds[idMaster], &rc);
	int originX = rc.left;
	int originY = rc.top;

	// find display area of tab control
	HWND hTabCtrl = GetDlgItem(mHWnds[idMaster], IDC_TAB);
	GetWindowRect(hTabCtrl, &rc);
	TabCtrl_AdjustRect(hTabCtrl, FALSE, &rc);

	// convert to client coordinates
	rc.left -= originX; rc.right  -= originX;
	rc.top  -= originY; rc.bottom -= originY;

	// move child dialogs into place
	MoveWindow(mHWnds[idBlurData], rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, FALSE);
	MoveWindow(mHWnds[idSelData],  rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, FALSE);
}

void MasterDlgProc::notifyChildrenCreated()
{
	assert(mAllDlgsCreated);

	// setup tab control
	HWND hTabCtrl = GetDlgItem(mHWnds[idMaster], IDC_TAB);
	TC_ITEM tci;
	tci.mask = TCIF_TEXT;
	tci.iImage = -1;
	tci.pszText = GetString(IDS_BLUR_TYPE);
	TabCtrl_InsertItem(hTabCtrl, 0, &tci);
	tci.pszText = GetString(IDS_SEL_TYPES);
	TabCtrl_InsertItem(hTabCtrl, 1, &tci);

	// position child dialogs
	placeChildren();

	// show appropriate window
	switch( TabCtrl_GetCurSel( GetDlgItem(mHWnds[idMaster], IDC_TAB) ) )
	{
		case 0:
			ShowWindow(mHWnds[idSelData],  SW_HIDE);
			ShowWindow(mHWnds[idBlurData], SW_SHOW);
			break;
		case 1:
			ShowWindow(mHWnds[idBlurData], SW_HIDE);
			ShowWindow(mHWnds[idSelData],  SW_SHOW);
			break;
	}
}

void MasterDlgProc::SetThing(ReferenceTarget *m)
{
	// parammap is being recycled - need to manually set the new blur's child paramblocks into the child parammaps
	BlurMgr *newBlur = (BlurMgr *)m;
	newBlur->pmBlurData->SetParamBlock(newBlur->pbBlurData);
	newBlur->pmSelData->SetParamBlock(newBlur->pbSelData);
}

void MasterDlgProc::DeleteThis()
{
	numCheckedIn = 0;
	mAllDlgsCreated = false;
	mHWnds[0] = mHWnds[1] = mHWnds[2] = NULL;
}

BOOL MasterDlgProc::DlgProc(TimeValue t, IParamMap2* map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);

	switch(msg)
	{
		case WM_INITDIALOG:
			checkIn(idMaster, hWnd);
			return FALSE;

		case WM_NOTIFY:
		{
			NMHDR* pnmhdr = (LPNMHDR)lParam;
			HWND hTabCtrl = GetDlgItem(hWnd, IDC_TAB);

			switch(pnmhdr->code)
			{
				case TCN_SELCHANGING:
					switch(TabCtrl_GetCurSel(hTabCtrl))
					{
					case 0:
						hideWnd(idBlurData);
						break;
					case 1:
						hideWnd(idSelData);
						break;
					}
					break;

				case TCN_SELCHANGE:
					switch(TabCtrl_GetCurSel(hTabCtrl))
					{
					case 0:
						showWnd(idBlurData);
						break;
					case 1:
						showWnd(idSelData);
						break;
					}
					break;

				default:
					return FALSE;
			}
			break;
		}

		default:
			return FALSE;
	}
	return TRUE;
}


// ---------------
// BlurTypeDlgProc
// ---------------
void BlurDataDlgProc::enableControls(TimeValue t, IParamMap2* map, HWND hWnd)
{
	int blurType;
	BOOL state;

	map->GetParamBlock()->GetValue(prmBlurType, t, blurType, FOREVER);
	switch (blurType)
	{
		case idBlurUnif:
		case idBlurDir:
			EnableWindow(GetDlgItem(hWnd, IDB_BRADIAL_CLEAR_NODE), FALSE);
			break;
		case idBlurRadial:
			state = ( IsDlgButtonChecked(hWnd, IDC_BRADIAL_USE_NODE) != BST_CHECKED );
			map->Enable( prmRadialXOrig, state );
			map->Enable( prmRadialYOrig, state );
			map->Enable( prmRadialNode, !state );
			EnableWindow(GetDlgItem(hWnd, IDB_BRADIAL_CLEAR_NODE), !state);
			break;
	}
}

BOOL BlurDataDlgProc::DlgProc(TimeValue t, IParamMap2* map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch(msg)
	{
		case WM_INITDIALOG:
			mpMasterDlgProc->checkIn(idBlurData, hWnd);
			map->SetTooltip( prmRadialNode, TRUE, GetString(IDS_BRADIAL_NODE_PROMPT) );
			break;

		case WM_SHOWWINDOW:
			enableControls(t, map, hWnd);
			break;

		case WM_COMMAND:
			switch( LOWORD(wParam) )
			{
				case IDR_BLUR_UNIF:
				case IDR_BLUR_DIR:
					enableControls(t, map, hWnd);
					break;

				case IDR_BLUR_RADIAL:
				case IDC_BRADIAL_USE_OBJECT:
					enableControls(t, map, hWnd);
					break;

				case IDB_BRADIAL_CLEAR_NODE:
					if ( HIWORD(wParam) == BN_CLICKED )
						map->GetParamBlock()->SetValue(prmRadialNode, 0, (INode *)NULL); // not animatable -- use time = 0
					break;

				default:
					return FALSE;
			}
			break;

		case WM_DESTROY:
			GetCOREInterface()->UnRegisterDlgWnd(hWnd); // this should be handled automatically, but currently is not.
			break;

		default:
			return FALSE;
	}
	return TRUE;
}


// --------------
// SelTypeDlgProc
// --------------
#define NUMCHANNELS 5

BOOL SelDataDlgProc::DlgProc(TimeValue t, IParamMap2* map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch(msg)
	{
		case WM_INITDIALOG:
		{
			mpMasterDlgProc->checkIn(idSelData, hWnd);

			// initialize strings for combo boxes
			_tcscpy( mChannelStr[0], GetString(IDS_RED) );
			_tcscpy( mChannelStr[1], GetString(IDS_GREEN));
			_tcscpy( mChannelStr[2], GetString(IDS_BLUE));
			_tcscpy( mChannelStr[3], GetString(IDS_ALPHA));
			_tcscpy( mChannelStr[4], GetString(IDS_LUMINANCE));

			// insert strings into listbox
			HWND hwndMap = GetDlgItem(hWnd, IDCB_SMASK_CHANNEL);  
			for (int index=0; index<NUMCHANNELS; index++)
				SendMessage( hwndMap, CB_ADDSTRING, 0, (LPARAM)mChannelStr[index] );
			break;
		}

		case WM_SHOWWINDOW:
		{
			int curIndex;
			map->GetParamBlock()->GetValue(prmMaskChannel, t, curIndex, FOREVER);
			SendMessage(GetDlgItem(hWnd, IDCB_SMASK_CHANNEL), CB_SETCURSEL, (WPARAM)curIndex, 0);

			// comboboxes not supported by parammap2 so manually set enable/disable for this control
			BOOL checked = ( SendMessage(GetDlgItem(hWnd, IDC_SMASK_ACTIVE), BM_GETCHECK, 0, 0) == BST_CHECKED ) ? TRUE : FALSE;
			EnableWindow(GetDlgItem(hWnd, IDCB_SMASK_CHANNEL), checked);
			break;
		}

		case WM_COMMAND:
			if ( (LOWORD(wParam) == IDC_SMASK_ACTIVE) && (HIWORD(wParam) == BN_CLICKED) )
			{
				BOOL checked = ( SendMessage(GetDlgItem(hWnd, IDC_SMASK_ACTIVE), BM_GETCHECK, 0, 0) == BST_CHECKED ) ? TRUE : FALSE;
				EnableWindow(GetDlgItem(hWnd, IDCB_SMASK_CHANNEL), checked);
				break;
			}

			else if ( (LOWORD(wParam) == IDCB_SMASK_CHANNEL) && (HIWORD(wParam) == CBN_SELCHANGE) )
			{
				HWND hListBox = (HWND)lParam;
				int index = SendMessage(hListBox, CB_GETCURSEL, 0, 0);
				map->GetParamBlock()->SetValue(prmMaskChannel, GetCOREInterface()->GetTime(), index);
				break;
			}

			else
				return FALSE;

		case WM_DESTROY:
			GetCOREInterface()->UnRegisterDlgWnd(hWnd); // this should be handled automatically, but currently is not.
			break;

		default:
			return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\dllMain.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.h

	 DESCRIPTION: DLL entry header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */


#if !defined(_DLL_MAIN_H_INCLUDED_)
#define _DLL_MAIN_H_INCLUDED_

// maxsdk includes
#include "max.h"

extern HINSTANCE hInstance;

TCHAR *GetString(int id);
extern ClassDesc* GetBlurMgrDesc();

#endif // !defined(_DLL_MAIN_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\pch.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: pch.h

	 DESCRIPTION: precompiled header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created March 17, 1999

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */


#if !defined(_PCH_H_INCLUDED_)
#define _PCH_H_INCLUDED_

// system includes
#include <math.h>
#include <assert.h>

// maxsdk includes
#include "max.h"
#include <iparamm2.h>
#include <iparamb2.h>
#include <bmmlib.h>

// local includes
#include "resource.h"
#include "dllMain.h"
#include "blurMgr.h"
#include "dlgProcs.h"
#include ".\_selectTypes\selImage.h"
#include ".\_selectTypes\selIgnBack.h"
#include ".\_selectTypes\selLum.h"
#include ".\_selectTypes\selMaps.h"
#include ".\_selectTypes\sctex.h"
#include ".\_blurTypes\blurBase.h"
#include ".\_blurTypes\blurUniform.h"
#include ".\_blurTypes\blurDirectional.h"
#include ".\_blurTypes\blurRadial.h"


#endif // !defined(_PCH_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurBase.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurBase.h

	 DESCRIPTION: base blur type - class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_BLURBASE_H_INCLUDED_)
#define _BLURBASE_H_INCLUDED_

#include "max.h"
#include "..\globals.h"

class BlurMgr;

// ----------------------------------------
// base blur type - class declaration
// ----------------------------------------
class BlurBase
{
protected:
	BlurMgr *const mp_blurMgr;
	WORD *mp_srcMap, *mp_srcAlpha;
	int m_bufSz, m_mapSz, m_imageSz, m_imageW, m_imageH;
	bool m_blurValid;
	BOOL m_affectAlpha;
	AColor *mp_blurCache, *mp_scratchMap;
	const TCHAR *mp_nameCurProcess;
	DWORD m_lastBMModifyID;

	int findRotPixels(int x1, int y1, int x2, int y2, IPoint2* buf = NULL, int sz = 0);
	void calcGaussWts(float *buf, int bufSz);
	void calcGaussWts(float *buf, int radA, int radB);
	void blendPixel(int index, WORD *mapFrom, AColor blendCol, float brighten, float blend, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo = NULL);
	virtual bool doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo) { return false; }

public:
	BlurBase() : mp_blurMgr(NULL), mp_srcMap(NULL), mp_srcAlpha(NULL),
		m_bufSz(0), m_mapSz(0), m_imageSz(0), m_imageW(0), m_imageH(0), m_blurValid(false), m_affectAlpha(FALSE),
		mp_blurCache(NULL), mp_scratchMap(NULL), mp_nameCurProcess(NULL), m_lastBMModifyID(0xFFFFFFFF) { }
	BlurBase(BlurMgr *const mgr) : mp_blurMgr(mgr), mp_srcMap(NULL), mp_srcAlpha(NULL),
		m_bufSz(0), m_mapSz(0), m_imageSz(0), m_imageW(0), m_imageH(0), m_blurValid(false), m_affectAlpha(FALSE),
		mp_blurCache(NULL), mp_scratchMap(NULL), mp_nameCurProcess(NULL), m_lastBMModifyID(0xFFFFFFFF) { }
	virtual ~BlurBase() { }
	virtual void notifyPrmChanged(int prmID) { }
	virtual void blur(TimeValue t, CompMap *compositeMap, Bitmap *bm, RenderGlobalContext *gc) { return; };
};

#endif // !defined(_BLURBASE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurDirectional.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurDirectional.cpp

	 DESCRIPTION: directional blur type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "blurDirectional.h"
#include "..\blurMgr.h"


BlurDirectional::~BlurDirectional()
{
	if (mp_blurCache)
		delete[] mp_blurCache;
}

void BlurDirectional::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmDirRot:
			m_rotValid = false;
		case prmDirUPixRad:
		case prmDirVPixRad:
		case prmDirUTrail:
		case prmDirVTrail:
			m_blurValid = false;
		case prmDirAlpha:
			break;
	}
}

bool BlurDirectional::calcRotUPixOffsets()
{
	double c( cos(m_rot) ), s( sin(m_rot) );
	int x1(0), y1(0), x2(0), y2(0);

//	if (m_leftRad) // count pixels left of center
	if (m_leftRad>0) // count pixels left of center // mjm - 10.18.99
	{
		x1 = -round(m_leftRad*c); y1 = -round(m_leftRad*s);
		m_leftRot = findRotPixels(x1, y1, 0, 0) - 1; // don't count origin
	}
	else
		m_leftRot = 0;

//	if (m_rightRad) // count pixels right of center
	if (m_rightRad>0) // count pixels right of center // mjm - 10.18.99
	{
		x2 = round(m_rightRad*c); y2 = round(m_rightRad*s);
		m_rightRot = findRotPixels(0, 0, x2, y2) - 1; // don't count origin
	}
	else
		m_rightRot = 0;

	m_numURotPix = m_leftRot+m_rightRot+1;
	if ( m_szURotPix < m_numURotPix )
	{
		if (mp_uRotPix)
			delete[] mp_uRotPix;
		m_szURotPix = m_numURotPix;
		mp_uRotPix = new IPoint2[m_szURotPix];
		if (!mp_uRotPix)
			return false;
	}

	if (m_numURotPix == 1)
	{
		mp_uRotPix[0].x = mp_uRotPix[0].y = 0;
		return true;
	}

//	if (m_leftRad) // record pixels left of center
	if (m_leftRad>0) // record pixels left of center // mjm - 10.18.99
		findRotPixels(x1, y1, 0, 0, mp_uRotPix, m_numURotPix); // last pixel recorded will be origin

//	if (m_rightRad) // record pixels right of center
	if (m_rightRad>0) // record pixels right of center // mjm - 10.18.99
		findRotPixels(0, 0, x2, y2, mp_uRotPix+m_leftRot, m_numURotPix-m_leftRot); // first pixel recorded will be origin

	return true;
}

bool BlurDirectional::calcRotVPixOffsets()
{
	float c( (float)cos(m_rot) ), s( (float)sin(m_rot) );
	int x1(0), y1(0), x2(0), y2(0);

//	if (m_upRad) // count pixels above center
	if (m_upRad>0) // count pixels above center // mjm - 10.18.99
	{
		x1 = round(m_upRad*s); y1 = -round(m_upRad*c);
		m_upRot = findRotPixels(x1, y1, 0, 0) - 1; // don't count origin
	}
	else
		m_upRot = 0;

//	if (m_downRad) // count pixels below center
	if (m_downRad>0) // count pixels below center // mjm - 10.18.99
	{
		x2 = -round(m_downRad*s); y2 = round(m_downRad*c);
		m_downRot = findRotPixels(0, 0, x2, y2) - 1; // don't count origin
	}
	else
		m_downRot = 0;

	m_numVRotPix = m_upRot+m_downRot+1;
	if ( m_szVRotPix < m_numVRotPix )
	{
		if (mp_vRotPix)
			delete[] mp_vRotPix;
		m_szVRotPix = m_numVRotPix;
		mp_vRotPix = new IPoint2[m_szVRotPix];
		if (!mp_vRotPix)
			return false;
	}

	if (m_numVRotPix == 1)
	{
		mp_vRotPix[0].x = mp_vRotPix[0].y = 0;
		return true;
	}

//	if (m_upRad) // record pixels above center
	if (m_upRad>0) // record pixels above center // mjm - 10.18.99
		findRotPixels(x1, y1, 0, 0, mp_vRotPix, m_numVRotPix); // last pixel recorded will be origin

//	if (m_downRad) // record pixels below center
	if (m_downRad>0) // record pixels below center // mjm - 10.18.99
		findRotPixels(0, 0, x2, y2, mp_vRotPix+m_upRot, m_numVRotPix-m_upRot); // first pixel recorded will be origin

	return true;
}

bool BlurDirectional::do1DBoxRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	float totWts;
	int x,y,p,mapIndex,filterIndex,taskDone;
	mp_nameCurProcess = GetString(IDS_PROCESS_BLUR);

	if (m_uPixRad) // blur only in u direction
	{
		// compute 1D gaussian filter in U direction
		int leftRad( round(m_uPixRad*(1-m_uTrail)) ), rightRad( round(m_uPixRad*(1+m_uTrail)) );
		if ( (leftRad != m_leftRad) || (rightRad != m_rightRad) || !m_rotValid )
		{
			m_leftRad = leftRad; m_rightRad = rightRad;
			if ( !calcRotUPixOffsets() )
				return false;

			if ( m_szUFilter < m_numURotPix )
			{
				if (mp_uFilter)
					delete[] mp_uFilter;
				m_szUFilter = m_numURotPix;
				mp_uFilter = new float[m_szUFilter];
			}
			calcGaussWts(mp_uFilter, m_leftRot, m_rightRot);
			m_rotValid = true;
		}

		mapIndex = -1;
		taskDone = m_imageH;
		// blur all pixels in x dir
		for (y=0; y<m_imageH; y++)
		{
			for (x=0; x<m_imageW; x++)
			{
				mapIndex++;

				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

				// average pixels
				for (filterIndex=0; filterIndex<m_numURotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_uRotPix[filterIndex].x, y-mp_uRotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;

					p = (mapIndex - (mp_uRotPix[filterIndex].y*m_imageW) + mp_uRotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_uFilter[filterIndex];
					totWts += mp_uFilter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}
			if ( ( (y%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, y, taskDone) )
				return false;
		}
	}
	else // blur only in v direction
	{
		// compute 1D gaussian filter in V direction
		int upRad( round(m_vPixRad*(1-m_vTrail)) ), downRad( round(m_vPixRad*(1+m_vTrail)) );
		if ( (upRad != m_upRad) || (downRad != m_downRad) )
		{
			m_upRad = upRad; m_downRad = downRad;
			if ( !calcRotVPixOffsets() )
				return false;

			if ( m_szVFilter < m_numVRotPix )
			{
				if (mp_vFilter)
					delete[] mp_vFilter;
				m_szVFilter = m_numVRotPix;
				mp_vFilter = new float[m_szVFilter];
			}
			calcGaussWts(mp_vFilter, m_upRot, m_downRot);
			m_rotValid = true;
		}

		taskDone = m_imageW;
		// blur all pixels in y dir
		for (x=0; x<m_imageW; x++)
		{
			for (y=0; y<m_imageH; y++)
			{
				mapIndex = x + y*m_imageW;

				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

				// average pixels
				for (filterIndex=0; filterIndex<m_numVRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_vRotPix[filterIndex].x, y-mp_vRotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;
					p = (mapIndex - (mp_vRotPix[filterIndex].y*m_imageW) + mp_vRotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_vFilter[filterIndex];
					totWts += mp_vFilter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}
			if ( ( (x%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, x, taskDone) )
				return false;
		}
	}
	if (mapTo)
	{
		// blend back to source
		int srcIdx;
		for (mapIndex=0; mapIndex<m_imageSz; mapIndex++)
		{
			if (pCompMap)
				blendPixel(mapIndex, mapFrom, mp_blurCache[mapIndex], (*pCompMap)[mapIndex].brighten, (*pCompMap)[mapIndex].blend, mapTo, alphaFrom, alphaTo);
			else
			{
				srcIdx = mapIndex*3;
				mapTo[srcIdx]   = (USHORT)(mp_blurCache[mapIndex].r * MAX_COL16);
				mapTo[srcIdx+1] = (USHORT)(mp_blurCache[mapIndex].g * MAX_COL16);
				mapTo[srcIdx+2] = (USHORT)(mp_blurCache[mapIndex].b * MAX_COL16);
				if (alphaTo)
					alphaTo[mapIndex] = (USHORT)(mp_blurCache[mapIndex].a * MAX_COL16);
			}
		}
	}
	return true;
}

bool BlurDirectional::do1DBoxNoRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	float totWts;
	int x,y,u,v,p,mapIndex, filterIndex, taskDone;
	mp_nameCurProcess = GetString(IDS_PROCESS_BLUR);

	if (m_uPixRad) // blur only in u direction
	{
		// compute 1D gaussian filter in U direction
		int leftRad( round(m_uPixRad*(1-m_uTrail)) ), rightRad( round(m_uPixRad*(1+m_uTrail)) );
		if ( (leftRad != m_leftRad) || (rightRad != m_rightRad) )
		{
			m_leftRad = leftRad; m_rightRad = rightRad;
			if ( m_szUFilter < leftRad+rightRad+1 )
			{
				if (mp_uFilter)
					delete[] mp_uFilter;
				m_szUFilter = leftRad+rightRad+1;
				mp_uFilter = new float[m_szUFilter];
			}
			calcGaussWts(mp_uFilter, m_leftRad, m_rightRad);
		}

		mapIndex = -1;
		taskDone = m_imageH;
		// blur all pixels in x dir
		for (y=0; y<m_imageH; y++)
		{
			for (x=0; x<m_imageW; x++)
			{
				mapIndex++;

				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

				// average pixels
				for (u=-m_leftRad, filterIndex=0; u<=m_rightRad; u++, filterIndex++)

				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+u, y, m_imageW, m_imageH) )
						continue;

					// compute offsets
					p = (mapIndex+u)*3; // align with mapFrom's rgb triplet
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_uFilter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_uFilter[filterIndex];
					totWts += mp_uFilter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}
			if ( ( (y%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, y, taskDone) )
				return false;
		}
	}
	else // blur only in v direction
	{
		// compute 1D gaussian filter in V direction
		int upRad( round(m_vPixRad*(1-m_vTrail)) ), downRad( round(m_vPixRad*(1+m_vTrail)) );
		if ( (upRad != m_upRad) || (downRad != m_downRad) )
		{
			m_upRad = upRad; m_downRad = downRad;
			if ( m_szVFilter < upRad+downRad+1 )
			{
				if (mp_vFilter)
					delete[] mp_vFilter;
				m_szVFilter = upRad+downRad+1;
				mp_vFilter = new float[m_szVFilter];
			}
			calcGaussWts(mp_vFilter, upRad, downRad);
		}

		taskDone = m_imageW;
		// blur all pixels in y dir
		for (x=0; x<m_imageW; x++) {
			for (y=0; y<m_imageH; y++) {
				mapIndex = x + y*m_imageW;

				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

				// average pixels
				for (v=-upRad, filterIndex=0; v<=downRad; v++, filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x, y+v, m_imageW, m_imageH) )
						continue;

					// compute offsets
					p = (mapIndex + v*m_imageW)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_vFilter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_vFilter[filterIndex];
					totWts += mp_vFilter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}
			if ( ( (x%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, x, taskDone) )
				return false;
		}
	}
	if (mapTo)
	{
		// blend back to source
		int srcIdx;
		for (mapIndex=0; mapIndex<m_imageSz; mapIndex++)
		{
			if (pCompMap)
				blendPixel(mapIndex, mapFrom, mp_blurCache[mapIndex], (*pCompMap)[mapIndex].brighten, (*pCompMap)[mapIndex].blend, mapTo, alphaFrom, alphaTo);
			else
			{
				srcIdx = mapIndex*3;
				mapTo[srcIdx]   = (USHORT)(mp_blurCache[mapIndex].r * MAX_COL16);
				mapTo[srcIdx+1] = (USHORT)(mp_blurCache[mapIndex].g * MAX_COL16);
				mapTo[srcIdx+2] = (USHORT)(mp_blurCache[mapIndex].b * MAX_COL16);
				if (alphaTo)
					alphaTo[mapIndex] = (USHORT)(mp_blurCache[mapIndex].a * MAX_COL16);
			}
		}
	}
	return true;
}

bool BlurDirectional::do2DBoxRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	float totWts;
	int x,y,p,mapIndex,filterIndex,taskDone,srcIdx;
	mp_nameCurProcess = GetString(IDS_PROCESS_BLUR);

	// compute 1D gaussian filter in U direction
	int leftRad( round(m_uPixRad*(1-m_uTrail)) ), rightRad( round(m_uPixRad*(1+m_uTrail)) );
	if ( (leftRad != m_leftRad) || (rightRad != m_rightRad) || !m_rotValid )
	{
		m_leftRad = leftRad; m_rightRad = rightRad;
		if ( !calcRotUPixOffsets() )
			return false;

		if ( m_szUFilter < m_numURotPix )
		{
			if (mp_uFilter)
				delete[] mp_uFilter;
			m_szUFilter = m_numURotPix;
			mp_uFilter = new float[m_szUFilter];
		}
		calcGaussWts(mp_uFilter, m_leftRot, m_rightRot);
		// m_rotValid false until mp_vFilter is calculated
	}

	mapIndex = -1;
	taskDone = m_imageH + m_imageW;
	// blur all pixels in x dir
	for (y=0; y<m_imageH; y++)
	{
		for (x=0; x<m_imageW; x++)
		{
			mapIndex++;

			mp_scratchMap[mapIndex].r = mp_scratchMap[mapIndex].g = mp_scratchMap[mapIndex].b = mp_scratchMap[mapIndex].a = 0.0f;
			totWts = 0.0f;

			// average pixels
			for (filterIndex=0; filterIndex<m_numURotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+mp_uRotPix[filterIndex].x, y-mp_uRotPix[filterIndex].y, m_imageW, m_imageH) )
					continue;

				p = (mapIndex - (mp_uRotPix[filterIndex].y*m_imageW) + mp_uRotPix[filterIndex].x)*3;
				mp_scratchMap[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_uFilter[filterIndex];
				totWts += mp_uFilter[filterIndex];
			}
			mp_scratchMap[mapIndex].r /= totWts;
			mp_scratchMap[mapIndex].g /= totWts;
			mp_scratchMap[mapIndex].b /= totWts;
			mp_scratchMap[mapIndex].a /= totWts;
		}
		if ( ( (y%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, y, taskDone) )
			return false;
	}

	// compute 1D gaussian filter in V direction
	int upRad( round(m_vPixRad*(1-m_vTrail)) ), downRad( round(m_vPixRad*(1+m_vTrail)) );
	if ( (upRad != m_upRad) || (downRad != m_downRad) || !m_rotValid )
	{
		m_upRad = upRad; m_downRad = downRad;
		if ( !calcRotVPixOffsets() )
			return false;

		if ( m_szVFilter < m_numVRotPix )
		{
			if (mp_vFilter)
				delete[] mp_vFilter;
			m_szVFilter = m_numVRotPix;
			mp_vFilter = new float[m_szVFilter];
		}
		calcGaussWts(mp_vFilter, m_upRot, m_downRot);
		m_rotValid = true;
	}

	// blur all pixels in y dir
	for (x=0; x<m_imageW; x++)
	{
		for (y=0; y<m_imageH; y++)
		{
			mapIndex = x + y*m_imageW;

				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

			// average pixels
			for (filterIndex=0; filterIndex<m_numVRotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+mp_vRotPix[filterIndex].x, y-mp_vRotPix[filterIndex].y, m_imageW, m_imageH) )
					continue;
				p = (mapIndex - (mp_vRotPix[filterIndex].y*m_imageW) + mp_vRotPix[filterIndex].x);
				mp_blurCache[mapIndex].r += mp_scratchMap[p].r * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].g += mp_scratchMap[p].g * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].b += mp_scratchMap[p].b * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].a += mp_scratchMap[p].a * mp_vFilter[filterIndex];
				totWts += mp_vFilter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;

			if (mapTo)
			{
				// blend back to source
				if (pCompMap)
					blendPixel(mapIndex, mapFrom, mp_blurCache[mapIndex], (*pCompMap)[mapIndex].brighten, (*pCompMap)[mapIndex].blend, mapTo, alphaFrom, alphaTo);
				else
				{
					srcIdx = mapIndex*3;
					mapTo[srcIdx]   = (USHORT)(mp_blurCache[mapIndex].r * MAX_COL16);
					mapTo[srcIdx+1] = (USHORT)(mp_blurCache[mapIndex].g * MAX_COL16);
					mapTo[srcIdx+2] = (USHORT)(mp_blurCache[mapIndex].b * MAX_COL16);
					if (alphaTo)
						alphaTo[mapIndex] = (USHORT)(mp_blurCache[mapIndex].a * MAX_COL16);
				}
			}
		}
		if ( ( (x%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, m_imageH+x, taskDone) )
			return false;
	}
	return true;
}

bool BlurDirectional::do2DBoxNoRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	float totWts;
	int x,y,u,v,p,mapIndex,filterIndex,taskDone, srcIdx;
	mp_nameCurProcess = GetString(IDS_PROCESS_BLUR);

	// compute 1D gaussian filter in U direction
	int leftRad( round(m_uPixRad*(1-m_uTrail)) ), rightRad( round(m_uPixRad*(1+m_uTrail)) );
	if ( (leftRad != m_leftRad) || (rightRad != m_rightRad) )
	{
		m_leftRad = leftRad; m_rightRad = rightRad;
		if ( m_szUFilter < leftRad+rightRad+1 )
		{
			if (mp_uFilter)
				delete[] mp_uFilter;
			m_szUFilter = leftRad+rightRad+1;
			mp_uFilter = new float[m_szUFilter];
		}
		calcGaussWts(mp_uFilter, m_leftRad, m_rightRad);
	}

	mapIndex = -1;
	taskDone = m_imageH + m_imageW;
	// blur all pixels in x dir
	for (y=0; y<m_imageH; y++) {
		for (x=0; x<m_imageW; x++) {
			mapIndex++;

			mp_scratchMap[mapIndex].r = mp_scratchMap[mapIndex].g = mp_scratchMap[mapIndex].b = mp_scratchMap[mapIndex].a = 0.0f;
			totWts = 0.0f;

			// average pixels
			for (u=-m_leftRad, filterIndex=0; u<=m_rightRad; u++, filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+u, y, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = (mapIndex+u)*3; // align with mapFrom's rgb triplet
				mp_scratchMap[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_uFilter[filterIndex];
				mp_scratchMap[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_uFilter[filterIndex];
				totWts += mp_uFilter[filterIndex];
			}
			mp_scratchMap[mapIndex].r /= totWts;
			mp_scratchMap[mapIndex].g /= totWts;
			mp_scratchMap[mapIndex].b /= totWts;
			mp_scratchMap[mapIndex].a /= totWts;
		}
		if ( ( (y%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, y, taskDone) )
			return false;
	}

	// compute 1D gaussian filter in V direction
	int upRad( round(m_vPixRad*(1-m_vTrail)) ), downRad( round(m_vPixRad*(1+m_vTrail)) );
	if ( (upRad != m_upRad) || (downRad != m_downRad) )
	{
		m_upRad = upRad; m_downRad = downRad;
		if ( m_szVFilter < upRad+downRad+1 )
		{
			if (mp_vFilter)
				delete[] mp_vFilter;
			m_szVFilter = upRad+downRad+1;
			mp_vFilter = new float[m_szVFilter];
		}
		calcGaussWts(mp_vFilter, upRad, downRad);
	}

	// blur all pixels in y dir
	for (x=0; x<m_imageW; x++) {
		for (y=0; y<m_imageH; y++) {
			mapIndex = x + y*m_imageW;

			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;

			// average pixels
			for (v=-upRad, filterIndex=0; v<=downRad; v++, filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x, y+v, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = mapIndex + v*m_imageW;
				mp_blurCache[mapIndex].r += mp_scratchMap[p].r * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].g += mp_scratchMap[p].g * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].b += mp_scratchMap[p].b * mp_vFilter[filterIndex];
				mp_blurCache[mapIndex].a += mp_scratchMap[p].a * mp_vFilter[filterIndex];
				totWts += mp_vFilter[filterIndex];
			}

			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;

			if (mapTo)
			{
				// blend back to source
				if (pCompMap)
					blendPixel(mapIndex, mapFrom, mp_blurCache[mapIndex], (*pCompMap)[mapIndex].brighten, (*pCompMap)[mapIndex].blend, mapTo, alphaFrom, alphaTo);
				else
				{
					srcIdx = mapIndex*3;
					mapTo[srcIdx]   = (USHORT)(mp_blurCache[mapIndex].r * MAX_COL16);
					mapTo[srcIdx+1] = (USHORT)(mp_blurCache[mapIndex].g * MAX_COL16);
					mapTo[srcIdx+2] = (USHORT)(mp_blurCache[mapIndex].b * MAX_COL16);
					if (alphaTo)
						alphaTo[mapIndex] = (USHORT)(mp_blurCache[mapIndex].a * MAX_COL16);
				}
			}
		}
		if ( ( (x%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, m_imageH+x, taskDone) )
			return false;
	}
	return true;
}

bool BlurDirectional::doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	if(m_blurValid && mapTo)
	{
		int srcIdx;
		for (int i=0; i<m_imageSz; i++)
			if (pCompMap)
				blendPixel(i, mapFrom, mp_blurCache[i], (*pCompMap)[i].brighten, (*pCompMap)[i].blend, mapTo, alphaFrom, alphaTo);
			else
			{
				srcIdx = i*3;
				mp_srcMap[srcIdx]   = (USHORT)(mp_blurCache[i].r * MAX_COL16);
				mp_srcMap[srcIdx+1] = (USHORT)(mp_blurCache[i].g * MAX_COL16);
				mp_srcMap[srcIdx+2] = (USHORT)(mp_blurCache[i].b * MAX_COL16);
				if (alphaTo)
					alphaTo[i] = (USHORT)(mp_blurCache[i].a * MAX_COL16);
			}
		return true;
	}

	// adjust so 0 <= angle < PI/2
	if (m_rot >= PIOVER2)
	{
		int iTemp(m_uPixRad);
		m_uPixRad = m_vPixRad;
		m_vPixRad = iTemp;

		float fTemp(m_uTrail);
		m_uTrail = m_vTrail;
		m_vTrail = fTemp;

		m_rot -= PIOVER2;
	}

	if ( m_uPixRad == m_vPixRad )
	{
		return do2DBoxNoRot(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
	}

	if ( m_rot == 0.0f )
	{
		if ( (!m_uPixRad && m_vPixRad) || (m_uPixRad && !m_vPixRad) )
			return do1DBoxNoRot(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
		else
			return do2DBoxNoRot(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
	}
	else
	{
		if ( (!m_uPixRad && m_vPixRad) || (m_uPixRad && !m_vPixRad) )
			return do1DBoxRot(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
		else
			return do2DBoxRot(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
	}
}

void BlurDirectional::blur(TimeValue t, CompMap *pCompMap, Bitmap *bm, RenderGlobalContext *gc)
{
	// get source bitmap data
	int type;
	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_blurValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
		}
	}

	// get ui parameters
	int iTemp;
	float fTemp;
	mp_blurMgr->getBlurValue(prmDirUPixRad, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_uPixRad = (int)( 0.5*floor( max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC) ) );

	mp_blurMgr->getBlurValue(prmDirVPixRad, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_vPixRad = (int)( 0.5*floor( max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC) ) );

	mp_blurMgr->getBlurValue(prmDirUTrail, t, fTemp, FOREVER);
	LimitValue(fTemp, -100.0f, 100.0f); // mjm - 9.30.99
	m_uTrail = fTemp*PERCENT2DEC;

	mp_blurMgr->getBlurValue(prmDirVTrail, t, fTemp, FOREVER);
	LimitValue(fTemp, -100.0f, 100.0f); // mjm - 9.30.99
	m_vTrail = fTemp*PERCENT2DEC;

	mp_blurMgr->getBlurValue(prmDirRot, t, iTemp, FOREVER);
	LimitValue(iTemp, -180, 180); // mjm - 9.30.99
	m_rot = (float)fmod(iTemp*DEG2RAD, PI);

	mp_blurMgr->getBlurValue(prmDirAlpha, t, m_affectAlpha, FOREVER);

	// setup buffers
	if (m_imageSz > m_mapSz)
	{
		if (mp_scratchMap)
			delete[] mp_scratchMap;
		mp_scratchMap = new AColor[m_imageSz];

		if (mp_blurCache)
			delete[] mp_blurCache;
		mp_blurCache = new AColor[m_imageSz];

		m_mapSz = m_imageSz;
	}

	m_blurValid = doBlur(pCompMap, mp_srcMap, mp_srcMap, mp_srcAlpha, (m_affectAlpha) ? mp_srcAlpha : NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurDirectional.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurDirectional.h

	 DESCRIPTION: directional blur type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_BLUR_DIRECTIONAL_H_INCLUDED_)
#define _BLUR_DIRECTIONAL_H_INCLUDED_

#include "blurBase.h"

class BlurDirectional : public BlurBase
{
protected:
	bool m_rotValid;
	int m_uPixRad, m_vPixRad, m_numURotPix, m_numVRotPix, m_szURotPix, m_szVRotPix, m_szUFilter, m_szVFilter,
		m_leftRad, m_rightRad, m_upRad, m_downRad, m_leftRot, m_rightRot, m_upRot, m_downRot;
	float m_uTrail, m_vTrail, m_rot;
	float *mp_uFilter, *mp_vFilter;
	IPoint2 *mp_uRotPix, *mp_vRotPix;


	bool calcRotUPixOffsets();
	bool calcRotVPixOffsets();
	bool do1DBoxRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);
	bool do1DBoxNoRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);
	bool do2DBoxRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);
	bool do2DBoxNoRot(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);
	virtual bool doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);

public:
	BlurDirectional() : m_rotValid(false), m_uPixRad(0), m_vPixRad(0), m_numURotPix(0), m_numVRotPix(0), m_szURotPix(0), m_szVRotPix(0),
		m_szUFilter(0), m_szVFilter(0), m_leftRad(-1), m_rightRad(-1), m_upRad(-1), m_downRad(-1), // mjm - 10.18.99
		m_leftRot(0), m_rightRot(0), m_upRot(0), m_downRot(0), m_uTrail(0.0f), m_vTrail(0.0f), m_rot(0.0f),
		mp_uFilter(NULL), mp_vFilter(NULL), mp_uRotPix(NULL), mp_vRotPix(NULL) { }
	BlurDirectional(BlurMgr *const mgr) : m_rotValid(false), m_uPixRad(0), m_vPixRad(0), m_numURotPix(0), m_numVRotPix(0), m_szURotPix(0), m_szVRotPix(0),
		m_szUFilter(0), m_szVFilter(0), m_leftRad(-1), m_rightRad(-1), m_upRad(-1), m_downRad(-1), // mjm - 10.18.99
		m_leftRot(0), m_rightRot(0), m_upRot(0), m_downRot(0), m_uTrail(0.0f), m_vTrail(0.0f), m_rot(0.0f),
		mp_uFilter(NULL), mp_vFilter(NULL), mp_uRotPix(NULL), mp_vRotPix(NULL), BlurBase(mgr) { }
	~BlurDirectional();
	virtual void notifyPrmChanged(int prmID);
	virtual void blur(TimeValue t, CompMap *compositeMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_BLUR_DIRECTIONAL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\globals.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: globals.h

	 DESCRIPTION: global access to identifiers

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_GLOBALS_H_INCLUDED_)
#define _GLOBALS_H_INCLUDED_

namespace blurGlobals {

	// primary IDs
	enum { idMaster, idBlurData, idSelData, numIDs };

	// parameter IDs
	enum // blur data parameters
	{
		prmBlurType,
		prmUnifPixRad, prmUnifAlpha,
		prmDirUPixRad, prmDirVPixRad, prmDirUTrail, prmDirVTrail, prmDirRot, prmDirAlpha,
		prmRadialPixRad, prmRadialTrail, prmRadialAlpha, prmRadialXOrig, prmRadialYOrig, prmRadialUseNode, prmRadialNode,
	};

	enum // selection data parameters
	{
		prmImageActive, prmIBackActive, prmLumActive, prmMaskActive,
		prmImageBrighten, prmImageBlend,
		prmIBackBrighten, prmIBackBlend, prmIBackFeathRad,
		prmLumBrighten, prmLumBlend, prmLumMin, prmLumMax, prmLumFeathRad,
		prmMaskMap, prmMaskChannel, prmMaskBrighten, prmMaskBlend, prmMaskMin, prmMaskMax, prmMaskFeathRad,
	};

	// blur types
	enum { idBlurUnif, idBlurDir, idBlurRadial, numBlurs };

	// selection types
	enum { idSelImage, idSelIBack, idSelLum, idSelMask, numSels };

	const int	MAX_COL16(65535);			// maximum 16 bit color value
	const float	PITIMES2(6.283185f);		// pi*2
	const float	PIOVER2(1.570796f);			// pi/2
	const float	PIOVER4(7.853982e-1f);		// pi/4
	const float	RT2OVER2(7.071068e-1f);		// (sqrt(2))/2
	const float	WORD2NORMFLT(1.525902e-5f);	// 16-bit WORD to normalized [0,1] float
	const float	DEG2RAD(1.745329e-2f);		// degrees to radians
	const float	RAD2DEG(5.729578e+1f);		// radians to degrees
	const float	PERCENT2DEC(0.01f);			// percent to decimal fraction

	inline int sgn(int x)
		{ return (x<0) ? -1 : 1; }
	inline int sqr(int i)
		{ return i*i; }
	inline float sqr(float f)
		{ return f*f; }
	inline double sqr(double d)
		{ return d*d; }
	inline void round(Point2 &pt)
		{ pt.x = (float)( (pt.x>0) ? (int)(pt.x+0.5f) : -(int)(0.5f-pt.x) );
		  pt.y = (float)( (pt.y>0) ? (int)(pt.y+0.5f) : -(int)(0.5f-pt.y) ); }
	inline int round(float x)
		{ return (x>0) ? (int)(x+0.5f) : -(int)(0.5f-x); }
	inline int round(double x)
		{ return (x>0) ? (int)(x+0.5) : -(int)(0.5-x); }
	inline bool inBounds(int x, int y, int w, int h)
		{ return (x>=0 && x<w && y>=0 && y<h); }
	inline WORD luminance16(WORD r, WORD g, WORD b)	// perceptually based luminance (from "A Technical Introduction to Digital Video", C. Poynton)
		{ return (WORD)(r*0.2125f + g*0.7154f + b*0.0721f); }
	inline float luminanceNormFloat(float r, float g, float b)
		{ return (r*0.2125f + g*0.7154f + b*0.0721f); }
	inline float luminanceNormFloat(WORD r, WORD g, WORD b)
		{ return (r*3.242542e-6f + g*1.091630e-5f + b*1.100175e-6f); }	// lum factors pre-multiplied by WORD2NORMFLT

	class CompWt
	{
	public:
		float brighten;
		float blend;
		CompWt() : brighten(0.0f), blend(0.0f) { }
		CompWt(float &_brighten, float &_blend) { brighten =_brighten; blend = _blend; }
		CompWt(CompWt &compWt) { brighten = compWt.brighten; blend = compWt.blend; }
	};

	class CompMap
	{
		CompWt *map;
		int size;

	public:
		CompMap() : map(NULL), size(0) { }

		~CompMap()
		{
			if (map)
				delete[] map;
		}

		CompWt& operator[](int i) { return map[i]; }

		void resize(int newSize)
		{
			if (newSize>size)
			{
				if (map)
					delete[] map;
				map = new CompWt[size = newSize];
			}
		}

		void set(float brighten, float blend, int num)
		{
			for (int i=0; i<num; i++)
			{
				map[i].brighten = brighten;
				map[i].blend = blend;
			}
		}
	};
}

using namespace blurGlobals;

#endif // !defined(_GLOBALS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurBase.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurBase.cpp

	 DESCRIPTION: uniform blur type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// system includes
#include <assert.h>

// local includes
#include "blurBase.h"

int BlurBase::findRotPixels(int x1, int y1, int x2, int y2, IPoint2* buf, int sz)
{
	int num(0);
	int x(x1), dx(x2-x1), ax(abs(dx)<<1), sx = sgn(dx);
	int y(y1), dy(y2-y1), ay(abs(dy)<<1), sy = sgn(dy);
	int d;

    if (ax>ay) // slope < 1
	{
		d = ay-(ax>>1);
		for (;;)
		{
			if (buf)
			{
				if (num > sz)
					return -1;
				buf[num].x = x;
				buf[num].y = y;
			}
			num++;
			if (x==x2)
				return num;
			if (d>=0)
			{
				y += sy;
				d -= ax;
			}
			x += sx;
			d += ay;
		}
	}
	else // slope >= 1
	{
		d = ax-(ay>>1);
		for (;;) {
			if (buf)
			{
				if (num > sz)
					return -1;
				buf[num].x   = x;
				buf[num].y = y;
			}
			num++;
			if (y==y2)
				return num;
			if (d>=0)
			{
				x += sx;
				d -= ay;
			}
			y += sy;
			d += ax;
		}
	}
}

void BlurBase::calcGaussWts(float *buf, int bufSz)
{
	assert(buf);

	int xDist, rad = (bufSz-1)/2;
	float sigma;
	
	for (int i=0; i<bufSz; i++)
	{
		xDist = i-rad;
		sigma = rad/2.0f;
		buf[i] = (float)exp(-(sqr(xDist))/(2.0*sqr(sigma)));
	}
}

void BlurBase::calcGaussWts(float *buf, int radA, int radB)
{
	assert(buf);

	int index(0);
	float sigma(radA/2.0f);
	for (int i=radA; i>0; i--)
		buf[index++] = (float)exp(-(sqr(i))/(2.0*sqr(sigma)));

	buf[index++] = 1.0f;

	sigma = radB/2.0f;
	for (i=1; i<=radB; i++)
		buf[index++] = (float)exp(-(sqr(i))/(2.0*sqr(sigma)));
}

void BlurBase::blendPixel(int index, WORD *mapFrom, AColor blendCol, float brighten, float blend, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	static int srcIdx;
	static float notBlend;

	srcIdx = index * 3;
	notBlend = (1 - blend) * WORD2NORMFLT; // pre-multiply the conversion from WORD to float

	blend *= brighten+1.0f; // pre-multiply brighten (+ 1.0f makes it a multiplier)

	blendCol.r = blendCol.r*blend + mapFrom[srcIdx  ]*notBlend;
	blendCol.g = blendCol.g*blend + mapFrom[srcIdx+1]*notBlend;
	blendCol.b = blendCol.b*blend + mapFrom[srcIdx+2]*notBlend;
	if (alphaTo && alphaFrom && (blend > 0.0f) )
		blendCol.a = blendCol.a*blend + alphaFrom[index]*notBlend;

	blendCol.ClampMinMax();

	mapTo[srcIdx]	= (USHORT)(blendCol.r * MAX_COL16);
	mapTo[srcIdx+1] = (USHORT)(blendCol.g * MAX_COL16);
	mapTo[srcIdx+2] = (USHORT)(blendCol.b * MAX_COL16);
	if (alphaTo && alphaFrom && (blend > 0.0f) )
			alphaTo[index] = (USHORT)(blendCol.a * MAX_COL16);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by blur.rc
//
#define IDD_MASTER                      501
#define IDD_BLUR_UNIFORM                521
#define IDD_BLUR_DIRECTIONAL            522
#define IDD_BLUR_RADIAL                 523
#define IDD_BLUR_SWIRL                  524
#define IDD_SEL_IMAGE                   531
#define IDD_SEL_IGN_BACK                532
#define IDD_SEL_LUMINANCE               533
#define IDD_SEL_MAPS                    534
#define IDD_BLUR_TYPES                  535
#define IDD_SEL_TYPES                   536
#define IDC_TAB                         1001
#define IDL_BLUR_TYPES                  1011
#define IDL_SEL_TYPES                   1012
#define IDE_RAD                         1021
#define IDSP_RAD                        1022
#define IDE_U_RAD                       1023
#define IDE_SLUM_FRAD                   1023
#define IDSP_U_RAD                      1024
#define IDSP_SLUM_FRAD                  1024
#define IDE_V_RAD                       1025
#define IDE_SMASK_FRAD                  1025
#define IDSP_V_RAD                      1026
#define IDSP_SMASK_FRAD                 1026
#define IDE_BRADIAL_RAD                 1027
#define IDSP_BRADIAL_RAD                1028
#define IDE_BRADIAL_XORIGIN             1029
#define IDSP_BRADIAL_XORIGIN            1030
#define IDE_TRAIL                       1031
#define IDE_BRADIAL_YORIGIN             1031
#define IDSP_TRAIL                      1032
#define IDSP_BRADIAL_YORIGIN            1032
#define IDE_U_TRAIL                     1034
#define IDSP_U_TRAIL                    1035
#define IDE_V_TRAIL                     1036
#define IDSP_V_TRAIL                    1037
#define IDE_ROT                         1041
#define IDSP_ROT                        1042
#define IDE_MIN                         1051
#define IDSP_MIN                        1052
#define IDE_MAX                         1053
#define IDSP_MAX                        1054
#define IDE_SMASK_MIN                   1055
#define IDE_SMASK_MAX                   1056
#define IDSP_SMASK_MIN                  1057
#define IDSP_SMASK_MAX                  1058
#define IDE_BRIGHTEN                    1061
#define IDSP_BRIGHTEN                   1062
#define IDE_BLEND                       1063
#define IDSP_BLEND                      1064
#define IDB_MAP                         1065
#define IDE_SIBACK_BRIGHTEN             1065
#define IDSP_SIBACK_BRIGHTEN            1066
#define IDCB_CHANNEL                    1067
#define IDE_SIBACK_BLEND                1067
#define IDSP_SIBACK_BLEND               1068
#define IDE_SLUM_BRIGHTEN               1069
#define IDSP_SLUM_BRIGHTEN              1070
#define IDE_SLUM_BLEND                  1071
#define IDSP_SLUM_BLEND                 1072
#define IDCB_SMASK_CHANNEL              1073
#define IDB_SMASK_MAP                   1074
#define IDE_SMASK_BRIGHTEN              1075
#define IDSP_SMASK_BRIGHTEN             1076
#define IDE_SMASK_BLEND                 1077
#define IDSP_SMASK_BLEND                1078
#define IDR_BLUR_UNIF                   1104
#define IDR_BLUR_DIR                    1105
#define IDC_SIMAGE_ACTIVE               1105
#define IDR_BLUR_RADIAL                 1106
#define IDC_SIBACK_ACTIVE               1106
#define IDE_BUNIF_RAD                   1107
#define IDC_SLUM_ACTIVE                 1107
#define IDSP_BUNIF_RAD                  1108
#define IDC_SMASK_ACTIVE                1108
#define IDE_BDIR_URAD                   1109
#define IDSP_BDIR_URAD                  1110
#define IDE_BDIR_VRAD                   1111
#define IDSP_BDIR_VRAD                  1112
#define IDE_BDIR_UTRAIL                 1113
#define IDSP_BDIR_UTRAIL                1114
#define IDE_BDIR_VTRAIL                 1115
#define IDSP_BDIR_VTRAIL                1116
#define IDE_BDIR_ROT                    1117
#define IDSP_BDIR_ROT                   1118
#define IDE_SIMAGE_BRIGHTEN             1119
#define IDSP_SIMAGE_BRIGHTEN            1120
#define IDE_SIMAGE_BLEND                1121
#define IDSP_SIMAGE_BLEND               1122
#define IDE_BRADIAL_TRAIL               1123
#define IDSP_BRADIAL_TRAIL              1124
#define IDE_SIBACK_FRAD                 1125
#define IDSP_SIBACK_FRAD                1126
#define IDE_SLUM_MIN                    1127
#define IDSP_SLUM_MIN                   1128
#define IDE_SLUM_MAX                    1129
#define IDSP_SLUM_MAX                   1130
#define IDC_BUNIF_ALPHA                 1131
#define IDC_BDIR_ALPHA                  1132
#define IDC_BRADIAL_ALPHA               1133
#define IDB_BRADIAL_OBJECT              1134
#define IDB_BRADIAL_NODE                1134
#define IDC_BRADIAL_USE_OBJECT          1135
#define IDC_BRADIAL_USE_NODE            1135
#define IDB_BRADIAL_CLEAR_NODE          1136
#define IDS_LIBDESCRIPTION              30501
#define IDS_BLUR_PARAMS                 30502
#define IDS_PARAMS                      30502
#define IDS_NAME                        30503
#define IDS_BLUR                        30504
#define IDS_CLASS_NAME                  30504
#define IDS_CDESC_CLASS_NAME            30505
#define IDS_BLUR_TYPE                   30601
#define IDS_BUNIF_PIXEL_RAD             30701
#define IDS_BUNIF_ALPHA                 30702
#define IDS_BDIR_UPIX_RAD               30711
#define IDS_BDIR_VPIX_RAD               30712
#define IDS_BDIR_UTRAIL                 30713
#define IDS_BDIR_VTRAIL                 30714
#define IDS_BDIR_ROTATION               30715
#define IDS_BDIR_ALPHA                  30716
#define IDS_BRADIAL_PIXEL_RAD           30721
#define IDS_BRADIAL_TRAIL               30722
#define IDS_BRADIAL_ALPHA               30723
#define IDS_BRADIAL_XORIGIN             30724
#define IDS_BRADIAL_YORIGIN             30725
#define IDS_BRADIAL_USE_OBJECT          30726
#define IDS_BRADIAL_USE_NODE            30726
#define IDS_BRADIAL_OBJECT              30727
#define IDS_BRADIAL_NODE                30727
#define IDS_BRADIAL_OBJECT_PROMPT       30728
#define IDS_BRADIAL_NODE_PROMPT         30728
#define IDS_SEL_TYPES                   30801
#define IDS_RED                         30833
#define IDS_GREEN                       30834
#define IDS_BLUE                        30835
#define IDS_ALPHA                       30836
#define IDS_LUMINANCE                   30837
#define IDS_SIMAGE_ACTIVE               30901
#define IDS_SIMAGE_BRIGHTEN             30902
#define IDS_SIMAGE_BLEND                30903
#define IDS_SIMAGE_BLEND2               30904
#define IDS_SIBACK_ACTIVE               30911
#define IDS_SIBACK_BRIGHTEN             30912
#define IDS_SIBACK_BLEND                30913
#define IDS_SIBACK_FEATHER_RAD          30914
#define IDS_SLUM_ACTIVE                 30921
#define IDS_SLUM_BRIGHTEN               30922
#define IDS_SLUM_BLEND                  30923
#define IDS_SLUM_MIN                    30924
#define IDS_SLUM_MAX                    30925
#define IDS_SLUM_FEATHER_RAD            30926
#define IDS_SMASK_ACTIVE                30931
#define IDS_SMASK_MAP                   30932
#define IDS_SMASK_CHANNEL               30933
#define IDS_SMASK_BRIGHTEN              30934
#define IDS_SMASK_BLEND                 30935
#define IDS_SMASK_MIN                   30936
#define IDS_SMASK_MAX                   30937
#define IDS_SMASK_FEATHER_RAD           30938
#define IDS_PROCESS_BLUR                30941
#define IDS_PROCESS_SELECT              30942
#define IDS_PROCESS_FEATHER             30943
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1137
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurRadial.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurRadial.h

	 DESCRIPTION: radial blur type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_BLUR_RADIAL_H_INCLUDED_)
#define _BLUR_RADIAL_H_INCLUDED_

class BlurBase;
#include "blurBase.h"

class BlurRadial : public BlurBase
{
protected:
	BOOL m_useNode;
	INode *m_node;
	Point2 m_orig;
	int m_pixRad, m_inRad, m_outRad, m_inRot, m_outRot, m_szFilter, m_szRotPix, m_numRotPix;
	float m_trail;
	float *mp_Filter;
	IPoint2 *mp_RotPix;
	Interval m_validInterval;

	bool calcRotPixOffsets(double theta);
	virtual bool doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);
public:
	BlurRadial() : m_szFilter(0), m_szRotPix(0), m_numRotPix(0), mp_Filter(NULL), mp_RotPix(NULL), m_validInterval(FOREVER) { }
	BlurRadial(BlurMgr *const mgr) : m_szFilter(0), m_szRotPix(0), m_numRotPix(0), mp_Filter(NULL), mp_RotPix(NULL), m_validInterval(FOREVER), BlurBase(mgr) { }
	~BlurRadial();
	virtual void notifyPrmChanged(int prmID);
	virtual void blur(TimeValue t, CompMap *compositeMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_BLUR_RADIAL_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurRadial.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurRadial.cpp

	 DESCRIPTION: radial blur type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "blurRadial.h"
#include "..\blurMgr.h"


BlurRadial::~BlurRadial()
{
	if (mp_blurCache)
		delete[] mp_blurCache;
}

void BlurRadial::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmRadialPixRad:
		case prmRadialTrail:
		case prmRadialXOrig:
		case prmRadialYOrig:
		case prmRadialUseNode:
		case prmRadialNode:
			m_blurValid = false;
		case prmRadialAlpha:
			break;
	}
}

bool BlurRadial::calcRotPixOffsets(double theta)
{
	double c( cos(theta) ), s( sin(theta) );
	int x1(0), y1(0), x2(0), y2(0);

	if (m_inRad) // count pixels left of center
	{
		x1 = -round(m_inRad*c); y1 = -round(m_inRad*s);
		m_inRot = findRotPixels(x1, y1, 0, 0) - 1; // don't count origin
	}
	else
		m_inRot = 0;

	if (m_outRad) // count pixels right of center
	{
		x2 = round(m_outRad*c); y2 = round(m_outRad*s);
		m_outRot = findRotPixels(0, 0, x2, y2) - 1; // don't count origin
	}
	else
		m_outRot = 0;

	m_numRotPix = m_inRot+m_outRot+1;
	if ( m_szRotPix < m_numRotPix )
	{
		if (mp_RotPix)
			delete[] mp_RotPix;
		m_szRotPix = m_numRotPix;
		mp_RotPix = new IPoint2[m_szRotPix];
		if (!mp_RotPix)
			return false;
	}

	if (m_numRotPix == 1)
	{
		mp_RotPix[0].x = mp_RotPix[0].y = 0;
		return true;
	}

	if (m_inRad) // record pixels left of center
		findRotPixels(x1, y1, 0, 0, mp_RotPix, m_numRotPix); // last pixel recorded will be origin

	if (m_outRad) // record pixels right of center
		findRotPixels(0, 0, x2, y2, mp_RotPix+m_inRot, m_numRotPix-m_inRot); // first pixel recorded will be origin

	return true;
}

bool BlurRadial::doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	// this function really needs to be cleaned up and modularized ... no time!
	float totWts, outMult=2.0f;
	int i,j,u,v,x,y,p,mapIndex,filterIndex,taskDone,doneSoFar(0);
	double pixRad,distRatio,dist,maxDist,theta;
	mp_nameCurProcess = GetString(IDS_PROCESS_BLUR);

	if(m_blurValid && mapTo)
	{
		int srcIdx;
		for (int i=0; i<m_imageSz; i++)
			if (pCompMap)
				blendPixel(i, mapFrom, mp_blurCache[i], (*pCompMap)[i].brighten, (*pCompMap)[i].blend, mapTo, alphaFrom, alphaTo);
			else
			{
				srcIdx = i*3;
				mp_srcMap[srcIdx]   = (USHORT)(mp_blurCache[i].r * MAX_COL16);
				mp_srcMap[srcIdx+1] = (USHORT)(mp_blurCache[i].g * MAX_COL16);
				mp_srcMap[srcIdx+2] = (USHORT)(mp_blurCache[i].b * MAX_COL16);
				if (alphaTo)
					alphaTo[i] = (USHORT)(mp_blurCache[i].a * MAX_COL16);
			}
		return true;
	}

	int maxX = max( abs(m_orig.x), abs(m_imageW - m_orig.x) );
	int maxY = max( abs(m_orig.y), abs(m_imageH - m_orig.y) );
	int maxXY = max(maxX, maxY);
	maxDist = sqrt( sqr(maxX) + sqr(maxY) );

	if ( inBounds(m_orig.x, m_orig.y, m_imageW, m_imageH) )
	{
		// ----------------------------------------------------------------------------------
		// do not blur origin
		// ----------------------------------------------------------------------------------
		mapIndex = m_orig.x + m_orig.y*m_imageW;
		p = mapIndex*3; // align with mapFrom's rgb triplet
		mp_blurCache[mapIndex].r = mapFrom[p]  *WORD2NORMFLT;
		mp_blurCache[mapIndex].g = mapFrom[p+1]*WORD2NORMFLT;
		mp_blurCache[mapIndex].b = mapFrom[p+2]*WORD2NORMFLT;
		mp_blurCache[mapIndex].a = alphaFrom[mapIndex]*WORD2NORMFLT;
	}

	// --------------------------------------------------------------------------------------
	// blur along axes
	// --------------------------------------------------------------------------------------
	int counter(0);
	y = m_orig.y;
	taskDone = maxX + maxY + maxXY + 40*maxY; // weight the last maxY since it is a much slower loop
	for (i=1; i<=maxX; i++)
	{
		dist = (double)i;
		distRatio = dist/maxDist;
		pixRad = distRatio * m_pixRad;
		m_inRad = round(pixRad*(1-m_trail)); m_outRad = round(pixRad*outMult*(1+m_trail));
		if ( m_szFilter < m_inRad+m_outRad+1 )
		{
			if (mp_Filter)
				delete[] mp_Filter;
			m_szFilter = m_inRad+m_outRad+1;
			mp_Filter = new float[m_szFilter];
		}
		calcGaussWts(mp_Filter, m_inRad, m_outRad);

		// +x axis --------------------------------------------------------------------------
		x = m_orig.x+i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (u=-m_inRad, filterIndex=0; u<=m_outRad; u++, filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+u, y, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = (mapIndex+u)*3; // align with mapFrom's rgb triplet
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}

		// -x axis --------------------------------------------------------------------------
		x = m_orig.x-i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (u=-m_outRad, filterIndex=m_outRad+m_inRad; u<=m_inRad; u++, filterIndex--)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+u, y, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = (mapIndex+u)*3; // align with mapFrom's rgb triplet
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}
		if ( ( (i%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, i, taskDone) )
			return false;
	}
	doneSoFar += maxX;

	x = m_orig.x;
	for (j=1; j<=maxY; j++)
	{
		dist = (double)j;
		distRatio = dist/maxDist;
		pixRad = distRatio * m_pixRad;
		m_inRad = round(pixRad*(1-m_trail)); m_outRad = round(pixRad*outMult*(1+m_trail));
		if ( m_szFilter < m_inRad+m_outRad+1 )
		{
			if (mp_Filter)
				delete[] mp_Filter;
			m_szFilter = m_inRad+m_outRad+1;
			mp_Filter = new float[m_szFilter];
		}
		calcGaussWts(mp_Filter, m_inRad, m_outRad);

		// +y axis --------------------------------------------------------------------------
		y = m_orig.y+j;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (v=-m_inRad, filterIndex=0; v<=m_outRad; v++, filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x, y+v, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = (mapIndex + v*m_imageW)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}

		// -y axis --------------------------------------------------------------------------
		y = m_orig.y-j;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (v=-m_outRad, filterIndex=m_outRad+m_inRad; v<=m_inRad; v++, filterIndex--)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x, y+v, m_imageW, m_imageH) )
					continue;

				// compute offsets
				p = (mapIndex + v*m_imageW)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}
		if ( ( (j%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, j+doneSoFar, taskDone) )
			return false;
	}
	doneSoFar += maxY;

	// --------------------------------------------------------------------------------------
	// blur along 45 degrees
	// --------------------------------------------------------------------------------------
	theta = atan(1);
	for (i=1; i<=maxXY; i++) {
		dist = sqrt( 2*sqr(i) );
		distRatio = dist/maxDist;
		pixRad = distRatio * m_pixRad;
		m_inRad = round(pixRad*(1-m_trail)); m_outRad = round(pixRad*outMult*(1+m_trail));
		if ( !calcRotPixOffsets(theta) )
			return false;
		if ( m_szFilter < m_numRotPix )
		{
			if (mp_Filter)
				delete[] mp_Filter;
			m_szFilter = m_numRotPix;
			mp_Filter = new float[m_szFilter];
		}
		calcGaussWts(mp_Filter, m_inRot, m_outRot);

		// +x, +y -------------------------------------------------------------------
		x = m_orig.x+i;
		y = m_orig.y+i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;

				p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}

		// -x, +y -------------------------------------------------------------------
		x = m_orig.x-i;
		y = m_orig.y+i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x-mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;

				p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}

		// -x, -y -------------------------------------------------------------------
		x = m_orig.x-i;
		y = m_orig.y-i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x-mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;

				p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}

		// +x, -y -------------------------------------------------------------------
		x = m_orig.x+i;
		y = m_orig.y-i;
		if ( inBounds(x, y, m_imageW, m_imageH) )
		{
			// average pixels
			mapIndex = x + y*m_imageW;
			mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
			totWts = 0.0f;
			for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
			{
				// for speed, the filter size is reduced at edges of image
				// rather than extrapolating color values for non-existing pixels
				if ( !inBounds(x+mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
						continue;

				p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
				mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
				mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
				totWts += mp_Filter[filterIndex];
			}
			mp_blurCache[mapIndex].r /= totWts;
			mp_blurCache[mapIndex].g /= totWts;
			mp_blurCache[mapIndex].b /= totWts;
			mp_blurCache[mapIndex].a /= totWts;
		}
		if ( ( (i%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, i+doneSoFar, taskDone) )
			return false;
	}
	doneSoFar += maxXY;

	// --------------------------------------------------------------------------------------
	// blur inbetween
	// --------------------------------------------------------------------------------------
	int iTemp;
	for (j=1; j<=maxXY; j++) {
		for (i=j+1; i<=maxXY; i++) {
			theta = atan2( j, i );
			dist = sqrt( sqr(i) + sqr(j) );
			distRatio = dist/maxDist;
			pixRad = distRatio * m_pixRad;
			m_inRad = round(pixRad*(1-m_trail)); m_outRad = round(pixRad*outMult*(1+m_trail));
			if ( !calcRotPixOffsets(theta) )
				return false;
			if ( m_szFilter < m_numRotPix )
			{
				if (mp_Filter)
					delete[] mp_Filter;
				m_szFilter = m_numRotPix;
				mp_Filter = new float[m_szFilter];
			}
			calcGaussWts(mp_Filter, m_inRot, m_outRot);

			// +x, +y -------------------------------------------------------------------
			x = m_orig.x+i;
			y = m_orig.y+j;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// -x, +y -------------------------------------------------------------------
			x = m_orig.x-i;
			y = m_orig.y+j;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x-mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// -x, -y -------------------------------------------------------------------
			x = m_orig.x-i;
			y = m_orig.y-j;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x-mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// +x, -y -------------------------------------------------------------------
			x = m_orig.x+i;
			y = m_orig.y-j;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// flip xy in mp_RotPix
			for (int k=0; k<m_numRotPix; k++)
			{
				iTemp = mp_RotPix[k].x;
				mp_RotPix[k].x = mp_RotPix[k].y;
				mp_RotPix[k].y = iTemp;
			}

			// +x, +y -------------------------------------------------------------------
			x = m_orig.x+j;
			y = m_orig.y+i;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// -x, +y -------------------------------------------------------------------
			x = m_orig.x-j;
			y = m_orig.y+i;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x-mp_RotPix[filterIndex].x, y+mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex + (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// -x, -y -------------------------------------------------------------------
			x = m_orig.x-j;
			y = m_orig.y-i;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;

				// average pixels
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x-mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) - mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}

			// +x, -y -------------------------------------------------------------------
			x = m_orig.x+j;
			y = m_orig.y-i;
			if ( inBounds(x, y, m_imageW, m_imageH) )
			{
				// average pixels
				mapIndex = x + y*m_imageW;
				mp_blurCache[mapIndex].r = mp_blurCache[mapIndex].g = mp_blurCache[mapIndex].b = mp_blurCache[mapIndex].a = 0.0f;
				totWts = 0.0f;
				for (filterIndex=0; filterIndex<m_numRotPix; filterIndex++)
				{
					// for speed, the filter size is reduced at edges of image
					// rather than extrapolating color values for non-existing pixels
					if ( !inBounds(x+mp_RotPix[filterIndex].x, y-mp_RotPix[filterIndex].y, m_imageW, m_imageH) )
							continue;

					p = (mapIndex - (mp_RotPix[filterIndex].y*m_imageW) + mp_RotPix[filterIndex].x)*3;
					mp_blurCache[mapIndex].r += mapFrom[p]  *WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].g += mapFrom[p+1]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].b += mapFrom[p+2]*WORD2NORMFLT * mp_Filter[filterIndex];
					mp_blurCache[mapIndex].a += alphaFrom[p/3]*WORD2NORMFLT * mp_Filter[filterIndex];
					totWts += mp_Filter[filterIndex];
				}
				mp_blurCache[mapIndex].r /= totWts;
				mp_blurCache[mapIndex].g /= totWts;
				mp_blurCache[mapIndex].b /= totWts;
				mp_blurCache[mapIndex].a /= totWts;
			}
		}
		if ( ( (j%3) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, 40*j+doneSoFar, taskDone) )
			return false;
	}

	if (mapTo)
	{
		int checkInterval(9*m_imageW);
		// blend back to source
		int srcIdx;
		for (mapIndex=0; mapIndex<m_imageSz; mapIndex++)
		{
			if (pCompMap)
				blendPixel(mapIndex, mapFrom, mp_blurCache[mapIndex], (*pCompMap)[mapIndex].brighten, (*pCompMap)[mapIndex].blend, mapTo, alphaFrom, alphaTo);
			else
			{
				srcIdx = mapIndex*3;
				mapTo[srcIdx]   = (USHORT)(mp_blurCache[mapIndex].r * MAX_COL16);
				mapTo[srcIdx+1] = (USHORT)(mp_blurCache[mapIndex].g * MAX_COL16);
				mapTo[srcIdx+2] = (USHORT)(mp_blurCache[mapIndex].b * MAX_COL16);
				if (alphaTo)
					alphaTo[mapIndex] = (USHORT)(mp_blurCache[mapIndex].a * MAX_COL16);
			}
		}
	}
	return true;
}

void BlurRadial::blur(TimeValue t, CompMap *pCompMap, Bitmap *bm, RenderGlobalContext *gc)
{
	// get source bitmap data
	int type;
	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_blurValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
		}
	}

	// get ui parameters
	Interval iValid = FOREVER;
	float fTemp;
	mp_blurMgr->getBlurValue(prmRadialPixRad, t, fTemp, iValid);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_pixRad = (int)( 0.5*floor( max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC) ) );

	mp_blurMgr->getBlurValue(prmRadialTrail, t, fTemp, iValid);
	LimitValue(fTemp, -100.0f, 100.0f); // mjm - 9.30.99
	m_trail = fTemp*PERCENT2DEC;

	mp_blurMgr->getBlurValue(prmRadialAlpha, t, m_affectAlpha, iValid);

	mp_blurMgr->getBlurValue(prmRadialUseNode, t, m_useNode, iValid);

	if (m_useNode)
	{
		mp_blurMgr->getBlurValue(prmRadialNode, 0, m_node, iValid); // not animatable -- use time = 0
		if (!m_node)
			return;
		RenderInfo* ri = bm->GetRenderInfo();
		Interval tmValid = FOREVER;
		Matrix3 nodeTM = m_node->GetObjTMAfterWSM(t, &tmValid);
		iValid &= tmValid;
		Point3 nodeOrigin = nodeTM.GetRow(3);
		m_orig = ri->MapWorldToScreen(nodeOrigin); // TODO: support fields
		// ensure integer values
		round(m_orig);
	}
	else
	{
		int tempInt;
		mp_blurMgr->getBlurValue(prmRadialXOrig, t, tempInt, iValid);
		LimitValue(tempInt, -999999, 999999); // mjm - 9.30.99
		m_orig.x = (float)tempInt;

		mp_blurMgr->getBlurValue(prmRadialYOrig, t, tempInt, iValid);
		LimitValue(tempInt, -999999, 999999); // mjm - 9.30.99
		m_orig.y = (float)tempInt;
	}

	// if old parameter block values are no longer valid
	if ( !(iValid == FOREVER) && !(m_validInterval.InInterval(iValid)) )
		m_blurValid = false;
	m_validInterval = iValid;

	// setup buffers
	if (m_imageSz > m_mapSz)
	{
		if (mp_scratchMap)
			delete[] mp_scratchMap;
		mp_scratchMap = new AColor[m_imageSz];

		if (mp_blurCache)
			delete[] mp_blurCache;
		mp_blurCache = new AColor[m_imageSz];

		m_mapSz = m_imageSz;
	}

	m_blurValid = doBlur(pCompMap, mp_srcMap, mp_srcMap, mp_srcAlpha, (m_affectAlpha) ? mp_srcAlpha : NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurUniform.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurUniform.cpp

	 DESCRIPTION: uniform blur type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "blurUniform.h"
#include "..\blurMgr.h"


BlurUniform::~BlurUniform()
{
	// mp_blurCache delete by ~BlurDirectional
}

void BlurUniform::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmUnifPixRad:
			m_blurValid = false;
		case prmUnifAlpha:
			break;
	}
}

bool BlurUniform::doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo)
{
	// since we're subclassed from BlurDirectional, do a non-rotated directional blur
	m_uPixRad = m_vPixRad = m_pixRad;
	m_uTrail = m_vTrail = 0.0f;
	return BlurDirectional::doBlur(pCompMap, mapFrom, mapTo, alphaFrom, alphaTo);
}

void BlurUniform::blur(TimeValue t, CompMap *pCompMap, Bitmap *bm, RenderGlobalContext *gc)
{
	// get source bitmap data
	int type;
	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_blurValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
		}
	}

	// get ui parameters
	float fTemp;
	mp_blurMgr->getBlurValue(prmUnifPixRad, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_pixRad = (int)( 0.5*floor( max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC) ) );

	mp_blurMgr->getBlurValue(prmUnifAlpha, t, m_affectAlpha, FOREVER);

	// setup buffers
	if (m_imageSz > m_mapSz)
	{
		if (mp_scratchMap)
			delete[] mp_scratchMap;
		mp_scratchMap = new AColor[m_imageSz];

		if (mp_blurCache)
			delete[] mp_blurCache;
		mp_blurCache = new AColor[m_imageSz];

		m_mapSz = m_imageSz;
	}

	m_blurValid = doBlur(pCompMap, mp_srcMap, mp_srcMap, mp_srcAlpha, (m_affectAlpha) ? mp_srcAlpha : NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selBase.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selBase.h

	 DESCRIPTION: base selection type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_SEL_BASE_H_INCLUDED_)
#define _SEL_BASE_H_INCLUDED_

#include "max.h"
#include "..\globals.h"
class BlurMgr;

// ----------------------------------------
// base selection type - class declaration
// ----------------------------------------
class SelBase
{
protected:
	BlurMgr *const mp_blurMgr;
	WORD *mp_srcMap, *mp_srcAlpha;
	float *mp_radMap;
	float m_min, m_max, m_brighten, m_blend;
	int m_feathRad;
	int m_mapSz, m_imageSz, m_imageW, m_imageH;
	bool m_selectValid, m_featherValid;
	bool m_compValid;
	const TCHAR *mp_nameCurProcess;
	DWORD m_lastBMModifyID;
	float *m_normRadMask;
	int m_normRadMaskW, m_normRadMaskH;

	virtual float calcBrighten(const float &normRadius) { return m_brighten * (1.0f - normRadius); }
	virtual float calcBlend(const float &normRadius) { return m_blend * (1.0f - normRadius); }
	virtual bool doSelect() { return false; }
	virtual bool doFeather() { return false; }
	virtual bool doComposite(CompMap &compMap) { return false; }

public:
	SelBase() :
		mp_blurMgr(NULL), mp_srcMap(NULL), mp_srcAlpha(NULL), mp_radMap(NULL), m_mapSz(0),
		m_imageSz(0), m_imageW(0), m_imageH(0), m_selectValid(false), m_featherValid(false), m_compValid(false),
		mp_nameCurProcess(NULL), m_lastBMModifyID(0xFFFFFFFF), m_normRadMask(NULL), m_normRadMaskW(0), m_normRadMaskH(0) { }

	SelBase(BlurMgr *const mgr) :
		mp_blurMgr(mgr), mp_srcMap(NULL), mp_srcAlpha(NULL), mp_radMap(NULL), m_mapSz(0),
		m_imageSz(0), m_imageW(0), m_imageH(0), m_selectValid(false), m_featherValid(false), m_compValid(false),
		mp_nameCurProcess(NULL), m_lastBMModifyID(0xFFFFFFFF), m_normRadMask(NULL), m_normRadMaskW(0), m_normRadMaskH(0) { }

	virtual ~SelBase() { }
	virtual void notifyPrmChanged(int prmID) { }
	bool checkValid(DWORD bmID) { return (m_selectValid && m_featherValid && m_compValid && (m_lastBMModifyID == bmID)); }
	virtual float getBrighten(TimeValue t) { return m_brighten; }
	virtual float getBlend(TimeValue t) { return m_blend; }
	virtual void select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc) { }
};

#endif // !defined(_SEL_BASE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_blurTypes\blurUniform.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: blurUniform.h

	 DESCRIPTION: uniform blur type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_BLUR_UNIFORM_H_INCLUDED_)
#define _BLUR_UNIFORM_H_INCLUDED_

#include "blurDirectional.h"

class BlurUniform : public BlurDirectional
{
protected:
	int m_pixRad;

	virtual bool doBlur(CompMap *pCompMap, WORD *mapFrom, WORD *mapTo, WORD *alphaFrom, WORD *alphaTo);

public:
	BlurUniform() : BlurDirectional() { }
	BlurUniform(BlurMgr *const mgr) : BlurDirectional(mgr) { }
	~BlurUniform();
	virtual void notifyPrmChanged(int prmID);
	virtual void blur(TimeValue t, CompMap *compositeMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_BLUR_UNIFORM_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selIgnBack.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selIgnBack.h

	 DESCRIPTION: ignore background selection type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_SEL_IGN_BACK_H_INCLUDED_)
#define _SEL_IGN_BACK_H_INCLUDED_

#include "SelLum.h"

class SelIgnBack : public SelLum
{
protected:
	virtual bool doSelect();

public:
	SelIgnBack() { }
	SelIgnBack(BlurMgr *const mgr) : SelLum(mgr) { }
	~SelIgnBack();
	virtual void notifyPrmChanged(int prmID);
	virtual void select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_SEL_IGN_BACK_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\scTex.cpp ===
/**********************************************************************
 *<
	FILE: sctex.cpp

	DESCRIPTION: A ShadeContext for rendering texture maps

	CREATED BY: Rolf Berteig (took code from mtlrend.cpp

	HISTORY: 2/02/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

// precompiled header
#include "pch.h"

// local includes
#include "sctex.h"


SCTex::SCTex() {
	tiling = 1.0f;
	mtlNum = 0; 
	doMaps = TRUE;
	filterMaps = TRUE;
	shadow = FALSE;
	backFace = FALSE;
	curTime = 0;
	norm = Point3(0,0,1);
	view = Point3(0,0,-1);
	ResetOutput();
	}

Box3 SCTex::ObjectBox() {
	return Box3(Point3(0,0,0),Point3(scale,scale,scale));
	}

Point3 SCTex::PObjRelBox() {
	Point3 q;
	Point3 p = PObj();
	Box3 b = ObjectBox();
	q.x = 2.0f*(p.x-b.pmin.x)/(b.pmax.x-b.pmin.x) - 1.0f;
	q.y = 2.0f*(p.y-b.pmin.y)/(b.pmax.y-b.pmin.y) - 1.0f;
	q.z = 2.0f*(p.z-b.pmin.z)/(b.pmax.z-b.pmin.z) - 1.0f;
	return q;
	}

void SCTex::ScreenUV(Point2& uv, Point2 &duv) {
	uv.x = uvw.x;
	uv.y = uvw.x;
	duv.x = duvw.x;
	duv.y = duvw.y;
	}

/*
Point3 SCTex::V() { 
	Point3 v;
	v.x = -2.0f*(uvw.x-0.5f);
	v.z = 2.0f*(uvw.y-0.5f);
	v.y = -0.5f;
	return Normalize(v);
	}       	
*/

Point3 SCTex::DPObjRelBox() {
	return Point3(0,0,0);
	}

void SCTex::DPdUVW(Point3 dP[3],int chan) { 
	dP[0] = dP[1] = dP[2] = Point3(0,0,0);
	}

Point3 SCTex::P() { 
	return pt; 
	}

Point3 SCTex::DP() { 
	return dpt; 
	}

Point3 SCTex::PObj() { 
	return pt; 
	}

Point3 SCTex::DPObj() { 
	return dpt; 
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selIgnBack.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selIgnBack.cpp

	 DESCRIPTION: ignore background selection type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "selIgnBack.h"
#include "..\blurMgr.h"

SelIgnBack::~SelIgnBack()
{
	// mp_radMap delete by ~SelLum()
}

void SelIgnBack::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmIBackFeathRad:
		{
			for (int i=0; i<m_imageSz; i++)
			{
				if ( mp_radMap[i] > 0.0f )
					mp_radMap[i] = 1.0f;
			}
			m_featherValid = m_compValid = false;
			break;
		}
		case prmIBackBrighten:
		case prmIBackBlend:
			m_compValid = false;
			break;
	}
}

bool SelIgnBack::doSelect()
{
	mp_nameCurProcess = GetString(IDS_PROCESS_SELECT);
	int interval = 3*m_imageW;
	for (int mapIndex=0; mapIndex<m_imageSz; mapIndex++)
	{
		if ( mp_srcAlpha[mapIndex] )
			mp_radMap[mapIndex] = 0.0f;
		else
			mp_radMap[mapIndex] = 1.0f;
		if ( ( (mapIndex%interval) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, mapIndex, m_imageSz) )
			return false;
	}
	return true;
}

void SelIgnBack::select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc)
{
	float fTemp;
	int type;

	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_selectValid = m_featherValid = m_compValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
			if (m_imageSz > m_mapSz)
			{
				if (mp_radMap)
					delete[] mp_radMap;
				mp_radMap = new float[m_imageSz];
				m_mapSz = m_imageSz;
			}
		}
	}

	if (!m_selectValid)
	{
		m_selectValid = doSelect();
	}
	
	if (!m_featherValid)
	{
		mp_blurMgr->getSelValue(prmIBackFeathRad, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
		m_feathRad = (int)floor(max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC));
		m_featherValid = doFeather();
	}

	mp_blurMgr->getSelValue(prmIBackBrighten, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_brighten = fTemp*PERCENT2DEC;

	mp_blurMgr->getSelValue(prmIBackBlend, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
	m_blend = fTemp*PERCENT2DEC;

	m_compValid = doComposite(compMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\scTex.h ===
/**********************************************************************
 *<
	FILE: sctex.h

	DESCRIPTION: A ShadeContext for rendering texture maps

	CREATED BY: Rolf Berteig (took code from mtlrend.cpp

	HISTORY: 2/02/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __SCTEXT_H__
#define __SCTEXT_H__

#include <max.h>

class LightDescImp: public LightDesc {
	public:
	Point3 pos;
	Color col;
    BOOL Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl) {
		dir = Normalize(pos-sc.P());
		dot_nl = DotProd(normal,dir);
		color = col;
		return 1;		
		}
	};
class SCTex: public ShadeContext {
	public:
	float tiling;
	float scale;
	Color ambientLight;
	LightDescImp* lights[2];
	Point3 uvw,duvw,norm,view,pt,dpt;
	IPoint2 scrPos;
	TimeValue curTime;
	Renderer *GetRenderer() { return NULL; }
	BOOL 	  InMtlEditor() { return TRUE; }
	LightDesc* Light(int n) { return lights[n]; }
	int ProjType() { return 1;} // returns: 0: perspective, 1: parallel
	int FaceNumber() { return 0; }
	TimeValue CurTime() { return curTime; }
	Point3 Normal() { return norm; }  	// interpolated normal
	void SetNormal(Point3 p) { norm = p;} 	// for perturbing normal
	Point3 GNormal() { return norm;} 	// geometric (face) normal
	Point3 ReflectVector() { return Point3(0,0,1); }
	Point3 RefractVector(float ior) {return Point3(0,0,1);	}
    Point3 CamPos() { return Point3(0,0,0); }			// camera position
//	Point3 V();
	Point3 V() { return view; }       	// Unit view vector: from camera towards P 
	void SetView(Point3 v) { view =v; }
	Point3 P();			// point to be shaded in camera space;
	Point3 DP();   		// deriv of P, relative to pixel, for AA
	Point3 PObj();					  	// point in obj coords
	Point3 DPObj();   	// deriv of PObj, rel to pixel, for AA
	Box3 ObjectBox(); 	 			 	// Object extents box in obj coords
	Point3 PObjRelBox();   				// Point rel to obj box [-1 .. +1 ] 
	Point3 DPObjRelBox();  				// Point rel to obj box [-1 .. +1 ] 
	Point3 UVW(int chan) { return uvw;	};
   	Point3 DUVW(int chan) {	return duvw;	}
	void DPdUVW(Point3 dP[3],int chan); 			// Bump vectors for UVW: in Camera space
	AColor EvalEnvironMap(Texmap *map, Point3 viewd) {
		AColor rcol;
        rcol.Black();
		return rcol;
		}

	void ScreenUV(Point2& uv, Point2 &duv); // screen coordinate
	IPoint2 SCTex::ScreenCoord() {return scrPos;}

	Point3 PointTo(const Point3& p, RefFrame ito) { return p; }
	Point3 PointFrom(const Point3& p, RefFrame ifrom) { return p; } 
	Point3 VectorTo(const Point3& p, RefFrame ito) { return p; } 
	Point3 VectorFrom(const Point3& p, RefFrame ifrom){ return p; } 
	void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE) {	}
	SCTex();
	void SetTiling(float t) { tiling = t; }
	};

// Allocates and renders a 3 byte per pixel image
UBYTE *RenderTexMap(Texmap *tex,int w, int h);

#endif //__SCTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selImage.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selImage.h

	 DESCRIPTION: whole image selection type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_SEL_IMAGE_H_INCLUDED_)
#define _SEL_IMAGE_H_INCLUDED_

#include "selBase.h"

class SelImage : public SelBase
{
protected:
	void updateParams();

public:
	SelImage() { }
	SelImage(BlurMgr *const mgr) : SelBase(mgr) { }
	~SelImage() { }
	virtual void notifyPrmChanged(int prmID) { }
	virtual float getBrighten(TimeValue t);
	virtual float getBlend(TimeValue t);
};

#endif // !defined(_SEL_IMAGE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selImage.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selImage.cpp

	 DESCRIPTION: whole image selection type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "selImage.h"
#include "..\blurMgr.h"

float SelImage::getBrighten(TimeValue t)
{
	float fTemp;
	mp_blurMgr->getSelValue(prmImageBrighten, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_brighten = fTemp*PERCENT2DEC;

	return m_brighten;
};

float SelImage::getBlend(TimeValue t)
{
	float fTemp;
	mp_blurMgr->getSelValue(prmImageBlend, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
	m_blend = fTemp*PERCENT2DEC;

	return m_blend;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selLum.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selLum.h

	 DESCRIPTION: luminance selection type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_SEL_LUM_H_INCLUDED_)
#define _SEL_LUM_H_INCLUDED_

#include "selBase.h"

class SelLum : public SelBase
{
protected:
	virtual bool doSelect();
	virtual bool doFeather();
	virtual bool doComposite(CompMap &compMap);

public:
	SelLum() { }
	SelLum(BlurMgr *const mgr) : SelBase(mgr) { }
	~SelLum();
	virtual void notifyPrmChanged(int prmID);
	virtual void select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_SEL_LUM_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selMaps.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selMaps.h

	 DESCRIPTION: maps selection type -  class declaration

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#if !defined(_SEL_MAPS_H_INCLUDED_)
#define _SEL_MAPS_H_INCLUDED_

#include "SelLum.h"
#include "scTex.h"

class SelMaps : public SelLum
{
enum { red, green, blue, alpha, luminance };

protected:
	SCTex m_shadeContext;
	Texmap *m_brightenMap;
	int m_channel;

	bool testPixel(int index);
	virtual bool doSelect();

public:
	SelMaps() : m_brightenMap(NULL) { }
	SelMaps(BlurMgr *const mgr) : m_brightenMap(NULL), SelLum(mgr) { }
	~SelMaps();
	virtual void notifyPrmChanged(int prmID);
	virtual void select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc);
};

#endif // !defined(_SEL_MAPS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selMaps.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selMaps.cpp

	 DESCRIPTION: maps selection type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "selMaps.h"
#include "..\blurMgr.h"

SelMaps::~SelMaps()
{
	// mp_radMap delete by ~SelLum()
}

void SelMaps::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmMaskMap:
		case prmMaskChannel:
		case prmMaskMin:
		case prmMaskMax:
			m_selectValid = m_featherValid = m_compValid = false;
			break;
		case prmMaskFeathRad:
		{
			for (int i=0; i<m_imageSz; i++)
			{
				if ( mp_radMap[i] > 0.0f )
					mp_radMap[i] = 1.0f;
			}
			m_featherValid = m_compValid = false;
			break;
		}
		case prmMaskBrighten:
		case prmMaskBlend:
			m_compValid = false;
			break;
	}
}

bool SelMaps::testPixel(int index)
{
	int x = index % m_imageW;
	int y = index / m_imageH;

	m_shadeContext.uvw.x = (x+0.5f) * m_shadeContext.duvw.x;
	m_shadeContext.uvw.y = (m_imageH-y-0.5f) * m_shadeContext.duvw.y;
	m_shadeContext.pt = m_shadeContext.uvw;
	m_shadeContext.scrPos.x = x;
	m_shadeContext.scrPos.y = y;

	AColor c = m_brightenMap->EvalColor(m_shadeContext);

	float val;
	switch (m_channel)
	{
	case red:
		val = c.r;
		break;
	case green:
		val = c.g;
		break;
	case blue:
		val = c.b;
		break;
	case alpha:
		val = c.a;
		break;
	case luminance:
		val = luminanceNormFloat(c.r, c.g, c.b);
		break; 
	}
	if ( val > m_min && val <= m_max )
		return true;
	else
		return false;
}

bool SelMaps::doSelect()
{
	mp_nameCurProcess = GetString(IDS_PROCESS_SELECT);
	int interval = 3*m_imageW;
	for (int mapIndex=0; mapIndex<m_imageSz; mapIndex++)
	{
		mp_radMap[mapIndex] = ( testPixel(mapIndex) ) ? 0.0f : 1.0f;
		if ( ( (mapIndex%interval) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, mapIndex, m_imageSz) )
			return false;
	}

	return true;
}

void SelMaps::select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc)
{
	int type;

	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);
	m_shadeContext.globContext = gc;

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_selectValid = m_featherValid = m_compValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
			if (m_imageSz > m_mapSz)
			{
				if (mp_radMap)
					delete[] mp_radMap;
				mp_radMap = new float[m_imageSz];
				m_mapSz = m_imageSz;
			}
		}
	}

	float fTemp;
	if (!m_selectValid)
	{
		m_brightenMap = NULL;
		mp_blurMgr->getSelValue(prmMaskMap, 0, m_brightenMap, FOREVER);
		if (!m_brightenMap)
			return;
		m_shadeContext.scale = 1.0f;
		m_shadeContext.duvw  = Point3(1.0f/float(m_imageW), 1.0f/float(m_imageH), 0.0f);
		m_shadeContext.uvw.z = 0.0f;
		m_shadeContext.filterMaps = TRUE;
		m_brightenMap->Update(t, Interval());
		m_brightenMap->LoadMapFiles(t);

		mp_blurMgr->getSelValue(prmMaskChannel, t, m_channel, FOREVER);
		mp_blurMgr->getSelValue(prmMaskMin, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
		m_min = fTemp*PERCENT2DEC;

		mp_blurMgr->getSelValue(prmMaskMax, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
		m_max = fTemp*PERCENT2DEC;

		m_selectValid = doSelect();
	}

	if (!m_featherValid)
	{
		mp_blurMgr->getSelValue(prmMaskFeathRad, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
		m_feathRad = (int)floor(max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC));
		m_featherValid = doFeather();
	}

	mp_blurMgr->getSelValue(prmMaskBrighten, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_brighten = fTemp*PERCENT2DEC;

	mp_blurMgr->getSelValue(prmMaskBlend, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
	m_blend = fTemp*PERCENT2DEC;

	m_compValid = doComposite(compMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\Blur\_selectTypes\selLum.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: selLum.cpp

	 DESCRIPTION: luminance selection type - class definitions

	 CREATED BY: michael malone (mjm)

	 HISTORY: created November 4, 1998

	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// precompiled header
#include "pch.h"

// local includes
#include "selLum.h"
#include "..\blurMgr.h"


SelLum::~SelLum()
{
	if (mp_radMap)
		delete[] mp_radMap;
}

void SelLum::notifyPrmChanged(int prmID)
{
	switch (prmID)
	{
		case prmLumMin:
		case prmLumMax:
			m_selectValid = m_featherValid = m_compValid = false;
			break;
		case prmLumFeathRad:
		{
			for (int i=0; i<m_imageSz; i++)
			{
				if ( mp_radMap[i] > 0.0f )
					mp_radMap[i] = 1.0f;
			}
			m_featherValid = m_compValid = false;
			break;
		}
		case prmLumBrighten:
		case prmLumBlend:
			m_compValid = false;
			break;
	}
}

bool SelLum::doSelect()
{
	float lum;
	int mapIndex, srcIndex;
	mp_nameCurProcess = GetString(IDS_PROCESS_SELECT);

	int interval = 3*m_imageW;
	for (mapIndex=0; mapIndex<m_imageSz; mapIndex++)
	{
		srcIndex = mapIndex*3;
		lum = luminanceNormFloat(mp_srcMap[srcIndex], mp_srcMap[srcIndex+1], mp_srcMap[srcIndex+2]); // grabs specular hilights better than max(r,g,b)
		if ((lum >= m_min) && (lum <= m_max))
			mp_radMap[mapIndex] = 0.0f;
		else
			mp_radMap[mapIndex] = 1.0f;
		if ( ( (mapIndex%interval) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, mapIndex, m_imageSz) )
			return false;
	}
	return true;
}

bool SelLum::doFeather()
{
	mp_nameCurProcess = GetString(IDS_PROCESS_FEATHER);

	// NOTE: there is _alot_ of room for optimization in this function

	// compute normalized radii mask for feathered pixels
	if (m_normRadMaskW != 2*m_feathRad + 1) {
		if (m_normRadMask)
			delete[] m_normRadMask;
		m_normRadMaskW = m_normRadMaskH = 2*m_feathRad + 1;
		m_normRadMask = new float[m_normRadMaskW*m_normRadMaskH];
		int index = -1;
		float x_dist, y_dist;
		for (int i=0; i<m_normRadMaskW; i++) {
			for (int j=0; j<m_normRadMaskH; j++) {
				x_dist = (float)i-m_feathRad;
				y_dist = (float)j-m_feathRad;
				m_normRadMask[++index] = (float)(sqrt(sqr(x_dist)+sqr(y_dist)) / (float)m_feathRad);
				m_normRadMask[index] = (m_normRadMask[index] > 1.0f) ? 1.0f : m_normRadMask[index];
			}
		}
	}

	// find feathered pixels
	int index, normRadIdx;
	int interval = 3*m_imageW;
	for (int mapIndex=0; mapIndex<m_imageSz; mapIndex++)
	{
		if (mp_radMap[mapIndex] == 0.0f) // a selected pixel
		{
			int y = mapIndex / m_imageW;
			int x = mapIndex % m_imageW;

			// skip pixel if surrounded by other selected pixels
			// lots of opportunity to optimize, but no time
			if (
				 ( ( x>0 )			&& (mp_radMap[mapIndex-1] == 0.0f) ) &&
				 ( ( x<m_imageW-1 ) && (mp_radMap[mapIndex+1] == 0.0f) ) &&
				 ( ( y>0 )			&& (mp_radMap[mapIndex-m_imageW] == 0.0f) ) &&
				 ( ( y<m_imageH-1 ) && (mp_radMap[mapIndex+m_imageW] == 0.0f) )
			   )
			   continue;
			
			// set offset and weight of the feathered pixels
			for (int v=-m_feathRad; v<=m_feathRad; v++)
			{
				for (int u=-m_feathRad; u<=m_feathRad; u++)
				{
					if ( !inBounds(x+u, y+v, m_imageW, m_imageH) )
						continue;

					// compute offsets
					index = (mapIndex + v*m_imageW + u);
					if (mp_radMap[index] != 0.0f)
					{
						normRadIdx = (u+m_feathRad) + (v+m_feathRad)*m_normRadMaskW;
						mp_radMap[index] = min(mp_radMap[index], m_normRadMask[normRadIdx]);
					}
				}
			}
		}
		if ( ( (mapIndex%interval) == 0 ) && mp_blurMgr->progress(mp_nameCurProcess, mapIndex, m_imageSz) )
			return false;
	}
	return true;
}

bool SelLum::doComposite(CompMap &compMap)
{
	// should hook up a curve control here for falloffs
	for (int mapIndex=0; mapIndex<m_imageSz; mapIndex++)
	{
		if ( mp_radMap[mapIndex] < 1.0f )
		{
			compMap[mapIndex].brighten = max( compMap[mapIndex].brighten, calcBrighten(mp_radMap[mapIndex]) );
			compMap[mapIndex].blend = max( compMap[mapIndex].blend, calcBlend(mp_radMap[mapIndex]) );
		}
	}
	return true;
}

void SelLum::select(TimeValue t, CompMap &compMap, Bitmap *bm, RenderGlobalContext *gc)
{
	float fTemp;
	int type;

	mp_srcAlpha = (WORD*)bm->GetAlphaPtr(&type);
	mp_srcMap = (WORD*)bm->GetStoragePtr(&type);
	assert(type == BMM_TRUE_48);

	// if source bitmap has changed since last call
	if ( m_lastBMModifyID != bm->GetModifyID() )
	{
		m_lastBMModifyID = bm->GetModifyID();
		m_selectValid = m_featherValid = m_compValid = false;
		if ( (bm->Width() != m_imageW) || (bm->Height() != m_imageH) )
		{
			m_imageW = bm->Width();
			m_imageH = bm->Height();
			m_imageSz = m_imageW * m_imageH;
			if (m_imageSz > m_mapSz)
			{
				if (mp_radMap)
					delete[] mp_radMap;
				mp_radMap = new float[m_imageSz];
				m_mapSz = m_imageSz;
			}
		}
	}

	if (!m_selectValid)
	{
		mp_blurMgr->getSelValue(prmLumMin, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
		m_min = fTemp*PERCENT2DEC;

		mp_blurMgr->getSelValue(prmLumMax, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
		m_max = fTemp*PERCENT2DEC;

		m_selectValid = doSelect();
	}
	
	if (!m_featherValid)
	{
		mp_blurMgr->getSelValue(prmLumFeathRad, t, fTemp, FOREVER);
		LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
		m_feathRad = (int)floor(max(m_imageW, m_imageH)*(fTemp*PERCENT2DEC));
		m_featherValid = SelLum::doFeather();
	}

	mp_blurMgr->getSelValue(prmLumBrighten, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 1000.0f); // mjm - 9.30.99
	m_brighten = fTemp*PERCENT2DEC;

	mp_blurMgr->getSelValue(prmLumBlend, t, fTemp, FOREVER);
	LimitValue(fTemp, 0.0f, 100.0f); // mjm - 9.30.99
	m_blend = fTemp*PERCENT2DEC;

	m_compValid = SelLum::doComposite(compMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\BrightCon\dllMain.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.h

	 DESCRIPTION: DLL entry header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created January 27, 1999

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#ifndef __DLL_MAIN__H
#define __DLL_MAIN__H


#include "resource.h"
#include "max.h"

extern HINSTANCE hInstance;

TCHAR *GetString(int id);
extern ClassDesc* GetBriteConDesc();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\BrightCon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by brightCon.rc
//
#define IDD_BRITECON_EFFECT             111
#define IDC_BRIGHTNESS                  1702
#define IDC_BRIGHTNESS_SPIN             1703
#define IDC_CONTRAST                    1704
#define IDC_CONTRAST_SPIN               1705
#define IDC_IGN_BACKGROUND              1706
#define IDS_LIBDESCRIPTION              30501
#define IDS_PARAMS                      30502
#define IDS_NAME                        30503
#define IDS_CLASS_NAME                  30504
#define IDS_CDESC_CLASS_NAME            30505
#define IDS_BRIGHTNESS                  30511
#define IDS_CONTRAST                    30512
#define IDS_IGN_BACK                    30513
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1707
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\BrightCon\dllMain.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.cpp

	 DESCRIPTION: DLL entry implementation

	 CREATED BY: michael malone (mjm)

	 HISTORY: created January 27, 1999

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#include "dllMain.h"


// global variables
HINSTANCE hInstance;

// global functions
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved)
{
	// remember this dll's instance handle
	hInstance = hinstDLL;

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// initialize max controls
		InitCustomControls(hInstance);
		// initialize microsoft controls
		InitCommonControls();
		break;
	}
	return (TRUE);
}


//------------------------------------------------------
// interface to Max
//------------------------------------------------------

// returns dll descriptive string
__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}


// returns number of classes in dll
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


// returns appropriate class descriptor
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i)
	{
	case 0:
		return GetBriteConDesc();
	default:
		return 0;
	}
}


// returns version to detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}


// standard hInstance dependent GetString()
TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\ColorBalance\dllMain.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.h

	 DESCRIPTION: DLL entry header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 2, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#ifndef __DLL_MAIN__H
#define __DLL_MAIN__H


#include "resource.h"
#include "max.h"

extern HINSTANCE hInstance;

TCHAR *GetString(int id);
extern ClassDesc* GetColBalDesc();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\BrightCon\brightCon.cpp ===
/**********************************************************************
 *<
	FILE: briteCon.cpp	

	DESCRIPTION: Simple Brightness & Contrast Post Effect

	CREATED BY: Kells Elmquist

	HISTORY: 7/9/98
	         1.5.99 mjm - update to paramblock2 and add ignore background option

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "dllMain.h"
#include <iparamm2.h>
#include <bmmlib.h>

// prototype for gain & brightness functions
typedef	float (*BriteConFn)( float value, float param );

// proposed functions for brightness & gain
float pivotGain( float val, float param );
float dcGain( float val, float param );

float perlinContrast( float val, float param );
float perlinGainPrim( float val, float param );
float perlinBrightness( float val, float param );
float perlinBiasPrim( float val, float param );
float keBrightness( float val, float param );

float schickContrast( float val, float param );
float schickBrightness( float val, float param );
float schickGainPrim( float val, float param );
float schickBiasPrim( float val, float param );

#define BRITECON_CLASS_ID 0x76912330 // dans * 16
Class_ID BriteConClassID(BRITECON_CLASS_ID,0);

// IDs to references
#define PBLOCK_REF 0

// parameter blocks IDs
enum { briteCon_params };

// parameters for colBal_params
enum { prm_brightness,
       prm_contrast,
	   prm_iBack };


// Brightness & contrast effect
class BriteConEffect: public Effect {
	public:
		IParamBlock2* pblock;
		
		BriteConEffect();
		~BriteConEffect() { }

		// Animatable/Reference
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) { return GetReference(i); }
		TSTR SubAnimName(int i);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		Class_ID ClassID() { return BriteConClassID; }
		void GetClassName(TSTR& s) { s = GetString(IDS_CLASS_NAME); }
		void DeleteThis() { delete this; }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);
		int	NumParamBlocks() { return 1; }
		IParamBlock2* GetParamBlock(int i) { return pblock; } // only one
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }
		IOResult Load(ILoad *iload);

		// Effect methods
		TSTR GetName() { return GetString(IDS_NAME); }
		EffectParamDlg *CreateParamDialog( IRendParams *pParams );
		DWORD GBufferChannelsRequired(TimeValue t) { return BMM_CHAN_NONE; }
		void Apply( TimeValue t, Bitmap *pBM, RenderGlobalContext *pGC, CheckAbortCallback *checkAbort);
	};


// Class Descriptor
class BriteConClassDesc : public ClassDesc2
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new BriteConEffect; }
	const TCHAR *	ClassName() { return GetString(IDS_CDESC_CLASS_NAME); }
	SClass_ID		SuperClassID() { return RENDER_EFFECT_CLASS_ID; }
	Class_ID 		ClassID() { return BriteConClassID; }
	const TCHAR* 	Category() { return _T(""); }
	const TCHAR*	InternalName() { return _T("briteCon"); } // hard-coded for scripter
	HINSTANCE		HInstance() { return hInstance; }
};

static BriteConClassDesc briteConCD;
ClassDesc* GetBriteConDesc() {return &briteConCD;}


// Parameter Description
static ParamBlockDesc2 briteCon_param_blk(briteCon_params, _T("briteCon parameters"), 0, &briteConCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF,
	//rollout
	IDD_BRITECON_EFFECT, IDS_PARAMS, 0, 0, NULL,
	// params
	prm_brightness, _T("brightness"), TYPE_FLOAT, P_ANIMATABLE, IDS_BRIGHTNESS,
		p_default, 0.5f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDC_BRIGHTNESS, IDC_BRIGHTNESS_SPIN, SPIN_AUTOSCALE,
		p_range, 0.0f, 1.0f,
		end,
	prm_contrast, _T("contrast"), TYPE_FLOAT, P_ANIMATABLE, IDS_CONTRAST,
		p_default, 0.5f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CONTRAST, IDC_CONTRAST_SPIN, SPIN_AUTOSCALE,
		p_range, 0.0f, 1.0f,
		end,
	prm_iBack, _T("ignoreBack"), TYPE_BOOL, P_ANIMATABLE, IDS_IGN_BACK,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_IGN_BACKGROUND,
		end,
	end
	);

///////////////////////////////
//
// Brightness & Contrast Effect
//
//
BriteConEffect::BriteConEffect()
{
	briteConCD.MakeAutoParamBlocks(this);
	assert(pblock);
}

IOResult BriteConEffect::Load(ILoad *iload)
{
	Effect::Load(iload);
	return IO_OK;
}

EffectParamDlg *BriteConEffect::CreateParamDialog(IRendParams *ip)
{	
	return briteConCD.CreateParamDialogs(ip, this);
}

TSTR BriteConEffect::SubAnimName(int i) 
{
	switch (i)
	{
	case 0:
		return GetString(IDS_PARAMS);
	default:
		return _T("");
	}
}

RefTargetHandle BriteConEffect::GetReference(int i)
{
	switch (i)
	{
	case 0:
		return pblock;
	default:
		return NULL;
	}
}

void BriteConEffect::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i)
	{
	case 0:
		pblock = (IParamBlock2*)rtarg; break;
	}
}

RefResult BriteConEffect::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
{
	switch (message)
	{
	case REFMSG_CHANGE:
		briteCon_param_blk.InvalidateUI( pblock->LastNotifyParamID() );
		break;
	}
	return REF_SUCCEED;
}

////////////////////////////////////////////
//
// Apply the brightness & contrast functions
//	
#define	BCTAB_SHIFT	4 // 16 bits into 12		
#define	BCTAB_SZ	4096		
#define MAX_COLf	65535.0f

// The current brightness & contrast functions
static BriteConFn pContrastFn = perlinContrast;
static BriteConFn pBrightnessFn = keBrightness;

void BriteConEffect::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc,CheckAbortCallback *checkAbort)
{
	long w = bm->Width();
	long h = bm->Height();

	float brightness;
	float contrast;
	BOOL iBack;
	pblock->GetValue(prm_brightness, t, brightness, FOREVER);
	pblock->GetValue(prm_contrast, t, contrast, FOREVER);
	pblock->GetValue(prm_iBack, t, iBack, FOREVER);

	// build contrast table
	unsigned short contrastTable[ BCTAB_SZ ];
	float vInc = 1.0f / float(BCTAB_SZ);
	float v = 0.5f * vInc;	// center of the first bin
	for ( long i = 0; i < BCTAB_SZ; ++i, v += vInc ) {

		// apply contrast then brightness to the result
		float f = (*pContrastFn)( v, contrast );
		f = (*pBrightnessFn)( f, brightness );
		if ( f > 1.0f )
			f = 1.0f;
		else if ( f < 0.0 )
			f = 0.0f;
		contrastTable[i] = unsigned short(f * MAX_COLf + 0.5f);
	}

	// modify current frame buffer, into itself
	float alpha;
	BMM_Color_64 tempCol;
	PixelBuf lineBuf(w);
	BMM_Color_64 *pPix = lineBuf.Ptr();
	// for each line
	for (long y = 0; y < h; y++) {
		bm->GetPixels(0, y, w, pPix);
		// for each pixel
		for ( long x = 0; x < w; ++x ){
			// if ignoring background ...
			if ( iBack )
			{
				// skip transparent pixel
				if (pPix[x].a == 0)
					continue;

				// otherwise, blend on alpha value
				alpha = pPix[x].a / MAX_COLf;
				tempCol.r = contrastTable[ pPix[x].r >> BCTAB_SHIFT ];
				tempCol.g = contrastTable[ pPix[x].g >> BCTAB_SHIFT ];
				tempCol.b = contrastTable[ pPix[x].b >> BCTAB_SHIFT ];

				pPix[x].r = (USHORT)(tempCol.r*alpha + pPix[x].r*(1.0f-alpha));
				pPix[x].g = (USHORT)(tempCol.g*alpha + pPix[x].g*(1.0f-alpha));
				pPix[x].b = (USHORT)(tempCol.b*alpha + pPix[x].b*(1.0f-alpha));
			}
			else
			{
				pPix[x].r = contrastTable[ pPix[x].r >> BCTAB_SHIFT ];
				pPix[x].g = contrastTable[ pPix[x].g >> BCTAB_SHIFT ];
				pPix[x].b = contrastTable[ pPix[x].b >> BCTAB_SHIFT ];
			}
		}
		bm->PutPixels(0, y, w, pPix);
		if (((y&3)==0)&&checkAbort&&checkAbort->Progress(y,h)) 
			return;
	}
}

//////////////////////////////////////////////////////////////
//
//	The brightness & contrast functions
//	
//	These are all defined only over the val range 0..1 
//  & the parameter range 0..1
//	they shd return values in the same range, tho checking is not required
//
//	if your function needs a value in range, clamp it
//

// this probably wants to be centered at the perceptual midpoint
// this looked best in my first tests
static float pivot = 0.35f;

// linear gain about the pivot point
// map contrast 0 to gain 0.25, contrast .5 to gain 1, & contrast 1 to gain 1.7
float pivotGain( float val, float param )
{
	float gain = param <= 0.5f ? param * 1.5f + 0.25f : (param - 0.5f) * 1.4f + 1.0f;
	return (val - pivot) * gain + pivot;
}

// dc gain for brightness
// 0.5 to gain of 0, 0 to gain of -.3, 1 to gain of +.3
float dcGain( float val, float param )
{
	return (val + (param - 0.5f) * 0.6f);
}

// perlin gain as contrast fn
// map 0.5 -> 0.5; 0.0 ->.25; 1.0 -> .75
float perlinContrast( float val, float param )
{
	float gain = ( 1.0f - param) * 0.5f + 0.25f;
	return perlinGainPrim( val, gain );
}

// perlin gain
float perlinGainPrim( float val, float param )
{
	if ( val < 0.5f )
		return 0.5f * perlinBiasPrim( 2.0f * val, param );
	else
		return 1.0f - 0.5f * perlinBiasPrim( 2.0f - 2.0f * val, param );
}

static float hiliteBias = 0.9f;

// my brightness function
float keBrightness( float val, float param )
{
	float hiliteCorr;
	if ( param < 0.5f ) {
		float p = 1.8f * param + 0.1f;
	    hiliteCorr = perlinBiasPrim( p , hiliteBias );
	} else hiliteCorr = 1.0f;

	float bias = param * 0.7f + 0.15f;
	return hiliteCorr * perlinBiasPrim( val, bias );
}

// perlin based brightness fn
float perlinBrightness( float val, float param )
{
	float bias = param * 0.7f + 0.1f;
	return perlinBiasPrim( val, bias );
}

// perlin bias primitive
float perlinBiasPrim( float val, float param )
{
	const double ln2R = -1.0 / log( 2.0 );
	if ( param < 0.0000001f )
		param = 0.0000001f;
	double lnA = log( param );
	return float( pow( double(val), lnA * ln2R ) );
}

// schick gain as contrast fn
// map 0.5 -> 0.5; 0.0 ->.25; 1.0 -> .75
float schickContrast( float val, float param )
{
	float gain = ( 1.0f - param) * 0.5f + 0.25f;
	return schickGainPrim( val, gain );
}

// schick gain
float schickGainPrim( float val, float param )
{
	float p = 1.0f/param - 2.0f;
	float t = 1.0f - 2.0f * val;
	if ( val < 0.5f )
		return ( val / (p * t + 1.0f) );
	else
		return ( (p * t - val)/(p * t - 1.0f) );
}

// perlin based brightness fn
float schickBrightness( float val, float param )
{
	float bias = param * 0.7f + 0.1f;
	return schickBiasPrim( val, bias );
}

// schick bias
float schickBiasPrim( float val, float param )
{
	return ( val/( (1.0f/param - 2.0f) * (1.0f - val) + 1.0f ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\ColorBalance\colorBalance.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: colorBalance.cpp

	 DESCRIPTION: balance RGB levels

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 02, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// local headers
#include "dllMain.h"

// sdk headers
#include <iparamm2.h>
#include <bmmlib.h>

// IDs to references
#define PBLOCK_REF 0

#define MAX_COLf 65535.0f
#define DEF_OFFSET 0

// parameter blocks IDs
enum { colBal_params };

// parameters for colBal_params
enum { prm_r,
       prm_g,
	   prm_b,
	   prm_pLum,
	   prm_iBack };

// global instance
static const Class_ID colBalClassID(0xd481815, 0x786d799c);


// ----------------------------------------
// color balance effect - class declaration
// ----------------------------------------
class ColorBalance: public Effect
{
public:
	// parameters
	IParamBlock2* pblock;

	ColorBalance();
	~ColorBalance() { }

	// Animatable/Reference
	int NumSubs() { return 1; }
	Animatable* SubAnim(int i) { return GetReference(i); }
	TSTR SubAnimName(int i);
	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	Class_ID ClassID() { return colBalClassID; }
	void GetClassName(TSTR& s) { s = GetString(IDS_COL_BAL); }
	void DeleteThis() { delete this; }
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; } // only one
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; }
	IOResult Load(ILoad *iload);

	// Effect
	TSTR GetName() { return GetString(IDS_COL_BAL); }
	EffectParamDlg *CreateParamDialog(IRendParams *ip);
	DWORD GBufferChannelsRequired(TimeValue t) { return BMM_CHAN_NONE; }
	void Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort);
};


// --------------------------------------------------
// color balance class descriptor - class declaration
// --------------------------------------------------
class ColBalClassDesc:public ClassDesc2
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ColorBalance; }
	const TCHAR *	ClassName() { return GetString(IDS_COL_BAL); }
	SClass_ID		SuperClassID() { return RENDER_EFFECT_CLASS_ID; }
	Class_ID 		ClassID() { return colBalClassID; }
	const TCHAR* 	Category() { return _T(""); }
	const TCHAR*	InternalName() { return _T("colorBalance"); } // hard-coded for scripter
	HINSTANCE		HInstance() { return hInstance; }
	};

// global instance
static ColBalClassDesc colBalCD;
// external access function (through colorBalance.h)
ClassDesc* GetColBalDesc() { return &colBalCD; }


// ---------------------------------------------
// parameter block description - global instance
// ---------------------------------------------
static ParamBlockDesc2 colBal_param_blk(colBal_params, _T("colorBalance parameters"), 0, &colBalCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF,
	//rollout
	IDD_COL_BAL_EFFECT, IDS_COL_BAL_PARAMS, 0, 0, NULL,
	// params
	prm_r, _T("red"), TYPE_INT, P_ANIMATABLE, IDS_RED,
		p_default, DEF_OFFSET,
		p_ui, TYPE_SLIDER, EDITTYPE_INT, IDC_RED_EDIT, IDC_RED_SLIDER, 10,
		p_range, -100, 100,
		end,
	prm_g, _T("green"), TYPE_INT, P_ANIMATABLE, IDS_GREEN,
		p_default, DEF_OFFSET,
		p_ui, TYPE_SLIDER, EDITTYPE_INT, IDC_GREEN_EDIT, IDC_GREEN_SLIDER, 10,
		p_range, -100, 100,
		end,
	prm_b, _T("blue"), TYPE_INT, P_ANIMATABLE, IDS_BLUE,
		p_default, DEF_OFFSET,
		p_ui, TYPE_SLIDER, EDITTYPE_INT, IDC_BLUE_EDIT, IDC_BLUE_SLIDER, 10,
		p_range, -100, 100,
		end,
	prm_pLum, _T("preserveLum"), TYPE_BOOL, P_ANIMATABLE, IDS_P_LUM,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_LUMINOSITY,
		end,
	prm_iBack, _T("ignoreBack"), TYPE_BOOL, P_ANIMATABLE, IDS_I_BACK,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_BACKGROUND,
		end,
	end
	);


// -----------------------------------------
// color balance effect - method definitions
// -----------------------------------------
ColorBalance::ColorBalance()
{
	colBalCD.MakeAutoParamBlocks(this);
	assert(pblock);
}

IOResult ColorBalance::Load(ILoad *iload)
{
	Effect::Load(iload);
	return IO_OK;
}

EffectParamDlg *ColorBalance::CreateParamDialog(IRendParams *ip)
{	
	return colBalCD.CreateParamDialogs(ip, this);
}

TSTR ColorBalance::SubAnimName(int i)
{
	switch (i)
	{
	case 0:
		return GetString(IDS_COL_BAL_PARAMS);
	default:
		return _T("");
	}
}

RefTargetHandle ColorBalance::GetReference(int i)
{
	switch (i)
	{
	case 0:
		return pblock;
	default:
		return NULL;
	}
}

void ColorBalance::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i)
	{
	case 0:
		pblock = (IParamBlock2*)rtarg;
		break;
	}
}

RefResult ColorBalance::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
{
	switch (message)
	{
	case REFMSG_CHANGE:
		colBal_param_blk.InvalidateUI( pblock->LastNotifyParamID() );
		break;
	}
	return REF_SUCCEED;
}

void ColorBalance::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort)
{
	int type;
	WORD *pS = (WORD*)bm->GetStoragePtr(&type); // rgb
	assert(type == BMM_TRUE_48);
	WORD *pA = (WORD*)bm->GetAlphaPtr(&type);   // alpha
	assert(type == BMM_GRAY_16);

	int chkIndex = 3*bm->Width();
	int imageSz = bm->Width() * bm->Height();

	int iTemp;
	pblock->GetValue(prm_r, t, iTemp, FOREVER);	float rOffset = iTemp * .01f;
	pblock->GetValue(prm_g, t, iTemp, FOREVER);	float gOffset = iTemp * .01f;
	pblock->GetValue(prm_b, t, iTemp, FOREVER);	float bOffset = iTemp * .01f;

	BOOL pLum;
	pblock->GetValue(prm_pLum, t, pLum, FOREVER);

	BOOL iBack;
	pblock->GetValue(prm_iBack, t, iBack, FOREVER);

	AColor c1, c2;
	for (int index=0; index<imageSz; index++, pS+=3, pA++)
	{
		if ( iBack && (*pA == 0) )
			continue;

		c1.r = *pS / MAX_COLf;
		c1.g = *(pS+1) / MAX_COLf;
		c1.b = *(pS+2) / MAX_COLf;
		c1.a = *pA / MAX_COLf;

		if (pLum)
		{
			// original luminance (from "A Technical Introduction to Digital Video", C. Poynton)
			float lumIn = c1.r*0.2125f + c1.g*0.7154f + c1.b*0.0721f;

/*
			float rOff(0.0f), gOff(0.0f), bOff(0.0f);
			rOff += rOffset*.85f; gOff -= rOffset*.15f; bOff -= rOffset*.15f; // split offset with other channels so not to lose
			rOff -= gOffset*.15f; gOff += gOffset*.85f; bOff -= gOffset*.15f; // all color information at extreme offsets
			rOff -= bOffset*.15f; gOff -= bOffset*.15f; bOff += bOffset*.85f;
			c2.r = c1.r + c1.r * rOff;
			c2.g = c1.g + c1.g * gOff;
			c2.b = c1.b + c1.b * bOff;
*/
			// above code rewritten - slightly compressed
			c2.r = c1.r * (1 + .85f*rOffset - .15f*(gOffset + bOffset));
			c2.g = c1.g * (1 + .85f*gOffset - .15f*(rOffset + bOffset));
			c2.b = c1.b * (1 + .85f*bOffset - .15f*(rOffset + gOffset));

			// new luminance
			float lumOut = c2.r*0.2125f + c2.g*0.7154f + c2.b*0.0721f;

			// scale to preserve luminance
			float ratio = (lumOut <= 0) ? 0 : lumIn / lumOut;
			c2 *= ratio;
		}
		else
		{
			// calculate new color by adding a percentage of maxAdd
			// not preserving luminance, so maxAdd allows full black to full white
			float maxAdd;
			maxAdd = (rOffset < 0) ? c1.r : (1.0f - c1.r);
			c2.r = c1.r + maxAdd*rOffset;

			maxAdd = (gOffset < 0) ? c1.g : (1.0f - c1.g);
			c2.g = c1.g + maxAdd*gOffset;

			maxAdd = (bOffset < 0) ? c1.b : (1.0f - c1.b);
			c2.b = c1.b + maxAdd*bOffset;
		}

		if ( iBack )
			c2 = c2*c1.a + c1*(1.0f-c1.a);
		
		c2.ClampMinMax();

		*pS     = (USHORT)(c2.r * MAX_COLf);
		*(pS+1) = (USHORT)(c2.g * MAX_COLf);
		*(pS+2) = (USHORT)(c2.b * MAX_COLf);

		if ( ( (index & chkIndex) == 0 ) && checkAbort && checkAbort->Progress(index, imageSz) ) 
			return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\ColorBalance\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by colorBalance.rc
//
#define IDD_COL_BAL_EFFECT              400
#define IDC_RED_EDIT                    500
#define IDC_GREEN_EDIT                  501
#define IDC_BLUE_EDIT                   502
#define IDC_RED_SLIDER                  600
#define IDC_GREEN_SLIDER                601
#define IDC_BLUE_SLIDER                 602
#define IDC_RED_SPIN                    700
#define IDC_GREEN_SPIN                  701
#define IDC_BLUE_SPIN                   702
#define IDC_LUMINOSITY                  800
#define IDC_BACKGROUND                  801
#define IDS_COL_BAL_PARAMS              30543
#define IDS_COL_BAL                     30544
#define IDS_LIBDESCRIPTION              30545
#define IDS_RED                         30546
#define IDS_GREEN                       30547
#define IDS_BLUE                        30548
#define IDS_P_LUM                       30549
#define IDS_I_BACK                      30550
#define IDS_RGB                         30551
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1735
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\ColorBalance\dllMain.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.cpp

	 DESCRIPTION: DLL entry implementation

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 2, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#include "dllMain.h"


// global variables
HINSTANCE hInstance;

// global functions
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved)
{
	// remember this dll's instance handle
	hInstance = hinstDLL;

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// initialize max controls
		InitCustomControls(hInstance);
		// initialize microsoft controls
		InitCommonControls();
		break;
	}
	return (TRUE);
}


//------------------------------------------------------
// interface to Max
//------------------------------------------------------

// returns dll descriptive string
__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}


// returns number of classes in dll
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


// returns appropriate class descriptor
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i)
	{
	case 0:
		return GetColBalDesc();
	default:
		return 0;
	}
}


// returns version to detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}


// standard hInstance dependent GetString()
TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FileOut\dllMain.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.cpp

	 DESCRIPTION: DLL entry implementation

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 15, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#include "dllMain.h"


// global variables
HINSTANCE hInstance;

// global functions
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved)
{
	// remember this dll's instance handle
	hInstance = hinstDLL;

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// initialize max controls
		InitCustomControls(hInstance);
		// initialize microsoft controls
		InitCommonControls();
		break;
	}
	return (TRUE);
}


//------------------------------------------------------
// interface to Max
//------------------------------------------------------

// returns dll descriptive string
__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}


// returns number of classes in dll
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


// returns appropriate class descriptor
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i)
	{
	case 0:
		return GetFileOutDesc();
	default:
		return 0;
	}
}


// returns version to detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}


// standard hInstance dependent GetString()
TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FileOut\dllMain.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.h

	 DESCRIPTION: DLL entry header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 15, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#ifndef __DLL_MAIN__H
#define __DLL_MAIN__H


#include "resource.h"
#include "max.h"

extern HINSTANCE hInstance;

TCHAR *GetString(int id);
extern ClassDesc* GetFileOutDesc();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FileOut\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fileOut.rc
//
#define IDD_FILE_OUT_EFFECT             400
#define IDT_VP_EVENT_LOWER_FRAME        1025
#define IDT_VP_EVENT_LOWER_FRAME2       1027
#define IDT_VP_EVENT_UPPER_FRAME        1033
#define IDC_SEL_FILE                    1700
#define IDC_SEL_DEV                     1701
#define IDC_CURRENT_FRAME               1706
#define IDC_TIME_SEG                    1707
#define IDB_FILES                       1709
#define IDB_DEVICES                     1710
#define IDT_UPPER_TEXT                  1711
#define IDT_LOWER_TEXT                  1712
#define IDB_ABOUT                       1713
#define IDB_SETUP                       1714
#define IDB_CLEAR                       1715
#define IDC_CHANNEL_LIST                1717
#define IDC_START_TIME_EDIT             1718
#define IDC_END_TIME_EDIT               1719
#define IDC_START_TIME_SPIN             1720
#define IDC_END_TIME_SPIN               1721
#define IDB_PICK_CAM                    1722
#define IDC_MINZ_EDIT                   1723
#define IDC_NEARZ_EDIT                  1723
#define IDC_MINZ_SPIN                   1724
#define IDC_NEARZ_SPIN                  1724
#define IDC_MAXZ_EDIT                   1725
#define IDC_FARZ_EDIT                   1725
#define IDC_MAXZ_SPIN                   1726
#define IDC_FARZ_SPIN                   1726
#define IDC_MINZ_TEXT                   1727
#define IDC_NEARZ_TEXT                  1727
#define IDC_MAXZ_TEXT                   1728
#define IDC_FARZ_TEXT                   1728
#define IDC_PICK_CAM_TEXT               1729
#define IDB_COPY                        1731
#define IDB_ACTIVE                      1734
#define IDB_FIT_SCENE                   1735
#define IDB_AFFECT_SRC                  1736
#define IDS_LIBDESCRIPTION              30500
#define IDS_FILE_OUT_PARAMS             30501
#define IDS_FILE_OUT                    30502
#define IDS_SEG_TYPE                    30503
#define IDS_CHANNEL_TYPE                30503
#define IDS_START_TIME                  30504
#define IDS_ACTIVE                      30504
#define IDS_END_TIME                    30505
#define IDS_BITMAP                      30505
#define IDS_UNDEFINED                   50038
#define IDS_NONE_AVAIL                  50053
#define IDS_ERROR_TITLE                 50125
#define IDS_ERROR_WRITE                 50126
#define IDS_CAM_NODE                    50127
#define IDS_MINZ                        50128
#define IDS_NEARZ                       50128
#define IDS_MAXZ                        50129
#define IDS_FARZ                        50129
#define IDS_PICK_CAM_PROMPT             50130
#define IDS_IMAGE                       50131
#define IDS_DEPTH                       50132
#define IDS_LUM                         50133
#define IDS_ALPHA                       50134
#define IDS_PICK_CAM_TIP                50135
#define IDS_COPY_VALS_TIP               50136
#define IDS_AFFECT_SRC                  50137
#define IDS_AFFECT_SRC_TIP              50138
#define IDS_FIT_SCENE                   50139
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1735
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FileOut\fileOut.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: fileOut.cpp

	 DESCRIPTION: post-render file output

	 CREATED BY: michael malone (mjm)

	 HISTORY: created October 15, 1998

		 mjm - 9.9.99 -- restructured to better handle cancelled render notification
		 
   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

// local headers
#include "dllMain.h"

// sdk headers
#include <iparamm2.h>
#include <bmmlib.h>

// IDs to references
#define PBLOCK_REF 0
#define DEF_OFFSET 0

// parameter blocks IDs
enum { pbIDFOut };

// parameters for pbIDFOut
enum { prmBitmap, 
	   prmActive,
	   prmAffectSrc,
	   prmChanType,
	   prmCameraNode,
	   prmNearZ,
	   prmFarZ,
	   prmFitScene, };

enum { image, luminance, depth, alpha };

// global instances
static const Class_ID fileOutClassID(0x51763499, 0x637e0353);
const int MAX_COL16(65535); // maximum 16 bit color value


// ----------------------------------------
// color balance effect - class declaration
// ----------------------------------------
class FileOut: public Effect
{
protected:
	Bitmap *mp_srcBM, *mp_writeBM;
	WORD *mp_srcMap, *mp_srcAlpha;
	float *mp_zBuf;
	PBBitmap* m_pPBBMap;
	BitmapInfo *m_pBi;
	CheckAbortCallback *mp_lastCheckAbort;
	int m_srcW, m_srcH, m_writeW, m_writeH;
	int m_firstFrame, m_lastFrame, m_thisFrame, m_fileFrame;
	BOOL m_writing, m_affectSrc, m_active, m_bmOpen, m_singleFrame;
	int m_channel;

	// an empty instance of a bitmap is needed for initialization
	PBBitmap m_PBBMap;


	void processImage();
	void processLum();
	void processDepth();
	void processAlpha();
	void processBMap();

public:
	IParamBlock2 *mp_pblock;

	FileOut();
	~FileOut();
	bool GetStartEndFrames();

	// Animatable/Reference
	int NumSubs() { return 1; }
	Animatable* SubAnim(int i) { return GetReference(i); }
	TSTR SubAnimName(int i);
	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	Class_ID ClassID() { return fileOutClassID; }
	void GetClassName(TSTR& s) { s = GetString(IDS_FILE_OUT); }
	void DeleteThis() { delete this; }
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return mp_pblock; } // only one
	IParamBlock2* GetParamBlockByID(BlockID id) { return (mp_pblock->ID() == id) ? mp_pblock : NULL; }
	IOResult Load(ILoad *iload);

	// Effect
	TSTR GetName() { return GetString(IDS_FILE_OUT); }
	EffectParamDlg *CreateParamDialog(IRendParams *ip);
	DWORD GBufferChannelsRequired(TimeValue t);
	void Update(TimeValue t, Interval& valid) { }
	int RenderBegin(TimeValue t, ULONG flags) { return 0; }
	int RenderEnd(TimeValue t);
	void Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort);
};


// --------------------------------------------------
// color balance class descriptor - class declaration
// --------------------------------------------------
class FileOutClassDesc : public ClassDesc2
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FileOut; }
	const TCHAR *	ClassName() { return GetString(IDS_FILE_OUT); }
	SClass_ID		SuperClassID() { return RENDER_EFFECT_CLASS_ID; }
	Class_ID 		ClassID() { return fileOutClassID; }
	const TCHAR* 	Category() { return _T(""); }
	const TCHAR*	InternalName() { return _T("fileOut"); } // hard-coded for scripter
	HINSTANCE		HInstance() { return hInstance; }
	};

// global instance
static FileOutClassDesc fileOutCD;
// external access function (through dllMain.h)
ClassDesc* GetFileOutDesc() { return &fileOutCD; }


// -------------------------------------------
// parameter accessor - class declaration
// -------------------------------------------
class FileOutPBAccessor : public PBAccessor
{
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)
	{
		// since this effect's params are not animatable, time is always 0
		static IParamBlock2* p_pblock;
		p_pblock = ((FileOut *)owner)->mp_pblock;

		// this accessor ensures that min <= max
		switch (id)
		{
			case prmNearZ:
				if ( v.f < p_pblock->GetFloat(prmFarZ) )
					p_pblock->SetValue(prmFarZ, 0, v.f - 0.1f);
				break;
			case prmFarZ:
				if ( v.f > p_pblock->GetFloat(prmNearZ) )
					p_pblock->SetValue(prmNearZ, 0, v.f + 0.1f);
				break;
		}
	}
};

// global instance
static FileOutPBAccessor fOutAccessor;


// -------------------------------------------
// parameter validator - class declaration
// -------------------------------------------
class FileOutPBValidator : public PBValidator
{
	// this validator picks only camera objects
	BOOL Validate(PB2Value &v)
	{
		static Object *ob;
		ob = (((INode *)v.r)->EvalWorldState(0)).obj;
		if ( ob && (ob->SuperClassID() == CAMERA_CLASS_ID) )
			return TRUE;
		else
			return FALSE;
	}
};

// global instance
static FileOutPBValidator fOutValidator;

typedef TCHAR TChBuffer[MAX_PATH];

// -------------------------------------------
// rollup dialog procedure - class declaration
// -------------------------------------------
#define NUMCHANNELS 4
class FileOutDlgProc : public ParamMap2UserDlgProc 
{
	TChBuffer mStrings[NUMCHANNELS];

	BOOL hasSetup(BitmapInfo *pBi);
	BOOL hasAbout(BitmapInfo *pBi);
	BOOL setup(BitmapInfo *pBi, HWND hWnd);
	void about(BitmapInfo *pBi, HWND hWnd);
	void handleSetup (BitmapInfo *pBi, HWND hWnd);
	void handleText (BitmapInfo *pBi, HWND hWnd);
	void showZCtrls(HWND hWnd, int state);
	void enableZCtrls(HWND hWnd, IParamMap2 *map, BOOL state);
	void copyZVals(IParamMap2 *map);

public:
	void SetThing(ReferenceTarget *newEff) { }
	BOOL DlgProc(TimeValue t,IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void DeleteThis() { }
	void Update(TimeValue t);
	void ShowControls(TimeValue t, IParamMap2 *map, HWND hWnd);
	ICustButton *m_iCopyBtn;
	BOOL m_camPicked;
};

// global instance
static FileOutDlgProc fOutDlgProc;


// ---------------------------------------------
// parameter block description - global instance
// ---------------------------------------------
static ParamBlockDesc2 pbdFOut(pbIDFOut, _T("fileOut parameters"), 0, &fileOutCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF,
	//rollout
	IDD_FILE_OUT_EFFECT, IDS_FILE_OUT_PARAMS, 0, 0, &fOutDlgProc,
	// params
	prmBitmap, _T("bitmap"), TYPE_BITMAP, 0, IDS_BITMAP,			// not animatable
		end,
	prmActive, _T("active"), TYPE_BOOL, P_ANIMATABLE, IDS_ACTIVE,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDB_ACTIVE,
		end,
	prmAffectSrc, _T("affectSource"), TYPE_BOOL, P_ANIMATABLE, IDS_AFFECT_SRC,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDB_AFFECT_SRC,
		end,
	prmChanType, _T("channelType"), TYPE_INT, 0, IDS_CHANNEL_TYPE,	// not animatable
		p_range, image, alpha,
		p_default, image,
		end,
	prmCameraNode, _T("cameraNode"), TYPE_INODE, 0, IDS_CAM_NODE,	// not animatable
		p_ui, TYPE_PICKNODEBUTTON, IDB_PICK_CAM,
		p_prompt, IDS_PICK_CAM_PROMPT,
		p_validator, &fOutValidator,
		end,
	prmNearZ, _T("nearZ"), TYPE_FLOAT, P_ANIMATABLE, IDS_NEARZ,
		p_range, -1.0e10f, 1.0e10f,
		p_default, 0.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDC_NEARZ_EDIT, IDC_NEARZ_SPIN, SPIN_AUTOSCALE,
		p_accessor, &fOutAccessor,
		end,
	prmFarZ, _T("farZ"), TYPE_FLOAT, P_ANIMATABLE, IDS_FARZ,
		p_range, -1.0e10f, 1.0e10f,
		p_default, -500.0f,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDC_FARZ_EDIT, IDC_FARZ_SPIN, SPIN_AUTOSCALE,
		p_accessor, &fOutAccessor,
		end,
	prmFitScene, _T("fitScene"), TYPE_BOOL, P_ANIMATABLE, IDS_FIT_SCENE,
		p_default, TRUE,
		p_ui, TYPE_SINGLECHEKBOX, IDB_FIT_SCENE,
		end,
	end
	);


// --------------------------------------------
// rollup dialog procedure - method definitions
// --------------------------------------------
BOOL FileOutDlgProc::hasSetup(BitmapInfo *pBi)
{
	if (!pBi->Device()[0])
		return (FALSE);
	else
	{
		DWORD devcap = TheManager->ioList.GetDeviceCapabilities(pBi->Device());
		return (devcap & BMMIO_CONTROLWRITE)==0? FALSE: TRUE;
	}   
}

BOOL FileOutDlgProc::hasAbout(BitmapInfo *pBi)
{
	if (!_tcslen(pBi->Device()))
		return (FALSE);
	else   
		return (TRUE);
}

BOOL FileOutDlgProc::setup(BitmapInfo *pBi, HWND hWnd)
{
	if (pBi->Device()[0])
	{
		BitmapIO *IO = TheManager->ioList.CreateDevInstance(pBi->Device());
		if(IO)
		{
			if (pBi->GetPiData())
			{
				if (!IO->ValidatePiData(pBi))
				  pBi->ResetPiData();
				else
				  IO->LoadConfigure(pBi->GetPiData());
			}
			if (IO->ShowControl(hWnd,BMMIO_CONTROLWRITE))
			{
				DWORD size = IO->EvaluateConfigure();
				if (pBi->AllocPiData(size))
				{
					if (!IO->SaveConfigure(pBi->GetPiData()))
					  pBi->ResetPiData();
				}
			}
			delete IO;
			return (TRUE);
		}
	}
	return (FALSE);
}

void FileOutDlgProc::about(BitmapInfo *pBi, HWND hWnd) {
	if (!_tcslen(pBi->Device()))
		return;
	BitmapIO *IO = TheManager->ioList.CreateDevInstance(pBi->Device());
	if(IO) {
		IO->ShowAbout(hWnd);
		delete IO;
	}
}

void FileOutDlgProc::handleSetup (BitmapInfo *pBi, HWND hWnd)
{
	HWND hDlg = GetDlgItem(hWnd,IDB_SETUP);
	EnableWindow(hDlg, hasSetup(pBi));
	hDlg = GetDlgItem(hWnd,IDB_ABOUT);
	EnableWindow(hDlg, hasAbout(pBi));
}

void FileOutDlgProc::handleText (BitmapInfo *pBi, HWND hWnd) {
	TCHAR file[MAX_PATH];

	if (!_tcslen(pBi->Name()))
		_tcscpy(file, GetString(IDS_NONE_AVAIL));
	else
		_tcscpy(file, pBi->Name());

	TSTR text;

	// handle file line
	if ( (_tcslen(file) > 40) && (_tcslen(pBi->Name())) ) {
		TCHAR txt[MAX_PATH];
		_tcscpy(txt,file);
		int i = 6;
		do {
			if (txt[i] == '\\')
				break;
			if (txt[i] == '/')
				break;
		} while (i++ < 12);
		txt[i+1] = 0;
		_tcscat(txt,"...\\");
		_tcscat(txt, pBi->Filename());
		SetDlgItemText(hWnd, IDT_UPPER_TEXT, txt);
	} else
		SetDlgItemText(hWnd, IDT_UPPER_TEXT, file);

	// handle device line
	text = pBi->Device();
	if (!text.length())
		text = GetString(IDS_UNDEFINED);
	SetDlgItemText(hWnd, IDT_LOWER_TEXT, text);   
}

void FileOutDlgProc::showZCtrls(HWND hWnd, int state)
{
	ShowWindow( GetDlgItem(hWnd, IDC_PICK_CAM_TEXT), state );
	ShowWindow( GetDlgItem(hWnd, IDB_COPY), state );
	ShowWindow( GetDlgItem(hWnd, IDB_PICK_CAM), state );
	ShowWindow( GetDlgItem(hWnd, IDC_NEARZ_EDIT), state );
	ShowWindow( GetDlgItem(hWnd, IDC_NEARZ_SPIN), state );
	ShowWindow( GetDlgItem(hWnd, IDC_NEARZ_TEXT), state );
	ShowWindow( GetDlgItem(hWnd, IDC_FARZ_EDIT), state );
	ShowWindow( GetDlgItem(hWnd, IDC_FARZ_SPIN), state );
	ShowWindow( GetDlgItem(hWnd, IDC_FARZ_TEXT), state );
	ShowWindow( GetDlgItem(hWnd, IDB_FIT_SCENE), state );
}

void FileOutDlgProc::enableZCtrls(HWND hWnd, IParamMap2 *map, BOOL state)
{
	EnableWindow( GetDlgItem(hWnd, IDC_PICK_CAM_TEXT), state );
	EnableWindow( GetDlgItem(hWnd, IDC_NEARZ_TEXT), state );
	EnableWindow( GetDlgItem(hWnd, IDC_FARZ_TEXT), state );

	if (m_camPicked)
	{
		m_iCopyBtn->Enable(state);
	}

	map->Enable( prmCameraNode, state );
	map->Enable( prmNearZ, state );
	map->Enable( prmFarZ, state );
}

void FileOutDlgProc::copyZVals(IParamMap2 *map)
{
	INode *p_node;
	map->GetParamBlock()->GetValue(prmCameraNode, 0, p_node, FOREVER);
	if (p_node)
	{
		CameraObject *p_cam = (CameraObject*)(p_node->EvalWorldState(0).obj);

		TimeValue t	= GetCOREInterface()->GetTime();
		float dist = p_cam->GetClipDist(t, CAM_HITHER_CLIP);
		map->GetParamBlock()->SetValue(prmNearZ, 0, -dist);
		dist = p_cam->GetClipDist(t, CAM_YON_CLIP);
		map->GetParamBlock()->SetValue(prmFarZ, 0, -dist);
	}
}

void FileOutDlgProc::Update(TimeValue t)
{
	IParamMap2 *map = fileOutCD.GetParamMap(&pbdFOut);
	if (map)
	{
		HWND hWnd = map->GetHWnd(); DbgAssert(hWnd);
		ShowControls(t, map, hWnd);
	}
}

void FileOutDlgProc::ShowControls(TimeValue t, IParamMap2 *map, HWND hWnd)
{
	int index;
	PBBitmap* pPBBMap;
	map->GetParamBlock()->GetValue(prmBitmap, t, pPBBMap, FOREVER); DbgAssert(pPBBMap);
	BitmapInfo*	pBi = &(pPBBMap->bi);

	handleText(pBi, hWnd);
	handleSetup(pBi, hWnd);
	map->GetParamBlock()->GetValue(prmChanType, t, index, FOREVER);
	SendMessage( GetDlgItem(hWnd, IDC_CHANNEL_LIST), CB_SETCURSEL, (WPARAM)index, 0 );
	ShowWindow( GetDlgItem(hWnd, IDB_AFFECT_SRC), (index != image) ? SW_SHOW : SW_HIDE );
	INode *p_node;
	map->GetParamBlock()->GetValue(prmCameraNode, 0, p_node, FOREVER);
	m_iCopyBtn->Enable( m_camPicked = (p_node) ? TRUE : FALSE );
	showZCtrls( hWnd, (index == depth) ? SW_SHOW : SW_HIDE );
	enableZCtrls( hWnd, map, IsDlgButtonChecked( hWnd, IDB_FIT_SCENE) != BST_CHECKED );
}

BOOL FileOutDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static TCHAR oldname[MAX_PATH];
	static HWND hCtrl;
	static PBBitmap* pPBBMap;
	static BitmapInfo*	pBi;

	map->GetParamBlock()->GetValue(prmBitmap, t, pPBBMap, FOREVER);
	DbgAssert(pPBBMap);
	pBi = &(pPBBMap->bi);

	switch (msg)
	{
		case WM_INITDIALOG:
		{
			// initialize strings for combo boxe
			_tcscpy( mStrings[0], GetString(IDS_IMAGE) );
			_tcscpy( mStrings[1], GetString(IDS_LUM));
			_tcscpy( mStrings[2], GetString(IDS_DEPTH));
			_tcscpy( mStrings[3], GetString(IDS_ALPHA));

			// insert strings into listbox
			hCtrl = GetDlgItem(hWnd, IDC_CHANNEL_LIST);
			for (int index=0; index<NUMCHANNELS; index++)
				SendMessage( hCtrl, CB_ADDSTRING, 0, (LPARAM)mStrings[index] );

			// some button settings
			map->SetTooltip( prmCameraNode, TRUE, GetString(IDS_PICK_CAM_TIP) );
			m_iCopyBtn = GetICustButton( GetDlgItem(hWnd, IDB_COPY) );
			m_iCopyBtn->SetTooltip(TRUE, GetString(IDS_COPY_VALS_TIP) );
			break;
		}

		case WM_SHOWWINDOW:
			if (wParam) // window is being shown
				ShowControls(t, map, hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDC_CHANNEL_LIST:
					if ( HIWORD(wParam) == CBN_SELCHANGE )
					{
						hCtrl = (HWND)lParam;
						int index = SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
						map->GetParamBlock()->SetValue(prmChanType, 0, index); // not animatable - time 0
						ShowWindow( GetDlgItem(hWnd, IDB_AFFECT_SRC), (index != image) ? SW_SHOW : SW_HIDE );
						showZCtrls( hWnd, (index == depth) ? SW_SHOW : SW_HIDE );
					}
					break;
				case IDB_FILES:
					_tcscpy(oldname, pBi->Name());
					if (TheManager->SelectFileOutput(pBi, hWnd)) {
						handleText(pBi, hWnd);
						handleSetup(pBi, hWnd);
					}
					break;
				case IDB_DEVICES:
					_tcscpy(oldname, pBi->Device());
					if (TheManager->SelectDeviceOutput(pBi, hWnd)) {
						handleText(pBi, hWnd);
						handleSetup(pBi, hWnd);
					}
					break;
				case IDB_CLEAR:
					// set to an 'unnamed' bitmap
					pBi->SetName( _T("") );
					pBi->SetDevice( _T("") );
					handleText(pBi, hWnd);
					handleSetup(pBi, hWnd);
					break;
				case IDB_ABOUT:
					about(pBi, hWnd);
					break;
				case IDB_SETUP:
					setup(pBi, hWnd);
					break;
				case IDB_COPY:
					copyZVals(map);
					break;
				case IDB_FIT_SCENE:
					enableZCtrls( hWnd, map, IsDlgButtonChecked( hWnd, IDB_FIT_SCENE) != BST_CHECKED );
					break;
			}
			break;

		case WM_DESTROY:
			ReleaseICustButton(m_iCopyBtn);
			break;
	}
	return FALSE;
}

// -----------------------------------------
// file output effect - method definitions
// -----------------------------------------
FileOut::FileOut()
{
	mp_srcBM = mp_writeBM = NULL;
	mp_srcMap = mp_srcAlpha = NULL;
	mp_zBuf = NULL;
	m_pPBBMap = NULL;
	m_pBi = NULL;
	mp_lastCheckAbort = NULL;
	m_srcW = m_srcH = m_writeW = m_writeH = m_firstFrame = m_lastFrame = m_thisFrame = m_fileFrame = 0;
	m_writing = m_affectSrc = m_active = m_bmOpen = m_singleFrame = FALSE;
	m_channel = image;

	fileOutCD.MakeAutoParamBlocks(this);
	DbgAssert(mp_pblock);

	// initialize to an 'unnamed' bitmap
	mp_pblock->SetValue(prmBitmap, 0, &m_PBBMap);
}

FileOut::~FileOut()
{
	if (mp_writeBM)
		mp_writeBM->DeleteThis();
}

IOResult FileOut::Load(ILoad *iload)
{
	Effect::Load(iload);
	return IO_OK;
}

EffectParamDlg *FileOut::CreateParamDialog(IRendParams *ip)
{	
	return fileOutCD.CreateParamDialogs(ip, this);
}

DWORD FileOut::GBufferChannelsRequired(TimeValue t)
{
	int channel;
	mp_pblock->GetValue(prmChanType, 0, channel, FOREVER); // not animatable - time 0
	return ( (channel == depth) ? BMM_CHAN_Z : BMM_CHAN_NONE );
}

TSTR FileOut::SubAnimName(int i)
{
	switch (i)
	{
	case 0:
		return GetString(IDS_FILE_OUT_PARAMS);
	default:
		return _T("");
	}
}

RefTargetHandle FileOut::GetReference(int i)
{
	switch (i)
	{
	case 0:
		return mp_pblock;
	default:
		return NULL;
	}
}

void FileOut::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i)
	{
	case 0:
		mp_pblock = (IParamBlock2*)rtarg;
		break;
	}
}

RefResult FileOut::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message)
{
	static int prmID;
	switch (message)
	{
		case REFMSG_CHANGE:
			switch (prmID = mp_pblock->LastNotifyParamID())
			{
				case prmCameraNode:
				{
					INode *p_node;
					mp_pblock->GetValue(prmCameraNode, 0, p_node, FOREVER);
					FileOutDlgProc *proc = (FileOutDlgProc*)(mp_pblock->GetMap()->GetUserDlgProc());
					proc->m_iCopyBtn->Enable( proc->m_camPicked = (p_node) ? TRUE : FALSE );
					break;
				}
				case prmBitmap:
				case prmActive:
				case prmNearZ:
				case prmFarZ:
				case prmFitScene:
					break;
			}
			pbdFOut.InvalidateUI(prmID);
			break;
	}
	return REF_SUCCEED;
}

void FileOut::processImage()
{
	DbgAssert(m_writing); // if not writing, shouldn't be here
	int type;
	mp_srcMap = (WORD*)mp_srcBM->GetStoragePtr(&type);
	DbgAssert(type == BMM_TRUE_48);
	mp_srcAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
	DbgAssert(type == BMM_GRAY_16);
	WORD *writeMap = (WORD*)mp_writeBM->GetStoragePtr(&type);
	DbgAssert(type == BMM_TRUE_48);
	WORD *writeAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
	DbgAssert(type == BMM_GRAY_16);

	int i(0), p(0), imageSz(m_srcW*m_srcH);
	for ( ; i<imageSz; i++, p+=3)
	{
		writeMap[p]   = mp_srcMap[p];
		writeMap[p+1] = mp_srcMap[p+1];
		writeMap[p+2] = mp_srcMap[p+2];
		writeAlpha[i] = mp_srcAlpha[i];
	}
}

void FileOut::processLum()
{
	int type;
	mp_srcMap = (WORD*)mp_srcBM->GetStoragePtr(&type);
	DbgAssert(type == BMM_TRUE_48);

	// perceptually based luminance (from "A Technical Introduction to Digital Video", C. Poynton)
	int i(0), p(0), imageSz(m_srcW*m_srcH);
	if (m_writing)
	{
		mp_srcAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
		DbgAssert(type == BMM_GRAY_16);
		WORD *writeMap = (WORD*)mp_writeBM->GetStoragePtr(&type);
		DbgAssert(type == BMM_TRUE_48);
		WORD *writeAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
		DbgAssert(type == BMM_GRAY_16);
		if (m_affectSrc)
		{
			for ( ; i<imageSz; i++, p+=3)
			{
				mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = writeMap[p] = writeMap[p+1] = writeMap[p+2] = (WORD)(mp_srcMap[p]*0.2125f + mp_srcMap[p+1]*0.7154f + mp_srcMap[p+2]*0.0721f); // r = g = b = source luminance
				writeAlpha[i] = mp_srcAlpha[i];
			}
		}
		else
		{
			for ( ; i<imageSz; i++, p+=3)
			{
				writeMap[p] = writeMap[p+1] = writeMap[p+2] = (WORD)(mp_srcMap[p]*0.2125f + mp_srcMap[p+1]*0.7154f + mp_srcMap[p+2]*0.0721f); // r = g = b = source luminance
				writeAlpha[i] = mp_srcAlpha[i];
			}
		}
	}
	else if (m_affectSrc)
	{
		for ( ; i<imageSz; i++, p+=3)
			mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = (WORD)(mp_srcMap[p]*0.2125f + mp_srcMap[p+1]*0.7154f + mp_srcMap[p+2]*0.0721f); // r = g = b = source luminance
	}
}

void FileOut::processDepth()
{
	int type;
	mp_srcMap = (WORD*)mp_srcBM->GetStoragePtr(&type);
	DbgAssert(type == BMM_TRUE_48);
	mp_srcAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
	DbgAssert(type == BMM_GRAY_16);

	DWORD zType;
	if ( !(mp_zBuf = (float *)mp_srcBM->GetChannel(BMM_CHAN_Z, zType)) )
		return;

	BOOL fitScene;
	mp_pblock->GetValue(prmFitScene, 0, fitScene, FOREVER);	// not animatable - time 0

	int i, p(0), imageSz(m_srcW*m_srcH);
	float nearZ(-1.0e30f), farZ(1.0e30f), z;
	if (fitScene)
	{
		for (i=0; i<imageSz; i++)
		{
			z = mp_zBuf[i];
			if (z == -1.0e30f) // default z
				continue;
			if (nearZ < z)
				nearZ = z;
			if (farZ > z)
				farZ = z;
		}
	}
	else
	{
		mp_pblock->GetValue(prmNearZ, 0, nearZ, FOREVER);	// not animatable - time 0
		mp_pblock->GetValue(prmFarZ,  0, farZ,  FOREVER);	// not animatable - time 0
	}

	float range(farZ - nearZ);
	if (m_writing)
	{
		WORD *writeMap = (WORD*)mp_writeBM->GetStoragePtr(&type);
		DbgAssert(type == BMM_TRUE_48);
		WORD *writeAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
		DbgAssert(type == BMM_GRAY_16);
		if (m_affectSrc)
		{
			for (i=0; i<imageSz; i++, p+=3)
			{
				z = (range == 0.0f) ? 1.0f : (mp_zBuf[i] - nearZ) / range;
				if ( (z < 0.0f) || (z > 1.0f) )
					z = 1.0f; // values outside of range set to black
				mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = writeMap[p] = writeMap[p+1] = writeMap[p+2] = (WORD)((1.0f-z) * MAX_COL16); // r = g = b = normalized z
				writeAlpha[i] = mp_srcAlpha[i];
			}
		}
		else
		{
			for (i=0; i<imageSz; i++, p+=3)
			{
				z = (range == 0.0f) ? 1.0f : (mp_zBuf[i] - nearZ) / range;
				if ( (z < 0.0f) || (z > 1.0f) )
					z = 1.0f; // values outside of range set to black
				writeMap[p] = writeMap[p+1] = writeMap[p+2] = (WORD)((1.0f-z) * MAX_COL16); // r = g = b = normalized z
				writeAlpha[i] = mp_srcAlpha[i];
			}
		}
	}
	else if (m_affectSrc)
	{
		for (i=0; i<imageSz; i++, p+=3)
		{
				z = (range == 0.0f) ? 1.0f : (mp_zBuf[i] - nearZ) / range;
				if ( (z < 0.0f) || (z > 1.0f) )
					z = 1.0f; // values outside of range set to black
				mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = (WORD)((1.0f-z) * MAX_COL16); // r = g = b = normalized z
		}
	}
}

void FileOut::processAlpha()
{
	int type;
	mp_srcMap = (WORD*)mp_srcBM->GetStoragePtr(&type);
	DbgAssert(type == BMM_TRUE_48);
	mp_srcAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
	DbgAssert(type == BMM_GRAY_16);

	int i(0), p(0), imageSz(m_srcW*m_srcH);
	if (m_writing)
	{
		WORD *writeMap = (WORD*)mp_writeBM->GetStoragePtr(&type);
		DbgAssert(type == BMM_TRUE_48);
		WORD *writeAlpha = (WORD*)mp_srcBM->GetAlphaPtr(&type);
		DbgAssert(type == BMM_GRAY_16);
		if (m_affectSrc)
		{
			for ( ; i<imageSz; i++, p+=3)
			{
				mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = writeMap[p] = writeMap[p+1] = writeMap[p+2] = writeAlpha[i] = mp_srcAlpha[i]; // r = g = b = source alpha
			}
		}
		else
		{
			for ( ; i<imageSz; i++, p+=3)
			{
				writeMap[p] = writeMap[p+1] = writeMap[p+2] = writeAlpha[i] = mp_srcAlpha[i]; // r = g = b = source alpha
			}
		}
	}
	else if (m_affectSrc)
	{
		for ( ; i<imageSz; i++, p+=3)
			mp_srcMap[p] = mp_srcMap[p+1] = mp_srcMap[p+2] = mp_srcAlpha[i]; // r = g = b = source alpha
	}
}

void FileOut::processBMap()
{
	m_srcW = mp_srcBM->Width();
	m_srcH = mp_srcBM->Height();

	if ( m_writing && !m_bmOpen )
	{
		m_fileFrame = -1;
		GetStartEndFrames();
		DbgAssert( m_thisFrame >= m_firstFrame && m_thisFrame <= m_lastFrame);

		m_pBi->SetWidth( m_srcW );
		m_pBi->SetHeight( m_srcH );
		m_pBi->SetAspect( mp_srcBM->Aspect() );
		m_pBi->SetGamma( mp_srcBM->Gamma() );
		m_pBi->SetFlags( mp_srcBM->Flags() );
		m_pBi->SetType( BMM_TRUE_64 );
		m_pBi->SetFirstFrame( m_thisFrame );
		m_pBi->SetLastFrame( m_thisFrame );
		m_pBi->SetCurrentFrame( m_thisFrame );

		if ( (m_srcW != m_writeW) || (m_srcH != m_writeH) )
		{
			if (mp_writeBM)
				mp_writeBM->DeleteThis();

			mp_writeBM = TheManager->Create(m_pBi);
			m_writeW = m_srcW;
			m_writeH = m_srcH;
		}

		if ( mp_writeBM->OpenOutput(m_pBi) != BMMRES_SUCCESS )
			GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR, DISPLAY_DIALOG, GetString(IDS_ERROR_TITLE), GetString(IDS_ERROR_WRITE), _T("") );
		else
			m_bmOpen = TRUE;
	}

	switch (m_channel)
	{
		case image:
			processImage();
			break;
		case luminance:
			processLum();
			break;
		case depth:
			processDepth();
			break;
		case alpha:
			processAlpha();
			break;
	}

	if (m_writing)
	{
		if (m_singleFrame)
			m_fileFrame = BMM_SINGLEFRAME;
		else
			m_pBi->SetLastFrame( ++m_fileFrame );

		if ( mp_writeBM->Write( m_pBi, m_fileFrame ) != BMMRES_SUCCESS )
			GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR, DISPLAY_DIALOG, GetString(IDS_ERROR_TITLE), GetString(IDS_ERROR_WRITE), _T("") );
	}
}

int FileOut::RenderEnd(TimeValue t)
{
	if ( m_bmOpen )
	{
		mp_writeBM->Close(m_pBi);
		m_bmOpen = FALSE;
	}
	return 1;
}

//---------------------------
// parser for frame sequences
//---------------------------
const TCHAR CZERO('0');
const TCHAR CNINE('9');
enum ItemType { FLSingle, FLRange, FLError, FLEnd };

inline BOOL IsNumeric(TCHAR c) { return ( c >= CZERO && c <= CNINE ) ? 1 : 0; }

static ItemType GetNextItem(TCHAR *s, int& nextc, int &n1, int &n2 )
{
	BOOL gotN1 = FALSE;
	BOOL gotN2 = FALSE;
	int i = nextc;
	for (;;)
	{
		if ( IsNumeric(s[i]) )
		{
			int n = s[i++] - CZERO;
			while ( IsNumeric(s[i]) )
			{
				n = n*10 + s[i++] - CZERO;
			}
			if (gotN1)
			{ n2 = n; gotN2 = TRUE; }
			else
			{ n1 = n; gotN1 = TRUE;	}
		} 
		else
		{
			switch(s[i])
			{
				case _T(' '):
					break;
				case _T(','):
					i++;
					// fall thru:
				case 0:
					// done with item
					if (!gotN1)
						return FLError;
					nextc = i;
					return gotN2 ? FLRange : FLSingle;
				case _T('-'):
					if (!gotN1)
						return FLError;
					break;
				default:
					 return FLError;
			}
			i++;
		}
	}
	return FLError;
}

static bool ParseFrameList(TCHAR *s, IntTab& nums)
{
	int n1, n2, nc(0);
	nums.SetCount(0);
	while (s[nc] != 0)
	{
		switch ( GetNextItem(s, nc, n1, n2) )
		{
			case FLSingle:
				nums.Append(1, &n1, 8);
				break;
			case FLRange:  		
			{
				if (n2 < n1) 
					return false;
				int n = nums.Count();
				nums.SetCount(n+n2-n1+1);
				for (int j=n1; j<=n2; j++) 
					nums[n+j-n1] = j;
				break;
			}
			case FLError:
				return false;
			case FLEnd:		
				return true;
		}
	}
	return true;
}

bool FileOut::GetStartEndFrames()
{
	Interface *ip = GetCOREInterface();
	int tpf = GetTicksPerFrame();

	switch ( ip->GetRendTimeType() )
	{
		case REND_TIMESINGLE:
			m_firstFrame = m_lastFrame = m_thisFrame;
			m_singleFrame = true;
			return true;

		case REND_TIMESEGMENT:
			m_firstFrame = GetAnimStart() / tpf;
			m_lastFrame  = GetAnimEnd()   / tpf;
			return true;

		case REND_TIMERANGE:
			m_firstFrame = ip->GetRendStart() / tpf;
			m_lastFrame  = ip->GetRendEnd()   / tpf;
			return true;

		case REND_TIMEPICKUP:
		{
			IntTab fNums;
			TSTR &frameStr = ip->GetRendPickFramesString();

			if ( !ParseFrameList(frameStr, fNums) ) 
				return false;
			else
			{
				m_firstFrame =  99999999;
				m_lastFrame  = -99999999;
				for (int i=0; i<fNums.Count(); i++)
				{
					if (fNums[i] < m_firstFrame) m_firstFrame = fNums[i];
					if (fNums[i] > m_lastFrame)  m_lastFrame  = fNums[i];
				}
			}
			return true;
		}
		default:
			return false;
	}
}

void FileOut::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort)
{
	mp_srcBM = bm;
	mp_lastCheckAbort = checkAbort;
	m_thisFrame = t / GetTicksPerFrame();
	m_singleFrame = (!gc) ? true : false;  // (!gc) indicates call from render effects dialog

	mp_pblock->GetValue(prmActive, t, m_active, FOREVER);

	mp_pblock->GetValue(prmBitmap, 0, m_pPBBMap, FOREVER); // not animatable - get value at time 0
	DbgAssert(m_pPBBMap);
	m_pBi = &(m_pPBBMap->bi);
	m_writing = ( _tcslen(m_pBi->Filename()) || _tcslen(m_pBi->Device()) ) ? TRUE : FALSE;

	mp_pblock->GetValue(prmAffectSrc, t, m_affectSrc, FOREVER);
	mp_pblock->GetValue(prmChanType, t, m_channel, FOREVER);
	if ( !m_active || ( !m_writing && ( !m_affectSrc || m_channel == image ) ) ) // with m_affectSrc, could be previewing but not writing file -- channel == image would not affect source
		return;

	processBMap();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FilmGrain\FilmGrain.cpp ===
//-----------------------------------------------------------------------------
// ------------------------
// File ....: FilmGrain.cpp
// ------------------------
// Author...: Gus J Grubba
// Date ....: October 1998
//
// Implementation of Film Grain Render Effect
//
//-----------------------------------------------------------------------------
      
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <iparamm2.h>
#include "FilmGrain.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst	= NULL;
static int controlsInit = FALSE;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	
	hInst = hDLLInst;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInst);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
	}

	return(TRUE);
}

//-----------------------------------------------------------------------------
// *> GetString()
//

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
// Class Description

class FGClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic	()				{ return 1; }
	void*			Create		(BOOL loading)	{ return new FilmGrain; }
	const TCHAR*	ClassName	()				{ return GetString(IDS_FILM_GRAIN_EFFECT); }
	SClass_ID		SuperClassID()				{ return RENDER_EFFECT_CLASS_ID; }
	Class_ID        ClassID		()				{ return fgClassID; }
	const TCHAR* 	Category	()				{ return _T("");  }
	const TCHAR*	InternalName()				{ return _T("FilmGrain");}
	HINSTANCE		HInstance	()				{ return hInst; }
};

static FGClassDesc FGDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR *LibDescription() { 
	return GetString(IDS_LIBDESCR);
}

DLLEXPORT int LibNumberClasses() {
	return 1;
}

DLLEXPORT ClassDesc* LibClassDesc(int i) {
	switch(i) {
		case 0:		return &FGDesc;
		default:	return 0;
	}
}

DLLEXPORT ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}

//-----------------------------------------------------------------------------
// Parameters

#define PBLOCK_REF 0

enum { fg_params };

//-- fg_params param IDs

enum { fg_grain, fg_mask };

static ParamBlockDesc2 fg_param_blk ( fg_params, _T("Film Grain Parameters"),0,&FGDesc, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//-- Rollout
	IDD_SAMPLE_EFFECT, IDS_FG_PARAMETERS, 0, 0, NULL, 
	// params
	fg_grain, _T("Grain"), TYPE_FLOAT, P_ANIMATABLE, IDS_GRAIN,	
		p_default,		0.2,
		p_range,		0.0, 1.0,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_GRAIN, IDC_GRAIN_SPIN, SPIN_AUTOSCALE, 
		end,
	fg_mask, _T("Mask Background"), TYPE_BOOL, P_ANIMATABLE, IDS_MASK,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_MASK,
		end,
	end
	);

FilmGrain::FilmGrain() {
	FGDesc.MakeAutoParamBlocks(this);
	assert(pblock);
}

IOResult FilmGrain::Load(ILoad *iload) {
	Effect::Load(iload);
	return IO_OK;
}

EffectParamDlg *FilmGrain::CreateParamDialog(IRendParams *ip) {	
	return FGDesc.CreateParamDialogs(ip, this);
}

Animatable* FilmGrain::SubAnim(int i) {
	switch (i) {
		case 0:		return pblock;
		default:	return NULL;
	}
}

TSTR FilmGrain::SubAnimName(int i) {
	switch (i) {
		case 0:		return GetString(IDS_PARAMETERS);
		default:	return _T("");
	}
}

RefTargetHandle FilmGrain::GetReference(int i) {
	switch (i) {
		case 0:		return pblock;
		default:	return NULL;
	}
}

void FilmGrain::SetReference(int i, RefTargetHandle rtarg) {
	switch (i) {
		case 0: pblock	= (IParamBlock2*)rtarg; break;
	}
}

RefResult FilmGrain::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget,PartID& partID,  RefMessage message) {
	switch (message) {
		case REFMSG_CHANGE:
			fg_param_blk.InvalidateUI();
			break;
	}
	return REF_SUCCEED;
}

void FilmGrain::Update(TimeValue t, Interval& valid)	{
}

int FilmGrain::RenderBegin(TimeValue t, ULONG flags)	{
	return 0;
}

int FilmGrain::RenderEnd(TimeValue t) {
	return 0;
}

static BOOL WINAPI fxCallBack(LPVOID lpparam, int /*done*/, int /*total*/, TCHAR* /*msg*/) {
	CheckAbortCallback*  checkAbort = (CheckAbortCallback*)lpparam;
	if (checkAbort && checkAbort->Check()) 
		return FALSE;
	return TRUE;
}
		
void FilmGrain::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc,CheckAbortCallback *checkAbort) {
	Interval valid;		
	float	grain;
	BOOL	mask;
	pblock->GetValue(fg_grain,t,grain,valid);
	pblock->GetValue(fg_mask,t,mask,valid);
	bm->FilmGrain(grain,mask,::fxCallBack,checkAbort);
}



//-- EOF: FilmGrain.cpp -------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\SampleEff\dllMain.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.cpp

	 DESCRIPTION: DLL entry implementation

	 CREATED BY: michael malone (mjm)

	 HISTORY: created January 27, 1999

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#include "dllMain.h"


// global variables
HINSTANCE hInstance;

// global functions
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved)
{
	// remember this dll's instance handle
	hInstance = hinstDLL;

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// initialize max controls
		InitCustomControls(hInstance);
		// initialize microsoft controls
		InitCommonControls();
		break;
	}
	return (TRUE);
}


//------------------------------------------------------
// interface to Max
//------------------------------------------------------

// returns dll descriptive string
__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}


// returns number of classes in dll
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


// returns appropriate class descriptor
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i)
	{
	case 0:
		return GetSampleEffDesc();
	default:
		return 0;
	}
}


// returns version to detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}


// standard hInstance dependent GetString()
TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\SampleEff\dllMain.h ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: dllMain.h

	 DESCRIPTION: DLL entry header

	 CREATED BY: michael malone (mjm)

	 HISTORY: created January 27, 1999

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */
#ifndef __DLL_MAIN__H
#define __DLL_MAIN__H


#include "resource.h"
#include "max.h"

extern HINSTANCE hInstance;

TCHAR *GetString(int id);
extern ClassDesc* GetSampleEffDesc();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FilmGrain\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FilmGrain.rc
//
#define IDD_SAMPLE_EFFECT               101
#define IDC_GRAIN                       1001
#define IDC_GRAIN_SPIN                  1002
#define IDC_MASK                        1003
#define IDS_FILM_GRAIN_EFFECT           30501
#define IDS_FG_PARAMETERS               30502
#define IDS_GRAIN                       30503
#define IDS_PARAMETERS                  30504
#define IDS_MASK                        30505
#define IDS_LIBDESCR                    30506
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\FilmGrain\FilmGrain.h ===
//-----------------------------------------------------------------------------
// ----------------------
// File ....: FilmGrain.h
// ----------------------
// Author...: Gus J Grubba
// Date ....: October 1998
// Descr....: Film Grain Render Effect
//
// History .: Oct, 27 1998 - Ported
//            
//-----------------------------------------------------------------------------
        
#ifndef _FGCLASS_
#define _FGCLASS_

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- Forward References

#include "resource.h"

TCHAR *GetString(int id);
Class_ID fgClassID(470000003,0);

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class FilmGrain: public Effect {

		//-- Parameters

		IParamBlock2*	pblock;
						
	public:
     
		//-- Constructors/Destructors
        
						FilmGrain				( );
						~FilmGrain				( )	{};
               
		//-- Animatable/Reference

		int				NumSubs					( )	{ return 1; }
		Animatable*		SubAnim					( int i );
		TSTR			SubAnimName				( int i );
		int				NumRefs					( )	{ return 1; }
		RefTargetHandle	GetReference			( int i );
		void			SetReference			( int i, RefTargetHandle rtarg );
		
		Class_ID		ClassID					( )	{ return fgClassID; }
		void			GetClassName			( TSTR& s ) { s = GetString(IDS_FILM_GRAIN_EFFECT); }
		void			DeleteThis				( )	{ delete this; }
		RefResult		NotifyRefChanged		( Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		int				NumParamBlocks			( ) { return 1; }
		IParamBlock2*	GetParamBlock			( int i ) { return pblock; }
		IParamBlock2*	GetParamBlockByID		( BlockID id ) { return (pblock->ID() == id) ? pblock : NULL; }

		IOResult		Load					( ILoad *iload );

		//-- Effectc

		TSTR			GetName					( ) { return GetString(IDS_FILM_GRAIN_EFFECT); }
		EffectParamDlg*	CreateParamDialog		( IRendParams *ip );
		DWORD			GBufferChannelsRequired	( TimeValue t ) { return BMM_CHAN_Z; }
		int				RenderBegin				( TimeValue t, ULONG flags );
		int				RenderEnd				( TimeValue t );
		void			Update					( TimeValue t, Interval& valid );
		void			Apply					( TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort );

		int				NumGizmos				( )					{ return 0; }
		INode*			GetGizmo				( int i )			{ return NULL; }
		void			DeleteGizmo				( int i )			{ ; }
		void			AppendGizmo				( INode *node )		{ ;	}
		BOOL			OKGizmo					( INode *node )		{ return FALSE; }
		void			EditGizmo				( INode *node )		{ ; }

};

#endif

//-- EOF: FilmGrain.h ---------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\SampleEff\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sampleEff.rc
//
#define IDD_SAMPLE_EFFECT               111
#define IDC_BACKGROUND                  1701
#define IDC_SAMP_COLOR                  1702
#define IDC_SLOW                        1703
#define IDC_STRENGTH                    1704
#define IDC_STRENGTH_SPIN               1705
#define IDC_IGN_BACKGROUND              1706
#define IDS_LIBDESCRIPTION              30501
#define IDS_PARAMS                      30502
#define IDS_NAME                        30503
#define IDS_CLASS_NAME                  30504
#define IDS_CDESC_CLASS_NAME            30505
#define IDS_COLOR                       30506
#define IDS_STRENGTH                    30507
#define IDS_SLOW                        30508
#define IDS_IGN_BACK                    30509
#define IDS_GIZMO                       30510
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1706
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RenderEffect\SampleEff\sampleEff.cpp ===
/**********************************************************************
 *<
	FILE: sampleEff.cpp

	DESCRIPTION: Simple render effect

	CREATED BY: Dan Silva

	HISTORY: 6/29/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "dllMain.h"
#include <iparamm2.h>
#include <bmmlib.h>

#define SAMPLE_EFF_CLASS_ID 0x7691234
static const Class_ID sampleEffClassID(SAMPLE_EFF_CLASS_ID, 0);

#define PBLOCK_REF 0
#define GIZMO_REF  1

//--- Parameter Maps ----------------------------------------------------

// JBW: IDs for ParamBlock2 blocks and parameters
// paramBlock IDs
enum { sampleEff_params, };
// param IDs
enum { prm_color, prm_strength, prm_slow, prm_iBack, prm_gizmo, };

class SampleEffect: public Effect {
	public:
		// Parameters
// JBW: use IParamBlock2's now
		IParamBlock2* pblock;
		BOOL slow;
		INode *gizmo;
						
		SampleEffect();
		~SampleEffect() { }

		// Animatable/Reference
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		Class_ID ClassID() {return sampleEffClassID;}
		void GetClassName(TSTR& s) { s = GetString(IDS_CLASS_NAME); }
		void DeleteThis() {delete this;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

		IOResult Load(ILoad *iload);

		// Effect
		TSTR GetName() { return GetString(IDS_NAME); }
		EffectParamDlg *CreateParamDialog(IRendParams *ip);
		DWORD GBufferChannelsRequired(TimeValue t) { return BMM_CHAN_Z; }
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);
		void Update(TimeValue t, Interval& valid);
		void Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *checkAbort);

		virtual int NumGizmos() {return 1;}
		virtual INode *GetGizmo(int i) {return gizmo;}
		virtual void DeleteGizmo(int i) { 
			ReplaceReference(GIZMO_REF,NULL); 
			}
		virtual void AppendGizmo(INode *node) {
			ReplaceReference(GIZMO_REF, node);
			}
		virtual BOOL OKGizmo(INode *node) { 
			if (node == gizmo) return FALSE;
			ObjectState os = node->EvalWorldState(GetCOREInterface()->GetTime());
			return os.obj->SuperClassID()==LIGHT_CLASS_ID;
			} 
		virtual void EditGizmo(INode *node) {} // selects this gizmo & displays params for it if any
	};

//JBW: removed the EffectParamDlg; UI handled by ClassDesc2 now

class SampleEffClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SampleEffect; }
	const TCHAR *	ClassName() { return GetString(IDS_CDESC_CLASS_NAME); }
	SClass_ID		SuperClassID() { return RENDER_EFFECT_CLASS_ID; }
	Class_ID 		ClassID() { return sampleEffClassID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("sampleEffect"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle
	};

static SampleEffClassDesc sampleEffCD;
ClassDesc* GetSampleEffDesc() { return &sampleEffCD; }


// JBW: Example statically-defined dialog proc for the IParamMap2 for the following paramblock2, if needed.
// For dynamically-created ParamMapUserDlgProc's, call CreateAutoEParamDlg() or CreateRParamMap2() directly
// giving DlgProc.
class SampleEffDlgProc : public ParamMap2UserDlgProc 
{
	public:
		IParamMap *pmap;

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
		void DeleteThis() { }
};
  
BOOL SampleEffDlgProc::DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int id = LOWORD(wParam);
	switch (msg) 
	{
		case WM_INITDIALOG:
			break;
		case WM_DESTROY:
			break;
		case WM_COMMAND:
			break;
	}
	return FALSE;
}

static SampleEffDlgProc sampleEffDlgProc;

/* ------------- per instance sampleEffect paramblock --------------------------- */

static ParamBlockDesc2 sampleEff_pbDesc ( sampleEff_params, _T("sampleEff parameters"),  0, &sampleEffCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_SAMPLE_EFFECT, IDS_PARAMS, 0, 0, &sampleEffDlgProc, 
	// params
	prm_color, _T("color"),	TYPE_RGBA, P_ANIMATABLE, IDS_COLOR,
		p_default, Color(0,0,0),
		p_ui, TYPE_COLORSWATCH, IDC_SAMP_COLOR,
		end,
	prm_strength, _T("strength"), TYPE_FLOAT, P_ANIMATABLE, IDS_STRENGTH,
		p_default, 0.5,
		p_range, 0.0, 1.0,
		p_ui, TYPE_SPINNER, EDITTYPE_FLOAT, IDC_STRENGTH, IDC_STRENGTH_SPIN, SPIN_AUTOSCALE,
		end,
	prm_slow, _T("slow"), TYPE_BOOL, 0, IDS_SLOW,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_SLOW,
		end,
	prm_iBack, _T("ignoreBack"), TYPE_BOOL, P_ANIMATABLE, IDS_IGN_BACK,
		p_default, FALSE,
		p_ui, TYPE_SINGLECHEKBOX, IDC_IGN_BACKGROUND,
		end,
	prm_gizmo, _T("gizmo"), TYPE_REFTARG, P_OWNERS_REF, IDS_GIZMO,
		p_refno, GIZMO_REF,
		end,
	end
	);

//--- SampleEffect ----------------------------------------------------------

SampleEffect::SampleEffect()
	{
	slow = FALSE;
	gizmo = NULL;
// JBW: ask the ClassDes2 to make the AUTO_CONSTRUCT parablocks and wire them in
	sampleEffCD.MakeAutoParamBlocks(this);
	assert(pblock);
	}

IOResult SampleEffect::Load(ILoad *iload)
	{
	Effect::Load(iload);
	return IO_OK;
	}

EffectParamDlg *SampleEffect::CreateParamDialog(IRendParams *ip)
	{	
//JBW: ask the ClassDesc2 to make the AUTO_UI EffectParamDlg and IParamMap2s
	return sampleEffCD.CreateParamDialogs(ip, this);
	}

Animatable* SampleEffect::SubAnim(int i) 	{
	switch (i) {
		case 0: return pblock;
		default: return NULL;
		}
	}

TSTR SampleEffect::SubAnimName(int i) {
	switch (i) {
		case 0: return GetString(IDS_PARAMS);
		default: return _T("");
		}
	}

RefTargetHandle SampleEffect::GetReference(int i)
	{
	switch (i) {
		case 0: return pblock;
		case 1: return gizmo;
		default: return NULL;
		}
	}

void SampleEffect::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0: pblock = (IParamBlock2*)rtarg; break;
		case 1: gizmo= (INode*)rtarg; break;
		}
	}

RefResult SampleEffect::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_CHANGE:
// JBW: ask the block to update its UI
			sampleEff_pbDesc.InvalidateUI( pblock->LastNotifyParamID() );
//			NotifyChanged();
			break;
		}
	return REF_SUCCEED;
	}

void SampleEffect::Update(TimeValue t, Interval& valid)
	{
	}

int SampleEffect::RenderBegin(TimeValue t, ULONG flags)
	{
	return 0;
	}

int SampleEffect::RenderEnd(TimeValue t)
	{
	return 0;
	}
		
#define MAX_COLf 65535.0f

void SampleEffect::Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc,CheckAbortCallback *checkAbort)
{
// JBW: all pblock references now use the new permanent param IDs
	Color color;
	float fstr;
	BOOL iBack;
	pblock->GetValue(prm_color, t, color, FOREVER);
	pblock->GetValue(prm_strength, t, fstr, FOREVER);
	pblock->GetValue(prm_iBack, t, iBack, FOREVER);
	pblock->GetValue(prm_slow, t, slow, FOREVER);

	int w = bm->Width();
	int h = bm->Height();
	int s = int(4095.0f*fstr);
	int cs = 4095-s;
	float alpha;
	PixelBuf l64(w);
	BMM_Color_64 *p=l64.Ptr();

	BMM_Color_64 tempCol;
	BMM_Color_64 c = color;
	for (int y = 0; y<h; y++)
	{
		bm->GetPixels(0, y, w, p);
		for (int x=0; x<w; x++)
		{
			if ( iBack )
			{
				// skip transparent pixel
				if (p[x].a == 0)
					continue;

				// otherwise, blend on alpha value
				alpha = p[x].a / MAX_COLf;
				tempCol.r = (cs*p[x].r+s*((p[x].r+c.r)>>1))>>12;
				tempCol.g = (cs*p[x].g+s*((p[x].g+c.g)>>1))>>12;
				tempCol.b = (cs*p[x].b+s*((p[x].b+c.b)>>1))>>12;

				p[x].r = (USHORT)(tempCol.r*alpha + p[x].r*(1.0f-alpha));
				p[x].g = (USHORT)(tempCol.g*alpha + p[x].g*(1.0f-alpha));
				p[x].b = (USHORT)(tempCol.b*alpha + p[x].b*(1.0f-alpha));
			}
			else
			{
				p[x].r = (cs*p[x].r+s*((p[x].r+c.r)>>1))>>12;
				p[x].g = (cs*p[x].g+s*((p[x].g+c.g)>>1))>>12;
				p[x].b = (cs*p[x].b+s*((p[x].b+c.b)>>1))>>12;
			}

			if (slow)
			{
				double t1(10.0), t2(100.0);
				for (int k=0; k<20; k++)
					t1 += sqrt(t1+t2); // do something to slow things down for testing
			}
		}
		bm->PutPixels(0, y, w, p);
		if (((y&3)==0)&&checkAbort&&checkAbort->Progress(y,h)) 
			return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\rendvue.cpp ===
/**********************************************************************
 *<
	FILE: rendvue.cpp

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "rvuepch.h"
#include "resource.h"
#include "rendvue.h"


extern BOOL FileExists(TCHAR *filename);

static void catflt(TCHAR *s, int maxlen, FLOAT f) {
	int i;
	TCHAR buf[20];
	_sntprintf(buf,20,_T(" %.4f\0"),f);

	// Keith Trummel November 27, 1996
	// Change comma decimal separator to a period
	for (i=0; i<(int)strlen(buf); i++)
		if (buf[i] == _T(','))
			buf[i] = _T('.');

	for (i=strlen(buf)-1; i>0; i--) {
		switch(buf[i]) {
			case _T('0'): if (i==1) goto finish; else buf[i] = 0; break;
			case _T('.'): buf[i] =  0; goto finish; 
			default: goto finish; 
			}
		}
   finish:
    if ( (_tcslen(buf)==3) && (buf[1]==_T('-')) && (buf[2]==_T('0'))) strcpy(buf,_T(" 0"));
	_tcsncat(s,buf,maxlen);
	}

static void catpnt(TCHAR *s, int maxlen, Point3 p) {
	catflt(s,maxlen,p.x);
	catflt(s,maxlen,p.y);
	catflt(s,maxlen,p.z);
	}



class RendVueClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new VueRenderer; }
	const TCHAR *	ClassName() { return GetString(IDS_VRENDTITLE); }
	SClass_ID		SuperClassID() { return RENDERER_CLASS_ID; }
	Class_ID 		ClassID() { return VREND_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) {}
	};

static RendVueClassDesc srendCD;

ClassDesc* GetRendVueDesc() { 
	return &srendCD;  
	}

class INodeEnum {
	public:
	virtual void proc(INode *node)=0;
	};

void INodeEnumTree(INode *node, INodeEnum& inodeEnum) {
	inodeEnum.proc(node);
	for (int i=0; i<node->NumberOfChildren(); i++) 
		INodeEnumTree(node->GetChildNode(i), inodeEnum);
	}

class RendINodeEnum: public INodeEnum {
	BOOL rendSelection;
	VueRenderer *sr;
	TimeValue t;
	public:
		RendINodeEnum(VueRenderer* scanrend, BOOL sel, TimeValue time) { 
			sr = scanrend; rendSelection = sel; t = time; }
		void proc(INode *node) {
			BOOL nodeHidden = node->IsNodeHidden();
			ObjectState os = node->EvalWorldState(t);
			if (os.obj==NULL) 
				return;
			switch (os.obj->SuperClassID()) {
				case LIGHT_CLASS_ID: 
					{
					LightObject *lo = (LightObject*)os.obj;
					sr->anyLights = TRUE;
					if (lo->GetUseLight()) {
		 				//sr->AddLight(node,(LightObject*)os.obj);
						sr->nlts++;
						}
					}
					break;
				case GEOMOBJECT_CLASS_ID: {
					if ((!sr->RP.rendHidden)&&nodeHidden) return;
					if (!os.obj->IsRenderable()) return;
					if (rendSelection) {
						if (!node->Selected()) 
							return;
						}
					sr->nobs++ ;
//					if (node->MotBlur()&&sr->RP.motBlur) {
//						for (int i=sr->RP.nBlurFrames-1; i>=0; i--)   // DS 8-24-96
//							sr->AddInstance(node,i);
//						}
//					else 
//						sr->AddInstance(node);
					break;
				}
			}
		}
	};

class RendINodeEnumFrame: public INodeEnum {
	BOOL rendSelection;
	VueRenderer *sr;
	TimeValue t;
	public:
		RendINodeEnumFrame(VueRenderer* scanrend, BOOL sel, TimeValue time) { 
			sr = scanrend; rendSelection = sel; t = time; 
			}
		void proc(INode *node);
	};


void RendINodeEnumFrame::proc(INode *node) {
	BOOL nodeHidden = node->IsNodeHidden();
	ObjectState os = node->EvalWorldState(t);
	if (os.obj==NULL) 
		return;
	Matrix3 tm = node->GetObjTMAfterWSM(t,NULL);
	Point3 p = tm.GetTrans();
	switch (os.obj->SuperClassID()) {
		case LIGHT_CLASS_ID: {
			LightObject *lo = (LightObject*)os.obj;
			GenLight *gl = (GenLight *)lo;
			Point3 col = gl->GetRGBColor(t);
			if (gl->GetUseLight()) {
				if (os.obj->ClassID()==Class_ID(OMNI_LIGHT_CLASS_ID,0))	{
					// OMNI Light --------------
					_sntprintf(sr->buffer,256,_T("light \"%s\""), node->GetName());
					catpnt(sr->buffer,256,p); 
					catpnt(sr->buffer,256,col);	
					if (gl->GetShadow()) _tcsncat(sr->buffer,_T(" 1"), 256);
					_tcsncat(sr->buffer,_T("\n"),256);
					_fputts(sr->buffer,sr->vuefile);
					}		 
				else 
				if (os.obj->ClassID()==Class_ID(SPOT_LIGHT_CLASS_ID,0)) {
					// SPOT light ----------
					_sntprintf(sr->buffer,256,_T("spotlight \"%s\""),node->GetName());
					catpnt(sr->buffer,256,p);
					// target is in the negative Z direction.
					Point3 tp = p - 100.0f*tm.GetRow(2);
					catpnt(sr->buffer,256,tp); 
					catpnt(sr->buffer,256,col);	
					catflt(sr->buffer,256,gl->GetHotspot(t));
					catflt(sr->buffer,256,gl->GetFallsize(t));
					if (gl->GetShadow()) _tcsncat(sr->buffer,_T(" 1"), 256);
					//if (gl->IsDir()) _tcsncat(sr->buffer,_T(" D"), 256);
					_tcsncat(sr->buffer,_T("\n"),256);
					_fputts(sr->buffer,sr->vuefile);
					}
				}
			 }
			break;

		case GEOMOBJECT_CLASS_ID: {
			if ((!sr->RP.rendHidden)&&nodeHidden) 	return;
			if (!os.obj->IsRenderable()) 	return;
			if (rendSelection&&!node->Selected()) 	return;
			_sntprintf(sr->buffer,256,_T("transform \"%s\"\0"), node->GetName());
			for (int j=0;j<4; j++) 
				catpnt(sr->buffer,256,tm.GetRow(j));
			_tcsncat(sr->buffer,_T("\n"),256);
			_fputts(sr->buffer,sr->vuefile);
			}
			break;
		}
	}

void RemoveScaling(Matrix3 &m) {
	for (int i=0; i<3; i++) 
		m.SetRow(i,Normalize(m.GetRow(i)));
	}


// ---------- ExtractRollAngle ----------------
// Returns roll angle in degrees, given a transform matrix.
//
// The matrix z axis is the negative view direction
// First rotate about world Z so this axis in the world y/z plane.
// Then rotate about world Z so the matrix z axis lies along the y axis (0,1,0)
// THen the position of the matrix X axis in the world ZX plane can be used
// to get the Roll angle.
float ExtractRollAngle(Matrix3 &m) {
	float roll;
	Point3 axis = m.GetRow(2);
	float bearing = (float)atan2(axis.x,axis.y);
	Matrix3 m2 = m;
	m2.RotateZ(bearing);
	axis = m2.GetRow(2);
	float azimuth = (float)atan2(axis.z,axis.y);
	m2.RotateX(-azimuth);
	Point3 v = m2.GetRow(1);
	roll = -RadToDeg(atan2(v.x,v.z));
	return roll;
	}


void VueRenderer::WriteViewNode(INode* vnode, TimeValue t) {
	Interval iv;
	iv.SetInfinite();
	const ObjectState& os = vnode->EvalWorldState(t);
	switch (os.obj->SuperClassID()){
		case CAMERA_CLASS_ID: {
			// compute camera transform
			CameraObject *cam = (CameraObject *)os.obj;
			Matrix3 camtm = vnode->GetObjTMAfterWSM(t,&iv);
			RemoveScaling(camtm);
			float fov = cam->GetFOV(t);
			Point3 p = camtm.GetTrans();
			Point3 t = p + camtm.GetRow(2)*(-100.0f);  // target is (somewhere) in negative Z direction
			_tcsncpy(buffer,_T("camera"),256);
			catpnt(buffer,256,p);
			catpnt(buffer,256,t);
			catflt(buffer, 256, ExtractRollAngle(camtm));
			catflt(buffer, 256, 2400.0f/RadToDeg(fov));
			_tcsncat(buffer,_T("\n"),256);
			_fputts(buffer,vuefile);
			}
			break;
#if 0
		case LIGHT_CLASS_ID: {
			Matrix3 ltm = vnode->GetObjTMAfterWSM(t,&iv);
			//RemoveScaling(ltm);
			vp.affineTM = Inverse(ltm);
			
			LightState ls;
			LightObject *ltob = (LightObject *)os.obj;
			ltob->EvalLightState(t,iv,&ls);

			float aspect = ls.shape?1.0f:ls.aspect;
			switch(ls.type) {
				case SPOT_LGT:			
					vp.projType = PROJ_PERSPECTIVE;      
					vp.fov = DegToRad(ls.fallsize);  
					vp.fov = 2.0f* (float)atan(tan(vp.fov*0.5f)*sqrt(aspect));
					rp.devAspect = (float(rp.devHeight)/float(rp.devWidth))*aspect;
					break;
				case DIRECT_LGT:
					vp.projType = PROJ_PARALLEL; 
					rp.devAspect = (float(rp.devHeight)/float(rp.devWidth))*aspect;
					//vp.zoom = DegToRad(ls.fallsize);  //TBD
					break;
				}
			}
#endif
		default:
			break;

		}	
	}

void VueRenderer::WriteViewParams(ViewParams *v) {
	// Not implemented
	}

int VueRenderer::Open(
	INode *scene,     	// root node of scene to render
	INode *vnode,     	// view node (camera or light), or NULL
	ViewParams *viewPar,// view params for rendering ortho or user viewport
	RendParams &rp,  	// common renderer parameters
	HWND hwnd, 				// owner window, for messages
	DefaultLight* defaultLights, // Array of default lights if none in scene
	int numDefLights	// number of lights in defaultLights array
	) 
	{
	sceneNode = scene;
	viewNode = vnode;
	viewParams = *viewPar;
	RP = rp;	
	vuefile = NULL;
	if (_tcslen(vueFileName)==0) return 0;
	if (FileExists(vueFileName)) {
		TSTR buf;
		buf.printf(GetString(IDS_FILE_ALREADY_EXISTS),vueFileName);
		int ret = MessageBox(NULL, buf, GetString(IDS_VRENDTITLE), MB_YESNO|MB_ICONEXCLAMATION|MB_TASKMODAL);
		if (ret!=IDYES)  return 0;  
		}
	vuefile =(FILE *)fopen(vueFileName,"w");
	if (vuefile==0) {
		TSTR buf;
		buf.printf(GetString(IDS_CANT_OPEN),vueFileName);
		MessageBox(NULL, buf, GetString(IDS_RENDER_ERR), MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
		return(0);
		}

	_ftprintf(vuefile,_T("VERSION 202\n"));

	RendINodeEnum nodeEnum(this, RP.rendType==RENDTYPE_SELECT, 0);
	
	//  Initialize instance list and Light list.
    INodeEnumTree(sceneNode, nodeEnum);

	return 1;
	}


int VueRenderer::Render(
	TimeValue t,   			// frame to render.
	Bitmap *tobm, 			// optional target bitmap
	FrameRendParams &frp,	// Time dependent parameters
	HWND hwnd, 				// owner window
	RendProgressCallback *prog,
	ViewParams *vp
	) 
	{

	if (vuefile==NULL) 
		return 0;

	int frameNum = t/GetTicksPerFrame();

	_ftprintf(vuefile,_T("\nframe %d\n"), frameNum);

	RendINodeEnumFrame nodeEnum(this, RP.rendType==RENDTYPE_SELECT, t);

	// write out the entries to the VUE file
    INodeEnumTree(sceneNode, nodeEnum);		 

	// write the camera entry to the VUE file
	if (viewNode) 
		WriteViewNode(viewNode, t);
	else 
		WriteViewParams(&viewParams);
	return 1;
	}

void VueRenderer::Close( HWND hwnd ) { 
	if (vuefile)
		fclose(vuefile);
	}		

RefTargetHandle VueRenderer::Clone(RemapDir &remap) {
	VueRenderer *newRend = new VueRenderer;
	newRend->vueFileName = vueFileName;
	return newRend;
	}

void VueRenderer::ResetParams(){
	vueFileName.Resize(0);
	}

#define VUE_FILENAME_CHUNKID 001

IOResult VueRenderer::Save(ISave *isave) {
    if (_tcslen(vueFileName)>0) {	
	     isave->BeginChunk(VUE_FILENAME_CHUNKID);
	     isave->WriteWString(vueFileName);
	     isave->EndChunk();	
		 }
	return IO_OK;
	}

IOResult VueRenderer::Load(ILoad *iload) {
	int id;
	TCHAR *buf;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case VUE_FILENAME_CHUNKID:	
				if (IO_OK==iload->ReadWStringChunk(&buf)) 
					vueFileName = buf;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\rendvue.h ===
/**********************************************************************
 *<
	FILE: rendvue.h

	DESCRIPTION: .VUE file renderer class definition

	CREATED BY: Dan Silva

	HISTORY: created 10/8/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef RENDVUE__H
#define RENDVUE__H

#define VREND_CLASS_ID Class_ID(5,0);

class VueRenderer : public Renderer {
	public:
		TSTR vueFileName;
		FILE *vuefile;
		INode *sceneNode;
		INode *viewNode;
		ViewParams viewParams; // view params for rendering ortho or user viewport
		RendParams RP;  	// common renderer parameters
		BOOL anyLights;
		TCHAR buffer[256];
		int nlts,nobs;
		VueRenderer() { vuefile = NULL; sceneNode = NULL; viewNode = NULL; anyLights = FALSE; nlts = nobs = 0; }
		int Open(
			INode *scene,     	// root node of scene to render
			INode *vnode,     	// view node (camera or light), or NULL
			ViewParams *viewPar,// view params for rendering ortho or user viewport
			RendParams &rp,  	// common renderer parameters
			HWND hwnd, 				// owner window, for messages
			DefaultLight* defaultLights=NULL, // Array of default lights if none in scene
			int numDefLights=0	// number of lights in defaultLights array
			);
		int Render(
			TimeValue t,   			// frame to render.
   			Bitmap *tobm, 			// optional target bitmap
			FrameRendParams &frp,	// Time dependent parameters
			HWND hwnd, 				// owner window
			RendProgressCallback *prog=NULL,
			ViewParams *vp=NULL
			);
		void Close(	HWND hwnd );		
		RefTargetHandle Clone(RemapDir &remap);

		// Adds rollup page(s) to renderer configure dialog
		// If prog==TRUE then the rollup page should just display the parameters
		// so the user has them for reference while rendering, they should not be editable.
		RendParamDlg *CreateParamDialog(IRendParams *ir,BOOL prog=FALSE);
		void ResetParams();
		void DeleteThis() { delete this;  }
		Class_ID ClassID() { return VREND_CLASS_ID;}
		void GetClassName(TSTR& s) {s = GetString(IDS_VRENDTITLE);}
		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		void WriteViewNode(INode* vnode, TimeValue t);
		void WriteViewParams(ViewParams *v);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\rvuepch.h ===
/**********************************************************************
 *<
	FILE: rvuepch.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef RVUEPCH__H

#define RVUEPCH_H

#include "max.h"
extern HINSTANCE hInstance;
extern ClassDesc* GetRendVueDesc();
TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rendvue.rc
//
#define IDS_RENDVUETITLE                1
#define IDS_VRENDTITLE                  2
#define IDS_RENDVUE_OPTIONS             3
#define IDS_WRITE_VUEFILE               4
#define IDS_RENDVUE_FILE_OVERWRITE      5
#define IDS_RENDER_ERR                  6
#define IDS_CANT_OPEN                   7
#define IDS_VUE_FILE                    8
#define IDS_FILE_ALREADY_EXISTS         9
#define IDD_DIALOG1                     101
#define IDD_RENDVUE_PARAMS              171
#define IDD_RENDVUE_PROG                176
#define IDC_RENDVUE_FILE                1000
#define IDC_RENDVUE_FILENAME            1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\rvuepch.cpp ===
/**********************************************************************
 *<
	FILE: rvuepch.cpp

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "rvuepch.h"
#include "resource.h"


HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;


	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}
	
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RENDVUETITLE); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() { return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetRendVueDesc();
		default: return 0;
		}
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() {
	return VERSION_3DSMAX; 
	}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplersHdr.cpp ===
////////////////////////////////////////////////////////////////
//	precompiled header for samplers
//
#include	"samplersHdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\RendVue\vuedlg.cpp ===
/**********************************************************************
 *<
	FILE: vuedlg.cpp

	DESCRIPTION: .VUE file selector

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "rvuepch.h"
#include "resource.h"
#include "rendvue.h"

class RendVueParamDlg : public RendParamDlg {
public:
	VueRenderer *rend;
	IRendParams *ir;
	HWND hPanel;
	BOOL prog;
	HFONT hFont;
	TSTR workFileName;
	RendVueParamDlg(VueRenderer *r,IRendParams *i,BOOL prog);
	~RendVueParamDlg();
	void AcceptParams();
	void DeleteThis() {delete this;}
	void InitParamDialog(HWND hWnd);
	void InitProgDialog(HWND hWnd);
	void ReleaseControls() {}
	BOOL FileBrowse();
	BOOL WndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
	};

RendVueParamDlg::~RendVueParamDlg()
	{
	DeleteObject(hFont);
	ir->DeleteRollupPage(hPanel);
	}

BOOL RendVueParamDlg::WndProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			if (prog) InitProgDialog(hWnd);
			else InitParamDialog(hWnd);
			break;
		
		case WM_DESTROY:
			if (!prog) ReleaseControls();
			break;
		default:
			return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK RendVueParamDlgProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	RendVueParamDlg *dlg = (RendVueParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG:
			dlg = (RendVueParamDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;
		case WM_LBUTTONDOWN:
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
			dlg->ir->RollupMouseMessage(hWnd,msg,wParam,lParam);
			break;
		case WM_COMMAND:
			case IDC_RENDVUE_FILE:
				if (dlg->FileBrowse()) {
					SetDlgItemText(hWnd,IDC_RENDVUE_FILENAME, dlg->workFileName.data());
					}
				break;
		case CC_SPINNER_CHANGE:   
			{
			}
			break;
		}	
	if (dlg) return dlg->WndProc(hWnd,msg,wParam,lParam);
	else return FALSE;
	}

RendVueParamDlg::RendVueParamDlg(
		VueRenderer *r,IRendParams *i,BOOL prog)
	{
	hFont      = hFont = CreateFont(14,0,0,0,FW_BOLD,0,0,0,0,0,0,0, VARIABLE_PITCH | FF_SWISS, _T(""));
	rend       = r;
	ir         = i;
	this->prog = prog;
	if (prog) {		
		hPanel = ir->AddRollupPage(
			hInstance, 
			MAKEINTRESOURCE(IDD_RENDVUE_PROG),
			RendVueParamDlgProc,
			GetString(IDS_VRENDTITLE),
			(LPARAM)this);
	} else {
		hPanel = ir->AddRollupPage(
			hInstance, 
			MAKEINTRESOURCE(IDD_RENDVUE_PARAMS),
			RendVueParamDlgProc,
			GetString(IDS_VRENDTITLE),
			(LPARAM)this);
		}
	}

void RendVueParamDlg::InitParamDialog(HWND hWnd) {
	workFileName = rend->vueFileName;
	SetDlgItemText(hWnd,IDC_RENDVUE_FILENAME, workFileName);
	}

void RendVueParamDlg::InitProgDialog(HWND hWnd) {
	SetDlgItemText(hWnd,IDC_RENDVUE_FILENAME, rend->vueFileName.data());
	}

void RendVueParamDlg::AcceptParams() {
	rend->vueFileName = workFileName;
	}

RendParamDlg * VueRenderer::CreateParamDialog(IRendParams *ir,BOOL prog) {
	return new RendVueParamDlg(this,ir,prog);
	}



// File Browse ------------------------------------------------------------
BOOL FileExists(TCHAR *filename) {
     HANDLE findhandle;
     WIN32_FIND_DATA file;
     findhandle = FindFirstFile(filename,&file);
     FindClose(findhandle);
     if (findhandle == INVALID_HANDLE_VALUE)
        return(FALSE);
     else
        return(TRUE);
	}

BOOL RunningNewShell() 
	{
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&os);
	if (os.dwPlatformId == VER_PLATFORM_WIN32_NT && os.dwMajorVersion < 4)
		return FALSE;
	return TRUE;
	}
	

#define VUEEXT _T(".vue")
#define VUEFILTER _T("*.vue")

void FixFileExt(OPENFILENAME &ofn, TCHAR* ext = VUEEXT) {
	int l = _tcslen(ofn.lpstrFile);
	int e = _tcslen(ext);
	if (_tcsicmp(ofn.lpstrFile+l-e, ext)) {
		_tcscat(ofn.lpstrFile,ext);	
		}
	}

#if 0
BOOL WINAPI FileHook( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
	{
	switch (message) {
		case WM_INITDIALOG:
			SetDlgItemText(hDlg, IDOK, _T("OK"));
			break;
		case WM_COMMAND:{
			}
			
			break;
		}
	return FALSE;
	}  

BOOL PMFileHook(HWND hWnd,UINT message,WPARAM wParam,LPARAM	lParam) 
	{
	switch (message) {
		case WM_INITDIALOG:
			SetDlgItemText(hWnd, IDOK, _T("OK"));
			break;
		case WM_COMMAND:{
			}
			
			break;
		}
	return 0;
	}
#endif

BOOL RendVueParamDlg::FileBrowse() {
	int tried = 0;
	FilterList filterList;
	HWND hWnd = hPanel;
	static int filterIndex = 1;
    OPENFILENAME  ofn;
	TSTR filename;
    TCHAR fname[512];
	TCHAR saveDir[1024];
		{
		TSTR dir;
		SplitFilename(workFileName, &dir, &filename,NULL);
		_tcscpy(saveDir,dir.data());
		}
	_tcscpy(fname,filename.data());
	_tcscat(fname, VUEEXT);

	filterList.Append(GetString(IDS_VUE_FILE));
	filterList.Append(VUEFILTER);

    memset(&ofn, 0, sizeof(OPENFILENAME));

    ofn.lStructSize      = sizeof(OPENFILENAME);
    ofn.hwndOwner        = hWnd;
	ofn.hInstance        = hInstance;	


	ofn.nFilterIndex = filterIndex;
    ofn.lpstrFilter  = filterList;

    ofn.lpstrTitle   = GetString(IDS_WRITE_VUEFILE); 
    ofn.lpstrFile    = fname;
    ofn.nMaxFile     = sizeof(fname) / sizeof(TCHAR);      

	Interface *iface = GetCOREInterface();
	
	if(saveDir[0])
	   	ofn.lpstrInitialDir = saveDir;
	else
  	 	ofn.lpstrInitialDir = iface->GetDir(APP_SCENE_DIR);

	if(RunningNewShell()) {
		ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER /* | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE*/;  // OFN_OVERWRITEPROMPT;
		ofn.lpfnHook = NULL;// (LPOFNHOOKPROC)FileHook;
		ofn.lCustData = 0;		// 0 for save, 1 for open
//		ofn.lpTemplateName = MAKEINTRESOURCE(IDD_EXT_FILE);
	}
	else {
		ofn.Flags			  =	OFN_HIDEREADONLY | OFN_PATHMUSTEXIST /* |OFN_ENABLEHOOK  | OFN_ENABLETEMPLATE */;
		ofn.lpfnHook		  =	NULL; // (LPOFNHOOKPROC)PMFileHook;
		ofn.lCustData		  =	0;
//		ofn.lpTemplateName	  =	MAKEINTRESOURCE(IDD_PM_EXT_FILE);
	}

	FixFileExt(ofn,VUEEXT); // add ".vue" if absent

	while (GetSaveFileName(&ofn)) 	{
		FixFileExt(ofn,VUEEXT); // add ".vue" if absent

		workFileName = ofn.lpstrFile;
		return TRUE;
		}
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplersHdr.h ===
/**********************************************************************
 *<
	FILE: samplersHdr.h

	DESCRIPTION: Hearder for samplers DLL

	CREATED BY: Kells Elmquist

	HISTORY:

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef SAMPLERS_HDR__H
#define SAMPLERS_HDR__H

#include "max.h"
#include "texutil.h"
#include "samplers.h"
#include "samplersRes.h"

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplersRes.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by samplers.rc
//
#define IDS_KE_SAMPLERS_DESC            1
#define IDS_KE_SINGLE_SAMPLER           2
#define IDS_KE_PARAMETERS               3
#define IDS_KE_QUALITY                  4
#define IDS_KE_SINGLE_COMMENT           5
#define IDS_KE_R25_SAMPLER              6
#define IDS_KE_R25_COMMENT              7
#define IDS_KE_ENABLE                   8
#define IDS_KE_UNIFORM_SAMPLER          9
#define IDS_KE_UNIFORM_COMMENT          10
#define IDS_KE_CMJ_SAMPLER              11
#define IDS_KE_CMJ_COMMENT              12
#define IDS_KE_HAMM_SAMPLER             13
#define IDS_KE_HAMM_COMMENT             14
#define IDS_KE_HALTON_SAMPLER           15
#define IDS_KE_HALTON_COMMENT           16
#define IDS_KE_AHALTON_SAMPLER          17
#define IDS_KE_AHALTON_COMMENT          18
#define IDS_KE_ACMJ_SAMPLER             19
#define IDS_KE_ACMJ_COMMENT             20
#define IDS_KE_SUBSAMP_TEX              21
#define IDS_KE_ADAPT_ENABLE             22
#define IDS_KE_ADAPT_THRESHOLD          23

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1728
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplerUtil.cpp ===
/////////////////////////////////////////////////////////////////////////
// 
//	FILE: SamplerUtil.cpp	
//
//	DESCRIPTION:Standard sampler plugin utilities
//
//	Created Kells Elmquist, 8 dec 1998
//

#include "samplersHdr.h"
#include "samplerUtil.h"
#include "stdSamplers.h"

// from old rendpost code
// #define mul 0x00004000 
// #define mur 0x00000200 
// #define mll 0x00400000
// #define mlr 0x00020000
//			if (ab->mask[1]&mlr) { // Lower Right (+X +Y)
//			if (ab->mask[0]&mur) { // Upper Right (+X -Y)
//			if (ab->mask[0]&mul) { // Upper Left (-X -Y)
//			if (ab->mask[1]&mll) { // Lower Left (-X +Y)

BOOL sampleInMask( Point2& sample,  MASK m )
{
	int x = int( sample.x * 8.0f );	// cd be 7.999
	x = bound( x, 0, 7 );
	int y = int( sample.y * 8.0f );
	y = bound( y, 0, 7 );
	BYTE * pMask = (BYTE*)m;
	BYTE b = pMask[ y ];		// >>>>< polarity? 8-y ?

	BYTE in = b & (0x80 >> x) ;		// >>>>< polarity?
	return in > 0;
}


RefResult intNotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_ENABLE: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				case PB_QUALITY: gpd->dim = defaultDim; break;
				case PB_SUBSAMP_TEX: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				default: 	     gpd->dim = defaultDim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_ENABLE : gpn->name = _T( GetString(IDS_KE_ENABLE) ); break;
				case PB_QUALITY : gpn->name = _T( GetString(IDS_KE_QUALITY) ); break;
				case PB_SUBSAMP_TEX : gpn->name = _T( GetString(IDS_KE_SUBSAMP_TEX) ); break;
				default:		  gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}


RefResult adaptNotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_ENABLE: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				case PB_QUALITY: gpd->dim = defaultDim; break;
				case PB_ADAPT_ENABLE: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				case PB_ADAPT_THRESHOLD: gpd->dim = defaultDim; break;
				case PB_SUBSAMP_TEX_ADAPT: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				default: 	     gpd->dim = defaultDim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_ENABLE : gpn->name = _T( GetString(IDS_KE_ENABLE) ); break;
				case PB_QUALITY : gpn->name = _T( GetString(IDS_KE_QUALITY) ); break;
				case PB_SUBSAMP_TEX_ADAPT : gpn->name = _T( GetString(IDS_KE_SUBSAMP_TEX) ); break;
				case PB_ADAPT_ENABLE : gpn->name = _T( GetString(IDS_KE_ADAPT_ENABLE) ); break;
				case PB_ADAPT_THRESHOLD : gpn->name = _T( GetString(IDS_KE_ADAPT_THRESHOLD) ); break;
				default:		  gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplerUtil.h ===
/////////////////////////////////////////////////////////////////////////
// 
//	FILE: SamplerUtil.h	
//
//	DESCRIPTION:Standard sampler plugin utilities
//
//	Created Kells Elmquist, 8 dec 1998
//

#ifndef SAMPLER_UTIL_H
#define SAMPLER_UTIL_H


#define ALL_ONES	0xffffffffL

inline void setMask( MASK m, ULONG v ) { m[0] = m[1] = v; }
inline void copyMask( MASK to, MASK from ) { to[0] = from[0]; to[1]=from[1];}
inline BOOL centerInMask( MASK m ){ return TRUE; } //>>>>>><

inline float bound( float v, float min=0.0f, float max=1.0f )
	{ return (v < min)? min : (v > max)? max : v; }
inline int bound( int v, int min=0, int max=1 )
	{ return (v < min)? min : (v > max)? max : v; }


BOOL sampleInMask( Point2& sample,  MASK m );


RefResult intNotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message);

RefResult adaptNotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message); 

// fixed, base 2....tests show this one works the best
inline float radicalInverse2( int n ) {
	float out = 0.0f;
	float digitVal = 0.5;
	for( int i = n; i > 0; i >>=1 ) {
		if ( i & 0x1 )
			out += digitVal;
		digitVal *= 0.5f;
	}
	return out;
}

inline float radicalInverse( int n, int base ) {
	float out = 0.0f;
	float digitMult = 1.0f / float(base);
	float digitVal = digitMult;
	for( int i = n; i > 0; i /= base ) {
		int d = i % base;
		if ( d )
			out += d * digitVal;
		digitVal *= digitMult;
	}
	return out;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\samplersMain.cpp ===
/**********************************************************************
 *<
	FILE: samplersMain.cpp

	DESCRIPTION:   	DLL main for samplers

	CREATED BY: 	Kells Elmquist

	HISTORY: 	created 1 dec 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "samplersHdr.h"
#include "stdSamplers.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();

		// register SXP readers
		// RegisterSXPReader(_T("MARBLE_I.SXP"), Class_ID(MARBLE_CLASS_ID,0));
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR * LibDescription() { return GetString(IDS_KE_SAMPLERS_DESC); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() 
{
#ifndef DESIGN_VER
	return 4;
#else
	return 4;
#endif // !DESIGN_VER
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		// Both versions
		case 0: return GetR25SamplerDesc();
		case 1: return GetHammersleySamplerDesc();
		case 2: return GetAHaltonSamplerDesc();
		case 3: return GetACMJSamplerDesc();
//		case 4: return GetUniformSamplerDesc();
//		case 5: return GetHaltonSamplerDesc();
//		case 6: return GetSingleSamplerDesc();
//		case 7: return GetCMJSamplerDesc();

#ifndef DESIGN_VER	// Not Design version

#else  // DESIGN_VER

#endif // DESIGN_VER

		default: return 0;
	}
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\stdSamplers.cpp ===
/**********************************************************************
 *<
	FILE: StdSamplers.cpp	

	DESCRIPTION:Standard sampler plugins

	Created Kells Elmquist, 1 dec 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "samplersHdr.h"
#include "stdSamplers.h"
#include "samplersRes.h"
#include "samplerUtil.h"
#include "macrorec.h"

// change sample sz depending on density
static BOOL sampleSzOn = TRUE;

//////////////////////////////////////////////////////////////////////////
//	 Parameter Block
//

#define ANIMATE		TRUE
#define NO_ANIMATE	FALSE

#define PBLOCK_LENGTH 3

static ParamBlockDescID pbDesc[ PBLOCK_LENGTH ] = {
	{ TYPE_FLOAT, NULL, 0, PB_QUALITY }, // Quality, not used but saved
	{ TYPE_BOOL,  NULL, 0, PB_ENABLE },  // Enable
	{ TYPE_BOOL,  NULL, 0, PB_SUBSAMP_TEX },  // Enable texture subsampling
}; 	


#define NUM_OLDVERSIONS	2
static ParamVersionDesc oldVersions[NUM_OLDVERSIONS] = {
	ParamVersionDesc(pbDesc,2, 0),
	ParamVersionDesc(pbDesc,2, 1),
};

#define PB_CURRENT_VERSION	2

static ParamVersionDesc curVersion(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION);

static MASK fullMask = {0xffffffff,0xffffffff};

////////////////////////////////////////////////////////////////////////////
//	Rev 2.5:  A x5 Center-Corner Sampler
//
Class_ID R25SamplerClassID( R25_SAMPLER_CLASS_ID , 0);

class R25Sampler: public Sampler {
	ShadeContext* pSC;
	BOOL texSuperSampleOn;

	public:
		// Parameters
		IParamBlock *pParamBlk;

		R25Sampler();
		void DeleteThis() { delete this; };
		RefTargetHandle Clone( RemapDir &remap=NoRemap() );

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		Class_ID ClassID() {return R25SamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_R25_SAMPLER ); }
		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		// this starts a sample sequence loop for the area of the mask
		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
								ShadeContext* sc, MASK pMask );
		
		// This is the function that is called internally to get the next sample 
		BOOL NextSample( Point2* pOutPt, float* pSampleSz, int n );

		// integer number of samples for current quality
		int GetNSamples(){ return 5; }	

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
			}
		int SupportsQualityLevels() { return 0; }

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_R25_COMMENT); }
		ULONG SupportsStdParams(){ return SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

	};


class R25SamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new R25Sampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_R25_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return R25SamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static R25SamplerClassDesc r25SamplerCD;
ClassDesc* GetR25SamplerDesc() { return &r25SamplerCD; }



//--- Rev 2.5 Sampler, frag corners & center -------------------------------


R25Sampler::R25Sampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	GetCOREInterface()->GetMacroRecorder()->Disable();
	pParamBlk->SetValue(PB_ENABLE, 0, 0 );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	GetCOREInterface()->GetMacroRecorder()->Enable();
	texSuperSampleOn = TRUE; 
}

RefTargetHandle R25Sampler::Clone( RemapDir &remap )
{
	R25Sampler*	mnew = new R25Sampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}


RefResult R25Sampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return intNotifyRefChanged( changeInt, hTarget, partID,  message);
}

/*********
RefResult R25Sampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_SUBSAMP_TEX: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				case PB_ENABLE: gpd->dim = defaultDim; break; //>>>>>< BOOL ??
				case PB_QUALITY: gpd->dim = defaultDim; break;
				default: 	     gpd->dim = defaultDim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_ENABLE : gpn->name = _T( GetString(IDS_KE_QUALITY) ); break;
				case PB_QUALITY : gpn->name = _T( GetString(IDS_KE_QUALITY) ); break;
				case PB_SUBSAMP_TEX : gpn->name = _T( GetString(IDS_KE_SUBSAMP_TEX) ); break;
				default:		  gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}
**********/
IOResult R25Sampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = PB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class R25SamplerCB: public PostLoadCallback {
	public:
		R25Sampler *s;
		int loadVersion;
	    R25SamplerCB(R25Sampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {

			 s->SetTextureSuperSampleOn( FALSE );
			 delete this;
		}
};

IOResult R25Sampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < PB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUM_OLDVERSIONS, &curVersion, this,0));
		iload->RegisterPostLoadCallback(new R25SamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


#define FAC 0.3125f
#define N_R25SAMPLES	5

void R25Sampler::DoSamples( Color& cOut, Color& tOut, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	Point2 sample;
	float sampleScale;
	float nSamples = 0.0f;
	pSC = sc;
	cOut.r = cOut.g = cOut.b = tOut.r = tOut.g = tOut.b = 0;
	int n = 0;

	while( NextSample( &sample, &sampleScale, n++ ) ){

		if ( sampleInMask( sample, mask ) ) {
			Color c, t;
			// NB, returns true for unclipped samples
			if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
				cOut += c;
				tOut += t;
				nSamples += 1.0f;
			}
		}
		
	} // end, while samples

	if ( nSamples == 0.0f ){
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( cOut, tOut, sample, 1.0f );
	} else {
		cOut /= nSamples;
		tOut /= nSamples;
	}
}


BOOL R25Sampler::NextSample( Point2* pOut, float* pSampleSz, int n )
{
	if ( n >= N_R25SAMPLES ) return FALSE;
	*pSampleSz = GetTextureSuperSampleOn() ? 0.5f : 1.0f;
	pOut->x = 0.5f;	pOut->y = 0.5f;	
	switch( n ) {
	 case 0 : pOut->x += FAC; pOut->y += FAC; break;
	 case 1 : pOut->x += FAC; pOut->y += -FAC; break;
	 case 2 : pOut->x += -FAC; pOut->y += -FAC; break;
	 case 3 : pOut->x += -FAC; pOut->y += FAC; break;
	 case 4 : { *pOut = pSC->SurfacePtScreen(); } break;

	 default :	break;
	}
	return TRUE;
}


///////////////////////////////////////////////////////////////


Class_ID UniformSamplerClassID( UNIFORM_SAMPLER_CLASS_ID , 0);



////////////////////////////////////////////////////////////////////////////
//	Regular, variable quality Sampler: n x n samples w/ n== 1..6
//
#define	N_UNIFORM_MAX_SAMPLES	6	// 6x6 samples max
#define	N_UNIFORM_MAX_SAMPLES2  (N_UNIFORM_MAX_SAMPLES*N_UNIFORM_MAX_SAMPLES)

class UniformSampler: public Sampler {
	public:
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;

		UniformSampler();
		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		Class_ID ClassID() {return UniformSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_UNIFORM_SAMPLER ); }
		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		// this starts a sample sequence loop for the area of the mask
		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
								ShadeContext* sc, MASK pMask );
		
		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
			}
		int SupportsQualityLevels() { return N_UNIFORM_MAX_SAMPLES; }

		// integer number of samples for current quality
		int GetNSamples();
		int GetSideSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_UNIFORM_COMMENT); }
		ULONG SupportsStdParams(){ return SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

	};


class UniformSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new UniformSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_UNIFORM_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return UniformSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static UniformSamplerClassDesc uniformSamplerCD;
ClassDesc* GetUniformSamplerDesc() { return &uniformSamplerCD; }



//--- UniformSampler -------------------------------


UniformSampler::UniformSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, 0 );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle UniformSampler::Clone( RemapDir &remap )
{
	UniformSampler*	mnew = new UniformSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}


int UniformSampler::GetSideSamples()
{
	int side = int( GetQuality() * N_UNIFORM_MAX_SAMPLES );
	if (side < 2 ) side = 2;
	if (side > N_UNIFORM_MAX_SAMPLES ) side = N_UNIFORM_MAX_SAMPLES;
	return side;
}	

int UniformSampler::GetNSamples()
{
	int side = GetSideSamples();
	return side * side;
}	


RefResult UniformSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return intNotifyRefChanged( changeInt, hTarget, partID,  message);
}

IOResult UniformSampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = PB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class UniformSamplerCB: public PostLoadCallback {
	public:
		UniformSampler *s;
		int loadVersion;
	    UniformSamplerCB(UniformSampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult UniformSampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < PB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUM_OLDVERSIONS, &curVersion, this,0));
		iload->RegisterPostLoadCallback(new UniformSamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


void UniformSampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	int sideSamples = GetSideSamples();
	int numSamples = sideSamples * sideSamples;
	DbgAssert( sideSamples > 0 );
	// we map 0...sideSz into 0..1
	float sideSzInv = 1.0f / float(sideSamples);
	float sampleScale = texSuperSampleOn ? sideSzInv : 1.0f;	

	Point2 sample;
	float nSamples = 0.0f;
	clr.r = clr.g = clr.b = trans.r = trans.g = trans.b = 0;

	// Sampling loop
	for( int y = 0; y < sideSamples; ++y ) {
		sample.y = (float(y) + 0.5f) * sideSzInv;

		for( int x = 0; x < sideSamples; ++x ) {
			sample.x =  (float(x) + 0.5f) * sideSzInv;
	
			if ( sampleInMask( sample, mask ) ) {
				Color c, t;
				// NB, returns true for unclipped samples
				if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
					clr += c;
					trans += t;
					nSamples += 1.0f;
				}
			}
		}
	}

	// Check for 0 samples
	if ( nSamples == 0.0f ){
		// use frag center if no other samples
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( clr, trans, sample, 1.0f );
	} else {
		clr /= nSamples;
		trans /= nSamples;
	}
}


////////////////////////////////////////////////////////////////////////////////
//	Canonical Multi-Jitter: variable quality Sampler: n x n samples w/ n== 1..6
//
#define	N_CMJ_MAX_SIDESAMPLES	6	// 6x6 samples max

Class_ID CMJSamplerClassID( CMJ_SAMPLER_CLASS_ID , 0);

class CMJSampler: public Sampler {

	public:
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;

		CMJSampler();
		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		Class_ID ClassID() {return CMJSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_CMJ_SAMPLER ); }
		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		// this starts a sample sequence loop for the area of the mask
		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
								ShadeContext* sc, MASK pMask );

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
			}
		int SupportsQualityLevels() { return N_CMJ_MAX_SIDESAMPLES; }

		// integer number of samples for current quality
		int GetNSamples();
		int GetSideSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_CMJ_COMMENT); }
		ULONG SupportsStdParams(){ return SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

	};


class CMJSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new CMJSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_CMJ_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return CMJSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static CMJSamplerClassDesc CMJSamplerCD;
ClassDesc* GetCMJSamplerDesc() { return &CMJSamplerCD; }



//--- Canonical Multi-Jitter (w/ no jitter) Sampler -------------------------------


CMJSampler::CMJSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, 0 );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle CMJSampler::Clone( RemapDir &remap )
{
	CMJSampler*	mnew = new CMJSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}

int CMJSampler::GetSideSamples()
{
	int side = int( GetQuality() * N_CMJ_MAX_SIDESAMPLES );
	if (side < 2 ) side = 2;
	if (side > N_CMJ_MAX_SIDESAMPLES ) side = N_CMJ_MAX_SIDESAMPLES;
	return side;
}	

int CMJSampler::GetNSamples()
{
	int side = GetSideSamples();
	return side * side;
}	


RefResult CMJSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return intNotifyRefChanged( changeInt, hTarget, partID,  message);
}
IOResult CMJSampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = PB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class CMJSamplerCB: public PostLoadCallback {
	public:
		CMJSampler *s;
		int loadVersion;
	    CMJSamplerCB(CMJSampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult CMJSampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < PB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUM_OLDVERSIONS, &curVersion, this,0));
		iload->RegisterPostLoadCallback(new CMJSamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


void CMJSampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	int sideSamples = GetSideSamples();
	int numSamples = sideSamples * sideSamples;
	DbgAssert( sideSamples > 0 );

	float sampleScale = texSuperSampleOn ? 1.0f / float(sideSamples) : 1.0f;	

	float subCellSz = 1.0f / float( numSamples );
	float halfSubCell = subCellSz * 0.5f;

	Point2 sample;
	float nSamples = 0.0f;
	clr.r = clr.g = clr.b = trans.r = trans.g = trans.b = 0;

	// Sampling loop
	for( int y = 0; y < sideSamples; ++y ) {
		for( int x = 0; x < sideSamples; ++x ) {

			sample.x = (float(x * sideSamples)+ float(y) + 0.5f) * subCellSz;
			sample.y = (float(y * sideSamples)+ float(x) + 0.5f) * subCellSz;
	
			if ( sampleInMask( sample, mask ) ) {
				Color c, t;
				// NB, returns true for unclipped samples
				if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
					clr += c;
					trans += t;
					nSamples += 1.0f;
				}
			}
		}
	}

	// Check for 0 samples
	if ( nSamples == 0.0f ){
		// use frag center if no other samples
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( clr, trans, sample, 1.0f );
	} else {
		clr /= nSamples;
		trans /= nSamples;
	}
}


////////////////////////////////////////////////////////////////////////////////
//	Hammersley: variable quality Sampler: n cols of 1 sample
//
#define	N_HAMM_MAX_SAMPLES	40	

Class_ID HammersleySamplerClassID( HAMMERSLEY_SAMPLER_CLASS_ID , 0);

class HammersleySampler: public Sampler {

	public:
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;

		HammersleySampler();
		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		Class_ID ClassID() {return HammersleySamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_HAMM_SAMPLER ); }

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
								ShadeContext* sc, MASK pMask );

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
			}
		int SupportsQualityLevels() { return N_HAMM_MAX_SAMPLES; }

		// integer number of samples for current quality
		int GetNSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_HAMM_COMMENT); }
		ULONG SupportsStdParams(){ return SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }
	};


class HammersleySamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new HammersleySampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_HAMM_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return HammersleySamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static HammersleySamplerClassDesc HammersleySamplerCD;
ClassDesc* GetHammersleySamplerDesc() { return &HammersleySamplerCD; }



//--- Hammersley Sampler -------------------------------


HammersleySampler::HammersleySampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, 0 );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle HammersleySampler::Clone( RemapDir &remap )
{
	HammersleySampler*	mnew = new HammersleySampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}


int HammersleySampler::GetNSamples()
{
	int n = int( GetQuality() * N_HAMM_MAX_SAMPLES );
	return (n < 4) ? 4 : n;
}	


RefResult HammersleySampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return intNotifyRefChanged( changeInt, hTarget, partID,  message);
}

IOResult HammersleySampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = PB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class HammersleySamplerCB: public PostLoadCallback {
	public:
		HammersleySampler *s;
		int loadVersion;
	    HammersleySamplerCB(HammersleySampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult HammersleySampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < PB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUM_OLDVERSIONS, &curVersion, this,0));
		iload->RegisterPostLoadCallback(new HammersleySamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


void HammersleySampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	int numSamples = GetNSamples();
	DbgAssert( numSamples > 0 );

	float sampleScale = texSuperSampleOn ? 1.0f / sqrtf( float(numSamples) ) : 1.0f;	

	IPoint2 s = sc->ScreenCoord(); 
	int nx = sc->globContext->devWidth;
	int nSample = ( s.y * nx + s.x ) * numSamples;

	Point2 sample;
	float nSamples = 0.0f;
	clr.r = clr.g = clr.b = trans.r = trans.g = trans.b = 0;

	// Sampling loop
	for( int n = 0; n < numSamples; ++n ) {

		sample.x = radicalInverse2( nSample + n  );
		sample.y = (float(n)+0.5f)/numSamples;

		if ( sampleInMask( sample, mask ) ) {
			Color c, t;
			// NB, returns true for unclipped samples
			if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
				clr += c;
				trans += t;
				nSamples += 1.0f;
			}
		}
	}

	// Check for 0 samples
	if ( nSamples == 0.0f ){
		// use frag center if no other samples
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( clr, trans, sample, 1.0f );
	} else {
		clr /= nSamples;
		trans /= nSamples;
	}
}




////////////////////////////////////////////////////////////////////////////////
//	Halton: variable quality Sampler: a double hammersley
//
#define	N_HALTON_MAX_SAMPLES	40	

static int baseA = 2;
static int baseB = 3;

Class_ID HaltonSamplerClassID( HALTON_SAMPLER_CLASS_ID , 0);

class HaltonSampler: public Sampler {

	public:
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;

		HaltonSampler();
		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		Class_ID ClassID() {return HaltonSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_HALTON_SAMPLER ); }

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
						ShadeContext* sc, MASK pMask );

		// integer number of samples for current quality
		int GetNSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
		}

		int SupportsQualityLevels() { return N_HALTON_MAX_SAMPLES; }
		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_HALTON_COMMENT); }
		ULONG SupportsStdParams(){ return SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

	};


class HaltonSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new HaltonSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_HALTON_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return HaltonSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static HaltonSamplerClassDesc HaltonSamplerCD;
ClassDesc* GetHaltonSamplerDesc() { return &HaltonSamplerCD; }



//--- Halton Sampler -------------------------------


HaltonSampler::HaltonSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, PB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, 0 );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle HaltonSampler::Clone( RemapDir &remap )
{
	HaltonSampler*	mnew = new HaltonSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}


int HaltonSampler::GetNSamples()
{
	int n = int( GetQuality() * N_HAMM_MAX_SAMPLES );
	return (n < 4) ? 4 : n;
}	


RefResult HaltonSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return intNotifyRefChanged( changeInt, hTarget, partID,  message);
}
IOResult HaltonSampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = PB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class HaltonSamplerCB: public PostLoadCallback {
	public:
		HaltonSampler *s;
		int loadVersion;
	    HaltonSamplerCB(HaltonSampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult HaltonSampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < PB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldVersions,NUM_OLDVERSIONS, &curVersion, this,0));
		iload->RegisterPostLoadCallback(new HaltonSamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


void HaltonSampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{

	int numSamples = GetNSamples();
	DbgAssert( numSamples > 0 );

	float sampleScale = texSuperSampleOn ? 1.0f / sqrtf( float(numSamples) ) : 1.0f;	

	IPoint2 s = sc->ScreenCoord(); 
	int nx = sc->globContext->devWidth;
	int nSample = ( s.y * nx + s.x ) * numSamples;

	Point2 sample;
	float nSamples = 0.0f;
	clr.r = clr.g = clr.b = trans.r = trans.g = trans.b = 0;

	// Sampling loop
	for( int n = 0; n < numSamples; ++n ) {

		sample.x = radicalInverse2( nSample + n  );
		sample.y = radicalInverse( nSample + n, baseB );

		if ( sampleInMask( sample, mask ) ) {
			Color c, t;
			// NB, returns true for unclipped samples
			if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
				clr += c;
				trans += t;
				nSamples += 1.0f;
			}
		}
	}

	// Check for 0 samples
	if ( nSamples == 0.0f ){
		// use frag center if no other samples
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( clr, trans, sample, 1.0f );
	} else {
		clr /= nSamples;
		trans /= nSamples;
	}
}


////////////////////////////////////////////////////////////////////////////////
//	Adaptive Parameter Block
//
#define APBLOCK_LENGTH 5

static ParamBlockDescID apbDesc[ APBLOCK_LENGTH ] = {
	{ TYPE_FLOAT, NULL, 0, PB_QUALITY },			// Quality
	{ TYPE_BOOL,  NULL, 0, PB_ENABLE },		 		// Enable
	{ TYPE_BOOL,  NULL, 0, PB_SUBSAMP_TEX },		// subsample textures on
	{ TYPE_BOOL,  NULL, 0, PB_ADAPT_ENABLE },		// AdaptiveEnable
	{ TYPE_FLOAT, NULL, 0, PB_ADAPT_THRESHOLD },	// Threshold
}; 	

#define NUM_OLDAVERSIONS	2
static ParamVersionDesc oldAVersions[NUM_OLDAVERSIONS] = {
	ParamVersionDesc(apbDesc,4, 0),
	ParamVersionDesc(apbDesc,4, 1),
};

#define APB_CURRENT_VERSION	2

static ParamVersionDesc curAVersion(apbDesc, APBLOCK_LENGTH, APB_CURRENT_VERSION);

//------------------------------------------------------------------
static inline float Max( Color& c )
{ return c.r > c.g ? (c.r > c.b ? c.r : c.b) : (c.g > c.b ? c.g : c.b); }
static inline float Max( float a, float b ){ return a > b ? a : b; }
static inline float Max( float a, float b, float c  )
{ return a>b ? (a > c ? a : c) : (b > c ? b : c); }

static inline void Abs( Color& c )
{ if (c.r < 0.0f) c.r = -c.r; if (c.g < 0.0f) c.g = -c.g; if (c.b < 0.0f) c.b = -c.b;}
static inline float Abs( float a ){ return a < 0.0f ? -a : a; }

////////////////////////////////////////////////////////////////////////////////
//	Adaptive Halton: variable quality Sampler: a double hammersley
//
static int nAdaptiveSamples = 4;


Class_ID AHaltonSamplerClassID( AHALTON_SAMPLER_CLASS_ID , 0);

class AdaptiveHaltonSampler: public Sampler {
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;
	public:

		AdaptiveHaltonSampler();

		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		Class_ID ClassID() {return AHaltonSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_AHALTON_SAMPLER ); }

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
						ShadeContext* sc, MASK pMask );

		// integer number of samples for current quality
		int GetNSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
		}

		int SupportsQualityLevels() { return N_HALTON_MAX_SAMPLES; }
		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_AHALTON_COMMENT); }

		// Adaptive Sampling
		ULONG SupportsStdParams(){ return R3_ADAPTIVE+SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetAdaptiveOn( BOOL on ){ pParamBlk->SetValue( PB_ADAPT_ENABLE, 0, on ); }
		BOOL IsAdaptiveOn(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ADAPT_ENABLE, 0, b, valid );
				return b;
			}

		void SetAdaptiveThreshold( float val )
			{ pParamBlk->SetValue( PB_ADAPT_THRESHOLD, 0, val ); }
		float GetAdaptiveThreshold() { float q; Interval valid;
				pParamBlk->GetValue( PB_ADAPT_THRESHOLD, 0, q, valid );
				return q;
			}

		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

	};


class AdaptiveHaltonSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AdaptiveHaltonSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_AHALTON_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return AHaltonSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static AdaptiveHaltonSamplerClassDesc AHaltonSamplerCD;
ClassDesc* GetAHaltonSamplerDesc() { return &AHaltonSamplerCD; }



//--- Adaptive Halton Sampler -------------------------------


AdaptiveHaltonSampler::AdaptiveHaltonSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(apbDesc, APBLOCK_LENGTH, APB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, FALSE );	
	pParamBlk->SetValue(PB_ADAPT_ENABLE, 0, TRUE );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_ADAPT_THRESHOLD, 0, 0.020f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle AdaptiveHaltonSampler::Clone( RemapDir &remap )
{
	AdaptiveHaltonSampler*	mnew = new AdaptiveHaltonSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}


int AdaptiveHaltonSampler::GetNSamples()
{
	int n = int( GetQuality() * N_HAMM_MAX_SAMPLES );
	return (n < 4) ? 4 : n;
}	


RefResult AdaptiveHaltonSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return adaptNotifyRefChanged( changeInt, hTarget, partID,  message);
}

IOResult AdaptiveHaltonSampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = APB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class AdaptiveHaltonSamplerCB: public PostLoadCallback {
	public:
		AdaptiveHaltonSampler *s;
		int loadVersion;
	    AdaptiveHaltonSamplerCB(AdaptiveHaltonSampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult AdaptiveHaltonSampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < APB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldAVersions,NUM_OLDAVERSIONS, &curAVersion, this,0));
		iload->RegisterPostLoadCallback(new AdaptiveHaltonSamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}



void AdaptiveHaltonSampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	int numSamples = GetNSamples();
	DbgAssert( numSamples > 0 );

	BOOL adaptOn = IsAdaptiveOn();
	float thresh = GetAdaptiveThreshold();

	// scale of edge of sample
	float sampleScale = texSuperSampleOn ? 1.0f / sqrtf( float(numSamples) ) : 1.0f;	

	IPoint2 s = sc->ScreenCoord(); 
	int nx = sc->globContext->devWidth;
	int nSample = ( s.y * nx + s.x ) * numSamples;

	Point2 sample;
	float nSamples = 0.0f;
	float max = -1.0f;
	clr.r = clr.g = clr.b = trans.r = trans.g = trans.b = 0;

	// Sampling loop
	for( int n = 0, ns = 0; n < numSamples; ++n ) {

		sample.x = radicalInverse2( nSample + n  );
		sample.y = radicalInverse( nSample + n, baseB );

		if ( sampleInMask( sample, mask ) ) {
			Color c, t, ref;
			// NB, returns true for unclipped samples
			if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
				clr += c;
				trans += t;
				nSamples += 1.0f;
				if ( adaptOn && ns < nAdaptiveSamples ){
					if ( ns == 0 ) {
						ref = c; 
					} else {
						Color d = c - ref;
						Abs( d );
						float m = Max( d );
						if ( m > max ) max = m;
						adaptOn = max > thresh ? FALSE: TRUE; //once were over, no more tests
						if( (ns == nAdaptiveSamples-1) && adaptOn )
								goto doneSampling;
					}
				}
				++ns;
			}
		}
	}

doneSampling: 
	// Check for 0 samples
	if ( nSamples == 0.0f ){
		// use frag center if no other samples
		sample = sc->SurfacePtScreen(); 
		cb->SampleAtOffset( clr, trans, sample, 1.0f );
	} else {
		clr /= nSamples;
		trans /= nSamples;
	}
}


////////////////////////////////////////////////////////////////////////////////
//	Adaptive CMJ: variable quality Sampler w/ simple adaption 

static int nCMJAdaptiveSamples = 3;

Class_ID ACMJSamplerClassID( ACMJ_SAMPLER_CLASS_ID , 0);

class ACMJSampler: public Sampler {
		// Parameters
		IParamBlock *pParamBlk;
		BOOL texSuperSampleOn;
	public:

		ACMJSampler();

		RefTargetHandle Clone( RemapDir &remap=NoRemap() );
		void DeleteThis() { delete this; };

		Class_ID ClassID() {return ACMJSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_ACMJ_SAMPLER ); }

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload); //{ return Sampler::Load(iload); }
		IOResult Save(ISave *isave); //{ return	Sampler::Save(isave); }

		virtual void DoSamples( Color& c, Color&t, SamplingCallback* cb, 
						ShadeContext* sc, MASK pMask );

		// integer number of samples for current quality
		int GetNSamples();

		void SetEnable( BOOL on )
			{ pParamBlk->SetValue( PB_ENABLE, 0, on ); }

		BOOL GetEnable(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ENABLE, 0, b, valid );
				return b;
			}

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
		}

		int SupportsQualityLevels() { return N_UNIFORM_MAX_SAMPLES; }
		TCHAR* GetDefaultComment(){	return GetString(IDS_KE_ACMJ_COMMENT); }

		// Adaptive Sampling, non-reqd methods
		ULONG SupportsStdParams(){ return R3_ADAPTIVE+SUPER_SAMPLE_TEX_CHECK_BOX; }

		void SetAdaptiveOn( BOOL on ){ pParamBlk->SetValue( PB_ADAPT_ENABLE, 0, on ); }
		BOOL IsAdaptiveOn(){ BOOL b; Interval valid;
				pParamBlk->GetValue( PB_ADAPT_ENABLE, 0, b, valid );
				return b;
			}

		void SetAdaptiveThreshold( float val )
			{ pParamBlk->SetValue( PB_ADAPT_THRESHOLD, 0, val ); }
		float GetAdaptiveThreshold() { float q; Interval valid;
				pParamBlk->GetValue( PB_ADAPT_THRESHOLD, 0, q, valid );
				return q;
			}
		void SetTextureSuperSampleOn( BOOL on )
		{
			texSuperSampleOn = on; 
			pParamBlk->SetValue( PB_SUBSAMP_TEX, 0, on ); 
		}
		BOOL GetTextureSuperSampleOn(){ return texSuperSampleOn; }

		int GetSideSamples();
	};


class ACMJSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ACMJSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_ACMJ_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return ACMJSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static ACMJSamplerClassDesc ACMJSamplerCD;
ClassDesc* GetACMJSamplerDesc() { return &ACMJSamplerCD; }



//--- Adaptive CMJ Sampler -------------------------------


ACMJSampler::ACMJSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(apbDesc, APBLOCK_LENGTH, APB_CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_ENABLE, 0, FALSE );	
	pParamBlk->SetValue(PB_ADAPT_ENABLE, 0, TRUE );	
	pParamBlk->SetValue(PB_QUALITY, 0, 0.5f );	
	pParamBlk->SetValue(PB_ADAPT_THRESHOLD, 0, 0.020f );	
	pParamBlk->SetValue(PB_SUBSAMP_TEX, 0, TRUE );	
	texSuperSampleOn = TRUE; 
}

RefTargetHandle ACMJSampler::Clone( RemapDir &remap )
{
	ACMJSampler*	mnew = new ACMJSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	mnew->texSuperSampleOn =	texSuperSampleOn; 
	return (RefTargetHandle)mnew;
}

int ACMJSampler::GetSideSamples()
{
	int side = int( GetQuality() * N_CMJ_MAX_SIDESAMPLES );
	if (side < 2 ) side = 2;
	if (side > N_CMJ_MAX_SIDESAMPLES ) side = N_CMJ_MAX_SIDESAMPLES;
	return side;
}	

int ACMJSampler::GetNSamples()
{
	int side = GetSideSamples();
	return side * side;
}	



RefResult ACMJSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	return adaptNotifyRefChanged( changeInt, hTarget, partID,  message);
}

IOResult ACMJSampler::Save(ISave *isave)
{ 
	ULONG nb;
	isave->BeginChunk(SAMPLER_VERS_CHUNK);
	int version = APB_CURRENT_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return	Sampler::Save(isave); 
}

class ACMJSamplerCB: public PostLoadCallback {
	public:
		ACMJSampler *s;
		int loadVersion;
	    ACMJSamplerCB(ACMJSampler *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			 s->SetTextureSuperSampleOn( TRUE );
			 delete this;
		}
};

IOResult ACMJSampler::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SAMPLER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < APB_CURRENT_VERSION ) {
		iload->RegisterPostLoadCallback(new ParamBlockPLCB(oldAVersions,NUM_OLDAVERSIONS, &curAVersion, this,0));
		iload->RegisterPostLoadCallback(new ACMJSamplerCB(this, version));
		iload->SetObsolete();
	}

	return	Sampler::Load(iload); 
}


void ACMJSampler::DoSamples( Color& clr, Color&trans, SamplingCallback* cb, 
								ShadeContext* sc, MASK mask )
{
	BOOL adaptOn = IsAdaptiveOn();
	float thresh = GetAdaptiveThreshold();

	int sideSamples = GetSideSamples();
	int numSamples = sideSamples * sideSamples;
	DbgAssert( sideSamples > 0 );

	float sampleScale = texSuperSampleOn ? 1.0f / float(sideSamples) : 1.0f;	

	float subCellSz = 1.0f / float( numSamples );
	float halfSubCell = subCellSz * 0.5f;

	Point2 sample;
	float nSamples = 1.0f;
	trans.Black();

	// Sampling loop
	int ns = 0;
	float max = -1.0f;

	// use frag center as ref for other samples
	sample = sc->SurfacePtScreen(); 
	Color ref;
	cb->SampleAtOffset( ref, trans, sample, 1.0f );
	clr = ref;

	for( int y = 0; y < sideSamples; ++y ) {
		for( int x = 0; x < sideSamples; ++x ) {

			sample.x = (float(x * sideSamples)+ float(y) + 0.5f) * subCellSz;
			sample.y = (float(y * sideSamples)+ float(x) + 0.5f) * subCellSz;
	
			if ( sampleInMask( sample, mask ) ) {
				Color c, t;
				// NB, returns true for unclipped samples
				if (cb->SampleAtOffset( c, t, sample, sampleScale )) {
					clr += c;
					trans += t;
					nSamples += 1.0f;

					if ( adaptOn && ns < nCMJAdaptiveSamples ){
						// use the max component of the difference between c & the ref clr
						Color d = c - ref;
						Abs( d );
						float m = Max( d );
						if ( m > max ) max = m;
						adaptOn = max > thresh ? FALSE: TRUE; //once were over, no more tests
						if( (ns == nCMJAdaptiveSamples-1) && adaptOn )
								goto doneSampling;
					}
					++ns;
				}
			}
		}
	}

doneSampling: 
	clr /= nSamples;
	trans /= nSamples;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\sampSampler.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	sampSampler.cpp	
//
//	Simple Sampler....single sample at 0.5, 0.5 pixels
//
//	Created: Kells Elmquist, 1 Dec, 1998
//
//	Copyright (c) 1998, All Rights Reserved.
//

#include "samplersHdr.h"
#include "stdSamplers.h"
#include "samplerUtil.h"
#include "imtl.h"


Class_ID singleSamplerClassID( SINGLE_SAMPLER_CLASS_ID , 0);

//////////////////////////////////////////////////////////////////////////
//	 Parameter Block
//
#define	PB_QUALITY	0


#define ANIMATE		TRUE
#define NO_ANIMATE	FALSE

#define PBLOCK_LENGTH 1

static ParamBlockDescID pbDesc[] = {
	{ TYPE_FLOAT, NULL, NO_ANIMATE, PB_QUALITY },  // Quality, not used but saved
}; 	


#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	1

static ParamVersionDesc curVersion(pbDesc, PBLOCK_LENGTH, CURRENT_VERSION);

static MASK fullMask = {0xffffffff,0xffffffff};

////////////////////////////////////////////////////////////////////////////
//	Single Sampler
//
class SingleSampler: public Sampler {
	private:
		ShadeContext* pSC;		
		int		n;		// sample count
		BOOL	enable;
		MASK	mask;	// fragment 8x8 mask

	public:
		// Parameters
		IParamBlock *pParamBlk;
		
		SingleSampler();
		RefTargetHandle Clone( RemapDir &remap );
		void DeleteThis() { delete this; };

		// Animatable/Reference
		int NumSubs() { return 1; }
		Animatable* SubAnim(int i){ return i? NULL : pParamBlk; }
		TSTR SubAnimName(int i)
			{ return i? _T("") : _T(GetString(IDS_KE_PARAMETERS)); }

		int NumRefs() { return 1;};
		RefTargetHandle GetReference(int i){ return i? NULL : pParamBlk; }
		void SetReference(int i, RefTargetHandle rtarg)
			{ if ( i == 0 ) pParamBlk = (IParamBlock*)rtarg; }

		Class_ID ClassID() {return singleSamplerClassID;};
		TSTR GetName() { return GetString( IDS_KE_SINGLE_SAMPLER ); }
		void GetClassName(TSTR& s) { s = GetName(); }
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
							         PartID& partID,  RefMessage message);

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// this starts a sample sequence for the area
		void DoSamples( Color& c, Color&t, SamplingCallback* cb, ShadeContext* sc, MASK pMask=NULL );
		
		// This is the function that is called to get the next sample 
		// returns FALSE when out of samples
		BOOL NextSample( Point2* pOutPt, float* pSampleSz );

		// integer number of samples for current quality
		int GetNSamples();	

		// This is the one default parameter
		// Quality is nominal, 0...1, 
		// 0 is one sample, high about .75, 1.0 shd be awesome
		void SetQuality( float q )
			{ pParamBlk->SetValue( PB_QUALITY, 0, q ); }

		float GetQuality() { float q; Interval valid;
				pParamBlk->GetValue( PB_QUALITY, 0, q, valid );
				return q;
			}
		int SupportsQualityLevels() { return 0; }

		void SetEnable( BOOL on ){ enable = on; }
		BOOL GetEnable(){ return enable; }

		TCHAR* GetDefaultComment();

	};


class SingleSamplerClassDesc : public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SingleSampler; }
	const TCHAR *	ClassName() { return GetString(IDS_KE_SINGLE_SAMPLER); }
	SClass_ID		SuperClassID() { return SAMPLER_CLASS_ID; }
	Class_ID 		ClassID() { return singleSamplerClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

static SingleSamplerClassDesc singleSamplerCD;
ClassDesc* GetSingleSamplerDesc() { return &singleSamplerCD; }



//--- Single Sampler ----------------------------------------------------------


SingleSampler::SingleSampler()
{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(pbDesc, PBLOCK_LENGTH, CURRENT_VERSION));
	DbgAssert(pParamBlk);
	pParamBlk->SetValue(PB_QUALITY, 0, 0 );	
	n = 1;
	setMask( mask, ALL_ONES );
}

RefTargetHandle SingleSampler::Clone( RemapDir &remap )
{
	SingleSampler*	mnew = new SingleSampler();
	mnew->ReplaceReference(0,remap.CloneRef(pParamBlk));
	return (RefTargetHandle)mnew;
}


IOResult SingleSampler::Load(ILoad *iload)
{
	Sampler::Load(iload);
	return IO_OK;
}


IOResult SingleSampler::Save(ISave *isave)
{
	Sampler::Save(isave);
	return IO_OK;
}


RefResult SingleSampler::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
{
	GetParamName * gpn;

	switch (message) {
		case REFMSG_CHANGE:
			;
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim * gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_QUALITY: gpd->dim = defaultDim; break;
				default: 	     gpd->dim = defaultDim; break;
			}
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_QUALITY : gpn->name = _T( GetString(IDS_KE_QUALITY) ); break;
				default:		  gpn->name = _T(""); break;
			}
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}

void SingleSampler::DoSamples( Color& c, Color &t, 
			 SamplingCallback* cb, ShadeContext* sc, MASK pMask )
{
	n = 0;
	if ( pMask ) 
		copyMask( mask, pMask );
	else
		setMask( mask, ALL_ONES );

	float sampleScale;
	Point2	sample;
	NextSample( &sample, &sampleScale );

	c.r = c.g = c.b = t.r = t.g = t.b = 0;

	if ( sampleInMask( sample, mask ) )
		cb->SampleAtOffset( c, t, sample, sampleScale );
	else
		cb->SampleAtOffset( c, t, sample, sampleScale );
}



BOOL SingleSampler::NextSample( Point2* pOut, float* pSampleSz )
{
	if ( n ) return FALSE;
#ifdef CENTER_OF_PIXEL
	pOut->x = pOut->y = 0.5f;
#else
	*pOut = pSC->SurfacePtScreen();	// center of fragment
    pOut->x = frac( pOut->x ); pOut->y = frac( pOut->y );
#endif
	*pSampleSz = 1.0f;	// entire pixel

	++n;
	return TRUE;
}

int SingleSampler::GetNSamples()
{
	return 1;
}


TCHAR* SingleSampler::GetDefaultComment()
{
	return GetString(IDS_KE_SINGLE_COMMENT);
}


//-----------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\cext.cpp ===
/**********************************************************************
 *<
	FILE: cext.cpp - parameterized c-extrusion
	Created by Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID CEXT_CLASS_ID(0x33b1284d, 0x7af0200d);
class CExtObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtTopLength,crtSideLength,crtBotLength,crtHeight;
		static float crtTopWidth,crtSideWidth,crtBotWidth;
		static int dlgHSegs, dlgTSegs, dlgWSegs,dlgBSegs,dlgSSegs;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		BOOL increate;

		CExtObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_CEXT); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return CEXT_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		1

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class CExtClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new CExtObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_CEXT_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return CEXT_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static CExtClassDesc CExtDesc;

ClassDesc* GetCExtDesc() { return &CExtDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for CExt class.
IObjParam *CExtObject::ip         = NULL;
int CExtObject::dlgHSegs    = DEF_SEGMENTS;
int CExtObject::dlgSSegs       = DEF_SEGMENTS;
int CExtObject::dlgTSegs       = DEF_SEGMENTS;
int CExtObject::dlgWSegs       = DEF_SEGMENTS;
int CExtObject::dlgBSegs       = DEF_SEGMENTS;
int CExtObject::dlgCreateMeth     = 0; // create_radius
IParamMap *CExtObject::pmapCreate = NULL;
IParamMap *CExtObject::pmapTypeIn = NULL;
IParamMap *CExtObject::pmapParam  = NULL;
Point3 CExtObject::crtPos         = Point3(0,0,0);
float CExtObject::crtHeight       = 0.0f;
float CExtObject::crtTopLength    = 0.0f;
float CExtObject::crtSideLength   = 0.0f;
float CExtObject::crtBotLength    = 0.0f;
float CExtObject::crtBotWidth     = 0.0f;
float CExtObject::crtSideWidth     = 0.0f;
float CExtObject::crtTopWidth     = 0.0f;

void CExtClassDesc::ResetClassParams(BOOL fileReset)
	{ CExtObject::dlgHSegs			= DEF_SEGMENTS;
	  CExtObject::dlgSSegs       = DEF_SEGMENTS;
	  CExtObject::dlgTSegs       = DEF_SEGMENTS;
	  CExtObject::dlgWSegs       = DEF_SEGMENTS;
	  CExtObject::dlgBSegs       = DEF_SEGMENTS;
	  CExtObject::dlgCreateMeth     = 0; // create_radius
	  CExtObject::crtHeight       = 0.0f;
	  CExtObject::crtTopLength    = 0.0f;
	  CExtObject::crtSideLength   = 0.0f;
	  CExtObject::crtBotLength    = 0.0f;
	  CExtObject::crtBotWidth     = 0.0f;
      CExtObject::crtSideWidth     = 0.0f;
      CExtObject::crtTopWidth     = 0.0f;
	  CExtObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_TOPLENGTH	0
#define PB_SIDELENGTH	1
#define PB_BOTLENGTH	2
#define PB_TOPWIDTH		3
#define PB_SIDEWIDTH	4
#define PB_BOTWIDTH		5
#define PB_HEIGHT		6
#define PB_TSEGS		7
#define PB_SSEGS		8
#define PB_BSEGS		9
#define PB_WSEGS		10
#define PB_HSEGS		11
#define PB_GENUVS		12

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_TOPLENGTH		2
#define PB_TI_SIDELENGTH	3
#define PB_TI_BOTLENGTH		4
#define PB_TI_TOPWIDTH		5
#define PB_TI_SIDEWIDTH		6
#define PB_TI_BOTWIDTH		7
#define PB_TI_HEIGHT		8

#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UEXTR_CORNER,IDC_UEXTR_CENTER};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_POSX,IDC_CEXT_POSXSPIN,
		IDC_CEXT_POSY,IDC_CEXT_POSYSPIN,
		IDC_CEXT_POSZ,IDC_CEXT_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Top Length
	ParamUIDesc(
		PB_TI_TOPLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_TOPLEN,IDC_CEXT_TOPLENSPIN,
		MIN_HEIGHT,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Side Length
	ParamUIDesc(
		PB_TI_SIDELENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_SIDELEN,IDC_CEXT_SIDELENSPIN,
		MIN_HEIGHT,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Length
	ParamUIDesc(
		PB_TI_BOTLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_BOTLEN,IDC_CEXT_BOTLENSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
		
	// Top Width
	ParamUIDesc(
		PB_TI_TOPWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_TOPWID,IDC_CEXT_TOPWIDSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Side Width
	ParamUIDesc(
		PB_TI_SIDEWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_SIDEWID,IDC_CEXT_SIDEWIDSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Width
	ParamUIDesc(
		PB_TI_BOTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_BOTWID,IDC_CEXT_BOTWIDSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_HEIGHT,IDC_CEXT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGTH 8


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Top Length
	ParamUIDesc(
		PB_TOPLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_TOPLEN,IDC_CEXT_TOPLENSPIN,
		MIN_HEIGHT,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Side Length
	ParamUIDesc(
		PB_SIDELENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_SIDELEN,IDC_CEXT_SIDELENSPIN,
		MIN_HEIGHT,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Length
	ParamUIDesc(
		PB_BOTLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_BOTLEN,IDC_CEXT_BOTLENSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
		
	// Top Width
	ParamUIDesc(
		PB_TOPWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_TOPWID,IDC_CEXT_TOPWIDSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Side Width
	ParamUIDesc(
		PB_SIDEWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_SIDEWID,IDC_CEXT_SIDEWIDSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Width
	ParamUIDesc(
		PB_BOTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_BOTWID,IDC_CEXT_BOTWIDSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CEXT_HEIGHT,IDC_CEXT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Top Segments
	ParamUIDesc(
		PB_TSEGS,
		EDITTYPE_INT,
		IDC_CEXT_TSEGS,IDC_CEXT_TSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Side Segments
	ParamUIDesc(
		PB_SSEGS,
		EDITTYPE_INT,
		IDC_CEXT_SSEGS,IDC_CEXT_SSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Bot Segments
	ParamUIDesc(
		PB_BSEGS,
		EDITTYPE_INT,
		IDC_CEXT_BSEGS,IDC_CEXT_BSEGSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_CEXT_WSEGS,IDC_CEXT_WSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
			
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_CEXT_HSEGS,IDC_CEXT_HSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 13


// variable type, NULL, animatable, number
ParamBlockDescID CExtdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }, 
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, TRUE, 8 }, 
	{ TYPE_INT, NULL, TRUE, 9 }, 
	{ TYPE_INT, NULL, TRUE, 10 }, 
	{ TYPE_INT, NULL, TRUE, 11 }, 
	{ TYPE_INT, NULL, FALSE, 12 }, 
	};

#define PBLOCK_LENGTH	13

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(CExtdescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

void FixTopWidth(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float topwidth,botwidth,sidelen;

	pblock->GetValue(PB_SIDELENGTH,t,sidelen,FOREVER);
	pblock->GetValue(PB_TOPWIDTH,(increate?0:t),topwidth,FOREVER);
	pblock->GetValue(PB_BOTWIDTH,t,botwidth,FOREVER);
	float fmax=(float)fabs(fabs(sidelen)-botwidth);	
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_CEXT_TOPWIDSPIN));
	  spin2->SetLimits(BMIN_LENGTH,fmax,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (topwidth>fmax) pblock->SetValue(PB_TOPWIDTH,(increate?0:t),fmax);
}
void FixBotWidth(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float sidelen,topwidth,botwidth;

	pblock->GetValue(PB_SIDELENGTH,t,sidelen,FOREVER);
	pblock->GetValue(PB_TOPWIDTH,t,topwidth,FOREVER);
	pblock->GetValue(PB_BOTWIDTH,(increate?0:t),botwidth,FOREVER);
	float fmax=(float)fabs(sidelen)-topwidth;		
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_CEXT_BOTWIDSPIN));
	  spin2->SetLimits(BMIN_LENGTH,fmax,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (botwidth>fmax) pblock->SetValue(PB_BOTWIDTH,(increate?0:t),fmax);
}
void FixSideWidth(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float toplen,botlen,sidewidth;

	pblock->GetValue(PB_SIDEWIDTH,(increate?0:t),sidewidth,FOREVER);
	pblock->GetValue(PB_TOPLENGTH,t,toplen,FOREVER);
	pblock->GetValue(PB_BOTLENGTH,t,botlen,FOREVER);
	float fmax=(toplen<0.0f?-toplen:toplen)+(botlen<0.0f?-botlen:botlen);										  
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_CEXT_SIDEWIDSPIN));
	  spin2->SetLimits(BMIN_LENGTH,fmax,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (sidewidth>fmax) pblock->SetValue(PB_SIDEWIDTH,(increate?0:t),fmax);
}
//--- TypeInDlgProc --------------------------------
class CExtWidthDlgProc : public ParamMapUserDlgProc {
	public:
		CExtObject *ob;

		CExtWidthDlgProc(CExtObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL CExtWidthDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_CEXT_TOPWIDSPIN:
					FixTopWidth(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				case IDC_CEXT_BOTWIDSPIN:
					FixBotWidth(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				case IDC_CEXT_SIDEWIDSPIN:
				{  FixSideWidth(ob->pblock,t,hWnd,ob->increate);
				}
			return TRUE;
				}
		}
	return FALSE;
	}

class CExtTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		CExtObject *ob;

		CExtTypeInDlgProc(CExtObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL CExtTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CEXT_CREATE: {
					if (ob->crtHeight==0.0f) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_TOPLENGTH,0,ob->crtTopLength);
						ob->pblock->SetValue(PB_SIDELENGTH,0,ob->crtSideLength);
						ob->pblock->SetValue(PB_BOTLENGTH,0,ob->crtBotLength);
						ob->pblock->SetValue(PB_TOPWIDTH,0,ob->crtTopWidth);
						ob->pblock->SetValue(PB_SIDEWIDTH,0,ob->crtSideWidth);
						ob->pblock->SetValue(PB_BOTWIDTH,0,ob->crtBotWidth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- CExt methods -------------------------------

CExtObject::CExtObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(CExtdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_TSEGS,0,dlgTSegs);
	pblock->SetValue(PB_SSEGS,0,dlgSSegs);
	pblock->SetValue(PB_BSEGS,0,dlgBSegs);	
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);	
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);	

	pblock->SetValue(PB_TOPLENGTH,0,crtTopLength);
	pblock->SetValue(PB_SIDELENGTH,0,crtSideLength);
	pblock->SetValue(PB_BOTLENGTH,0,crtBotLength);
	pblock->SetValue(PB_TOPWIDTH,0,crtTopWidth);
	pblock->SetValue(PB_SIDEWIDTH,0,crtSideWidth);
	pblock->SetValue(PB_BOTWIDTH,0,crtBotWidth);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	increate=FALSE;
	}

IOResult CExtObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void CExtObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (pmapCreate && pmapParam) {
		
		// Left over from last CExt ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UEXTRUSIONS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_C_EXTRUSION2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_C_EXTRUSION3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new CExtTypeInDlgProc(this));
		}	
	if(pmapParam) {
		// A callback for the type in.
		pmapParam->SetUserDlgProc(new CExtWidthDlgProc(this));
		}	
	}
		
void CExtObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_TSEGS,ip->GetTime(),dlgTSegs,FOREVER);
	pblock->GetValue(PB_SSEGS,ip->GetTime(),dlgSSegs,FOREVER);
	pblock->GetValue(PB_BSEGS,ip->GetTime(),dlgBSegs,FOREVER);	
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);	
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);		
}

/*void CExtObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	pblock->SetValue(PB_TOPLENGTH,0,toplength);
	pblock->SetValue(PB_SIDELENGTH,0,sidelength);
	pblock->SetValue(PB_BOTLENGTH,0,botlength);
	pblock->SetValue(PB_TOPWIDTH,0,topwidth);
	pblock->SetValue(PB_SIDEWIDTH,0,sidewidth);
	pblock->SetValue(PB_BOTWIDTH,0,botwidth);
	pblock->SetValue(PB_TSEGS,0,tsegs);
	pblock->SetValue(PB_SSEGS,0,ssegs);
	pblock->SetValue(PB_BSEGS,0,bsegs);
	pblock->SetValue(PB_WSEGS,0,wsegs);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_GENUVS,0, genUV);
*/

void BuildCExtMesh(Mesh &mesh,
		int hsegs, int tsegs, int ssegs, int bsegs, int wsegs,
		float height, float toplen, float sidelen, float botlen,
		float topwidth, float sidewidth, float botwidth,
		int genUVs, BOOL create)
{	int nf=0;
	int nfaces,ntverts;
	BOOL minush=height<0.0f;
	if (minush) height=-height;
	BOOL minusx=(toplen<0.0f),minusy=(sidelen<0.0f);
	toplen=(float)fabs(toplen);
	botlen=(float)fabs(botlen);
	sidelen=(float)fabs(sidelen);
	 // sides + top/bot
	int VertexPerLevel=2*(wsegs+tsegs+ssegs+bsegs);
	int topverts=(wsegs+1)*(1+tsegs+ssegs+bsegs);
	int nverts=2*topverts+(hsegs+1)*VertexPerLevel;
	nfaces=hsegs*4*(wsegs+bsegs+tsegs+ssegs)+4*wsegs*(tsegs+ssegs+bsegs);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	if (genUVs) 
	{ ntverts=nverts+hsegs+1;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	Point3 p;
	p.x=p.y=p.z=0.0f;
	float minx=(botlen>toplen?0.0f:botlen-toplen),maxx=botlen;
	float xlen=(botlen>toplen?botlen:toplen);
	float xincr,xpos=0.0f,yincr;
	float uvdist=2.0f*(botlen+toplen+sidelen)-2.0f*sidewidth;
	float ystart,xstart;
	float xtv,ytv,ypos,dx=sidewidth/wsegs,tdy=topwidth/wsegs,bdy=botwidth/wsegs;
	int i,j,nv=0,fc=0,dlevel=bsegs+ssegs+tsegs+1,botv=nverts-topverts;
	int tlast,tendcount=ntverts-hsegs-1,tnv=0,bottv=tendcount-topverts;
	tlast=tendcount;
	for (j=0;j<=wsegs;j++)
	{ xstart=0.0f;xincr=(botlen-j*dx)/bsegs;
      yincr=botwidth/wsegs;ystart=j*yincr;
	  for (i=0;i<=bsegs;i++)
	  { mesh.setVert(nv,xpos=xstart+i*xincr,ystart,height);	
	    mesh.setVert(botv,xpos,ystart,0.0f);
	    if (genUVs)
	    { mesh.setTVert(tnv,xtv=(xpos-minx)/xlen,ytv=ystart/sidelen,0.0f);
	      mesh.setTVert(bottv,xtv,1.0f-ytv,0.0f);
	    }
	    nv++;botv++;bottv++;tnv++;
	  }
	  yincr=(sidelen-j*(tdy+bdy))/ssegs;xpos=mesh.verts[nv-1].x;
	  for (i=1;i<=ssegs;i++)
	  { mesh.setVert(nv,xpos,ypos=ystart+i*yincr,height);	
	    mesh.setVert(botv,xpos,ypos,0.0f);
	    if (genUVs)
	    { mesh.setTVert(tnv,xtv,ytv=ypos/sidelen,0.0f);
	      mesh.setTVert(bottv,xtv,1.0f-ytv,0.0f);
	    }
	   nv++;botv++;bottv++;tnv++;
  	  }
 	  xstart=xpos;xincr=(toplen-j*dx)/tsegs;
	  for (i=1;i<=tsegs;i++)
	  { mesh.setVert(nv,xpos=xstart-i*xincr,ypos,height);	
	    mesh.setVert(botv,xpos,ypos,0.0f);
	    if (genUVs)
	    { mesh.setTVert(tnv,xtv=(xpos-minx)/xlen,ytv,0.0f);
	      mesh.setTVert(bottv,xtv,1.0f-ytv,0.0f);
	    }
	    nv++;botv++;bottv++;tnv++;
	  }
	}
	xstart=0.0f;xpos=0.0f;ypos=0.0f;
	float uval=0.0f;
	int refnv=nv;
	xincr=botlen/bsegs;
	for (i=0;i<=bsegs;i++)
	{  mesh.setVert(nv,xpos=xstart+i*xincr,0.0f,height);	
	   if (genUVs) mesh.setTVert(tnv,xtv=(uval=xpos)/uvdist,1.0f,0.0f);
	   nv++;tnv++;
    }
	yincr=sidelen/ssegs;xpos=mesh.verts[nv-1].x;
	for (i=1;i<=ssegs;i++)
	{ mesh.setVert(nv,xpos,ypos+=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;tnv++;
  	}
 	xincr=toplen/tsegs;
	for (i=1;i<=tsegs;i++)
	{ mesh.setVert(nv,xpos-=xincr,ypos,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=xincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	yincr=topwidth/wsegs;
	for (i=1;i<=wsegs;i++)
	{ mesh.setVert(nv,xpos,ypos-=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	xincr=(toplen-sidewidth)/tsegs;
	for (i=1;i<=tsegs;i++)
	{ mesh.setVert(nv,xpos+=xincr,ypos,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=xincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	yincr=(sidelen-topwidth-botwidth)/ssegs;
	for (i=1;i<=ssegs;i++)
	{ mesh.setVert(nv,xpos,ypos-=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	xincr=(botlen-sidewidth)/bsegs;
	for (i=1;i<=bsegs;i++)
	{ mesh.setVert(nv,xpos-=xincr,ypos,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=xincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	yincr=botwidth/wsegs;
	for (i=1;i<wsegs;i++)
	{ mesh.setVert(nv,xpos,ypos-=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;tnv++;
	}
	if (genUVs) mesh.setTVert(tendcount++,1.0f,1.0f,0.0f);
	float zval,hincr=height/hsegs,zv;
	for (j=0;j<VertexPerLevel;j++)
	{ zval=height;
	  for (i=1;i<=hsegs;i++)
	  {	 zval-=hincr;
	     mesh.setVert(refnv+VertexPerLevel*i,mesh.verts[refnv].x,mesh.verts[refnv].y,zval);
		 if (genUVs) 
		 { mesh.setTVert(refnv+VertexPerLevel*i,mesh.tVerts[refnv].x,zv=zval/height,0.0f);
		   if (j==VertexPerLevel-1) mesh.setTVert(tendcount++,1.0f,zv,0.0f);
		 }
	  }
	refnv++;
	}
	int base=0,top=dlevel,alevel=dlevel-1;
	for (i=0;i<wsegs;i++)
	{ for (j=0;j<alevel;j++)
	 { if (genUVs) 
	   { mesh.tvFace[fc].setTVerts(top,base,base+1);
		 mesh.tvFace[fc+1].setTVerts(top,base+1,top+1);
	   }
	   AddFace(&mesh.faces[fc++],top,base,base+1,0,1);
	   AddFace(&mesh.faces[fc++],top,base+1,top+1,1,1);
	   top++;base++;
  	 } top++;base++;
	}
	base=top+VertexPerLevel;
	tendcount=tlast;
    int b1,smgroup=2,s0=bsegs+1,s1=s0+ssegs,s2=s1+tsegs,s3=s2+wsegs;
	int s4=s3+tsegs,s5=s4+ssegs,s6=s5+bsegs;
	for (i=0;i<hsegs;i++)
	{ for (j=1;j<=VertexPerLevel;j++)
	{ if (genUVs) 
	   { b1=(j<VertexPerLevel?base+1:tendcount+1);
		 mesh.tvFace[fc].setTVerts(top,base,b1);
		 mesh.tvFace[fc+1].setTVerts(top,b1,(j<VertexPerLevel?top+1:tendcount++));
	   }
	   b1=(j<VertexPerLevel?base+1:base-VertexPerLevel+1);
	   smgroup=(j<s0?2:(j<s1?4:(j<s2?2:(j<s3?4:(j<s4?2:(j<s5?4:(j<s6?2:4)))))));
	   AddFace(&mesh.faces[fc++],top,base,b1,0,smgroup);
	   AddFace(&mesh.faces[fc++],top,b1,(j<VertexPerLevel?top+1:top-VertexPerLevel+1),1,smgroup);
	   top++;base++;
  	 } 
	}
	top=base;base=top+alevel;
	base=top+dlevel;
	// Just for Jack
	for (i=0;i<wsegs;i++)
	{ for (j=0;j<alevel;j++)
	 { if (genUVs) 
	   { mesh.tvFace[fc].setTVerts(top,base,base+1);
		 mesh.tvFace[fc+1].setTVerts(top,base+1,top+1);
	   }
	   AddFace(&mesh.faces[fc++],top,base,base+1,0,1);
	   AddFace(&mesh.faces[fc++],top,base+1,top+1,1,1);
	   top++;base++;
  	 } top++;base++;
	}
	if (minusx || minusy || minush)
	{   float centerx=(create?toplen:0),centery=(create?sidelen:0);
		 for (i=0;i<nverts;i++)
	   { if (minusx) mesh.verts[i].x=-mesh.verts[i].x+centerx;
	     if (minusy) mesh.verts[i].y=-mesh.verts[i].y+centery;
	     if (minush) mesh.verts[i].z-=height;
	   }
	   DWORD hold;
	   int tedge;
	   if (minusx!=minusy)
	   for (i=0;i<nfaces;i++)
	   { hold=mesh.faces[i].v[0];mesh.faces[i].v[0]=mesh.faces[i].v[2];mesh.faces[i].v[2]=hold;
	     tedge=mesh.faces[i].getEdgeVis(0);mesh.faces[i].setEdgeVis(0,mesh.faces[i].getEdgeVis(1));
		 mesh.faces[i].setEdgeVis(1,tedge);
	     if (genUVs)
         { hold=mesh.tvFace[i].t[0];mesh.tvFace[i].t[0]=mesh.tvFace[i].t[2];mesh.tvFace[i].t[2]=hold;}
	   }
	}
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts); */
	mesh.InvalidateGeomCache();
mesh.InvalidateTopologyCache(); mesh.BuildStripsAndEdges();
}

BOOL CExtObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void CExtObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void CExtObject::BuildMesh(TimeValue t)
	{	
	int hsegs,tsegs,ssegs,bsegs,wsegs;
	float height,toplen,sidelen,botlen,topwidth,sidewidth,botwidth;
	int genUVs;	

	// Start the validity interval at forever and widdle it down.
	FixTopWidth(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	FixBotWidth(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	FixSideWidth(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	ivalid = FOREVER;
	
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_TSEGS,t,tsegs,ivalid);
	pblock->GetValue(PB_SSEGS,t,ssegs,ivalid);
	pblock->GetValue(PB_BSEGS,t,bsegs,ivalid);
	pblock->GetValue(PB_WSEGS,t,wsegs,ivalid);
	pblock->GetValue(PB_TOPLENGTH,t,toplen,ivalid);
	pblock->GetValue(PB_SIDELENGTH,t,sidelen,ivalid);
	pblock->GetValue(PB_BOTLENGTH,t,botlen,ivalid);
	pblock->GetValue(PB_TOPWIDTH,t,topwidth,ivalid);
	pblock->GetValue(PB_SIDEWIDTH,t,sidewidth,ivalid);
	pblock->GetValue(PB_BOTWIDTH,t,botwidth,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	LimitValue(height, MIN_HEIGHT, BMAX_HEIGHT);
	LimitValue(toplen, MIN_HEIGHT, BMAX_LENGTH);
	LimitValue(sidelen, MIN_HEIGHT,BMAX_WIDTH);
	LimitValue(botlen, MIN_HEIGHT, BMAX_HEIGHT);
	LimitValue(topwidth, BMIN_LENGTH,BMAX_LENGTH);
	LimitValue(sidewidth, BMIN_WIDTH,BMAX_WIDTH);
	LimitValue(botwidth, BMIN_HEIGHT,BMAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(tsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(ssegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(bsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	
	BuildCExtMesh(mesh,hsegs,tsegs,ssegs,bsegs,wsegs,height,
		toplen,sidelen,botlen,topwidth,sidewidth,botwidth, genUVs,dlgCreateMeth);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}


Object* CExtObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int CExtObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class CExtObjCreateCallBack: public CreateMouseCallBack {
	CExtObject *ob;	
	Point3 p[2],d;
	IPoint2 sp0,sp1,sp2;
	float xwid,l,hd,slen;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(CExtObject *obj) { ob = obj; }
	};

int CExtObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:	ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_BOTLENGTH,0,0.01f);
				ob->pblock->SetValue(PB_TOPLENGTH,0,0.01f);
				ob->pblock->SetValue(PB_SIDELENGTH,0,0.01f);
				break;
			case 1: 
				mat.IdentityMatrix();
				sp1 = m;
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				d = p[1]-p[0];
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = len;}
				if (!ob->dlgCreateMeth)
				{ mat.SetTrans(p[0]);
				if (flags&MOUSE_CTRL) d.x=(d.y*=2.0f);}
				else 
				{ mat.SetTrans(p[0]-Point3(fabs(d.x),fabs(d.y),fabs(d.z))); 
				  d=2.0f*d;	
				}
				float tmp;
				xwid=(tmp=(float)fabs(d.x));
				slen=(float)fabs(d.y);
				tmp*=0.2f;
				ob->pblock->SetValue(PB_BOTLENGTH,0,d.x);
				ob->pblock->SetValue(PB_TOPLENGTH,0,d.x);
				ob->pblock->SetValue(PB_SIDELENGTH,0,d.y);
				ob->pblock->SetValue(PB_BOTWIDTH,0,tmp);
				ob->pblock->SetValue(PB_TOPWIDTH,0,tmp);
				ob->pblock->SetValue(PB_SIDEWIDTH,0,0.2f*slen);
				ob->pmapParam->Invalidate();
				ob->increate=TRUE;
				if (msg==MOUSE_POINT && (Length(sp1-sp0)<3 || Length(d)<0.1f)) 
				{ ob->increate=FALSE;
					return CREATE_ABORT;	}
				break;
			case 2:
				{
				sp2=m;
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) {	if (Length(m-sp0)<3) {ob->increate=FALSE; return CREATE_ABORT;}}
				break;
				}
			case 3: 
				float f=vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				if (f<0.0f) f=0.0f;
				float fmax=slen/2.0f;										  
				if (f>fmax) f=fmax;
				ob->pblock->SetValue(PB_TOPWIDTH,0,f);
				ob->pblock->SetValue(PB_SIDEWIDTH,0,(f>xwid?xwid:f));
				ob->pblock->SetValue(PB_BOTWIDTH,0,f);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{  ob->suspendSnap = FALSE;	
				ob->increate=FALSE;
				   return CREATE_STOP;
				}
				break;
			}
	} else {
		if (msg == MOUSE_ABORT)
		{ob->increate=FALSE;
		return CREATE_ABORT;}
		}
	return 1;
	}

static CExtObjCreateCallBack cylCreateCB;

CreateMouseCallBack* CExtObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL CExtObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_BOTLENGTH,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL CExtObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL CExtObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_TOPLENGTH: crtTopLength = v; break;
		case PB_TI_SIDELENGTH: crtSideLength = v; break;
		case PB_TI_BOTLENGTH: crtBotLength = v; break;
		case PB_TI_TOPWIDTH: crtTopWidth = v; break;
		case PB_TI_SIDEWIDTH: crtSideWidth = v; break;
		case PB_TI_BOTWIDTH: crtBotWidth = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL CExtObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL CExtObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL CExtObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_TOPLENGTH: v = crtTopLength; break;
		case PB_TI_SIDELENGTH: v = crtSideLength; break;
		case PB_TI_BOTLENGTH: v = crtBotLength; break;
		case PB_TI_TOPWIDTH: v = crtTopWidth; break;
		case PB_TI_SIDEWIDTH: v = crtSideWidth; break;
		case PB_TI_BOTWIDTH: v = crtBotWidth; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL CExtObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void CExtObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *CExtObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_TOPLENGTH:return stdWorldDim;
		case PB_SIDELENGTH:return stdWorldDim;
		case PB_BOTLENGTH:return stdWorldDim;
		case PB_TOPWIDTH: return stdWorldDim;
		case PB_SIDEWIDTH: return stdWorldDim;
		case PB_BOTWIDTH: return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_TSEGS: return stdSegmentsDim;
		case PB_SSEGS: return stdSegmentsDim;
		case PB_BSEGS: return stdSegmentsDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR CExtObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_TOPLENGTH: return TSTR(GetString(IDS_AP_BACKLENGTH));
		case PB_SIDELENGTH: return TSTR(GetString(IDS_RB_SIDELENGTH));
		case PB_BOTLENGTH: return TSTR(GetString(IDS_AP_FRONTLENGTH));
		case PB_TOPWIDTH:  return TSTR(GetString(IDS_AP_BACKWIDTH));
		case PB_SIDEWIDTH:  return TSTR(GetString(IDS_RB_SIDEWIDTH));
		case PB_BOTWIDTH:  return TSTR(GetString(IDS_AP_FRONTWIDTH));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_TSEGS:  return TSTR(GetString(IDS_AP_BACKSEGS));
		case PB_SSEGS:  return TSTR(GetString(IDS_RB_SSEGS));
		case PB_BSEGS:  return TSTR(GetString(IDS_AP_FRONTSEGS));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle CExtObject::Clone(RemapDir& remap) 
	{
	CExtObject* newob = new CExtObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Samplers\stdSamplers.h ===
///////////////////////////////////////////////////////////////
//
//	Standard Samplers functions
//

#ifndef STDSAMPLERS_H
#define STDSAMPLERS_H

// Common parameter block ids
#define	PB_QUALITY		0
#define	PB_ENABLE		1
#define	PB_SUBSAMP_TEX	2

#define	PB_ADAPT_ENABLE	3
#define	PB_ADAPT_THRESHOLD	4
#define	PB_SUBSAMP_TEX_ADAPT	5


// Class ids

#define SINGLE_SAMPLER_CLASS_ID		0x25773210
//#define R25_SAMPLER_CLASS_ID		0x25773211
#define UNIFORM_SAMPLER_CLASS_ID	0x25773212
#define CMJ_SAMPLER_CLASS_ID		0x25773213
#define HAMMERSLEY_SAMPLER_CLASS_ID	0x25773214
#define HALTON_SAMPLER_CLASS_ID		0x25773215
#define AHALTON_SAMPLER_CLASS_ID	0x25773216
#define ACMJ_SAMPLER_CLASS_ID		0x25773217


// Sampler Class Descriptors
extern ClassDesc* GetSingleSamplerDesc();
extern ClassDesc* GetR25SamplerDesc();
extern ClassDesc* GetUniformSamplerDesc();
extern ClassDesc* GetCMJSamplerDesc();
extern ClassDesc* GetHammersleySamplerDesc();
extern ClassDesc* GetHaltonSamplerDesc();
extern ClassDesc* GetAHaltonSamplerDesc();
extern ClassDesc* GetACMJSamplerDesc();




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\chbox.cpp ===
/*****************************************************************************
 *<
	FILE: chbox.cpp

	DESCRIPTION: Chbox - builds filleted/chamfered boxes

	CREATED BY:  Audrey Peterson
	Copyright (c) 1996 All Rights Reserved
 *>
 *****************************************************************************/
// Resource include file.
#include "solids.h"
#include "iparamm.h"
#include "simpobj.h"

// Unique Class ID.  It is specified as two 32-bit quantities.
#define SCS_C_CLASS_ID1 0x1AD73F40
#define SCS_C_CLASS_ID2 0x48EA0F97
#define sidesmooth 0
#define chsmooth 1
#define topsquare 0
#define messyedge 1
#define middle 2
#define bottomedge 3
#define bottomsquare 4

typedef struct{
  int surface,deltavert;
} chinfo;

class ChBoxObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static int dlgLSegs;
		static int dlgWSegs;
		static int dlgHSegs;
		static int dlgCSegs;
		static int createMeth;
		static Point3 crtPos;		
		static float crtWidth, crtHeight, crtLength, crtRadius;

		ChBoxObject();
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_CHNAME); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(SCS_C_CLASS_ID1,SCS_C_CLASS_ID2); }  
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
	};				


// Misc stuff
#define CMIN_RADIUS		float(0.0)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0.1)
#define BMAX_WIDTH		float(1.0E30)
#define BMIN_HEIGHT		float(-1.0E30)
#define BMAX_HEIGHT		float(1.0E30)

#define BDEF_DIM		float(0)
#define BDEF_SEGS		1
#define CDEF_SEGS		3

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200


//--- Parameter map/block descriptors -------------------------------

// The parameter map descriptors define the properties of a parameter
// such as the type (spinner, radio button, check box, etc.), which
// resource ID they refer to, and which index into the virtual array
// they use.

// Parameter block indices
#define PB_LENGTH	0
#define PB_WIDTH	1
#define PB_HEIGHT	2
#define PB_RADIUS	3
#define PB_LSEGS	4
#define PB_WSEGS	5
#define PB_HSEGS	6
#define PB_CSEGS	7
#define PB_GENUVS	8
#define PB_SMOOTH	9

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_LENGTH		2
#define PB_TI_WIDTH			3
#define PB_TI_HEIGHT		4
#define PB_TI_RADIUS		5

//	Creation method

static int createMethIDs[] = {IDC_CC_CREATEBOX,IDC_CC_CREATECUBE};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_CC_POSX,IDC_CC_POSXSPIN,
		IDC_CC_POSY,IDC_CC_POSYSPIN,
		IDC_CC_POSZ,IDC_CC_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Length
	ParamUIDesc(
		PB_TI_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CC_LENGTH,IDC_CC_LENGTHSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CC_WIDTH,IDC_CC_WIDTHSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CC_HEIGHT,IDC_CC_HEIGHTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_CC_RADIUS,IDC_CC_RADIUSSPIN,
		CMIN_RADIUS,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGTH 5

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_CC_LENGTH,IDC_CC_LENGTHSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_CC_WIDTH,IDC_CC_WIDTHSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CC_HEIGHT,IDC_CC_HEIGHTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_CC_RADIUS,IDC_CC_RADIUSSPIN,
		CMIN_RADIUS,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	
	// Length Segments
	ParamUIDesc(
		PB_LSEGS,
		EDITTYPE_INT,
		IDC_CC_LENSEGS,IDC_CC_LENSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_CC_WIDSEGS,IDC_CC_WIDSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_CC_HGTSEGS,IDC_CC_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

		// Fillet Segments
	ParamUIDesc(
		PB_CSEGS,
		EDITTYPE_INT,
		IDC_CC_RADSEGS,IDC_CC_RADSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OT_SMOOTH),			
	
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 10


ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, FALSE, 8 }, 
	};

ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, FALSE, 8 }, 
	{ TYPE_INT, NULL, FALSE, 9 }, 
	};

#define PBLOCK_LENGTH	10

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,9,0),	
	};
#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class ChBoxTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		ChBoxObject *ob;

		ChBoxTypeInDlgProc(ChBoxObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ChBoxTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CC_CREATE: {					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_LENGTH,0,ob->crtLength);
						ob->pblock->SetValue(PB_WIDTH,0,ob->crtWidth);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);					
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Box methods -------------------------------

// Constructor
ChBoxObject::ChBoxObject()
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer1,PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_LSEGS,0,dlgLSegs);
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);	
	pblock->SetValue(PB_CSEGS,0,dlgCSegs);	
	pblock->SetValue(PB_LENGTH,0,crtLength);
	pblock->SetValue(PB_WIDTH,0,crtWidth);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_SMOOTH,0,1);
	}
// Called by MAX when the sphere object is loaded from disk.
IOResult ChBoxObject::Load(ILoad *iload) 
	{	
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}

// This method is called by the system when the user needs 
// to edit the objects parameters in the command panel.  
void ChBoxObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	// We subclass off SimpleObject so we must call its
	// BeginEditParams() method first.
	SimpleObject::BeginEditParams(ip,flags,prev);
	// Save the interface pointer.
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last box ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			// Here we create each new rollup page in the command panel
			// using our descriptors.
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CHAMFERCUBE1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CHAMFERCUBE2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_CHAMFERCUBE3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		// This handles processing the Create button in the 
		// Keyboard Entry rollup page.
		pmapTypeIn->SetUserDlgProc(new ChBoxTypeInDlgProc(this));
		}
	}
		
// This is called by the system to terminate the editing of the
// parameters in the command panel.  
void ChBoxObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		// Remove the rollup pages from the command panel.
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object 
	// created will inherit them.
	pblock->GetValue(PB_LSEGS,ip->GetTime(),dlgLSegs,FOREVER);
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);	
	pblock->GetValue(PB_CSEGS,ip->GetTime(),dlgCSegs,FOREVER);	
	}

#define POSX 0	// right
#define POSY 1	// back
#define POSZ 2	// top
#define NEGX 3	// left
#define NEGY 4	// front
#define NEGZ 5	// bottom

int direction(Point3 *v) {
	Point3 a = v[0]-v[2];
	Point3 b = v[1]-v[0];
	Point3 n = CrossProd(a,b);
	switch(MaxComponent(n)) {
		case 0: return (n.x<0)?NEGX:POSX;
		case 1: return (n.y<0)?NEGY:POSY;
		case 2: return (n.z<0)?NEGZ:POSZ;
		}
	return 0;
	}

// Remap the sub-object material numbers so that the top face is the first one
// The order now is:
// Top / Bottom /  Left/ Right / Front / Back
static int mapDir[6] ={ 3, 5, 0, 2, 4, 1 };
static int hsegs,wsegs,csegs,fcount,scount,curvertex;
static float wincr,hincr,cincr;
static Point3 NewPt,Toppt,CornerPt;
static int boxpos,wsegcount,hseg;

void CalculateHeightDivisions(int plus,int *PtRotation)
{float deltay;

  curvertex++;
  if (hseg==hsegs)
    { (*PtRotation)++;
      hseg=0;
      NewPt.y=(plus?Toppt.y:-CornerPt.y);}
  else
   { deltay=hincr*hseg;
     NewPt.y=(plus?-CornerPt.y+deltay:Toppt.y-deltay);
     hseg++;
   }
}
void CalculateWidthDivisions(int plus,int *PtRotation)
{float deltax;

  curvertex++;
   if (wsegcount==wsegs)
       {NewPt.x=(plus?CornerPt.x:-CornerPt.x);
       wsegcount=0;(*PtRotation)++;}
   else
    { deltax=wincr*wsegcount;
      NewPt.x=(plus?-CornerPt.x+deltax:CornerPt.x-deltax);
      wsegcount++;
    }
}

void FillinSquare(int *PtRotation,int *cornervert,float CurRadius)
{ if (hseg>0) CalculateHeightDivisions(((*PtRotation)>1),PtRotation);
  else if (wsegcount>0) CalculateWidthDivisions((*PtRotation)<3,PtRotation);
  else
   { switch (*PtRotation){
       case 0: NewPt.x=-CornerPt.x-CurRadius;
               NewPt.y=CornerPt.y;
               hseg++;
               break;
       case 1: NewPt.x=-CornerPt.x;
               NewPt.y=-CornerPt.y-CurRadius;
               wsegcount++;
               break;
       case 2: NewPt.x=CornerPt.x+CurRadius;
               NewPt.y=-CornerPt.y;
               hseg++;
               break;
       case 3: NewPt.x=CornerPt.x;
               NewPt.y=CornerPt.y+CurRadius;
               wsegcount++;
               break;
       default:;
      }
      curvertex+=csegs;
      if ((*PtRotation)==2) cornervert[*PtRotation]=curvertex-csegs;
      else cornervert[*PtRotation]=curvertex;
    }
}

void CalculateNewPt(float dx,float dy,int *PtRotation,int *cornervert,int deltapt)
{
    (*PtRotation)++;
    switch (*PtRotation){
      case 1: NewPt.y=-CornerPt.y-dy;
              NewPt.x=-CornerPt.x-dx;
              curvertex=cornervert[1]-deltapt;
              break;
      case 2: NewPt.x=CornerPt.x+dx;
              NewPt.y=-CornerPt.y-dy;
              curvertex=cornervert[2]+deltapt;
              break;
      case 3: NewPt.y=CornerPt.y+dy;
              curvertex=cornervert[3]-deltapt;
              *PtRotation=6;
              break;
   }
}

static int sidenum,endpt,face,topchamferfaces,chamferstart;
static int SidesPerSlice,topnum,tstartpt,maxfaces;
static int circleseg,firstface,cstartpt;
static chinfo chamferinfo[4];

//int ChBoxObject::getnextfirstvertex()
int getnextfirstvertex()
{ int c;

  if (boxpos==bottomedge)
  { c=curvertex -=chamferinfo[sidenum].deltavert;
    if (curvertex==endpt)
    { circleseg=1;firstface=0;
      if (endpt!=cstartpt) sidenum++;
       endpt-=chamferinfo[sidenum].deltavert*(chamferinfo[sidenum].surface==1?hsegs:wsegs);
     }
  }
  else
  { c=++curvertex;
    if (boxpos==messyedge)
     { c=(face==topchamferfaces+chamferstart-2?cstartpt:curvertex);
       if ((circleseg>0)&&(circleseg++>csegs)) circleseg=0;
     }
    else  if (boxpos==middle)
     c=(++fcount==SidesPerSlice?fcount=0,curvertex-SidesPerSlice:curvertex);

  }
  return(c);
}

int getnextsecondvertex()
{ int c;

  if (boxpos==messyedge)
  { c=topnum +=chamferinfo[sidenum].deltavert;
    if (topnum==endpt)
    { circleseg=1;firstface=1;
      if (endpt!=tstartpt) sidenum++;
      else {topnum=cstartpt;boxpos=middle;circleseg=0;firstface=0;}
       endpt+=chamferinfo[sidenum].deltavert*(chamferinfo[sidenum].surface==1?hsegs:wsegs);
     }
  }
  else
  { c=++topnum;
   if (boxpos==bottomedge)
    { c=(face==maxfaces-chamferstart-1?tstartpt:topnum);
      if ((circleseg>0)&&(circleseg++>csegs)) circleseg=0;
    }
    else if (boxpos==middle)
       c=(++scount==SidesPerSlice?scount=0,topnum-SidesPerSlice:topnum);
    else
       {if (++scount==wsegs) {scount=0;c=topnum++;}
       }
  }
  return(c);
}

void AddFace(Face *f,int smooth_group,int tdelta,TVFace *tvface,int genUVs)
{ int a,b,c;
  f[0].setSmGroup(smooth_group);
  f[0].setMatID((MtlID)0); 	 /*default */
  a=topnum; 
  if (firstface)
  { b=curvertex;
	f[0].setVerts(a, b, c=getnextfirstvertex());
    f[0].setEdgeVisFlags(1,1,0);
  }
  else
  { if (((boxpos==topsquare)||(boxpos==bottomsquare))&&(++fcount==wsegs))
    {fcount=0;b=curvertex++;}
    else if (boxpos==messyedge?face==topchamferfaces+chamferstart-1:scount==SidesPerSlice-1)
       b=(boxpos==middle?curvertex-SidesPerSlice:cstartpt);
	else b=curvertex;
	f[0].setVerts(a, b, c=getnextsecondvertex());
    f[0].setEdgeVisFlags(0,1,1);
  }
  if (genUVs)
  { a+=tdelta;b+=tdelta;c+=tdelta;
	tvface[0].setTVerts(a,b,c);
  }
  face++;
}

BOOL ChBoxObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void ChBoxObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void ChBoxObject::BuildMesh(TimeValue t)
	{
	int smooth,dsegs,vertices;
	int WLines,HLines,DLines,CLines,VertexPerSlice;
	int VertexPerFace,FacesPerSlice,chamferend;
	float usedw,usedd,usedh,cradius,zdelta,CurRadius;
	Point3 va,vb,p;
	float depth, width, height;
	int genUVs = 1,sqvertex,CircleLayers;
	BOOL bias = 0,minusd;

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;	
	pblock->GetValue(PB_LENGTH,t,height,ivalid);
	pblock->GetValue(PB_WIDTH,t,width,ivalid);
	pblock->GetValue(PB_HEIGHT,t,depth,ivalid);
	minusd=depth<0.0f;
	depth=(float)fabs(depth);
	pblock->GetValue(PB_RADIUS,t,cradius,ivalid);
	pblock->GetValue(PB_LSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_WSEGS,t,wsegs,ivalid);
	pblock->GetValue(PB_HSEGS,t,dsegs,ivalid);
	pblock->GetValue(PB_CSEGS,t,csegs,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);
	
	LimitValue(csegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(dsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);

	smooth=(smooth>0?1:0);
	mesh.setSmoothFlags(smooth);
	float twocrad,usedm,mindim=(height>width?(width>depth?depth:width):(height>depth?depth:height));
	usedm=mindim-2*cradius;
	if (usedm<0.01f) cradius=(mindim-0.01f)/2.0f;
	twocrad=2.0f*cradius;
    usedh=height-twocrad;
    usedw=width-twocrad;
    usedd=depth-twocrad;
	float cangincr=PI/(2.0f*csegs),cudelta,udist;
    CircleLayers=csegs;
	cudelta=cradius*(float)sqrt(2.0f*(1.0f-(float)cos(cangincr)));
	udist=4.0f*csegs*cudelta+2.0f*width+2.0f*height-4.0f*cradius;
	chamferinfo[0].surface=1;chamferinfo[0].deltavert=1;
	chamferinfo[1].surface=2;chamferinfo[1].deltavert=1;
	chamferinfo[2].surface=1;chamferinfo[2].deltavert=-1;
	chamferinfo[3].surface=2;chamferinfo[3].deltavert=-1;
    WLines=wsegs-1;
    HLines=hsegs-1;
    DLines=dsegs-1;
    CLines=csegs+1;
    VertexPerSlice=2*(WLines+HLines)+4*CLines;
/* WLines*HLines on middle, 2*Clines*(WLines+HLines) on sides, 4*CLines*csegs+4 for circles */
    VertexPerFace=WLines*HLines+2*CLines*(WLines+HLines+2*csegs)+4;
    vertices=VertexPerFace*2+VertexPerSlice*DLines;
    sqvertex=(wsegs+1)*(hsegs+1);
/* 4 vertices, 2 faces/cseg + 2 each hseg & wseg sides, each seg w/ 2 faces*/
    SidesPerSlice=2*(2*csegs+hsegs+wsegs);
    FacesPerSlice=SidesPerSlice*2;
/* this one only has 1 face/ cseg */
    topchamferfaces=4*(csegs+hsegs+wsegs);
/*top chamfer + top face(2 faces/seg)(*2 for bottom) plus any depth faces*/
    maxfaces=2*(topchamferfaces+2*hsegs*wsegs)+(2*(CircleLayers-1)+dsegs)*FacesPerSlice;
    chamferstart=2*hsegs*wsegs;
    chamferend=chamferstart+topchamferfaces+(CircleLayers-1)*FacesPerSlice;
    chamferinfo[0].deltavert +=wsegs;
    chamferinfo[2].deltavert -=wsegs;
	int bottomvertex,vertexnum,tverts;
	int twomapped,endvert=vertices+(twomapped=2*VertexPerSlice);
	float xmax,ymax;
	mesh.setNumVerts(vertices);
	mesh.setNumFaces(maxfaces);
	tverts=endvert+DLines+2;
	if (genUVs)
	{ mesh.setNumTVerts(tverts);
	  mesh.setNumTVFaces(maxfaces);
	}
	else
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
    zdelta=depth/2;
    wsegcount=0;vertexnum=0;
    bottomvertex=vertices-1;
    CornerPt.z=zdelta;
    CornerPt.x=(xmax=width/2)-cradius;
    CornerPt.y=(ymax=height/2)-cradius;
    NewPt.x=Toppt.x=-CornerPt.x;
    NewPt.y=Toppt.y=CornerPt.y;
    NewPt.z=Toppt.z=zdelta;
      /* Do top and bottom faces */
	hincr=usedh/hsegs;		//yincr
	wincr=usedw/wsegs;		//xincr
	int segcount,topvertex,tvcounter=0,tvbottom=endvert-1;
	float udiv=2.0f*xmax,vdiv=2.0f*ymax,u,v;
	for (hseg=0;hseg<=hsegs;hseg++)
	{ if (hseg>0) 
	  {NewPt.y=(hseg==hsegs?-CornerPt.y:Toppt.y-hseg*hincr); NewPt.x=Toppt.x; }
	  for (segcount=0;segcount<=wsegs;segcount++)
	  { /* make top point */
	   NewPt.z=Toppt.z;
       NewPt.x=(segcount==wsegs?CornerPt.x:Toppt.x+segcount*wincr);
	   if (genUVs) 
		 mesh.setTVert(vertexnum,u=(xmax+NewPt.x)/udiv,v=(ymax+NewPt.y)/vdiv,0.0f);
	   mesh.setVert(vertexnum++,NewPt);
		/* make bottom pt */
       NewPt.z=-zdelta;
	   if (genUVs) 
	     mesh.setTVert(tvbottom--,u,1.0f-v,0.0f);
	   mesh.setVert(bottomvertex--,NewPt);
	  }
	}
    /* start on the chamfer */
	int layer,vert;
    layer=0;
    hseg=0;
	tvcounter=vertexnum;
    bottomvertex-=(VertexPerSlice-1);
    topvertex=vertexnum;
	BOOL done,atedge;
	float dincr=usedd/dsegs,cincr=2.0f*CircleLayers,RotationAngle;
	float dx,dy;
	int cornervert[4],PtRotation;
     for (layer=1;layer<=CircleLayers;layer++)	   /* add chamfer layer */
	 { if (layer==CircleLayers)	{zdelta=cradius;CurRadius=cradius;}
	   else
	   { RotationAngle=(PI*layer)/cincr;
	 	 zdelta=cradius-(cradius*(float)cos(RotationAngle));
		 CurRadius=cradius*(float)sin(RotationAngle);
	   }
	   zdelta=CornerPt.z-zdelta;
       atedge=(layer==CircleLayers);
	   int vfromedge=0,oldside=0,vfromstart=0;
	   sidenum=0;
	   float u1,v1;
	   BOOL atstart=TRUE;
       while (vertexnum<topvertex+csegs)	/* add vertex loop */
	   { PtRotation=hseg=wsegcount=0;done=FALSE;
         RotationAngle=(vertexnum-topvertex)*cangincr;
         curvertex=vert=vertexnum;
		 NewPt.x=Toppt.x-(dx=CurRadius*(float)sin(RotationAngle));
         NewPt.y=Toppt.y+(dy=CurRadius*(float)cos(RotationAngle));
         NewPt.z=zdelta;
		 while (!done)
		 { mesh.setVert(vert,NewPt);
		   if (genUVs) 
		    mesh.setTVert(vert,u1=(xmax+NewPt.x)/udiv,v1=(ymax+NewPt.y)/vdiv,0.0f);
           /* reflected vertex to second face */
           vert=bottomvertex+curvertex-topvertex;
           NewPt.z=-zdelta;
		   mesh.setVert(vert,NewPt);
		   if (genUVs)
		     mesh.setTVert(vert+twomapped,u1,1.0f-v1,0.0f);
           if ((atedge)&&(DLines>0))	 /* add non-corner points */
		    for (segcount=1;segcount<=DLines;segcount++)
		    { NewPt.z=zdelta-segcount*dincr;
		      mesh.setVert(vert=curvertex+VertexPerSlice*segcount,NewPt);
		    }
		   /* Rotate Pt */
		   if (!(done=PtRotation>5))
		   { if (vertexnum==topvertex) 
		     { FillinSquare(&PtRotation,cornervert,CurRadius);
		       if (curvertex==topvertex+VertexPerSlice-1) (PtRotation)=6;
		     }
			 else
				CalculateNewPt(dx,dy,&PtRotation,cornervert,vertexnum-topvertex);
		     vert=curvertex;
			 NewPt.z=zdelta;
		   }
		 }
	     vertexnum++;	   /* done rotation */
	   }
       vertexnum=topvertex +=VertexPerSlice;
       bottomvertex -=VertexPerSlice;  
	}
	float dfromedge=0.0f;
	int tvnum,j,i,chsegs=csegs+1,cwsegs=wsegs;
	if (genUVs)
	{ u=0.0f;
	  dfromedge=-cudelta;
	  tvnum=vertexnum;
	  vertexnum=topvertex-VertexPerSlice;
	  for (j=0;j<2;j++)
	  {
	  for (int gverts=0;gverts<chsegs;gverts++)
	  {	dfromedge+=cudelta;
		mesh.setTVert(tvnum,u=dfromedge/udist,1.0f,0.0f);
	    for (i=1;i<=dsegs;i++)
	     mesh.setTVert(tvnum+VertexPerSlice*i,u,1.0f-(float)i/dsegs,0.0f);
		vertexnum++;
		tvnum++;
	  }
	  chsegs=csegs;
	  for (gverts=0;gverts<hsegs;gverts++)
	  { dfromedge+=(float)fabs(mesh.verts[vertexnum].y-mesh.verts[vertexnum-1].y);
		mesh.setTVert(tvnum,u=dfromedge/udist,1.0f,0.0f);
	    for (i=1;i<=dsegs;i++)
	     mesh.setTVert(tvnum+VertexPerSlice*i,u,1.0f-(float)i/dsegs,0.0f);
		vertexnum++;
		tvnum++;
	  }
	  for (gverts=0;gverts<csegs;gverts++)
	  {	dfromedge+=cudelta;
		mesh.setTVert(tvnum,u=dfromedge/udist,1.0f,0.0f);
	    for (i=1;i<=dsegs;i++)
	     mesh.setTVert(tvnum+VertexPerSlice*i,u,1.0f-(float)i/dsegs,0.0f);
		vertexnum++;
		tvnum++;
	  }
	  if (j==1) cwsegs--;
	  for (gverts=0;gverts<cwsegs;gverts++)
	  { dfromedge+=(float)fabs(mesh.verts[vertexnum].x-mesh.verts[vertexnum-1].x);
		mesh.setTVert(tvnum,u=dfromedge/udist,1.0f,0.0f);
	    for (i=1;i<=dsegs;i++)
	     mesh.setTVert(tvnum+VertexPerSlice*i,u,1.0f-(float)i/dsegs,0.0f);
		vertexnum++;
		tvnum++;
	  }
	  }
	  int lastvert=endvert;
	  mesh.setTVert(lastvert++,1.0f,1.0f,0.0f);
	  for (j=1;j<dsegs;j++)
	    mesh.setTVert(lastvert++,1.0f,1.0f-(float)j/dsegs,0.0f);
	  mesh.setTVert(lastvert,1.0f,0.0f,0.0f);
	}
    /* all vertices calculated - Now specify faces*/
	 int tvdelta=0;
    sidenum=topnum=face=fcount=scount=circleseg=0;
    curvertex=wsegs+1;
    firstface=layer=1;
//	smooth=(csegs>1?1:0);
    tstartpt=cstartpt=endpt=0;
    boxpos=topsquare;cstartpt=chamferinfo[0].deltavert;
	AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
      while (face<chamferstart)   /* Do Square Layer */
	  { firstface=!firstface;
		AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
      }  
      boxpos=messyedge;firstface=1;
      topnum=tstartpt=0;
      cstartpt=curvertex=topnum+sqvertex;circleseg=1;
      endpt=hsegs*(wsegs+1);
      /* Do Chamfer */
	  while (face<chamferend)
      { AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
		if (circleseg==0) firstface=!firstface;
	  }
      fcount=scount=0;
      boxpos=middle;tvdelta+=VertexPerSlice;
     /*Do box sides */
	  int tpt,lastv=tverts-1;
	  BOOL inside=TRUE;
      while (face<maxfaces-chamferstart-topchamferfaces)
	  { tpt=face;
		AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
		if (genUVs && inside)
		{ if ((firstface)&&(mesh.tvFace[tpt].t[2]<mesh.tvFace[tpt].t[1]))
			mesh.tvFace[tpt].t[2]=endvert+1;
		  else if (mesh.tvFace[tpt].t[2]<mesh.tvFace[tpt].t[0])
		  { mesh.tvFace[tpt].t[1]=endvert+1;
			mesh.tvFace[tpt].t[2]=endvert;
			endvert++;
			if (!(inside=endvert<lastv)) 
			  tvdelta+=VertexPerSlice;
		  }
		}	
		firstface=!firstface;
	  }
      /* back in chamfer */
      circleseg=2;firstface=0;
      boxpos=bottomedge;
      sidenum=0;tstartpt=topnum;
      cstartpt=curvertex=vertices-1;
      endpt=cstartpt-hsegs*chamferinfo[0].deltavert;
	  while (face<maxfaces-chamferstart)  /* Do Second Chamfer */
	  { AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
		if (circleseg==0) firstface=!firstface;
	  }
      boxpos=bottomsquare;
      curvertex=topnum;
      topnum=curvertex+chamferinfo[0].deltavert;
      firstface=1;fcount=0;
	  while (face<maxfaces)
	  { AddFace(&mesh.faces[face],smooth,tvdelta,&mesh.tvFace[face],genUVs);
        firstface=!firstface;
	  }
    float deltaz=(minusd?-depth/2.0f:depth/2.0f);
	for (i=0;i<vertices;i++)
	{ mesh.verts[i].z+=deltaz;
	}
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

Object* ChBoxObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int ChBoxObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) 
	{
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}


class ChBoxObjCreateCallBack: public CreateMouseCallBack {
	ChBoxObject *ob;
	Point3 p0,p1;
	IPoint2 sp0, sp1,sp2;
	BOOL square;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(ChBoxObject *obj) { ob = obj; }
	};

int ChBoxObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{	Point3 d;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) 
	{switch(point) 
		{ case 0:
				sp0 = m;
				ob->pblock->SetValue(PB_WIDTH,0,0.0f);
				ob->pblock->SetValue(PB_LENGTH,0,0.0f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.0f);
				ob->suspendSnap = TRUE;								
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
#ifdef BOTTOMPIV
				{
				Point3 xyz = mat.GetTrans();
				xyz.z = p0.z;
				mat.SetTrans(xyz);
				}
#endif
				break;
			case 1:
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1.z = p0.z +(float).01; 
				if (ob->createMeth || (flags&MOUSE_CTRL)) 
				{  mat.SetTrans(p0);
				} else 
				{	mat.SetTrans(float(.5)*(p0+p1));
#ifdef BOTTOMPIV 					
					Point3 xyz = mat.GetTrans();
					xyz.z = p0.z;
					mat.SetTrans(xyz);					
#endif
				}
				d = p1-p0;
				square = FALSE;
				if (ob->createMeth) 
				{
					// Constrain to cube
					d.x = d.y = d.z = Length(d)*2.0f;
				} else 
				if (flags&MOUSE_CTRL) 
				{
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					square = TRUE;
				}
				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_HEIGHT,0,d.z);
				ob->pmapParam->Invalidate();										
				if (msg==MOUSE_POINT && ob->createMeth) 
				{ if (Length(sp1-sp0)<3) CREATE_ABORT;					
				} else if (msg==MOUSE_POINT && 
						(Length(sp1-sp0)<3 || Length(d)<0.1f)) 
				{  return CREATE_ABORT;
				}
				break;
			case 2:
			sp2=m;
			if (!ob->createMeth)
				{
#ifdef _OSNAP
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p0,Point3(0,0,1),sp1,m,TRUE));
#else
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
#endif
				d = p1-p0;
				if (square) 
				{ // Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;					
				}
				ob->pblock->SetValue(PB_WIDTH,0,float(fabs(d.x)));
				ob->pblock->SetValue(PB_LENGTH,0,float(fabs(d.y)));
				ob->pblock->SetValue(PB_HEIGHT,0,d.z);
				ob->pmapParam->Invalidate();
			}
			else
			{   d.x =vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,1,0),sp1,m));
			    if (d.x<0.0f) d.x=0.0f;
				ob->pblock->SetValue(PB_RADIUS,0,d.x);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT && ob->createMeth) 
				{ ob->suspendSnap = FALSE;
					return CREATE_STOP;					
				}
			}
				break;
			case 3:
				d.x =vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,1,0),sp2,m));
				if (d.x<0.0f) d.x=0.0f;
				ob->pblock->SetValue(PB_RADIUS,0,d.x);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{  ob->suspendSnap = FALSE;					
				   return CREATE_STOP;
				}
				break;
			}
	}	
	else
	if (msg == MOUSE_ABORT) 
	 {return CREATE_ABORT;}

	return TRUE;
}

static ChBoxObjCreateCallBack chboxCreateCB;

CreateMouseCallBack* ChBoxObject::GetCreateMouseCallBack() {
	chboxCreateCB.SetObj(this);
	return(&chboxCreateCB);
	}


BOOL ChBoxObject::OKtoDisplay(TimeValue t) 
	{
	/*
	float l, w, h;
	pblock->GetValue(PB_LENGTH,t,l,FOREVER);
	pblock->GetValue(PB_WIDTH,t,w,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,h,FOREVER);
	if (l==0.0f || w==0.0f || h==0.0f) return FALSE;
	else return TRUE;
	*/
	return TRUE;
	}


// From ParamArray
BOOL ChBoxObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: createMeth = v; break;
		}		
	return TRUE;
	}

BOOL ChBoxObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_LENGTH: crtLength = v; break;
		case PB_TI_WIDTH:  crtWidth = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		case PB_TI_RADIUS: crtRadius = v; break;
		}	
	return TRUE;
	}

BOOL ChBoxObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL ChBoxObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = createMeth; break;
		}
	return TRUE;
	}

BOOL ChBoxObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {				
		case PB_TI_LENGTH: v = crtLength; break;
		case PB_TI_WIDTH:  v = crtWidth; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		case PB_TI_RADIUS: v = crtRadius; break;
		}
	return TRUE;
	}

BOOL ChBoxObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void ChBoxObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *ChBoxObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH:return stdWorldDim;
		case PB_WIDTH: return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_RADIUS:return stdWorldDim;
		case PB_SMOOTH:return stdNormalizedDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_LSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;		
		case PB_CSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR ChBoxObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_LENGTH: return TSTR(GetString(IDS_RB_LENGTH));
		case PB_WIDTH:  return TSTR(GetString(IDS_RB_WIDTH));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_RADIUS: return TSTR(GetString(IDS_RB_FILLET));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_LSEGS:  return TSTR(GetString(IDS_RB_LSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		case PB_CSEGS:  return TSTR(GetString(IDS_RB_CSEGS));
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle ChBoxObject::Clone(RemapDir& remap) 
	{
	ChBoxObject* newob = new ChBoxObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
	}



// This is the method that actually handles the user input
// during the box creation.

// From Object

class ChBoxObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new ChBoxObject;}
	const TCHAR *	ClassName() { return GetString(IDS_AP_CHBOX_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SCS_C_CLASS_ID1,SCS_C_CLASS_ID2); }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);}	
	void			ResetClassParams(BOOL fileReset);
	};

static ChBoxObjClassDesc chboxObjDesc;

ClassDesc* GetChBoxobjDesc() { return &chboxObjDesc; }
// class variable for sphere class.
IObjParam *ChBoxObject::ip         = NULL;
int ChBoxObject::dlgLSegs          = BDEF_SEGS;
int ChBoxObject::dlgWSegs          = BDEF_SEGS;
int ChBoxObject::dlgHSegs          = BDEF_SEGS;
int ChBoxObject::dlgCSegs          = CDEF_SEGS;
IParamMap *ChBoxObject::pmapCreate = NULL;
IParamMap *ChBoxObject::pmapTypeIn = NULL;
IParamMap *ChBoxObject::pmapParam  = NULL;	
Point3 ChBoxObject::crtPos         = Point3(0,0,0);		
float ChBoxObject::crtWidth        = 0.1f; 
float ChBoxObject::crtHeight       = 0.1f;
float ChBoxObject::crtLength       = 0.1f;
float ChBoxObject::crtRadius       = 0.01f;
int ChBoxObject::createMeth        = 0;

void ChBoxObjClassDesc::ResetClassParams(BOOL fileReset)
	{
	ChBoxObject::dlgLSegs   = BDEF_SEGS;
	ChBoxObject::dlgWSegs   = BDEF_SEGS;
	ChBoxObject::dlgHSegs   = BDEF_SEGS;
	ChBoxObject::dlgCSegs   = BDEF_SEGS;
	ChBoxObject::crtWidth   = 0.0f; 
	ChBoxObject::crtHeight  = 0.0f;
	ChBoxObject::crtLength  = 0.0f;
	ChBoxObject::crtRadius  = 0.0f;
	ChBoxObject::createMeth = 0;
	ChBoxObject::crtPos         = Point3(0,0,0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\chcyl.cpp ===
/**********************************************************************
 *<
	FILE: chcyl.cpp - builds filleted/chamfered cylinders
   	Created by Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID CHCYL_CLASS_ID(0x7b9a546e, 0x21a446a1);
class ChCylinderObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtRadius,crtFillet;
		static float crtHeight,crtSliceFrom,crtSliceTo;
		static int dlgHSegs, dlgSides, dlgFSegs,dlgCSegs;
		static int dlgCreateMeth;
		static int dlgSmooth, dlgSlice;
		static Point3 crtPos;		
		
		ChCylinderObject();	
		BOOL increate;

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_CHCYLINDER); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return CHCYL_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_SLICE	float(-1.0E30)
#define MAX_SLICE	float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		12

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class ChCylClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ChCylinderObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_CHCYLINDER_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return CHCYL_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static ChCylClassDesc chcylDesc;

ClassDesc* GetChCylinderDesc() { return &chcylDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for ChCylinder class.
IObjParam *ChCylinderObject::ip         = NULL;
int ChCylinderObject::dlgHSegs			= DEF_SEGMENTS;
int ChCylinderObject::dlgFSegs			= 1;
int ChCylinderObject::dlgCSegs			= 1;
int ChCylinderObject::dlgSides          = DEF_SIDES;
int ChCylinderObject::dlgCreateMeth     = 1; // create_radius
int ChCylinderObject::dlgSmooth         = SMOOTH_ON;
int ChCylinderObject::dlgSlice          = 0;
IParamMap *ChCylinderObject::pmapCreate = NULL;
IParamMap *ChCylinderObject::pmapTypeIn = NULL;
IParamMap *ChCylinderObject::pmapParam  = NULL;
Point3 ChCylinderObject::crtPos         = Point3(0,0,0);
float ChCylinderObject::crtRadius       = 0.0f;
float ChCylinderObject::crtHeight       = 0.0f;
float ChCylinderObject::crtFillet       = 0.0f;
float ChCylinderObject::crtSliceFrom    = 0.0f;
float ChCylinderObject::crtSliceTo    = 0.0f;

void ChCylClassDesc::ResetClassParams(BOOL fileReset)
	{ ChCylinderObject::dlgHSegs			= DEF_SEGMENTS;
	  ChCylinderObject::dlgFSegs			= 1;
	  ChCylinderObject::dlgCSegs			= 1;
	  ChCylinderObject::dlgSides          = DEF_SIDES;
	  ChCylinderObject::dlgCreateMeth     = 1; // create_radius
	  ChCylinderObject::dlgSmooth         = SMOOTH_ON;
	  ChCylinderObject::dlgSlice          = 0;
	  ChCylinderObject::crtRadius       = 0.0f;
	  ChCylinderObject::crtHeight       = 0.0f;
	  ChCylinderObject::crtFillet       = 0.0f;
	  ChCylinderObject::crtSliceFrom    = 0.0f;
	  ChCylinderObject::crtSliceTo    = 0.0f;
	  ChCylinderObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS		0
#define PB_HEIGHT		1
#define PB_FILLET		2
#define PB_HSEGS		3
#define PB_FSEGS		4
#define PB_SIDES		5
#define PB_CSEGS		6
#define PB_SMOOTHON		7
#define PB_SLICEON		8
#define PB_SLICEFROM	9
#define PB_SLICETO		10
#define PB_GENUVS		11

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_HEIGHT		3
#define PB_TI_FILLET		4
// dont worry about the CREATE button here
#define BMIN_HEIGHT		float(-1.0E30)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.0)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UCYLS_BYDIA,IDC_UCYLS_BYRAD};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_CCY_POSX,IDC_CCY_POSXSPIN,
		IDC_CCY_POSY,IDC_CCY_POSYSPIN,
		IDC_CCY_POSZ,IDC_CCY_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_CCY_RADIUS,IDC_CCY_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CCY_HEIGHT,IDC_CCY_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Fillet
	ParamUIDesc(
		PB_TI_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_CCY_FILLET,IDC_CCY_FILLETSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	

	};
#define TYPEINDESC_LENGTH 4


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_CCY_RADIUS,IDC_CCY_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_CCY_HEIGHT,IDC_CCY_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Fillet
	ParamUIDesc(
		PB_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_CCY_FILLET,IDC_CCY_FILLETSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),	
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_CCY_HGTSEGS,IDC_CCY_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Fillet Segments
	ParamUIDesc(
		PB_FSEGS,
		EDITTYPE_INT,
		IDC_CCY_FILLETSEGS,IDC_CCY_FILLETSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_CCY_SIDES,IDC_CCY_SIDESSPIN,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Cap Segments
	ParamUIDesc(
		PB_CSEGS,
		EDITTYPE_INT,
		IDC_CCY_CAPSEGS,IDC_CCY_CAPSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTHON,TYPE_SINGLECHEKBOX,IDC_CCY_SMOOTHON),			

	// Gen Slice
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_CCY_SLICEON),			

	// Pie slice from
	ParamUIDesc(
		PB_SLICEFROM,
		EDITTYPE_FLOAT,
		IDC_CCY_SLICE1,IDC_CCY_SLICE1SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Pie slice to
	ParamUIDesc(
		PB_SLICETO,
		EDITTYPE_FLOAT,
		IDC_CCY_SLICE2,IDC_CCY_SLICE2SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),		

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			

	};
#define PARAMDESC_LENGTH 12


// variable type, NULL, animatable, number
ParamBlockDescID chcyldescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 } 
	};

#define PBLOCK_LENGTH	12

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(chcyldescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

void FixFillet(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float radius,height,fillet;

	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	pblock->GetValue(PB_FILLET,(increate?0:t),fillet,FOREVER);
	float hh=0.5f*(float)fabs(height),maxf=(hh>radius?radius:hh);
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_CCY_FILLETSPIN));
	  spin2->SetLimits(BMIN_LENGTH,maxf,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (fillet>maxf) pblock->SetValue(PB_FILLET,(increate?0:t),maxf);
}

//--- TypeInDlgProc --------------------------------

class ChCylTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		ChCylinderObject *ob;

		ChCylTypeInDlgProc(ChCylinderObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ChCylTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CCY_CREATE: {
					if (ob->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_FILLET,0,ob->crtFillet);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


class ChCylFilletDlgProc : public ParamMapUserDlgProc {
	public:
		ChCylinderObject *ob;

		ChCylFilletDlgProc(ChCylinderObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ChCylFilletDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_CCY_FILLETSPIN:
					FixFillet(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}
//--- ChCylinder methods -------------------------------

ChCylinderObject::ChCylinderObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(chcyldescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_FILLET,0,crtFillet);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);
	pblock->SetValue(PB_FSEGS,0,dlgFSegs);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_CSEGS,0,dlgCSegs);
	pblock->SetValue(PB_SMOOTHON,0,dlgSmooth);
	pblock->SetValue(PB_SLICEON,0,dlgSlice);
	pblock->SetValue(PB_SLICEFROM,0,crtSliceFrom);
	pblock->SetValue(PB_SLICETO,0,crtSliceTo);
	increate=FALSE;
	}

IOResult ChCylinderObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void ChCylinderObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last ChCylinder ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UREVS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_CHAMFERCYL2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_CHAMFERCYL3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}
	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new ChCylTypeInDlgProc(this));
		}
	if(pmapParam) {
		pmapParam->SetUserDlgProc(new ChCylFilletDlgProc(this));
		}
	}
		
void ChCylinderObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);
	pblock->GetValue(PB_FSEGS,ip->GetTime(),dlgFSegs,FOREVER);
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);	
	pblock->GetValue(PB_CSEGS,ip->GetTime(),dlgCSegs,FOREVER);	
	}

/*void ChCylinderObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	BOOL genUV, BOOL sliceOn, float slice1, float slice2) {
	pblock->SetValue(PB_RADIUS,0,radius);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_FILLET,0,fillet);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_FSEGS,0,fsegs);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_CSEGS,0,csegs);
	pblock->SetValue(PB_SMOOTH,0,smooth);
	pblock->SetValue(PB_SLICEON,0,slice);
	pblock->SetValue(PB_SLICEFROM,0,slice1);
	pblock->SetValue(PB_SLICETO,0,slice2);
	pblock->SetValue(PB_GENUVS,0,genUV);
	} */

/*void AddFace(Face *f,int a,int b,int c,int evis,int smooth_group)
{ f[0].setSmGroup(smooth_group);
  f[0].setMatID((MtlID)0); 	 //default 
  if (evis==0) f[0].setEdgeVisFlags(1,1,0);
  else if (evis==1) f[0].setEdgeVisFlags(0,1,1);
  else if (evis==2) f[0].setEdgeVisFlags(0,0,1);
  else f[0].setEdgeVisFlags(1,0,1);	
  f[0].setVerts(a,b,c);
}  */

void BuildChCylinderMesh(Mesh &mesh,
		int segs, int smooth, int llsegs, int capsegs, int csegs,int doPie,
		float radius1, float radius2, float height, float pie1, float pie2,
		int genUVs)
	{
	Point3 p;
	BOOL minush=height<0.0f;
	if (minush) height=-height;
	int ix,jx,ic = 1;
	int nf=0,nv=0, lsegs,VertexPerLevel;
	float delta,ang,hh=height*0.5f;	
	float totalPie, startAng = 0.0f;
	if (radius2>radius1) radius2=radius1;
	if (radius2>hh) radius2=hh;

	if (doPie) doPie = 1;
	else doPie = 0; 

	lsegs = llsegs-1 + 2*capsegs;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;		
	int nfaces,ntverts,levels=csegs*2+(llsegs-1);
	int capv=segs,sideedge=capsegs+csegs,*edgelstr,*edgelstl,totlevels,incap;
    // capv=vertex in one cap layer
	totlevels=levels+capsegs*2+2;
	incap=capsegs+1;
	int	tvinslice=totlevels+totlevels-2;
	if (doPie) {
		delta    = totalPie/(float)(segs);
		startAng = pie2; capv++;
		VertexPerLevel=segs+2;
		nfaces=2*segs*(levels+1)+(sideedge+llsegs)*4;
		ntverts=tvinslice+2*(segs+1);
		// 2 faces between every 2 vertices, with 2 ends, except in central cap)
	} else {
		delta = (float)2.0*PI/(float)segs;
		VertexPerLevel=segs;
		nfaces=2*segs*(levels+1);
		ntverts=2*(segs+1)+llsegs-1;
	}
	if (height<0) {delta = -delta;}
	edgelstl=new int[totlevels];
	edgelstr=new int[totlevels];
	int lastlevel=totlevels-1,dcapv=capv-1,dvertper=VertexPerLevel-1;
	edgelstr[0]=0;edgelstl[0]=0;
	edgelstr[1]=1;
	edgelstl[1]=capv;
	for (int i=2;i<=sideedge;i++)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	}
	while (i<=totlevels-sideedge)
	{ edgelstr[i]=edgelstr[i-1]+VertexPerLevel;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	while (i<lastlevel)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	edgelstl[lastlevel]=(edgelstr[lastlevel]=edgelstl[i-1]+1);
	int nverts=edgelstl[lastlevel]+1;

	nfaces+=2*segs*(2*capsegs-1);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	if (genUVs) 
	{ ntverts+=nverts;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	mesh.setSmoothFlags((smooth != 0) | ((doPie != 0) << 1));

	// bottom vertex 
	mesh.setVert(nv, Point3(0.0f,0.0f,height));
	mesh.setVert(nverts-1, Point3(0.0f,0.0f,0.0f));		
	float ru,cang,sang,rotz,botz,deltacsegs=PI/(2.0f*csegs),radius=radius1-radius2;
	int iy,msegs=segs,deltaend=nverts-capv-1;
	// Bottom cap vertices
	ang = startAng;	 
	if (!doPie) msegs--;
	for (jx = 0; jx<=msegs; jx++) 
	{ cang=(float)cos(ang);
	  sang=(float)sin(ang);
	  iy=0;
	  for(ix=1; ix<=sideedge; ix++)
	  { if (ix<=capsegs)
		{ botz=0.0f;
		  p.z = height;
		  ru=radius*float(ix)/float(capsegs);
	    }
		else
		{ iy++;
		  ru=radius+radius2*(float)sin(rotz=deltacsegs*float(iy));
		  if (jx==0)
		  {	p.z=(iy==csegs?height-radius2:height-radius2*(1.0f-(float)cos(rotz)));
		  } else p.z=mesh.verts[edgelstr[ix]].z;
		  botz=height-p.z;
		  if ((doPie)&&((jx==0)&&(ix==sideedge)))
		  {	mesh.setVert(edgelstl[ix]+1,Point3(0.0f,0.0f,p.z));
			mesh.setVert(edgelstl[lastlevel-ix]+1,Point3(0.0f,0.0f,botz));
		  }
		}
		p.x = cang*ru;
		p.y = sang*ru;	
		mesh.setVert(edgelstr[ix]+jx, p);
		mesh.setVert(edgelstr[lastlevel-ix]+jx,Point3(p.x,p.y,botz));
	  }
	  ang += delta;
	}
	//top layer done, now reflect sides down 
	int sidevs,startv=edgelstr[sideedge],deltav;
	if (llsegs>1)
	{ float sideheight=height-2.0f*radius2,topd=height-radius2,sincr=sideheight/llsegs;
	  for (sidevs=0;sidevs<VertexPerLevel;sidevs++)
	  { p=mesh.verts[startv];
	    deltav=VertexPerLevel;
	    for (ic=1;ic<llsegs;ic++)
	    { p.z =topd-sincr*ic;
	 	  mesh.setVert(startv+deltav, p);
		  deltav+=VertexPerLevel;
	    }
	    startv++;
	  }
	}
	int lasttvl=0,lasttvr=0;
	if (genUVs)
	{ int tvcount=0,nexttv;
	  float udenom=2.0f*radius1;
	  for (i=0;i<=sideedge;i++)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
	  }
	  int iseg,hcount=0;
	  float hlevel;
	  for (i=sideedge;i<=lastlevel-sideedge;i++)
	  { hlevel=1.0f-hcount++/(float)llsegs;
		for (iseg=0;iseg<=segs;iseg++)
		 mesh.setTVert(tvcount++,(float)iseg/segs,hlevel,0.0f);
	  }
	  i--;
	  while (i<=lastlevel)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
		i++;
	  }
	  if (doPie)
	  { lasttvl=lasttvr=tvcount;
		float u,v;
		mesh.setTVert(tvcount++,0.0f,1.0f,0.0f);
		for (i=sideedge;i<=sideedge+llsegs;i++)
	    { mesh.setTVert(tvcount++,0.0f,mesh.verts[edgelstl[i]].z/height,0.0f);
		}
		mesh.setTVert(tvcount++,0.0f,0.0f,0.0f);
		for (i=1;i<lastlevel;i++)
		{ u=(float)sqrt(mesh.verts[edgelstl[i]].x*mesh.verts[edgelstl[i]].x+mesh.verts[edgelstl[i]].y*mesh.verts[edgelstl[i]].y)/radius1;
		  v=mesh.verts[edgelstl[i]].z/height;
		  mesh.setTVert(tvcount++,u,v,0.0f);
		  mesh.setTVert(tvcount++,u,v,0.0f);
		}
	  }
	}	
	int lvert=(doPie?segs+1:segs);
    int t0,t1,b0,b1,tvt0=0,tvt1=0,tvb0=1,tvb1=2,fc=0,smoothgr=(smooth?4:0),vseg=segs+1;
	int tvcount=0,lowerside=lastlevel-sideedge,onside=0;
	BOOL ok,wrap;
	// Now make faces ---
	for (int clevel=0;clevel<lastlevel-1;clevel++)
	{ t1=(t0=edgelstr[clevel])+1;
	  b1=(b0=edgelstr[clevel+1])+1;
	  ok=!doPie; wrap=FALSE;
	  if ((clevel>0)&&((doPie)||(onside==1))) {tvt0++;tvt1++;tvb0++,tvb1++;}
	  if (clevel==1) {tvt0=1;tvt1=2;}
	  if (clevel==sideedge)
	    {tvt1+=lvert;tvt0+=lvert;tvb0+=vseg;tvb1+=vseg;onside++;}
	  else if (clevel==lowerside)
	    {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	  while ((b0<edgelstl[clevel+1])||ok)
	  { if (b1==edgelstr[clevel+2]) 
	    { b1=edgelstr[clevel+1]; 
	      t1=edgelstr[clevel];
		  ok=FALSE;wrap=(onside!=1);}
	  if (smooth)
	  { if (csegs>1) smoothgr=4;
	    else
	    {if ((clevel<capsegs)||(clevel>=lastlevel-capsegs))
	      smoothgr=4;
	    else if ((clevel<sideedge)||(clevel>=lowerside)) 
		  smoothgr=8;
		else smoothgr=16;
	    }
	  }
	  if (genUVs) mesh.tvFace[fc].setTVerts(tvt0,tvb0,(wrap?tvb1-segs:tvb1));
		AddFace(&mesh.faces[fc++],t0,b0,b1,0,smoothgr);
	    if (clevel>0)
		{ if (genUVs)
		  { if (wrap) mesh.tvFace[fc].setTVerts(tvt0++,tvb1-segs,tvt1-segs);
			else mesh.tvFace[fc].setTVerts(tvt0++,tvb1,tvt1);
			tvt1++;
		  }
		  AddFace(&mesh.faces[fc++],t0,b1,t1,1,smoothgr);
		  t0++;t1++;
		}
		b0++;b1++;tvb0++,tvb1++;
	  }
	}
	smoothgr=(smooth?4:0);
	t1=(t0=edgelstr[lastlevel-1])+1;b0=edgelstr[lastlevel];
	int lastpt=(doPie?lastlevel-1:lastlevel);
	if (doPie){tvt0++;tvt1++;tvb0++,tvb1++;}
	while (t0<edgelstl[lastpt])
	  { if ((!doPie)&&(t1==edgelstr[lastlevel]))
	    { t1=edgelstr[lastlevel-1];tvt1-=segs;}
		if (genUVs) mesh.tvFace[fc].setTVerts(tvt0++,tvb0,tvt1++);
		AddFace(&mesh.faces[fc++],t0,b0,t1,1,smoothgr);
		t0++;t1++;
	  }
	int chv=edgelstl[sideedge]+1,botcap=lastlevel-sideedge;
	int chb=edgelstl[botcap]+1,chm0,chm1,last=0,sg0=(smooth?2:0),sg1=(smooth?1:0);
	if (doPie)
	{int topctv=lasttvl+1,tvcount=topctv+llsegs+2;
	  for (i=1;i<=lastlevel;i++)
	  { if (i<=sideedge)
		{ if (genUVs)
		  { mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chv,edgelstl[last],(i==1?1:2),sg0);
		  AddFace(&mesh.faces[fc++],edgelstr[last],chv,edgelstr[i],(i==1?3:2),sg1);
		}
	    else if (i<=botcap)
		{ if (genUVs)
		  { topctv++;
			mesh.tvFace[fc].setTVerts(lasttvl,tvcount,topctv);
			mesh.tvFace[fc+1].setTVerts(lasttvl,topctv,topctv-1);lasttvl=tvcount++;
		    mesh.tvFace[fc+2].setTVerts(topctv-1,topctv,tvcount);
		    mesh.tvFace[fc+3].setTVerts(topctv-1,tvcount,lasttvr);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[last],edgelstl[i],chm1=(edgelstl[i]+1),0,sg0);
	      AddFace(&mesh.faces[fc++],edgelstl[last],chm1,chm0=(edgelstl[last]+1),1,sg0);
		  AddFace(&mesh.faces[fc++],chm0,chm1,edgelstr[i],0,sg1);
	      AddFace(&mesh.faces[fc++],chm0,edgelstr[i],edgelstr[last],1,sg1);
		}
		else
		{if (genUVs)
		  {	if (i==lastlevel) tvcount=topctv+1;
			mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);
			  if (i<lastlevel) lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chb,edgelstl[last],(i==lastlevel?3:2),sg0);
	      AddFace(&mesh.faces[fc++],edgelstr[last],chb,edgelstr[i],(i==lastlevel?1:2),sg1);
		}
		last++;
	  }
	}
	if (minush)
	for (i=0;i<nverts;i++)
	{ mesh.verts[i].z-=height;	}
	if (edgelstr) delete []edgelstr;
	if (edgelstl) delete []edgelstl;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts);
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

BOOL ChCylinderObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void ChCylinderObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void ChCylinderObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, hsegs, capsegs,fsegs;
	float radius,height,pie1, pie2,fillet;
	int doPie, genUVs;	

	FixFillet(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	
	pblock->GetValue(PB_FSEGS,t,fsegs,ivalid);
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_CSEGS,t,capsegs,ivalid);
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_FILLET,t,fillet,ivalid);
	pblock->GetValue(PB_SMOOTHON,t,smooth,ivalid);	
	pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
	pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(fsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(capsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
	
	BuildChCylinderMesh(mesh,
		segs, smooth, hsegs, capsegs, fsegs,doPie,
		radius, fillet, height, pie1, pie2, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f


Object* ChCylinderObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int ChCylinderObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class ChCylinderObjCreateCallBack: public CreateMouseCallBack {
	ChCylinderObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1,sp2;
	float h,r;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(ChCylinderObject *obj) { ob = obj; }
	};

int ChCylinderObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float f;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->pblock->SetValue(PB_FILLET,0,0.01f);
				ob->increate=TRUE;
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 ||
						Length(p[1]-p[0])<0.1f) {	
						ob->increate=FALSE;
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				{ sp2=m;
#ifdef _OSNAP
				h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					if (Length(m-sp0)<3) 
					{ ob->increate=FALSE;return CREATE_ABORT;}
					}
				}
				break;
			case 3:
				f =vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				float hh=0.5f*float(fabs(h));if (f<0.0f) f=0.0f;
				if (f>r) f=r;
				if (f>hh) f=hh;
				ob->pblock->SetValue(PB_FILLET,0,f);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{  ob->suspendSnap = FALSE;	
				   ob->increate=FALSE;
				   return CREATE_STOP;
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		ob->increate=FALSE;
		return CREATE_ABORT;
		}

	return TRUE;
	}

static ChCylinderObjCreateCallBack cylCreateCB;

CreateMouseCallBack* ChCylinderObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL ChCylinderObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL ChCylinderObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL ChCylinderObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		case PB_TI_FILLET: crtFillet = v; break;
		}	
	return TRUE;
	}

BOOL ChCylinderObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL ChCylinderObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL ChCylinderObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		case PB_TI_FILLET: v = crtFillet; break;
		}
	return TRUE;
	}

BOOL ChCylinderObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void ChCylinderObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *ChCylinderObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return stdWorldDim;
		case PB_HEIGHT: return stdWorldDim;
		case PB_FILLET: return stdWorldDim;
		case PB_HSEGS: return stdSegmentsDim;
		case PB_FSEGS: return stdSegmentsDim;
		case PB_SIDES: return stdSegmentsDim;
		case PB_CSEGS: return stdSegmentsDim;
		case PB_SLICEFROM: return stdAngleDim;
		case PB_SLICETO: return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR ChCylinderObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return TSTR(GetString(IDS_RB_RADIUS));
		case PB_HEIGHT:  return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_FILLET: return TSTR(GetString(IDS_RB_FILLET));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		case PB_FSEGS:  return TSTR(GetString(IDS_RB_FSEGS));
		case PB_SIDES:  return TSTR(GetString(IDS_RB_SIDES));
		case PB_CSEGS:  return TSTR(GetString(IDS_RB_CAPSEGS));
		case PB_SMOOTHON: return TSTR(GetString(IDS_RB_SMOOTHON));
		case PB_SLICEON: return TSTR(GetString(IDS_RB_SLICEON));
		case PB_SLICEFROM:  return TSTR(GetString(IDS_RB_SLICEFROM));
		case PB_SLICETO:  return TSTR(GetString(IDS_RB_SLICETO));
		//case PB_GENUVS:		return GetString(IDS_RB_GENTEXCOORDS);
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle ChCylinderObject::Clone(RemapDir& remap) 
	{
	ChCylinderObject* newob = new ChCylinderObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\gengon.cpp ===
/**********************************************************************
 *<
	FILE: gengon.cpp - builds generalized n-gonal extrusions
	CREATED BY:  Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID GENGON_CLASS_ID(0x49bf599f, 0x35f945ab);
class GengonObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtRadius,crtFillet;
		static float crtHeight;
		static int dlgHSegs, dlgSides, dlgFSegs,dlgSSegs;
		static int dlgCreateMeth;
		static Point3 crtPos;	
		BOOL increate;
		
		GengonObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_GENGON); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return GENGON_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		5

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class GengonClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new GengonObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_GENGON_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return GENGON_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static GengonClassDesc GengonDesc;

ClassDesc* GetGengonDesc() { return &GengonDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Gengon class.
IObjParam *GengonObject::ip         = NULL;
int GengonObject::dlgHSegs			= DEF_SEGMENTS;
int GengonObject::dlgFSegs			= 1;
int GengonObject::dlgSSegs			= 1;
int GengonObject::dlgSides          = DEF_SIDES;
int GengonObject::dlgCreateMeth     = 1; // create_radius
IParamMap *GengonObject::pmapCreate = NULL;
IParamMap *GengonObject::pmapTypeIn = NULL;
IParamMap *GengonObject::pmapParam  = NULL;
Point3 GengonObject::crtPos         = Point3(0,0,0);
float GengonObject::crtRadius       = 0.0f;
float GengonObject::crtHeight       = 0.0f;
float GengonObject::crtFillet       = 0.0f;

void GengonClassDesc::ResetClassParams(BOOL fileReset)
	{ GengonObject::dlgHSegs			= DEF_SEGMENTS;
	  GengonObject::dlgFSegs			= 1;
	  GengonObject::dlgSSegs			= 1;
	  GengonObject::dlgSides          = DEF_SIDES;
	  GengonObject::dlgCreateMeth     = 1; // create_radius
	  GengonObject::crtRadius       = 0.0f;
	  GengonObject::crtHeight       = 0.0f;
	  GengonObject::crtFillet       = 0.0f;
	  GengonObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_SIDES		0
#define PB_RADIUS		1
#define PB_FILLET		2
#define PB_HEIGHT		3
#define PB_SSEGS		4
#define PB_FSEGS		5
#define PB_HSEGS		6
#define PB_GENUVS		7
#define PB_SMOOTH		8

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_SIDES			2
#define PB_TI_RADIUS		3
#define PB_TI_FILLET		4
#define PB_TI_HEIGHT		5

// dont worry about the CREATE button here
#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UCYLS_BYDIA,IDC_UCYLS_BYRAD};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1


//
//
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_GG_POSX,IDC_GG_POSXSPIN,
		IDC_GG_POSY,IDC_GG_POSYSPIN,
		IDC_GG_POSZ,IDC_GG_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Sides
	ParamUIDesc(
		PB_TI_SIDES,
		EDITTYPE_INT,
		IDC_GG_SIDES,IDC_GG_SIDESSPIN,
		float(MIN_SIDES),float(MAX_SIDES),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_GG_RADIUS,IDC_GG_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Fillet
	ParamUIDesc(
		PB_TI_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_GG_FILLET,IDC_GG_FILLETSPIN,
		0.0f,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
		
	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_GG_HEIGHT,IDC_GG_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
	
};

#define TYPEINDESC_LENGTH 5


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_GG_SIDES,IDC_GG_SIDESSPIN,
		float(MIN_SIDES),float(MAX_SIDES),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_GG_RADIUS,IDC_GG_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),	

	// Fillet
	ParamUIDesc(
		PB_FILLET,
		EDITTYPE_UNIVERSE,
		IDC_GG_FILLET,IDC_GG_FILLETSPIN,
		0.0f,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
		
	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_GG_HEIGHT,IDC_GG_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Side Segments
	ParamUIDesc(
		PB_SSEGS,
		EDITTYPE_INT,
		IDC_GG_SIDESEGS,IDC_GG_SIDESEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Fillet Segments
	ParamUIDesc(
		PB_FSEGS,
		EDITTYPE_INT,
		IDC_GG_FILLETSEGS,IDC_GG_FILLETSEGSSPIN,
		0.0f,(float)MAX_SEGMENTS,
		0.1f),

	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_GG_HGTSEGS,IDC_GG_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTH,TYPE_SINGLECHEKBOX,IDC_OT_SMOOTH),
	
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 9


// variable type, NULL, animatable, number
ParamBlockDescID gengondescVer0[] = {
	{ TYPE_INT, NULL, TRUE, 0 }, 
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, FALSE, 7 } 
	};

ParamBlockDescID gengondescVer1[] = {
	{ TYPE_INT, NULL, TRUE, 0 }, 
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, FALSE, 7 }, 
	{ TYPE_INT, NULL, FALSE, 8 } 
	};

#define PBLOCK_LENGTH	9

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(gengondescVer0,8,0),	
	};
#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(gengondescVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

void FixGenFilletLimits(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float s,fillet,r;
  int sides;

	pblock->GetValue(PB_SIDES,t,sides,FOREVER);
	pblock->GetValue(PB_RADIUS,t,r,FOREVER);
	pblock->GetValue(PB_FILLET,(increate?0:t),fillet,FOREVER);
	s=(float)sqrt(2.0f*r*r*(1-(float)cos(TWOPI/sides)));
	s*=0.499f;
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_GG_FILLETSPIN));
	  spin2->SetLimits(0.0f,s,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (fillet>s) pblock->SetValue(PB_FILLET,(increate?0:t),s);
}
class GengonCapValsDlgProc : public ParamMapUserDlgProc {
	public:
		GengonObject *ob;

		GengonCapValsDlgProc(GengonObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL GengonCapValsDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_GG_FILLETSPIN:
					FixGenFilletLimits(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}

class GengonTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		GengonObject *ob;

		GengonTypeInDlgProc(GengonObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL GengonTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_GG_CREATE: {
					if (ob->crtRadius==0.0f) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_SIDES,0,ob->dlgSides);
						ob->pblock->SetValue(PB_FILLET,0,ob->crtFillet);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Gengon methods -------------------------------

GengonObject::GengonObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(gengondescVer1,PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_FILLET,0,crtFillet);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_SSEGS,0,dlgSSegs);
	pblock->SetValue(PB_FSEGS,0,dlgFSegs);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);
	increate=FALSE;
	}

IOResult GengonObject::Load(ILoad *iload) 
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));
	return IO_OK;
	}


void GengonObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Gengon ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UREVS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_GENGON2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_GENGON3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new GengonTypeInDlgProc(this));
		}	
	}
		
void GengonObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);
	pblock->GetValue(PB_FSEGS,ip->GetTime(),dlgFSegs,FOREVER);
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);	
	pblock->GetValue(PB_SSEGS,ip->GetTime(),dlgSSegs,FOREVER);	
	}

/*void GengonObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	BOOL genUV, BOOL sliceOn, float slice1, float slice2) {
	pblock->SetValue(PB_RADIUS,0,radius);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_FILLET,0,fillet);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_FSEGS,0,fsegs);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_SSEGS,0,SSegs);
	pblock->SetValue(PB_SMOOTH,0,smooth);
	pblock->SetValue(PB_GENUVS,0,genUV);
	} */

/*void AddFace(Face *f,int a,int b,int c,int evis,int smooth_group)
{ f[0].setSmGroup(smooth_group);
  f[0].setMatID((MtlID)0); 	 //default 
  if (evis==0) f[0].setEdgeVisFlags(1,1,0);
  else if (evis==1) f[0].setEdgeVisFlags(0,1,1);
  else if (evis==2) f[0].setEdgeVisFlags(0,0,1);
  else f[0].setEdgeVisFlags(1,0,1);	
  f[0].setVerts(a,b,c);
}  */

void BuildGengonMesh(Mesh &mesh,
		int segs, int llsegs, int sidesegs, int fsegs,
		float radius1, float fillet, float height, int genUVs,int smooth)
	{
	Point3 p;
	BOOL minush=(height<0.0f);
	if (minush) height=-height;
	int ix,jx,ic = 1,ssegs=sidesegs-1;
	int nf=0,VertexPerLevel,totalsegs=segs+segs*(ssegs+fsegs);
	float delta,ang;	
	float startAng = 0.0f;	

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	int nfaces,ntverts;
	VertexPerLevel=totalsegs;
	nfaces=2*totalsegs*(llsegs+1);
	int nverts=VertexPerLevel*(llsegs+1)+2;

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth);
	if (genUVs) 
	{ ntverts=nverts+2*VertexPerLevel+llsegs+1;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	
	delta = (float)2.0*PI/(float)segs;
	if (height<0) delta = -delta;
	mesh.setVert(0, Point3(0.0f,0.0f,height));
	mesh.setVert(nverts-1, Point3(0.0f,0.0f,0.0f));
	// fill in fillet 
	float alfa,theta=(segs-2)*PI/(float)segs,theta2=theta/2.0f,k;
	float stepangle,sang,x,y,l1,l2,ax,ay,cx;
	int i,nv=2;
	if (fsegs>0)
	{ alfa=PI-theta;
	  sang=stepangle=alfa/fsegs;
	  k=fillet*(float)sin(theta2);
	  l1=k/(float)tan(alfa/2.0f);
	  l2=fillet*(float)cos(theta2);
	  cx=radius1-l1-l2;
	  ax=l1;ay=-k;	
	  mesh.setVert(1,Point3(cx+ax,ay,height));
	  for (i=1;i<=fsegs;i++)
	  {	x=cx+(float)cos(sang)*ax-(float)sin(sang)*ay;
	    y=(float)sin(sang)*ax+(float)cos(sang)*ay;
		mesh.setVert(nv++,Point3(x,y,height));
		sang+=stepangle;
	  }
	} else mesh.setVert(1,Point3(radius1,0.0f,height));
	ang=delta;
	for (jx = 1; jx<segs; jx++) 
	{ nv+=ssegs;
	  for (ix=0; ix<=fsegs; ix++)
	  {	x=(float)cos(ang)*mesh.verts[ix+1].x-(float)sin(ang)*mesh.verts[ix+1].y;
	    y=(float)sin(ang)*mesh.verts[ix+1].x+(float)cos(ang)*mesh.verts[ix+1].y;
		mesh.setVert(nv++, Point3(x,y,height));
	  }
	  ang += delta;
	}
	// fill in side segments
	int startpt,cpt,sidept,endpt=(startpt=1+fsegs)+sidesegs,lasts=segs-1;
	float deltax,deltay;
	if (sidesegs>1)
	 for (i=1;i<=segs;i++)
	 { cpt=startpt+1;
	   deltax=(mesh.verts[endpt].x-mesh.verts[startpt].x)/sidesegs;
	   deltay=(mesh.verts[endpt].y-mesh.verts[startpt].y)/sidesegs;
	   for (sidept=1;sidept<sidesegs;sidept++)
	   { mesh.verts[cpt].z=height;
		 mesh.verts[cpt].x=mesh.verts[startpt].x+(float)sidept*deltax;
		 mesh.verts[cpt++].y=mesh.verts[startpt].y+(float)sidept*deltay;
	   }
	   endpt=(startpt=cpt+fsegs)+sidesegs;
	   if (i==lasts) endpt-=totalsegs;
	 }
	else 
	{  deltax=mesh.verts[2].x-mesh.verts[1].x;
	   deltay=mesh.verts[2].y-mesh.verts[1].y;
	}
	//top layer done, now reflect sides down 
	int sidevs,startv=1,deltav;
	float sincr=height/llsegs;
	for (sidevs=0;sidevs<VertexPerLevel;sidevs++)
	{ p=mesh.verts[startv];
	  deltav=VertexPerLevel;
	  for (ic=1;ic<=llsegs;ic++)
	  { p.z =height-sincr*ic;
	    mesh.setVert(startv+deltav, p);
	    deltav+=VertexPerLevel;
	  }
	  startv++;
	}
	int tvcount;
	if (genUVs)
	{ float sidedist=(float)sqrt((deltax*deltax)+(deltay*deltay));
	  float sdenom=(fillet+sidedist)*segs,udenom=2.0f*radius1;
	  float fdist=(fsegs>0?(fillet/fsegs)/sdenom:0.0f),sdist=(sidedist/sidesegs)/sdenom;
	  tvcount=0;
	  for (i=0;i<=VertexPerLevel;i++)
	  { mesh.setTVert(tvcount++,(radius1+mesh.verts[i].x)/udenom,(radius1+mesh.verts[i].y)/udenom,0.0f);
	  }
	  int iseg,hcount=0,fcount;
	  float hlevel,u;
	  for (i=0;i<=llsegs;i++)
	  { hlevel=1.0f-hcount++/(float)llsegs;
		mesh.setTVert(tvcount++,u=0.0f,hlevel,0.0f);
		for (iseg=0;iseg<segs;iseg++)
		{ for (fcount=0;fcount<fsegs;fcount++)
		   mesh.setTVert(tvcount++,u+=fdist,hlevel,0.0f);
		  for (fcount=0;fcount<sidesegs;fcount++)
		   mesh.setTVert(tvcount++,u+=sdist,hlevel,0.0f);
		}
		mesh.tVerts[tvcount-1].x=1.0f;
	  }
	  i=nverts-VertexPerLevel-1;
	  while (tvcount<ntverts)
	  { mesh.setTVert(tvcount++,(radius1+mesh.verts[i].x)/udenom,(radius1+mesh.verts[i].y)/udenom,0.0f);
	    i++;
	  }
	}	
	int lvert=segs;
    int fc=0,sidesm=(smooth?2:0);
	int last=VertexPerLevel-1;
	BOOL evengr=TRUE;
	// Now make faces ---
	int j,b0=1,b1=2,tb0,tb1,tt0,tt1,t0,t1,ecount=0;
	for (i=0;i<VertexPerLevel;i++)
	{ if (genUVs) mesh.tvFace[fc].setTVerts(0,b0,(i<last?b1:1));
	AddFace(&mesh.faces[fc++],0,b0++,(i<last?b1++:1),0,smooth);
	}
	tt1=(tt0=i+1)+1;t0=1;t1=2;b1=(b0=t0+VertexPerLevel)+1;
	tb1=(tb0=tt1+VertexPerLevel)+1;
	for (i=1;i<=llsegs;i++)
	{ ecount=0;
	  for(j=0;j<VertexPerLevel;j++)
	  { if (genUVs) 
		{ mesh.tvFace[fc].setTVerts(tt0,tb0++,tb1);
		  mesh.tvFace[fc+1].setTVerts(tt0++,tb1++,tt1++);
		}
		if (fsegs==0) 
		{ if (sidesm)
			{sidesm=(evengr?2:4);
		     if ((j==last)&&(evengr)) sidesm=8;
			}
		  ecount++;if (ecount==sidesegs) {ecount=0;evengr=!evengr;}
	    }
	AddFace(&mesh.faces[fc++],t0,b0++,(j==last?t1:b1),0,sidesm);
	if (j<last)
	  AddFace(&mesh.faces[fc++],t0++,b1,t1,1,sidesm);
	else
	  AddFace(&mesh.faces[fc++],t0++,b1-VertexPerLevel,t1-VertexPerLevel,1,sidesm);
	t1++;b1++;
	  }
	 tt0++;tt1++;tb0++;tb1++;
	}
	if (genUVs) {tt0=(tt1=ntverts-VertexPerLevel)-1;tb0=ntverts-1;}
	for (i=0;i<VertexPerLevel;i++)
	{ if (genUVs)
	   { mesh.tvFace[fc].setTVerts(tt0++,tb0,(i==last?tt1-VertexPerLevel:tt1));
	     tt1++;
	   }
	AddFace(&mesh.faces[fc++],t0++,b0,(i==last?t1-VertexPerLevel:t1),1,smooth);
	  t1++;
	}
	if (minush)
	for (i=0;i<nverts;i++) mesh.verts[i].z-=height;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts);
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

BOOL GengonObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void GengonObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void GengonObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, hsegs, sidesegs,fsegs;
	float radius,height,fillet;
	int genUVs;	

	// Start the validity interval at forever and widdle it down.
    FixGenFilletLimits(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	ivalid = FOREVER;
	
	pblock->GetValue(PB_FSEGS,t,fsegs,ivalid);
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_SSEGS,t,sidesegs,ivalid);
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_FILLET,t,fillet,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(fsegs, 0, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(sidesegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
	if (fillet==0.0f) fsegs=0;
	
	BuildGengonMesh(mesh,
		segs, hsegs, sidesegs, fsegs,
		radius, fillet, height, genUVs,smooth);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f


Object* GengonObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int GengonObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class GengonObjCreateCallBack: public CreateMouseCallBack {
	GengonObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1,sp2;	
	float r,s;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(GengonObject *obj) { ob = obj; }
	};

int GengonObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->increate=TRUE;
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) 
				  { if (Length(m-sp0)<3 ||Length(p[1]-p[0])<0.1f)
					{  ob->increate=FALSE;
					return CREATE_ABORT;	}
				  }
				break;
			case 2:
				{sp2=m;
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{ if (Length(m-sp0)<3) 
				{ ob->increate=FALSE;return CREATE_ABORT;}
				  else 
				  { int sides;
					ob->pblock->GetValue(PB_SIDES,0,sides,FOREVER);
					s=(float)sqrt(2.0f*r*r*(1-(float)cos(TWOPI/sides)));
					s*=0.5f;
				  }
				}
				}
				break;
			case 3:
				{
				float fillet = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				if (fillet<0.0f) fillet=0.0f;
				if (fillet>s) fillet=s;
				ob->pblock->SetValue(PB_FILLET,0,fillet);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					ob->suspendSnap = FALSE;
					ob->increate=FALSE;
					return CREATE_STOP;
					}
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {		
		ob->increate=FALSE;
		return CREATE_ABORT;
		}

	return TRUE;
	}

static GengonObjCreateCallBack cylCreateCB;

CreateMouseCallBack* GengonObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL GengonObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL GengonObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		case PB_TI_SIDES: dlgSides = v; break;
		}		
	return TRUE;
	}

BOOL GengonObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		case PB_TI_FILLET: crtFillet = v; break;
		}	
	return TRUE;
	}

BOOL GengonObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL GengonObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		case PB_TI_SIDES: v = dlgSides; break;
		}
	return TRUE;
	}

BOOL GengonObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		case PB_TI_FILLET: v = crtFillet; break;
		}
	return TRUE;
	}

BOOL GengonObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void GengonObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *GengonObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDES:return stdSegmentsDim;
		case PB_RADIUS: return stdWorldDim;
		case PB_FILLET: return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_SSEGS: return stdSegmentsDim;
		case PB_FSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR GengonObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDES: return TSTR(GetString(IDS_RB_SIDES));
		case PB_RADIUS: return TSTR(GetString(IDS_RB_RADIUS));
		case PB_FILLET: return TSTR(GetString(IDS_RB_FILLET));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_SSEGS:  return TSTR(GetString(IDS_RB_SSEGS));
		case PB_FSEGS:  return TSTR(GetString(IDS_RB_FSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle GengonObject::Clone(RemapDir& remap) 
	{
	GengonObject* newob = new GengonObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\damper.cpp ===
#include "solids.h"

#include "interpik.h"
#include "texutil.h"

#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define TESTLIMIT 100

#define A_RENDER			A_PLUGIN1

const float PIover2=1.570796327f;
const float QuarterPI=0.785398163f;

const int tps = TIME_TICKSPERSEC;
const float INSIDEDIAM=0.0f;
const float PISTONMIN=0.1f;
const float PISTONDIAM=99999999.0f;
const float STOPMAX=1.05f*99999999.0f;
const float BOOTDIAM=0.99f*STOPMAX;

static int controlsInit = FALSE;
const Point3 ZAxis=Point3(0.0f,0.0f,1.0f);
#define fourninthPI (4.0f/9.0f)*PI
#define oneeightPI	(1.0f/18.0f)*PI

static Class_ID DAMPER_CLASS_ID(0x46aa537c, 0x712729f0);

#define PBLK		0
#define CUSTNODE 	1
#define CUSTNODE2 	2
typedef float Matrix4By4[4][4];
typedef float Matrix3By3[3][3];

const float EPSILON=0.0001f;
const Point3 Ones=Point3(1.0f,1.0f,1.0f);

class DamperPickOperand;
class DamperObject;

class DamperObject : public DynamHelperObject {
	public:
		static IParamMap *pmapParam;
		DamperObject();
		~DamperObject();
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	
		static DamperObject *editOb;
		INode *custnode2,*custnode,*thisnode;
		TSTR custname,custname2;
		static IObjParam *ip;
		Matrix3 S;
		static HWND hParams;
		ICustButton *iPick,*iPick2;

		static BOOL creating;
		static DamperPickOperand pickCB;
		BOOL cancelled;
		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// From BaseObject
		TCHAR *GetObjectName();
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
			
		// Animatable methods		
		Class_ID ClassID() {return DAMPER_CLASS_ID;} 
		void DeleteThis() {delete this;}
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void MapKeys(TimeMap *map,DWORD flags);
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		// From SimpleObject
		void MakeSaveVertex(Point3 *SaveVertex,int NvertsPerRing,int nfillets,int nsides,int wtype,TimeValue t);
		void BuildMesh(TimeValue t);

		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void ShowName();
		void ShowName2();
		void ShowNames();
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);

		INode *GetEndNode1();
		INode *GetEndNode2();
		Point3 ApplyAtEnd1(TimeValue t);
		Point3 ApplyAtEnd2(TimeValue t);
		Point3 Force(TimeValue t, TimeValue dt);
};

//--- ClassDescriptor and class vars ---------------------------------

class DamperClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new DamperObject();}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return DAMPER_CLASS_ID;}
	const TCHAR* 	Category(); 
	void			ResetClassParams(BOOL fileReset);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static DamperClassDesc DamperDesc;
ClassDesc* GetDamperDesc() {return &DamperDesc;}

class DamperPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		DamperObject *po;
		int dodist,repi;

		DamperPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

IParamMap *DamperObject::pmapParam;
IObjParam *DamperObject::ip    = NULL;
BOOL DamperObject::creating    = FALSE;
HWND DamperObject::hParams		=NULL;
DamperPickOperand DamperObject::pickCB;
DamperObject *DamperObject::editOb	=NULL;

//--- Parameter map/block descriptors -------------------------------

#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)

#define PB_ENDSMETHOD			0
#define PB_NOREFLENGTH			1

#define PB_RENDERABLE			2
	
#define PB_MOUNTDIA				3
#define PB_MOUNTLEN				4
#define PB_CYLDIA				5
#define PB_CYLLEN				6
#define PB_CYLSIDES				7
#define PB_CYLFILLET1			8
#define PB_CYLFILLET1SEGS		9
#define PB_CYLFILLET2			10
#define PB_CYLFILLET2SEGS		11
#define PB_INSIDEDIA			12
#define PB_SMOOTHCYL			13

#define PB_PISTONDIA			14
#define PB_PISTONLEN			15
#define PB_PISTONSIDES			16
#define PB_SMOOTHPISTON			17

#define PB_ENABLEBOOT			18
#define PB_BOOTDIA1				19
#define PB_BOOTDIA2				20
#define PB_BOOTSIDES			21
#define PB_BOOTFOLDS			22
#define PB_BOOTRESOLUTION		23
#define PB_BOOTSTOPDIA			24
#define PB_BOOTSTOPLEN			25
#define PB_BOOTSETBACK			26
#define PB_BOOTSTOPFILLET		27
#define PB_BOOTSTOPFILLETSEGS	28
#define PB_SMOOTHBOOT			29

#define PB_DYNTYPE				30
#define PB_DYNDRAG				31
#define PB_DYNDRAGUNITS			32
#define PB_SPRINGDIR			33
#define PB_DYNFORCE				34
#define PB_DYNFORCEUNITS		35

#define PB_MAPMEMAPME			36

static int endmethodIDs[] = {IDC_SPRING_REFS,IDC_SPRING_DIMS};

static int dyntypeIDs[] = {IDC_DAMPERON,IDC_ACTUATORON};

static int dragunitsIDs[] = {IDC_DRAGUNITS_LBINSEC,IDC_DRAGUNITS_NEWTMS};

static int forceunitIDs[] = {IDC_FORCEUNITS_LBS,IDC_FORCEUNITS_NEWTS};

static int springdirIDs[] = {IDC_SPRING_COMP,IDC_SPRING_EXT,IDC_SPRING_BOTH};

//
// Parameters

static ParamUIDesc descDamperParam1[] = {

	// End Method
	ParamUIDesc(PB_ENDSMETHOD,TYPE_RADIO,endmethodIDs,2),

	// No reference version Length
	ParamUIDesc(
		PB_NOREFLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_DAMPER_LENGTH,IDC_DAMPER_LENGTHSPIN,
		0.0f,99999999.0f,
		0.1f),	
		
	// IsRenderable?
	ParamUIDesc(PB_RENDERABLE,TYPE_SINGLECHEKBOX,IDC_DAMPER_RENDERTHIS),			

	// Mounting Stud Diameter
	ParamUIDesc(
		PB_MOUNTDIA,
		EDITTYPE_UNIVERSE,
		IDC_STUDDIA,IDC_STUDDIASPIN,
		0.1f,99999999.0f,
		0.1f),	
		
	// Mounting Stud Len
	ParamUIDesc(
		PB_MOUNTLEN,
		EDITTYPE_UNIVERSE,
		IDC_STUDLEN,IDC_STUDLENSPIN,
		0.1f,99999999.0f,
		0.1f),	
		
	// Main Diameter
	ParamUIDesc(
		PB_CYLDIA,
		EDITTYPE_UNIVERSE,
		IDC_CYLDIA,IDC_CYLDIASPIN,
		0.1f,99999999.0f,
		0.1f),	
		
	// Main Len
	ParamUIDesc(
		PB_CYLLEN,
		EDITTYPE_UNIVERSE,
		IDC_CYLLEN,IDC_CYLLENSPIN,
		0.1f,99999999.0f,
		0.1f),	

	// Stud/Cylinder Sides
	ParamUIDesc(
		PB_CYLSIDES,
		EDITTYPE_INT,
		IDC_CYLSIDES,IDC_CYLSIDESSPIN,
		3.0f,100.0f,
		1.0f),	

	// Fillet 1 Size
	ParamUIDesc(
		PB_CYLFILLET1,
		EDITTYPE_UNIVERSE,
		IDC_CYLFILLET1,IDC_CYLFILLET1SPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Fillet 1 Segments
	ParamUIDesc(
		PB_CYLFILLET1SEGS,
		EDITTYPE_INT,
		IDC_FILLET1SEGS,IDC_FILLET1SEGSSPIN,
		0.0f,100.0f,
		1.0f),	
		
	// Fillet 2 Size
	ParamUIDesc(
		PB_CYLFILLET2,
		EDITTYPE_UNIVERSE,
		IDC_CYLFILLET2,IDC_CYLFILLET2SPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Fillet 2 Segments
	ParamUIDesc(
		PB_CYLFILLET2SEGS,
		EDITTYPE_INT,
		IDC_FILLET2SEGS,IDC_FILLET2SEGSSPIN,
		0.0f,100.0f,
		1.0f),	

	// ID
	ParamUIDesc(
		PB_INSIDEDIA,
		EDITTYPE_UNIVERSE,
		IDC_CYLINSIDEDIA,IDC_CYLINSIDEDIASPIN,
		INSIDEDIAM,99999999.0f,
		0.1f),	

	// Smooth Cylinder
	ParamUIDesc(PB_SMOOTHCYL,TYPE_SINGLECHEKBOX,IDC_SMOOTHCYL),			

// Rod Parameters

	// Piston Dia
	ParamUIDesc(
		PB_PISTONDIA,
		EDITTYPE_UNIVERSE,
		IDC_RODDIA,IDC_RODDIASPIN,
		PISTONMIN,PISTONDIAM,
		0.1f),	

	// Piston Length
	ParamUIDesc(
		PB_PISTONLEN,
		EDITTYPE_UNIVERSE,
		IDC_RODLEN,IDC_RODLENSPIN,
		0.1f,99999999.0f,
		0.1f),	

	// Piston Sides
	ParamUIDesc(
		PB_PISTONSIDES,
		EDITTYPE_INT,
		IDC_RODSIDES,IDC_RODSIDESSPIN,
		3.0f,100.0f,
		1.0f),	

	// Smooth Rod
	ParamUIDesc(PB_SMOOTHPISTON,TYPE_SINGLECHEKBOX,IDC_SMOOTHROD),			

// Boot parameters

	// Enable Boot
	ParamUIDesc(PB_ENABLEBOOT,TYPE_SINGLECHEKBOX,IDC_BOOTON),			

	// Minor Dia
	ParamUIDesc(
		PB_BOOTDIA1,
		EDITTYPE_UNIVERSE,
		IDC_BOOTDIA1,IDC_BOOTDIA1SPIN,
		0.0f,BOOTDIAM,
		0.1f),	

	// Major Diameter
	ParamUIDesc(
		PB_BOOTDIA2,
		EDITTYPE_UNIVERSE,
		IDC_BOOTDIA2,IDC_BOOTDIA2SPIN,
		0.0f,BOOTDIAM,
		0.1f),	
		
	// Boot Sides
	ParamUIDesc(
		PB_BOOTSIDES,
		EDITTYPE_INT,
		IDC_FOLDSIDES,IDC_FOLDSIDESSPIN,
		3.0f,100.0f,
		1.0f),	

	// Boot Folds
	ParamUIDesc(
		PB_BOOTFOLDS,
		EDITTYPE_INT,
		IDC_FOLDS,IDC_FOLDSSPIN,
		1.0f,100.0f,
		1.0f),	

	// Boot Resolution
	ParamUIDesc(
		PB_BOOTRESOLUTION,
		EDITTYPE_INT,
		IDC_FOLDRES,IDC_FOLDRESSPIN,
		4.0f,100.0f,
		1.0f),	

	// Stop Dia
	ParamUIDesc(
		PB_BOOTSTOPDIA,
		EDITTYPE_UNIVERSE,
		IDC_BOOTSTOPDIA,IDC_BOOTSTOPDIASPIN,
		0.0f,STOPMAX,
		0.1f),	

	// Stop Len
	ParamUIDesc(
		PB_BOOTSTOPLEN,
		EDITTYPE_UNIVERSE,
		IDC_STOPTHICK,IDC_STOPTHICKSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Setback
	ParamUIDesc(
		PB_BOOTSETBACK,
		EDITTYPE_UNIVERSE,
		IDC_STOPSETBACK,IDC_STOPSETBACKSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Stop Fillet
	ParamUIDesc(
		PB_BOOTSTOPFILLET,
		EDITTYPE_UNIVERSE,
		IDC_STOPFILLET,IDC_STOPFILLETSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Stop Fillet Segments
	ParamUIDesc(
		PB_BOOTSTOPFILLETSEGS,
		EDITTYPE_INT,
		IDC_STOPFILLETSEGS,IDC_STOPFILLETSEGSSPIN,
		0.0f,100.0f,
		1.0f),	

	// Smooth Boot
	ParamUIDesc(PB_SMOOTHBOOT,TYPE_SINGLECHEKBOX,IDC_SMOOTHBOOT),			

//Dynamics Parameters

	// Dyn Object Type
	ParamUIDesc(PB_DYNTYPE,TYPE_RADIO,dyntypeIDs,2),

	// Drag
	ParamUIDesc(
		PB_DYNDRAG,
		EDITTYPE_FLOAT,
		IDC_DRAG,IDC_DRAGSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Dyn Drag Units
	ParamUIDesc(PB_DYNDRAGUNITS,TYPE_RADIO,dragunitsIDs,2),

	// Dyn Spring Dir
	ParamUIDesc(PB_SPRINGDIR,TYPE_RADIO,springdirIDs,3),
			
	// Force
	ParamUIDesc(
		PB_DYNFORCE,
		EDITTYPE_FLOAT,
		IDC_FORCE,IDC_FORCESPIN,
		-99999999.0f,99999999.0f,
		0.1f),	

	// Dyn Force units
	ParamUIDesc(PB_DYNFORCEUNITS,TYPE_RADIO,forceunitIDs,2),

	// Texture Coords
	ParamUIDesc(PB_MAPMEMAPME,TYPE_SINGLECHEKBOX,IDC_DAMPER_MAPME),			
};

#define DAMPERPARAMSDESC_LENGTH 37

ParamBlockDescID descDamperVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 }, // End Method
	{ TYPE_FLOAT, NULL, TRUE, 1 }, // No Ref Length
	{ TYPE_INT, NULL, FALSE, 2 }, // Renderable
	{ TYPE_FLOAT, NULL, TRUE, 3 }, // Stud Dia
	{ TYPE_FLOAT, NULL, TRUE, 4 }, // Stud Len
	{ TYPE_FLOAT, NULL, TRUE, 5 }, // Cyl Dia
	{ TYPE_FLOAT, NULL, TRUE, 6 }, // Cyl len
	{ TYPE_INT, NULL, TRUE, 7 }, // Stud/Cyl Sidecount
	{ TYPE_FLOAT, NULL, TRUE, 8 }, // Fillet 1
	{ TYPE_INT, NULL, TRUE, 9 }, // Fillet 1 segments
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // Fillet 2
	{ TYPE_INT, NULL, TRUE, 11 }, // Fillet 2 segments
	{ TYPE_FLOAT, NULL, TRUE, 12 }, // Inside Dia
	{ TYPE_INT, NULL, FALSE, 13 }, // Smooth Cyl

	{ TYPE_FLOAT, NULL, TRUE, 14 }, // Rod Dia
	{ TYPE_FLOAT, NULL, TRUE, 15 }, // Rod Len
	{ TYPE_INT, NULL, TRUE, 16 }, // Rod Side Count
	{ TYPE_INT, NULL, FALSE, 17 }, // Smooth Rod

	{ TYPE_INT, NULL, FALSE, 18 }, // Boot On
	{ TYPE_FLOAT, NULL, TRUE, 19 }, // Boot Dia Small
	{ TYPE_FLOAT, NULL, TRUE, 20 }, // Boot Dia Large
	{ TYPE_INT, NULL, TRUE, 21 },  // Boot Sides
	{ TYPE_INT, NULL, TRUE, 22 },  // Boot Folds
	{ TYPE_INT, NULL, TRUE, 23 },  // Boot Resolution
	{ TYPE_FLOAT, NULL, TRUE, 24 }, // Stop Dia
	{ TYPE_FLOAT, NULL, TRUE, 25 }, // Stop Len
	{ TYPE_FLOAT, NULL, TRUE, 26 }, // Stop Setback
	{ TYPE_FLOAT, NULL, TRUE, 27 }, // Stop Fillet Size
	{ TYPE_INT, NULL, TRUE, 28 },  // Stop Fillet segments
	{ TYPE_INT, NULL, FALSE, 29 },  // Smooth Boot

	{ TYPE_INT, NULL, FALSE, 30 },  // Dynamics Object Type
	{ TYPE_FLOAT, NULL, TRUE, 31 }, // Drag value
	{ TYPE_INT, NULL, FALSE, 32 },  // Drag Units
	{ TYPE_INT, NULL, FALSE, 33 }, // Damper Direction
	{ TYPE_FLOAT, NULL, TRUE, 34 }, // Force value
	{ TYPE_INT, NULL, FALSE, 35 },  // Force Units

	{ TYPE_INT, NULL, FALSE, 36 },  // texture coords
};

#define PBLOCK_DAMPER_LENGTH	37

// Array of old versions
// static ParamVersionDesc versions[] = {ParamVersionDesc(descDamperVer0,24,0)};

#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	0

// Current version
static ParamVersionDesc curVersion(descDamperVer0,PBLOCK_DAMPER_LENGTH,CURRENT_VERSION);


class CreateMDamperProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		DamperObject *SSBlizObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateMDamperProc()
			{
			ignoreSelectionChange = FALSE;
			}
//		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


class CreateCPartRestoreNode : public RestoreObj {
	public:   		
		DamperObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPartRestoreNode(DamperObject *o) {
			obj = o; name=TSTR(o->custname);
			save=o->custnode;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname);saver=obj->custnode;	}
		  obj->custname = name;
		  obj->custnode=save;
		  if (obj->hParams) obj->ShowName();
			}
		void Redo() 
		{ obj->custname = namer;
		  obj->custnode=saver;
		  if (obj->hParams) obj->ShowName();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};

class CreateCPart2RestoreNode : public RestoreObj {
	public:   		
		DamperObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPart2RestoreNode(DamperObject *o) {
			obj = o; name=TSTR(o->custname2);
			save=o->custnode2;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname2);	}
		  obj->custname2 = name;
		  obj->custnode2=save;
		  if (obj->hParams) obj->ShowName2();
			}
		void Redo() 
		{ obj->custname2 = namer;
		  obj->custnode2 = saver;
		  if (obj->hParams) obj->ShowName2();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK2);}
	};

#define CID_CREATEDAMPERMODE	CID_USER +75

class CreateMDamperMode : public CommandMode {		
	public:		
		CreateMDamperProc proc;
		IObjParam *ip;
		DamperObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,DamperObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEDAMPERMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateMDamperMode theCreateMDamperMode;

void DamperClassDesc::ResetClassParams(BOOL fileReset)
	{
	}

RefResult CreateMDamperProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( SSBlizObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (SSBlizObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (SSBlizObject->creating) 
						{  theCreateMDamperMode.JumpStart(SSBlizObject->ip,SSBlizObject);
							createInterface->SetCommandMode(&theCreateMDamperMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				SSBlizObject  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateMDamperProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	SSBlizObject       = NULL;
	CreateNewObject();
	}
void CreateMDamperProc::CreateNewObject()
	{
	SSBlizObject = (DamperObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( SSBlizObject ) {
		SSBlizObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		SSBlizObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateMDamperProc::End()
{ if ( SSBlizObject ) 
	{ 
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	SSBlizObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a Damper view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete SSBlizObject;
			SSBlizObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();}
	}
}

void CreateMDamperMode::JumpStart(IObjParam *i,DamperObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int DamperClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateMDamperMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateMDamperMode);
	return TRUE;
	}

int DamperClassDesc::EndCreate(Interface *i)
	{
	theCreateMDamperMode.End();
	i->RemoveMode(&theCreateMDamperMode);
	return TRUE;
	}
int CreateMDamperProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( SSBlizObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates SSBlizObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( SSBlizObject);
					SSBlizObject->thisnode=CloudNode;
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = SSBlizObject->GetCreateMouseCallBack();
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					if (createCB) {						
						res = createCB->proc(vpx,msg,point,flag,m,mat);
						createInterface->SetNodeTMRelConstPlane(CloudNode,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP)
						    theHold.Accept(GetString(IDS_AP_CREATE));	 
						
						createInterface->RedrawViews(createInterface->GetTime());   //DS
						}

					break;
					
				}			
			break;

		case MOUSE_MOVE:
			if (createCB) {				
				res = createCB->proc(vpx,msg,point,flag,m,mat);
				createInterface->SetNodeTMRelConstPlane(CloudNode,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP)
					theHold.Accept(GetString(IDS_AP_CREATE));	// TH
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
				}
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: 
	if (createCB)
	{ res = createCB->proc(vpx,msg,point,flag,m,mat);
	  createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
	  if (res==CREATE_ABORT)
	      goto abort;
	  if (res==CREATE_STOP)
	  {
#ifdef _OSNAP
         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	    theHold.Accept(GetString(IDS_AP_CREATE));	
	  }
	  createInterface->RedrawViews(createInterface->GetTime()); 
		break;
	}
	abort:
		assert( SSBlizObject );
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		SSBlizObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		#ifdef _OSNAP  //PREVIEW SNAP
			if(createCB) {
				res = createCB->proc(vpx,msg,point,flag,m,mat);
			}
			else
			{
				assert( SSBlizObject );					
				createCB = SSBlizObject->GetCreateMouseCallBack();
			}
		#endif
		vpx->TrackImplicitGrid(m);
			break;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}
BOOL DamperObject::OKtoDisplay(TimeValue t) 
	{ return (mesh.getNumVerts()>1);
	}

static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL DamperPickOperand::Filter(INode *node)
{	if (node)
	{	ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
//		if (os.obj->IsParticleSystem() || os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) 
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}

	return node ? TRUE : FALSE;
}

BOOL DamperPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
//		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj)))
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}
	return node ? TRUE : FALSE;
}

void DamperObject::ShowName()
{ TSTR name=(custnode ? custname : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ1NAME), name);
}
void DamperObject::ShowName2()
{ TSTR name=(custnode2 ? custname2 : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ2NAME), name);
}
void DamperObject::ShowNames()
{ ShowName();ShowName2();
}

BOOL DamperPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
{	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	theHold.Begin();
	if (dodist)
	{ theHold.Put(new CreateCPart2RestoreNode(po));
	  if (po->custnode2) po->ReplaceReference(CUSTNODE2,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE2,node);	
	  po->custname2 = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName2();	
	}
	else
	{ theHold.Put(new CreateCPartRestoreNode(po));
	  if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	  po->custname = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName();	
	}
	theHold.Accept(GetString(IDS_AP_COMPICK));
	po->pmapParam->Invalidate();
	ip->FlashNodes(&nodes);
	nodes.Resize(0);
	po->ivalid.SetEmpty();
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (po->creating) {
		theCreateMDamperMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateMDamperMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {return TRUE;}
}

void DamperPickOperand::EnterMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,FALSE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
}

void DamperPickOperand::ExitMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
}

//-- ParticleDlgProc ------------------------------------------------

class DamperParamDlg : public ParamMapUserDlgProc {
	public:
		DamperObject *po;
		float bootmax,bootmin;

		DamperParamDlg(DamperObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
		void BootParams(BOOL ison);
		void ActuatorParams(BOOL ison);
		void BoundParams(BOOL ison);
		void MainChange(TimeValue t);
		void PistonChange(TimeValue t);
		void BootStop(TimeValue t);
		void StopChange(TimeValue t);
};

void DamperParamDlg::StopChange(TimeValue t)
{ float outdiam,indiam,maxval;
  po->pblock->GetValue(PB_BOOTSTOPDIA,t,outdiam,FOREVER);
  po->pblock->GetValue(PB_BOOTDIA1,t,indiam,FOREVER);
  maxval=0.99f*outdiam;
  BOOL change;
  if (change=(maxval<indiam))
  { po->pblock->SetValue(PB_BOOTDIA1,t,maxval); }
  if (bootmax>maxval) bootmax=maxval;
  FixFSpinnerLimits(po->hParams,IDC_BOOTDIA1SPIN,bootmin,bootmax,change);
}
void DamperParamDlg::BootStop(TimeValue t)
{ float outdiam,indiam,outmin;
  po->pblock->GetValue(PB_BOOTDIA2,t,outdiam,FOREVER);
  po->pblock->GetValue(PB_BOOTDIA1,t,indiam,FOREVER);
  outmin=1.01f*indiam;
  BOOL change;
  if (change=(outdiam<outmin)) po->pblock->SetValue(PB_BOOTDIA2,t,outmin);
  FixFSpinnerLimits(po->hParams,IDC_BOOTDIA2SPIN,outmin,BOOTDIAM,change);
}
void DamperParamDlg::PistonChange(TimeValue t)
{ float outdiam,indiam,stopdiam,minstop;
  po->pblock->GetValue(PB_BOOTDIA1,t,outdiam,FOREVER);
  po->pblock->GetValue(PB_PISTONDIA,t,indiam,FOREVER);
  po->pblock->GetValue(PB_BOOTSTOPDIA,t,stopdiam,FOREVER);
  bootmin=1.01f*indiam;
  BOOL changes,changed;
  if (changed=(outdiam<bootmin)) {po->pblock->SetValue(PB_BOOTDIA1,t,bootmin);outdiam=bootmin;}
  minstop=1.05f*indiam;
  if (changes=(stopdiam<minstop)) po->pblock->SetValue(PB_BOOTSTOPDIA,t,minstop);  
  float maxdiam=0.99f*stopdiam; if (maxdiam<bootmax) bootmax=maxdiam;
  if (outdiam>bootmax) {po->pblock->SetValue(PB_BOOTDIA1,t,bootmax);changed=TRUE;}
  FixFSpinnerLimits(po->hParams,IDC_BOOTDIA1SPIN,bootmin,bootmax,changed);
  FixFSpinnerLimits(po->hParams,IDC_BOOTSTOPDIASPIN,minstop,STOPMAX,changes);
  StopChange(t);
  BootStop(t);
}
void DamperParamDlg::MainChange(TimeValue t)
{ float outdiam,indiam,maxin;BOOL change;
  po->pblock->GetValue(PB_CYLDIA,t,outdiam,FOREVER);
  po->pblock->GetValue(PB_INSIDEDIA,t,indiam,FOREVER);
  maxin=0.99f*outdiam;
  if (change=(maxin<indiam)) po->pblock->SetValue(PB_INSIDEDIA,t,maxin);
  FixFSpinnerLimits(po->hParams,IDC_CYLINSIDEDIASPIN,INSIDEDIAM,maxin,change);
  float maxpiston=0.95f*outdiam,pistondiam;
  po->pblock->GetValue(PB_PISTONDIA,t,pistondiam,FOREVER);
  if (change=(maxpiston<pistondiam)){ pistondiam=maxpiston;po->pblock->SetValue(PB_PISTONDIA,t,maxpiston);}
  FixFSpinnerLimits(po->hParams,IDC_RODDIASPIN,INSIDEDIAM,maxpiston,change);
  float maxboot=0.99f*outdiam,bootdiam;bootmin=1.01f*pistondiam;
  po->pblock->GetValue(PB_BOOTDIA1,t,bootdiam,FOREVER);
  if (change=(maxboot<bootdiam)) po->pblock->SetValue(PB_BOOTDIA1,t,maxboot);
  FixFSpinnerLimits(po->hParams,IDC_BOOTDIA1SPIN,bootmin,bootdiam,change);
  PistonChange(t);
}

void DamperParamDlg::Update(TimeValue t)
{ if (!po->editOb) return;
  po->ShowNames();
  int emethod;
  po->pblock->GetValue(PB_ENDSMETHOD,0,emethod,FOREVER);
  BoundParams(!emethod);
  int booton;
  po->pblock->GetValue(PB_ENABLEBOOT,t,booton,FOREVER);
  BootParams(booton);
  if (booton)
  { float stopdiam,maindiam,pistondiam;
    po->pblock->GetValue(PB_BOOTSTOPDIA,t,stopdiam,FOREVER);
    po->pblock->GetValue(PB_CYLDIA,t,maindiam,FOREVER);
    bootmax=(stopdiam>maindiam?maindiam:stopdiam);
    po->pblock->GetValue(PB_PISTONDIA,t,pistondiam,FOREVER);
    bootmin=1.01f*pistondiam;
    MainChange(t);
  }
/*  if ((emethod)||(!po->thisnode))
  { po->iPick->Disable();
    po->iPick2->Disable();
  }
  else if (!po->iPick->IsEnabled())
  { po->iPick->Enable(TRUE);
    po->iPick2->Enable(TRUE);
  }*/
}

void DamperParamDlg::BoundParams(BOOL ison)
{ BOOL ok=ison;
  EnableWindow(GetDlgItem(po->hParams,IDC_DAMPERON),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_ACTUATORON),ison);
  if (ison)
  { SpinnerOff(po->hParams,IDC_DAMPER_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),TRUE);
	int act;po->pblock->GetValue(PB_DYNTYPE,0,act,FOREVER);
    ActuatorParams(act);
	ok=(po->thisnode!=NULL);
  }
  else
  { SpinnerOn(po->hParams,IDC_DAMPER_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),FALSE);
    SpinnerOff(po->hParams,IDC_DRAGSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_LBINSEC),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_NEWTMS),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_COMP),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_EXT),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_BOTH),FALSE);
    SpinnerOff(po->hParams,IDC_FORCESPIN); 
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_LBS),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_NEWTS),FALSE);
  }
  if ((po->iPick->IsEnabled()!=ok)||(po->iPick2->IsEnabled()!=ok))
  { TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,ok);
    TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,ok);
  }
}
void DamperParamDlg::BootParams(BOOL ison)
{ if (ison)
  { SpinnerOn(po->hParams,IDC_BOOTDIA1SPIN);
    SpinnerOn(po->hParams,IDC_BOOTDIA2SPIN);
    SpinnerOn(po->hParams,IDC_FOLDSIDESSPIN);
    SpinnerOn(po->hParams,IDC_FOLDSSPIN);
    SpinnerOn(po->hParams,IDC_FOLDRESSPIN);
    SpinnerOn(po->hParams,IDC_BOOTSTOPDIASPIN);
    SpinnerOn(po->hParams,IDC_STOPTHICKSPIN);
    SpinnerOn(po->hParams,IDC_STOPSETBACKSPIN);
    SpinnerOn(po->hParams,IDC_STOPFILLETSPIN);
    SpinnerOn(po->hParams,IDC_STOPFILLETSEGSSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SMOOTHBOOT),TRUE);
  }
  else
  { SpinnerOff(po->hParams,IDC_BOOTDIA1SPIN);
    SpinnerOff(po->hParams,IDC_BOOTDIA2SPIN);
    SpinnerOff(po->hParams,IDC_FOLDSIDESSPIN);
    SpinnerOff(po->hParams,IDC_FOLDSSPIN);
    SpinnerOff(po->hParams,IDC_FOLDRESSPIN);
    SpinnerOff(po->hParams,IDC_BOOTSTOPDIASPIN);
    SpinnerOff(po->hParams,IDC_STOPTHICKSPIN);
    SpinnerOff(po->hParams,IDC_STOPSETBACKSPIN);
    SpinnerOff(po->hParams,IDC_STOPFILLETSPIN);
    SpinnerOff(po->hParams,IDC_STOPFILLETSEGSSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SMOOTHBOOT),FALSE);
  }
}
void DamperParamDlg::ActuatorParams(BOOL ison)
{
  if (ison)
  { SpinnerOff(po->hParams,IDC_DRAGSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_LBINSEC),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_NEWTMS),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_COMP),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_EXT),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_BOTH),FALSE);
    SpinnerOn(po->hParams,IDC_FORCESPIN); 
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_LBS),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_NEWTS),TRUE);
  }
  else
  { SpinnerOn(po->hParams,IDC_DRAGSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_LBINSEC),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_DRAGUNITS_NEWTMS),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_COMP),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_EXT),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_BOTH),TRUE);
	SpinnerOff(po->hParams,IDC_FORCESPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_LBS),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_FORCEUNITS_NEWTS),FALSE);
  }
}

BOOL DamperParamDlg::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			po->iPick = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT1));
			po->iPick->SetType(CBT_CHECK);
			po->iPick->SetHighlightColor(GREEN_WASH);
			po->iPick2 = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT2));
			po->iPick2->SetType(CBT_CHECK);
			po->iPick2->SetHighlightColor(GREEN_WASH);
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(po->iPick);
			ReleaseICustButton(po->iPick2);
			return FALSE;
		case CC_SPINNER_BUTTONUP:
			{ 
			  if (HIWORD(wParam)) 
			  { switch ( LOWORD(wParam) ) 
				{
				 case IDC_CYLDIASPIN: 
				  { MainChange(t);
					po->pmapParam->Invalidate();
				  }
					break;
				 case IDC_BOOTDIA2SPIN: 
				  { BootStop(t);
					po->pmapParam->Invalidate();
				  }
					break;
				 case IDC_BOOTSTOPDIASPIN: 
				 case IDC_RODDIASPIN: 
				  { PistonChange(t);
					po->pmapParam->Invalidate();
				  }
					break;				
				}
			  }
			return TRUE;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SPRING_PICKOBJECT1: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMDamperMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMDamperMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
					}
			  case IDC_SPRING_PICKOBJECT2: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMDamperMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMDamperMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=1;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
					}
			  case IDC_SPRING_REFS: 
				  { BoundParams(TRUE);				  
				  }
				  break;				   
			  case IDC_SPRING_DIMS: 
				  { BoundParams(FALSE);
					if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMDamperMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMDamperMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} 
				  }
				  break;			  
			  case IDC_BOOTDIA2: 
				  { BootStop(t);				  
				  }
				  break;				   
			  case IDC_BOOTSTOPDIA: 
			  case IDC_RODDIA: 
				  { PistonChange(t);				  
				  }
				  break;				   
			  case IDC_CYLDIA: 
				  { MainChange(t);				  
				  }
				  break;				   
			  case IDC_BOOTON: 
				  { int ison;po->pblock->GetValue(PB_ENABLEBOOT,0,ison,FOREVER);
					BootParams(ison);
				  }
				  break;				   
			  case IDC_DAMPERON: 
				  { int ison;po->pblock->GetValue(PB_DYNTYPE,0,ison,FOREVER);
					ActuatorParams(ison);
				  }
				  break;				   
			  case IDC_ACTUATORON: 
				  { int ison;po->pblock->GetValue(PB_DYNTYPE,0,ison,FOREVER);
					ActuatorParams(ison);
				  }
				  break;
			}
		default:
			return FALSE;
		}
	return TRUE;
}

//--- DamperObject Methods--------------------------------------------

DamperObject::DamperObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	int length = PBLOCK_DAMPER_LENGTH;
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descDamperVer0, length, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_ENDSMETHOD,0,1);
	pblock->SetValue(PB_NOREFLENGTH,0,2.0f);
	pblock->SetValue(PB_RENDERABLE,0,1);

	pblock->SetValue(PB_MOUNTDIA,0,0.5f);	
	pblock->SetValue(PB_MOUNTLEN,0,0.2f);	
	pblock->SetValue(PB_CYLDIA,0,1.0f);
	pblock->SetValue(PB_CYLLEN,0,1.0f);
	pblock->SetValue(PB_CYLSIDES,0,8);
	pblock->SetValue(PB_CYLFILLET1,0,0.0f);
	pblock->SetValue(PB_CYLFILLET1SEGS,0,0);
	pblock->SetValue(PB_CYLFILLET2,0,0.0f);
	pblock->SetValue(PB_CYLFILLET2SEGS,0,0);
	pblock->SetValue(PB_INSIDEDIA,0,0.0f);
	pblock->SetValue(PB_SMOOTHCYL,0,1);

	pblock->SetValue(PB_PISTONDIA,0,0.2f);
	pblock->SetValue(PB_PISTONLEN,0,1.0f);
	pblock->SetValue(PB_PISTONSIDES,0,8);
	pblock->SetValue(PB_SMOOTHPISTON,0,1);

	pblock->SetValue(PB_ENABLEBOOT,0,0);
	pblock->SetValue(PB_BOOTDIA1,0,0.25f);
	pblock->SetValue(PB_BOOTDIA2,0,1.0f);
	pblock->SetValue(PB_BOOTSIDES,0,8);
	pblock->SetValue(PB_BOOTFOLDS,0,4);
	pblock->SetValue(PB_BOOTRESOLUTION,0,4);
	pblock->SetValue(PB_BOOTSTOPDIA,0,0.4f);
	pblock->SetValue(PB_BOOTSTOPLEN,0,0.2f);
	pblock->SetValue(PB_BOOTSETBACK,0,0.2f);
	pblock->SetValue(PB_BOOTSTOPFILLET,0,0.0f);
	pblock->SetValue(PB_BOOTSTOPFILLETSEGS,0,0);
	pblock->SetValue(PB_SMOOTHBOOT,0,1);

	pblock->SetValue(PB_DYNTYPE,0,0);
	pblock->SetValue(PB_DYNDRAG,0,0.0f);
	pblock->SetValue(PB_DYNDRAGUNITS,0,0);
	pblock->SetValue(PB_SPRINGDIR,0,2);
	pblock->SetValue(PB_DYNFORCE,0,0.0f);
	pblock->SetValue(PB_DYNFORCEUNITS,0,0);

	pblock->SetValue(PB_MAPMEMAPME,0,0);

	S.IdentityMatrix();
	iPick=NULL;
	iPick2=NULL;
	thisnode=NULL;
	custnode=NULL;
	custnode2=NULL;
	custname=TSTR(_T(" "));
	custname2=TSTR(_T(" "));
}

DamperObject::~DamperObject()
{	DeleteAllRefsFromMe();
}

void DamperObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
{	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	editOb   = this;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }


	if (pmapParam) 
	{	pmapParam->SetParamBlock(pblock);
	} else 
	{		pmapParam = CreateCPParamMap(
			descDamperParam1,DAMPERPARAMSDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_DAMPER),
			GetString(IDS_AP_DAMPPARAMETERS),
			0);		
		}
	hParams=pmapParam->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new DamperParamDlg(this));
}

void DamperObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	editOb = NULL;
	if (flags&END_EDIT_REMOVEUI) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		hParams=NULL;
		}
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
}

void DamperObject::MapKeys(TimeMap *map,DWORD flags)
{
}  

static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

void DamperObject::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{	thisnode=inode;    
		SimpleObject::GetWorldBoundBox(t,inode,vpt,box);
	}  

int DamperObject::RenderBegin(TimeValue t, ULONG flags)
{	SetAFlag(A_RENDER);
	int renderme;
	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

int DamperObject::RenderEnd(TimeValue t)
{	ClearAFlag(A_RENDER);
	int renderme;
 	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

INode *DamperObject::GetEndNode1()
{	if (custnode)
		return (custnode);
	else
		return (NULL);
}

INode *DamperObject::GetEndNode2()
{	if (custnode2) 
		return (custnode2);
	else
		return (NULL);
}

Point3 DamperObject::ApplyAtEnd1(TimeValue t)
{	if (custnode)
	{	Matrix3 mat1 = custnode->GetObjTMAfterWSM(t);
		return (mat1.GetRow(3));
	}
	else
		return (Zero);
}

Point3 DamperObject::ApplyAtEnd2(TimeValue t)
{	if (custnode2)
	{	Matrix3 mat2 = custnode2->GetObjTMAfterWSM(t);
		return (mat2.GetRow(3));
	}
	else
		return (Zero);
}

#define COMPRESSION	0
#define EXTENSION	1
#define	BIDIRECT	2

#define POUNDSSECONDSPERINCH	0
#define NEWTONSECONDSPERMETER	1

#define DAMPER		0
#define ACTUATOR	1

#define POUNDS		0
#define NEWTONS		1

Point3 DamperObject::Force(TimeValue t, TimeValue dt)
{	if ((custnode)&&(custnode2))
	{	Matrix3 mat1now, mat2now, mat1before, mat2before;
		mat1now = custnode->GetObjTMAfterWSM(t);
		mat2now = custnode2->GetObjTMAfterWSM(t);

		float lennow, lenbefore;
		Point3 forcedir = (mat1now.GetRow(3) - mat2now.GetRow(3));
		lennow = Length(forcedir);
		if (lennow < 0.01f)
			return (Zero);
		else
			forcedir = Normalize(forcedir);

		int cylindertype;
		pblock->GetValue(PB_DYNTYPE,t,cylindertype,ivalid);
		if (cylindertype == DAMPER)
		{	mat1before = custnode->GetObjTMAfterWSM(t - dt);
			mat2before = custnode2->GetObjTMAfterWSM(t - dt);
			lenbefore = Length(mat1before.GetRow(3) - mat2before.GetRow(3));
			float difflen = lenbefore - lennow;
			if ((float)fabs(difflen) < 0.01f)
				return (Zero);

			int dampertype;
			pblock->GetValue(PB_SPRINGDIR,t,dampertype,ivalid);
			if ((dampertype == COMPRESSION)&&(difflen < 0.0f))
				return (Zero);
			else if ((dampertype == EXTENSION)&&(difflen > 0.0f))
				return (Zero);

			difflen *= GetMeterMult();

			float diffvel = (float)tps * difflen / (float)dt;

			float drag;
			pblock->GetValue(PB_DYNDRAG,t,drag,ivalid);
			int dragunits;
			pblock->GetValue(PB_DYNDRAGUNITS,t,dragunits,ivalid);
			if (dragunits == POUNDSSECONDSPERINCH)
				drag *= 175.55441f;
			return (drag * diffvel * forcedir);
		}
		else // cylindertype must be ACTUATOR
		{	float pushforce;
			pblock->GetValue(PB_DYNFORCE,t,pushforce,ivalid);
			int pushforceunits;
			pblock->GetValue(PB_DYNFORCEUNITS,t,pushforceunits,ivalid);
			if (pushforceunits == POUNDS)
				pushforce *= 4.4591f;
			return (pushforce * forcedir);
		}
	}
	else
		return (Zero);
}

BOOL DamperObject::HasUVW() 
{ 	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_MAPMEMAPME, 0, genUVs, v);
	return genUVs; 
}

void DamperObject::SetGenUVW(BOOL sw) 
{  	if (sw==HasUVW()) 
		return;
	pblock->SetValue(PB_MAPMEMAPME,0, sw);
}

void DamperObject::BuildMesh(TimeValue t)
{	if (TestAFlag(A_RENDER))
	{	int renderme;
		pblock->GetValue(PB_RENDERABLE,0,renderme,ivalid);
		if (!renderme)
		{	mesh.setNumVerts(0);
			mesh.setNumFaces(0);
			mesh.setNumTVerts(0);
			mesh.setNumTVFaces(0);
			mesh.InvalidateGeomCache();
			return;
		}
	}
	
	if (!ivalid.InInterval(t))
	{	ivalid=FOREVER;
		int createfree;
		pblock->GetValue(PB_ENDSMETHOD,0,createfree,ivalid);
		if ((!createfree)&&((!custnode)||(!custnode2))) 
			createfree = 1;
		if (!createfree) 
			ivalid.SetInstant(t);
		Matrix3 mat1,mat2;
		srand(56576);
		int s1 = rand();
		float Lf = 0.0f; // Lf is the free length of the damper

		Matrix3 Tlocal(1);
		if (createfree) 
			pblock->GetValue(PB_NOREFLENGTH,t,Lf,ivalid);
		else
		{	Point3 RV = Point3(RND11(),RND11(),RND11());
			mat1 = custnode->GetObjTMAfterWSM(t);
			mat2 = (custnode==custnode2?mat1:custnode2->GetObjTMAfterWSM(t));

			Matrix3 mato1(1), mato2(1);

			Point3 pos1 = custnode->GetObjOffsetPos();
			mato1.PreTranslate(pos1);
			Quat quat1 = custnode->GetObjOffsetRot();
			PreRotateMatrix(mato1, quat1);
			ScaleValue scaleValue1 = custnode->GetObjOffsetScale();
			ApplyScaling(mato1, scaleValue1);
			mato1 = Inverse(mato1);

			Point3 pos2 = custnode2->GetObjOffsetPos();
			mato2.PreTranslate(pos2);
			Quat quat2 = custnode2->GetObjOffsetRot();
			PreRotateMatrix(mato2, quat2);
			ScaleValue scaleValue2 = custnode2->GetObjOffsetScale();
			ApplyScaling(mato2, scaleValue2);
			mato2 = Inverse(mato2);

			S = thisnode->GetObjTMBeforeWSM(t);
//			Point3 P1 = mat1.GetRow(3) + mat1*mato1.GetRow(3),
//				   P2 = mat2.GetRow(3) + mat2*mato2.GetRow(3);
			Point3 P1 = mat1*mato1.GetRow(3),
				   P2 = mat2*mato2.GetRow(3);
			Matrix3 SI = Inverse(S);
			Point3 P0 = SI*P1;
			Matrix3 T1 = mat1;
			T1.NoTrans();
			Point3 RVw = T1 * RV;
			Lf = Length(P2 - P1);
			pblock->SetValue(PB_NOREFLENGTH,0,Lf);
			ivalid.SetInstant(t);
			Point3 Zw;
			if (Lf < 0.01f)
				Zw = Normalize(P1);
			else
				Zw = Normalize(P2 - P1);
			Point3 Xw = Normalize(RVw ^ Zw),
				   Yw = Normalize(Zw ^ Xw);	
			SI.NoTrans();
			Point3 Xs = SI * Xw,
				   Ys = SI * Yw,
				   Zs = SI * Zw;
			Tlocal.SetRow(0,Xs);
			Tlocal.SetRow(1,Ys);
			Tlocal.SetRow(2,Zs);
			Tlocal.SetRow(3,P0);
		}

		float rstud, lstud, rcyl, lcyl, z_endofcyl;
		pblock->GetValue(PB_MOUNTDIA,t,rstud,ivalid);
		rstud *= 0.5f;
		pblock->GetValue(PB_MOUNTLEN,t,lstud,ivalid);
		pblock->GetValue(PB_CYLDIA,t,rcyl,ivalid);
		rcyl *= 0.5f;
		pblock->GetValue(PB_CYLLEN,t,lcyl,ivalid);
		z_endofcyl = lstud + lcyl;

		int cylsides, cylfillet1segs, cylfillet2segs;
		pblock->GetValue(PB_CYLSIDES,t,cylsides,ivalid);
		pblock->GetValue(PB_CYLFILLET1SEGS,t,cylfillet1segs,ivalid);
		pblock->GetValue(PB_CYLFILLET2SEGS,t,cylfillet2segs,ivalid);

		float cylfillet1, cylfillet2, insidedia;
		pblock->GetValue(PB_CYLFILLET1,t,cylfillet1,ivalid);
		pblock->GetValue(PB_CYLFILLET2,t,cylfillet2,ivalid);
		pblock->GetValue(PB_INSIDEDIA,t,insidedia,ivalid);
		insidedia *= 0.5f;

		int smoothcyl, smoothrod, smoothboot;
		pblock->GetValue(PB_SMOOTHCYL,t,smoothcyl,ivalid);
		pblock->GetValue(PB_SMOOTHPISTON,t,smoothrod,ivalid);

		float roddia, rodlen;
		pblock->GetValue(PB_PISTONDIA,t,roddia,ivalid);
		roddia *= 0.5f;
		pblock->GetValue(PB_PISTONLEN,t,rodlen,ivalid);

		int rodsides;
		pblock->GetValue(PB_PISTONSIDES,t,rodsides,ivalid);

		int IsBooted;
		pblock->GetValue(PB_ENABLEBOOT,t,IsBooted,ivalid);

		int bootsides, bootfolds, bootres, bootfilletsegs;
		float bootdia1, bootdia2, bootstopdia, bootstoplen, bootstoploc, bootstopfillet, diffboot; 
		if (IsBooted)
		{	pblock->GetValue(PB_BOOTDIA1,t,bootdia1,ivalid);
			bootdia1 *= 0.5f;
			pblock->GetValue(PB_BOOTDIA2,t,bootdia2,ivalid);
			bootdia2 *= 0.5f;
			diffboot = bootdia2 - bootdia1;
			pblock->GetValue(PB_BOOTSIDES,t,bootsides,ivalid);
			pblock->GetValue(PB_BOOTFOLDS,t,bootfolds,ivalid);
			pblock->GetValue(PB_BOOTRESOLUTION,t,bootres,ivalid);
			pblock->GetValue(PB_BOOTSTOPDIA,t,bootstopdia,ivalid);
			bootstopdia *= 0.5f;
			pblock->GetValue(PB_BOOTSTOPLEN,t,bootstoplen,ivalid);
			pblock->GetValue(PB_BOOTSETBACK,t,bootstoploc,ivalid);
			pblock->GetValue(PB_BOOTSTOPFILLET,t,bootstopfillet,ivalid);
			pblock->GetValue(PB_BOOTSTOPFILLETSEGS,t,bootfilletsegs,ivalid);
			pblock->GetValue(PB_SMOOTHBOOT,t,smoothboot,ivalid);
		}

		int NvertsPerRingStud = cylsides;
		int NRingsStud = 6 + ((cylfillet1segs>0)?cylfillet1segs:0) 
			               + ((cylfillet2segs>0)?cylfillet2segs:0) 
						   + (insidedia>0.0f?2:0);
//		int NRingsStud = 6 + ((cylfillet1segs>0)&&(cylfillet1>0.0f)?cylfillet1segs:0) 
//			               + ((cylfillet2segs>0)&&(cylfillet2>0.0f)?cylfillet2segs:0) 
//						   + (insidedia>0.0f?2:0);
		int NvertsStud = NRingsStud*NvertsPerRingStud;
		int NtvertsStud = NRingsStud*(NvertsPerRingStud+1);
		int NfacesStud = (NRingsStud-1)*2*NvertsPerRingStud;

		int NvertsPerRingRod = rodsides;
		int NRingsRod = 4;
		int NvertsRod = NRingsRod*NvertsPerRingRod;
		int NtvertsRod = NRingsRod*(NvertsPerRingRod+1);
		int NfacesRod = (NRingsRod-1)*2*NvertsPerRingRod;

		int NvertsPerRingBoot=0, NRingsBoot=0, NvertsBoot=0, NfacesBoot=0, NtvertsBoot;
		if (IsBooted)
		{	NvertsPerRingBoot = bootsides;
			NRingsBoot = 5 + bootres*bootfolds + ((bootfilletsegs>0)?bootfilletsegs:0);
//			NRingsBoot = 5 + bootres*bootfolds + ((bootfilletsegs>0)&&(bootstopfillet>0.0f)?bootfilletsegs:0);
			NvertsBoot = NRingsBoot*NvertsPerRingBoot;
			NtvertsBoot = NRingsBoot*(NvertsPerRingBoot+1);
			NfacesBoot = (NRingsBoot-2)*2*NvertsPerRingBoot;
		}
		float NdivsBoot = (float)bootres*(float)bootfolds;
		int NRingsStop = 4 + ((bootfilletsegs>0)?bootfilletsegs:0);
//		int NRingsStop = 4 + ((bootfilletsegs>0)&&(bootstopfillet>0.0f)?bootfilletsegs:0);

		int Nverts = NvertsStud + NvertsRod + NvertsBoot;
		int Ntverts = NtvertsStud + NtvertsRod + NtvertsBoot;
		int Nfaces = NfacesStud + NfacesRod + NfacesBoot;
		int Ntfaces = Nfaces;

		int mapmenow;
		pblock->GetValue(PB_MAPMEMAPME,0,mapmenow,FOREVER);

		mesh.setNumVerts(Nverts);
		mesh.setNumFaces(Nfaces);

		if (mapmenow)
		{	mesh.setNumTVerts(Nverts + NRingsStud + NRingsRod + NRingsBoot);
			mesh.setNumTVFaces(Nfaces);
		}
		else
		{	mesh.setNumTVerts(0);
			mesh.setNumTVFaces(0);
		}

		int i,j;
		float u, fverts;

		Point3 *RingCoordsStud = new Point3[NvertsPerRingStud];
		assert(RingCoordsStud);
		fverts = (float)NvertsPerRingStud;
		for (i=0; i<NvertsPerRingStud; i++)
		{	u = (float)i/fverts;
			RingCoordsStud[i].z = u;
			u *= TWOPI;
			RingCoordsStud[i].x = (float)cos(u);
			RingCoordsStud[i].y = (float)sin(u);
		}

		Point3 *RingCoordsRod = new Point3[NvertsPerRingRod];
		assert(RingCoordsRod);
		fverts = (float)NvertsPerRingRod;
		for (i=0; i<NvertsPerRingRod; i++)
		{	u = (float)i/fverts;
			RingCoordsRod[i].z = u;
			u *= TWOPI;
			RingCoordsRod[i].x = (float)cos(u);
			RingCoordsRod[i].y = (float)sin(u);
		}

		Point3 *RingCoordsBoot = new Point3[NvertsPerRingBoot];
		assert(RingCoordsBoot);
		if (IsBooted)
		{	fverts = (float)NvertsPerRingBoot;
			for (i=0; i<NvertsPerRingBoot; i++)
			{	u = (float)i/fverts;
				RingCoordsBoot[i].z = u;
				u *= TWOPI;
				RingCoordsBoot[i].x = (float)cos(u);
				RingCoordsBoot[i].y = (float)sin(u);
			}
		}

		int thisvert = 0;
		float thisradius, thisz, fltNverts, thisxtex, thisangle;

		fltNverts = (float)NvertsPerRingStud;

// vertices for CYLINDER AND STUD
		for (i=0 ; i < NRingsStud ; i++)
		{	thisxtex = (float)i/(float)(NRingsStud-1);
			if (i == 0)
			{	thisradius = 0.0f;
				thisz = 0.0f;
			}
			else if (i == 1)
			{	thisradius = rstud;
				thisz = 0.0f;
			}
			else if (i == 2)
			{	thisradius = rstud;
				thisz = lstud;
			}
			else if (i == 3)
			{	thisz = lstud;
				if (cylfillet1segs == 0)
					thisradius = rcyl;
				else
					thisradius = rcyl - cylfillet1;
			}
			else if (i < 4+cylfillet1segs)
			{	thisangle = (float)(i - 3)*PIover2/(float)(cylfillet1segs);
				thisradius = cylfillet1*(float)sin(thisangle) + rcyl - cylfillet1;
				thisz = lstud + cylfillet1 - cylfillet1*(float)cos(thisangle);
			}
			else if (i == 4+cylfillet1segs)
			{	thisradius = rcyl;
				if (cylfillet2segs == 0)
					thisz = lstud + lcyl;
				else
					thisz = lstud + lcyl - cylfillet2;
			}
			else if (i < 5+cylfillet1segs+cylfillet2segs) 
			{	thisangle = (float)(i - cylfillet1segs - 4)*PIover2/(float)(cylfillet2segs);
				thisradius = rcyl - cylfillet2 + cylfillet2*(float)cos(thisangle);
				thisz = lstud + lcyl - cylfillet2 + cylfillet2*(float)sin(thisangle);
			}
			else if (i == 5+cylfillet1segs+cylfillet2segs)
			{	thisradius = insidedia;
				thisz = lstud + lcyl;
			}
			else if (i == 6+cylfillet1segs+cylfillet2segs)
			{	thisradius = insidedia;
				thisz = lstud + cylfillet1;
			}
			else if (i == 7+cylfillet1segs+cylfillet2segs)
			{	thisradius = 0.0f;
				thisz = lstud + cylfillet1;
			}
			for (j=0 ; j < NvertsPerRingStud ; j++)
			{	if (createfree)
					mesh.setVert(thisvert,Point3(thisradius*RingCoordsStud[j].x,
								                 thisradius*RingCoordsStud[j].y,
												 thisz));
				else
					mesh.setVert(thisvert,Tlocal*Point3(thisradius*RingCoordsStud[j].x,
								                        thisradius*RingCoordsStud[j].y,
												        thisz));
				if (mapmenow)
					mesh.tVerts[thisvert] = Point3(thisxtex,RingCoordsStud[j].z,0.0f);
				thisvert++;
			}
			if (mapmenow)
				mesh.tVerts[Nverts+i] = Point3(thisxtex, 0.999f, 0.0f);
		}

// vertices for ROD
		for (i=0 ; i < NRingsRod ; i++)
		{	thisxtex = (float)i/(float)(NRingsRod-1);
			if (i == 0)
			{	thisradius = 0.0f;
				thisz = Lf - rodlen;
			}
			else if (i == 1)
			{	thisradius = roddia;
				thisz = Lf - rodlen;
			}
			else if (i == 2)
			{	thisradius = roddia;
				thisz = Lf;
			}
			else if (i == 3)
			{	thisradius = 0.0f;
				thisz = Lf;
			}
			for (j=0 ; j < NvertsPerRingRod ; j++)
			{	if (createfree)
					mesh.setVert(thisvert,Point3(thisradius*RingCoordsRod[j].x,
								                 thisradius*RingCoordsRod[j].y,
												 thisz));
				else
					mesh.setVert(thisvert,Tlocal*Point3(thisradius*RingCoordsRod[j].x,
								                        thisradius*RingCoordsRod[j].y,
												        thisz));
				if (mapmenow)
					mesh.tVerts[thisvert] = Point3(thisxtex,RingCoordsRod[j].z,0.0f);
				thisvert++;
			}
			if (mapmenow)
				mesh.tVerts[Nverts+NRingsStud+i] = Point3(thisxtex, 0.999f, 0.0f);
		}

// vertices for BOOT
		float multiwavelen, distancealong, effectiveangle;
		if (IsBooted)
		{	for (i=0 ; i < NRingsBoot ; i++) // Stop vertices
			{	thisxtex = (float)i/(float)(NRingsBoot-1);
				if (i == 0)
				{	thisradius = roddia;
					thisz = Lf - bootstoplen - bootstoploc;
				}
				else if (i == 1)
				{	thisradius = bootstopdia;
					thisz = Lf - bootstoplen - bootstoploc;
				}
				else if (i == 2)
				{	thisradius = bootstopdia;
					if (bootfilletsegs == 0)
						thisz = Lf - bootstoploc;
					else
						thisz = Lf - bootstoploc - bootstopfillet;
				}
				else if (i < 3+bootfilletsegs)
				{	thisangle = (float)(i - 2)*PIover2/(float)(bootfilletsegs);
					thisradius = bootstopfillet*(float)cos(thisangle) + bootstopdia - bootstopfillet;
					thisz = Lf - bootstoploc - bootstopfillet + bootstopfillet*(float)sin(thisangle);
				}
				else if (i == 3+bootfilletsegs)
				{	thisradius = roddia;
					thisz = Lf - bootstoploc;
				}
// boot vertices proper here
				else if (i > 3+bootfilletsegs)
				{	multiwavelen = Lf - lstud - lcyl - bootstoploc - bootstoplen;
					distancealong = float(i-bootfilletsegs-4)/NdivsBoot;
					effectiveangle = (float)bootfolds*PI*distancealong;
					thisz = lstud + lcyl + distancealong*multiwavelen;
					thisradius = bootdia1 + (float)fabs(diffboot*(float)sin(effectiveangle));
				}

				for (j=0 ; j < NvertsPerRingBoot ; j++)
				{	if (createfree)
						mesh.setVert(thisvert,Point3(thisradius*RingCoordsBoot[j].x,
									                 thisradius*RingCoordsBoot[j].y,
													 thisz));
					else
						mesh.setVert(thisvert,Tlocal*Point3(thisradius*RingCoordsBoot[j].x,
									                        thisradius*RingCoordsBoot[j].y,
													        thisz));
					if (mapmenow)
						mesh.tVerts[thisvert] = Point3(thisxtex,RingCoordsBoot[j].z,0.0f);
					thisvert++;
				}
				if (mapmenow)
					mesh.tVerts[Nverts+NRingsStud+NRingsRod+i] = Point3(thisxtex, 0.999f, 0.0f);
			}

		}

// set up variables to create faces
		int thisface = 0, v1, v2, v3, v4, v5, v6;
		int rowsoffaces, lastverttest;
		thisvert = 0;

// Faces for Cylinder
		rowsoffaces = NRingsStud - 1;
		lastverttest = NvertsPerRingStud - 1;
		for (i=0 ; i < rowsoffaces ; i++)
			for (j=0 ; j < NvertsPerRingStud ; j++)
			{	v1 = thisvert;
				v2 = ( j < lastverttest ? v1+1 : v1 - lastverttest );
				v3 = v1 + NvertsPerRingStud;
				v4 = v2 + NvertsPerRingStud;
				v5 = (j < lastverttest? v2 : Nverts+i);
				v6 = (j < lastverttest? v4 : Nverts+i+1);
				mesh.faces[thisface].setVerts(v4,v3,v1);
				if (i == 0)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i == 1)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 2)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i < 3+cylfillet1segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 3+cylfillet1segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?4:0);
				else if (i < 4+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 4+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i == 5+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 6+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				if (i < 2 )
					mesh.faces[thisface].setMatID(0);
				else if (i == 2)
				{	if (rstud > rcyl)
						mesh.faces[thisface].setMatID(0);
					else
						mesh.faces[thisface].setMatID(1);
				}
				else
					mesh.faces[thisface].setMatID(1);
				if (mapmenow)
					mesh.tvFace[thisface].setTVerts(v6,v3,v1);
				thisface++;
				mesh.faces[thisface].setVerts(v1,v2,v4);
				if (i == 0)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i == 1)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 2)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i < 3+cylfillet1segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 3+cylfillet1segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?4:0);
				else if (i < 4+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 4+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				else if (i == 5+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?2:0);
				else if (i == 6+cylfillet1segs+cylfillet2segs)
					mesh.faces[thisface].setSmGroup(smoothcyl?1:0);
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				if (i < 2 )
					mesh.faces[thisface].setMatID(0);
				else if (i == 2)
				{	if (rstud > rcyl)
						mesh.faces[thisface].setMatID(0);
					else
						mesh.faces[thisface].setMatID(1);
				}
				else
					mesh.faces[thisface].setMatID(1);
				if (mapmenow)
					mesh.tvFace[thisface].setTVerts(v1,v5,v6);
				thisface++;
				thisvert++;
			}

// Faces for Rod 
		rowsoffaces = NRingsRod - 1;
		lastverttest = NvertsPerRingRod - 1;
		thisvert += NvertsPerRingStud;
		for (i=0 ; i < rowsoffaces ; i++)
			for (j=0 ; j < NvertsPerRingRod ; j++)
			{	v1 = thisvert;
				v2 = ( j < lastverttest ? v1+1 : v1 - lastverttest );
				v3 = v1 + NvertsPerRingRod;
				v4 = v2 + NvertsPerRingRod;
				v5 = (j < lastverttest? v2 : Nverts+NRingsStud+i);
				v6 = (j < lastverttest? v4 : Nverts+NRingsStud+i+1);

				mesh.faces[thisface].setVerts(v4,v3,v1);
				if (i == 0)
					mesh.faces[thisface].setSmGroup(smoothrod?1:0);
				else if (i == 1)
					mesh.faces[thisface].setSmGroup(smoothrod?2:0);
				else if (i == 2)
					mesh.faces[thisface].setSmGroup(smoothrod?1:0);
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				mesh.faces[thisface].setMatID(2);
				if (mapmenow)
					mesh.tvFace[thisface].setTVerts(v6,v3,v1);
				thisface++;

				mesh.faces[thisface].setVerts(v1,v2,v4);
				if (i == 0)
					mesh.faces[thisface].setSmGroup(smoothrod?1:0);
				else if (i == 1)
					mesh.faces[thisface].setSmGroup(smoothrod?2:0);
				else if (i == 2)
					mesh.faces[thisface].setSmGroup(smoothrod?1:0);
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				mesh.faces[thisface].setMatID(2);
				if (mapmenow)
					mesh.tvFace[thisface].setTVerts(v1,v5,v6);
				thisface++;
				thisvert++;
			}

		if (IsBooted)
		{	rowsoffaces = 3 + ((bootfilletsegs>0) ? bootfilletsegs : 0);
//		{	rowsoffaces = 3 + (((bootfilletsegs>0)&&(bootstopfillet>0.0f)) ? bootfilletsegs : 0);
			lastverttest = NvertsPerRingBoot - 1;
			thisvert += NvertsPerRingRod;
			for (i=0 ; i < rowsoffaces ; i++)
				for (j=0 ; j < NvertsPerRingBoot ; j++)
				{	v1 = thisvert;
					v2 = ( j < lastverttest ? v1+1 : v1 - lastverttest );
					v3 = v1 + NvertsPerRingBoot;
					v4 = v2 + NvertsPerRingBoot;
					v5 = (j < lastverttest? v2 : Nverts+NRingsStud+NRingsRod+i);
					v6 = (j < lastverttest? v4 : Nverts+NRingsStud+NRingsRod+i+1);
	
					mesh.faces[thisface].setVerts(v4,v3,v1);
					if (i == 0) //boot end flat
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					else if (i == 1) //side cylindrical surface
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i < 2 + bootfilletsegs)&&(bootfilletsegs == 1)) //hard fillet
						mesh.faces[thisface].setSmGroup(smoothboot?4:0);
					else if ((i < 2 + bootfilletsegs)&&(bootfilletsegs > 1)) //smooth fillet
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs == 1)) //end with hard fillet
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs > 1)) //end with smooth fillet
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs == 0)) //end
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					mesh.faces[thisface].setEdgeVisFlags(1,1,0);
					mesh.faces[thisface].setMatID(3);
					if (mapmenow)
						mesh.tvFace[thisface].setTVerts(v6,v3,v1);
					thisface++;
	
					mesh.faces[thisface].setVerts(v1,v2,v4);
					if (i == 0) //boot end flat
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					else if (i == 1) //side cylindrical surface
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i < 2 + bootfilletsegs)&&(bootfilletsegs == 1)) //hard fillet
						mesh.faces[thisface].setSmGroup(smoothboot?4:0);
					else if ((i < 2 + bootfilletsegs)&&(bootfilletsegs > 1)) //smooth fillet
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs == 1)) //end with hard fillet
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs > 1)) //end with smooth fillet
						mesh.faces[thisface].setSmGroup(smoothboot?2:0);
					else if ((i == 2 + bootfilletsegs)&&(bootfilletsegs == 0)) //end
						mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					mesh.faces[thisface].setEdgeVisFlags(1,1,0);
					mesh.faces[thisface].setMatID(3);
					if (mapmenow)
						mesh.tvFace[thisface].setTVerts(v1,v5,v6);
					thisface++;
					thisvert++;
				}
			rowsoffaces = bootfolds*bootres;
			lastverttest = NvertsPerRingBoot - 1;
			thisvert += NvertsPerRingBoot;
			for (i=0 ; i < rowsoffaces ; i++)
				for (j=0 ; j < NvertsPerRingBoot ; j++)
				{	v1 = thisvert;
					v2 = ( j < lastverttest ? v1+1 : v1 - lastverttest );
					v3 = v1 + NvertsPerRingBoot;
					v4 = v2 + NvertsPerRingBoot;
					v5 = (j < lastverttest? v2 : Nverts+NRingsStud+NRingsRod+NRingsStop+i);
					v6 = (j < lastverttest? v4 : Nverts+NRingsStud+NRingsRod+NRingsStop+i+1);
	
					mesh.faces[thisface].setVerts(v4,v3,v1);
					mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					mesh.faces[thisface].setEdgeVisFlags(1,1,0);
					mesh.faces[thisface].setMatID(4);
					if (mapmenow)
						mesh.tvFace[thisface].setTVerts(v6,v3,v1);
					thisface++;
	
					mesh.faces[thisface].setVerts(v1,v2,v4);
					mesh.faces[thisface].setSmGroup(smoothboot?1:0);
					mesh.faces[thisface].setEdgeVisFlags(1,1,0);
					mesh.faces[thisface].setMatID(4);
					if (mapmenow)
						mesh.tvFace[thisface].setTVerts(v1,v5,v6);
					thisface++;
					thisvert++;
				}
		}

		if (RingCoordsStud) 
			delete[] RingCoordsStud;
		if (RingCoordsRod) 
			delete[] RingCoordsRod;
		if (RingCoordsBoot) 
			delete[] RingCoordsBoot;
	}
	mesh.InvalidateGeomCache();
	mesh.InvalidateTopologyCache();mesh.BuildStripsAndEdges();
	srand( (unsigned)time( NULL ) );
}

class DamperEmitterCreateCallback : public CreateMouseCallBack {
	public:
		DamperObject *ob;
		Point3 p[2];
		IPoint2 sp0, sp1;
		BOOL square;
		void Cleanup();
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int DamperEmitterCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	float r;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	{ switch(point)
		{ 	case 0:
				ob->suspendSnap = TRUE;				
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS));
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_MOUNTDIA,0,0.01f);
				ob->pblock->SetValue(PB_CYLDIA,0,0.01f);
				ob->pblock->SetValue(PB_NOREFLENGTH,0,0.01f);
				ob->pblock->SetValue(PB_CYLLEN,0,0.01f);
				ob->pblock->SetValue(PB_INSIDEDIA,0,0.0f);
				ob->pblock->SetValue(PB_PISTONDIA,0,0.01f);
				ob->pblock->SetValue(PB_PISTONLEN,0,0.01f);
				break;
			case 1: 
				{	mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
					p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
					// diameter
					Point3 center = p[0];
					r = Length(p[1]-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
				
				ob->pblock->SetValue(PB_MOUNTDIA,0,r);
				ob->pblock->SetValue(PB_CYLDIA,0,2.0f*r);
				ob->pblock->SetValue(PB_PISTONDIA,0,0.5f*r);
				ob->pblock->SetValue(PB_BOOTDIA1,0,0.7f*r);
				ob->pblock->SetValue(PB_BOOTDIA2,0,1.8f*r);
				ob->pblock->SetValue(PB_BOOTSTOPDIA,0,0.8f*r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL)
				{	float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
				}

				if (msg==MOUSE_POINT) 
				{if (Length(m-sp0)<3 ||	Length(p[1]-p[0])<0.1f)
					{return CREATE_ABORT;	}
				}
				break;
				}
			case 2:
				{
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				if (h<0.0f) 
					h = -h;
				ob->pblock->SetValue(PB_NOREFLENGTH,0,h);
				ob->pblock->SetValue(PB_MOUNTLEN,0,0.1f*h);
				ob->pblock->SetValue(PB_CYLLEN,0,0.6f*h);
				ob->pblock->SetValue(PB_PISTONLEN,0,0.5f*h);
				ob->pblock->SetValue(PB_BOOTSTOPLEN,0,0.05f*h);
				ob->pblock->SetValue(PB_BOOTSETBACK,0,0.1f*h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{ ob->suspendSnap = FALSE;
				  if (Length(m-sp0)<3 ) return CREATE_ABORT;	
				  else { TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
						TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
						return CREATE_STOP;
						}
				}
				}
				break;
			}
	}
	else
	if (msg == MOUSE_ABORT) 
	{ return CREATE_ABORT;}

	return TRUE;
}

static DamperEmitterCreateCallback emitterCallback;

CreateMouseCallBack* DamperObject::GetCreateMouseCallBack() 
	{
	emitterCallback.ob = this;
	return &emitterCallback;
	}

void DamperObject::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *DamperObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_NOREFLENGTH:
		case PB_MOUNTDIA:
		case PB_MOUNTLEN:
		case PB_CYLDIA:
		case PB_CYLLEN:
		case PB_CYLFILLET1:
		case PB_CYLFILLET2:
		case PB_INSIDEDIA:
		case PB_PISTONDIA:
		case PB_PISTONLEN:
		case PB_BOOTDIA1:
		case PB_BOOTDIA2:
		case PB_BOOTSTOPDIA:
		case PB_BOOTSTOPLEN:
		case PB_BOOTSETBACK:
		case PB_BOOTSTOPFILLET:
					return stdWorldDim;
		default:	return defaultDim;
		}
	}

TSTR DamperObject::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ENDSMETHOD:			return GetString(IDS_AP_ENDSMETHOD);break;
		case PB_NOREFLENGTH:		return GetString(IDS_AP_NOREFDL);break;
		case PB_RENDERABLE:			return GetString(IDS_AP_RENDER);break;

		case PB_MOUNTDIA:			return GetString(IDS_AP_MOUNTDIA);break;
		case PB_MOUNTLEN:			return GetString(IDS_AP_MOUNTLEN);break;
		case PB_CYLDIA:				return GetString(IDS_AP_CYLDIA);break;
		case PB_CYLLEN:				return GetString(IDS_AP_CYLLEN);break;
		case PB_CYLSIDES:			return GetString(IDS_AP_CYLSIDES);break;
		case PB_CYLFILLET1:			return GetString(IDS_AP_CYLFILLET1);break;
		case PB_CYLFILLET1SEGS:		return GetString(IDS_AP_CYLFILLET1SEGS);break;
		case PB_CYLFILLET2:			return GetString(IDS_AP_CYLFILLET2);break;
		case PB_CYLFILLET2SEGS:		return GetString(IDS_AP_CYLFILLET2SEGS);break;
		case PB_INSIDEDIA:			return GetString(IDS_AP_INSIDEDIA);break;
		case PB_SMOOTHCYL:			return GetString(IDS_AP_SMOOTHCYL);break;

		case PB_PISTONDIA:			return GetString(IDS_AP_PISTONDIA);break;
		case PB_PISTONLEN:			return GetString(IDS_AP_PISTONLEN);break;
		case PB_PISTONSIDES:		return GetString(IDS_AP_PISTONSIDES);break;
		case PB_SMOOTHPISTON:		return GetString(IDS_AP_SMOOTHPISTON);break;

		case PB_ENABLEBOOT:			return GetString(IDS_AP_ENABLEBOOT);break;
		case PB_BOOTDIA1:			return GetString(IDS_AP_BOOTDIA1);break;
		case PB_BOOTDIA2:			return GetString(IDS_AP_BOOTDIA2);break;
		case PB_BOOTSIDES:			return GetString(IDS_AP_BOOTSIDES);break;
		case PB_BOOTFOLDS:			return GetString(IDS_AP_BOOTFOLDS);break;
		case PB_BOOTRESOLUTION:		return GetString(IDS_AP_BOOTRESOLUTION);break;
		case PB_BOOTSTOPDIA:		return GetString(IDS_AP_BOOTSTOPDIA);break;
		case PB_BOOTSTOPLEN:		return GetString(IDS_AP_BOOTSTOPLEN);break;
		case PB_BOOTSETBACK:		return GetString(IDS_AP_BOOTSETBACK);break;
		case PB_BOOTSTOPFILLET:		return GetString(IDS_AP_BOOTSTOPFILLET);break;
		case PB_BOOTSTOPFILLETSEGS:	return GetString(IDS_AP_BOOTSTOPFILLETSEGS);break;
		case PB_SMOOTHBOOT:			return GetString(IDS_AP_SMOOTHBOOT);break;

		case PB_DYNTYPE:			return GetString(IDS_AP_DYNTYPE);break;
		case PB_DYNDRAG:			return GetString(IDS_AP_DYNDRAG);break;
		case PB_DYNDRAGUNITS:		return GetString(IDS_AP_DYNDRAGUNITS);break;
		case PB_SPRINGDIR:			return GetString(IDS_AP_DAMPERDIR);break;
		case PB_DYNFORCE:			return GetString(IDS_AP_DYNFORCE);break;
		case PB_DYNFORCEUNITS:		return GetString(IDS_AP_DYNFORCEUNITS);break;
		case PB_MAPMEMAPME:			return GetString(IDS_AP_MAPME);break;

		default: 					return TSTR(_T(""));
		}
	}

//--- Damper particle -----------------------------------------------

RefTargetHandle DamperObject::Clone(RemapDir& remap) 
	{
	DamperObject* newob = new DamperObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	if (custnode2) newob->ReplaceReference(CUSTNODE2,custnode2);
	newob->custname=custname;
	newob->custname2=custname2;
	newob->ivalid.SetEmpty();	
	int cnt=GetCOREInterface()->GetSelNodeCount();
	if (cnt>0) newob->thisnode=GetCOREInterface()->GetSelNode(0);
	else newob->thisnode=NULL;
	return newob;
	}

RefTargetHandle DamperObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		case CUSTNODE2: return (RefTargetHandle)custnode2;
		default: return NULL;
		}
	}

void DamperObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		case CUSTNODE2: custnode2 = (INode *)rtarg; return;
		}
	}

RefResult DamperObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode)
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPartRestoreNode(this));
			    DeleteReference(CUSTNODE);
				custnode=NULL;cancelled=FALSE;
				custname=TSTR(_T(" "));				
				}
			  if (hTarget==custnode2) 
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPart2RestoreNode(this));
			    DeleteReference(CUSTNODE2);
				custnode2=NULL;cancelled=FALSE;
			    custname2=TSTR(_T(" "));
			  }
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				cancelled=FALSE;
				}
			  if (hTarget==custnode2) 
			  { custname2 = TSTR(custnode2->GetName());
			    ShowName2();
				cancelled=FALSE;
				}
			  break;
			}
		case REFMSG_CHANGE:
			{ MeshInvalid();
			  if (editOb==this) InvalidateUI();
			  cancelled=FALSE;
			}
			break;
		default: SimpleObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

/*class DamperPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		DamperPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((DamperObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
				((DamperObject*)targ)->pblock->SetValue(PB_SYMMETRY,0,0);
				}
			delete this;
			}
	};*/

#define COM_CUSTNAME_CHUNK	0x0100
#define COM_CUSTNAME2_CHUNK	0x0101
#define COM_CNODE_CHUNK		0x0102

IOResult DamperObject::Save(ISave *isave)
{ 	ULONG nb;
	int refid;

	isave->BeginChunk(COM_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	isave->BeginChunk(COM_CUSTNAME2_CHUNK);		
	isave->WriteWString(custname2);
	isave->EndChunk();

	refid=isave->GetRefID(thisnode);
	isave->BeginChunk(COM_CNODE_CHUNK);		
	isave->Write(&refid,sizeof(int),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult DamperObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	int cnmtl=0;
	int refid;
	
//	iload->RegisterPostLoadCallback(
			//new DamperPostLoadCallback(
				//new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	// Default names
	custname = TSTR(_T(" "));
	custname2 = TSTR(_T(" "));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case COM_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case COM_CUSTNAME2_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname2= TSTR(buf);
				break;
				}
			case COM_CNODE_CHUNK: 
			{	res=iload->Read(&refid,sizeof(int),&nb);
			    iload->RecordBackpatch(refid,(void**)&thisnode);
				break; }
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

const TCHAR *DamperClassDesc::ClassName ()	{return GetString(IDS_AP_DAMPER);}
const TCHAR *DamperClassDesc::Category ()	{return GetString(IDS_EP_DYNPRIMS);}
TCHAR *DamperObject::GetObjectName() {return GetString(IDS_AP_DAMPER);}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\oiltnk.cpp ===
/**********************************************************************
 *<
	FILE: oiltnk.cpp - builds OilTank objects
 	CREATED BY:  Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID OILTNK_CLASS_ID(0x210e642a, 0x22f11ef8);
class OilTnkObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtRadius, crtCapHeight,crtBlend;
		static float crtHeight,crtSliceFrom,crtSliceTo;
		static int dlgHSegs, dlgSides,crtCenters;
		static int dlgCreateMeth;
		static int dlgSmooth, dlgSlice;
		static Point3 crtPos;
		BOOL increate;
		
		OilTnkObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_OILTNK); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return OILTNK_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_SLICE	float(-1.0E30)
#define MAX_SLICE	float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		12

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class OilTnkClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new OilTnkObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_OILTNK_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return OILTNK_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static OilTnkClassDesc OilTnkDesc;

ClassDesc* GetOilTnkDesc() { return &OilTnkDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for OilTnk class.
IObjParam *OilTnkObject::ip         = NULL;
int OilTnkObject::dlgHSegs			= DEF_SEGMENTS;
int OilTnkObject::dlgSides          = DEF_SIDES;
int OilTnkObject::dlgCreateMeth     = 1; // create_radius
int OilTnkObject::dlgSmooth         = SMOOTH_ON;
int OilTnkObject::dlgSlice          = 0;
int OilTnkObject::crtCenters          = 0;
IParamMap *OilTnkObject::pmapCreate = NULL;
IParamMap *OilTnkObject::pmapTypeIn = NULL;
IParamMap *OilTnkObject::pmapParam  = NULL;
Point3 OilTnkObject::crtPos         = Point3(0,0,0);
float OilTnkObject::crtRadius       = 0.0f;
float OilTnkObject::crtHeight       = 0.0f;
float OilTnkObject::crtCapHeight    = 0.0f;
float OilTnkObject::crtSliceFrom    = 0.0f;
float OilTnkObject::crtSliceTo    = 0.0f;
float OilTnkObject::crtBlend	= 0.0f;

void OilTnkClassDesc::ResetClassParams(BOOL fileReset)
	{ OilTnkObject::dlgHSegs			= DEF_SEGMENTS;
	  OilTnkObject::dlgSides          = DEF_SIDES;
	  OilTnkObject::crtBlend			=0.0f;
	  OilTnkObject::dlgCreateMeth     = 1; // create_radius
	  OilTnkObject::dlgSmooth         = SMOOTH_ON;
	  OilTnkObject::dlgSlice          = 0;
	  OilTnkObject::crtCenters          = 0;
	  OilTnkObject::crtRadius       = 0.0f;
	  OilTnkObject::crtHeight       = 0.0f;
	  OilTnkObject::crtCapHeight    = 0.0f;
	  OilTnkObject::crtSliceFrom    = 0.0f;
	  OilTnkObject::crtSliceTo    = 0.0f;
	  OilTnkObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS		0
#define PB_CAPHEIGHT	1
#define PB_HEIGHT		2
#define PB_CENTERS		3
#define PB_BLEND		4
#define PB_SIDES		5
#define PB_HSEGS		6
#define PB_SMOOTHON		7
#define PB_SLICEON		8
#define PB_SLICEFROM	9
#define PB_SLICETO		10
#define PB_GENUVS		11

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_CAPHEIGHT		3
#define PB_TI_HEIGHT		4
#define PB_TI_CENTERS		5
#define PB_TI_BLEND			6
// dont worry about the CREATE button here
#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UCYLS_BYDIA,IDC_UCYLS_BYRAD};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1


//
//
// Type in

static int centerIDs[] = {IDC_OT_LENOVERALL,IDC_OT_LENCENTERS};
static int capIDs[] = {IDC_OT_ONECAP,IDC_OT_TWOCAPS};

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_OT_POSX,IDC_OT_POSXSPIN,
		IDC_OT_POSY,IDC_OT_POSYSPIN,
		IDC_OT_POSZ,IDC_OT_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_OT_RADIUS,IDC_OT_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Cap Height
	ParamUIDesc(
		PB_TI_CAPHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_OT_CAPHGT,IDC_OT_CAPHGTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_OT_HEIGHT,IDC_OT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_TI_CENTERS,TYPE_RADIO,centerIDs,2),
	// Blend
	ParamUIDesc(
		PB_TI_BLEND,
		EDITTYPE_UNIVERSE,
		IDC_OT_BLEND,IDC_OT_BLENDSPIN,
		0.0f,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	};
#define TYPEINDESC_LENGTH 6

//
//
// Parameters


// DANGER DANGER DANGER I THINK THIS IS A REDEF BUT I HAVE NO
//EXAMPLES WITH RADIO BUTTONS APPEARING IN BOTH PARAM AND NONPARAM SCREENS

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_OT_RADIUS,IDC_OT_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Cap Height
	ParamUIDesc(
		PB_CAPHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_OT_CAPHGT,IDC_OT_CAPHGTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_OT_HEIGHT,IDC_OT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_CENTERS,TYPE_RADIO,centerIDs,2),

	// Blend
	ParamUIDesc(
		PB_BLEND,
		EDITTYPE_UNIVERSE,
		IDC_OT_BLEND,IDC_OT_BLENDSPIN,
		0.0f,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_OT_SIDES,IDC_OT_SIDESSPIN,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_OT_HGTSEGS,IDC_OT_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTHON,TYPE_SINGLECHEKBOX,IDC_OT_SMOOTH),			

	// Gen Slice
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_OT_SLICEON),			

	// Pie slice from
	ParamUIDesc(
		PB_SLICEFROM,
		EDITTYPE_FLOAT,
		IDC_OT_SLICE1,IDC_OT_SLICE1SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Pie slice to
	ParamUIDesc(
		PB_SLICETO,
		EDITTYPE_FLOAT,
		IDC_OT_SLICE2,IDC_OT_SLICE2SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			

	};
#define PARAMDESC_LENGTH 12


// variable type, NULL, animatable, number
ParamBlockDescID OilTnkdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 }, 
	{ TYPE_FLOAT, NULL, TRUE, 4},
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 } 
	};

#define PBLOCK_LENGTH	12

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(OilTnkdescVer0,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class OilTnkTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		OilTnkObject *ob;

		OilTnkTypeInDlgProc(OilTnkObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL OilTnkTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_OT_CREATE: {
					if (ob->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_CAPHEIGHT,0,ob->crtCapHeight);
						ob->pblock->SetValue(PB_BLEND,0,ob->crtBlend);
						ob->pblock->SetValue(PB_CENTERS,0,ob->crtCenters);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void FixCapLimits(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float radius,height,minc,capheight,hh;
  BOOL con;

	pblock->GetValue(PB_CAPHEIGHT,(increate?0:t),capheight,FOREVER);
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	pblock->GetValue(PB_CENTERS,t,con,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	height=(float)fabs(height);
	minc=0.025f*radius;
	if (con) height+=2.0f*capheight;
	hh=height/2.0f;
	float maxh=(hh>radius?radius:hh)*0.99f;
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_OT_CAPHGTSPIN));
	  spin2->SetLimits(minc,maxh,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (capheight>maxh) pblock->SetValue(PB_CAPHEIGHT,(increate?0:t),maxh);
	if (capheight<minc) pblock->SetValue(PB_CAPHEIGHT,(increate?0:t),minc);
}
void FixBlendLimits(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float maxb,height,capheight,blend;
  BOOL con;

	pblock->GetValue(PB_CAPHEIGHT,t,capheight,FOREVER);
	pblock->GetValue(PB_CENTERS,t,con,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	pblock->GetValue(PB_BLEND,(increate?0:t),blend,FOREVER);
	height=(float)fabs(height);
	if (con) height+=2.0f*capheight;
	maxb=(height-2.0f*capheight)/2.0f;
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_OT_BLENDSPIN));
	  spin2->SetLimits(0.0f,maxb,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (blend>maxb) pblock->SetValue(PB_BLEND,(increate?0:t),maxb);
}

class OilTnkCapValsDlgProc : public ParamMapUserDlgProc {
	public:
		OilTnkObject *ob;

		OilTnkCapValsDlgProc(OilTnkObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL OilTnkCapValsDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_OT_CAPHGTSPIN:
					FixCapLimits(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				case IDC_OT_BLENDSPIN:
					FixBlendLimits(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}
//--- OilTnk methods -------------------------------

OilTnkObject::OilTnkObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(OilTnkdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_CAPHEIGHT,0,crtCapHeight);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_CENTERS,0,crtCenters);
	pblock->SetValue(PB_BLEND,0,crtBlend);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);
	pblock->SetValue(PB_SMOOTHON,0,dlgSmooth);
	pblock->SetValue(PB_SLICEON,0,dlgSlice);
	pblock->SetValue(PB_SLICEFROM,0,crtSliceFrom);
	pblock->SetValue(PB_SLICETO,0,crtSliceTo);
	increate=FALSE;
	}

IOResult OilTnkObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void OilTnkObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last OilTnk ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UREVS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_OILTANK2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_OILTANK3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new OilTnkTypeInDlgProc(this));
		}
	if(pmapParam) {
		// A callback for the type in.
		pmapParam->SetUserDlgProc(new OilTnkCapValsDlgProc(this));
		}
	}
		
void OilTnkObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);	
	}

/*void BoxObject::SetParams(float radius, float capheight, float height,
						  BOOL centers, BOOL ncaps, float blend,
						  int sides, int hsegs, BOOL smooth, BOOL slice, 
						  float slice1, float slice2, BOOL genUV) {
	pblock->SetValue(PB_RADIUS,0,radius);
	pblock->SetValue(PB_CAPHEIGHT,0,capheight);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_CENTERS,0,centers);
	pblock->SetValue(PB_BLEND,0,blend);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_SMOOTH,0,smooth);
	pblock->SetValue(PB_SLICEON,0,slice);
	pblock->SetValue(PB_SLICEFROM,0,slice1);
	pblock->SetValue(PB_SLICETO,0,slice2);
	pblock->SetValue(PB_GENUVS,0,genUV);
	} 
*/


void BuildOilTnkMesh(Mesh &mesh,
		int segs, int smooth, int llsegs, int doPie, float radius1, float blend,
		float height, float capheight, float pie1, float pie2, int genUVs)
	{
	Point3 p;		   
	BOOL minush=(height<0.0f);
	if (minush) height=-height;
	int ix,jx,ic = 1;
	int nf=0,nv=0, lsegs,VertexPerLevel,capsegs=(int)(segs/3.0f),csegs=(blend>0?1:0);
	float delta,ang;	
	float totalPie, startAng = 0.0f;	

	if (doPie) doPie = 1;
	else doPie = 0; 

	lsegs = llsegs-1 + 2*capsegs;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;		
	int nfaces,ntverts,levels=csegs*2+(llsegs-1);
	int capv=segs,sideedge=capsegs+csegs,*edgelstr,*edgelstl,totlevels;
    // capv=vertex in one cap layer
	totlevels=levels+capsegs*2+2;
	int	tvinslice=totlevels+totlevels-2;
	if (doPie) {
		delta    = totalPie/(float)(segs);
		startAng = pie2; capv++;
		VertexPerLevel=segs+2;
		nfaces=2*segs*(levels+1)+(sideedge+llsegs)*4;
		ntverts=tvinslice+2*(segs+1);
		// 2 faces between every 2 vertices, with 2 ends, except in central cap)
	} else {
		delta = (float)2.0*PI/(float)segs;
		VertexPerLevel=segs;
		nfaces=2*segs*(levels+1);
		ntverts=2*(segs+1)+llsegs-1;
	}

	edgelstl=new int[totlevels];
	edgelstr=new int[totlevels];
	int lastlevel=totlevels-1,dcapv=capv-1,dvertper=VertexPerLevel-1;
	edgelstr[0]=0;edgelstl[0]=0;
	edgelstr[1]=1;
	edgelstl[1]=capv;
	for (int i=2;i<=sideedge;i++)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	}
	while ((i<lastlevel)&&(i<=totlevels-sideedge))
	{ edgelstr[i]=edgelstr[i-1]+VertexPerLevel;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	while (i<lastlevel)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	edgelstl[lastlevel]=(edgelstr[lastlevel]=edgelstl[i-1]+((doPie &&(sideedge==1))?2:1));
	int nverts=edgelstl[lastlevel]+1;

	nfaces+=2*segs*(2*capsegs-1);
	if (height<0) delta = -delta;

  mesh.setSmoothFlags(smooth != 0);
  if (radius1==0.0f)
  { mesh.setNumVerts(0);
	  mesh.setNumFaces(0);
	  mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
  }
  else
  {
	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	if (genUVs) 
	{ ntverts+=nverts;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	
	mesh.setSmoothFlags((smooth != 0) | ((doPie != 0) << 1));
	// bottom vertex 
	mesh.setVert(nv, Point3(0.0f,0.0f,height));
	mesh.setVert(nverts-1, Point3(0.0f,0.0f,0.0f));		
	float ru,cang,sang,botz;//deltacsegs=PI/(2.0f*csegs);
	int msegs=segs,deltaend=nverts-capv-1;
	// Bottom cap vertices
	ang = startAng;	 
	if (!doPie) msegs--;
	float r1sqr=radius1*radius1,chsq=capheight*capheight;
	float tnkrad=(r1sqr+chsq)/(2.0f*capheight);
	float theta=(float)atan(2.0f*radius1*capheight/(r1sqr-chsq)),alpha=(float)acos(1.0f-blend/(2.0f*r1sqr));
	float tangle=theta/capsegs,chrad=tnkrad*(float)sin(theta-alpha),tmpangle;
	float chz=tnkrad*(1.0f-(float)cos(theta-alpha));
	BOOL incap=TRUE;
	for (jx = 0; jx<=msegs; jx++) 
	{ cang=(float)cos(ang);
	  sang=(float)sin(ang);
	  for(ix=1; ix<=sideedge; ix++)
	  {if (ix<=capsegs)
		{ incap=(capsegs==sideedge||ix<capsegs);
		  ru=(incap?tnkrad*(float)sin(tmpangle=(tangle*(float)ix)):chrad);
		  if (jx==0)
		  { p.z = height-(incap?tnkrad*(1.0f-(float)cos(tmpangle)):chz);
		  } else p.z=mesh.verts[edgelstr[ix]].z;
	    }
		else
		{ ru=radius1;
		  if (jx==0)
		  {	p.z=height-(capheight+blend);
		  } else p.z=mesh.verts[edgelstr[ix]].z;
		}
		botz=height-p.z;
		if ((doPie)&&((jx==0)&&(ix==sideedge)))
		{ mesh.setVert(edgelstl[ix]+1,Point3(0.0f,0.0f,p.z));
		  mesh.setVert(edgelstl[lastlevel-ix]+1,Point3(0.0f,0.0f,botz));
		}
		p.x = cang*ru;
		p.y = sang*ru;	
		mesh.setVert(edgelstr[ix]+jx, p);
		mesh.setVert(edgelstr[lastlevel-ix]+jx,Point3(p.x,p.y,botz));
	  }
	  ang += delta;
	}
	//top layer done, now reflect sides down 
	int sidevs,startv=edgelstr[sideedge],deltav;				
	if (llsegs>1)
	{ float topd=mesh.verts[startv].z,sincr=(height-2.0f*(height-topd))/llsegs;
	  for (sidevs=0;sidevs<VertexPerLevel;sidevs++)
	  { p=mesh.verts[startv];
	    deltav=VertexPerLevel;
	    for (ic=1;ic<llsegs;ic++)
	    { p.z =topd-sincr*ic;
	 	  mesh.setVert(startv+deltav, p);
		  deltav+=VertexPerLevel;
	    }
	    startv++;
	  }
	}
	int lasttvl=0,lasttvr=0;
	if (genUVs)
	{ int tvcount=0,nexttv;
	  float udenom=2.0f*radius1;
	  for (i=0;i<=sideedge;i++)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
	  }
	  int iseg,hcount=0,lastedge=(sideedge==1?lastlevel-2:lastlevel-1);
	  float hlevel;
	  for (i=sideedge;i<=lastlevel-sideedge;i++)
	  { hlevel=1.0f-hcount++/(float)llsegs;
		for (iseg=0;iseg<=segs;iseg++)
		 mesh.setTVert(tvcount++,(float)iseg/segs,hlevel,0.0f);
	  }
	  i--;
	  while (i<=lastlevel)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
		i++;
	  }
	  if (doPie)
	  { lasttvl=lasttvr=tvcount;
		float u,v;
		mesh.setTVert(tvcount++,0.0f,1.0f,0.0f);
		for (i=sideedge;i<=sideedge+llsegs;i++)
	    { mesh.setTVert(tvcount++,0.0f,mesh.verts[edgelstl[i]].z/height,0.0f);
		}
		mesh.setTVert(tvcount++,0.0f,0.0f,0.0f);
		for (i=1;i<lastlevel;i++)
		{ u=(float)sqrt(mesh.verts[edgelstl[i]].x*mesh.verts[edgelstl[i]].x+mesh.verts[edgelstl[i]].y*mesh.verts[edgelstl[i]].y)/radius1;
		  v=mesh.verts[edgelstl[i]].z/height;
		  mesh.setTVert(tvcount++,u,v,0.0f);
		  mesh.setTVert(tvcount++,u,v,0.0f);
		}
	  }
	}	
	int lvert=(doPie?segs+1:segs);
    int t0,t1,b0,b1,tvt0=0,tvt1=0,tvb0=1,tvb1=2,fc=0,smoothgr=(smooth?4:0),vseg=segs+1;
	int tvcount=0,lowerside=lastlevel-sideedge,onside=0;
	BOOL ok,wrap;
	// Now make faces ---
	for (int clevel=0;clevel<lastlevel-1;clevel++)
	{ t1=(t0=edgelstr[clevel])+1;
	  b1=(b0=edgelstr[clevel+1])+1;
	  ok=!doPie; wrap=FALSE;
	  if ((clevel>0)&&((doPie)||(onside==1))) {tvt0++;tvt1++;tvb0++,tvb1++;}
	  if (clevel==1) {tvt0=1;tvt1=2;}
	  if (clevel==sideedge)
	    {tvt1+=lvert;tvt0+=lvert;tvb0+=vseg;tvb1+=vseg;onside++;}
	  else if (clevel==lowerside)
	    {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	  while ((b0<edgelstl[clevel+1])||ok)
	  { if (b1==edgelstr[clevel+2]) 
	    { b1=edgelstr[clevel+1]; 
	      t1=edgelstr[clevel];
		  ok=FALSE;wrap=(onside!=1);}
	  if (smooth)
	  { if (blend>0.0f) smoothgr=4;
	    else if ((clevel<sideedge)||(clevel>=lowerside)) 
		  smoothgr=4;
		else smoothgr=8;
	  }
	  if (genUVs) mesh.tvFace[fc].setTVerts(tvt0,tvb0,(wrap?tvb1-segs:tvb1));
		AddFace(&mesh.faces[fc++],t0,b0,b1,0,smoothgr);
	    if (clevel>0)
		{ if (genUVs)
		  { if (wrap) mesh.tvFace[fc].setTVerts(tvt0++,tvb1-segs,tvt1-segs);
			else mesh.tvFace[fc].setTVerts(tvt0++,tvb1,tvt1);
			tvt1++;
		  }
		  AddFace(&mesh.faces[fc++],t0,b1,t1,1,smoothgr);
		  t0++;t1++;
		}
		b0++;b1++;tvb0++,tvb1++;
	  }
	}
	smoothgr=(smooth?4:0);
	t1=(t0=edgelstr[lastlevel-1])+1;b0=edgelstr[lastlevel];
	int lastpt=(doPie?lastlevel-1:lastlevel);
	if ((doPie)||(onside==1)) {tvt0++;tvt1++;tvb0++,tvb1++;}
	if (sideedge==1) {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	while (t0<edgelstl[lastpt])
	  { if ((!doPie)&&(t1==edgelstr[lastlevel]))
	    { t1=edgelstr[lastlevel-1];tvt1-=segs;}
		if (genUVs) mesh.tvFace[fc].setTVerts(tvt0++,tvb0,tvt1++);
		AddFace(&mesh.faces[fc++],t0,b0,t1,1,smoothgr);
		t0++;t1++;
	  }
	int chv=edgelstl[sideedge]+1,botcap=lastlevel-sideedge;
	int chb=edgelstl[botcap]+1,chm0,chm1,last=0,sg0=(smooth?2:0),sg1=(smooth?1:0);
	if (doPie)
	{int topctv=lasttvl+1,tvcount=topctv+llsegs+2;
	  for (i=1;i<=lastlevel;i++)
	  { if (i<=sideedge)
		{ if (genUVs)
		  { mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chv,edgelstl[last],(i==1?1:2),sg0);
		  AddFace(&mesh.faces[fc++],edgelstr[last],chv,edgelstr[i],(i==1?3:2),sg1);
		}
	    else if (i<=botcap)
		{ if (genUVs)
		  { topctv++;
			mesh.tvFace[fc].setTVerts(lasttvl,tvcount,topctv);
			mesh.tvFace[fc+1].setTVerts(lasttvl,topctv,topctv-1);lasttvl=tvcount++;
		    mesh.tvFace[fc+2].setTVerts(topctv-1,topctv,tvcount);
		    mesh.tvFace[fc+3].setTVerts(topctv-1,tvcount,lasttvr);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[last],edgelstl[i],chm1=(edgelstl[i]+1),0,sg0);
	      AddFace(&mesh.faces[fc++],edgelstl[last],chm1,chm0=(edgelstl[last]+1),1,sg0);
		  AddFace(&mesh.faces[fc++],chm0,chm1,edgelstr[i],0,sg1);
	      AddFace(&mesh.faces[fc++],chm0,edgelstr[i],edgelstr[last],1,sg1);
		}
		else
		{if (genUVs)
		  {	if (i==lastlevel) tvcount=topctv+1;
			mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);
			  if (i<lastlevel) lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chb,edgelstl[last],(i==lastlevel?3:2),sg0);
	      AddFace(&mesh.faces[fc++],edgelstr[last],chb,edgelstr[i],(i==lastlevel?1:2),sg1);
		}
		last++;
	  }
	}

	if (minush)
	for (i=0;i<nverts;i++) mesh.verts[i].z-=height;
	if (edgelstr) delete []edgelstr;
	if (edgelstl) delete []edgelstl;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts);
  }
  mesh.InvalidateGeomCache();
  mesh.BuildStripsAndEdges();
}

BOOL OilTnkObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void OilTnkObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void OilTnkObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, hsegs;
	float radius,height,pie1, pie2,capheight,blend;
	int doPie, genUVs,con;	

 
	FixCapLimits(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	FixBlendLimits(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);

	ivalid = FOREVER;
	
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_CAPHEIGHT,t,capheight,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_BLEND,t,blend,ivalid);
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_CENTERS,t,con,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	if (con) height+=2.0f*capheight;
	pblock->GetValue(PB_SMOOTHON,t,smooth,ivalid);	
	pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
	pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
				//        sides, smooth, 			  cylrad  fsize	 totalh
	BuildOilTnkMesh(mesh, segs, smooth, hsegs, doPie,radius, blend, height, capheight,pie1, pie2, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f


Object* OilTnkObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int OilTnkObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class OilTnkObjCreateCallBack: public CreateMouseCallBack {
	OilTnkObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1,sp2;
	float h,r,basech;
	int con;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(OilTnkObject *obj) { ob = obj; }
	};

int OilTnkObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->GetValue(PB_CENTERS,0,con,FOREVER);
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.005f);
				ob->pblock->SetValue(PB_CAPHEIGHT,0,0.0025f);
				ob->increate=TRUE;
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pblock->SetValue(PB_HEIGHT,0,0.5f*r);
				ob->pblock->SetValue(PB_CAPHEIGHT,0,(basech=0.25f*r));
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 ||
						Length(p[1]-p[0])<0.1f) {	
						ob->increate=FALSE;
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				{sp2=m;
				float minh=0.5f*r;
#ifdef _OSNAP
				float tmph = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float tmph = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				tmph+=(tmph<0?-minh:minh);
				p[1].z=p[0].z;
				h=tmph;
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) 
				{ if (Length(m-sp0)<3) {ob->increate=FALSE;
				return CREATE_ABORT;}
				}
				}
				break;
			case 3:
				{
				float ch = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				if (ch<0.0f) ch=0.0f;
				ch+=basech;float rmax=0.99f*r;
				if (ch>=rmax) ch=rmax;
				float blend;
				ob->pblock->GetValue(PB_BLEND,0,blend,FOREVER);
				float chmax=((float)fabs(h)-2.0f*blend)/2.0f;
				float minc=0.025f*r;
				if ((!con)&&(ch>chmax)) ch=(chmax<0?minc:chmax);
				if (ch<minc) ch=minc;
				ob->pblock->SetValue(PB_CAPHEIGHT,0,ch);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					ob->suspendSnap = FALSE;ob->increate=FALSE;
					return CREATE_STOP;
					}
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {
		ob->increate=FALSE;		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static OilTnkObjCreateCallBack cylCreateCB;

CreateMouseCallBack* OilTnkObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL OilTnkObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL OilTnkObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		case PB_TI_CENTERS: crtCenters = v; break;
		}		
	return TRUE;
	}

BOOL OilTnkObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_CAPHEIGHT: crtCapHeight = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		case PB_TI_BLEND: crtBlend = v; break;
		}	
	return TRUE;
	}

BOOL OilTnkObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL OilTnkObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		case PB_TI_CENTERS: v = crtCenters; break;
		}
	return TRUE;
	}

BOOL OilTnkObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v=crtRadius; break;
		case PB_TI_CAPHEIGHT: v=crtCapHeight; break;
		case PB_TI_HEIGHT: v=crtHeight; break;
		case PB_TI_BLEND: v=crtBlend; break;
		}
	return TRUE;
	}

BOOL OilTnkObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void OilTnkObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *OilTnkObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return stdWorldDim;
		case PB_CAPHEIGHT: return stdWorldDim;
		case PB_HEIGHT: return stdWorldDim;
		case PB_BLEND: return stdWorldDim;
		case PB_SIDES: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		case PB_SLICEFROM: return stdAngleDim;
		case PB_SLICETO: return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR OilTnkObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return TSTR(GetString(IDS_RB_RADIUS));
		case PB_CAPHEIGHT: return TSTR(GetString(IDS_RB_CAPHEIGHT));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_BLEND: return TSTR(GetString(IDS_RB_BLEND));
		case PB_SIDES: return TSTR(GetString(IDS_RB_SIDES));
		case PB_HSEGS: return TSTR(GetString(IDS_RB_HSEGS));
		case PB_SMOOTHON: return TSTR(GetString(IDS_RB_SMOOTHON));
		case PB_SLICEON: return TSTR(GetString(IDS_RB_SLICEON));
		case PB_SLICEFROM: return TSTR(GetString(IDS_RB_SLICEFROM));
		case PB_SLICETO: return TSTR(GetString(IDS_RB_SLICETO));
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle OilTnkObject::Clone(RemapDir& remap) 
	{
	OilTnkObject* newob = new OilTnkObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\prism.cpp ===
/**********************************************************************
 *<
	FILE:prism.cpp
	CREATED BY:  Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"

static Class_ID PRISM_CLASS_ID(0x63705fac, 0x5c1f553f);
class PrismObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtHeight,crtSide1,crtSide2,crtSide3;
		static int dlgHSegs, dlgSide1Segs, dlgSide2Segs,dlgSide3Segs;
		static int dlgCreateMeth;
		static Point3 crtPos;
		int isdone;
		
		PrismObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_PRISM); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return PRISM_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		1

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)


//--- ClassDescriptor and class vars ---------------------------------

class PrismClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new PrismObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_PRISM_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return PRISM_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static PrismClassDesc PrismDesc;

ClassDesc* GetPrismDesc() { return &PrismDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Prism class.
IObjParam *PrismObject::ip         = NULL;
int PrismObject::dlgHSegs			= DEF_SEGMENTS;
int PrismObject::dlgSide1Segs       = DEF_SIDES;
int PrismObject::dlgSide2Segs       = DEF_SIDES;
int PrismObject::dlgSide3Segs       = DEF_SIDES;
int PrismObject::dlgCreateMeth     = 1; // create_radius
IParamMap *PrismObject::pmapCreate = NULL;
IParamMap *PrismObject::pmapTypeIn = NULL;
IParamMap *PrismObject::pmapParam  = NULL;
Point3 PrismObject::crtPos         = Point3(0,0,0);
float PrismObject::crtHeight       = 0.0f;
float PrismObject::crtSide1       = 0.0f;
float PrismObject::crtSide2       = 0.0f;
float PrismObject::crtSide3       = 0.0f;

void PrismClassDesc::ResetClassParams(BOOL fileReset)
	{ PrismObject::dlgHSegs			= DEF_SEGMENTS;
	  PrismObject::dlgSide1Segs     = DEF_SIDES;
	  PrismObject::dlgSide2Segs     = DEF_SIDES;
	  PrismObject::dlgSide3Segs     = DEF_SIDES;
	  PrismObject::dlgCreateMeth     = 1; // create_radius
	  PrismObject::crtHeight       = 0.0f;
	  PrismObject::crtSide1       = 0.0f;
	  PrismObject::crtSide2       = 0.0f;
	  PrismObject::crtSide3       = 0.0f;
	  PrismObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_SIDE1		0
#define PB_SIDE2		1
#define PB_SIDE3		2
#define PB_HEIGHT		3
#define PB_S1SEGS		4
#define PB_S2SEGS		5
#define PB_S3SEGS		6
#define PB_HSEGS		7
#define PB_GENUVS		8

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_SIDE1			2
#define PB_TI_SIDE2			3
#define PB_TI_SIDE3			4
#define PB_TI_HEIGHT		5

#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_PR_CREATEBASE,IDC_PR_CREATEVERTICES};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1



//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_PR_POSX,IDC_PR_POSXSPIN,
		IDC_PR_POSY,IDC_PR_POSYSPIN,
		IDC_PR_POSZ,IDC_PR_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Side1 Length
	ParamUIDesc(
		PB_TI_SIDE1,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE1LEN,IDC_PR_SIDE1LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Side2 Length
	ParamUIDesc(
		PB_TI_SIDE2,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE2LEN,IDC_PR_SIDE2LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Side3 Length
	ParamUIDesc(
		PB_TI_SIDE3,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE3LEN,IDC_PR_SIDE3LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_PR_HEIGHT,IDC_PR_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGTH 5


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Side1 Length
	ParamUIDesc(
		PB_SIDE1,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE1LEN,IDC_PR_SIDE1LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Side2 Length
	ParamUIDesc(
		PB_SIDE2,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE2LEN,IDC_PR_SIDE2LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Side3 Length
	ParamUIDesc(
		PB_SIDE3,
		EDITTYPE_UNIVERSE,
		IDC_PR_SIDE3LEN,IDC_PR_SIDE3LENSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_PR_HEIGHT,IDC_PR_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	
	
	// Side1 Segments
	ParamUIDesc(
		PB_S1SEGS,
		EDITTYPE_INT,
		IDC_PR_SIDE1SEGS,IDC_PR_SIDE1SEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Side2 Segments
	ParamUIDesc(
		PB_S2SEGS,
		EDITTYPE_INT,
		IDC_PR_SIDE2SEGS,IDC_PR_SIDE2SEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Side3 Segments
	ParamUIDesc(
		PB_S3SEGS,
		EDITTYPE_INT,
		IDC_PR_SIDE3SEGS,IDC_PR_SIDE3SEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_PR_HGTSEGS,IDC_PR_HGTSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 9


// variable type, NULL, animatable, number
ParamBlockDescID PrismdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 }, 
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, FALSE, 8 }, 
	};

#define PBLOCK_LENGTH	9

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(PrismdescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

void FixSide1(IParamBlock *pblock,TimeValue t,HWND hWnd)
{ float s1len,s2len,s3len,dl;

	pblock->GetValue(PB_SIDE1,t,s1len,FOREVER);
	pblock->GetValue(PB_SIDE2,t,s2len,FOREVER);
	pblock->GetValue(PB_SIDE3,t,s3len,FOREVER);
	dl=0.95f*(s2len+s3len);
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_PR_SIDE1LENSPIN));
	  spin2->SetLimits(BMIN_LENGTH,dl,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (s1len>dl) pblock->SetValue(PB_SIDE1,t,dl);
}
void FixSide2(IParamBlock *pblock,TimeValue t,HWND hWnd)
{ float s1len,s2len,s3len,dl;

	pblock->GetValue(PB_SIDE1,t,s1len,FOREVER);
	pblock->GetValue(PB_SIDE2,t,s2len,FOREVER);
	pblock->GetValue(PB_SIDE3,t,s3len,FOREVER);
	dl=0.95f*(s1len+s3len);
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_PR_SIDE2LENSPIN));
	  spin2->SetLimits(BMIN_LENGTH,dl,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (s2len>dl) pblock->SetValue(PB_SIDE2,t,dl);
}
void FixSide3(IParamBlock *pblock,TimeValue t,HWND hWnd)
{ float s1len,s2len,s3len,dl;

	pblock->GetValue(PB_SIDE1,t,s1len,FOREVER);
	pblock->GetValue(PB_SIDE2,t,s2len,FOREVER);
	pblock->GetValue(PB_SIDE3,t,s3len,FOREVER);
	dl=0.95f*(s1len+s2len);
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_PR_SIDE3LENSPIN));
	  spin2->SetLimits(BMIN_LENGTH,dl,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (s3len>dl) pblock->SetValue(PB_SIDE3,t,dl);
}
//--- TypeInDlgProc --------------------------------

class PrismTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		PrismObject *ob;

		PrismTypeInDlgProc(PrismObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL PrismTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_PR_CREATE: {
					if (ob->crtHeight==0.0f) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_SIDE1,0,ob->crtSide1);
						ob->pblock->SetValue(PB_SIDE2,0,ob->crtSide2);
						ob->pblock->SetValue(PB_SIDE3,0,ob->crtSide3);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;ob->isdone=TRUE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}
class PrismSideDlgProc : public ParamMapUserDlgProc {
	public:
		PrismObject *ob;

		PrismSideDlgProc(PrismObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL PrismSideDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_PR_SIDE1LENSPIN:
					FixSide1(ob->pblock,t,hWnd);
			return TRUE;
				case IDC_PR_SIDE2LENSPIN:
					FixSide2(ob->pblock,t,hWnd);
			return TRUE;
				case IDC_PR_SIDE3LENSPIN:
					FixSide3(ob->pblock,t,hWnd);
			return TRUE;
				}
		}
	return FALSE;
	}



//--- Prism methods -------------------------------

PrismObject::PrismObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(PrismdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_S1SEGS,0,dlgSide1Segs);
	pblock->SetValue(PB_S2SEGS,0,dlgSide2Segs);
	pblock->SetValue(PB_S3SEGS,0,dlgSide3Segs);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);

	pblock->SetValue(PB_SIDE1,0,crtSide1);
	pblock->SetValue(PB_SIDE2,0,crtSide2);
	pblock->SetValue(PB_SIDE3,0,crtSide3);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	isdone=FALSE;
	}

IOResult PrismObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void PrismObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Prism ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PRISM1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PRISM2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_PRISM3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new PrismTypeInDlgProc(this));
		}	
	if(pmapParam) {
		pmapParam->SetUserDlgProc(new PrismSideDlgProc(this));
		}
	}
		
void PrismObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_S1SEGS,ip->GetTime(),dlgSide1Segs,FOREVER);
	pblock->GetValue(PB_S2SEGS,ip->GetTime(),dlgSide2Segs,FOREVER);	
	pblock->GetValue(PB_S3SEGS,ip->GetTime(),dlgSide3Segs,FOREVER);	
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);		
	}

/*void PrismObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	pblock->SetValue(PB_SIDE1,0,side1);
	pblock->SetValue(PB_SIDE2,0,side2);
	pblock->SetValue(PB_SIDE3,0,side3);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_S1SEGS,0,s1segs);
	pblock->SetValue(PB_S2SEGS,0,s2segs);
	pblock->SetValue(PB_S3SEGS,0,s3segs);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_CSEGS,0,csegs);
	pblock->SetValue(PB_GENUVS,0, genUV);
*/

void BuildPrismMesh(Mesh &mesh,
		int s1segs, int s2segs, int s3segs, int llsegs, 
		float s1len, float s2len, float s3len, float height,
		int genUVs)
{	BOOL minush=(height<0.0f);
	if (minush) height=-height;
	int nf=0,totalsegs=s1segs+s2segs+s3segs;
	float s13len=s1len*s3len;
	if ((s1len<=0.0f)||(s2len<=0.0f)||(s3len<=0.0f))
	{ mesh.setNumVerts(0);
	  mesh.setNumFaces(0);
	  mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	else
	{ float acvalue=(s2len*s2len-s1len*s1len-s3len*s3len)/(-2.0f*s13len);
	  acvalue=(acvalue<-1.0f?-1.0f:(acvalue>1.0f?acvalue=1.0f:acvalue));
	  float theta=(float)acos(acvalue);
	int nfaces,ntverts;
	nfaces=2*totalsegs*(llsegs+1);
	int nverts=totalsegs*(llsegs+1)+2;

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	if (genUVs) 
	{ ntverts=nverts+2*totalsegs+llsegs+1;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	
	Point3 Pt0=Point3(0.0f,0.0f,height),Pt1=Point3(s1len,0.0f,height);
	Point3 Pt2=Point3(s3len*(float)cos(theta),s3len*(float)sin(theta),height);
	Point3 CenterPt=(Pt0+Pt1+Pt2)/3.0f,Mins;
	float maxx;
	if (s1len<Pt2.x) {Mins.x=s1len;maxx=Pt2.x;}
	else {Mins.x=Pt2.x;maxx=s1len;}
	if (maxx<0.0f) maxx=0.0f;
	if (Mins.x>0.0f) Mins.x=0.0f;
	Mins.y=0.0f;
	float xdist=maxx-Mins.x,ydist=Pt2.y;
	if (xdist==0.0f) xdist=0.001f;if (ydist==0.0f) ydist=0.001f;
	mesh.setVert(0,CenterPt);
	mesh.setVert(nverts-1, Point3(CenterPt.x,CenterPt.y,0.0f));
	mesh.setVert(1,Pt0);
	int botstart=ntverts-totalsegs-1,tnv=totalsegs+1;
	float u=0.0f,yval=Pt2.y,bu,tu,tb;
	if (genUVs) 
	{ mesh.setTVert(0,tu=(CenterPt.x-Mins.x)/xdist,tb=(CenterPt.y-Mins.y)/ydist,0.0f);
	  mesh.setTVert(1,bu=(-Mins.x/xdist),0.0f,0.0f);
	  mesh.setTVert(tnv++,0.0f,1.0f,0.0f);
	  mesh.setTVert(botstart++,1.0f-bu,1.0f,0.0f);
	  mesh.setTVert(ntverts-1,1.0f-tu,1.0f-tb,0.0f);
	}
	int i,nv=2;
	float sincr=s1len/s1segs,tdist=s1len+s2len+s3len,udiv=sincr/tdist,pos;
	if (tdist==0.0f) tdist=0.0001f;
	for (i=1;i<s1segs;i++)
	{ mesh.setVert(nv,Point3(pos=sincr*i,0.0f,height));
	  if (genUVs) 
	  { mesh.setTVert(nv,bu=(pos-Mins.x)/xdist,0.0f,0.0f);
	    mesh.setTVert(tnv++,u+=udiv,1.0f,0.0f);
	    mesh.setTVert(botstart++,1.0f-bu,1.0f,0.0f);
	  }
	  nv++;
	}
	mesh.setVert(nv,Pt1);
	if (genUVs)
	{ mesh.setTVert(nv,bu=(Pt1.x-Mins.x)/xdist,0.0f,0.0f);
	  mesh.setTVert(tnv++,u+=udiv,1.0f,0.0f);
	  mesh.setTVert(botstart++,1.0f-bu,1.0f,0.0f);
	}
	Point3 slope=(Pt2-Pt1)/(float)s2segs;
	float ypos,bv;
	nv++;udiv=(s2len/s2segs)/tdist;
	for (i=1;i<s2segs;i++)
	{ mesh.setVert(nv,Point3(pos=(Pt1.x+slope.x*i),ypos=(Pt1.y+slope.y*i),height));
	  if (genUVs) 
	  { mesh.setTVert(nv,bu=(pos-Mins.x)/xdist,bv=(ypos-Mins.y)/ydist,0.0f);
	    mesh.setTVert(tnv++,u+=udiv,1.0f,0.0f);
	    mesh.setTVert(botstart++,1.0f-bu,1.0f-bv,0.0f);
	  }
	  nv++;
	}
	mesh.setVert(nv,Pt2);
	if (genUVs)
	{ mesh.setTVert(nv,bu=(Pt2.x-Mins.x)/xdist,1.0f,0.0f);
	  mesh.setTVert(tnv++,u+=udiv,1.0f,0.0f);
	  mesh.setTVert(botstart++,1.0f-bu,0.0f,0.0f);
	}
	nv++; slope=(Pt0-Pt2)/(float)s3segs;udiv=(s2len/s2segs)/tdist;
	for (i=1;i<s3segs;i++)
	{ mesh.setVert(nv,Point3(pos=(Pt2.x+slope.x*i),ypos=(Pt2.y+slope.y*i),height));
	  if (genUVs) 
	  { mesh.setTVert(nv,bu=(pos-Mins.x)/xdist,bv=(ypos-Mins.y)/ydist,0.0f);
	    mesh.setTVert(tnv++,u+=udiv,1.0f,0.0f);
	    mesh.setTVert(botstart++,1.0f-bu,1.0f-bv,0.0f);
	  }
	  nv++;
	}
	if (genUVs)	mesh.setTVert(tnv++,1.0f,1.0f,0.0f);
	//top layer done, now reflect sides down 
	int sidevs,startv=1,deltav,ic;
	startv=1;
	sincr=height/llsegs;
	Point3 p;
	for (sidevs=0;sidevs<totalsegs;sidevs++)
	{ p=mesh.verts[startv];
	  deltav=totalsegs;
	  for (ic=1;ic<=llsegs;ic++)
	  { p.z =height-sincr*ic;
	    mesh.setVert(startv+deltav, p);
		deltav+=totalsegs;
	  }
	  startv++;
	}
	if (genUVs)
	{ startv=totalsegs+1;
	  int tvseg=totalsegs+1;
	  for (sidevs=0;sidevs<=totalsegs;sidevs++)
	  { p=mesh.tVerts[startv];
	    deltav=tvseg;
	    for (ic=1;ic<=llsegs;ic++)
	    { p.y =1.0f-ic/(float)llsegs;
	      mesh.setTVert(startv+deltav,p);
	      deltav+=tvseg;
	    }
   	   startv++;
	 }
	}
    int fc=0,sidesm=2;
	int last=totalsegs-1;
	// Now make faces ---
	int j,b0=1,b1=2,tb0,tb1,tt0,tt1,t0,t1,ecount=0,s2end=s1segs+s2segs;
	for (i=0;i<totalsegs;i++)
	{ if (genUVs) mesh.tvFace[fc].setTVerts(0,b0,(i<last?b1:1));
	AddFace(&mesh.faces[fc++],0,b0++,(i<last?b1++:1),0,1);
	}
	tt1=(tt0=i+1)+1;t0=1;t1=2;b1=(b0=t0+totalsegs)+1;
	tb1=(tb0=tt1+totalsegs)+1;
	for (i=1;i<=llsegs;i++)
	{ for (j=0;j<totalsegs;j++)
	  { if (genUVs) 
		{ mesh.tvFace[fc].setTVerts(tt0,tb0++,tb1);
		  mesh.tvFace[fc+1].setTVerts(tt0++,tb1++,tt1++);
		}
	    if (j<s1segs) sidesm=2;
		else if (j<s2end) sidesm=4;
		else sidesm=8;
	  AddFace(&mesh.faces[fc++],t0,b0++,(j==last?t1:b1),0,sidesm);
	  if (j<last)
	    AddFace(&mesh.faces[fc++],t0++,b1,t1,1,sidesm);
	  else
	   AddFace(&mesh.faces[fc++],t0++,b1-totalsegs,t1-totalsegs,1,sidesm);
	  t1++;b1++;
	  }
	 tt0++;tt1++;tb0++;tb1++;
	}
	if (genUVs) {tt0=(tt1=ntverts-totalsegs)-1;tb0=ntverts-1;}
	for (i=0;i<totalsegs;i++)
	{ if (genUVs)
	   { mesh.tvFace[fc].setTVerts(tt0++,tb0,(i==last?tt1-totalsegs:tt1));
	     tt1++;
	   }
	AddFace(&mesh.faces[fc++],t0++,b0,(i==last?t1-totalsegs:t1),1,1);
	  t1++;
	}
	if (minush)
	for (i=0;i<nverts;i++) mesh.verts[i].z-=height;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts); */
}
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}
BOOL PrismObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void PrismObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void PrismObject::BuildMesh(TimeValue t)
	{	
	int hsegs,s1segs,s2segs,s3segs;
	float height,s1len,s2len,s3len;
	int genUVs;	

	if (isdone)
	{  FixSide1(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL));
	   FixSide2(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL));
	   FixSide3(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL));
	}

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_S1SEGS,t,s1segs,ivalid);
	pblock->GetValue(PB_S2SEGS,t,s2segs,ivalid);
	pblock->GetValue(PB_S3SEGS,t,s3segs,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_SIDE1,t,s1len,ivalid);
	pblock->GetValue(PB_SIDE2,t,s2len,ivalid);
	pblock->GetValue(PB_SIDE3,t,s3len,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(s1len, BMIN_HEIGHT, MAX_HEIGHT);
	LimitValue(s2len, BMIN_HEIGHT, MAX_HEIGHT);
	LimitValue(s3len, BMIN_HEIGHT, MAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(s1segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(s2segs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(s3segs, MIN_SEGMENTS, MAX_SEGMENTS);
	
	BuildPrismMesh(mesh, s1segs, s2segs, s3segs, hsegs, 
		s1len, s2len, s3len, height, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}


#ifndef NO_NURBS

Object*
BuildNURBSPrism(float side1, float side2, float side3, float height, int genUVs)
{
	float s13len=side1*side3;
	float theta = (float)acos((side2*side2 - side1*side1 - side3*side3)/(-2.0f*s13len));

	int prism_faces[5][4] = {{0, 1, 2, 2}, // bottom
							{1, 0, 4, 3}, // front
							{2, 1, 5, 4}, // left
							{0, 2, 3, 5}, // right
							{4, 3, 5, 5}};// top
	Point3 prism_verts[6] ={Point3(0.0f, 0.0f, 0.0f),
							Point3(side1,  0.0f, 0.0f),
							Point3(side3*(float)cos(theta), side3*(float)sin(theta), 0.0f),
							Point3(0.0f, 0.0f, height),
							Point3(side1,  0.0f, height),
							Point3(side3*(float)cos(theta), side3*(float)sin(theta), height)};

	NURBSSet nset;

	for (int face = 0; face < 5; face++) {
		Point3 bl = prism_verts[prism_faces[face][0]];
		Point3 br = prism_verts[prism_faces[face][1]];
		Point3 tl = prism_verts[prism_faces[face][2]];
		Point3 tr = prism_verts[prism_faces[face][3]];

		NURBSCVSurface *surf = new NURBSCVSurface();
		nset.AppendObject(surf);
		surf->SetUOrder(4);
		surf->SetVOrder(4);
		surf->SetNumCVs(4, 4);
		surf->SetNumUKnots(8);
		surf->SetNumVKnots(8);

		Point3 top, bot;
		for (int r = 0; r < 4; r++) {
			top = tl + (((float)r/3.0f) * (tr - tl));
			bot = bl + (((float)r/3.0f) * (br - bl));
			for (int c = 0; c < 4; c++) {
				NURBSControlVertex ncv;
				ncv.SetPosition(0, bot + (((float)c/3.0f) * (top - bot)));
				ncv.SetWeight(0, 1.0f);
				surf->SetCV(r, c, ncv);
			}
		}

		for (int k = 0; k < 4; k++) {
			surf->SetUKnot(k, 0.0);
			surf->SetVKnot(k, 0.0);
			surf->SetUKnot(k + 4, 1.0);
			surf->SetVKnot(k + 4, 1.0);
		}

		surf->Renderable(TRUE);
		surf->SetGenerateUVs(genUVs);
		if (height > 0.0f)
			surf->FlipNormals(TRUE);
		else
			surf->FlipNormals(FALSE);

		float sum = side1 + side2 + side3;
		float s1 = side1/sum;
		float s3 = 1.0f - side3/sum;
		switch(face) {
		case 0:
			surf->SetTextureUVs(0, 0, Point2(0.5f, 0.0f));
			surf->SetTextureUVs(0, 1, Point2(0.5f, 0.0f));
			surf->SetTextureUVs(0, 2, Point2(1.0f, 1.0f));
			surf->SetTextureUVs(0, 3, Point2(0.0f, 1.0f));
			break;
		case 1:
			surf->SetTextureUVs(0, 0, Point2(s1, 1.0f));
			surf->SetTextureUVs(0, 1, Point2(0.0f, 1.0f));
			surf->SetTextureUVs(0, 2, Point2(s1, 0.0f));
			surf->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));
			break;
		case 2:
			surf->SetTextureUVs(0, 0, Point2(s3, 1.0f));
			surf->SetTextureUVs(0, 1, Point2(s1, 1.0f));
			surf->SetTextureUVs(0, 2, Point2(s3, 0.0f));
			surf->SetTextureUVs(0, 3, Point2(s1, 0.0f));
			break;
		case 3:
			surf->SetTextureUVs(0, 0, Point2(1.0f, 1.0f));
			surf->SetTextureUVs(0, 1, Point2(s3, 1.0f));
			surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			surf->SetTextureUVs(0, 3, Point2(s3, 0.0f));
			break;
		case 4:
			surf->SetTextureUVs(0, 0, Point2(0.5f, 1.0f));
			surf->SetTextureUVs(0, 1, Point2(0.5f, 1.0f));
			surf->SetTextureUVs(0, 2, Point2(1.0f, 0.0f));
			surf->SetTextureUVs(0, 3, Point2(0.0f, 0.0f));
			break;
		}

		char bname[80];
		sprintf(bname, "%s%02d", GetString(IDS_CT_SURF), face);
		surf->SetName(bname);
	}

#define F(s1, s2, s1r, s1c, s2r, s2c) \
	fuse.mSurf1 = (s1); \
	fuse.mSurf2 = (s2); \
	fuse.mRow1 = (s1r); \
	fuse.mCol1 = (s1c); \
	fuse.mRow2 = (s2r); \
	fuse.mCol2 = (s2c); \
	nset.mSurfFuse.Append(1, &fuse);

	NURBSFuseSurfaceCV fuse;
	// Bottom(0) to Front (1)
	F(0, 1, 3, 0, 0, 0);
	F(0, 1, 2, 0, 1, 0);
	F(0, 1, 1, 0, 2, 0);
	F(0, 1, 0, 0, 3, 0);

	// Bottom(0) to Left (2)
	F(0, 2, 3, 0, 3, 0);
	F(0, 2, 3, 1, 2, 0);
	F(0, 2, 3, 2, 1, 0);
	F(0, 2, 3, 3, 0, 0);

	// Bottom(0) to Right (3)
	F(0, 3, 0, 0, 0, 0);
	F(0, 3, 0, 1, 1, 0);
	F(0, 3, 0, 2, 2, 0);
	F(0, 3, 0, 3, 3, 0);

	// Top(4) to Front (1)
	F(4, 1, 3, 0, 3, 3);
	F(4, 1, 2, 0, 2, 3);
	F(4, 1, 1, 0, 1, 3);
	F(4, 1, 0, 0, 0, 3);

	// Top(4) to Left (2)
	F(4, 2, 0, 0, 3, 3);
	F(4, 2, 0, 1, 2, 3);
	F(4, 2, 0, 2, 1, 3);
	F(4, 2, 0, 3, 0, 3);

	// Top(4) to Right (3)
	F(4, 3, 3, 0, 0, 3);
	F(4, 3, 3, 1, 1, 3);
	F(4, 3, 3, 2, 2, 3);
	F(4, 3, 3, 3, 3, 3);

	// Front(1) to Left (2)
	F(1, 2, 0, 1, 3, 1);
	F(1, 2, 0, 2, 3, 2);

	// Left(2) to Right (3)
	F(2, 3, 0, 1, 3, 1);
	F(2, 3, 0, 2, 3, 2);

	// Right(3) to Front (1)
	F(3, 1, 0, 1, 3, 1);
	F(3, 1, 0, 2, 3, 2);

	// Fuse the triangles together
	for (int i = 1; i < 4; i++) {
		F(0, 0, 0, 3, i, 3);
		F(4, 4, 0, 3, i, 3);
	}

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *obj = CreateNURBSObject(NULL, &nset, mat);
	return obj;
}

#endif

Object* PrismObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float side1, side2, side3, height;
		int genUVs;
		pblock->GetValue(PB_SIDE1,t,side1,valid);
		pblock->GetValue(PB_SIDE2,t,side2,valid);
		pblock->GetValue(PB_SIDE3,t,side3,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSPrism(side1, side2, side3, height, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 
#endif

    return SimpleObject::ConvertToType(t,obtype);
	}

int PrismObject::CanConvertToType(Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID)
        return 1;
#endif
	if (obtype == triObjectClassID)
		return 1;

    return SimpleObject::CanConvertToType(obtype);
	}

void PrismObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
}


class PrismObjCreateCallBack: public CreateMouseCallBack {
	PrismObject *ob;	
	Point3 p0,p1,p2,tmp,d;
	IPoint2 sp0,sp1,sp2;
	float l,hd;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(PrismObject *obj) { ob = obj; }
	};

int PrismObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:
			{	ob->suspendSnap = TRUE;				
				sp0 = m;				
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0); // Set Node's transform				
				ob->pblock->SetValue(PB_SIDE1,0,0.01f);
				ob->pblock->SetValue(PB_SIDE2,0,0.01f);
				ob->pblock->SetValue(PB_SIDE3,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				break;}
			case 1: 
			{	mat.IdentityMatrix();
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				d = p1-p0;
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					}
				hd=d.x/2.0f,l=(float)sqrt(hd*hd+d.y*d.y);	
				float dl=0.95f*(l+l);
				hd=(float)fabs(d.x);
				if (hd>dl) hd=dl;
				dl=0.95f*(hd+l);
				if (l>dl) l=dl;
				ob->pblock->SetValue(PB_SIDE1,0,hd);
				ob->pblock->SetValue(PB_SIDE2,0,l);
				ob->pblock->SetValue(PB_SIDE3,0,l);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT )
				{if (Length(sp1-sp0)<3 || Length(d)<0.1f) 
				  { return CREATE_ABORT;}
				else {tmp=(p2=p0+Point3(hd/2.0f,l,0.0f));} }
				break; }
			case 2:
				if (!ob->dlgCreateMeth) 
				{
#ifdef _OSNAP
				  float h = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m,TRUE));
#else
				  float h = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
#endif
				  ob->pblock->SetValue(PB_HEIGHT,0,h);
				  ob->pmapParam->Invalidate();				
				  if (msg==MOUSE_POINT)
				  {	ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
				  }
				}
				else
				{ sp2=m;
				  Point3 newpt = vpt->SnapPoint(m,m,NULL,snapdim);
				  p2=tmp+(newpt-p1);
				  d=p2-p0;
				  float l2,dl,l3,l1;
				  l1=hd;
				  l3=(float)sqrt(d.x*d.x+d.y*d.y);
				  Point3 midpt=p0+Point3(hd,0.0f,0.0f);
				  d=p2-midpt;l2=(float)sqrt(d.x*d.x+d.y*d.y);
				  dl=0.95f*(l2+l3);
				  if (l1>dl) 
				  { l1=dl;				  
				    ob->pblock->SetValue(PB_SIDE1,0,(hd=l1));
				  }
				  dl=0.95f*(l1+l3);
				  if (l2>dl) l2=dl;
				  ob->pblock->SetValue(PB_SIDE2,0,l2);
				  dl=0.95f*(l1+l2);
				  if (l3>dl) l3=dl;
				  ob->pblock->SetValue(PB_SIDE3,0,l3);
				  ob->pmapParam->Invalidate();				
				  if (msg==MOUSE_POINT)
			  	  {	if (Length(m-sp0)<3) CREATE_ABORT; }
				}
				break;

			case 3:
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp2,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp2,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{   ob->suspendSnap = FALSE;ob->isdone=TRUE;
					return CREATE_STOP;
				}
				break;

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static PrismObjCreateCallBack cylCreateCB;

CreateMouseCallBack* PrismObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL PrismObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_SIDE1,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL PrismObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL PrismObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_SIDE1: crtSide1 = v; break;
		case PB_TI_SIDE2: crtSide2 = v; break;
		case PB_TI_SIDE3: crtSide3 = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL PrismObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL PrismObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL PrismObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_SIDE1: v = crtSide1; break;
		case PB_TI_SIDE2: v = crtSide2; break;
		case PB_TI_SIDE3: v = crtSide3; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL PrismObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void PrismObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *PrismObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDE1: return stdWorldDim;
		case PB_SIDE2: return stdWorldDim;
		case PB_SIDE3: return stdWorldDim;
		case PB_HEIGHT: return stdWorldDim;
		case PB_S1SEGS: return stdSegmentsDim;
		case PB_S2SEGS: return stdSegmentsDim;
		case PB_S3SEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR PrismObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDE1: return TSTR(GetString(IDS_RB_SIDE1));
		case PB_SIDE2: return TSTR(GetString(IDS_RB_SIDE2));
		case PB_SIDE3: return TSTR(GetString(IDS_RB_SIDE3));
